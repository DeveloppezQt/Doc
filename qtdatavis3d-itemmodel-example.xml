<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Item Model Example</db:title>
<db:productname>QtDataVis3D</db:productname>
<db:edition>Qt Data Visualization | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Using an item model as data source for <db:link xlink:href="q3dbars.xml">Q3DBars</db:link>.</db:para>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The item model example shows how to make a simple 3D bar graph using <db:link xlink:href="q3dbars.xml">Q3DBars</db:link> and how to modify the data being drawn at run-time. The example shows how to:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Create an application with <db:link xlink:href="q3dbars.xml">Q3DBars</db:link> and widgets</db:para>
</db:listitem>
<db:listitem>
<db:para>Use <db:link xlink:href="qitemmodelbardataproxy.xml">QItemModelBarDataProxy</db:link> to set data to the graph</db:para>
</db:listitem>
<db:listitem>
<db:para>Use a table widget to modify the data in the graph</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For instructions about how to interact with the graph, see <db:link xlink:href="qtdatavisualization-interacting-with-data.xml">this page</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/itemmodel-example-2.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:guilabel>Welcome</db:guilabel> mode and select the example from <db:guilabel>Examples</db:guilabel>. For more information, visit <db:link xlink:href="https://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="creating-the-application">
<db:title>Creating the Application</db:title>
<db:para>First, in main.cpp, we create a <db:link xlink:href="qapplication.xml">QApplication</db:link>, instantiate <db:link xlink:href="q3dbars.xml">Q3DBars</db:link> and a window container for it:</db:para>
<db:programlisting language="cpp">QApplication app(argc, argv);
Q3DBars *graph = new Q3DBars();
QWidget *container = QWidget::createWindowContainer(graph);
</db:programlisting>
<db:para>The call to <db:link xlink:href="qwidget.xml#createWindowContainer">QWidget::createWindowContainer</db:link> is required, as all data visualization graph classes (<db:link xlink:href="q3dbars.xml">Q3DBars</db:link>, <db:link xlink:href="q3dscatter.xml">Q3DScatter</db:link>, and <db:link xlink:href="q3dsurface.xml">Q3DSurface</db:link>) inherit <db:link xlink:href="qwindow.xml">QWindow</db:link>. Any class inheriting <db:link xlink:href="qwindow.xml">QWindow</db:link> cannot be used as a widget any other way.</db:para>
<db:para>Then we'll create a layout and add the graph and the table widget into it:</db:para>
<db:programlisting language="cpp">QWidget widget;
QVBoxLayout *layout = new QVBoxLayout(&amp;amp;widget);
QTableWidget *tableWidget = new QTableWidget(&amp;amp;widget);
layout-&amp;gt;addWidget(container, 1);
layout-&amp;gt;addWidget(tableWidget, 1, Qt::AlignHCenter);
</db:programlisting>
<db:para>The table widget is going to be used to display the numerical data being inserted into the graph, and to modify it (See <db:link xlink:href="qtdatavis3d-scatter-example.xml#adding-data-to-the-graph">Adding data to the graph</db:link> and <db:link xlink:href="qtdatavis3d-itemmodel-example.xml#interacting-with-the-data">Interacting with the data</db:link>).</db:para>
<db:para>We need to instantiate <db:link xlink:href="qitemmodelbardataproxy.xml">QItemModelBarDataProxy</db:link> and a <db:link xlink:href="qbar3dseries.xml">QBar3DSeries</db:link> for it, and give the series to the graph:</db:para>
<db:programlisting language="cpp">// Since we are dealing with QTableWidget, the model will already have data sorted properly
// into rows and columns, so we simply set useModelCategories property to true to utilize this.
QItemModelBarDataProxy *proxy = new QItemModelBarDataProxy(tableWidget-&amp;gt;model());
proxy-&amp;gt;setUseModelCategories(true);
QBar3DSeries *series = new QBar3DSeries(proxy);
series-&amp;gt;setMesh(QAbstract3DSeries::MeshPyramid);
graph-&amp;gt;addSeries(series);
</db:programlisting>
<db:para>Here we tell the proxy to directly map the model's rows and columns into the proxy's rows and columns instead of defining row and column roles to map for them. Then we give the model from the table widget to the proxy. We also create a series instance and set the proxy to it. We customize the series visuals a bit by changing the object mesh to pyramids, and finally add the series to the graph.</db:para>
<db:para>Next, let's create another class to handle the data addition and other interaction with the graph. Let's call it <db:code>GraphDataGenerator</db:code> (See <db:link xlink:href="qtdatavis3d-scatter-example.xml#setting-up-the-graph">Setting up the graph</db:link> and <db:link xlink:href="qtdatavis3d-scatter-example.xml#adding-data-to-the-graph">Adding data to the graph</db:link> for details) and connect some signals between <db:link xlink:href="qbar3dseries.xml">QBar3DSeries</db:link>, <db:code>GraphDataGenerator</db:code>, and <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link> (See <db:link xlink:href="qtdatavis3d-itemmodel-example.xml#interacting-with-the-data">Interacting with the data</db:link> for a closer look):</db:para>
<db:programlisting language="cpp">GraphDataGenerator generator(graph, tableWidget);
QObject::connect(series, &amp;amp;QBar3DSeries::selectedBarChanged, &amp;amp;generator,
                 &amp;amp;GraphDataGenerator::selectFromTable);
QObject::connect(tableWidget, &amp;amp;QTableWidget::currentCellChanged, &amp;amp;generator,
                 &amp;amp;GraphDataGenerator::selectedFromTable);
</db:programlisting>
<db:para>The application main is done and we can show the graph and start the event loop:</db:para>
<db:programlisting language="cpp">widget.show();
generator.start();
return app.exec();
</db:programlisting>
</db:section>
<db:section xml:id="setting-up-the-graph">
<db:title>Setting up the Graph</db:title>
<db:para>Let's set up the visual attributes for the graph in the constructor of <db:code>GraphDataGenerator</db:code>:</db:para>
<db:programlisting language="cpp">// Set up bar specifications; make the bars as wide as they are deep,
// and add a small space between them
m_graph-&amp;gt;setBarThickness(1.0f);
m_graph-&amp;gt;setBarSpacing(QSizeF(0.2, 0.2));

// Set selection mode to slice row
m_graph-&amp;gt;setSelectionMode(QAbstract3DGraph::SelectionItemAndRow | QAbstract3DGraph::SelectionSlice);

// Set theme
m_graph-&amp;gt;activeTheme()-&amp;gt;setType(Q3DTheme::ThemeDigia);

// Set font
QFont font = QFont(&quot;Impact&quot;, 20);
font.setStyleHint(QFont::SansSerif);
m_graph-&amp;gt;activeTheme()-&amp;gt;setFont(font);

// Set preset camera position
m_graph-&amp;gt;scene()-&amp;gt;activeCamera()-&amp;gt;setCameraPreset(Q3DCamera::CameraPresetFront);
</db:programlisting>
<db:para>First we set bar thickness ratio to 1.0, which means bars will be as wide as they are deep. 1.0 is also the default value, so the line is basically unnecessary. It's left there so you could easily try how changing it affects the graph. The second line sets bar spacings to 0.2, which means there will be a gap of 20% of the bar's thickness between the bars in both directions.</db:para>
<db:para>We want to be able to select rows of data for a closer inspection, so we set the selection mode to slice item and row. This means that whenever we select a bar in the graph, the whole row will be displayed separately and the selected bar will be highlighted.</db:para>
<db:para>We don't want to use the default colors, so we set one of the predefined themes as the active theme.</db:para>
<db:para>Next line sets the font to <db:code>Impact</db:code>. If your system doesn't have it, it will be replaced by the system default.</db:para>
<db:para>And finally, we set the camera position to one of the predefined camera positions. Now the initial graph settings are done.</db:para>
<db:note>
<db:para>You do not need to set any of these in case you're happy with the defaults. You can easily try them by commenting out the contents of the constructor.</db:para>
</db:note>
</db:section>
<db:section xml:id="adding-data-to-the-graph">
<db:title>Adding Data to the Graph</db:title>
<db:para>We created the data generator in the application main and gave it the graph and the table widget as parameters:</db:para>
<db:programlisting language="cpp">GraphDataGenerator generator(graph, tableWidget);
</db:programlisting>
<db:para>We added a separate start method to the generator, so that it wouldn't start doing anything until everything else is set up. We then called the method when starting the application:</db:para>
<db:programlisting language="cpp">generator.start();
</db:programlisting>
<db:para>Let's have a look at the contents of the <db:code>start()</db:code> method:</db:para>
<db:programlisting language="cpp">setupModel();

// Table needs to be shown before the size of its headers can be accurately obtained,
// so we postpone it a bit
m_dataTimer = new QTimer();
m_dataTimer-&amp;gt;setSingleShot(true);
QObject::connect(m_dataTimer, &amp;amp;QTimer::timeout, this, &amp;amp;GraphDataGenerator::fixTableSize);
m_dataTimer-&amp;gt;start(0);
</db:programlisting>
<db:para>The main thing <db:code>start()</db:code> does is set up the data model. It also activates a timer for getting the accurate dimensions of the table widget after it's been filled with data. The reason we do this is that the widget doesn't know its final visual domensions until all the data has been inserted to it and it has been shown. The data timer usage is not vital for the application, so we won't take a closer look at it. It's just there to make <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link> look better.</db:para>
<db:para>In <db:code>setupModel()</db:code> we first introduce the row and column labels, and the actual data:</db:para>
<db:programlisting language="cpp">// Set up row and column names
QStringList days;
days &amp;lt;&amp;lt; &quot;Monday&quot; &amp;lt;&amp;lt; &quot;Tuesday&quot; &amp;lt;&amp;lt; &quot;Wednesday&quot; &amp;lt;&amp;lt; &quot;Thursday&quot; &amp;lt;&amp;lt; &quot;Friday&quot; &amp;lt;&amp;lt; &quot;Saturday&quot; &amp;lt;&amp;lt; &quot;Sunday&quot;;
QStringList weeks;
weeks &amp;lt;&amp;lt; &quot;week 1&quot; &amp;lt;&amp;lt; &quot;week 2&quot; &amp;lt;&amp;lt; &quot;week 3&quot; &amp;lt;&amp;lt; &quot;week 4&quot; &amp;lt;&amp;lt; &quot;week 5&quot;;

// Set up data         Mon  Tue  Wed  Thu  Fri  Sat  Sun
float hours[5][7] = {{2.0f, 1.0f, 3.0f, 0.2f, 1.0f, 5.0f, 10.0f},     // week 1
                     {0.5f, 1.0f, 3.0f, 1.0f, 2.0f, 2.0f, 3.0f},      // week 2
                     {1.0f, 1.0f, 2.0f, 1.0f, 4.0f, 4.0f, 4.0f},      // week 3
                     {0.0f, 1.0f, 0.0f, 0.0f, 2.0f, 2.0f, 0.3f},      // week 4
                     {3.0f, 3.0f, 6.0f, 2.0f, 2.0f, 1.0f, 1.0f}};     // week 5
</db:programlisting>
<db:para>Then we set up the axes:</db:para>
<db:programlisting language="cpp">m_graph-&amp;gt;rowAxis()-&amp;gt;setTitle(&quot;Week of year&quot;);
m_graph-&amp;gt;rowAxis()-&amp;gt;setTitleVisible(true);
m_graph-&amp;gt;columnAxis()-&amp;gt;setTitle(&quot;Day of week&quot;);
m_graph-&amp;gt;columnAxis()-&amp;gt;setTitleVisible(true);
m_graph-&amp;gt;valueAxis()-&amp;gt;setTitle(&quot;Hours spent on the Internet&quot;);
m_graph-&amp;gt;valueAxis()-&amp;gt;setTitleVisible(true);
m_graph-&amp;gt;valueAxis()-&amp;gt;setLabelFormat(&quot;%.1f h&quot;);
</db:programlisting>
<db:para>Next we will set up the table widget:</db:para>
<db:programlisting language="cpp">m_tableWidget-&amp;gt;setRowCount(5);
m_tableWidget-&amp;gt;setColumnCount(7);
m_tableWidget-&amp;gt;setHorizontalHeaderLabels(days);
m_tableWidget-&amp;gt;setVerticalHeaderLabels(weeks);
m_tableWidget-&amp;gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
m_tableWidget-&amp;gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
m_tableWidget-&amp;gt;setCurrentCell(-1, -1);
m_tableWidget-&amp;gt;setSelectionMode(QAbstractItemView::SingleSelection);
</db:programlisting>
<db:para>After that all that's left is adding the data to the table widget:</db:para>
<db:programlisting language="cpp">for (int week = 0; week &amp;lt; weeks.size(); week++) {
    for (int day = 0; day &amp;lt; days.size(); day++) {
        QModelIndex index = m_tableWidget-&amp;gt;model()-&amp;gt;index(week, day);
        m_tableWidget-&amp;gt;model()-&amp;gt;setData(index, hours[week][day]);
    }
}
</db:programlisting>
<db:para>Now we have a bar graph and a table widget, both displaying the same data.</db:para>
<db:para>You're probably wondering how the data can be displayed in the graph, as the only thing we did was add it to the table widget? That's because of what we did earlier, in the application main:</db:para>
<db:programlisting language="cpp">// Since we are dealing with QTableWidget, the model will already have data sorted properly
// into rows and columns, so we simply set useModelCategories property to true to utilize this.
QItemModelBarDataProxy *proxy = new QItemModelBarDataProxy(tableWidget-&amp;gt;model());
proxy-&amp;gt;setUseModelCategories(true);
QBar3DSeries *series = new QBar3DSeries(proxy);
series-&amp;gt;setMesh(QAbstract3DSeries::MeshPyramid);
graph-&amp;gt;addSeries(series);
</db:programlisting>
<db:para>We created <db:link xlink:href="qitemmodelbardataproxy.xml">QItemModelBarDataProxy</db:link> instance, and gave the proxy the model of the table widget we just created. The proxy maps the rows and the columns in the model of the table widget into rows and columns for itself directly, as we set the <db:link xlink:href="qitemmodelbardataproxy.xml#useModelCategories-prop">QItemModelBarDataProxy::useModelCategories</db:link> property to true, and the graph gets the data to be displayed via the series that owns the proxy.</db:para>
</db:section>
<db:section xml:id="interacting-with-the-data">
<db:title>Interacting with the Data</db:title>
<db:para>We made a couple of signal connections in the application main earlier:</db:para>
<db:programlisting language="cpp">GraphDataGenerator generator(graph, tableWidget);
QObject::connect(series, &amp;amp;QBar3DSeries::selectedBarChanged, &amp;amp;generator,
                 &amp;amp;GraphDataGenerator::selectFromTable);
QObject::connect(tableWidget, &amp;amp;QTableWidget::currentCellChanged, &amp;amp;generator,
                 &amp;amp;GraphDataGenerator::selectedFromTable);
</db:programlisting>
<db:para>Now we'll find out what these were for.</db:para>
<db:para>The first one connects a signal from <db:link xlink:href="q3dbars.xml">Q3DBars</db:link> to the <db:code>GraphDataGenerator</db:code>. Signal <db:link xlink:href="qbar3dseries.xml#selectedBar-prop">QBar3DSeries::selectedBarChanged</db:link>() is emitted when a bar is selected from the series. We connect that to a method in the data generator that selects the same data item in the table widget:</db:para>
<db:programlisting language="cpp">void GraphDataGenerator::selectFromTable(const QPoint &amp;amp;selection)
{
    m_tableWidget-&amp;gt;setFocus();
    m_tableWidget-&amp;gt;setCurrentCell(selection.x(), selection.y());
}
</db:programlisting>
<db:para>The second connection does the opposite; it connects a signal from the table widget to a method in the data generator. The method then selects the corresponding bar in the series:</db:para>
<db:programlisting language="cpp">void GraphDataGenerator::selectedFromTable(int currentRow, int currentColumn,
                                           int previousRow, int previousColumn)
{
    Q_UNUSED(previousRow);
    Q_UNUSED(previousColumn);
    m_graph-&amp;gt;seriesList().at(0)-&amp;gt;setSelectedBar(QPoint(currentRow, currentColumn));
}
</db:programlisting>
<db:para>You can even select an item in the widget and change the value of it, and the new value is updated to the graph. This is handled again by the proxy with mapping between the data in the table widget and itself.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/itemmodel-example.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
<db:section xml:id="example-contents">
<db:title>Example Contents</db:title>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtdatavis3d.git/tree/examples/datavisualization/itemmodel?h=6.4">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:section>
</db:article>
