<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QOpenGLFramebufferObject Class</db:title>
<db:productname>QtGui</db:productname>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link> class encapsulates an OpenGL framebuffer object.</db:para>
<db:para>This class was introduced in Qt 5.0.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QOpenGLFramebufferObject</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QOpenGLFramebufferObject is part of <db:simplelist><db:member><db:link xlink:href="painting-3d.xml">Rendering in 3D</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link> class encapsulates an OpenGL framebuffer object, defined by the <db:code>GL_EXT_framebuffer_object</db:code> extension. It provides a rendering surface that can be painted on with a <db:link xlink:href="qpainter.xml">QPainter</db:link> with the help of <db:link xlink:href="qopenglpaintdevice.xml">QOpenGLPaintDevice</db:link>, or rendered to using native OpenGL calls. This surface can be bound and used as a regular texture in your own OpenGL drawing code. By default, the <db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link> class generates a 2D OpenGL texture (using the <db:code>GL_TEXTURE_2D</db:code> target), which is used as the internal rendering target.</db:para>
<db:para><db:emphasis role="bold">It is important to have a current OpenGL context when creating a <db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link>, otherwise initialization will fail.</db:emphasis></db:para>
<db:para>Create the QOpenGLFrameBufferObject instance with the <db:link xlink:href="qopenglframebufferobject.xml#Attachment-enum">CombinedDepthStencil</db:link> attachment if you want <db:link xlink:href="qpainter.xml">QPainter</db:link> to render correctly. Note that you need to create a <db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link> with more than one sample per pixel for primitives to be antialiased when drawing using a <db:link xlink:href="qpainter.xml">QPainter</db:link>. To create a multisample framebuffer object you should use one of the constructors that take a <db:link xlink:href="qopenglframebufferobjectformat.xml">QOpenGLFramebufferObjectFormat</db:link> parameter, and set the <db:link xlink:href="qopenglframebufferobjectformat.xml#samples">QOpenGLFramebufferObjectFormat::samples</db:link>() property to a non-zero value.</db:para>
<db:para>For multisample framebuffer objects a color render buffer is created, otherwise a texture with the specified texture target is created. The color render buffer or texture will have the specified internal format, and will be bound to the <db:code>GL_COLOR_ATTACHMENT0</db:code> attachment in the framebuffer object.</db:para>
<db:para>If you want to use a framebuffer object with multisampling enabled as a texture, you first need to copy from it to a regular framebuffer object using QOpenGLContext::blitFramebuffer().</db:para>
<db:para>It is possible to draw into a <db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link> using <db:link xlink:href="qpainter.xml">QPainter</db:link> and <db:link xlink:href="qopenglpaintdevice.xml">QOpenGLPaintDevice</db:link> in a separate thread.</db:para>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Attachment-enum">
<db:title>enum QOpenGLFramebufferObject::Attachment</db:title>
<db:para>This enum type is used to configure the depth and stencil buffers attached to the framebuffer object when it is created.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link></db:emphasis>::NoAttachment</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>No attachment is added to the framebuffer object. Note that the OpenGL depth and stencil tests won't work when rendering to a framebuffer object without any depth or stencil buffers. This is the default value.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link></db:emphasis>::CombinedDepthStencil</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>If the <db:code>GL_EXT_packed_depth_stencil</db:code> extension is present, a combined depth and stencil buffer is attached. If the extension is not present, only a depth buffer is attached.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link></db:emphasis>::Depth</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>A depth buffer is attached to the framebuffer object.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglframebufferobject.xml#attachment">attachment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QOpenGLFramebufferObject">
<db:title>[explicit] QOpenGLFramebufferObject::QOpenGLFramebufferObject(const QSize &amp;<db:emphasis>size</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>Constructs an OpenGL framebuffer object and binds a 2D OpenGL texture to the buffer of the size <db:code role="parameter">size</db:code>. The texture is bound to the <db:code>GL_COLOR_ATTACHMENT0</db:code> target in the framebuffer object.</db:para>
<db:para>The <db:code role="parameter">target</db:code> parameter is used to specify the OpenGL texture target. The default target is <db:code>GL_TEXTURE_2D</db:code>. Keep in mind that <db:code>GL_TEXTURE_2D</db:code> textures must have a power of 2 width and height (e.g. 256x512), unless you are using OpenGL 2.0 or higher.</db:para>
<db:para>By default, no depth and stencil buffers are attached. This behavior can be toggled using one of the overloaded constructors.</db:para>
<db:para>The default internal texture format is <db:code>GL_RGBA8</db:code> for desktop OpenGL, and <db:code>GL_RGBA</db:code> for OpenGL/ES.</db:para>
<db:para>It is important that you have a current OpenGL context set when creating the <db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link>, otherwise the initialization will fail.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglframebufferobject.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglframebufferobject.xml#texture">texture</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglframebufferobject.xml#attachment">attachment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QOpenGLFramebufferObject-2">
<db:title>QOpenGLFramebufferObject::QOpenGLFramebufferObject(const QSize &amp;<db:emphasis>size</db:emphasis>, const QOpenGLFramebufferObjectFormat &amp;<db:emphasis>format</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs an OpenGL framebuffer object of the given <db:code role="parameter">size</db:code> based on the supplied <db:code role="parameter">format</db:code>.</db:para>
</db:section>
<db:section xml:id="QOpenGLFramebufferObject-3">
<db:title>QOpenGLFramebufferObject::QOpenGLFramebufferObject(int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs an OpenGL framebuffer object and binds a 2D OpenGL texture to the buffer of the given <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglframebufferobject.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglframebufferobject.xml#texture">texture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QOpenGLFramebufferObject-4">
<db:title>QOpenGLFramebufferObject::QOpenGLFramebufferObject(int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, const QOpenGLFramebufferObjectFormat &amp;<db:emphasis>format</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs an OpenGL framebuffer object of the given <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code> based on the supplied <db:code role="parameter">format</db:code>.</db:para>
</db:section>
<db:section xml:id="QOpenGLFramebufferObject-5">
<db:title>QOpenGLFramebufferObject::QOpenGLFramebufferObject(const QSize &amp;<db:emphasis>size</db:emphasis>, QOpenGLFramebufferObject::Attachment <db:emphasis>attachment</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D, GLenum <db:emphasis>internal_format</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given <db:code role="parameter">size</db:code>.</db:para>
<db:para>The <db:code role="parameter">attachment</db:code> parameter describes the depth/stencil buffer configuration, <db:code role="parameter">target</db:code> the texture target and <db:code role="parameter">internal_format</db:code> the internal texture format. The default texture target is <db:code>GL_TEXTURE_2D</db:code>, while the default internal format is <db:code>GL_RGBA8</db:code> for desktop OpenGL and <db:code>GL_RGBA</db:code> for OpenGL/ES.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglframebufferobject.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglframebufferobject.xml#texture">texture</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglframebufferobject.xml#attachment">attachment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QOpenGLFramebufferObject-6">
<db:title>QOpenGLFramebufferObject::QOpenGLFramebufferObject(int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, QOpenGLFramebufferObject::Attachment <db:emphasis>attachment</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D, GLenum <db:emphasis>internal_format</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code>.</db:para>
<db:para>The <db:code role="parameter">attachment</db:code> parameter describes the depth/stencil buffer configuration, <db:code role="parameter">target</db:code> the texture target and <db:code role="parameter">internal_format</db:code> the internal texture format. The default texture target is <db:code>GL_TEXTURE_2D</db:code>, while the default internal format is <db:code>GL_RGBA8</db:code> for desktop OpenGL and <db:code>GL_RGBA</db:code> for OpenGL/ES.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglframebufferobject.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglframebufferobject.xml#texture">texture</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglframebufferobject.xml#attachment">attachment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QOpenGLFramebufferObject">
<db:title>[virtual noexcept] QOpenGLFramebufferObject::~QOpenGLFramebufferObject()</db:title>
<db:para>Destroys the framebuffer object and frees any allocated resources.</db:para>
</db:section>
<db:section xml:id="attachment">
<db:title>QOpenGLFramebufferObject::Attachment QOpenGLFramebufferObject::attachment() const</db:title>
<db:para>Returns the status of the depth and stencil buffers attached to this framebuffer object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglframebufferobject.xml#setAttachment">setAttachment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bind">
<db:title>bool QOpenGLFramebufferObject::bind()</db:title>
<db:para>Switches rendering from the default, windowing system provided framebuffer to this framebuffer object. Returns true upon success, false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglframebufferobject.xml#release">release</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blitFramebuffer">
<db:title>[static] void QOpenGLFramebufferObject::blitFramebuffer(QOpenGLFramebufferObject *<db:emphasis>target</db:emphasis>, const QRect &amp;<db:emphasis>targetRect</db:emphasis>, QOpenGLFramebufferObject *<db:emphasis>source</db:emphasis>, const QRect &amp;<db:emphasis>sourceRect</db:emphasis>, GLbitfield <db:emphasis>buffers</db:emphasis> = GL_COLOR_BUFFER_BIT, GLenum <db:emphasis>filter</db:emphasis> = GL_NEAREST)</db:title>
<db:para>Blits from the <db:code role="parameter">sourceRect</db:code> rectangle in the <db:code role="parameter">source</db:code> framebuffer object to the <db:code role="parameter">targetRect</db:code> rectangle in the <db:code role="parameter">target</db:code> framebuffer object.</db:para>
<db:para>If <db:code role="parameter">source</db:code> or <db:code role="parameter">target</db:code> is 0, the default framebuffer will be used instead of a framebuffer object as source or target respectively.</db:para>
<db:para>The <db:code role="parameter">buffers</db:code> parameter should be a mask consisting of any combination of <db:code>GL_COLOR_BUFFER_BIT</db:code>, <db:code>GL_DEPTH_BUFFER_BIT</db:code>, and <db:code>GL_STENCIL_BUFFER_BIT</db:code>. Any buffer type that is not present both in the source and target buffers is ignored.</db:para>
<db:para>The <db:code role="parameter">sourceRect</db:code> and <db:code role="parameter">targetRect</db:code> rectangles may have different sizes; in this case <db:code role="parameter">buffers</db:code> should not contain <db:code>GL_DEPTH_BUFFER_BIT</db:code> or <db:code>GL_STENCIL_BUFFER_BIT</db:code>. The <db:code role="parameter">filter</db:code> parameter should be set to <db:code>GL_LINEAR</db:code> or <db:code>GL_NEAREST</db:code>, and specifies whether linear or nearest interpolation should be used when scaling is performed.</db:para>
<db:para>If <db:code role="parameter">source</db:code> equals <db:code role="parameter">target</db:code> a copy is performed within the same buffer. Results are undefined if the source and target rectangles overlap and have different sizes. The sizes must also be the same if any of the framebuffer objects are multisample framebuffers.</db:para>
<db:para>Note that the scissor test will restrict the blit area if enabled.</db:para>
<db:para>This function will have no effect unless <db:link xlink:href="qopenglframebufferobject.xml#hasOpenGLFramebufferBlit">hasOpenGLFramebufferBlit</db:link>() returns true.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglframebufferobject.xml#hasOpenGLFramebufferBlit">hasOpenGLFramebufferBlit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blitFramebuffer-1">
<db:title>[static] void QOpenGLFramebufferObject::blitFramebuffer(QOpenGLFramebufferObject *<db:emphasis>target</db:emphasis>, QOpenGLFramebufferObject *<db:emphasis>source</db:emphasis>, GLbitfield <db:emphasis>buffers</db:emphasis> = GL_COLOR_BUFFER_BIT, GLenum <db:emphasis>filter</db:emphasis> = GL_NEAREST)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Convenience overload to blit between two framebuffer objects.</db:para>
</db:section>
<db:section xml:id="format">
<db:title>QOpenGLFramebufferObjectFormat QOpenGLFramebufferObject::format() const</db:title>
<db:para>Returns the format of this framebuffer object.</db:para>
</db:section>
<db:section xml:id="handle">
<db:title>GLuint QOpenGLFramebufferObject::handle() const</db:title>
<db:para>Returns the OpenGL framebuffer object handle for this framebuffer object (returned by the <db:code>glGenFrameBuffersEXT()</db:code> function). This handle can be used to attach new images or buffers to the framebuffer. The user is responsible for cleaning up and destroying these objects.</db:para>
</db:section>
<db:section xml:id="hasOpenGLFramebufferBlit">
<db:title>[static] bool QOpenGLFramebufferObject::hasOpenGLFramebufferBlit()</db:title>
<db:para>Returns true if the OpenGL <db:code>GL_EXT_framebuffer_blit</db:code> extension is present on this system; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglframebufferobject.xml#blitFramebuffer">blitFramebuffer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasOpenGLFramebufferObjects">
<db:title>[static] bool QOpenGLFramebufferObject::hasOpenGLFramebufferObjects()</db:title>
<db:para>Returns true if the OpenGL <db:code>GL_EXT_framebuffer_object</db:code> extension is present on this system; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="height">
<db:title>int QOpenGLFramebufferObject::height() const</db:title>
<db:para>Returns the height of the framebuffer object attachments.</db:para>
</db:section>
<db:section xml:id="isBound">
<db:title>bool QOpenGLFramebufferObject::isBound() const</db:title>
<db:para>Returns true if the framebuffer object is currently bound to a context, otherwise false is returned.</db:para>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QOpenGLFramebufferObject::isValid() const</db:title>
<db:para>Returns true if the framebuffer object is valid.</db:para>
<db:para>The framebuffer can become invalid if the initialization process fails, the user attaches an invalid buffer to the framebuffer object, or a non-power of two width/height is specified as the texture size if the texture target is <db:code>GL_TEXTURE_2D</db:code>. The non-power of two limitation does not apply if the OpenGL version is 2.0 or higher, or if the GL_ARB_texture_non_power_of_two extension is present.</db:para>
<db:para>The framebuffer can also become invalid if the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> that the framebuffer was created within is destroyed and there are no other shared contexts that can take over ownership of the framebuffer.</db:para>
</db:section>
<db:section xml:id="release">
<db:title>bool QOpenGLFramebufferObject::release()</db:title>
<db:para>Switches rendering back to the default, windowing system provided framebuffer. Returns true upon success, false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglframebufferobject.xml#bind">bind</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAttachment">
<db:title>void QOpenGLFramebufferObject::setAttachment(QOpenGLFramebufferObject::Attachment <db:emphasis>attachment</db:emphasis>)</db:title>
<db:para>Sets the attachments of the framebuffer object to <db:code role="parameter">attachment</db:code>.</db:para>
<db:para>This can be used to free or reattach the depth and stencil buffer attachments as needed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglframebufferobject.xml#attachment">attachment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>QSize QOpenGLFramebufferObject::size() const</db:title>
<db:para>Returns the size of the texture attached to this framebuffer object.</db:para>
</db:section>
<db:section xml:id="texture">
<db:title>GLuint QOpenGLFramebufferObject::texture() const</db:title>
<db:para>Returns the texture id for the texture attached as the default rendering target in this framebuffer object. This texture id can be bound as a normal texture in your own OpenGL code.</db:para>
<db:para>If a multisample framebuffer object is used then the value returned from this function will be invalid.</db:para>
</db:section>
<db:section xml:id="toImage">
<db:title>QImage QOpenGLFramebufferObject::toImage() const</db:title>
<db:para>Returns the contents of this framebuffer object as a <db:link xlink:href="qimage.xml">QImage</db:link>.</db:para>
</db:section>
<db:section xml:id="width">
<db:title>int QOpenGLFramebufferObject::width() const</db:title>
<db:para>Returns the width of the framebuffer object attachments.</db:para>
</db:section>
</db:section>
</db:article>
