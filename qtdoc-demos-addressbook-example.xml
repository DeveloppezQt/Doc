<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Quick Demo - RESTful API client Address Book</db:title>
<db:productname>QtDoc</db:productname>
<db:edition>Qt 6.4.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Example of how to create a RESTful API client.</db:para>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbookclient.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>This example shows how to create a basic QML application with address book functionality. The application uses RESTful communication with a given server to send requests and retrieve data.</db:para>
<db:para>The application allows users to add new contacts by clicking the 'Add Contact' button and then entering the data for the record and clicking the 'Add' button (see image below).</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/newcontact.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The Address Book application gives you the ability to delete an entry, by clicking the 'Delete' button next to the entry, and update by updating the data in the table.</db:para>
<db:para>In order to use the modification features, users must authorize themselves by providing a key and value, which will be used in communication with the RESTful API.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/authorize.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>To run the client application, first run the <db:link xlink:href="qthttpserver-addressbookserver-example.xml">Address Book server example</db:link> in the background or use an already running server that provides used API. Then run the client application, to run it host and port arguments must be provided, for example:</db:para>
<db:programlisting language="cpp">./addressbookclient  --host http://127.0.0.1 --port 62122
</db:programlisting>
<db:para>This example application uses <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> which is wrapped in the RestAccessManager class.</db:para>
<db:programlisting language="cpp">manager.connectToHost(host, port);
manager.setAutoDeleteReplies(true);
QObject::connect(&amp;amp;manager, &amp;amp;QNetworkAccessManager::finished, this,
                 &amp;amp;RestAccessManager::readContacts);
</db:programlisting>
<db:para>The code snippet above shows how to connect <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> to this wrapper. First, a connection to the server is established and the <db:link xlink:href="qnetworkaccessmanager.xml#setAutoDeleteReplies">QNetworkAccessManager::setAutoDeleteReplies</db:link> method is called to simplify the <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> deletion. Then <db:link xlink:href="qobject.xml#connect">QObject::connect</db:link> is used to call the internal RestAccessManager::readContacts after the <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> is ready to be processed.</db:para>
<db:programlisting language="cpp">void RestAccessManager::readContacts(QNetworkReply *reply)
{
    if (reply-&amp;gt;error()) {
        return;
    }
    const std::optional&amp;lt;QJsonArray&amp;gt; array = byteArrayToJsonArray(reply-&amp;gt;readAll());
    if (array) {
        ContactsMap tmpContacts;
        for (const auto &amp;amp;jsonValue : *array) {
            if (jsonValue.isObject()) {
                const QJsonObject obj = jsonValue.toObject();
                if (obj.contains(&quot;id&quot;) &amp;amp;&amp;amp; obj.contains(&quot;name&quot;) &amp;amp;&amp;amp; obj.contains(&quot;address&quot;)) {
                    tmpContacts.insert(obj.value(&quot;id&quot;).toInt(),
                                       ContactEntry{ obj.value(&quot;id&quot;).toInt(),
                                                     obj.value(&quot;name&quot;).toString(),
                                                     obj.value(&quot;address&quot;).toString() });
                }
            }
        }
        {
            QMutexLocker lock(&amp;amp;contactsMtx);
            contacts.swap(tmpContacts);
        }
        emit contactsChanged();
    } else {
        this-&amp;gt;updateContacts();
    }
}
</db:programlisting>
<db:para>This method asynchronously processes each <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> for each request sent via <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>. When the response is an array, that practically means that RestAccessManage got a new list of the contacts, so it has to update it. When the response is different, it means that the corresponding request has changed the list of contacts and it needs to be retrieved from the server.</db:para>
<db:programlisting language="cpp">void RestAccessManager::updateContacts()
{
    auto request = QNetworkRequest(QUrl(QString(&quot;%1:%2/v2/contact&quot;).arg(host).arg(port)));
    request.setHeader(QNetworkRequest::KnownHeaders::ContentTypeHeader, &quot;application/json&quot;);
    manager.get(request);
}
</db:programlisting>
<db:para>To send a GET request, the <db:link xlink:href="qnetworkaccessmanager.xml#get">QNetworkAccessManager::get</db:link> method is used with the prepared <db:link xlink:href="qnetworkrequest.xml">QNetworkRequest</db:link>. <db:link xlink:href="qnetworkrequest.xml#setHeader">QNetworkRequest::setHeader</db:link> is used to ensure correct encoding of the content.</db:para>
<db:programlisting language="cpp">void RestAccessManager::addContact(const ContactEntry &amp;amp;entry)
{
    auto request = QNetworkRequest(QUrl(QString(&quot;%1:%2/v2/contact&quot;).arg(host).arg(port)));
    request.setHeader(QNetworkRequest::KnownHeaders::ContentTypeHeader, &quot;application/json&quot;);
    if (authHeader) {
        request.setRawHeader(authHeader-&amp;gt;key.toLatin1(), authHeader-&amp;gt;value.toLatin1());
    }
    manager.post(request, QJsonDocument(entry.toJson()).toJson(QJsonDocument::Compact));
}
</db:programlisting>
<db:para>To send the POST request, a similar approach can be used. In addition, to set the authorization header <db:link xlink:href="qnetworkrequest.xml#setRawHeader">QNetworkRequest::setRawHeader</db:link> was used.</db:para>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtdoc.git/tree/examples/demos/addressbook?h=6.4">Example project @ code.qt.io</db:link></db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qthttpserver-addressbookserver-example.xml">RESTful server Address Book Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
