<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Plug &amp; Paint Basic Tools Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Widgets Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** You may use this file under the terms of the BSD license as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names
**     of its contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &lt;QtWidgets&gt;

#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;basictoolsplugin.h&quot;

const float Pi = 3.14159f;

QStringList BasicToolsPlugin::brushes() const
{
    return QStringList() &lt;&lt; tr(&quot;Pencil&quot;) &lt;&lt; tr(&quot;Air Brush&quot;)
                         &lt;&lt; tr(&quot;Random Letters&quot;);
}

QRect BasicToolsPlugin::mousePress(const QString &amp;brush, QPainter &amp;painter,
                                   const QPoint &amp;pos)
{
    return mouseMove(brush, painter, pos, pos);
}

QRect BasicToolsPlugin::mouseMove(const QString &amp;brush, QPainter &amp;painter,
                                  const QPoint &amp;oldPos, const QPoint &amp;newPos)
{
    painter.save();

    int rad = painter.pen().width() / 2;
    QRect boundingRect = QRect(oldPos, newPos).normalized()
                                              .adjusted(-rad, -rad, +rad, +rad);
    QColor color = painter.pen().color();
    int thickness = painter.pen().width();
    QColor transparentColor(color.red(), color.green(), color.blue(), 0);

    if (brush == tr(&quot;Pencil&quot;)) {
        painter.drawLine(oldPos, newPos);
    } else if (brush == tr(&quot;Air Brush&quot;)) {
        int numSteps = 2 + (newPos - oldPos).manhattanLength() / 2;

        painter.setBrush(QBrush(color, Qt::Dense6Pattern));
        painter.setPen(Qt::NoPen);

        for (int i = 0; i &lt; numSteps; ++i) {
            int x = oldPos.x() + i * (newPos.x() - oldPos.x()) / (numSteps - 1);
            int y = oldPos.y() + i * (newPos.y() - oldPos.y()) / (numSteps - 1);

            painter.drawEllipse(x - (thickness / 2), y - (thickness / 2),
                                thickness, thickness);
        }
    } else if (brush == tr(&quot;Random Letters&quot;)) {
        QChar ch('A' + (qrand() % 26));

        QFont biggerFont = painter.font();
        biggerFont.setBold(true);
        biggerFont.setPointSize(biggerFont.pointSize() + thickness);
        painter.setFont(biggerFont);

        painter.drawText(newPos, QString(ch));

        QFontMetrics metrics(painter.font());
        boundingRect = metrics.boundingRect(ch);
        boundingRect.translate(newPos);
        boundingRect.adjust(-10, -10, +10, +10);
    }
    painter.restore();
    return boundingRect;
}

QRect BasicToolsPlugin::mouseRelease(const QString &amp; /* brush */,
                                     QPainter &amp; /* painter */,
                                     const QPoint &amp; /* pos */)
{
    return QRect(0, 0, 0, 0);
}

QStringList BasicToolsPlugin::shapes() const
{
    return QStringList() &lt;&lt; tr(&quot;Circle&quot;) &lt;&lt; tr(&quot;Star&quot;) &lt;&lt; tr(&quot;Text...&quot;);
}

QPainterPath BasicToolsPlugin::generateShape(const QString &amp;shape,
                                             QWidget *parent)
{
    QPainterPath path;

    if (shape == tr(&quot;Circle&quot;)) {
        path.addEllipse(0, 0, 50, 50);
    } else if (shape == tr(&quot;Star&quot;)) {
        path.moveTo(90, 50);
        for (int i = 1; i &lt; 5; ++i) {
            path.lineTo(50 + 40 * cos(0.8 * i * Pi),
                        50 + 40 * sin(0.8 * i * Pi));
        }
        path.closeSubpath();
    } else if (shape == tr(&quot;Text...&quot;)) {
        QString text = QInputDialog::getText(parent, tr(&quot;Text Shape&quot;),
                                             tr(&quot;Enter text:&quot;),
                                             QLineEdit::Normal, tr(&quot;Qt&quot;));
        if (!text.isEmpty()) {
            QFont timesFont(&quot;Times&quot;, 50);
            timesFont.setStyleStrategy(QFont::ForceOutline);
            path.addText(0, 0, timesFont, text);
        }
    }

    return path;
}

QStringList BasicToolsPlugin::filters() const
{
    return QStringList() &lt;&lt; tr(&quot;Invert Pixels&quot;) &lt;&lt; tr(&quot;Swap RGB&quot;)
                         &lt;&lt; tr(&quot;Grayscale&quot;);
}

QImage BasicToolsPlugin::filterImage(const QString &amp;filter, const QImage &amp;image,
                                     QWidget * /* parent */)
{
    QImage result = image.convertToFormat(QImage::Format_RGB32);

    if (filter == tr(&quot;Invert Pixels&quot;)) {
        result.invertPixels();
    } else if (filter == tr(&quot;Swap RGB&quot;)) {
        result = result.rgbSwapped();
    } else if (filter == tr(&quot;Grayscale&quot;)) {
        for (int y = 0; y &lt; result.height(); ++y) {
            for (int x = 0; x &lt; result.width(); ++x) {
                int pixel = result.pixel(x, y);
                int gray = qGray(pixel);
                int alpha = qAlpha(pixel);
                result.setPixel(x, y, qRgba(gray, gray, gray, alpha));
            }
        }
    }
    return result;
}

</db:programlisting>
</db:article>
