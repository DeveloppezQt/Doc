<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Torrent Example</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 5.2.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Demonstrates complex TCP/IP operations.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** You may use this file under the terms of the BSD license as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names
**     of its contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;bencodeparser.h&quot;
#include &quot;metainfo.h&quot;

#include &lt;QDateTime&gt;
#include &lt;QMetaType&gt;
#include &lt;QString&gt;

MetaInfo::MetaInfo()
{
    clear();
}

void MetaInfo::clear()
{
    errString = &quot;Unknown error&quot;;
    content.clear();
    infoData.clear();
    metaInfoMultiFiles.clear();
    metaInfoAnnounce.clear();
    metaInfoAnnounceList.clear();
    metaInfoCreationDate = QDateTime();
    metaInfoComment.clear();
    metaInfoCreatedBy.clear();
    metaInfoName.clear();
    metaInfoPieceLength = 0;
    metaInfoSha1Sums.clear();
}

bool MetaInfo::parse(const QByteArray &amp;data)
{
    clear();
    content = data;

    BencodeParser parser;
    if (!parser.parse(content)) {
        errString = parser.errorString();
        return false;
    }

    infoData = parser.infoSection();

    QMap&lt;QByteArray, QVariant&gt; dict = parser.dictionary();
    if (!dict.contains(&quot;info&quot;))
        return false;

    QMap&lt;QByteArray, QVariant&gt; info = qvariant_cast&lt;Dictionary&gt;(dict.value(&quot;info&quot;));

    if (info.contains(&quot;files&quot;)) {
        metaInfoFileForm = MultiFileForm;

        QList&lt;QVariant&gt; files = info.value(&quot;files&quot;).toList();

        for (int i = 0; i &lt; files.size(); ++i) {
            QMap&lt;QByteArray, QVariant&gt; file = qvariant_cast&lt;Dictionary&gt;(files.at(i));
            QList&lt;QVariant&gt; pathElements = file.value(&quot;path&quot;).toList();
            QByteArray path;
            foreach (QVariant p, pathElements) {
                if (!path.isEmpty())
                    path += &quot;/&quot;;
                path += p.toByteArray();
            }

            MetaInfoMultiFile multiFile;
            multiFile.length = file.value(&quot;length&quot;).toLongLong();
            multiFile.path = QString::fromUtf8(path);
            multiFile.md5sum = file.value(&quot;md5sum&quot;).toByteArray();
            metaInfoMultiFiles &lt;&lt; multiFile;
        }

        metaInfoName = QString::fromUtf8(info.value(&quot;name&quot;).toByteArray());
        metaInfoPieceLength = info.value(&quot;piece length&quot;).toInt();
        QByteArray pieces = info.value(&quot;pieces&quot;).toByteArray();
        for (int i = 0; i &lt; pieces.size(); i += 20)
            metaInfoSha1Sums &lt;&lt; pieces.mid(i, 20);
    } else if (info.contains(&quot;length&quot;)) {
        metaInfoFileForm = SingleFileForm;
        metaInfoSingleFile.length = info.value(&quot;length&quot;).toLongLong();
        metaInfoSingleFile.md5sum = info.value(&quot;md5sum&quot;).toByteArray();
        metaInfoSingleFile.name = QString::fromUtf8(info.value(&quot;name&quot;).toByteArray());
        metaInfoSingleFile.pieceLength = info.value(&quot;piece length&quot;).toInt();

        QByteArray pieces = info.value(&quot;pieces&quot;).toByteArray();
        for (int i = 0; i &lt; pieces.size(); i += 20)
            metaInfoSingleFile.sha1Sums &lt;&lt; pieces.mid(i, 20);
    }

    metaInfoAnnounce = QString::fromUtf8(dict.value(&quot;announce&quot;).toByteArray());

    if (dict.contains(&quot;announce-list&quot;)) {
        // ### unimplemented
    }

    if (dict.contains(&quot;creation date&quot;))
        metaInfoCreationDate.setTime_t(dict.value(&quot;creation date&quot;).toInt());
    if (dict.contains(&quot;comment&quot;))
        metaInfoComment = QString::fromUtf8(dict.value(&quot;comment&quot;).toByteArray());
    if (dict.contains(&quot;created by&quot;))
        metaInfoCreatedBy = QString::fromUtf8(dict.value(&quot;created by&quot;).toByteArray());

    return true;
}

QByteArray MetaInfo::infoValue() const
{
    return infoData;
}

QString MetaInfo::errorString() const
{
    return errString;
}

MetaInfo::FileForm MetaInfo::fileForm() const
{
    return metaInfoFileForm;
}

QString MetaInfo::announceUrl() const
{
    return metaInfoAnnounce;
}

QStringList MetaInfo::announceList() const
{
    return metaInfoAnnounceList;
}

QDateTime MetaInfo::creationDate() const
{
    return metaInfoCreationDate;
}

QString MetaInfo::comment() const
{
    return metaInfoComment;
}

QString MetaInfo::createdBy() const
{
    return metaInfoCreatedBy;
}

MetaInfoSingleFile MetaInfo::singleFile() const
{
    return metaInfoSingleFile;
}

QList&lt;MetaInfoMultiFile&gt; MetaInfo::multiFiles() const
{
    return metaInfoMultiFiles;
}

QString MetaInfo::name() const
{
    return metaInfoName;
}

int MetaInfo::pieceLength() const
{
    return metaInfoPieceLength;
}

QList&lt;QByteArray&gt; MetaInfo::sha1Sums() const
{
    return metaInfoSha1Sums;
}

qint64 MetaInfo::totalSize() const
{
    if (fileForm() == SingleFileForm)
        return singleFile().length;

    qint64 size = 0;
    foreach (MetaInfoMultiFile file, multiFiles())
        size += file.length;
    return size;
}

</db:programlisting>
</db:article>
