<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Icons Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Icons example shows how <db:link xlink:href="qicon.xml">QIcon</db:link> can generate pixmaps reflecting an icon's state, mode and size.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>These pixmaps are generated from the set of pixmaps made available to the icon, and are used by Qt widgets to show an icon representing a particular action.</db:para>
<db:mediaobject>
<db:alt>Screenshot of the Icons example</db:alt>
<db:imageobject>
<db:imagedata fileref="images/icons-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Contents:</db:para>
<db:section xml:id="qicon-overview">
<db:title>QIcon Overview</db:title>
<db:para>The <db:link xlink:href="qicon.xml">QIcon</db:link> class provides scalable icons in different modes and states. An icon's state and mode are depending on the intended use of the icon. Qt currently defines four modes:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Mode</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qicon.xml#Mode-enum">QIcon::Normal</db:link></db:para>
</db:td>
<db:td>
<db:para>Display the pixmap when the user is not interacting with the icon, but the functionality represented by the icon is available.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qicon.xml#Mode-enum">QIcon::Active</db:link></db:para>
</db:td>
<db:td>
<db:para>Display the pixmap when the functionality represented by the icon is available and the user is interacting with the icon, for example, moving the mouse over it or clicking it.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qicon.xml#Mode-enum">QIcon::Disabled</db:link></db:para>
</db:td>
<db:td>
<db:para>Display the pixmap when the functionality represented by the icon is not available.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qicon.xml#Mode-enum">QIcon::Selected</db:link></db:para>
</db:td>
<db:td>
<db:para>Display the pixmap when the icon is selected.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para><db:link xlink:href="qicon.xml">QIcon</db:link>'s states are <db:link xlink:href="qicon.xml#State-enum">QIcon::On</db:link> and <db:link xlink:href="qicon.xml#State-enum">QIcon::Off</db:link>, which will display the pixmap when the widget is in the respective state. The most common usage of <db:link xlink:href="qicon.xml">QIcon</db:link>'s states are when displaying checkable tool buttons or menu entries (see <db:link xlink:href="qabstractbutton.xml#checkable-prop">QAbstractButton::setCheckable</db:link>() and <db:link xlink:href="qaction.xml#checkable-prop">QAction::setCheckable</db:link>()). When a tool button or menu entry is checked, the <db:link xlink:href="qicon.xml">QIcon</db:link>'s state is <db:link xlink:href="qicon.xml#State-enum">On</db:link>, otherwise it's <db:link xlink:href="qicon.xml#State-enum">Off</db:link>. You can, for example, use the <db:link xlink:href="qicon.xml">QIcon</db:link>'s states to display differing pixmaps depending on whether the tool button or menu entry is checked or not.</db:para>
<db:para>A <db:link xlink:href="qicon.xml">QIcon</db:link> can generate smaller, larger, active, disabled, and selected pixmaps from the set of pixmaps it is given. Such pixmaps are used by Qt widgets to show an icon representing a particular action.</db:para>
</db:section>
<db:section xml:id="overview-of-the-icons-application">
<db:title>Overview of the Icons Application</db:title>
<db:para>With the Icons application you get a preview of an icon's generated pixmaps reflecting its different states, modes and size.</db:para>
<db:para>When an image is loaded into the application, it is converted into a pixmap and becomes a part of the set of pixmaps available to the icon. An image can be excluded from this set by checking off the related checkbox. The application provides a sub directory containing sets of images explicitly designed to illustrate how Qt renders an icon in different modes and states.</db:para>
<db:para>The application allows you to manipulate the icon size with some predefined sizes and a spin box. The predefined sizes are style dependent, but most of the styles have the same values: Only the Macintosh style differ by using 32 pixels, instead of 16 pixels, for toolbar buttons. You can navigate between the available styles using the <db:guilabel>View</db:guilabel> menu.</db:para>
<db:mediaobject>
<db:alt>Screenshot of the View menu</db:alt>
<db:imageobject>
<db:imagedata fileref="images/icons-view-menu.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The <db:guilabel>View</db:guilabel> menu also provide the option to make the application guess the icon state and mode from an image's file name. The <db:guilabel>File</db:guilabel> menu provide the options of adding an image and removing all images. These last options are also available through a context menu that appears if you press the right mouse button within the table of image files. In addition, the <db:guilabel>File</db:guilabel> menu provide an <db:guilabel>Exit</db:guilabel> option, and the <db:guilabel>Help</db:guilabel> menu provide information about the example and about Qt.</db:para>
<db:mediaobject>
<db:alt>Screenshot of the Find Files</db:alt>
<db:imageobject>
<db:imagedata fileref="images/icons_find_normal.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The screenshot above shows the application with one image file loaded. The <db:guilabel>Guess Image Mode/State</db:guilabel> is enabled and the style is Plastique.</db:para>
<db:para>When <db:link xlink:href="qicon.xml">QIcon</db:link> is provided with only one available pixmap, that pixmap is used for all the states and modes. In this case the pixmap's icon mode is set to normal, and the generated pixmaps for the normal and active modes will look the same. But in disabled and selected mode, Qt will generate a slightly different pixmap.</db:para>
<db:para>The next screenshot shows the application with an additional file loaded, providing <db:link xlink:href="qicon.xml">QIcon</db:link> with two available pixmaps. Note that the new image file's mode is set to disabled. When rendering the <db:guilabel>Disabled</db:guilabel> mode pixmaps, Qt will now use the new image. We can see the difference: The generated disabled pixmap in the first screenshot is slightly darker than the pixmap with the originally set disabled mode in the second screenshot.</db:para>
<db:mediaobject>
<db:alt>Screenshot of the Find Files</db:alt>
<db:imageobject>
<db:imagedata fileref="images/icons_find_normal_disabled.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>When Qt renders the icon's pixmaps it searches through the set of available pixmaps following a particular algorithm. The algorithm is documented in <db:link xlink:href="qicon.xml">QIcon</db:link>, but we will describe some particular cases below.</db:para>
<db:mediaobject>
<db:alt>Screenshot of the Find Files</db:alt>
<db:imageobject>
<db:imagedata fileref="images/icons_monkey_active.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>In the screenshot above, we have set monkey_on_32x32 to be an Active/On pixmap and monkey_off_64x64 to be Normal/Off. To render the other six mode/state combinations, <db:link xlink:href="qicon.xml">QIcon</db:link> uses the search algorithm described in the table below:</db:para>
<db:informaltable style="generic" width="100%">
<db:thead>
<db:tr>
<db:th colspan="2">
<db:para>Requested Pixmap</db:para>
</db:th>
<db:th colspan="8">
<db:para>Preferred Alternatives (mode/state)</db:para>
</db:th>
</db:tr>
<db:tr>
<db:th>
<db:para>Mode</db:para>
</db:th>
<db:th>
<db:para>State</db:para>
</db:th>
<db:th>
<db:para>1</db:para>
</db:th>
<db:th>
<db:para>2</db:para>
</db:th>
<db:th>
<db:para>3</db:para>
</db:th>
<db:th>
<db:para>4</db:para>
</db:th>
<db:th>
<db:para>5</db:para>
</db:th>
<db:th>
<db:para>6</db:para>
</db:th>
<db:th>
<db:para>7</db:para>
</db:th>
<db:th>
<db:para>8</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td rowspan="2">
<db:para>Normal</db:para>
</db:td>
<db:td>
<db:para>Off</db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">N0</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>A0</db:para>
</db:td>
<db:td>
<db:para>N1</db:para>
</db:td>
<db:td>
<db:para>A1</db:para>
</db:td>
<db:td>
<db:para>D0</db:para>
</db:td>
<db:td>
<db:para>S0</db:para>
</db:td>
<db:td>
<db:para>D1</db:para>
</db:td>
<db:td>
<db:para>S1</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>On</db:para>
</db:td>
<db:td>
<db:para>N1</db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">A1</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>N0</db:para>
</db:td>
<db:td>
<db:para>A0</db:para>
</db:td>
<db:td>
<db:para>D1</db:para>
</db:td>
<db:td>
<db:para>S1</db:para>
</db:td>
<db:td>
<db:para>D0</db:para>
</db:td>
<db:td>
<db:para>S0</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td rowspan="2">
<db:para>Active</db:para>
</db:td>
<db:td>
<db:para>Off</db:para>
</db:td>
<db:td>
<db:para>A0</db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">N0</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>A1</db:para>
</db:td>
<db:td>
<db:para>N1</db:para>
</db:td>
<db:td>
<db:para>D0</db:para>
</db:td>
<db:td>
<db:para>S0</db:para>
</db:td>
<db:td>
<db:para>D1</db:para>
</db:td>
<db:td>
<db:para>S1</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>On</db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">A1</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>N1</db:para>
</db:td>
<db:td>
<db:para>A0</db:para>
</db:td>
<db:td>
<db:para>N0</db:para>
</db:td>
<db:td>
<db:para>D1</db:para>
</db:td>
<db:td>
<db:para>S1</db:para>
</db:td>
<db:td>
<db:para>D0</db:para>
</db:td>
<db:td>
<db:para>S0</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td rowspan="2">
<db:para>Disabled</db:para>
</db:td>
<db:td>
<db:para>Off</db:para>
</db:td>
<db:td>
<db:para>D0</db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">N0'</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>A0'</db:para>
</db:td>
<db:td>
<db:para>D1</db:para>
</db:td>
<db:td>
<db:para>N1'</db:para>
</db:td>
<db:td>
<db:para>A1'</db:para>
</db:td>
<db:td>
<db:para>S0'</db:para>
</db:td>
<db:td>
<db:para>S1'</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>On</db:para>
</db:td>
<db:td>
<db:para>D1</db:para>
</db:td>
<db:td>
<db:para>N1'</db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">A1'</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>D0</db:para>
</db:td>
<db:td>
<db:para>N0'</db:para>
</db:td>
<db:td>
<db:para>A0'</db:para>
</db:td>
<db:td>
<db:para>S1'</db:para>
</db:td>
<db:td>
<db:para>S0'</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td rowspan="2">
<db:para>Selected</db:para>
</db:td>
<db:td>
<db:para>Off</db:para>
</db:td>
<db:td>
<db:para>S0</db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">N0''</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>A0''</db:para>
</db:td>
<db:td>
<db:para>S1</db:para>
</db:td>
<db:td>
<db:para>N1''</db:para>
</db:td>
<db:td>
<db:para>A1''</db:para>
</db:td>
<db:td>
<db:para>D0''</db:para>
</db:td>
<db:td>
<db:para>D1''</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>On</db:para>
</db:td>
<db:td>
<db:para>S1</db:para>
</db:td>
<db:td>
<db:para>N1''</db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">A1''</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>S0</db:para>
</db:td>
<db:td>
<db:para>N0''</db:para>
</db:td>
<db:td>
<db:para>A0''</db:para>
</db:td>
<db:td>
<db:para>D1''</db:para>
</db:td>
<db:td>
<db:para>D0''</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>In the table, &quot;0&quot; and &quot;1&quot; stand for Off&quot; and &quot;On&quot;, respectively. Single quotes indicates that <db:link xlink:href="qicon.xml">QIcon</db:link> generates a disabled (&quot;grayed out&quot;) version of the pixmap; similarly, double quuote indicate that <db:link xlink:href="qicon.xml">QIcon</db:link> generates a selected (&quot;blued out&quot;) version of the pixmap.</db:para>
<db:para>The alternatives used in the screenshot above are shown in bold. For example, the Disabled/Off pixmap is derived by graying out the Normal/Off pixmap (monkey_off_64x64).</db:para>
<db:para>In the next screenshots, we loaded the whole set of monkey images. By checking or unchecking file names from the image list, we get different results:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/icons_monkey.png"/>
</db:imageobject>
</db:inlinemediaobject> Screenshot of the Monkey Files</db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/icons_monkey_mess.png"/>
</db:imageobject>
</db:inlinemediaobject> Screenshot of the Monkey Files</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>For any given mode/state combination, it is possible to specify several images at different resolutions. When rendering an icon, <db:link xlink:href="qicon.xml">QIcon</db:link> will automatically pick the most suitable image and scale it down if necessary. (<db:link xlink:href="qicon.xml">QIcon</db:link> never scales up images, because this rarely looks good.)</db:para>
<db:para>The screenshots below shows what happens when we provide <db:link xlink:href="qicon.xml">QIcon</db:link> with three images (qt_extended_16x16.png, qt_extended_32x32.png, qt_extended_48x48.png) and try to render the <db:link xlink:href="qicon.xml">QIcon</db:link> at various resolutions:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/icons_qt_extended_8x8.png"/>
</db:imageobject>
</db:inlinemediaobject> Qt Extended icon at 8 x 8</db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/icons_qt_extended_16x16.png"/>
</db:imageobject>
</db:inlinemediaobject> Qt Extended icon at 16 x 16</db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/icons_qt_extended_17x17.png"/>
</db:imageobject>
</db:inlinemediaobject> Qt Extended icon at 17 x 17</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
</db:td>
<db:td>
<db:para>8 x 8</db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">16 x 16</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>17 x 17</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/icons_qt_extended_32x32.png"/>
</db:imageobject>
</db:inlinemediaobject> Qt Extended icon at 32 x 32</db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/icons_qt_extended_33x33.png"/>
</db:imageobject>
</db:inlinemediaobject> Qt Extended icon at 33 x 33</db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/icons_qt_extended_48x48.png"/>
</db:imageobject>
</db:inlinemediaobject> Qt Extended icon at 48 x 48</db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/icons_qt_extended_64x64.png"/>
</db:imageobject>
</db:inlinemediaobject> Qt Extended icon at 64 x 64</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">32 x 32</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>33 x 33</db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">48 x 48</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>64 x 64</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>For sizes up to 16 x 16, <db:link xlink:href="qicon.xml">QIcon</db:link> uses qt_extended_16x16.png and scales it down if necessary. For sizes between 17 x 17 and 32 x 32, it uses qt_extended_32x32.png. For sizes above 32 x 32, it uses qt_extended_48x48.png.</db:para>
</db:section>
<db:section xml:id="line-by-line-walkthrough">
<db:title>Line-by-Line Walkthrough</db:title>
<db:para>The Icons example consists of four classes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>MainWindow inherits <db:link xlink:href="qmainwindow.xml">QMainWindow</db:link> and is the main application window.</db:para>
</db:listitem>
<db:listitem>
<db:para>IconPreviewArea is a custom widget that displays all combinations of states and modes for a given icon.</db:para>
</db:listitem>
<db:listitem>
<db:para>IconSizeSpinBox is a subclass of <db:link xlink:href="qspinbox.xml">QSpinBox</db:link> that lets the user enter icon sizes (e.g., &quot;48 x 48&quot;).</db:para>
</db:listitem>
<db:listitem>
<db:para>ImageDelegate is a subclass of <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> that provides comboboxes for letting the user set the mode and state associated with an image.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>We will start by reviewing the IconPreviewArea class before we take a look at the MainWindow class. Finally, we will review the IconSizeSpinBox and ImageDelegate classes.</db:para>
<db:section xml:id="iconpreviewarea-class-definition">
<db:title>IconPreviewArea Class Definition</db:title>
<db:para>An IconPreviewArea widget consists of a group box containing a grid of <db:link xlink:href="qlabel.xml">QLabel</db:link> widgets displaying headers and pixmaps.</db:para>
<db:mediaobject>
<db:alt>Screenshot of IconPreviewArea.</db:alt>
<db:imageobject>
<db:imagedata fileref="images/icons_preview_area.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">class IconPreviewArea : public QWidget
{
    Q_OBJECT

public:
    explicit IconPreviewArea(QWidget *parent = Q_NULLPTR);

    void setIcon(const QIcon &amp;icon);
    void setSize(const QSize &amp;size);

    static QVector&lt;QIcon::Mode&gt; iconModes();
    static QVector&lt;QIcon::State&gt; iconStates();
    static QStringList iconModeNames();
    static QStringList iconStateNames();

private:
    QLabel *createHeaderLabel(const QString &amp;text);
    QLabel *createPixmapLabel();
    void updatePixmapLabels();

    enum { NumModes = 4, NumStates = 2 };

    QIcon icon;
    QSize size;
    QLabel *stateLabels[NumStates];
    QLabel *modeLabels[NumModes];
    QLabel *pixmapLabels[NumModes][NumStates];
};
</db:programlisting>
<db:para>The IconPreviewArea class inherits <db:link xlink:href="qwidget.xml">QWidget</db:link>. It displays the generated pixmaps corresponding to an icon's possible states and modes at a given size.</db:para>
<db:programlisting language="cpp">QVector&lt;QIcon::Mode&gt; IconPreviewArea::iconModes()
{
    static const QVector&lt;QIcon::Mode&gt; result = {QIcon::Normal, QIcon::Active, QIcon::Disabled, QIcon::Selected};
    return result;
}

QVector&lt;QIcon::State&gt; IconPreviewArea::iconStates()
{
    static const QVector&lt;QIcon::State&gt; result = {QIcon::Off, QIcon::On};
    return result;
}

QStringList IconPreviewArea::iconModeNames()
{
    static const QStringList result = {tr(&quot;Normal&quot;), tr(&quot;Active&quot;), tr(&quot;Disabled&quot;), tr(&quot;Selected&quot;)};
    return result;
}

QStringList IconPreviewArea::iconStateNames()
{
    static const QStringList result = {tr(&quot;Off&quot;), tr(&quot;On&quot;)};
    return result;
}
</db:programlisting>
<db:para>We would like the table columns to be in the order <db:link xlink:href="qicon.xml#Mode-enum">QIcon::Normal</db:link>, <db:link xlink:href="qicon.xml#Mode-enum">QIcon::Active</db:link>, <db:link xlink:href="qicon.xml#Mode-enum">QIcon::Disabled</db:link>, <db:link xlink:href="qicon.xml#Mode-enum">QIcon::Selected</db:link> and the rows in the order <db:link xlink:href="qicon.xml#State-enum">QIcon::Off</db:link>, <db:link xlink:href="qicon.xml#State-enum">QIcon::On</db:link>, which does not match the enumeration. The above code provides arrays allowing to map from enumeration value to row/column (by using QVector::indexOf()) and back by using the array index and lists of the matching strings. Qt's containers can be easily populated by using C++ 11 initializer lists. If the compiler does not provide that feature, a pattern like</db:para>
<db:programlisting language="cpp">QVector&lt;QIcon::Mode&gt; IconPreviewArea::iconModes()
{
    static QVector&lt;QIcon::Mode&gt; result;
    if (result.isEmpty())
        result &lt;&lt; QIcon::Normal &lt;&lt; QIcon::Active &lt;&lt; QIcon::Disabled &lt;&lt; QIcon::Selected;
    return result;
}
</db:programlisting>
<db:para>can be used.</db:para>
<db:para>We need two public functions to set the current icon and the icon's size. In addition the class has three private functions: We use the createHeaderLabel() and createPixmapLabel() functions when constructing the preview area, and we need the updatePixmapLabels() function to update the preview area when the icon or the icon's size has changed.</db:para>
<db:para>The NumModes and NumStates constants reflect <db:link xlink:href="qicon.xml">QIcon</db:link>'s number of currently defined modes and states.</db:para>
</db:section>
<db:section xml:id="iconpreviewarea-class-implementation">
<db:title>IconPreviewArea Class Implementation</db:title>
<db:programlisting language="cpp">IconPreviewArea::IconPreviewArea(QWidget *parent)
    : QWidget(parent)
{
    QGridLayout *mainLayout = new QGridLayout(this);

    for (int row = 0; row &lt; NumStates; ++row) {
        stateLabels[row] = createHeaderLabel(IconPreviewArea::iconStateNames().at(row));
        mainLayout-&gt;addWidget(stateLabels[row], row + 1, 0);
    }
    Q_ASSERT(NumStates == 2);

    for (int column = 0; column &lt; NumModes; ++column) {
        modeLabels[column] = createHeaderLabel(IconPreviewArea::iconModeNames().at(column));
        mainLayout-&gt;addWidget(modeLabels[column], 0, column + 1);
    }
    Q_ASSERT(NumModes == 4);

    for (int column = 0; column &lt; NumModes; ++column) {
        for (int row = 0; row &lt; NumStates; ++row) {
            pixmapLabels[column][row] = createPixmapLabel();
            mainLayout-&gt;addWidget(pixmapLabels[column][row], row + 1, column + 1);
        }
    }
}
</db:programlisting>
<db:para>In the constructor we create the labels displaying the headers and the icon's generated pixmaps, and add them to a grid layout.</db:para>
<db:para>When creating the header labels, we make sure the enums NumModes and NumStates defined in the .h file, correspond with the number of labels that we create. Then if the enums at some point are changed, the Q_ASSERT() macro will alert that this part of the .cpp file needs to be updated as well.</db:para>
<db:para>If the application is built in debug mode, the Q_ASSERT() macro will expand to</db:para>
<db:programlisting language="cpp">if (!condition)
   qFatal(&quot;ASSERT: &quot;condition&quot; in file ...&quot;);
</db:programlisting>
<db:para>In release mode, the macro simply disappear. The mode can be set in the application's .pro file. One way to do so is to add an option to qmake when building the application:</db:para>
<db:programlisting language="cpp">qmake &quot;CONFIG += debug&quot; icons.pro
</db:programlisting>
<db:para>or</db:para>
<db:programlisting language="cpp">qmake &quot;CONFIG += release&quot; icons.pro
</db:programlisting>
<db:para>Another approach is to add this line directly to the .pro file.</db:para>
<db:programlisting language="cpp">void IconPreviewArea::setIcon(const QIcon &amp;icon)
{
    this-&gt;icon = icon;
    updatePixmapLabels();
}

void IconPreviewArea::setSize(const QSize &amp;size)
{
    if (size != this-&gt;size) {
        this-&gt;size = size;
        updatePixmapLabels();
    }
}
</db:programlisting>
<db:para>The public setIcon() and setSize() functions change the icon or the icon size, and make sure that the generated pixmaps are updated.</db:para>
<db:programlisting language="cpp">QLabel *IconPreviewArea::createHeaderLabel(const QString &amp;text)
{
    QLabel *label = new QLabel(tr(&quot;&lt;b&gt;%1&lt;/b&gt;&quot;).arg(text));
    label-&gt;setAlignment(Qt::AlignCenter);
    return label;
}

QLabel *IconPreviewArea::createPixmapLabel()
{
    QLabel *label = new QLabel;
    label-&gt;setEnabled(false);
    label-&gt;setAlignment(Qt::AlignCenter);
    label-&gt;setFrameShape(QFrame::Box);
    label-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    label-&gt;setBackgroundRole(QPalette::Base);
    label-&gt;setAutoFillBackground(true);
    label-&gt;setMinimumSize(132, 132);
    return label;
}
</db:programlisting>
<db:para>We use the createHeaderLabel() and createPixmapLabel() functions to create the preview area's labels displaying the headers and the icon's generated pixmaps. Both functions return the <db:link xlink:href="qlabel.xml">QLabel</db:link> that is created.</db:para>
<db:programlisting language="cpp">void IconPreviewArea::updatePixmapLabels()
{
    QWindow *window = Q_NULLPTR;
    if (const QWidget *nativeParent = nativeParentWidget())
        window = nativeParent-&gt;windowHandle();
    for (int column = 0; column &lt; NumModes; ++column) {
        for (int row = 0; row &lt; NumStates; ++row) {
            const QPixmap pixmap =
                icon.pixmap(window, size, IconPreviewArea::iconModes().at(column),
                            IconPreviewArea::iconStates().at(row));
            QLabel *pixmapLabel = pixmapLabels[column][row];
            pixmapLabel-&gt;setPixmap(pixmap);
            pixmapLabel-&gt;setEnabled(!pixmap.isNull());
            QString toolTip;
            if (!pixmap.isNull()) {
                const QSize actualSize = icon.actualSize(size);
                toolTip =
                    tr(&quot;Size: %1x%2\nActual size: %3x%4\nDevice pixel ratio: %5&quot;)
                        .arg(size.width()).arg(size.height())
                        .arg(actualSize.width()).arg(actualSize.height())
                        .arg(pixmap.devicePixelRatioF());
            }
            pixmapLabel-&gt;setToolTip(toolTip);
        }
    }
}
</db:programlisting>
<db:para>We use the private updatePixmapLabel() function to update the generated pixmaps displayed in the preview area.</db:para>
<db:para>For each mode, and for each state, we retrieve a pixmap using the <db:link xlink:href="qicon.xml#pixmap">QIcon::pixmap</db:link>() function, which generates a pixmap corresponding to the given state, mode and size. We pass the QWindows instance obtained by calling <db:link xlink:href="qwidget.xml#windowHandle">QWidget::windowHandle</db:link>() on the top level widget (<db:link xlink:href="qwidget.xml#nativeParentWidget">QWidget::nativeParentWidget</db:link>()) in order to retrieve the pixmap that matches best. We format a tooltip displaying size, actual size and device pixel ratio.</db:para>
</db:section>
<db:section xml:id="mainwindow-class-definition">
<db:title>MainWindow Class Definition</db:title>
<db:para>The MainWindow widget consists of three main elements: an images group box, an icon size group box and a preview area.</db:para>
<db:mediaobject>
<db:alt>Screenshot of the Icons example</db:alt>
<db:imageobject>
<db:imagedata fileref="images/icons-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow();

    void loadImages(const QStringList &amp;fileNames);

    void show();

private slots:
    void about();
    void changeStyle(bool checked);
    void changeSize(int, bool);
    void triggerChangeSize();
    void changeIcon();
    void addSampleImages();
    void addOtherImages();
    void removeAllImages();
    void useHighDpiPixmapsChanged(int checkState);
    void screenChanged();

private:
    QWidget *createImagesGroupBox();
    QWidget *createIconSizeGroupBox();
    QWidget *createHighDpiIconSizeGroupBox();
    void createActions();
    void createContextMenu();
    void checkCurrentStyle();
    void addImages(const QString &amp;directory);

    IconPreviewArea *previewArea;

    QTableWidget *imagesTable;

    QButtonGroup *sizeButtonGroup;
    IconSizeSpinBox *otherSpinBox;

    QLabel *devicePixelRatioLabel;
    QLabel *screenNameLabel;

    QAction *addOtherImagesAct;
    QAction *addSampleImagesAct;
    QAction *removeAllImagesAct;
    QAction *guessModeStateAct;
    QAction *nativeFileDialogAct;
    QActionGroup *styleActionGroup;
};
</db:programlisting>
<db:para>The MainWindow class inherits from <db:link xlink:href="qmainwindow.xml">QMainWindow</db:link>. We reimplement the constructor, and declare several private slots:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The about() slot simply provides information about the example.</db:para>
</db:listitem>
<db:listitem>
<db:para>The changeStyle() slot changes the application's GUI style and adjust the style dependent size options.</db:para>
</db:listitem>
<db:listitem>
<db:para>The changeSize() slot changes the size of the preview area's icon.</db:para>
</db:listitem>
<db:listitem>
<db:para>The changeIcon() slot updates the set of pixmaps available to the icon displayed in the preview area.</db:para>
</db:listitem>
<db:listitem>
<db:para>The addSampleImages() slot allows the user to load a new image from the samples provided into the application.</db:para>
</db:listitem>
<db:listitem>
<db:para>The addOtherImages() slot allows the user to load a new image from the directory obtained by calling <db:link xlink:href="qstandardpaths.xml#standardLocations">QStandardPaths::standardLocations</db:link>(<db:link xlink:href="qstandardpaths.xml#StandardLocation-enum">QStandardPaths::PicturesLocation</db:link>).</db:para>
</db:listitem>
<db:listitem>
<db:para>The screenChanged() updates the display in the <db:guilabel>High DPI</db:guilabel> group box to correctly display the parameters of the current screen the window is located on.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In addition we declare several private functions to simplify the constructor.</db:para>
</db:section>
<db:section xml:id="mainwindow-class-implementation">
<db:title>MainWindow Class Implementation</db:title>
<db:programlisting language="cpp">MainWindow::MainWindow()
{
    QWidget *centralWidget = new QWidget(this);
    setCentralWidget(centralWidget);

    createActions();

    QGridLayout *mainLayout = new QGridLayout(centralWidget);

    QGroupBox *previewGroupBox = new QGroupBox(tr(&quot;Preview&quot;));
    previewArea = new IconPreviewArea(previewGroupBox);
    QVBoxLayout *previewLayout = new QVBoxLayout(previewGroupBox);
    previewLayout-&gt;addWidget(previewArea);

    mainLayout-&gt;addWidget(previewGroupBox, 0, 0, 1, 2);
    mainLayout-&gt;addWidget(createImagesGroupBox(), 1, 0);
    QVBoxLayout *vBox = new QVBoxLayout;
    vBox-&gt;addWidget(createIconSizeGroupBox());
    vBox-&gt;addWidget(createHighDpiIconSizeGroupBox());
    vBox-&gt;addItem(new QSpacerItem(0, 0, QSizePolicy::Ignored, QSizePolicy::MinimumExpanding));
    mainLayout-&gt;addLayout(vBox, 1, 1);
    createContextMenu();

    setWindowTitle(tr(&quot;Icons&quot;));
    checkCurrentStyle();
    sizeButtonGroup-&gt;button(OtherSize)-&gt;click();
}
</db:programlisting>
<db:para>In the constructor we first create the main window's central widget and its child widgets, and put them in a grid layout. Then we create the menus with their associated entries and actions.</db:para>
<db:para>We set the window title and determine the current style for the application. We also enable the icon size spin box by clicking the associated radio button, making the current value of the spin box the icon's initial size.</db:para>
<db:programlisting language="cpp">void MainWindow::about()
{
    QMessageBox::about(this, tr(&quot;About Icons&quot;),
            tr(&quot;The &lt;b&gt;Icons&lt;/b&gt; example illustrates how Qt renders an icon in &quot;
               &quot;different modes (active, normal, disabled, and selected) and &quot;
               &quot;states (on and off) based on a set of images.&quot;));
}
</db:programlisting>
<db:para>The about() slot displays a message box using the static <db:link xlink:href="qmessagebox.xml#about">QMessageBox::about</db:link>() function. In this example it displays a simple box with information about the example.</db:para>
<db:para>The about() function looks for a suitable icon in four locations: It prefers its parent's icon if that exists. If it doesn't, the function tries the top-level widget containing parent, and if that fails, it tries the active window. As a last resort it uses the <db:link xlink:href="qmessagebox.xml">QMessageBox</db:link>'s Information icon.</db:para>
<db:programlisting language="cpp">void MainWindow::changeStyle(bool checked)
{
    if (!checked)
        return;

    const QAction *action = qobject_cast&lt;QAction *&gt;(sender());
</db:programlisting>
<db:para>In the changeStyle() slot we first check the slot's parameter. If it is false we immediately return, otherwise we find out which style to change to, i.e. which action that triggered the slot, using the <db:link xlink:href="qobject.xml#sender">QObject::sender</db:link>() function.</db:para>
<db:para>This function returns the sender as a <db:link xlink:href="qobject.xml">QObject</db:link> pointer. Since we know that the sender is a <db:link xlink:href="qaction.xml">QAction</db:link> object, we can safely cast the <db:link xlink:href="qobject.xml">QObject</db:link>. We could have used a C-style cast or a C++ static_cast(), but as a defensive programming technique we use a <db:link xlink:href="">qobject_cast()</db:link>. The advantage is that if the object has the wrong type, a null pointer is returned. Crashes due to null pointers are much easier to diagnose than crashes due to unsafe casts.</db:para>
<db:programlisting language="cpp">    QStyle *style = QStyleFactory::create(action-&gt;data().toString());
    Q_ASSERT(style);
    QApplication::setStyle(style);

    foreach (QAbstractButton *button, sizeButtonGroup-&gt;buttons()) {
        const QStyle::PixelMetric metric = static_cast&lt;QStyle::PixelMetric&gt;(sizeButtonGroup-&gt;id(button));
        const int value = style-&gt;pixelMetric(metric);
        switch (metric) {
        case QStyle::PM_SmallIconSize:
            button-&gt;setText(tr(&quot;Small (%1 x %1)&quot;).arg(value));
            break;
        case QStyle::PM_LargeIconSize:
            button-&gt;setText(tr(&quot;Large (%1 x %1)&quot;).arg(value));
            break;
        case QStyle::PM_ToolBarIconSize:
            button-&gt;setText(tr(&quot;Toolbars (%1 x %1)&quot;).arg(value));
            break;
        case QStyle::PM_ListViewIconSize:
            button-&gt;setText(tr(&quot;List views (%1 x %1)&quot;).arg(value));
            break;
        case QStyle::PM_IconViewIconSize:
            button-&gt;setText(tr(&quot;Icon views (%1 x %1)&quot;).arg(value));
            break;
        case QStyle::PM_TabBarIconSize:
            button-&gt;setText(tr(&quot;Tab bars (%1 x %1)&quot;).arg(value));
            break;
        default:
            break;
        }
    }

    triggerChangeSize();
}
</db:programlisting>
<db:para>Once we have the action, we extract the style name using <db:link xlink:href="qaction.xml#data">QAction::data</db:link>(). Then we create a <db:link xlink:href="qstyle.xml">QStyle</db:link> object using the static <db:link xlink:href="qstylefactory.xml#create">QStyleFactory::create</db:link>() function.</db:para>
<db:para>Although we can assume that the style is supported by the <db:link xlink:href="qstylefactory.xml">QStyleFactory</db:link>: To be on the safe side, we use the Q_ASSERT() macro to check if the created style is valid before we use the <db:link xlink:href="qapplication.xml#setStyle">QApplication::setStyle</db:link>() function to set the application's GUI style to the new style. <db:link xlink:href="qapplication.xml">QApplication</db:link> will automatically delete the style object when a new style is set or when the application exits.</db:para>
<db:para>The predefined icon size options provided in the application are style dependent, so we need to update the labels in the icon size group box and in the end call the changeSize() slot to update the icon's size.</db:para>
<db:programlisting language="cpp">void MainWindow::changeSize(int id, bool checked)
{
    if (!checked)
        return;

    const bool other = id == int(OtherSize);
    const int extent = other
        ? otherSpinBox-&gt;value()
        : QApplication::style()-&gt;pixelMetric(static_cast&lt;QStyle::PixelMetric&gt;(id));

    previewArea-&gt;setSize(QSize(extent, extent));
    otherSpinBox-&gt;setEnabled(other);
}

void MainWindow::triggerChangeSize()
{
    changeSize(sizeButtonGroup-&gt;checkedId(), true);
}
</db:programlisting>
<db:para>The changeSize() slot sets the size for the preview area's icon.</db:para>
<db:para>It is invoked by the <db:link xlink:href="qbuttongroup.xml">QButtonGroup</db:link> whose members are radio buttons for controlling the icon size. In createIconSizeGroupBox(), each button is assigned a <db:link xlink:href="qstyle.xml#PixelMetric-enum">QStyle::PixelMetric</db:link> value as an id, which is passed as a parameter to the slot.</db:para>
<db:para>The special value OtherSize indicates that the spin box is enabled. If it is, we extract the extent of the new size from the box. If it's not, we query the style for the metric. Then we create a <db:link xlink:href="qsize.xml">QSize</db:link> object based on the extent, and use that object to set the size of the preview area's icon.</db:para>
<db:programlisting language="cpp">void MainWindow::addImages(const QString &amp;directory)
{
    QFileDialog fileDialog(this, tr(&quot;Open Images&quot;), directory);
    QStringList mimeTypeFilters;
    foreach (const QByteArray &amp;mimeTypeName, QImageReader::supportedMimeTypes())
        mimeTypeFilters.append(mimeTypeName);
    mimeTypeFilters.sort();
    fileDialog.setMimeTypeFilters(mimeTypeFilters);
    fileDialog.selectMimeTypeFilter(QLatin1String(&quot;image/png&quot;));
    fileDialog.setAcceptMode(QFileDialog::AcceptOpen);
    fileDialog.setFileMode(QFileDialog::ExistingFiles);
    if (!nativeFileDialogAct-&gt;isChecked())
        fileDialog.setOption(QFileDialog::DontUseNativeDialog);
    if (fileDialog.exec() == QDialog::Accepted)
        loadImages(fileDialog.selectedFiles());
</db:programlisting>
<db:para>The function addImages() is called by the slot addSampleImages() passing the samples directory, or by the slot addOtherImages() passing the directory obtained by querying <db:link xlink:href="qstandardpaths.xml#standardLocations">QStandardPaths::standardLocations</db:link>().</db:para>
<db:para>The first thing we do is to show a file dialog to the user. We initialize it to show the filters returned by <db:link xlink:href="qimagereader.xml#supportedMimeTypes">QImageReader::supportedMimeTypes</db:link>().</db:para>
<db:para>For each of the files the file dialog returns, we add a row to the table widget. The table widget is listing the images the user has loaded into the application.</db:para>
<db:programlisting language="cpp">        const QFileInfo fileInfo(fileName);
        const QString imageName = fileInfo.baseName();
        const QString fileName2x = fileInfo.absolutePath()
            + QLatin1Char('/') + imageName + QLatin1String(&quot;@2x.&quot;) + fileInfo.suffix();
        const QFileInfo fileInfo2x(fileName2x);
        const QImage image(fileName);
        const QString toolTip =
            tr(&quot;Directory: %1\nFile: %2\nFile@2x: %3\nSize: %4x%5&quot;)
               .arg(QDir::toNativeSeparators(fileInfo.absolutePath()), fileInfo.fileName())
               .arg(fileInfo2x.exists() ? fileInfo2x.fileName() : tr(&quot;&lt;None&gt;&quot;))
               .arg(image.width()).arg(image.height());
        QTableWidgetItem *fileItem = new QTableWidgetItem(imageName);
        fileItem-&gt;setData(Qt::UserRole, fileName);
        fileItem-&gt;setIcon(QPixmap::fromImage(image));
        fileItem-&gt;setFlags((fileItem-&gt;flags() | Qt::ItemIsUserCheckable) &amp; ~Qt::ItemIsEditable);
        fileItem-&gt;setToolTip(toolTip);
</db:programlisting>
<db:para>We retrieve the image name using the <db:link xlink:href="qfileinfo.xml#baseName">QFileInfo::baseName</db:link>() function that returns the base name of the file without the path, and create the first table widget item in the row. We check if a high resolution version of the image exists (identified by the suffix @2x on the base name) and display that along with the size in the tooltip.</db:para>
<db:para>We add the file's complete name to the item's data. Since an item can hold several information pieces, we need to assign the file name a role that will distinguish it from other data. This role can be <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::UserRole</db:link> or any value above it.</db:para>
<db:para>We also make sure that the item is not editable by removing the <db:link xlink:href="qt.xml#ItemFlag-enum">Qt::ItemIsEditable</db:link> flag. Table items are editable by default.</db:para>
<db:programlisting language="cpp">        QIcon::Mode mode = QIcon::Normal;
        QIcon::State state = QIcon::Off;
        if (guessModeStateAct-&gt;isChecked()) {
            if (imageName.contains(QLatin1String(&quot;_act&quot;), Qt::CaseInsensitive))
                mode = QIcon::Active;
            else if (imageName.contains(QLatin1String(&quot;_dis&quot;), Qt::CaseInsensitive))
                mode = QIcon::Disabled;
            else if (imageName.contains(QLatin1String(&quot;_sel&quot;), Qt::CaseInsensitive))
                mode = QIcon::Selected;

            if (imageName.contains(QLatin1String(&quot;_on&quot;), Qt::CaseInsensitive))
                state = QIcon::On;
        }
</db:programlisting>
<db:para>Then we create the second and third items in the row making the default mode Normal and the default state Off. But if the <db:guilabel>Guess Image Mode/State</db:guilabel> option is checked, and the file name contains &quot;_act&quot;, &quot;_dis&quot;, or &quot;_sel&quot;, the modes are changed to Active, Disabled, or Selected. And if the file name contains &quot;_on&quot;, the state is changed to On. The sample files in the example's images subdirectory respect this naming convention.</db:para>
<db:programlisting language="cpp">        imagesTable-&gt;setItem(row, 0, fileItem);
        QTableWidgetItem *modeItem =
            new QTableWidgetItem(IconPreviewArea::iconModeNames().at(IconPreviewArea::iconModes().indexOf(mode)));
        modeItem-&gt;setToolTip(toolTip);
        imagesTable-&gt;setItem(row, 1, modeItem);
        QTableWidgetItem *stateItem =
            new QTableWidgetItem(IconPreviewArea::iconStateNames().at(IconPreviewArea::iconStates().indexOf(state)));
        stateItem-&gt;setToolTip(toolTip);
        imagesTable-&gt;setItem(row, 2, stateItem);
        imagesTable-&gt;openPersistentEditor(modeItem);
        imagesTable-&gt;openPersistentEditor(stateItem);

        fileItem-&gt;setCheckState(Qt::Checked);
    }
}
</db:programlisting>
<db:para>In the end we add the items to the associated row, and use the <db:link xlink:href="qtablewidget.xml#openPersistentEditor">QTableWidget::openPersistentEditor</db:link>() function to create comboboxes for the mode and state columns of the items.</db:para>
<db:para>Due to the connection between the table widget's <db:link xlink:href="qtablewidget.xml#itemChanged">itemChanged</db:link>() signal and the changeIcon() slot, the new image is automatically converted into a pixmap and made part of the set of pixmaps available to the icon in the preview area. So, corresponding to this fact, we need to make sure that the new image's check box is enabled.</db:para>
<db:programlisting language="cpp">void MainWindow::changeIcon()
{
    QIcon icon;

    for (int row = 0; row &lt; imagesTable-&gt;rowCount(); ++row) {
        const QTableWidgetItem *fileItem = imagesTable-&gt;item(row, 0);
        const QTableWidgetItem *modeItem = imagesTable-&gt;item(row, 1);
        const QTableWidgetItem *stateItem = imagesTable-&gt;item(row, 2);

        if (fileItem-&gt;checkState() == Qt::Checked) {
            const int modeIndex = IconPreviewArea::iconModeNames().indexOf(modeItem-&gt;text());
            Q_ASSERT(modeIndex &gt;= 0);
            const int stateIndex = IconPreviewArea::iconStateNames().indexOf(stateItem-&gt;text());
            Q_ASSERT(stateIndex &gt;= 0);
            const QIcon::Mode mode = IconPreviewArea::iconModes().at(modeIndex);
            const QIcon::State state = IconPreviewArea::iconStates().at(stateIndex);
</db:programlisting>
<db:para>The changeIcon() slot is called when the user alters the set of images listed in the <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link>, to update the <db:link xlink:href="qicon.xml">QIcon</db:link> object rendered by the IconPreviewArea.</db:para>
<db:para>We first create a <db:link xlink:href="qicon.xml">QIcon</db:link> object, and then we run through the <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link>, which lists the images the user has loaded into the application.</db:para>
<db:programlisting language="cpp">            const QString fileName = fileItem-&gt;data(Qt::UserRole).toString();
            QImage image(fileName);
            if (!image.isNull())
                icon.addPixmap(QPixmap::fromImage(image), mode, state);
        }
    }
</db:programlisting>
<db:para>We also extract the image file's name using the <db:link xlink:href="qtablewidgetitem.xml#data">QTableWidgetItem::data</db:link>() function. This function takes a Qt::DataItemRole as an argument to retrieve the right data (remember that an item can hold several pieces of information) and returns it as a <db:link xlink:href="qvariant.xml">QVariant</db:link>. Then we use the <db:link xlink:href="qvariant.xml#toString">QVariant::toString</db:link>() function to get the file name as a <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
<db:para>To create a pixmap from the file, we need to first create an image and then convert this image into a pixmap using <db:link xlink:href="qpixmap.xml#fromImage">QPixmap::fromImage</db:link>(). Once we have the final pixmap, we add it, with its associated mode and state, to the <db:link xlink:href="qicon.xml">QIcon</db:link>'s set of available pixmaps.</db:para>
<db:programlisting language="cpp">    previewArea-&gt;setIcon(icon);
}
</db:programlisting>
<db:para>After running through the entire list of images, we change the icon of the preview area to the one we just created.</db:para>
<db:programlisting language="cpp">void MainWindow::removeAllImages()
{
    imagesTable-&gt;setRowCount(0);
    changeIcon();
}
</db:programlisting>
<db:para>In the removeAllImages() slot, we simply set the table widget's row count to zero, automatically removing all the images the user has loaded into the application. Then we update the set of pixmaps available to the preview area's icon using the changeIcon() slot.</db:para>
<db:mediaobject>
<db:alt>Screenshot of the images group box</db:alt>
<db:imageobject>
<db:imagedata fileref="images/icons_images_groupbox.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The createImagesGroupBox() function is implemented to simplify the constructor. The main purpose of the function is to create a <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link> that will keep track of the images the user has loaded into the application.</db:para>
<db:programlisting language="cpp">QWidget *MainWindow::createImagesGroupBox()
{
    QGroupBox *imagesGroupBox = new QGroupBox(tr(&quot;Images&quot;));

    imagesTable = new QTableWidget;
    imagesTable-&gt;setSelectionMode(QAbstractItemView::NoSelection);
    imagesTable-&gt;setItemDelegate(new ImageDelegate(this));
</db:programlisting>
<db:para>First we create a group box that will contain the table widget. Then we create a <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link> and customize it to suit our purposes.</db:para>
<db:para>We call <db:link xlink:href="qabstractitemview.xml#selectionMode-prop">QAbstractItemView::setSelectionMode</db:link>() to prevent the user from selecting items.</db:para>
<db:para>The <db:link xlink:href="qabstractitemview.xml#setItemDelegate">QAbstractItemView::setItemDelegate</db:link>() call sets the item delegate for the table widget. We create a ImageDelegate that we make the item delegate for our view.</db:para>
<db:para>The <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> class can be used to provide an editor for an item view class that is subclassed from <db:link xlink:href="qabstractitemview.xml">QAbstractItemView</db:link>. Using a delegate for this purpose allows the editing mechanism to be customized and developed independently from the model and view.</db:para>
<db:para>In this example we derive ImageDelegate from <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link>. <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> usually provides line editors, while our subclass ImageDelegate, provides comboboxes for the mode and state fields.</db:para>
<db:programlisting language="cpp">    QStringList labels;
    labels &lt;&lt; tr(&quot;Image&quot;) &lt;&lt; tr(&quot;Mode&quot;) &lt;&lt; tr(&quot;State&quot;);

    imagesTable-&gt;horizontalHeader()-&gt;setDefaultSectionSize(90);
    imagesTable-&gt;setColumnCount(3);
    imagesTable-&gt;setHorizontalHeaderLabels(labels);
    imagesTable-&gt;horizontalHeader()-&gt;setSectionResizeMode(0, QHeaderView::Stretch);
    imagesTable-&gt;horizontalHeader()-&gt;setSectionResizeMode(1, QHeaderView::Fixed);
    imagesTable-&gt;horizontalHeader()-&gt;setSectionResizeMode(2, QHeaderView::Fixed);
    imagesTable-&gt;verticalHeader()-&gt;hide();
</db:programlisting>
<db:para>Then we customize the <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link>'s horizontal header, and hide the vertical header.</db:para>
<db:programlisting language="cpp">    connect(imagesTable, &amp;QTableWidget::itemChanged,
            this, &amp;MainWindow::changeIcon);

    QVBoxLayout *layout = new QVBoxLayout(imagesGroupBox);
    layout-&gt;addWidget(imagesTable);
    return imagesGroupBox;
}
</db:programlisting>
<db:para>At the end, we connect the <db:link xlink:href="qtablewidget.xml#itemChanged">QTableWidget::itemChanged</db:link>() signal to the changeIcon() slot to ensure that the preview area is in sync with the image table.</db:para>
<db:mediaobject>
<db:alt>Screenshot of the icon size group box</db:alt>
<db:imageobject>
<db:imagedata fileref="images/icons_size_groupbox.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The createIconSizeGroupBox() function is called from the constructor. It creates the widgets controlling the size of the preview area's icon.</db:para>
<db:programlisting language="cpp">QWidget *MainWindow::createIconSizeGroupBox()
{
    QGroupBox *iconSizeGroupBox = new QGroupBox(tr(&quot;Icon Size&quot;));

    sizeButtonGroup = new QButtonGroup(this);
    sizeButtonGroup-&gt;setExclusive(true);

    typedef void (QButtonGroup::*QButtonGroupIntBoolSignal)(int, bool);
    connect(sizeButtonGroup, static_cast&lt;QButtonGroupIntBoolSignal&gt;(&amp;QButtonGroup::buttonToggled),
            this, &amp;MainWindow::changeSize);

    QRadioButton *smallRadioButton = new QRadioButton;
    sizeButtonGroup-&gt;addButton(smallRadioButton, QStyle::PM_SmallIconSize);
    QRadioButton *largeRadioButton = new QRadioButton;
    sizeButtonGroup-&gt;addButton(largeRadioButton, QStyle::PM_LargeIconSize);
    QRadioButton *toolBarRadioButton = new QRadioButton;
    sizeButtonGroup-&gt;addButton(toolBarRadioButton, QStyle::PM_ToolBarIconSize);
    QRadioButton *listViewRadioButton = new QRadioButton;
    sizeButtonGroup-&gt;addButton(listViewRadioButton, QStyle::PM_ListViewIconSize);
    QRadioButton *iconViewRadioButton = new QRadioButton;
    sizeButtonGroup-&gt;addButton(iconViewRadioButton, QStyle::PM_IconViewIconSize);
    QRadioButton *tabBarRadioButton = new QRadioButton;
    sizeButtonGroup-&gt;addButton(tabBarRadioButton, QStyle::PM_TabBarIconSize);
    QRadioButton *otherRadioButton = new QRadioButton(tr(&quot;Other:&quot;));
    sizeButtonGroup-&gt;addButton(otherRadioButton, OtherSize);
    otherSpinBox = new IconSizeSpinBox;
    otherSpinBox-&gt;setRange(8, 256);
    const QString spinBoxToolTip =
        tr(&quot;Enter a custom size within %1..%2&quot;)
           .arg(otherSpinBox-&gt;minimum()).arg(otherSpinBox-&gt;maximum());
    otherSpinBox-&gt;setValue(64);
    otherSpinBox-&gt;setToolTip(spinBoxToolTip);
    otherRadioButton-&gt;setToolTip(spinBoxToolTip);
</db:programlisting>
<db:para>First we create a group box that will contain all the widgets; then we create the radio buttons and the spin box. We add the radio buttons to an instance of <db:link xlink:href="qbuttongroup.xml">QButtonGroup</db:link>, using the value of the <db:link xlink:href="qstyle.xml#PixelMetric-enum">QStyle::PixelMetric</db:link> they represent as an integer id.</db:para>
<db:programlisting language="cpp">enum { OtherSize = QStyle::PM_CustomBase };
</db:programlisting>
<db:para>We introduce an enumeration constant OtherSize to represent a custom size.</db:para>
<db:para>The spin box is not a regular <db:link xlink:href="qspinbox.xml">QSpinBox</db:link> but an IconSizeSpinBox. The IconSizeSpinBox class inherits <db:link xlink:href="qspinbox.xml">QSpinBox</db:link> and reimplements two functions: <db:link xlink:href="qspinbox.xml#textFromValue">QSpinBox::textFromValue</db:link>() and <db:link xlink:href="qspinbox.xml#valueFromText">QSpinBox::valueFromText</db:link>(). The IconSizeSpinBox is designed to handle icon sizes, e.g., &quot;32 x 32&quot;, instead of plain integer values.</db:para>
<db:programlisting language="cpp">    typedef void (QSpinBox::*QSpinBoxIntSignal)(int);
    connect(otherSpinBox, static_cast&lt;QSpinBoxIntSignal&gt;(&amp;QSpinBox::valueChanged),
            this, &amp;MainWindow::triggerChangeSize);

    QHBoxLayout *otherSizeLayout = new QHBoxLayout;
    otherSizeLayout-&gt;addWidget(otherRadioButton);
    otherSizeLayout-&gt;addWidget(otherSpinBox);
    otherSizeLayout-&gt;addStretch();

    QGridLayout *layout = new QGridLayout(iconSizeGroupBox);
    layout-&gt;addWidget(smallRadioButton, 0, 0);
    layout-&gt;addWidget(largeRadioButton, 1, 0);
    layout-&gt;addWidget(toolBarRadioButton, 2, 0);
    layout-&gt;addWidget(listViewRadioButton, 0, 1);
    layout-&gt;addWidget(iconViewRadioButton, 1, 1);
    layout-&gt;addWidget(tabBarRadioButton, 2, 1);
    layout-&gt;addLayout(otherSizeLayout, 3, 0, 1, 2);
    layout-&gt;setRowStretch(4, 1);
    return iconSizeGroupBox;
}
</db:programlisting>
<db:para>Then we connect all of the radio buttons <db:link xlink:href="qabstractbutton.xml#toggled">toggled</db:link>() signals and the spin box's <db:link xlink:href="qspinbox.xml#valueChanged">valueChanged</db:link>() signal to the changeSize() slot to make sure that the size of the preview area's icon is updated whenever the user changes the icon size. In the end we put the widgets in a layout that we install on the group box.</db:para>
<db:programlisting language="cpp">void MainWindow::createActions()
{
    QMenu *fileMenu = menuBar()-&gt;addMenu(tr(&quot;&amp;File&quot;));

    addSampleImagesAct = new QAction(tr(&quot;Add &amp;Sample Images...&quot;), this);
    addSampleImagesAct-&gt;setShortcut(tr(&quot;Ctrl+A&quot;));
    connect(addSampleImagesAct, &amp;QAction::triggered, this, &amp;MainWindow::addSampleImages);
    fileMenu-&gt;addAction(addSampleImagesAct);

    addOtherImagesAct = new QAction(tr(&quot;&amp;Add Images...&quot;), this);
    addOtherImagesAct-&gt;setShortcut(QKeySequence::Open);
    connect(addOtherImagesAct, &amp;QAction::triggered, this, &amp;MainWindow::addOtherImages);
    fileMenu-&gt;addAction(addOtherImagesAct);

    removeAllImagesAct = new QAction(tr(&quot;&amp;Remove All Images&quot;), this);
    removeAllImagesAct-&gt;setShortcut(tr(&quot;Ctrl+R&quot;));
    connect(removeAllImagesAct, &amp;QAction::triggered,
            this, &amp;MainWindow::removeAllImages);
    fileMenu-&gt;addAction(removeAllImagesAct);

    fileMenu-&gt;addSeparator();

    QAction *exitAct = fileMenu-&gt;addAction(tr(&quot;&amp;Quit&quot;), this, &amp;QWidget::close);
    exitAct-&gt;setShortcuts(QKeySequence::Quit);

    QMenu *viewMenu = menuBar()-&gt;addMenu(tr(&quot;&amp;View&quot;));

    styleActionGroup = new QActionGroup(this);
    foreach (const QString &amp;styleName, QStyleFactory::keys()) {
        QAction *action = new QAction(tr(&quot;%1 Style&quot;).arg(styleName), styleActionGroup);
        action-&gt;setData(styleName);
        action-&gt;setCheckable(true);
        connect(action, &amp;QAction::triggered, this, &amp;MainWindow::changeStyle);
        viewMenu-&gt;addAction(action);
    }

    QMenu *settingsMenu = menuBar()-&gt;addMenu(tr(&quot;&amp;Settings&quot;));

    guessModeStateAct = new QAction(tr(&quot;&amp;Guess Image Mode/State&quot;), this);
    guessModeStateAct-&gt;setCheckable(true);
    guessModeStateAct-&gt;setChecked(true);
    settingsMenu-&gt;addAction(guessModeStateAct);

    nativeFileDialogAct = new QAction(tr(&quot;&amp;Use Native File Dialog&quot;), this);
    nativeFileDialogAct-&gt;setCheckable(true);
    nativeFileDialogAct-&gt;setChecked(true);
    settingsMenu-&gt;addAction(nativeFileDialogAct);

    QMenu *helpMenu = menuBar()-&gt;addMenu(tr(&quot;&amp;Help&quot;));
    helpMenu-&gt;addAction(tr(&quot;&amp;About&quot;), this, &amp;MainWindow::about);
    helpMenu-&gt;addAction(tr(&quot;About &amp;Qt&quot;), qApp, &amp;QApplication::aboutQt);
}
</db:programlisting>
<db:para>In the createActions() function we create and customize all the actions needed to implement the functionality associated with the menu entries in the application.</db:para>
<db:para>In particular we create the styleActionGroup based on the currently available GUI styles using <db:link xlink:href="qstylefactory.xml">QStyleFactory</db:link>. <db:link xlink:href="qstylefactory.xml#keys">QStyleFactory::keys</db:link>() returns a list of valid keys, typically including &quot;windows&quot; and &quot;fusion&quot;. Depending on the platform, &quot;windowsvista&quot; and &quot;macintosh&quot; may be available.</db:para>
<db:para>We create one action for each key, and adds the action to the action group. Also, for each action, we call <db:link xlink:href="qaction.xml#setData">QAction::setData</db:link>() with the style name. We will retrieve it later using <db:link xlink:href="qaction.xml#data">QAction::data</db:link>().</db:para>
<db:para>As we go along, we create the <db:guilabel>File</db:guilabel>, <db:guilabel>View</db:guilabel> and <db:guilabel>Help</db:guilabel> menus and add the actions to them.</db:para>
<db:para>The <db:link xlink:href="qmenu.xml">QMenu</db:link> class provides a menu widget for use in menu bars, context menus, and other popup menus. We put each menu in the application's menu bar, which we retrieve using <db:link xlink:href="qmainwindow.xml#menuBar">QMainWindow::menuBar</db:link>().</db:para>
<db:programlisting language="cpp">void MainWindow::createContextMenu()
{
    imagesTable-&gt;setContextMenuPolicy(Qt::ActionsContextMenu);
    imagesTable-&gt;addAction(addSampleImagesAct);
    imagesTable-&gt;addAction(addOtherImagesAct);
    imagesTable-&gt;addAction(removeAllImagesAct);
}
</db:programlisting>
<db:para>QWidgets have a <db:link xlink:href="qwidget.xml#contextMenuPolicy-prop">contextMenuPolicy</db:link> property that controls how the widget should behave when the user requests a context menu (e.g., by right-clicking). We set the <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link>'s context menu policy to <db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::ActionsContextMenu</db:link>, meaning that the <db:link xlink:href="qaction.xml">QAction</db:link>s associated with the widget should appear in its context menu.</db:para>
<db:para>Then we add the <db:guilabel>Add Image</db:guilabel> and <db:guilabel>Remove All Images</db:guilabel> actions to the table widget. They will then appear in the table widget's context menu.</db:para>
<db:programlisting language="cpp">void MainWindow::checkCurrentStyle()
{
    foreach (QAction *action, styleActionGroup-&gt;actions()) {
        QString styleName = action-&gt;data().toString();
        QScopedPointer&lt;QStyle&gt; candidate(QStyleFactory::create(styleName));
        Q_ASSERT(!candidate.isNull());
        if (candidate-&gt;metaObject()-&gt;className()
                == QApplication::style()-&gt;metaObject()-&gt;className()) {
            action-&gt;trigger();
            return;
        }
    }
}
</db:programlisting>
<db:para>In the checkCurrentStyle() function we go through the group of style actions, looking for the current GUI style.</db:para>
<db:para>For each action, we first extract the style name using <db:link xlink:href="qaction.xml#data">QAction::data</db:link>(). Since this is only a <db:link xlink:href="qstylefactory.xml">QStyleFactory</db:link> key (e.g., &quot;macintosh&quot;), we cannot compare it directly to the current style's class name. We need to create a <db:link xlink:href="qstyle.xml">QStyle</db:link> object using the static <db:link xlink:href="qstylefactory.xml#create">QStyleFactory::create</db:link>() function and compare the class name of the created <db:link xlink:href="qstyle.xml">QStyle</db:link> object with that of the current style. As soon as we are done with a <db:link xlink:href="qstyle.xml">QStyle</db:link> candidate, we delete it.</db:para>
<db:para>For all <db:link xlink:href="qobject.xml">QObject</db:link> subclasses that use the Q_OBJECT macro, the class name of an object is available through its <db:link xlink:href="qobject.xml#metaObject">meta-object</db:link>.</db:para>
<db:para>We can assume that the style is supported by <db:link xlink:href="qstylefactory.xml">QStyleFactory</db:link>, but to be on the safe side we use the Q_ASSERT() macro to make sure that <db:link xlink:href="qstylefactory.xml#create">QStyleFactory::create</db:link>() returned a valid pointer.</db:para>
<db:programlisting language="cpp">void MainWindow::show()
{
    QMainWindow::show();
    connect(windowHandle(), &amp;QWindow::screenChanged, this, &amp;MainWindow::screenChanged);
    screenChanged();
}
</db:programlisting>
<db:para>We overload the show() function to set up the updating of the current screen in screenChanged(). After calling <db:link xlink:href="qwidget.xml#show">QWidget::show</db:link>(), the <db:link xlink:href="qwindow.xml">QWindow</db:link> associated with the <db:link xlink:href="qwidget.xml">QWidget</db:link> is created and we can connect to its <db:link xlink:href="qwindow.xml#screenChanged">QWindow::screenChanged</db:link>() signal.</db:para>
</db:section>
<db:section xml:id="iconsizespinbox-class-definition">
<db:title>IconSizeSpinBox Class Definition</db:title>
<db:programlisting language="cpp">class IconSizeSpinBox : public QSpinBox
{
    Q_OBJECT

public:
    explicit IconSizeSpinBox(QWidget *parent = Q_NULLPTR);

    int valueFromText(const QString &amp;text) const override;
    QString textFromValue(int value) const override;
};
</db:programlisting>
<db:para>The IconSizeSpinBox class is a subclass of <db:link xlink:href="qspinbox.xml">QSpinBox</db:link>. A plain <db:link xlink:href="qspinbox.xml">QSpinBox</db:link> can only handle integers. But since we want to display the spin box's values in a more sophisticated way, we need to subclass <db:link xlink:href="qspinbox.xml">QSpinBox</db:link> and reimplement the <db:link xlink:href="qspinbox.xml#textFromValue">QSpinBox::textFromValue</db:link>() and <db:link xlink:href="qspinbox.xml#valueFromText">QSpinBox::valueFromText</db:link>() functions.</db:para>
<db:mediaobject>
<db:alt>Screenshot of the icon size spinbox</db:alt>
<db:imageobject>
<db:imagedata fileref="images/icons_size_spinbox.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
<db:section xml:id="iconsizespinbox-class-implementation">
<db:title>IconSizeSpinBox Class Implementation</db:title>
<db:programlisting language="cpp">IconSizeSpinBox::IconSizeSpinBox(QWidget *parent)
    : QSpinBox(parent)
{
}
</db:programlisting>
<db:para>The constructor is trivial.</db:para>
<db:programlisting language="cpp">QString IconSizeSpinBox::textFromValue(int value) const
{
    return tr(&quot;%1 x %1&quot;).arg(value);
}
</db:programlisting>
<db:para><db:link xlink:href="qspinbox.xml#textFromValue">QSpinBox::textFromValue</db:link>() is used by the spin box whenever it needs to display a value. The default implementation returns a base 10 representation of the value parameter.</db:para>
<db:para>Our reimplementation returns a <db:link xlink:href="qstring.xml">QString</db:link> of the form &quot;32 x 32&quot;.</db:para>
<db:programlisting language="cpp">int IconSizeSpinBox::valueFromText(const QString &amp;text) const
{
    static const QRegularExpression regExp(tr(&quot;(\\d+)(\\s*[xx]\\s*\\d+)?&quot;));
    Q_ASSERT(regExp.isValid());

    const QRegularExpressionMatch match = regExp.match(text);
    if (match.isValid())
        return match.captured(1).toInt();
    return 0;
}
</db:programlisting>
<db:para>The <db:link xlink:href="qspinbox.xml#valueFromText">QSpinBox::valueFromText</db:link>() function is used by the spin box whenever it needs to interpret text typed in by the user. Since we reimplement the textFromValue() function we also need to reimplement the valueFromText() function to interpret the parameter text and return the associated int value.</db:para>
<db:para>We parse the text using a regular expression (a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>). We define an expression that matches one or several digits, optionally followed by whitespace, an &quot;x&quot; or the times symbol, whitespace and one or several digits again.</db:para>
<db:para>The first digits of the regular expression are captured using parentheses. This enables us to use the <db:link xlink:href="qregexp.xml#cap">QRegExp::cap</db:link>() or <db:link xlink:href="qregexp.xml#capturedTexts">QRegExp::capturedTexts</db:link>() functions to extract the matched characters. If the first and second numbers of the spin box value differ (e.g., &quot;16 x 24&quot;), we use the first number.</db:para>
<db:para>When the user presses <db:guilabel>Enter</db:guilabel>, <db:link xlink:href="qspinbox.xml">QSpinBox</db:link> first calls <db:link xlink:href="qspinbox.xml#valueFromText">QSpinBox::valueFromText</db:link>() to interpret the text typed by the user, then <db:link xlink:href="qspinbox.xml#textFromValue">QSpinBox::textFromValue</db:link>() to present it in a canonical format (e.g., &quot;16 x 16&quot;).</db:para>
</db:section>
<db:section xml:id="imagedelegate-class-definition">
<db:title>ImageDelegate Class Definition</db:title>
<db:programlisting language="cpp">class ImageDelegate : public QItemDelegate
{
    Q_OBJECT

public:
    explicit ImageDelegate(QObject *parent = Q_NULLPTR);
</db:programlisting>
<db:para>The ImageDelegate class is a subclass of <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link>. The <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> class provides display and editing facilities for data items from a model. A single <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> object is responsible for all items displayed in a item view (in our case, a <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link>).</db:para>
<db:para>A <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> can be used to provide an editor for an item view class that is subclassed from <db:link xlink:href="qabstractitemview.xml">QAbstractItemView</db:link>. Using a delegate for this purpose allows the editing mechanism to be customized and developed independently from the model and view.</db:para>
<db:programlisting language="cpp">    QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &amp;option,
                          const QModelIndex &amp;index) const override;
    void setEditorData(QWidget *editor, const QModelIndex &amp;index) const override;
    void setModelData(QWidget *editor, QAbstractItemModel *model,
                      const QModelIndex &amp;index) const override;

</db:programlisting>
<db:para>The default implementation of <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> creates a <db:link xlink:href="qlineedit.xml">QLineEdit</db:link>. Since we want the editor to be a <db:link xlink:href="qcombobox.xml">QComboBox</db:link>, we need to subclass <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> and reimplement the <db:link xlink:href="qitemdelegate.xml#createEditor">QItemDelegate::createEditor</db:link>(), <db:link xlink:href="qitemdelegate.xml#setEditorData">QItemDelegate::setEditorData</db:link>() and <db:link xlink:href="qitemdelegate.xml#setModelData">QItemDelegate::setModelData</db:link>() functions.</db:para>
<db:programlisting language="cpp">private slots:
    void emitCommitData();
};
</db:programlisting>
<db:para>The emitCommitData() slot is used to emit the QImageDelegate::commitData() signal with the appropriate argument.</db:para>
</db:section>
<db:section xml:id="imagedelegate-class-implementation">
<db:title>ImageDelegate Class Implementation</db:title>
<db:programlisting language="cpp">ImageDelegate::ImageDelegate(QObject *parent)
    : QItemDelegate(parent)
{
}
</db:programlisting>
<db:para>The constructor is trivial.</db:para>
<db:programlisting language="cpp">QWidget *ImageDelegate::createEditor(QWidget *parent,
                                     const QStyleOptionViewItem &amp; /* option */,
                                     const QModelIndex &amp;index) const
{
    QComboBox *comboBox = new QComboBox(parent);
    if (index.column() == 1)
        comboBox-&gt;addItems(IconPreviewArea::iconModeNames());
    else if (index.column() == 2)
        comboBox-&gt;addItems(IconPreviewArea::iconStateNames());

    typedef void (QComboBox::*QComboBoxIntSignal)(int);
    connect(comboBox, static_cast&lt;QComboBoxIntSignal&gt;(&amp;QComboBox::activated),
            this, &amp;ImageDelegate::emitCommitData);

    return comboBox;
}
</db:programlisting>
<db:para>The default <db:link xlink:href="qitemdelegate.xml#createEditor">QItemDelegate::createEditor</db:link>() implementation returns the widget used to edit the item specified by the model and item index for editing. The parent widget and style option are used to control the appearance of the editor widget.</db:para>
<db:para>Our reimplementation creates and populates a combobox instead of the default line edit. The contents of the combobox depends on the column in the table for which the editor is requested. Column 1 contains the <db:link xlink:href="qicon.xml">QIcon</db:link> modes, whereas column 2 contains the <db:link xlink:href="qicon.xml">QIcon</db:link> states.</db:para>
<db:para>In addition, we connect the combobox's <db:link xlink:href="qcombobox.xml#activated">activated</db:link>() signal to the emitCommitData() slot to emit the <db:link xlink:href="qabstractitemdelegate.xml#commitData">QAbstractItemDelegate::commitData</db:link>() signal whenever the user chooses an item using the combobox. This ensures that the rest of the application notices the change and updates itself.</db:para>
<db:programlisting language="cpp">void ImageDelegate::setEditorData(QWidget *editor,
                                  const QModelIndex &amp;index) const
{
    QComboBox *comboBox = qobject_cast&lt;QComboBox *&gt;(editor);
    if (!comboBox)
        return;

    int pos = comboBox-&gt;findText(index.model()-&gt;data(index).toString(),
                                 Qt::MatchExactly);
    comboBox-&gt;setCurrentIndex(pos);
}
</db:programlisting>
<db:para>The <db:link xlink:href="qitemdelegate.xml#setEditorData">QItemDelegate::setEditorData</db:link>() function is used by <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link> to transfer data from a <db:link xlink:href="qtablewidgetitem.xml">QTableWidgetItem</db:link> to the editor. The data is stored as a string; we use <db:link xlink:href="qcombobox.xml#findText">QComboBox::findText</db:link>() to locate it in the combobox.</db:para>
<db:para>Delegates work in terms of models, not items. This makes it possible to use them with any item view class (e.g., <db:link xlink:href="qlistview.xml">QListView</db:link>, <db:link xlink:href="qlistwidget.xml">QListWidget</db:link>, <db:link xlink:href="qtreeview.xml">QTreeView</db:link>, etc.). The transition between model and items is done implicitly by <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link>; we don't need to worry about it.</db:para>
<db:programlisting language="cpp">void ImageDelegate::setModelData(QWidget *editor, QAbstractItemModel *model,
                                 const QModelIndex &amp;index) const
{
    QComboBox *comboBox = qobject_cast&lt;QComboBox *&gt;(editor);
    if (!comboBox)
        return;

    model-&gt;setData(index, comboBox-&gt;currentText());
}
</db:programlisting>
<db:para>The <db:link xlink:href="qitemdelegate.xml#setEditorData">QItemDelegate::setEditorData</db:link>() function is used by <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link> to transfer data back from the editor to the <db:link xlink:href="qtablewidgetitem.xml">QTableWidgetItem</db:link>.</db:para>
<db:programlisting language="cpp">void ImageDelegate::emitCommitData()
{
    emit commitData(qobject_cast&lt;QWidget *&gt;(sender()));
}
</db:programlisting>
<db:para>The emitCommitData() slot simply emit the <db:link xlink:href="qabstractitemdelegate.xml#commitData">QAbstractItemDelegate::commitData</db:link>() signal for the editor that triggered the slot. This signal must be emitted when the editor widget has completed editing the data, and wants to write it back into the model.</db:para>
</db:section>
<db:section xml:id="the-implementation-of-the-function-main">
<db:title>The Implementation of the Function main()</db:title>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    QCoreApplication::setApplicationName(MainWindow::tr(&quot;Icons&quot;));
    QCoreApplication::setApplicationVersion(QT_VERSION_STR);
    QCommandLineParser commandLineParser;
    commandLineParser.setSingleDashWordOptionMode(QCommandLineParser::ParseAsLongOptions);
    commandLineParser.addHelpOption();
    commandLineParser.addVersionOption();
    QCommandLineOption noHighDpiPixmapOption(&quot;no-highdpi-pixmaps&quot;,
                                             &quot;Disable High DPI image loading (Qt::AA_UseHighDpiPixmaps)&quot;);
    commandLineParser.addOption(noHighDpiPixmapOption);
        commandLineParser.addPositionalArgument(MainWindow::tr(&quot;[file]&quot;), MainWindow::tr(&quot;Icon file(s) to open.&quot;));
    commandLineParser.process(QCoreApplication::arguments());

    if (!commandLineParser.isSet(noHighDpiPixmapOption))
        QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);

    MainWindow mainWin;
    if (!commandLineParser.positionalArguments().isEmpty())
        mainWin.loadImages(commandLineParser.positionalArguments());

    const QRect availableGeometry = QApplication::desktop()-&gt;availableGeometry(&amp;mainWin);
    mainWin.resize(availableGeometry.width() / 2, availableGeometry.height() * 2 / 3);
    mainWin.move((availableGeometry.width() - mainWin.width()) / 2, (availableGeometry.height() - mainWin.height()) / 2);

    mainWin.show();
    return app.exec();
}
</db:programlisting>
<db:para>We use <db:link xlink:href="qcommandlineparser.xml">QCommandLineParser</db:link> to handle any command line options or parameters passed to the application. Then, we resize the main window according to the available screen geometry and show it.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/iconpreviewarea.cpp">widgets/icons/iconpreviewarea.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/iconpreviewarea.h">widgets/icons/iconpreviewarea.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/icons.pro">widgets/icons/icons.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/iconsizespinbox.cpp">widgets/icons/iconsizespinbox.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/iconsizespinbox.h">widgets/icons/iconsizespinbox.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/imagedelegate.cpp">widgets/icons/imagedelegate.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/imagedelegate.h">widgets/icons/imagedelegate.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/main.cpp">widgets/icons/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/mainwindow.cpp">widgets/icons/mainwindow.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/mainwindow.h">widgets/icons/mainwindow.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Images:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/designer.png">widgets/icons/images/designer.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/find_disabled.png">widgets/icons/images/find_disabled.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/find_normal.png">widgets/icons/images/find_normal.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/monkey_off_128x128.png">widgets/icons/images/monkey_off_128x128.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/monkey_off_16x16.png">widgets/icons/images/monkey_off_16x16.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/monkey_off_32x32.png">widgets/icons/images/monkey_off_32x32.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/monkey_off_64x64.png">widgets/icons/images/monkey_off_64x64.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/monkey_on_128x128.png">widgets/icons/images/monkey_on_128x128.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/monkey_on_16x16.png">widgets/icons/images/monkey_on_16x16.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/monkey_on_32x32.png">widgets/icons/images/monkey_on_32x32.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/monkey_on_64x64.png">widgets/icons/images/monkey_on_64x64.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/qt_extended_16x16.png">widgets/icons/images/qt_extended_16x16.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/qt_extended_32x32.png">widgets/icons/images/qt_extended_32x32.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/icons/images/qt_extended_48x48.png">widgets/icons/images/qt_extended_48x48.png</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:section></db:article>
