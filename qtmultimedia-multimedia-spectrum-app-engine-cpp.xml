<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Spectrum Example</db:title>
<db:productname>QtMultimedia</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Multimedia Documentation</db:titleabbrev>
<db:abstract>
<db:para>Analyzing a raw audio stream using the FFTReal library.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2017 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;engine.h&quot;
#include &quot;tonegenerator.h&quot;
#include &quot;utils.h&quot;

#include &amp;lt;math.h&amp;gt;

#include &amp;lt;QAudioInput&amp;gt;
#include &amp;lt;QAudioOutput&amp;gt;
#include &amp;lt;QCoreApplication&amp;gt;
#include &amp;lt;QDebug&amp;gt;
#include &amp;lt;QFile&amp;gt;
#include &amp;lt;QMetaObject&amp;gt;
#include &amp;lt;QSet&amp;gt;
#include &amp;lt;QThread&amp;gt;

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

const qint64 BufferDurationUs       = 10 * 1000000;
const int    NotifyIntervalMs       = 100;

// Size of the level calculation window in microseconds
const int    LevelWindowUs          = 0.1 * 1000000;

//-----------------------------------------------------------------------------
// Constructor and destructor
//-----------------------------------------------------------------------------

Engine::Engine(QObject *parent)
    :   QObject(parent)
    ,   m_mode(QAudio::AudioInput)
    ,   m_state(QAudio::StoppedState)
    ,   m_generateTone(false)
    ,   m_file(0)
    ,   m_analysisFile(0)
    ,   m_availableAudioInputDevices
            (QAudioDeviceInfo::availableDevices(QAudio::AudioInput))
    ,   m_audioInputDevice(QAudioDeviceInfo::defaultInputDevice())
    ,   m_audioInput(0)
    ,   m_audioInputIODevice(0)
    ,   m_recordPosition(0)
    ,   m_availableAudioOutputDevices
            (QAudioDeviceInfo::availableDevices(QAudio::AudioOutput))
    ,   m_audioOutputDevice(QAudioDeviceInfo::defaultOutputDevice())
    ,   m_audioOutput(0)
    ,   m_playPosition(0)
    ,   m_bufferPosition(0)
    ,   m_bufferLength(0)
    ,   m_dataLength(0)
    ,   m_levelBufferLength(0)
    ,   m_rmsLevel(0.0)
    ,   m_peakLevel(0.0)
    ,   m_spectrumBufferLength(0)
    ,   m_spectrumAnalyser()
    ,   m_spectrumPosition(0)
    ,   m_count(0)
{
    qRegisterMetaType&amp;lt;FrequencySpectrum&amp;gt;(&quot;FrequencySpectrum&quot;);
    qRegisterMetaType&amp;lt;WindowFunction&amp;gt;(&quot;WindowFunction&quot;);
    connect(&amp;amp;m_spectrumAnalyser, QOverload&amp;lt;const FrequencySpectrum&amp;amp;&amp;gt;::of(&amp;amp;SpectrumAnalyser::spectrumChanged),
            this, QOverload&amp;lt;const FrequencySpectrum&amp;amp;&amp;gt;::of(&amp;amp;Engine::spectrumChanged));

    // This code might misinterpret things like &quot;-something -category&quot;.  But
    // it's unlikely that that needs to be supported so we'll let it go.
    QStringList arguments = QCoreApplication::instance()-&amp;gt;arguments();
    for (int i = 0; i &amp;lt; arguments.count(); ++i) {
        if (arguments.at(i) == QStringLiteral(&quot;--&quot;))
            break;

        if (arguments.at(i) == QStringLiteral(&quot;-category&quot;)
                || arguments.at(i) == QStringLiteral(&quot;--category&quot;)) {
            ++i;
            if (i &amp;lt; arguments.count())
                m_audioOutputCategory = arguments.at(i);
            else
                --i;
        }
    }

    initialize();

#ifdef DUMP_DATA
    createOutputDir();
#endif

#ifdef DUMP_SPECTRUM
    m_spectrumAnalyser.setOutputPath(outputPath());
#endif
}

Engine::~Engine()
{

}

//-----------------------------------------------------------------------------
// Public functions
//-----------------------------------------------------------------------------

bool Engine::loadFile(const QString &amp;amp;fileName)
{
    reset();
    bool result = false;
    Q_ASSERT(!m_generateTone);
    Q_ASSERT(!m_file);
    Q_ASSERT(!fileName.isEmpty());
    m_file = new WavFile(this);
    if (m_file-&amp;gt;open(fileName)) {
        if (isPCMS16LE(m_file-&amp;gt;fileFormat())) {
            result = initialize();
        } else {
            emit errorMessage(tr(&quot;Audio format not supported&quot;),
                              formatToString(m_file-&amp;gt;fileFormat()));
        }
    } else {
        emit errorMessage(tr(&quot;Could not open file&quot;), fileName);
    }
    if (result) {
        m_analysisFile = new WavFile(this);
        m_analysisFile-&amp;gt;open(fileName);
    }
    return result;
}

bool Engine::generateTone(const Tone &amp;amp;tone)
{
    reset();
    Q_ASSERT(!m_generateTone);
    Q_ASSERT(!m_file);
    m_generateTone = true;
    m_tone = tone;
    ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::generateTone&quot;
                 &amp;lt;&amp;lt; &quot;startFreq&quot; &amp;lt;&amp;lt; m_tone.startFreq
                 &amp;lt;&amp;lt; &quot;endFreq&quot; &amp;lt;&amp;lt; m_tone.endFreq
                 &amp;lt;&amp;lt; &quot;amp&quot; &amp;lt;&amp;lt; m_tone.amplitude;
    return initialize();
}

bool Engine::generateSweptTone(qreal amplitude)
{
    Q_ASSERT(!m_generateTone);
    Q_ASSERT(!m_file);
    m_generateTone = true;
    m_tone.startFreq = 1;
    m_tone.endFreq = 0;
    m_tone.amplitude = amplitude;
    ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::generateSweptTone&quot;
                 &amp;lt;&amp;lt; &quot;startFreq&quot; &amp;lt;&amp;lt; m_tone.startFreq
                 &amp;lt;&amp;lt; &quot;amp&quot; &amp;lt;&amp;lt; m_tone.amplitude;
    return initialize();
}

bool Engine::initializeRecord()
{
    reset();
    ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::initializeRecord&quot;;
    Q_ASSERT(!m_generateTone);
    Q_ASSERT(!m_file);
    m_generateTone = false;
    m_tone = SweptTone();
    return initialize();
}

qint64 Engine::bufferLength() const
{
    return m_file ? m_file-&amp;gt;size() : m_bufferLength;
}

void Engine::setWindowFunction(WindowFunction type)
{
    m_spectrumAnalyser.setWindowFunction(type);
}

//-----------------------------------------------------------------------------
// Public slots
//-----------------------------------------------------------------------------

void Engine::startRecording()
{
    if (m_audioInput) {
        if (QAudio::AudioInput == m_mode &amp;amp;&amp;amp;
            QAudio::SuspendedState == m_state) {
            m_audioInput-&amp;gt;resume();
        } else {
            m_spectrumAnalyser.cancelCalculation();
            spectrumChanged(0, 0, FrequencySpectrum());

            m_buffer.fill(0);
            setRecordPosition(0, true);
            stopPlayback();
            m_mode = QAudio::AudioInput;
            connect(m_audioInput, &amp;amp;QAudioInput::stateChanged,
                    this, &amp;amp;Engine::audioStateChanged);
            connect(m_audioInput, &amp;amp;QAudioInput::notify,
                    this, &amp;amp;Engine::audioNotify);

            m_count = 0;
            m_dataLength = 0;
            emit dataLengthChanged(0);
            m_audioInputIODevice = m_audioInput-&amp;gt;start();
            connect(m_audioInputIODevice, &amp;amp;QIODevice::readyRead,
                    this, &amp;amp;Engine::audioDataReady);
        }
    }
}

void Engine::startPlayback()
{
    if (m_audioOutput) {
        if (QAudio::AudioOutput == m_mode &amp;amp;&amp;amp;
            QAudio::SuspendedState == m_state) {
#ifdef Q_OS_WIN
            // The Windows backend seems to internally go back into ActiveState
            // while still returning SuspendedState, so to ensure that it doesn't
            // ignore the resume() call, we first re-suspend
            m_audioOutput-&amp;gt;suspend();
#endif
            m_audioOutput-&amp;gt;resume();
        } else {
            m_spectrumAnalyser.cancelCalculation();
            spectrumChanged(0, 0, FrequencySpectrum());
            setPlayPosition(0, true);
            stopRecording();
            m_mode = QAudio::AudioOutput;
            connect(m_audioOutput, &amp;amp;QAudioOutput::stateChanged,
                    this, &amp;amp;Engine::audioStateChanged);
            connect(m_audioOutput, &amp;amp;QAudioOutput::notify,
                    this, &amp;amp;Engine::audioNotify);

            m_count = 0;
            if (m_file) {
                m_file-&amp;gt;seek(0);
                m_bufferPosition = 0;
                m_dataLength = 0;
                m_audioOutput-&amp;gt;start(m_file);
            } else {
                m_audioOutputIODevice.close();
                m_audioOutputIODevice.setBuffer(&amp;amp;m_buffer);
                m_audioOutputIODevice.open(QIODevice::ReadOnly);
                m_audioOutput-&amp;gt;start(&amp;amp;m_audioOutputIODevice);
            }
        }
    }
}

void Engine::suspend()
{
    if (QAudio::ActiveState == m_state ||
        QAudio::IdleState == m_state) {
        switch (m_mode) {
        case QAudio::AudioInput:
            m_audioInput-&amp;gt;suspend();
            break;
        case QAudio::AudioOutput:
            m_audioOutput-&amp;gt;suspend();
            break;
        }
    }
}

void Engine::setAudioInputDevice(const QAudioDeviceInfo &amp;amp;device)
{
    if (device.deviceName() != m_audioInputDevice.deviceName()) {
        m_audioInputDevice = device;
        initialize();
    }
}

void Engine::setAudioOutputDevice(const QAudioDeviceInfo &amp;amp;device)
{
    if (device.deviceName() != m_audioOutputDevice.deviceName()) {
        m_audioOutputDevice = device;
        initialize();
    }
}

//-----------------------------------------------------------------------------
// Private slots
//-----------------------------------------------------------------------------

void Engine::audioNotify()
{
    switch (m_mode) {
    case QAudio::AudioInput: {
            const qint64 recordPosition = qMin(m_bufferLength, audioLength(m_format, m_audioInput-&amp;gt;processedUSecs()));
            setRecordPosition(recordPosition);
            const qint64 levelPosition = m_dataLength - m_levelBufferLength;
            if (levelPosition &amp;gt;= 0)
                calculateLevel(levelPosition, m_levelBufferLength);
            if (m_dataLength &amp;gt;= m_spectrumBufferLength) {
                const qint64 spectrumPosition = m_dataLength - m_spectrumBufferLength;
                calculateSpectrum(spectrumPosition);
            }
            emit bufferChanged(0, m_dataLength, m_buffer);
        }
        break;
    case QAudio::AudioOutput: {
            const qint64 playPosition = audioLength(m_format, m_audioOutput-&amp;gt;processedUSecs());
            setPlayPosition(qMin(bufferLength(), playPosition));
            const qint64 levelPosition = playPosition - m_levelBufferLength;
            const qint64 spectrumPosition = playPosition - m_spectrumBufferLength;
            if (m_file) {
                if (levelPosition &amp;gt; m_bufferPosition ||
                    spectrumPosition &amp;gt; m_bufferPosition ||
                    qMax(m_levelBufferLength, m_spectrumBufferLength) &amp;gt; m_dataLength) {
                    m_bufferPosition = 0;
                    m_dataLength = 0;
                    // Data needs to be read into m_buffer in order to be analysed
                    const qint64 readPos = qMax(qint64(0), qMin(levelPosition, spectrumPosition));
                    const qint64 readEnd = qMin(m_analysisFile-&amp;gt;size(), qMax(levelPosition + m_levelBufferLength, spectrumPosition + m_spectrumBufferLength));
                    const qint64 readLen = readEnd - readPos + audioLength(m_format, WaveformWindowDuration);
                    qDebug() &amp;lt;&amp;lt; &quot;Engine::audioNotify [1]&quot;
                             &amp;lt;&amp;lt; &quot;analysisFileSize&quot; &amp;lt;&amp;lt; m_analysisFile-&amp;gt;size()
                             &amp;lt;&amp;lt; &quot;readPos&quot; &amp;lt;&amp;lt; readPos
                             &amp;lt;&amp;lt; &quot;readLen&quot; &amp;lt;&amp;lt; readLen;
                    if (m_analysisFile-&amp;gt;seek(readPos + m_analysisFile-&amp;gt;headerLength())) {
                        m_buffer.resize(readLen);
                        m_bufferPosition = readPos;
                        m_dataLength = m_analysisFile-&amp;gt;read(m_buffer.data(), readLen);
                        qDebug() &amp;lt;&amp;lt; &quot;Engine::audioNotify [2]&quot; &amp;lt;&amp;lt; &quot;bufferPosition&quot; &amp;lt;&amp;lt; m_bufferPosition &amp;lt;&amp;lt; &quot;dataLength&quot; &amp;lt;&amp;lt; m_dataLength;
                    } else {
                        qDebug() &amp;lt;&amp;lt; &quot;Engine::audioNotify [2]&quot; &amp;lt;&amp;lt; &quot;file seek error&quot;;
                    }
                    emit bufferChanged(m_bufferPosition, m_dataLength, m_buffer);
                }
            } else {
                if (playPosition &amp;gt;= m_dataLength)
                    stopPlayback();
            }
            if (levelPosition &amp;gt;= 0 &amp;amp;&amp;amp; levelPosition + m_levelBufferLength &amp;lt; m_bufferPosition + m_dataLength)
                calculateLevel(levelPosition, m_levelBufferLength);
            if (spectrumPosition &amp;gt;= 0 &amp;amp;&amp;amp; spectrumPosition + m_spectrumBufferLength &amp;lt; m_bufferPosition + m_dataLength)
                calculateSpectrum(spectrumPosition);
        }
        break;
    }
}

void Engine::audioStateChanged(QAudio::State state)
{
    ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::audioStateChanged from&quot; &amp;lt;&amp;lt; m_state
                 &amp;lt;&amp;lt; &quot;to&quot; &amp;lt;&amp;lt; state;

    if (QAudio::IdleState == state &amp;amp;&amp;amp; m_file &amp;amp;&amp;amp; m_file-&amp;gt;pos() == m_file-&amp;gt;size()) {
        stopPlayback();
    } else {
        if (QAudio::StoppedState == state) {
            // Check error
            QAudio::Error error = QAudio::NoError;
            switch (m_mode) {
            case QAudio::AudioInput:
                error = m_audioInput-&amp;gt;error();
                break;
            case QAudio::AudioOutput:
                error = m_audioOutput-&amp;gt;error();
                break;
            }
            if (QAudio::NoError != error) {
                reset();
                return;
            }
        }
        setState(state);
    }
}

void Engine::audioDataReady()
{
    Q_ASSERT(0 == m_bufferPosition);
    const qint64 bytesReady = m_audioInput-&amp;gt;bytesReady();
    const qint64 bytesSpace = m_buffer.size() - m_dataLength;
    const qint64 bytesToRead = qMin(bytesReady, bytesSpace);

    const qint64 bytesRead = m_audioInputIODevice-&amp;gt;read(
                                       m_buffer.data() + m_dataLength,
                                       bytesToRead);

    if (bytesRead) {
        m_dataLength += bytesRead;
        emit dataLengthChanged(dataLength());
    }

    if (m_buffer.size() == m_dataLength)
        stopRecording();
}

void Engine::spectrumChanged(const FrequencySpectrum &amp;amp;spectrum)
{
    ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::spectrumChanged&quot; &amp;lt;&amp;lt; &quot;pos&quot; &amp;lt;&amp;lt; m_spectrumPosition;
    emit spectrumChanged(m_spectrumPosition, m_spectrumBufferLength, spectrum);
}

//-----------------------------------------------------------------------------
// Private functions
//-----------------------------------------------------------------------------

void Engine::resetAudioDevices()
{
    delete m_audioInput;
    m_audioInput = 0;
    m_audioInputIODevice = 0;
    setRecordPosition(0);
    delete m_audioOutput;
    m_audioOutput = 0;
    setPlayPosition(0);
    m_spectrumPosition = 0;
    setLevel(0.0, 0.0, 0);
}

void Engine::reset()
{
    stopRecording();
    stopPlayback();
    setState(QAudio::AudioInput, QAudio::StoppedState);
    setFormat(QAudioFormat());
    m_generateTone = false;
    delete m_file;
    m_file = 0;
    delete m_analysisFile;
    m_analysisFile = 0;
    m_buffer.clear();
    m_bufferPosition = 0;
    m_bufferLength = 0;
    m_dataLength = 0;
    emit dataLengthChanged(0);
    resetAudioDevices();
}

bool Engine::initialize()
{
    bool result = false;

    QAudioFormat format = m_format;

    if (selectFormat()) {
        if (m_format != format) {
            resetAudioDevices();
            if (m_file) {
                emit bufferLengthChanged(bufferLength());
                emit dataLengthChanged(dataLength());
                emit bufferChanged(0, 0, m_buffer);
                setRecordPosition(bufferLength());
                result = true;
            } else {
                m_bufferLength = audioLength(m_format, BufferDurationUs);
                m_buffer.resize(m_bufferLength);
                m_buffer.fill(0);
                emit bufferLengthChanged(bufferLength());
                if (m_generateTone) {
                    if (0 == m_tone.endFreq) {
                        const qreal nyquist = nyquistFrequency(m_format);
                        m_tone.endFreq = qMin(qreal(SpectrumHighFreq), nyquist);
                    }
                    // Call function defined in utils.h, at global scope
                    ::generateTone(m_tone, m_format, m_buffer);
                    m_dataLength = m_bufferLength;
                    emit dataLengthChanged(dataLength());
                    emit bufferChanged(0, m_dataLength, m_buffer);
                    setRecordPosition(m_bufferLength);
                    result = true;
                } else {
                    emit bufferChanged(0, 0, m_buffer);
                    m_audioInput = new QAudioInput(m_audioInputDevice, m_format, this);
                    m_audioInput-&amp;gt;setNotifyInterval(NotifyIntervalMs);
                    result = true;
                }
            }
            m_audioOutput = new QAudioOutput(m_audioOutputDevice, m_format, this);
            m_audioOutput-&amp;gt;setNotifyInterval(NotifyIntervalMs);
            m_audioOutput-&amp;gt;setCategory(m_audioOutputCategory);
        }
    } else {
        if (m_file)
            emit errorMessage(tr(&quot;Audio format not supported&quot;),
                              formatToString(m_format));
        else if (m_generateTone)
            emit errorMessage(tr(&quot;No suitable format found&quot;), &quot;&quot;);
        else
            emit errorMessage(tr(&quot;No common input / output format found&quot;), &quot;&quot;);
    }

    ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::initialize&quot; &amp;lt;&amp;lt; &quot;m_bufferLength&quot; &amp;lt;&amp;lt; m_bufferLength;
    ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::initialize&quot; &amp;lt;&amp;lt; &quot;m_dataLength&quot; &amp;lt;&amp;lt; m_dataLength;
    ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::initialize&quot; &amp;lt;&amp;lt; &quot;format&quot; &amp;lt;&amp;lt; m_format;
    ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::initialize&quot; &amp;lt;&amp;lt; &quot;m_audioOutputCategory&quot; &amp;lt;&amp;lt; m_audioOutputCategory;

    return result;
}

bool Engine::selectFormat()
{
    bool foundSupportedFormat = false;

    if (m_file || QAudioFormat() != m_format) {
        QAudioFormat format = m_format;
        if (m_file)
            // Header is read from the WAV file; just need to check whether
            // it is supported by the audio output device
            format = m_file-&amp;gt;fileFormat();
        if (m_audioOutputDevice.isFormatSupported(format)) {
            setFormat(format);
            foundSupportedFormat = true;
        }
    } else {

        QList&amp;lt;int&amp;gt; sampleRatesList;
    #ifdef Q_OS_WIN
        // The Windows audio backend does not correctly report format support
        // (see QTBUG-9100).  Furthermore, although the audio subsystem captures
        // at 11025Hz, the resulting audio is corrupted.
        sampleRatesList += 8000;
    #endif

        if (!m_generateTone)
            sampleRatesList += m_audioInputDevice.supportedSampleRates();

        sampleRatesList += m_audioOutputDevice.supportedSampleRates();
        sampleRatesList = sampleRatesList.toSet().toList(); // remove duplicates
        qSort(sampleRatesList);
        ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::initialize frequenciesList&quot; &amp;lt;&amp;lt; sampleRatesList;

        QList&amp;lt;int&amp;gt; channelsList;
        channelsList += m_audioInputDevice.supportedChannelCounts();
        channelsList += m_audioOutputDevice.supportedChannelCounts();
        channelsList = channelsList.toSet().toList();
        qSort(channelsList);
        ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::initialize channelsList&quot; &amp;lt;&amp;lt; channelsList;

        QAudioFormat format;
        format.setByteOrder(QAudioFormat::LittleEndian);
        format.setCodec(&quot;audio/pcm&quot;);
        format.setSampleSize(16);
        format.setSampleType(QAudioFormat::SignedInt);
        int sampleRate, channels;
        foreach (sampleRate, sampleRatesList) {
            if (foundSupportedFormat)
                break;
            format.setSampleRate(sampleRate);
            foreach (channels, channelsList) {
                format.setChannelCount(channels);
                const bool inputSupport = m_generateTone ||
                                          m_audioInputDevice.isFormatSupported(format);
                const bool outputSupport = m_audioOutputDevice.isFormatSupported(format);
                ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::initialize checking &quot; &amp;lt;&amp;lt; format
                             &amp;lt;&amp;lt; &quot;input&quot; &amp;lt;&amp;lt; inputSupport
                             &amp;lt;&amp;lt; &quot;output&quot; &amp;lt;&amp;lt; outputSupport;
                if (inputSupport &amp;amp;&amp;amp; outputSupport) {
                    foundSupportedFormat = true;
                    break;
                }
            }
        }

        if (!foundSupportedFormat)
            format = QAudioFormat();

        setFormat(format);
    }

    return foundSupportedFormat;
}

void Engine::stopRecording()
{
    if (m_audioInput) {
        m_audioInput-&amp;gt;stop();
        QCoreApplication::instance()-&amp;gt;processEvents();
        m_audioInput-&amp;gt;disconnect();
    }
    m_audioInputIODevice = 0;

#ifdef DUMP_AUDIO
    dumpData();
#endif
}

void Engine::stopPlayback()
{
    if (m_audioOutput) {
        m_audioOutput-&amp;gt;stop();
        QCoreApplication::instance()-&amp;gt;processEvents();
        m_audioOutput-&amp;gt;disconnect();
        setPlayPosition(0);
    }
}

void Engine::setState(QAudio::State state)
{
    const bool changed = (m_state != state);
    m_state = state;
    if (changed)
        emit stateChanged(m_mode, m_state);
}

void Engine::setState(QAudio::Mode mode, QAudio::State state)
{
    const bool changed = (m_mode != mode || m_state != state);
    m_mode = mode;
    m_state = state;
    if (changed)
        emit stateChanged(m_mode, m_state);
}

void Engine::setRecordPosition(qint64 position, bool forceEmit)
{
    const bool changed = (m_recordPosition != position);
    m_recordPosition = position;
    if (changed || forceEmit)
        emit recordPositionChanged(m_recordPosition);
}

void Engine::setPlayPosition(qint64 position, bool forceEmit)
{
    const bool changed = (m_playPosition != position);
    m_playPosition = position;
    if (changed || forceEmit)
        emit playPositionChanged(m_playPosition);
}

void Engine::calculateLevel(qint64 position, qint64 length)
{
#ifdef DISABLE_LEVEL
    Q_UNUSED(position)
    Q_UNUSED(length)
#else
    Q_ASSERT(position + length &amp;lt;= m_bufferPosition + m_dataLength);

    qreal peakLevel = 0.0;

    qreal sum = 0.0;
    const char *ptr = m_buffer.constData() + position - m_bufferPosition;
    const char *const end = ptr + length;
    while (ptr &amp;lt; end) {
        const qint16 value = *reinterpret_cast&amp;lt;const qint16*&amp;gt;(ptr);
        const qreal fracValue = pcmToReal(value);
        peakLevel = qMax(peakLevel, fracValue);
        sum += fracValue * fracValue;
        ptr += 2;
    }
    const int numSamples = length / 2;
    qreal rmsLevel = sqrt(sum / numSamples);

    rmsLevel = qMax(qreal(0.0), rmsLevel);
    rmsLevel = qMin(qreal(1.0), rmsLevel);
    setLevel(rmsLevel, peakLevel, numSamples);

    ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::calculateLevel&quot; &amp;lt;&amp;lt; &quot;pos&quot; &amp;lt;&amp;lt; position &amp;lt;&amp;lt; &quot;len&quot; &amp;lt;&amp;lt; length
                 &amp;lt;&amp;lt; &quot;rms&quot; &amp;lt;&amp;lt; rmsLevel &amp;lt;&amp;lt; &quot;peak&quot; &amp;lt;&amp;lt; peakLevel;
#endif
}

void Engine::calculateSpectrum(qint64 position)
{
#ifdef DISABLE_SPECTRUM
    Q_UNUSED(position)
#else
    Q_ASSERT(position + m_spectrumBufferLength &amp;lt;= m_bufferPosition + m_dataLength);
    Q_ASSERT(0 == m_spectrumBufferLength % 2); // constraint of FFT algorithm

    // QThread::currentThread is marked 'for internal use only', but
    // we're only using it for debug output here, so it's probably OK :)
    ENGINE_DEBUG &amp;lt;&amp;lt; &quot;Engine::calculateSpectrum&quot; &amp;lt;&amp;lt; QThread::currentThread()
                 &amp;lt;&amp;lt; &quot;count&quot; &amp;lt;&amp;lt; m_count &amp;lt;&amp;lt; &quot;pos&quot; &amp;lt;&amp;lt; position &amp;lt;&amp;lt; &quot;len&quot; &amp;lt;&amp;lt; m_spectrumBufferLength
                 &amp;lt;&amp;lt; &quot;spectrumAnalyser.isReady&quot; &amp;lt;&amp;lt; m_spectrumAnalyser.isReady();

    if (m_spectrumAnalyser.isReady()) {
        m_spectrumBuffer = QByteArray::fromRawData(m_buffer.constData() + position - m_bufferPosition,
                                                   m_spectrumBufferLength);
        m_spectrumPosition = position;
        m_spectrumAnalyser.calculate(m_spectrumBuffer, m_format);
    }
#endif
}

void Engine::setFormat(const QAudioFormat &amp;amp;format)
{
    const bool changed = (format != m_format);
    m_format = format;
    m_levelBufferLength = audioLength(m_format, LevelWindowUs);
    m_spectrumBufferLength = SpectrumLengthSamples *
                            (m_format.sampleSize() / 8) * m_format.channelCount();
    if (changed)
        emit formatChanged(m_format);
}

void Engine::setLevel(qreal rmsLevel, qreal peakLevel, int numSamples)
{
    m_rmsLevel = rmsLevel;
    m_peakLevel = peakLevel;
    emit levelChanged(m_rmsLevel, m_peakLevel, numSamples);
}

#ifdef DUMP_DATA
void Engine::createOutputDir()
{
    m_outputDir.setPath(&quot;output&quot;);

    // Ensure output directory exists and is empty
    if (m_outputDir.exists()) {
        const QStringList files = m_outputDir.entryList(QDir::Files);
        QString file;
        foreach (file, files)
            m_outputDir.remove(file);
    } else {
        QDir::current().mkdir(&quot;output&quot;);
    }
}
#endif // DUMP_DATA

#ifdef DUMP_AUDIO
void Engine::dumpData()
{
    const QString txtFileName = m_outputDir.filePath(&quot;data.txt&quot;);
    QFile txtFile(txtFileName);
    txtFile.open(QFile::WriteOnly | QFile::Text);
    QTextStream stream(&amp;amp;txtFile);
    const qint16 *ptr = reinterpret_cast&amp;lt;const qint16*&amp;gt;(m_buffer.constData());
    const int numSamples = m_dataLength / (2 * m_format.channels());
    for (int i=0; i&amp;lt;numSamples; ++i) {
        stream &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;\t&quot; &amp;lt;&amp;lt; *ptr &amp;lt;&amp;lt; &quot;\n&quot;;
        ptr += m_format.channels();
    }

    const QString pcmFileName = m_outputDir.filePath(&quot;data.pcm&quot;);
    QFile pcmFile(pcmFileName);
    pcmFile.open(QFile::WriteOnly);
    pcmFile.write(m_buffer.constData(), m_dataLength);
}
#endif // DUMP_AUDIO

</db:programlisting>
</db:article>
