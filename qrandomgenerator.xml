<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRandomGenerator Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> class allows one to obtain random values from a high-quality Random Number Generator.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QRandomGenerator</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qrandomgenerator64.xml" xlink:role="class">QRandomGenerator64</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> may be used to generate random values from a high-quality random number generator. Like the C++ random engines, <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> can be seeded with user-provided values through the constructor. When seeded, the sequence of numbers generated by this class is deterministic. That is to say, given the same seed data, <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> will generate the same sequence of numbers. But given different seeds, the results should be considerably different.</db:para>
<db:para><db:link xlink:href="qrandomgenerator.xml#securelySeeded">QRandomGenerator::securelySeeded</db:link>() can be used to create a <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> that is securely seeded with <db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>(), meaning that the sequence of numbers it generates cannot be easily predicted. Additionally, <db:link xlink:href="qrandomgenerator.xml#global">QRandomGenerator::global</db:link>() returns a global instance of <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> that Qt will ensure to be securely seeded. This object is thread-safe, may be shared for most uses, and is always seeded from <db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>()</db:para>
<db:para><db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>() may be used to access the system's cryptographically-safe random generator. On Unix systems, it's equivalent to reading from /dev/urandom or the getrandom() or getentropy() system calls.</db:para>
<db:para>The class can generate 32-bit or 64-bit quantities, or fill an array of those. The most common way of generating new values is to call the <db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>(), <db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>() or <db:link xlink:href="qrandomgenerator.xml#fillRange">fillRange</db:link>() functions. One would use it as:</db:para>
<db:programlisting language="cpp">    quint32 value = QRandomGenerator::global()-&amp;gt;generate();
</db:programlisting>
<db:para>Additionally, it provides a floating-point function <db:link xlink:href="qrandomgenerator.xml#generateDouble">generateDouble</db:link>() that returns a number in the range [0, 1) (that is, inclusive of zero and exclusive of 1). There's also a set of convenience functions that facilitate obtaining a random number in a bounded, integral range.</db:para>
<db:section xml:id="seeding-and-determinism">
<db:title>Seeding and determinism</db:title>
<db:para><db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> may be seeded with specific seed data. When that is done, the numbers generated by the object will always be the same, as in the following example:</db:para>
<db:programlisting language="cpp">    QRandomGenerator prng1(1234), prng2(1234);
    Q_ASSERT(prng1.generate() == prng2.generate());
    Q_ASSERT(prng1.generate64() == prng2.generate64());
</db:programlisting>
<db:para>The seed data takes the form of one or more 32-bit words. The ideal seed size is approximately equal to the size of the <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> class itself. Due to mixing of the seed data, <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> cannot guarantee that distinct seeds will produce different sequences.</db:para>
<db:para><db:link xlink:href="qrandomgenerator.xml#global">QRandomGenerator::global</db:link>(), like all generators created by <db:link xlink:href="qrandomgenerator.xml#securelySeeded">QRandomGenerator::securelySeeded</db:link>(), is always seeded from <db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>(), so it's not possible to make it produce identical sequences.</db:para>
</db:section>
<db:section xml:id="bulk-data">
<db:title>Bulk data</db:title>
<db:para>When operating in deterministic mode, <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> may be used for bulk data generation. In fact, applications that do not need cryptographically-secure or true random data are advised to use a regular <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> instead of <db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>() for their random data needs.</db:para>
<db:para>For ease of use, <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> provides a global object that can be easily used, as in the following example:</db:para>
<db:programlisting language="cpp">    int x = QRandomGenerator::global()-&amp;gt;generate();
    int y = QRandomGenerator::global()-&amp;gt;generate();
    int w = QRandomGenerator::global()-&amp;gt;bounded(16384);
    int h = QRandomGenerator::global()-&amp;gt;bounded(16384);
</db:programlisting>
</db:section>
<db:section xml:id="system-wide-random-number-generator">
<db:title>System-wide random number generator</db:title>
<db:para><db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>() may be used to access the system-wide random number generator, which is cryptographically-safe on all systems that Qt runs on. This function will use hardware facilities to generate random numbers where available. On such systems, those facilities are true Random Number Generators. However, if they are true RNGs, those facilities have finite entropy sources and thus may fail to produce any results if their entropy pool is exhausted.</db:para>
<db:para>If that happens, first the operating system then <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> will fall back to Pseudo Random Number Generators of decreasing qualities (Qt's fallback generator being the simplest). Whether those generators are still of cryptographic quality is implementation-defined. Therefore, <db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>() should not be used for high-frequency random number generation, lest the entropy pool become empty. As a rule of thumb, this class should not be called upon to generate more than a kilobyte per second of random data (note: this may vary from system to system).</db:para>
<db:para>If an application needs true RNG data in bulk, it should use the operating system facilities (such as /dev/random on Linux) directly and wait for entropy to become available. If the application requires PRNG engines of cryptographic quality but not of true randomness, <db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>() may still be used (see section below).</db:para>
<db:para>If neither a true RNG nor a cryptographically secure PRNG are required, applications should instead use PRNG engines like <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link>'s deterministic mode and those from the C++ Standard Library. <db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>() can be used to seed those.</db:para>
<db:section xml:id="fallback-quality">
<db:title>Fallback quality</db:title>
<db:para><db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>() uses the operating system facilities to obtain random numbers, which attempt to collect real entropy from the surrounding environment to produce true random numbers. However, it's possible that the entropy pool becomes exhausted, in which case the operating system will fall back to a pseudo-random engine for a time. Under no circumstances will <db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>() block, waiting for more entropy to be collected.</db:para>
<db:para>The following operating systems guarantee that the results from their random-generation API will be of at least cryptographically-safe quality, even if the entropy pool is exhausted: Apple OSes (Darwin), BSDs, Linux, Windows. Barring a system installation problem (such as /dev/urandom not being readable by the current process), <db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>() will therefore have the same guarantees.</db:para>
<db:para>On other operating systems, <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> will fall back to a PRNG of good numeric distribution, but it cannot guarantee proper seeding in all cases. Please consult the OS documentation for more information.</db:para>
<db:para>Applications that require <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> not to fall back to non-cryptographic quality generators are advised to check their operating system documentation or restrict their deployment to one of the above.</db:para>
</db:section>
</db:section>
<db:section xml:id="reentrancy-and-thread-safety">
<db:title>Reentrancy and thread-safety</db:title>
<db:para><db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> is reentrant, meaning that multiple threads can operate on this class at the same time, so long as they operate on different objects. If multiple threads need to share one PRNG sequence, external locking by a mutex is required.</db:para>
<db:para>The exceptions are the objects returned by <db:link xlink:href="qrandomgenerator.xml#global">QRandomGenerator::global</db:link>() and <db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>(): those objects are thread-safe and may be used by any thread without external locking. Note that thread-safety does not extend to copying those objects: they should always be used by reference.</db:para>
</db:section>
<db:section xml:id="standard-c-library-compatibility">
<db:title>Standard C++ Library compatibility</db:title>
<db:para><db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> is modeled after the requirements for random number engines in the C++ Standard Library and may be used in almost all contexts that the Standard Library engines can. Exceptions to the requirements are the following:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> does not support seeding from another seed sequence-like class besides std::seed_seq itself;</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> is not comparable (but is copyable) or streamable to std::ostream or from std::istream.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para><db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> is also compatible with the uniform distribution classes std::uniform_int_distribution and std:uniform_real_distribution, as well as the free function std::generate_canonical. For example, the following code may be used to generate a floating-point number in the range [1, 2.5):</db:para>
<db:programlisting language="cpp">    std::uniform_real_distribution dist(1, 2.5);
    return dist(*QRandomGenerator::global());
</db:programlisting>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator64.xml">QRandomGenerator64</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="result_type-typedef">
<db:title>QRandomGenerator::result_type</db:title>
<db:typedefsynopsis>
<db:typedefname>result_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>A typedef to the type that <db:link xlink:href="qrandomgenerator.xml#operator-28-29">operator</db:link>() returns. That is, quint32.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#operator-28-29">operator</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="bounded-9">
<db:title>qint64 QRandomGenerator::bounded(int <db:emphasis>lowest</db:emphasis>, qint64 <db:emphasis>highest</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="bounded-10">qint64 QRandomGenerator::bounded(qint64 <db:emphasis>lowest</db:emphasis>, int <db:emphasis>highest</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="bounded-12">quint64 QRandomGenerator::bounded(quint64 <db:emphasis>lowest</db:emphasis>, unsigned int <db:emphasis>highest</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="bounded-11">quint64 QRandomGenerator::bounded(unsigned int <db:emphasis>lowest</db:emphasis>, quint64 <db:emphasis>highest</db:emphasis>)</db:bridgehead>
<db:para>This is an overloaded function.</db:para>
<db:para>This function exists to help with overload resolution when the types of the parameters don't exactly match. They will promote the smaller type to the type of the larger one and call the correct overload.</db:para>
</db:section>
<db:section xml:id="QRandomGenerator">
<db:title>QRandomGenerator::QRandomGenerator(quint32 <db:emphasis>seedValue</db:emphasis> = 1)</db:title>
<db:constructorsynopsis>
<db:methodname>QRandomGenerator</db:methodname>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>seedValue</db:parameter>
<db:initializer>1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QRandomGenerator(quint32 seedValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Initializes this <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> object with the value <db:code role="parameter">seedValue</db:code> as the seed. Two objects constructed or reseeded with the same seed value will produce the same number sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#seed">seed</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#securelySeeded">securelySeeded</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRandomGenerator-1">
<db:title>QRandomGenerator::QRandomGenerator(const quint32 (&amp;)[N] <db:emphasis>seedBuffer</db:emphasis> = N)</db:title>
<db:constructorsynopsis>
<db:methodname>QRandomGenerator</db:methodname>
<db:methodparam>
<db:type>const quint32 (&amp;)[N]</db:type>
<db:parameter>seedBuffer</db:parameter>
<db:initializer>N</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QRandomGenerator(const quint32 (&amp;)[N] seedBuffer)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Initializes this <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> object with the values found in the array <db:code role="parameter">seedBuffer</db:code> as the seed. Two objects constructed or reseeded with the same seed value will produce the same number sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#seed">seed</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#securelySeeded">securelySeeded</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRandomGenerator-2">
<db:title>QRandomGenerator::QRandomGenerator(const quint32 *<db:emphasis>seedBuffer</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QRandomGenerator</db:methodname>
<db:methodparam>
<db:type>const quint32 *</db:type>
<db:parameter>seedBuffer</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QRandomGenerator(const quint32 *seedBuffer, qsizetype len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Initializes this <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> object with <db:code role="parameter">len</db:code> values found in the array <db:code role="parameter">seedBuffer</db:code> as the seed. Two objects constructed or reseeded with the same seed value will produce the same number sequence.</db:para>
<db:para>This constructor is equivalent to:</db:para>
<db:programlisting language="cpp">    std::seed_seq sseq(seedBuffer, seedBuffer + len);
    QRandomGenerator generator(sseq);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#seed">seed</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#securelySeeded">securelySeeded</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRandomGenerator-3">
<db:title>QRandomGenerator::QRandomGenerator(std::seed_seq &amp;<db:emphasis>sseq</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QRandomGenerator</db:methodname>
<db:methodparam>
<db:type>std::seed_seq &amp;</db:type>
<db:parameter>sseq</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QRandomGenerator(std::seed_seq &amp;sseq)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Initializes this <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> object with the seed sequence <db:code role="parameter">sseq</db:code> as the seed. Two objects constructed or reseeded with the same seed value will produce the same number sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#seed">seed</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#securelySeeded">securelySeeded</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRandomGenerator-4">
<db:title>QRandomGenerator::QRandomGenerator(const quint32 *<db:emphasis>begin</db:emphasis>, const quint32 *<db:emphasis>end</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QRandomGenerator</db:methodname>
<db:methodparam>
<db:type>const quint32 *</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const quint32 *</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QRandomGenerator(const quint32 *begin, const quint32 *end)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Initializes this <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> object with the values found in the range from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> as the seed. Two objects constructed or reseeded with the same seed value will produce the same number sequence.</db:para>
<db:para>This constructor is equivalent to:</db:para>
<db:programlisting language="cpp">    std::seed_seq sseq(begin, end);
    QRandomGenerator generator(sseq);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#seed">seed</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#securelySeeded">securelySeeded</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRandomGenerator-5">
<db:title>QRandomGenerator::QRandomGenerator(const QRandomGenerator &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QRandomGenerator</db:methodname>
<db:methodparam>
<db:type>const QRandomGenerator &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QRandomGenerator(const QRandomGenerator &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a copy of the generator state in the <db:code role="parameter">other</db:code> object. If <db:code role="parameter">other</db:code> is <db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>() or a copy of that, this object will also read from the operating system random-generating facilities. In that case, the sequences generated by the two objects will be different.</db:para>
<db:para>In all other cases, the new <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> object will start at the same position in the deterministic sequence as the <db:code role="parameter">other</db:code> object was. Both objects will generate the same sequence from this point on.</db:para>
<db:para>For that reason, it is not advisable to create a copy of <db:link xlink:href="qrandomgenerator.xml#global">QRandomGenerator::global</db:link>(). If one needs an exclusive deterministic generator, consider instead using <db:link xlink:href="qrandomgenerator.xml#securelySeeded">securelySeeded</db:link>() to obtain a new object that shares no relationship with the <db:link xlink:href="qrandomgenerator.xml#global">QRandomGenerator::global</db:link>().</db:para>
</db:section>
<db:section xml:id="bounded">
<db:title>double QRandomGenerator::bounded(double <db:emphasis>highest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>double</db:type>
<db:methodname>bounded</db:methodname>
<db:methodparam>
<db:type>double</db:type>
<db:parameter>highest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">double bounded(double highest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Generates one random double in the range between 0 (inclusive) and <db:code role="parameter">highest</db:code> (exclusive). This function is equivalent to and is implemented as:</db:para>
<db:programlisting language="cpp">    return generateDouble() * highest;
</db:programlisting>
<db:para>If the <db:code role="parameter">highest</db:code> parameter is negative, the result will be negative too; if it is infinite or NaN, the result will be infinite or NaN too (that is, not random).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generateDouble">generateDouble</db:link>()</db:member>
<db:member>bounded()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bounded-1">
<db:title>quint32 QRandomGenerator::bounded(quint32 <db:emphasis>highest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>quint32</db:type>
<db:methodname>bounded</db:methodname>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>highest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">quint32 bounded(quint32 highest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Generates one random 32-bit quantity in the range between 0 (inclusive) and <db:code role="parameter">highest</db:code> (exclusive). The same result may also be obtained by using <db:link xlink:href="http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution">std::uniform_int_distribution</db:link> with parameters 0 and highest - 1. That class can also be used to obtain quantities larger than 32 bits; for 64 bits, the 64-bit <db:link xlink:href="qrandomgenerator.xml#bounded">bounded</db:link>() overload can be used too.</db:para>
<db:para>For example, to obtain a value between 0 and 255 (inclusive), one would write:</db:para>
<db:programlisting language="cpp">    quint32 v = QRandomGenerator::global()-&amp;gt;bounded(256);
</db:programlisting>
<db:para>Naturally, the same could also be obtained by masking the result of <db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>() to only the lower 8 bits. Either solution is as efficient.</db:para>
<db:para>Note that this function cannot be used to obtain values in the full 32-bit range of quint32. Instead, use <db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generateDouble">generateDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bounded-2">
<db:title>quint32 QRandomGenerator::bounded(quint32 <db:emphasis>lowest</db:emphasis>, quint32 <db:emphasis>highest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>quint32</db:type>
<db:methodname>bounded</db:methodname>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>lowest</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>highest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">quint32 bounded(quint32 lowest, quint32 highest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Generates one random 32-bit quantity in the range between <db:code role="parameter">lowest</db:code> (inclusive) and <db:code role="parameter">highest</db:code> (exclusive). The <db:code role="parameter">highest</db:code> parameter must be greater than <db:code role="parameter">lowest</db:code>.</db:para>
<db:para>The same result may also be obtained by using <db:link xlink:href="http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution">std::uniform_int_distribution</db:link> with parameters <db:code role="parameter">lowest</db:code> and \a highest - 1. That class can also be used to obtain quantities larger than 32 bits.</db:para>
<db:para>For example, to obtain a value between 1000 (incl.) and 2000 (excl.), one would write:</db:para>
<db:programlisting language="cpp">    quint32 v = QRandomGenerator::global()-&amp;gt;bounded(1000, 2000);
</db:programlisting>
<db:para>Note that this function cannot be used to obtain values in the full 32-bit range of quint32. Instead, use <db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generateDouble">generateDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bounded-3">
<db:title>int QRandomGenerator::bounded(int <db:emphasis>highest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>bounded</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>highest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">int bounded(int highest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Generates one random 32-bit quantity in the range between 0 (inclusive) and <db:code role="parameter">highest</db:code> (exclusive). <db:code role="parameter">highest</db:code> must be positive.</db:para>
<db:para>Note that this function cannot be used to obtain values in the full 32-bit range of int. Instead, use <db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>() and cast to int.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generateDouble">generateDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bounded-4">
<db:title>int QRandomGenerator::bounded(int <db:emphasis>lowest</db:emphasis>, int <db:emphasis>highest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>bounded</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>lowest</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>highest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">int bounded(int lowest, int highest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Generates one random 32-bit quantity in the range between <db:code role="parameter">lowest</db:code> (inclusive) and <db:code role="parameter">highest</db:code> (exclusive), both of which may be negative, but <db:code role="parameter">highest</db:code> must be greater than <db:code role="parameter">lowest</db:code>.</db:para>
<db:para>Note that this function cannot be used to obtain values in the full 32-bit range of int. Instead, use <db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>() and cast to int.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generateDouble">generateDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bounded-5">
<db:title>quint64 QRandomGenerator::bounded(quint64 <db:emphasis>highest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>quint64</db:type>
<db:methodname>bounded</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>highest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">quint64 bounded(quint64 highest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Generates one random 64-bit quantity in the range between 0 (inclusive) and <db:code role="parameter">highest</db:code> (exclusive). The same result may also be obtained by using <db:link xlink:href="http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution">std::uniform_int_distribution&lt;quint64&gt;</db:link> with parameters 0 and highest - 1.</db:para>
<db:para>Note that this function cannot be used to obtain values in the full 64-bit range of quint64. Instead, use <db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>().</db:para>
<db:note>
<db:para>This function is implemented as a loop, which depends on the random value obtained. On the long run, on average it should loop just under 2 times, but if the random generator is defective, this function may take considerably longer to execute.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generateDouble">generateDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bounded-6">
<db:title>quint64 QRandomGenerator::bounded(quint64 <db:emphasis>lowest</db:emphasis>, quint64 <db:emphasis>highest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>quint64</db:type>
<db:methodname>bounded</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>lowest</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>highest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">quint64 bounded(quint64 lowest, quint64 highest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Generates one random 64-bit quantity in the range between <db:code role="parameter">lowest</db:code> (inclusive) and <db:code role="parameter">highest</db:code> (exclusive). The <db:code role="parameter">highest</db:code> parameter must be greater than <db:code role="parameter">lowest</db:code>.</db:para>
<db:para>The same result may also be obtained by using <db:link xlink:href="http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution">std::uniform_int_distribution&lt;quint64&gt;</db:link> with parameters <db:code role="parameter">lowest</db:code> and \a highest - 1.</db:para>
<db:para>Note that this function cannot be used to obtain values in the full 64-bit range of quint64. Instead, use <db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>().</db:para>
<db:note>
<db:para>This function is implemented as a loop, which depends on the random value obtained. On the long run, on average it should loop just under 2 times, but if the random generator is defective, this function may take considerably longer to execute.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generateDouble">generateDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bounded-7">
<db:title>qint64 QRandomGenerator::bounded(qint64 <db:emphasis>highest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qint64</db:type>
<db:methodname>bounded</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>highest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 bounded(qint64 highest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Generates one random 64-bit quantity in the range between 0 (inclusive) and <db:code role="parameter">highest</db:code> (exclusive). <db:code role="parameter">highest</db:code> must be positive.</db:para>
<db:para>Note that this function cannot be used to obtain values in the full 64-bit range of qint64. Instead, use <db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>() and cast to qint64 or instead use the unsigned version of this function.</db:para>
<db:note>
<db:para>This function is implemented as a loop, which depends on the random value obtained. On the long run, on average it should loop just under 2 times, but if the random generator is defective, this function may take considerably longer to execute.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generateDouble">generateDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bounded-8">
<db:title>qint64 QRandomGenerator::bounded(qint64 <db:emphasis>lowest</db:emphasis>, qint64 <db:emphasis>highest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qint64</db:type>
<db:methodname>bounded</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>lowest</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>highest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">8</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 bounded(qint64 lowest, qint64 highest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Generates one random 64-bit quantity in the range between <db:code role="parameter">lowest</db:code> (inclusive) and <db:code role="parameter">highest</db:code> (exclusive), both of which may be negative, but <db:code role="parameter">highest</db:code> must be greater than <db:code role="parameter">lowest</db:code>.</db:para>
<db:para>Note that this function cannot be used to obtain values in the full 64-bit range of qint64. Instead, use <db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>() and cast to qint64.</db:para>
<db:note>
<db:para>This function is implemented as a loop, which depends on the random value obtained. On the long run, on average it should loop just under 2 times, but if the random generator is defective, this function may take considerably longer to execute.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generateDouble">generateDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="discard">
<db:title>void QRandomGenerator::discard(unsigned long long <db:emphasis>z</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>discard</db:methodname>
<db:methodparam>
<db:type>unsigned long long</db:type>
<db:parameter>z</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void discard(unsigned long long z)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Discards the next <db:code role="parameter">z</db:code> entries from the sequence. This method is equivalent to calling <db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>() <db:code role="parameter">z</db:code> times and discarding the result, as in:</db:para>
<db:programlisting language="cpp">    while (z--)
        generator.generate();
</db:programlisting>
</db:section>
<db:section xml:id="fillRange">
<db:title>void QRandomGenerator::fillRange(UInt *<db:emphasis>buffer</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>fillRange</db:methodname>
<db:methodparam>
<db:type>UInt *</db:type>
<db:parameter>buffer</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void fillRange(UInt *buffer, qsizetype count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Generates <db:code role="parameter">count</db:code> 32- or 64-bit quantities (depending on the type UInt) and stores them in the buffer pointed by <db:code role="parameter">buffer</db:code>. This is the most efficient way to obtain more than one quantity at a time, as it reduces the number of calls into the Random Number Generator source.</db:para>
<db:para>For example, to fill a list of 16 entries with random values, one may write:</db:para>
<db:programlisting language="cpp">    QList&amp;lt;quint32&amp;gt; list;
    list.resize(16);
    QRandomGenerator::global()-&amp;gt;fillRange(list.data(), list.size());
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fillRange-1">
<db:title>void QRandomGenerator::fillRange(UInt (&amp;)[N] <db:emphasis>buffer</db:emphasis> = N)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>fillRange</db:methodname>
<db:methodparam>
<db:type>UInt (&amp;)[N]</db:type>
<db:parameter>buffer</db:parameter>
<db:initializer>N</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void fillRange(UInt (&amp;)[N] buffer)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Generates N 32- or 64-bit quantities (depending on the type UInt) and stores them in the <db:code role="parameter">buffer</db:code> array. This is the most efficient way to obtain more than one quantity at a time, as it reduces the number of calls into the Random Number Generator source.</db:para>
<db:para>For example, to fill generate two 32-bit quantities, one may write:</db:para>
<db:programlisting language="cpp">    quint32 array[2];
    QRandomGenerator::global()-&amp;gt;fillRange(array);
</db:programlisting>
<db:para>It would have also been possible to make one call to <db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>() and then split the two halves of the 64-bit value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="generate64">
<db:title>quint64 QRandomGenerator::generate64()</db:title>
<db:methodsynopsis>
<db:type>quint64</db:type>
<db:methodname>generate64</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint64 generate64()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Generates a 64-bit random quantity and returns it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#operator-28-29">operator()</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="generate">
<db:title>quint32 QRandomGenerator::generate()</db:title>
<db:methodsynopsis>
<db:type>quint32</db:type>
<db:methodname>generate</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint32 generate()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Generates a 32-bit random quantity and returns it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#operator-28-29">operator()</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="generate-1">
<db:title>void QRandomGenerator::generate(ForwardIterator <db:emphasis>begin</db:emphasis>, ForwardIterator <db:emphasis>end</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>generate</db:methodname>
<db:methodparam>
<db:type>ForwardIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ForwardIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void generate(ForwardIterator begin, ForwardIterator end)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Generates 32-bit quantities and stores them in the range between <db:code role="parameter">begin</db:code> and <db:code role="parameter">end</db:code>. This function is equivalent to (and is implemented as):</db:para>
<db:programlisting language="cpp">    std::generate(begin, end, [this]() { return generate(); });
</db:programlisting>
<db:para>This function complies with the requirements for the function <db:link xlink:href="http://en.cppreference.com/w/cpp/numeric/random/seed_seq/generate">std::seed_seq::generate</db:link>, which requires unsigned 32-bit integer values.</db:para>
<db:para>Note that if the [begin, end) range refers to an area that can store more than 32 bits per element, the elements will still be initialized with only 32 bits of data. Any other bits will be zero. To fill the range with 64 bit quantities, one can write:</db:para>
<db:programlisting language="cpp">    std::generate(begin, end, []() { return QRandomGenerator::global()-&amp;gt;generate64(); });
</db:programlisting>
<db:para>If the range refers to contiguous memory (such as an array or the data from a <db:link xlink:href="qlist.xml">QList</db:link>), the <db:link xlink:href="qrandomgenerator.xml#fillRange">fillRange</db:link>() function may be used too.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#fillRange">fillRange</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="generateDouble">
<db:title>double QRandomGenerator::generateDouble()</db:title>
<db:methodsynopsis>
<db:type>double</db:type>
<db:methodname>generateDouble</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">double generateDouble()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Generates one random qreal in the canonical range [0, 1) (that is, inclusive of zero and exclusive of 1).</db:para>
<db:para>This function is equivalent to:</db:para>
<db:programlisting language="cpp">    QRandomGenerator64 rd;
    return std::generate_canonical&amp;lt;qreal, std::numeric_limits&amp;lt;qreal&amp;gt;::digits&amp;gt;(rd);
</db:programlisting>
<db:para>The same may also be obtained by using <db:link xlink:href="http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution">std::uniform_real_distribution</db:link> with parameters 0 and 1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#bounded">bounded</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="global">
<db:title>[static] QRandomGenerator *QRandomGenerator::global()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QRandomGenerator *</db:type>
<db:methodname>global</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRandomGenerator * global()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">thread safe</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to a shared <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> that was seeded using <db:link xlink:href="qrandomgenerator.xml#securelySeeded">securelySeeded</db:link>(). This function should be used to create random data without the expensive creation of a securely-seeded <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> for a specific use or storing the rather large <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> object.</db:para>
<db:para>For example, the following creates a random RGB color:</db:para>
<db:programlisting language="cpp">    return QColor::fromRgb(QRandomGenerator::global()-&amp;gt;generate());
</db:programlisting>
<db:para>Accesses to this object are thread-safe and it may therefore be used in any thread without locks. The object may also be copied and the sequence produced by the copy will be the same as the shared object will produce. Note, however, that if there are other threads accessing the global object, those threads may obtain samples at unpredictable intervals.</db:para>
<db:note>
<db:para>This function is <db:link xlink:href="threads-reentrancy.xml">thread-safe</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#securelySeeded">securelySeeded</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#system">system</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="max">
<db:title>[static constexpr] QRandomGenerator::result_type QRandomGenerator::max()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QRandomGenerator::result_type</db:type>
<db:methodname>max</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRandomGenerator::result_type max()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum value that <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> may ever generate. That is, std::numeric_limits&lt;result_type&gt;::max().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#min">min</db:link>()</db:member>
<db:member><db:link xlink:href="">QRandomGenerator64::max</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="min">
<db:title>[static constexpr] QRandomGenerator::result_type QRandomGenerator::min()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QRandomGenerator::result_type</db:type>
<db:methodname>min</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRandomGenerator::result_type min()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the minimum value that <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> may ever generate. That is, 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#max">max</db:link>()</db:member>
<db:member><db:link xlink:href="">QRandomGenerator64::min</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="securelySeeded">
<db:title>[static] QRandomGenerator QRandomGenerator::securelySeeded()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QRandomGenerator</db:type>
<db:methodname>securelySeeded</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRandomGenerator securelySeeded()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a new <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> object that was securely seeded with <db:link xlink:href="qrandomgenerator.xml#system">QRandomGenerator::system</db:link>(). This function will obtain the ideal seed size for the algorithm that <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> uses and is therefore the recommended way for creating a new <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> object that will be kept for some time.</db:para>
<db:para>Given the amount of data required to securely seed the deterministic engine, this function is somewhat expensive and should not be used for short-term uses of <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> (using it to generate fewer than 2600 bytes of random data is effectively a waste of resources). If the use doesn't require that much data, consider using <db:link xlink:href="qrandomgenerator.xml#global">QRandomGenerator::global</db:link>() and not storing a <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> object instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#global">global</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#system">system</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="seed">
<db:title>void QRandomGenerator::seed(quint32 <db:emphasis>seed</db:emphasis> = 1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>seed</db:methodname>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void seed(quint32 seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reseeds this object using the value <db:code role="parameter">seed</db:code> as the seed.</db:para>
</db:section>
<db:section xml:id="seed-1">
<db:title>void QRandomGenerator::seed(std::seed_seq &amp;<db:emphasis>seed</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>seed</db:methodname>
<db:methodparam>
<db:type>std::seed_seq &amp;</db:type>
<db:parameter>seed</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void seed(std::seed_seq &amp;seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Reseeds this object using the seed sequence <db:code role="parameter">seed</db:code> as the seed.</db:para>
</db:section>
<db:section xml:id="system">
<db:title>[static] QRandomGenerator *QRandomGenerator::system()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QRandomGenerator *</db:type>
<db:methodname>system</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRandomGenerator * system()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">thread safe</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to a shared <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> that always uses the facilities provided by the operating system to generate random numbers. The system facilities are considered to be cryptographically safe on at least the following operating systems: Apple OSes (Darwin), BSDs, Linux, Windows. That may also be the case on other operating systems.</db:para>
<db:para>They are also possibly backed by a true hardware random number generator. For that reason, the <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> returned by this function should not be used for bulk data generation. Instead, use it to seed <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> or a random engine from the &lt;random&gt; header.</db:para>
<db:para>The object returned by this function is thread-safe and may be used in any thread without locks. It may also be copied and the resulting <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link> will also access the operating system facilities, but they will not generate the same sequence.</db:para>
<db:note>
<db:para>This function is <db:link xlink:href="threads-reentrancy.xml">thread-safe</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#securelySeeded">securelySeeded</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#global">global</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-28-29">
<db:title>QRandomGenerator::result_type QRandomGenerator::operator()()</db:title>
<db:methodsynopsis>
<db:type>QRandomGenerator::result_type</db:type>
<db:methodname>operator()</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRandomGenerator::result_type operator()()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Generates a 32-bit random quantity and returns it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrandomgenerator.xml#generate">generate</db:link>()</db:member>
<db:member><db:link xlink:href="qrandomgenerator.xml#generate64">generate64</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="operator-not-eq">
<db:title>bool operator!=(const QRandomGenerator &amp;<db:emphasis>rng1</db:emphasis>, const QRandomGenerator &amp;<db:emphasis>rng2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QRandomGenerator &amp;</db:type>
<db:parameter>rng1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRandomGenerator &amp;</db:type>
<db:parameter>rng2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QRandomGenerator &amp;rng1, const QRandomGenerator &amp;rng2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the two engines <db:code role="parameter">rng1</db:code> and <db:code role="parameter">rng2</db:code> are at different states or if one of them is reading from the operating system facilities and the other is not, false otherwise.</db:para>
</db:section>
</db:section>
</db:article>
