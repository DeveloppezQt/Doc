<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRhiResourceUpdateBatch Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Records upload and copy type of operations.</db:para>
<db:para>This class was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>rhi/qrhi.h</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui-private</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>With <db:link xlink:href="qrhi.xml">QRhi</db:link> it is no longer possible to perform copy type of operations at arbitrary times. Instead, all such operations are recorded into batches that are then passed, most commonly, to <db:link xlink:href="qrhicommandbuffer.xml#beginPass">QRhiCommandBuffer::beginPass</db:link>(). What then happens under the hood is hidden from the application: the underlying implementations can defer and implement these operations in various different ways.</db:para>
<db:para>A resource update batch owns no graphics resources and does not perform any actual operations on its own. It should rather be viewed as a command buffer for update, upload, and copy type of commands.</db:para>
<db:para>To get an available, empty batch from the pool, call <db:link xlink:href="qrhi.xml#nextResourceUpdateBatch">QRhi::nextResourceUpdateBatch</db:link>().</db:para>
<db:note>
<db:para>This is a RHI API with limited compatibility guarantees, see <db:link xlink:href="qrhi.xml">QRhi</db:link> for details.</db:para>
</db:note>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="copyTexture">
<db:title>void QRhiResourceUpdateBatch::copyTexture(QRhiTexture *<db:emphasis>dst</db:emphasis>, QRhiTexture *<db:emphasis>src</db:emphasis>, const QRhiTextureCopyDescription &amp;<db:emphasis>desc</db:emphasis> = QRhiTextureCopyDescription())</db:title>
<db:para>Enqueues a texture-to-texture copy operation from <db:code role="parameter">src</db:code> into <db:code role="parameter">dst</db:code> as described by <db:code role="parameter">desc</db:code>.</db:para>
<db:note>
<db:para>The source texture <db:code role="parameter">src</db:code> must be created with <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::UsedAsTransferSource</db:link>.</db:para>
</db:note>
<db:note>
<db:para>The format of the textures must match. With most graphics APIs the data is copied as-is without any format conversions. If <db:code role="parameter">dst</db:code> and <db:code role="parameter">src</db:code> are created with different formats, unspecified issues may arise.</db:para>
</db:note>
</db:section>
<db:section xml:id="generateMips">
<db:title>void QRhiResourceUpdateBatch::generateMips(QRhiTexture *<db:emphasis>tex</db:emphasis>)</db:title>
<db:para>Enqueues a mipmap generation operation for the specified texture <db:code role="parameter">tex</db:code>.</db:para>
<db:para>Both 2D and cube textures are supported.</db:para>
<db:note>
<db:para>The texture must be created with <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::MipMapped</db:link> and <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::UsedWithGenerateMips</db:link>.</db:para>
</db:note>
<db:warning>
<db:para><db:link xlink:href="qrhi.xml">QRhi</db:link> cannot guarantee that mipmaps can be generated for all supported texture formats. For example, <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::RGBA32F</db:link> is not a <db:code>filterable</db:code> format in OpenGL ES 3.0 and Metal on iOS, and therefore the mipmap generation request may fail. RGBA8 and RGBA16F are typically filterable, so it is recommended to use these formats when mipmap generation is desired.</db:para>
</db:warning>
</db:section>
<db:section xml:id="hasOptimalCapacity">
<db:title>bool QRhiResourceUpdateBatch::hasOptimalCapacity() const</db:title>
<db:para>Returns true until the number of buffer and texture operations enqueued onto this batch is below a reasonable limit.</db:para>
<db:para>The return value is false when the number of buffer and/or texture operations added to this batch have reached, or are about to reach, a certain limit. The batch is fully functional afterwards as well, but may need to allocate additional memory. Therefore, a renderer that collects lots of buffer and texture updates in a single batch when preparing a frame may want to consider <db:link xlink:href="qrhicommandbuffer.xml#resourceUpdate">submitting the batch</db:link> and <db:link xlink:href="qrhi.xml#nextResourceUpdateBatch">starting a new one</db:link> when this function returns false.</db:para>
</db:section>
<db:section xml:id="merge">
<db:title>void QRhiResourceUpdateBatch::merge(QRhiResourceUpdateBatch *<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Copies all queued operations from the <db:code role="parameter">other</db:code> batch into this one.</db:para>
<db:note>
<db:para><db:code role="parameter">other</db:code> may no longer contain valid data after the merge operation, and must not be submitted, but it will still need to be released by calling <db:link xlink:href="qrhiresourceupdatebatch.xml#release">release</db:link>().</db:para>
</db:note>
<db:para>This allows for a convenient pattern where resource updates that are already known during the initialization step are collected into a batch that is then merged into another when starting to first render pass later on:</db:para>
<db:programlisting language="cpp">void init()
{
    initialUpdates = rhi-&gt;nextResourceUpdateBatch();
    initialUpdates-&gt;uploadStaticBuffer(vbuf, vertexData);
    initialUpdates-&gt;uploadStaticBuffer(ibuf, indexData);
    // ...
}

void render()
{
    QRhiResourceUpdateBatch *resUpdates = rhi-&gt;nextResourceUpdateBatch();
    if (initialUpdates) {
        resUpdates-&gt;merge(initialUpdates);
        initialUpdates-&gt;release();
        initialUpdates = nullptr;
    }
    // resUpdates-&gt;updateDynamicBuffer(...);
    cb-&gt;beginPass(rt, clearCol, clearDs, resUpdates);
}
</db:programlisting>
</db:section>
<db:section xml:id="readBackBuffer">
<db:title>void QRhiResourceUpdateBatch::readBackBuffer(QRhiBuffer *<db:emphasis>buf</db:emphasis>, quint32 <db:emphasis>offset</db:emphasis>, quint32 <db:emphasis>size</db:emphasis>, QRhiReadbackResult *<db:emphasis>result</db:emphasis>)</db:title>
<db:para>Enqueues reading back a region of the <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> <db:code role="parameter">buf</db:code>. The size of the region is specified by <db:code role="parameter">size</db:code> in bytes, <db:code role="parameter">offset</db:code> is the offset in bytes to start reading from.</db:para>
<db:para>A readback is asynchronous. <db:code role="parameter">result</db:code> contains a callback that is invoked when the operation has completed. The data is provided in <db:link xlink:href="qrhireadbackresult.xml#data-var">QRhiReadbackResult::data</db:link>. Upon successful completion that <db:link xlink:href="qbytearray.xml">QByteArray</db:link> will have a size equal to <db:code role="parameter">size</db:code>. On failure the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> will be empty.</db:para>
<db:note>
<db:para>Reading buffers with a usage different than <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">QRhiBuffer::UniformBuffer</db:link> is supported only when the <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::ReadBackNonUniformBuffer</db:link> feature is reported as supported.</db:para>
</db:note>
<db:note>
<db:para>The asynchronous readback is guaranteed to have completed when one of the following conditions is met: <db:link xlink:href="qrhi.xml#finish">finish</db:link>() has been called; or, at least <db:code>N</db:code> frames have been <db:link xlink:href="qrhi.xml#endFrame">submitted</db:link>, including the frame that issued the readback operation, and the <db:link xlink:href="qrhi.xml#beginFrame">recording of a new frame</db:link> has been started, where <db:code>N</db:code> is the <db:link xlink:href="qrhi.xml#resourceLimit">resource limit value</db:link> returned for <db:link xlink:href="qrhi.xml#ResourceLimit-enum">QRhi::MaxAsyncReadbackFrames</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiresourceupdatebatch.xml#readBackTexture">readBackTexture</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#isFeatureSupported">QRhi::isFeatureSupported</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#resourceLimit">QRhi::resourceLimit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readBackTexture">
<db:title>void QRhiResourceUpdateBatch::readBackTexture(const QRhiReadbackDescription &amp;<db:emphasis>rb</db:emphasis>, QRhiReadbackResult *<db:emphasis>result</db:emphasis>)</db:title>
<db:para>Enqueues a texture-to-host copy operation as described by <db:code role="parameter">rb</db:code>.</db:para>
<db:para>Normally <db:code role="parameter">rb</db:code> will specify a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> as the source. However, when the swapchain in the current frame was created with <db:link xlink:href="qrhiswapchain.xml#Flag-enum">QRhiSwapChain::UsedAsTransferSource</db:link>, it can also be the source of the readback. For this, leave the texture set to null in <db:code role="parameter">rb</db:code>.</db:para>
<db:para>Unlike other operations, the results here need to be processed by the application. Therefore, <db:code role="parameter">result</db:code> provides not just the data but also a callback as operations on the batch are asynchronous by nature:</db:para>
<db:programlisting language="cpp">rhi-&gt;beginFrame(swapchain);
cb-&gt;beginPass(swapchain-&gt;currentFrameRenderTarget(), colorClear, dsClear);
// ...
QRhiReadbackResult *rbResult = new QRhiReadbackResult;
rbResult-&gt;completed = [rbResult] {
    {
        const QImage::Format fmt = QImage::Format_RGBA8888_Premultiplied; // fits QRhiTexture::RGBA8
        const uchar *p = reinterpret_cast&lt;const uchar *&gt;(rbResult-&gt;data.constData());
        QImage image(p, rbResult-&gt;pixelSize.width(), rbResult-&gt;pixelSize.height(), fmt);
        image.save(&quot;result.png&quot;);
    }
    delete rbResult;
};
QRhiResourceUpdateBatch *u = nextResourceUpdateBatch();
QRhiReadbackDescription rb; // no texture -&gt; uses the current backbuffer of sc
u-&gt;readBackTexture(rb, rbResult);
cb-&gt;endPass(u);
rhi-&gt;endFrame(swapchain);
</db:programlisting>
<db:note>
<db:para>The texture must be created with <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::UsedAsTransferSource</db:link>.</db:para>
</db:note>
<db:note>
<db:para>Multisample textures cannot be read back.</db:para>
</db:note>
<db:note>
<db:para>The readback returns raw byte data, in order to allow the applications to interpret it in any way they see fit. Be aware of the blending settings of rendering code: if the blending is set up to rely on premultiplied alpha, the results of the readback must also be interpreted as Premultiplied.</db:para>
</db:note>
<db:note>
<db:para>When interpreting the resulting raw data, be aware that the readback happens with a byte ordered format. A <db:link xlink:href="qrhitexture.xml#Format-enum">RGBA8</db:link> texture maps therefore to byte ordered <db:link xlink:href="qimage.xml">QImage</db:link> formats, such as, <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_RGBA8888</db:link>.</db:para>
</db:note>
<db:note>
<db:para>The asynchronous readback is guaranteed to have completed when one of the following conditions is met: <db:link xlink:href="qrhi.xml#finish">finish</db:link>() has been called; or, at least <db:code>N</db:code> frames have been <db:link xlink:href="qrhi.xml#endFrame">submitted</db:link>, including the frame that issued the readback operation, and the <db:link xlink:href="qrhi.xml#beginFrame">recording of a new frame</db:link> has been started, where <db:code>N</db:code> is the <db:link xlink:href="qrhi.xml#resourceLimit">resource limit value</db:link> returned for <db:link xlink:href="qrhi.xml#ResourceLimit-enum">QRhi::MaxAsyncReadbackFrames</db:link>.</db:para>
</db:note>
<db:para>A single readback operation copies one mip level of one layer (cubemap face or 3D slice or texture array element) at a time. The level and layer are specified by the respective fields in <db:code role="parameter">rb</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiresourceupdatebatch.xml#readBackBuffer">readBackBuffer</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#resourceLimit">QRhi::resourceLimit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="release">
<db:title>void QRhiResourceUpdateBatch::release()</db:title>
<db:para>Returns the batch to the pool. This should only be used when the batch is not passed to one of <db:link xlink:href="qrhicommandbuffer.xml#beginPass">QRhiCommandBuffer::beginPass</db:link>(), <db:link xlink:href="qrhicommandbuffer.xml#endPass">QRhiCommandBuffer::endPass</db:link>(), or <db:link xlink:href="qrhicommandbuffer.xml#resourceUpdate">QRhiCommandBuffer::resourceUpdate</db:link>() because these implicitly call destroy().</db:para>
<db:note>
<db:para><db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link> instances must never by <db:code>deleted</db:code> by applications.</db:para>
</db:note>
</db:section>
<db:section xml:id="updateDynamicBuffer">
<db:title>void QRhiResourceUpdateBatch::updateDynamicBuffer(QRhiBuffer *<db:emphasis>buf</db:emphasis>, quint32 <db:emphasis>offset</db:emphasis>, quint32 <db:emphasis>size</db:emphasis>, const void *<db:emphasis>data</db:emphasis>)</db:title>
<db:para>Enqueues updating a region of a <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> <db:code role="parameter">buf</db:code> created with the type <db:link xlink:href="qrhibuffer.xml#Type-enum">QRhiBuffer::Dynamic</db:link>.</db:para>
<db:para>The region is specified <db:code role="parameter">offset</db:code> and <db:code role="parameter">size</db:code>. The actual bytes to write are specified by <db:code role="parameter">data</db:code> which must have at least <db:code role="parameter">size</db:code> bytes available. <db:code role="parameter">data</db:code> can safely be destroyed or changed once this function returns.</db:para>
<db:note>
<db:para>If host writes are involved, which is the case with updateDynamicBuffer() typically as such buffers are backed by host visible memory with most backends, they may accumulate within a frame. Thus pass 1 reading a region changed by a batch passed to pass 2 may see the changes specified in pass 2's update batch.</db:para>
</db:note>
<db:note>
<db:para><db:link xlink:href="qrhi.xml">QRhi</db:link> transparently manages double buffering in order to prevent stalling the graphics pipeline. The fact that a <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> may have multiple native buffer objects underneath can be safely ignored when using the <db:link xlink:href="qrhi.xml">QRhi</db:link> and <db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link>.</db:para>
</db:note>
</db:section>
<db:section xml:id="uploadStaticBuffer">
<db:title>void QRhiResourceUpdateBatch::uploadStaticBuffer(QRhiBuffer *<db:emphasis>buf</db:emphasis>, quint32 <db:emphasis>offset</db:emphasis>, quint32 <db:emphasis>size</db:emphasis>, const void *<db:emphasis>data</db:emphasis>)</db:title>
<db:para>Enqueues updating a region of a <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> <db:code role="parameter">buf</db:code> created with the type <db:link xlink:href="qrhibuffer.xml#Type-enum">QRhiBuffer::Immutable</db:link> or <db:link xlink:href="qrhibuffer.xml#Type-enum">QRhiBuffer::Static</db:link>.</db:para>
<db:para>The region is specified <db:code role="parameter">offset</db:code> and <db:code role="parameter">size</db:code>. The actual bytes to write are specified by <db:code role="parameter">data</db:code> which must have at least <db:code role="parameter">size</db:code> bytes available. <db:code role="parameter">data</db:code> can safely be destroyed or changed once this function returns.</db:para>
</db:section>
<db:section xml:id="uploadStaticBuffer-1">
<db:title>void QRhiResourceUpdateBatch::uploadStaticBuffer(QRhiBuffer *<db:emphasis>buf</db:emphasis>, const void *<db:emphasis>data</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Enqueues updating the entire <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> <db:code role="parameter">buf</db:code> created with the type <db:link xlink:href="qrhibuffer.xml#Type-enum">QRhiBuffer::Immutable</db:link> or <db:link xlink:href="qrhibuffer.xml#Type-enum">QRhiBuffer::Static</db:link>.</db:para>
</db:section>
<db:section xml:id="uploadTexture">
<db:title>void QRhiResourceUpdateBatch::uploadTexture(QRhiTexture *<db:emphasis>tex</db:emphasis>, const QImage &amp;<db:emphasis>image</db:emphasis>)</db:title>
<db:para>Enqueues uploading the image data for mip level 0 of layer 0 of the texture <db:code role="parameter">tex</db:code>.</db:para>
<db:para><db:code role="parameter">tex</db:code> must have an uncompressed format. Its format must also be compatible with the QImage::format() of <db:code role="parameter">image</db:code>. The source data is given in <db:code role="parameter">image</db:code>.</db:para>
</db:section>
<db:section xml:id="uploadTexture-1">
<db:title>void QRhiResourceUpdateBatch::uploadTexture(QRhiTexture *<db:emphasis>tex</db:emphasis>, const QRhiTextureUploadDescription &amp;<db:emphasis>desc</db:emphasis>)</db:title>
<db:para>Enqueues uploading the image data for one or more mip levels in one or more layers of the texture <db:code role="parameter">tex</db:code>.</db:para>
<db:para>The details of the copy (source <db:link xlink:href="qimage.xml">QImage</db:link> or compressed texture data, regions, target layers and levels) are described in <db:code role="parameter">desc</db:code>.</db:para>
</db:section>
</db:section>
</db:article>
