<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Quick 3D Scenes with 2D Content</db:title>
<db:productname>QtQuick3D</db:productname>
<db:edition>Qt Quick 3D | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Quick 3D Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Embedding Qt Quick items in a 3D scene.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="A2d-items-in-a-3d-world">
<db:title>2D Items in a 3D World</db:title>
<db:para>Qt Quick 3D offers efficient creation and rendering of scenes that combine 3D and 2D elements.</db:para>
<db:para>What do we mean by a combined 3D-2D scene?</db:para>
<db:para>By nature, a <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> object, representing a 3D viewport in the 2D scene, can be easily combined with Qt Quick items, such as, Rectangle, Image, Text, around, below, or above the <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> item, which itself is a Qt Quick <db:link xlink:href="qml-qtquick-item.xml">Item</db:link>.</db:para>
<db:para>Consider the following example:</db:para>
<db:programlisting language="qml">import QtQuick
import QtQuick3D

Rectangle {
    gradient: Gradient {
        GradientStop { position: 0; color: &quot;steelblue&quot; }
        GradientStop { position: 1; color: &quot;black&quot; }
    }
    Text {
        text: &quot;Hello 2D World&quot;
        font.pointSize: 32
        color: &quot;red&quot;
        anchors.top: parent.top
        anchors.horizontalCenter: parent.horizontalCenter
    }
    Item {
        width: 400; height: 400
        anchors.centerIn: parent
        View3D {
            anchors.fill: parent
            environment: SceneEnvironment { backgroundMode: SceneEnvironment.Color; clearColor: &quot;lightGray&quot; }
            PerspectiveCamera { z: 600 }
            DirectionalLight { }
            Model {
                source: &quot;#Cube&quot;
                materials: PrincipledMaterial { baseColor: &quot;green&quot;; metalness: 0.0; roughness: 0.0 }
                eulerRotation: Qt.vector3d(30, 45, 0)
            }
        }
    }
}
</db:programlisting>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick2d-3d-1.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:para>Here the 3D scene is the area with gray background. The rest of the window consists of 2D Qt Quick items. These can overlap with the <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> but are not part of the 3D world, are not using the 3D coordinate system, and do not take part in the 3D scene's transformations.</db:para>
<db:para>What if we want to have 2D items within the 3D world, in a way that they truly participate in all 3D transforms? For example, can we have <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link> and <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> items placed within the 3D world, in a way that they follow the cube's rotation and are always placed above it?</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick2d-3d-3.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:para>In the following sections we will take a look at how this can be achieved. While the example uses <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link> and <db:link xlink:href="qml-qtquick-text.xml">Text</db:link>, any Qt Quick content, including Qt Quick Controls, <db:link xlink:href="qml-qtquick-shapes-shape.xml">Shape</db:link>, <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link>, <db:link xlink:href="qml-qtquick-particles-particlesystem.xml">ParticleSystem</db:link>, can be used this way.</db:para>
<db:note>
<db:para>There are also other approaches available to integrate 2D content with the 3D objects. Adding 2D items to 3D nodes allows freely combining the 2D and 3D objects in the 3D world, but it does not allow rendering the 2D content on the surface of a 3D object. If the goal is to texture a 3D mesh with content generated by Qt Quick, use <db:link xlink:href="qml-qtquick3d-texture.xml#sourceItem-prop">the sourceItem property</db:link> of <db:link xlink:href="qml-qtquick3d-texture.xml">Texture</db:link> instead.</db:para>
</db:note>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Qt Quick content used as a texture map</db:para>
</db:th>
<db:th>
<db:para>Qt Quick items in the 3D scene</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick2d-3d-4.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick2d-3d-5.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="adding-2d-items-to-3d-nodes">
<db:title>Adding 2D Items to 3D Nodes</db:title>
<db:para>The key enabler is <db:link xlink:href="qml-qtquick3d-object3d.xml">Object3D</db:link>'s ability to accept <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> child objects, and treat them in a special way. <db:link xlink:href="qml-qtquick3d-object3d.xml">Object3D</db:link> is the base class for the <db:link xlink:href="qml-qtquick3d-node.xml">Node</db:link> type. This means that any <db:link xlink:href="qml-qtquick3d-node.xml">Node</db:link>, and also types like <db:link xlink:href="qml-qtquick3d-model.xml">Model</db:link>, accept <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> children.</db:para>
<db:para>Starting with Qt 6.0, adding a 2D item to a 3D node no longer triggers rendering the 2D content into a OpenGL texture, Vulkan image, or similar. Rather, the default mode is to render the 2D items in-line with the rest of the 3D scene, in the same render pass. The 2D items have all 3D transformations applied. The transformations are inherited from the wrapping <db:link xlink:href="qml-qtquick3d-node.xml">Node</db:link>.</db:para>
<db:programlisting language="qml">import QtQuick
import QtQuick3D

Rectangle {
    gradient: Gradient {
        GradientStop { position: 0; color: &quot;steelblue&quot; }
        GradientStop { position: 1; color: &quot;black&quot; }
    }
    Text {
        text: &quot;Hello 2D World&quot;
        font.pointSize: 32
        color: &quot;red&quot;
        anchors.top: parent.top
        anchors.horizontalCenter: parent.horizontalCenter
    }
    Item {
        width: 400; height: 400
        anchors.centerIn: parent
        View3D {
            anchors.fill: parent
            environment: SceneEnvironment { backgroundMode: SceneEnvironment.Color; clearColor: &quot;lightGray&quot; }
            PerspectiveCamera { z: 600 }
            DirectionalLight { }
            Model {
                Node {
                    y: 150
                    Rectangle {
                        anchors.horizontalCenter: parent.horizontalCenter
                        color: &quot;white&quot;
                        width: text3d.width
                        height: text3d.height
                        Text {
                            id: text3d
                            text: &quot;Hello 3D World&quot;
                            font.pointSize: 32
                        }
                    }
                }
                source: &quot;#Cube&quot;
                materials: PrincipledMaterial { baseColor: &quot;green&quot;; metalness: 0.0; roughness: 0.0 }
                eulerRotation: Qt.vector3d(30, 45, 0)
            }
        }
    }
}
</db:programlisting>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick2d-3d-2.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:para>Compared to the first snippet, the <db:link xlink:href="qml-qtquick3d-model.xml">Model</db:link> node now has a child node, with a transform that places it somewhat above the cube's position. <db:code>150</db:code> is relative to the cube's center, in the 3D coordinate space.</db:para>
<db:programlisting language="qml">Model {
    Node {
        y: 150
</db:programlisting>
<db:para>Then there is the <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link> item. When adding it under a <db:link xlink:href="qml-qtquick3d-node.xml">Node</db:link>, the boundaries of the 3D and 2D world are crossed internally, but this remains transparent to the application designer. An invisible <db:code>content item</db:code> is generated automatically, allowing the Rectangle to refer to <db:code>parent</db:code> and perform anchoring. The 3D transform from the Node is applied to the entire 2D subtree. In the example this means that the rotation will match the cube's rotation.</db:para>
<db:programlisting language="qml">Node {
    y: 150
    Rectangle {
        anchors.horizontalCenter: parent.horizontalCenter
</db:programlisting>
<db:section xml:id="coordinate-spaces-in-2d-and-3d">
<db:title>Coordinate Spaces in 2D and 3D</db:title>
<db:para>The 2D items continue to use Qt Quick's coordinate system: Y axis runs from top to bottom, and the units correspond to pixels. 3D nodes on the other hand use the 3D coordinate system: the Y axis points up, and the units correspond to centimeters, affected by the <db:link xlink:href="qml-qtquick3d-camera.xml">Camera</db:link>'s perspective projection.</db:para>
<db:para>The top item's top-left corner is placed at the Node's origin by default. This means that the top-level item in a 2D subtree will often want to specify an anchor, for example <db:code>anchors.centerIn: parent</db:code>, or, like in the example, anchoring the horizontal center to the parent' horizontal center, thus centering the 2D content horizontally over the 3D node.</db:para>
</db:section>
<db:section xml:id="further-considerations">
<db:title>Further Considerations</db:title>
<db:itemizedlist>
<db:listitem>
<db:para>While the 2D items are rended in-line with 3D objects, they do not participate in lighting, and will not be casting shadows.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick-item.xml#clip-prop">Clipping</db:link> may not perform as expected and should be avoided. If clipping is essential to the design of 2D items, the application should make an explicit fall back to rendering to a texture. This can be achieved by adding <db:code>layer.enabled: true</db:code> to the top-level <db:code>Item</db:code> under the 3D node.</db:para>
</db:listitem>
<db:listitem>
<db:para>As of Qt 6.2, input is passed to the 2D items as necessary. Input from pointing devices must occur within the <db:link xlink:href="qml-qtquick-item.xml#childrenRect.x-prop">childrenRect</db:link> of the declared Items.</db:para>
</db:listitem>
<db:listitem>
<db:para>While adding a 2D item tree into the 3D scene is fairly cheap, excess amounts (hundreds or more) of 2D subtrees within the 3D scene should be avoided, because in large amounts this may lead to increased memory and graphics resource usage. Note that this refers to the number of separate <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> subtrees under 3D nodes, not the total number of 2D items in those subtrees. For example, the QML snippet above contains only one 2D subtree.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick3d-quickitems-example.xml">Qt Quick 3D - Quick Items Example</db:link></db:member>
<db:member><db:link xlink:href="qquickitem.xml#mapFromGlobal-2">QQuickItem::mapFromGlobal</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
