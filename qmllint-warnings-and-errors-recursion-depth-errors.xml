<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Recursion depths errors</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Qml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>[recursion-depth-errors] Qml statement or expression is too deeply nested.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>This warning category is spelled [recursion-depth-errors] by qmllint.</db:para>
<db:section xml:id="maximum-statement-or-expression-depth-exceeded">
<db:title>Maximum statement or expression depth exceeded</db:title>
<db:section xml:id="what-happened">
<db:title>What happened?</db:title>
<db:para>A QML statement or expression was too deeply nested for the compiler. This usually only happens for generated code where statements or expressions can be very long, as the recursion limit is usually large enough for any sensible QML document.</db:para>
</db:section>
<db:section xml:id="why-is-this-bad">
<db:title>Why is this bad?</db:title>
<db:para>The QML engine will not be able to run this code.</db:para>
</db:section>
<db:section xml:id="example">
<db:title>Example</db:title>
<db:programlisting language="qml">import QtQuick

Item {
    function f() {
        let x = 1 + 1 + .... + 1 // maximum depth exceeded: add too many ones together
        return x
    }

    Item { Item { .... } } // maximum depth exceeded: too many nested Item's
}
</db:programlisting>
<db:para>To fix this warning, auto-generate smaller code pieces. Split deeply nested Components in multiple files or inline components, or split deeply nested expressions into multiple expressions:</db:para>
<db:programlisting language="qml">import QtQuick

Item {
    function f() {
        let x = 1 + 1 + .... + 1 // first half of the split
        x += 1 + 1 + .... + 1 // second half of the split
        return x
    }

    component NestedItem : Item { Item {... }} // first half of the nested Item
    component DeeplyNestedItem: Item { ... NestedItem{} ... } // second half of the nested Items + NestedItem
    DeeplyNestedItem {}
}
</db:programlisting>
</db:section>
</db:section>
</db:article>
