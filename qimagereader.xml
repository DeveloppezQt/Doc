<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QImageReader Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qimagereader.xml">QImageReader</db:link> class provides a format independent interface for reading images from files or other devices.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QImageReader</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Gui)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QImageReader is part of <db:simplelist><db:member><db:link xlink:href="painting.xml">Painting Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The most common way to read images is through <db:link xlink:href="qimage.xml">QImage</db:link> and <db:link xlink:href="qpixmap.xml">QPixmap</db:link>'s constructors, or by calling QImage::load() and <db:link xlink:href="qpixmap.xml#load">QPixmap::load</db:link>(). <db:link xlink:href="qimagereader.xml">QImageReader</db:link> is a specialized class which gives you more control when reading images. For example, you can read an image into a specific size by calling <db:link xlink:href="qimagereader.xml#setScaledSize">setScaledSize</db:link>(), and you can select a clip rect, effectively loading only parts of an image, by calling <db:link xlink:href="qimagereader.xml#setClipRect">setClipRect</db:link>(). Depending on the underlying support in the image format, this can save memory and speed up loading of images.</db:para>
<db:para>To read an image, you start by constructing a <db:link xlink:href="qimagereader.xml">QImageReader</db:link> object. Pass either a file name or a device pointer, and the image format to <db:link xlink:href="qimagereader.xml">QImageReader</db:link>'s constructor. You can then set several options, such as the clip rect (by calling <db:link xlink:href="qimagereader.xml#setClipRect">setClipRect</db:link>()) and scaled size (by calling <db:link xlink:href="qimagereader.xml#setScaledSize">setScaledSize</db:link>()). <db:link xlink:href="qimagereader.xml#canRead">canRead</db:link>() returns the image if the <db:link xlink:href="qimagereader.xml">QImageReader</db:link> can read the image (i.e., the image format is supported and the device is open for reading). Call <db:link xlink:href="qimagereader.xml#read">read</db:link>() to read the image.</db:para>
<db:para>If any error occurs when reading the image, <db:link xlink:href="qimagereader.xml#read">read</db:link>() will return a null <db:link xlink:href="qimage.xml">QImage</db:link>. You can then call <db:link xlink:href="qimagereader.xml#error">error</db:link>() to find the type of error that occurred, or <db:link xlink:href="qimagereader.xml#errorString">errorString</db:link>() to get a human readable description of what went wrong.</db:para>
<db:note>
<db:para><db:link xlink:href="qimagereader.xml">QImageReader</db:link> assumes exclusive control over the file or device that is assigned. Any attempts to modify the assigned file or device during the lifetime of the <db:link xlink:href="qimagereader.xml">QImageReader</db:link> object will yield undefined results.</db:para>
</db:note>
<db:section xml:id="formats">
<db:title>Formats</db:title>
<db:para>Call <db:link xlink:href="qimagereader.xml#supportedImageFormats">supportedImageFormats</db:link>() for a list of formats that <db:link xlink:href="qimagereader.xml">QImageReader</db:link> can read. <db:link xlink:href="qimagereader.xml">QImageReader</db:link> supports all built-in image formats, in addition to any image format plugins that support reading. Call <db:link xlink:href="qimagereader.xml#supportedMimeTypes">supportedMimeTypes</db:link>() to obtain a list of supported MIME types, which for example can be passed to <db:link xlink:href="qfiledialog.xml#setMimeTypeFilters">QFileDialog::setMimeTypeFilters</db:link>().</db:para>
<db:para><db:link xlink:href="qimagereader.xml">QImageReader</db:link> autodetects the image format by default, by looking at the provided (optional) format string, the file name suffix, and the data stream contents. You can enable or disable this feature, by calling <db:link xlink:href="qimagereader.xml#setAutoDetectImageFormat">setAutoDetectImageFormat</db:link>().</db:para>
</db:section>
<db:section xml:id="high-resolution-versions-of-images">
<db:title>High Resolution Versions of Images</db:title>
<db:para>It is possible to provide high resolution versions of images should a scaling between <db:emphasis>device pixels</db:emphasis> and <db:emphasis>device independent pixels</db:emphasis> be in effect.</db:para>
<db:para>The high resolution version is marked by the suffix <db:code>@2x</db:code> on the base name. The image read will have its <db:emphasis>device pixel ratio</db:emphasis> set to a value of 2.</db:para>
<db:para>This can be disabled by setting the environment variable <db:code>QT_HIGHDPI_DISABLE_2X_IMAGE_LOADING</db:code>.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagewriter.xml">QImageWriter</db:link></db:member>
<db:member><db:link xlink:href="qimageiohandler.xml">QImageIOHandler</db:link></db:member>
<db:member><db:link xlink:href="qimageioplugin.xml">QImageIOPlugin</db:link></db:member>
<db:member><db:link xlink:href="qmimedatabase.xml">QMimeDatabase</db:link></db:member>
<db:member><db:link xlink:href="qcolorspace.xml">QColorSpace</db:link></db:member>
<db:member><db:link xlink:href="">QImage::devicePixelRatio</db:link>()</db:member>
<db:member><db:link xlink:href="qpixmap.xml#devicePixelRatio">QPixmap::devicePixelRatio</db:link>()</db:member>
<db:member><db:link xlink:href="qicon.xml">QIcon</db:link></db:member>
<db:member><db:link xlink:href="qpainter.xml#drawPixmap">QPainter::drawPixmap</db:link>()</db:member>
<db:member><db:link xlink:href="qpainter.xml#drawImage">QPainter::drawImage</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ImageReaderError-enum">
<db:title>enum QImageReader::ImageReaderError</db:title>
<db:enumsynopsis>
<db:enumname>ImageReaderError</db:enumname>
<db:enumitem>
<db:enumidentifier>UnknownError</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>FileNotFoundError</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DeviceError</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnsupportedFormatError</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>InvalidDataError</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the different types of errors that can occur when reading images with <db:link xlink:href="qimagereader.xml">QImageReader</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimagereader.xml">QImageReader</db:link></db:emphasis>::FileNotFoundError</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qimagereader.xml">QImageReader</db:link> was used with a file name, but not file was found with that name. This can also happen if the file name contained no extension, and the file with the correct extension is not supported by Qt.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimagereader.xml">QImageReader</db:link></db:emphasis>::DeviceError</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qimagereader.xml">QImageReader</db:link> encountered a device error when reading the image. You can consult your particular device for more details on what went wrong.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimagereader.xml">QImageReader</db:link></db:emphasis>::UnsupportedFormatError</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>Qt does not support the requested image format.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimagereader.xml">QImageReader</db:link></db:emphasis>::InvalidDataError</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The image data was invalid, and <db:link xlink:href="qimagereader.xml">QImageReader</db:link> was unable to read an image from it. The can happen if the image file is damaged.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimagereader.xml">QImageReader</db:link></db:emphasis>::UnknownError</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>An unknown error occurred. If you get this value after calling <db:link xlink:href="qimagereader.xml#read">read</db:link>(), it is most likely caused by a bug in <db:link xlink:href="qimagereader.xml">QImageReader</db:link>.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QImageReader">
<db:title>QImageReader::QImageReader()</db:title>
<db:constructorsynopsis>
<db:methodname>QImageReader</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QImageReader()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty <db:link xlink:href="qimagereader.xml">QImageReader</db:link> object. Before reading an image, call <db:link xlink:href="qimagereader.xml#setDevice">setDevice</db:link>() or <db:link xlink:href="qimagereader.xml#setFileName">setFileName</db:link>().</db:para>
</db:section>
<db:section xml:id="QImageReader-1">
<db:title>[explicit] QImageReader::QImageReader(QIODevice *<db:emphasis>device</db:emphasis>, const QByteArray &amp;<db:emphasis>format</db:emphasis> = QByteArray())</db:title>
<db:constructorsynopsis>
<db:methodname>QImageReader</db:methodname>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>format</db:parameter>
<db:initializer>QByteArray()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QImageReader(QIODevice *device, const QByteArray &amp;format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qimagereader.xml">QImageReader</db:link> object with the device <db:code role="parameter">device</db:code> and the image format <db:code role="parameter">format</db:code>.</db:para>
</db:section>
<db:section xml:id="QImageReader-2">
<db:title>[explicit] QImageReader::QImageReader(const QString &amp;<db:emphasis>fileName</db:emphasis>, const QByteArray &amp;<db:emphasis>format</db:emphasis> = QByteArray())</db:title>
<db:constructorsynopsis>
<db:methodname>QImageReader</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>fileName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>format</db:parameter>
<db:initializer>QByteArray()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QImageReader(const QString &amp;fileName, const QByteArray &amp;format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qimagereader.xml">QImageReader</db:link> object with the file name <db:code role="parameter">fileName</db:code> and the image format <db:code role="parameter">format</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setFileName">setFileName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QImageReader">
<db:title>QImageReader::~QImageReader()</db:title>
<db:destructorsynopsis>
<db:methodname>~QImageReader</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QImageReader()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destructs the <db:link xlink:href="qimagereader.xml">QImageReader</db:link> object.</db:para>
</db:section>
<db:section xml:id="allocationLimit">
<db:title>[static, since 6.0] int QImageReader::allocationLimit()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>int</db:type>
<db:methodname>allocationLimit</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int allocationLimit()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current allocation limit, in megabytes.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setAllocationLimit">setAllocationLimit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="autoDetectImageFormat">
<db:title>bool QImageReader::autoDetectImageFormat() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>autoDetectImageFormat</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool autoDetectImageFormat() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if image format autodetection is enabled on this image reader; otherwise returns <db:code>false</db:code>. By default, autodetection is enabled.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setAutoDetectImageFormat">setAutoDetectImageFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="autoTransform">
<db:title>bool QImageReader::autoTransform() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>autoTransform</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool autoTransform() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the image handler will apply transformation metadata on <db:link xlink:href="qimagereader.xml#read">read</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setAutoTransform">setAutoTransform</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#transformation">transformation</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="backgroundColor">
<db:title>QColor QImageReader::backgroundColor() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QColor</db:type>
<db:methodname>backgroundColor</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QColor backgroundColor() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the background color that's used when reading an image. If the image format does not support setting the background color an invalid color is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setBackgroundColor">setBackgroundColor</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canRead">
<db:title>bool QImageReader::canRead() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>canRead</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool canRead() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if an image can be read for the device (i.e., the image format is supported, and the device seems to contain valid data); otherwise returns <db:code>false</db:code>.</db:para>
<db:para>canRead() is a lightweight function that only does a quick test to see if the image data is valid. <db:link xlink:href="qimagereader.xml#read">read</db:link>() may still return false after canRead() returns <db:code>true</db:code>, if the image data is corrupt.</db:para>
<db:note>
<db:para>A <db:link xlink:href="qmimedatabase.xml">QMimeDatabase</db:link> lookup is normally a better approach than this function for identifying potentially non-image files or data.</db:para>
</db:note>
<db:para>For images that support animation, canRead() returns <db:code>false</db:code> when all frames have been read.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#read">read</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#supportedImageFormats">supportedImageFormats</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedatabase.xml">QMimeDatabase</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clipRect">
<db:title>QRect QImageReader::clipRect() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRect</db:type>
<db:methodname>clipRect</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRect clipRect() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the clip rect (also known as the ROI, or Region Of Interest) of the image. If no clip rect has been set, an invalid <db:link xlink:href="qrect.xml">QRect</db:link> is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setClipRect">setClipRect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentImageNumber">
<db:title>int QImageReader::currentImageNumber() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>currentImageNumber</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int currentImageNumber() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function returns the sequence number of the current frame. If the image format doesn't support animation, 0 is returned.</db:para>
<db:para>This function returns -1 if an error occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#supportsAnimation">supportsAnimation</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#currentImageNumber">QImageIOHandler::currentImageNumber</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#canRead">canRead</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentImageRect">
<db:title>QRect QImageReader::currentImageRect() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRect</db:type>
<db:methodname>currentImageRect</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRect currentImageRect() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function returns the rect for the current frame. Otherwise, a null rect is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#supportsAnimation">supportsAnimation</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#currentImageRect">QImageIOHandler::currentImageRect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="decideFormatFromContent">
<db:title>bool QImageReader::decideFormatFromContent() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>decideFormatFromContent</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool decideFormatFromContent() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns whether the image reader should decide which plugin to use only based on the contents of the datastream rather than on the file extension.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setDecideFormatFromContent">setDecideFormatFromContent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="device">
<db:title>QIODevice *QImageReader::device() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QIODevice *</db:type>
<db:methodname>device</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QIODevice * device() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the device currently assigned to <db:link xlink:href="qimagereader.xml">QImageReader</db:link>, or <db:code>nullptr</db:code> if no device has been assigned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setDevice">setDevice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="error">
<db:title>QImageReader::ImageReaderError QImageReader::error() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImageReader::ImageReaderError</db:type>
<db:methodname>error</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImageReader::ImageReaderError error() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the type of error that occurred last.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#ImageReaderError-enum">ImageReaderError</db:link></db:member>
<db:member><db:link xlink:href="qimagereader.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QImageReader::errorString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>errorString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString errorString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a human readable description of the last error that occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#error">error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fileName">
<db:title>QString QImageReader::fileName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>fileName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString fileName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If the currently assigned device is a <db:link xlink:href="qfile.xml">QFile</db:link>, or if <db:link xlink:href="qimagereader.xml#setFileName">setFileName</db:link>() has been called, this function returns the name of the file <db:link xlink:href="qimagereader.xml">QImageReader</db:link> reads from. Otherwise (i.e., if no device has been assigned or the device is not a <db:link xlink:href="qfile.xml">QFile</db:link>), an empty <db:link xlink:href="qstring.xml">QString</db:link> is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setFileName">setFileName</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#setDevice">setDevice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="format">
<db:title>QByteArray QImageReader::format() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>format</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray format() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the format <db:link xlink:href="qimagereader.xml">QImageReader</db:link> uses for reading images.</db:para>
<db:para>You can call this function after assigning a device to the reader to determine the format of the device. For example:</db:para>
<db:programlisting language="cpp">QImageReader reader(&quot;image.png&quot;);
// reader.format() == &quot;png&quot;
</db:programlisting>
<db:para>If the reader cannot read any image from the device (e.g., there is no image there, or the image has already been read), or if the format is unsupported, this function returns an empty QByteArray().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setFormat">setFormat</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#supportedImageFormats">supportedImageFormats</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="imageCount">
<db:title>int QImageReader::imageCount() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>imageCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int imageCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function returns the total number of images in the animation. If the format does not support animation, 0 is returned.</db:para>
<db:para>This function returns -1 if an error occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#supportsAnimation">supportsAnimation</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#imageCount">QImageIOHandler::imageCount</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#canRead">canRead</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="imageFormat">
<db:title>QImage::Format QImageReader::imageFormat() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage::Format</db:type>
<db:methodname>imageFormat</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage::Format imageFormat() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the format of the image, without actually reading the image contents. The format describes the image format <db:link xlink:href="qimagereader.xml#read">QImageReader::read</db:link>() returns, not the format of the actual image.</db:para>
<db:para>If the image format does not support this feature, this function returns an invalid format.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#ImageOption-enum">QImageIOHandler::ImageOption</db:link></db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#option">QImageIOHandler::option</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#supportsOption">QImageIOHandler::supportsOption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="imageFormat-1">
<db:title>[static] QByteArray QImageReader::imageFormat(const QString &amp;<db:emphasis>fileName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>imageFormat</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>fileName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray imageFormat(const QString &amp;fileName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If supported, this function returns the image format of the file <db:code role="parameter">fileName</db:code>. Otherwise, an empty string is returned.</db:para>
</db:section>
<db:section xml:id="imageFormat-2">
<db:title>[static] QByteArray QImageReader::imageFormat(QIODevice *<db:emphasis>device</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>imageFormat</db:methodname>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray imageFormat(QIODevice *device)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If supported, this function returns the image format of the device <db:code role="parameter">device</db:code>. Otherwise, an empty string is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#autoDetectImageFormat">QImageReader::autoDetectImageFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="imageFormatsForMimeType">
<db:title>[static] QList&lt;QByteArray&gt; QImageReader::imageFormatsForMimeType(const QByteArray &amp;<db:emphasis>mimeType</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QList&lt;QByteArray&gt;</db:type>
<db:methodname>imageFormatsForMimeType</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>mimeType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QByteArray&gt; imageFormatsForMimeType(const QByteArray &amp;mimeType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of image formats corresponding to <db:code role="parameter">mimeType</db:code>.</db:para>
<db:para>Note that the <db:link xlink:href="qguiapplication.xml">QGuiApplication</db:link> instance must be created before this function is called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#supportedImageFormats">supportedImageFormats</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#supportedMimeTypes">supportedMimeTypes</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="jumpToImage">
<db:title>bool QImageReader::jumpToImage(int <db:emphasis>imageNumber</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>jumpToImage</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>imageNumber</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool jumpToImage(int imageNumber)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function skips to the image whose sequence number is <db:code role="parameter">imageNumber</db:code>, returning true if successful or false if the corresponding image cannot be found.</db:para>
<db:para>The next call to <db:link xlink:href="qimagereader.xml#read">read</db:link>() will attempt to read this image.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#jumpToNextImage">jumpToNextImage</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#jumpToImage">QImageIOHandler::jumpToImage</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="jumpToNextImage">
<db:title>bool QImageReader::jumpToNextImage()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>jumpToNextImage</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool jumpToNextImage()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function steps over the current image, returning true if successful or false if there is no following image in the animation.</db:para>
<db:para>The default implementation calls <db:link xlink:href="qimagereader.xml#read">read</db:link>(), then discards the resulting image, but the image handler may have a more efficient way of implementing this operation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#jumpToImage">jumpToImage</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#jumpToNextImage">QImageIOHandler::jumpToNextImage</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="loopCount">
<db:title>int QImageReader::loopCount() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>loopCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int loopCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function returns the number of times the animation should loop. If this function returns -1, it can either mean the animation should loop forever, or that an error occurred. If an error occurred, <db:link xlink:href="qimagereader.xml#canRead">canRead</db:link>() will return false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#supportsAnimation">supportsAnimation</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#loopCount">QImageIOHandler::loopCount</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#canRead">canRead</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nextImageDelay">
<db:title>int QImageReader::nextImageDelay() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>nextImageDelay</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int nextImageDelay() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For image formats that support animation, this function returns the number of milliseconds to wait until displaying the next frame in the animation. If the image format doesn't support animation, 0 is returned.</db:para>
<db:para>This function returns -1 if an error occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#supportsAnimation">supportsAnimation</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#nextImageDelay">QImageIOHandler::nextImageDelay</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#canRead">canRead</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quality">
<db:title>int QImageReader::quality() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>quality</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int quality() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the quality setting of the image format.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setQuality">setQuality</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="read">
<db:title>QImage QImageReader::read()</db:title>
<db:methodsynopsis>
<db:type>QImage</db:type>
<db:methodname>read</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage read()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads an image from the device. On success, the image that was read is returned; otherwise, a null <db:link xlink:href="qimage.xml">QImage</db:link> is returned. You can then call <db:link xlink:href="qimagereader.xml#error">error</db:link>() to find the type of error that occurred, or <db:link xlink:href="qimagereader.xml#errorString">errorString</db:link>() to get a human readable description of the error.</db:para>
<db:para>For image formats that support animation, calling read() repeatedly will return the next frame. When all frames have been read, a null image will be returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#canRead">canRead</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#supportedImageFormats">supportedImageFormats</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#supportsAnimation">supportsAnimation</db:link>()</db:member>
<db:member><db:link xlink:href="qmovie.xml">QMovie</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="read-1">
<db:title>bool QImageReader::read(QImage *<db:emphasis>image</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>read</db:methodname>
<db:methodparam>
<db:type>QImage *</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool read(QImage *image)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Reads an image from the device into <db:code role="parameter">image</db:code>, which must point to a <db:link xlink:href="qimage.xml">QImage</db:link>. Returns <db:code>true</db:code> on success; otherwise, returns <db:code>false</db:code>.</db:para>
<db:para>If <db:code role="parameter">image</db:code> has same format and size as the image data that is about to be read, this function may not need to allocate a new image before reading. Because of this, it can be faster than the other <db:link xlink:href="qimagereader.xml#read">read</db:link>() overload, which always constructs a new image; especially when reading several images with the same format and size.</db:para>
<db:programlisting language="cpp">QImage icon(64, 64, QImage::Format_RGB32);
QImageReader reader(&quot;icon_64x64.bmp&quot;);
if (reader.read(&amp;amp;icon)) {
    // Display icon
}
</db:programlisting>
<db:para>For image formats that support animation, calling <db:link xlink:href="qimagereader.xml#read">read</db:link>() repeatedly will return the next frame. When all frames have been read, a null image will be returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#canRead">canRead</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#supportedImageFormats">supportedImageFormats</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#supportsAnimation">supportsAnimation</db:link>()</db:member>
<db:member><db:link xlink:href="qmovie.xml">QMovie</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="scaledClipRect">
<db:title>QRect QImageReader::scaledClipRect() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRect</db:type>
<db:methodname>scaledClipRect</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRect scaledClipRect() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the scaled clip rect of the image.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setScaledClipRect">setScaledClipRect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="scaledSize">
<db:title>QSize QImageReader::scaledSize() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSize</db:type>
<db:methodname>scaledSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSize scaledSize() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the scaled size of the image.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setScaledSize">setScaledSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAllocationLimit">
<db:title>[static, since 6.0] void QImageReader::setAllocationLimit(int <db:emphasis>mbLimit</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>setAllocationLimit</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>mbLimit</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setAllocationLimit(int mbLimit)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the allocation limit to <db:code role="parameter">mbLimit</db:code> megabytes. Images that would require a <db:link xlink:href="qimage.xml">QImage</db:link> memory allocation above this limit will be rejected. If <db:code role="parameter">mbLimit</db:code> is 0, the allocation size check will be disabled.</db:para>
<db:para>This limit helps applications avoid unexpectedly large memory usage from loading corrupt image files. It is normally not needed to change it. The default limit is large enough for all commonly used image sizes.</db:para>
<db:para>At runtime, this value may be overridden by the environment variable <db:code>QT_IMAGEIO_MAXALLOC</db:code>.</db:para>
<db:note>
<db:para>The memory requirements are calculated for a minimum of 32 bits per pixel, since Qt will typically convert an image to that depth when it is used in GUI. This means that the effective allocation limit is significantly smaller than <db:code role="parameter">mbLimit</db:code> when reading 1 bpp and 8 bpp images.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#allocationLimit">allocationLimit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAutoDetectImageFormat">
<db:title>void QImageReader::setAutoDetectImageFormat(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setAutoDetectImageFormat</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enabled</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setAutoDetectImageFormat(bool enabled)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">enabled</db:code> is true, image format autodetection is enabled; otherwise, it is disabled. By default, autodetection is enabled.</db:para>
<db:para><db:link xlink:href="qimagereader.xml">QImageReader</db:link> uses an extensive approach to detecting the image format; firstly, if you pass a file name to <db:link xlink:href="qimagereader.xml">QImageReader</db:link>, it will attempt to detect the file extension if the given file name does not point to an existing file, by appending supported default extensions to the given file name, one at a time. It then uses the following approach to detect the image format:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Image plugins are queried first, based on either the optional format string, or the file name suffix (if the source device is a file). No content detection is done at this stage. <db:link xlink:href="qimagereader.xml">QImageReader</db:link> will choose the first plugin that supports reading for this format.</db:para>
</db:listitem>
<db:listitem>
<db:para>If no plugin supports the image format, Qt's built-in handlers are checked based on either the optional format string, or the file name suffix.</db:para>
</db:listitem>
<db:listitem>
<db:para>If no capable plugins or built-in handlers are found, each plugin is tested by inspecting the content of the data stream.</db:para>
</db:listitem>
<db:listitem>
<db:para>If no plugins could detect the image format based on data contents, each built-in image handler is tested by inspecting the contents.</db:para>
</db:listitem>
<db:listitem>
<db:para>Finally, if all above approaches fail, <db:link xlink:href="qimagereader.xml">QImageReader</db:link> will report failure when trying to read the image.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>By disabling image format autodetection, <db:link xlink:href="qimagereader.xml">QImageReader</db:link> will only query the plugins and built-in handlers based on the format string (i.e., no file name extensions are tested).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#autoDetectImageFormat">autoDetectImageFormat</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#canRead">QImageIOHandler::canRead</db:link>()</db:member>
<db:member><db:link xlink:href="qimageioplugin.xml#capabilities">QImageIOPlugin::capabilities</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAutoTransform">
<db:title>void QImageReader::setAutoTransform(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setAutoTransform</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enabled</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setAutoTransform(bool enabled)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Determines that images returned by <db:link xlink:href="qimagereader.xml#read">read</db:link>() should have transformation metadata automatically applied if <db:code role="parameter">enabled</db:code> is <db:code>true</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#autoTransform">autoTransform</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#transformation">transformation</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setBackgroundColor">
<db:title>void QImageReader::setBackgroundColor(const QColor &amp;<db:emphasis>color</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setBackgroundColor</db:methodname>
<db:methodparam>
<db:type>const QColor &amp;</db:type>
<db:parameter>color</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setBackgroundColor(const QColor &amp;color)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the background color to <db:code role="parameter">color</db:code>. Image formats that support this operation are expected to initialize the background to <db:code role="parameter">color</db:code> before reading an image.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#backgroundColor">backgroundColor</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setClipRect">
<db:title>void QImageReader::setClipRect(const QRect &amp;<db:emphasis>rect</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setClipRect</db:methodname>
<db:methodparam>
<db:type>const QRect &amp;</db:type>
<db:parameter>rect</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setClipRect(const QRect &amp;rect)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the image clip rect (also known as the ROI, or Region Of Interest) to <db:code role="parameter">rect</db:code>. The coordinates of <db:code role="parameter">rect</db:code> are relative to the untransformed image size, as returned by <db:link xlink:href="qimagereader.xml#size">size</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#clipRect">clipRect</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#setScaledSize">setScaledSize</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#setScaledClipRect">setScaledClipRect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDecideFormatFromContent">
<db:title>void QImageReader::setDecideFormatFromContent(bool <db:emphasis>ignored</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDecideFormatFromContent</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>ignored</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDecideFormatFromContent(bool ignored)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">ignored</db:code> is set to true, then the image reader will ignore specified formats or file extensions and decide which plugin to use only based on the contents in the datastream.</db:para>
<db:para>Setting this flag means that all image plugins gets loaded. Each plugin will read the first bytes in the image data and decide if the plugin is compatible or not.</db:para>
<db:para>This also disables auto detecting the image format.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#decideFormatFromContent">decideFormatFromContent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDevice">
<db:title>void QImageReader::setDevice(QIODevice *<db:emphasis>device</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDevice</db:methodname>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDevice(QIODevice *device)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets <db:link xlink:href="qimagereader.xml">QImageReader</db:link>'s device to <db:code role="parameter">device</db:code>. If a device has already been set, the old device is removed from <db:link xlink:href="qimagereader.xml">QImageReader</db:link> and is otherwise left unchanged.</db:para>
<db:para>If the device is not already open, <db:link xlink:href="qimagereader.xml">QImageReader</db:link> will attempt to open the device in <db:link xlink:href="qiodevicebase.xml#OpenModeFlag-enum">ReadOnly</db:link> mode by calling open(). Note that this does not work for certain devices, such as <db:link xlink:href="qprocess.xml">QProcess</db:link>, <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> and <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link>, where more logic is required to open the device.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#device">device</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#setFileName">setFileName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFileName">
<db:title>void QImageReader::setFileName(const QString &amp;<db:emphasis>fileName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFileName</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>fileName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFileName(const QString &amp;fileName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the file name of <db:link xlink:href="qimagereader.xml">QImageReader</db:link> to <db:code role="parameter">fileName</db:code>. Internally, <db:link xlink:href="qimagereader.xml">QImageReader</db:link> will create a <db:link xlink:href="qfile.xml">QFile</db:link> object and open it in <db:link xlink:href="qiodevicebase.xml#OpenModeFlag-enum">ReadOnly</db:link> mode, and use this when reading images.</db:para>
<db:para>If <db:code role="parameter">fileName</db:code> does not include a file extension (e.g., .png or .bmp), <db:link xlink:href="qimagereader.xml">QImageReader</db:link> will cycle through all supported extensions until it finds a matching file.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#fileName">fileName</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#setDevice">setDevice</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#supportedImageFormats">supportedImageFormats</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFormat">
<db:title>void QImageReader::setFormat(const QByteArray &amp;<db:emphasis>format</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFormat</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFormat(const QByteArray &amp;format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the format <db:link xlink:href="qimagereader.xml">QImageReader</db:link> will use when reading images, to <db:code role="parameter">format</db:code>. <db:code role="parameter">format</db:code> is a case insensitive text string. Example:</db:para>
<db:programlisting language="cpp">QImageReader reader;
reader.setFormat(&quot;png&quot;); // same as reader.setFormat(&quot;PNG&quot;);
</db:programlisting>
<db:para>You can call <db:link xlink:href="qimagereader.xml#supportedImageFormats">supportedImageFormats</db:link>() for the full list of formats <db:link xlink:href="qimagereader.xml">QImageReader</db:link> supports.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#format">format</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setQuality">
<db:title>void QImageReader::setQuality(int <db:emphasis>quality</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setQuality</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>quality</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setQuality(int quality)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the quality setting of the image format to <db:code role="parameter">quality</db:code>.</db:para>
<db:para>Some image formats, in particular lossy ones, entail a tradeoff between a) visual quality of the resulting image, and b) decoding execution time. This function sets the level of that tradeoff for image formats that support it.</db:para>
<db:para>In case of scaled image reading, the quality setting may also influence the tradeoff level between visual quality and execution speed of the scaling algorithm.</db:para>
<db:para>The value range of <db:code role="parameter">quality</db:code> depends on the image format. For example, the &quot;jpeg&quot; format supports a quality range from 0 (low visual quality) to 100 (high visual quality).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#quality">quality</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#setScaledSize">setScaledSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setScaledClipRect">
<db:title>void QImageReader::setScaledClipRect(const QRect &amp;<db:emphasis>rect</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setScaledClipRect</db:methodname>
<db:methodparam>
<db:type>const QRect &amp;</db:type>
<db:parameter>rect</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setScaledClipRect(const QRect &amp;rect)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the scaled clip rect to <db:code role="parameter">rect</db:code>. The scaled clip rect is the clip rect (also known as ROI, or Region Of Interest) that is applied after the image has been scaled.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#scaledClipRect">scaledClipRect</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#setScaledSize">setScaledSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setScaledSize">
<db:title>void QImageReader::setScaledSize(const QSize &amp;<db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setScaledSize</db:methodname>
<db:methodparam>
<db:type>const QSize &amp;</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setScaledSize(const QSize &amp;size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the scaled size of the image to <db:code role="parameter">size</db:code>. The scaling is performed after the initial clip rect, but before the scaled clip rect is applied. The algorithm used for scaling depends on the image format. By default (i.e., if the image format does not support scaling), <db:link xlink:href="qimagereader.xml">QImageReader</db:link> will use QImage::scale() with Qt::SmoothScaling.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#scaledSize">scaledSize</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#setClipRect">setClipRect</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#setScaledClipRect">setScaledClipRect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>QSize QImageReader::size() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSize</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSize size() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size of the image, without actually reading the image contents.</db:para>
<db:para>If the image format does not support this feature, this function returns an invalid size. Qt's built-in image handlers all support this feature, but custom image format plugins are not required to do so.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimageiohandler.xml#ImageOption-enum">QImageIOHandler::ImageOption</db:link></db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#option">QImageIOHandler::option</db:link>()</db:member>
<db:member><db:link xlink:href="qimageiohandler.xml#supportsOption">QImageIOHandler::supportsOption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="subType">
<db:title>QByteArray QImageReader::subType() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>subType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray subType() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the subtype of the image.</db:para>
</db:section>
<db:section xml:id="supportedImageFormats">
<db:title>[static] QList&lt;QByteArray&gt; QImageReader::supportedImageFormats()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QList&lt;QByteArray&gt;</db:type>
<db:methodname>supportedImageFormats</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QByteArray&gt; supportedImageFormats()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of image formats supported by <db:link xlink:href="qimagereader.xml">QImageReader</db:link>.</db:para>
<db:para>By default, Qt can read the following formats:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Format</db:para>
</db:th>
<db:th>
<db:para>MIME type</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>BMP</db:para>
</db:td>
<db:td>
<db:para>image/bmp</db:para>
</db:td>
<db:td>
<db:para>Windows Bitmap</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>GIF</db:para>
</db:td>
<db:td>
<db:para>image/gif</db:para>
</db:td>
<db:td>
<db:para>Graphic Interchange Format (optional)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>JPG</db:para>
</db:td>
<db:td>
<db:para>image/jpeg</db:para>
</db:td>
<db:td>
<db:para>Joint Photographic Experts Group</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>PNG</db:para>
</db:td>
<db:td>
<db:para>image/png</db:para>
</db:td>
<db:td>
<db:para>Portable Network Graphics</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>PBM</db:para>
</db:td>
<db:td>
<db:para>image/x-portable-bitmap</db:para>
</db:td>
<db:td>
<db:para>Portable Bitmap</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>PGM</db:para>
</db:td>
<db:td>
<db:para>image/x-portable-graymap</db:para>
</db:td>
<db:td>
<db:para>Portable Graymap</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>PPM</db:para>
</db:td>
<db:td>
<db:para>image/x-portable-pixmap</db:para>
</db:td>
<db:td>
<db:para>Portable Pixmap</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>XBM</db:para>
</db:td>
<db:td>
<db:para>image/x-xbitmap</db:para>
</db:td>
<db:td>
<db:para>X11 Bitmap</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>XPM</db:para>
</db:td>
<db:td>
<db:para>image/x-xpixmap</db:para>
</db:td>
<db:td>
<db:para>X11 Pixmap</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>SVG</db:para>
</db:td>
<db:td>
<db:para>image/svg+xml</db:para>
</db:td>
<db:td>
<db:para>Scalable Vector Graphics</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Reading and writing SVG files is supported through the <db:link xlink:href="qtsvg-index.xml">Qt SVG</db:link> module. The <db:link xlink:href="qtimageformats-index.xml">Qt Image Formats</db:link> module provides support for additional image formats.</db:para>
<db:para>Note that the <db:link xlink:href="qapplication.xml">QApplication</db:link> instance must be created before this function is called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setFormat">setFormat</db:link>()</db:member>
<db:member><db:link xlink:href="qimagewriter.xml#supportedImageFormats">QImageWriter::supportedImageFormats</db:link>()</db:member>
<db:member><db:link xlink:href="qimageioplugin.xml">QImageIOPlugin</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportedMimeTypes">
<db:title>[static] QList&lt;QByteArray&gt; QImageReader::supportedMimeTypes()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QList&lt;QByteArray&gt;</db:type>
<db:methodname>supportedMimeTypes</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QByteArray&gt; supportedMimeTypes()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of MIME types supported by <db:link xlink:href="qimagereader.xml">QImageReader</db:link>.</db:para>
<db:para>Note that the <db:link xlink:href="qapplication.xml">QApplication</db:link> instance must be created before this function is called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#supportedImageFormats">supportedImageFormats</db:link>()</db:member>
<db:member><db:link xlink:href="qimagewriter.xml#supportedMimeTypes">QImageWriter::supportedMimeTypes</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportedSubTypes">
<db:title>QList&lt;QByteArray&gt; QImageReader::supportedSubTypes() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QByteArray&gt;</db:type>
<db:methodname>supportedSubTypes</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QByteArray&gt; supportedSubTypes() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of subtypes supported by an image.</db:para>
</db:section>
<db:section xml:id="supportsAnimation">
<db:title>bool QImageReader::supportsAnimation() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>supportsAnimation</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool supportsAnimation() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the image format supports animation; otherwise, false is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmovie.xml#supportedFormats">QMovie::supportedFormats</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportsOption">
<db:title>bool QImageReader::supportsOption(QImageIOHandler::ImageOption <db:emphasis>option</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>supportsOption</db:methodname>
<db:methodparam>
<db:type>QImageIOHandler::ImageOption</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool supportsOption(QImageIOHandler::ImageOption option) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the reader supports <db:code role="parameter">option</db:code>; otherwise returns false.</db:para>
<db:para>Different image formats support different options. Call this function to determine whether a certain option is supported by the current format. For example, the PNG format allows you to embed text into the image's metadata (see <db:link xlink:href="qimagereader.xml#text">text</db:link>()), and the BMP format allows you to determine the image's size without loading the whole image into memory (see <db:link xlink:href="qimagereader.xml#size">size</db:link>()).</db:para>
<db:programlisting language="cpp">QImageReader reader(&quot;:/image.png&quot;);
if (reader.supportsOption(QImageIOHandler::Size))
    qDebug() &amp;lt;&amp;lt; &quot;Size:&quot; &amp;lt;&amp;lt; reader.size();
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagewriter.xml#supportsOption">QImageWriter::supportsOption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="text">
<db:title>QString QImageReader::text(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>text</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString text(const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the image text associated with <db:code role="parameter">key</db:code>.</db:para>
<db:para>Support for this option is implemented through <db:link xlink:href="qimageiohandler.xml#ImageOption-enum">QImageIOHandler::Description</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#textKeys">textKeys</db:link>()</db:member>
<db:member><db:link xlink:href="qimagewriter.xml#setText">QImageWriter::setText</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="textKeys">
<db:title>QStringList QImageReader::textKeys() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>textKeys</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList textKeys() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the text keys for this image. You can use these keys with <db:link xlink:href="qimagereader.xml#text">text</db:link>() to list the image text for a certain key.</db:para>
<db:para>Support for this option is implemented through <db:link xlink:href="qimageiohandler.xml#ImageOption-enum">QImageIOHandler::Description</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#text">text</db:link>()</db:member>
<db:member><db:link xlink:href="qimagewriter.xml#setText">QImageWriter::setText</db:link>()</db:member>
<db:member><db:link xlink:href="">QImage::textKeys</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="transformation">
<db:title>QImageIOHandler::Transformations QImageReader::transformation() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImageIOHandler::Transformations</db:type>
<db:methodname>transformation</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImageIOHandler::Transformations transformation() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the transformation metadata of the image, including image orientation. If the format does not support transformation metadata, <db:link xlink:href="qimageiohandler.xml#Transformation-enum">QImageIOHandler::TransformationNone</db:link> is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml#setAutoTransform">setAutoTransform</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml#autoTransform">autoTransform</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
