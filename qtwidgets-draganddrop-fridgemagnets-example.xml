<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Fridge Magnets Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Fridge Magnets example illustrates how to move around several types of MIME-encoded data with drag and drop.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The Fridge Magnets example shows how to supply more than one type of MIME-encoded data with a drag and drop operation.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/fridgemagnets-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>With this application the user can play around with a collection of fridge magnets, using drag and drop to form new sentences from the words on the magnets. The example consists of two classes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>DragLabel is a custom widget representing one single fridge magnet.</db:para>
</db:listitem>
<db:listitem>
<db:para>DragWidget provides the main application window.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>We will first take a look at the DragLabel class, then we will examine the DragWidget class.</db:para>
<db:section xml:id="draglabel-class-definition">
<db:title>DragLabel Class Definition</db:title>
<db:para>Each fridge magnet is represented by an instance of the DragLabel class:</db:para>
<db:programlisting language="cpp">class DragLabel : public QLabel
{
public:
    DragLabel(const QString &amp;text, QWidget *parent);
    QString labelText() const;

private:
    QString m_labelText;
};
</db:programlisting>
<db:para>Each instance of this <db:link xlink:href="qlabel.xml">QLabel</db:link> subclass will be used to display an pixmap generated from a text string. Since we cannot store both text and a pixmap in a standard label, we declare a private variable to hold the original text, and we define an additional member function to allow it to be accessed.</db:para>
</db:section>
<db:section xml:id="draglabel-class-implementation">
<db:title>DragLabel Class Implementation</db:title>
<db:para>In the DragLabel constructor, we first create a <db:link xlink:href="qimage.xml">QImage</db:link> object on which we will draw the fridge magnet's text and frame:</db:para>
<db:programlisting language="cpp">DragLabel::DragLabel(const QString &amp;text, QWidget *parent)
    : QLabel(parent)
{
    QFontMetrics metric(font());
    QSize size = metric.size(Qt::TextSingleLine, text);

    QImage image(size.width() + 12, size.height() + 12, QImage::Format_ARGB32_Premultiplied);
    image.fill(qRgba(0, 0, 0, 0));

    QFont font;
    font.setStyleStrategy(QFont::ForceOutline);
</db:programlisting>
<db:para>Its size depends on the current font size, and its format is <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_ARGB32_Premultiplied</db:link>; i.e., the image is stored using a premultiplied 32-bit ARGB format (0xAARRGGBB).</db:para>
<db:para>We then construct a font object that uses the application's default font, and set its style strategy. The style strategy tells the font matching algorithm what type of fonts should be used to find an appropriate default family. The <db:link xlink:href="qfont.xml#StyleStrategy-enum">QFont::ForceOutline</db:link> forces the use of outline fonts.</db:para>
<db:para>To draw the text and frame onto the image, we use the <db:link xlink:href="qpainter.xml">QPainter</db:link> class. <db:link xlink:href="qpainter.xml">QPainter</db:link> provides highly optimized methods to do most of the drawing GUI programs require. It can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps.</db:para>
<db:programlisting language="cpp">    QLinearGradient gradient(0, 0, 0, image.height()-1);
    gradient.setColorAt(0.0, Qt::white);
    gradient.setColorAt(0.2, QColor(200, 200, 255));
    gradient.setColorAt(0.8, QColor(200, 200, 255));
    gradient.setColorAt(1.0, QColor(127, 127, 200));

    QPainter painter;
    painter.begin(&amp;image);
    painter.setRenderHint(QPainter::Antialiasing);
    painter.setBrush(gradient);
    painter.drawRoundedRect(QRectF(0.5, 0.5, image.width()-1, image.height()-1),
                            25, 25, Qt::RelativeSize);

    painter.setFont(font);
    painter.setBrush(Qt::black);
    painter.drawText(QRect(QPoint(6, 6), size), Qt::AlignCenter, text);
    painter.end();
</db:programlisting>
<db:para>A painter can be activated by passing a paint device to the constructor, or by using the <db:link xlink:href="qpainter.xml#begin">begin</db:link>() method as we do in this example. The <db:link xlink:href="qpainter.xml#end">end</db:link>() method deactivates it. Note that the latter function is called automatically upon destruction when the painter is actived by its constructor. The <db:link xlink:href="qpainter.xml#RenderHint-enum">QPainter::Antialiasing</db:link> render hint ensures that the paint engine will antialias the edges of primitives if possible.</db:para>
<db:para>When the painting is done, we convert our image to a pixmap using <db:link xlink:href="qpixmap.xml">QPixmap</db:link>'s <db:link xlink:href="qpixmap.xml#fromImage">fromImage</db:link>() method. This method also takes an optional flags argument, and converts the given image to a pixmap using the specified flags to control the conversion (the flags argument is a bitwise-OR of the <db:link xlink:href="qt.xml#ImageConversionFlag-enum">Qt::ImageConversionFlags</db:link>; passing 0 for flags sets all the default options).</db:para>
<db:programlisting language="cpp">    setPixmap(QPixmap::fromImage(image));
    m_labelText = text;
}
</db:programlisting>
<db:para>Finally, we set the label's <db:link xlink:href="qlabel.xml#pixmap-prop">pixmap property</db:link> and store the label's text for later use.</db:para>
<db:para><db:emphasis>Note that setting the pixmap clears any previous content, including any text previously set using <db:link xlink:href="qlabel.xml#text-prop">QLabel::setText</db:link>(), and disables the label widget's buddy shortcut, if any.</db:emphasis></db:para>
</db:section>
<db:section xml:id="dragwidget-class-definition">
<db:title>DragWidget Class Definition</db:title>
<db:para>The DragWidget class inherits <db:link xlink:href="qwidget.xml">QWidget</db:link>, providing support for drag and drop operations:</db:para>
<db:programlisting language="cpp">class DragWidget : public QWidget
{
public:
    DragWidget(QWidget *parent = 0);

protected:
    void dragEnterEvent(QDragEnterEvent *event) Q_DECL_OVERRIDE;
    void dragMoveEvent(QDragMoveEvent *event) Q_DECL_OVERRIDE;
    void dropEvent(QDropEvent *event) Q_DECL_OVERRIDE;
    void mousePressEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
};
</db:programlisting>
<db:para>To make the widget responsive to drag and drop operations, we simply reimplement the <db:link xlink:href="qwidget.xml#dragEnterEvent">dragEnterEvent</db:link>(), <db:link xlink:href="qwidget.xml#dragMoveEvent">dragMoveEvent</db:link>() and <db:link xlink:href="qwidget.xml#dropEvent">dropEvent</db:link>() event handlers inherited from <db:link xlink:href="qwidget.xml">QWidget</db:link>.</db:para>
<db:para>We also reimplement <db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>() to make the widget responsive to mouse clicks. This is where we will write code to start drag and drop operations.</db:para>
</db:section>
<db:section xml:id="dragwidget-class-implementation">
<db:title>DragWidget Class Implementation</db:title>
<db:para>In the constructor, we first open the file containing the words on our fridge magnets:</db:para>
<db:programlisting language="cpp">DragWidget::DragWidget(QWidget *parent)
    : QWidget(parent)
{
    QFile dictionaryFile(QStringLiteral(&quot;:/dictionary/words.txt&quot;));
    dictionaryFile.open(QFile::ReadOnly);
    QTextStream inputStream(&amp;dictionaryFile);
</db:programlisting>
<db:para><db:link xlink:href="qfile.xml">QFile</db:link> is an I/O device for reading and writing text and binary files and resources, and may be used by itself or in combination with <db:link xlink:href="qtextstream.xml">QTextStream</db:link> or <db:link xlink:href="qdatastream.xml">QDataStream</db:link>. We have chosen to read the contents of the file using the <db:link xlink:href="qtextstream.xml">QTextStream</db:link> class that provides a convenient interface for reading and writing text.</db:para>
<db:para>We then create the fridge magnets. As long as there is data (the <db:link xlink:href="qtextstream.xml#atEnd">QTextStream::atEnd</db:link>() method returns true if there is no more data to be read from the stream), we read one line at a time using <db:link xlink:href="qtextstream.xml">QTextStream</db:link>'s <db:link xlink:href="qtextstream.xml#readLine">readLine</db:link>() method.</db:para>
<db:programlisting language="cpp">    int x = 5;
    int y = 5;

    while (!inputStream.atEnd()) {
        QString word;
        inputStream &gt;&gt; word;
        if (!word.isEmpty()) {
            DragLabel *wordLabel = new DragLabel(word, this);
            wordLabel-&gt;move(x, y);
            wordLabel-&gt;show();
            wordLabel-&gt;setAttribute(Qt::WA_DeleteOnClose);
            x += wordLabel-&gt;width() + 2;
            if (x &gt;= 245) {
                x = 5;
                y += wordLabel-&gt;height() + 2;
            }
        }
    }
</db:programlisting>
<db:para>For each line, we create a DragLabel object using the read line as text, we calculate its position and ensure that it is visible by calling the <db:link xlink:href="qwidget.xml#show">QWidget::show</db:link>() method. We set the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_DeleteOnClose</db:link> attribute on each label to ensure that any unused labels will be deleted; we will need to create new labels and delete old ones when they are dragged around, and this ensures that the example does not leak memory.</db:para>
<db:para>We also set the FridgeMagnets widget's palette, minimum size and window title.</db:para>
<db:programlisting language="cpp">    QPalette newPalette = palette();
    newPalette.setColor(QPalette::Window, Qt::white);
    setPalette(newPalette);

    setMinimumSize(400, qMax(200, y));
    setWindowTitle(tr(&quot;Fridge Magnets&quot;));
</db:programlisting>
<db:para>Finally, to enable our user to move the fridge magnets around, we must also set the FridgeMagnets widget's <db:link xlink:href="qwidget.xml#acceptDrops-prop">acceptDrops</db:link> property.</db:para>
<db:programlisting language="cpp">    setAcceptDrops(true);
}
</db:programlisting>
<db:para>Setting this property to true announces to the system that this widget <db:emphasis>may</db:emphasis> be able to accept drop events (events that are sent when drag and drop actions are completed). Later, we will implement the functions that ensure that the widget accepts the drop events it is interested in.</db:para>
<db:section xml:id="dragging">
<db:title>Dragging</db:title>
<db:para>Let's take a look at the <db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>() event handler, where drag and drop operations begin:</db:para>
<db:programlisting language="cpp">void DragWidget::mousePressEvent(QMouseEvent *event)
{
    DragLabel *child = static_cast&lt;DragLabel*&gt;(childAt(event-&gt;pos()));
    if (!child)
        return;

    QPoint hotSpot = event-&gt;pos() - child-&gt;pos();

    QByteArray itemData;
    QDataStream dataStream(&amp;itemData, QIODevice::WriteOnly);
    dataStream &lt;&lt; child-&gt;labelText() &lt;&lt; QPoint(hotSpot);
</db:programlisting>
<db:para>Mouse events occur when a mouse button is pressed or released inside a widget, or when the mouse cursor is moved. By reimplementing the <db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>() method we ensure that we will receive mouse press events for the widget containing the fridge magnets.</db:para>
<db:para>Whenever we receive such an event, we first check to see if the position of the click coincides with one of the labels. If not, we simply return.</db:para>
<db:para>If the user clicked a label, we determine the position of the <db:emphasis>hot spot</db:emphasis> (the position of the click relative to the top-left corner of the label). We create a byte array to store the label's text and the hot spot, and we use a <db:link xlink:href="qdatastream.xml">QDataStream</db:link> object to stream the data into the byte array.</db:para>
<db:para>With all the information in place, we create a new <db:link xlink:href="qmimedata.xml">QMimeData</db:link> object. As mentioned above, <db:link xlink:href="qmimedata.xml">QMimeData</db:link> objects associate the data that they hold with the corresponding MIME types to ensure that information can be safely transferred between applications. The <db:link xlink:href="qmimedata.xml#setData">setData</db:link>() method sets the data associated with a given MIME type. In our case, we associate our item data with the custom application/x-fridgemagnet type.</db:para>
<db:programlisting language="cpp">    QMimeData *mimeData = new QMimeData;
    mimeData-&gt;setData(fridgetMagnetsMimeType(), itemData);
    mimeData-&gt;setText(child-&gt;labelText());
</db:programlisting>
<db:para>Note that we also associate the magnet's text with the text/plain MIME type using <db:link xlink:href="qmimedata.xml">QMimeData</db:link>'s <db:link xlink:href="qmimedata.xml#setText">setText</db:link>() method. Below, we will see how our widget detects both these MIME types with its event handlers.</db:para>
<db:para>Finally, we create a <db:link xlink:href="qdrag.xml">QDrag</db:link> object. It is the <db:link xlink:href="qdrag.xml">QDrag</db:link> class that handles most of the details of a drag and drop operation, providing support for MIME-based drag and drop data transfer. The data to be transferred by the drag and drop operation is contained in a <db:link xlink:href="qmimedata.xml">QMimeData</db:link> object. When we call <db:link xlink:href="qdrag.xml">QDrag</db:link>'s <db:link xlink:href="qdrag.xml#setMimeData">setMimeData</db:link>() method the ownership of our item data is transferred to the <db:link xlink:href="qdrag.xml">QDrag</db:link> object.</db:para>
<db:para>We call the <db:link xlink:href="qdrag.xml#setPixmap">setPixmap</db:link>() function to set the pixmap used to represent the data during the drag and drop operation. Typically, this pixmap shows an icon that represents the MIME type of the data being transferred, but any pixmap can be used. In this example, we simply use the pixmap used by the label itself to make it look like the fridge magnet itself is being moved.</db:para>
<db:programlisting language="cpp">    QDrag *drag = new QDrag(this);
    drag-&gt;setMimeData(mimeData);
    drag-&gt;setPixmap(*child-&gt;pixmap());
    drag-&gt;setHotSpot(hotSpot);

    child-&gt;hide();
</db:programlisting>
<db:para>We also specify the cursor's hot spot, its position relative to the top-level corner of the drag pixmap, to be the point we calculated above. This makes the process of dragging the label feel more natural because the cursor always points to the same place on the label during the drag operation.</db:para>
<db:para>We start the drag operation using <db:link xlink:href="qdrag.xml">QDrag</db:link>'s <db:link xlink:href="qdrag.xml#exec">exec</db:link>() function, requesting that the magnet is copied when the drag is completed.</db:para>
<db:programlisting language="cpp">    if (drag-&gt;exec(Qt::MoveAction | Qt::CopyAction, Qt::CopyAction) == Qt::MoveAction)
        child-&gt;close();
    else
        child-&gt;show();
}
</db:programlisting>
<db:para>The function returns the drop action actually performed by the user (this can be either a copy or a move action in this case); if this action is equal to <db:link xlink:href="qt.xml#DropAction-enum">Qt::MoveAction</db:link> we will close the activated fridge magnet widget because we will create a new one to replace it (see the <db:link xlink:href="qtwidgets-draganddrop-fridgemagnets-example.xml#drop">dropEvent()</db:link> implementation). Otherwise, if the drop is outside our main widget, we simply show the widget in its original position.</db:para>
</db:section>
<db:section xml:id="dropping">
<db:title>Dropping</db:title>
<db:para>When a a drag and drop action enters our widget, we will receive a drag enter <db:emphasis>event</db:emphasis>. <db:link xlink:href="qdragenterevent.xml">QDragEnterEvent</db:link> inherits most of its functionality from <db:link xlink:href="qdragmoveevent.xml">QDragMoveEvent</db:link>, which in turn inherits most of its functionality from <db:link xlink:href="qdropevent.xml">QDropEvent</db:link>. Note that we must accept this event in order to receive the drag move events that are sent while the drag and drop action is in progress. The drag enter event is always immediately followed by a drag move event.</db:para>
<db:para>In our dragEnterEvent() implementation, we first determine whether we support the event's MIME type or not:</db:para>
<db:programlisting language="cpp">void DragWidget::dragEnterEvent(QDragEnterEvent *event)
{
    if (event-&gt;mimeData()-&gt;hasFormat(fridgetMagnetsMimeType())) {
        if (children().contains(event-&gt;source())) {
            event-&gt;setDropAction(Qt::MoveAction);
            event-&gt;accept();
        } else {
            event-&gt;acceptProposedAction();
        }
</db:programlisting>
<db:para>If the type is application/x-fridgemagnet and the event origins from any of this application's fridge magnet widgets, we first set the event's drop action using the <db:link xlink:href="qdropevent.xml#setDropAction">QDropEvent::setDropAction</db:link>() method. An event's drop action is the action to be performed on the data by the target. <db:link xlink:href="qt.xml#DropAction-enum">Qt::MoveAction</db:link> indicates that the data is moved from the source to the target.</db:para>
<db:para>Then we call the event's <db:link xlink:href="qdragmoveevent.xml#accept-1">accept</db:link>() method to indicate that we have handled the event. In general, unaccepted events might be propagated to the parent widget. If the event origins from any other widget, we simply accept the proposed action.</db:para>
<db:programlisting language="cpp">    } else if (event-&gt;mimeData()-&gt;hasText()) {
        event-&gt;acceptProposedAction();
    } else {
        event-&gt;ignore();
    }
}
</db:programlisting>
<db:para>We also accept the proposed action if the event's MIME type is text/plain, i.e., if <db:link xlink:href="qmimedata.xml#hasText">QMimeData::hasText</db:link>() returns true. If the event has any other type, on the other hand, we call the event's <db:link xlink:href="qdragmoveevent.xml#ignore-1">ignore</db:link>() method allowing the event to be propagated further.</db:para>
<db:programlisting language="cpp">void DragWidget::dragMoveEvent(QDragMoveEvent *event)
{
    if (event-&gt;mimeData()-&gt;hasFormat(fridgetMagnetsMimeType())) {
        if (children().contains(event-&gt;source())) {
            event-&gt;setDropAction(Qt::MoveAction);
            event-&gt;accept();
        } else {
            event-&gt;acceptProposedAction();
        }
    } else if (event-&gt;mimeData()-&gt;hasText()) {
        event-&gt;acceptProposedAction();
    } else {
        event-&gt;ignore();
    }
}
</db:programlisting>
<db:para>Drag move events occur when the cursor enters a widget, when it moves within the widget, and when a modifier key is pressed on the keyboard while the widget has focus. Our widget will receive drag move events repeatedly while a drag is within its boundaries. We reimplement the <db:link xlink:href="qwidget.xml#dragMoveEvent">dragMoveEvent</db:link>() method, and examine the event in the exact same way as we did with drag enter events.</db:para>
<db:para>Note that the <db:link xlink:href="qwidget.xml#dropEvent">dropEvent</db:link>() event handler behaves slightly differently: We first get hold of the event's MIME data.</db:para>
<db:anchor xml:id="drop"/>
<db:programlisting language="cpp">void DragWidget::dropEvent(QDropEvent *event)
{
    if (event-&gt;mimeData()-&gt;hasFormat(fridgetMagnetsMimeType())) {
        const QMimeData *mime = event-&gt;mimeData();
</db:programlisting>
<db:para>The <db:link xlink:href="qmimedata.xml">QMimeData</db:link> class provides a container for data that records information about its MIME type. <db:link xlink:href="qmimedata.xml">QMimeData</db:link> objects associate the data that they hold with the corresponding MIME types to ensure that information can be safely transferred between applications, and copied around within the same application.</db:para>
<db:para>We retrieve the data associated with the application/x-fridgemagnet MIME type using a data stream in order to create a new DragLabel object.</db:para>
<db:programlisting language="cpp">        QByteArray itemData = mime-&gt;data(fridgetMagnetsMimeType());
        QDataStream dataStream(&amp;itemData, QIODevice::ReadOnly);

        QString text;
        QPoint offset;
        dataStream &gt;&gt; text &gt;&gt; offset;
</db:programlisting>
<db:para>The <db:link xlink:href="qdatastream.xml">QDataStream</db:link> class provides serialization of binary data to a <db:link xlink:href="qiodevice.xml">QIODevice</db:link> (a data stream is a binary stream of encoded information which is completely independent of the host computer's operating system, CPU or byte order).</db:para>
<db:para>Finally, we create a label and move it to the event's position:</db:para>
<db:programlisting language="cpp">        DragLabel *newLabel = new DragLabel(text, this);
        newLabel-&gt;move(event-&gt;pos() - offset);
        newLabel-&gt;show();
        newLabel-&gt;setAttribute(Qt::WA_DeleteOnClose);

        if (event-&gt;source() == this) {
            event-&gt;setDropAction(Qt::MoveAction);
            event-&gt;accept();
        } else {
            event-&gt;acceptProposedAction();
        }
</db:programlisting>
<db:para>If the source of the event is also the widget receiving the drop event, we set the event's drop action to <db:link xlink:href="qt.xml#DropAction-enum">Qt::MoveAction</db:link> and call the event's <db:link xlink:href="qdragmoveevent.xml#accept-1">accept</db:link>() method. Otherwise, we simply accept the proposed action. This means that labels are moved rather than copied in the same window. However, if we drag a label to a second instance of the Fridge Magnets example, the default action is to copy it, leaving the original in the first instance.</db:para>
<db:para>If the event's MIME type is text/plain (i.e., if <db:link xlink:href="qmimedata.xml#hasText">QMimeData::hasText</db:link>() returns true) we retrieve its text and split it into words. For each word we create a new DragLabel action, and show it at the event's position plus an offset depending on the number of words in the text. In the end we accept the proposed action. This lets the user drop selected text from a text editor or Web browser onto the widget to add more fridge magnets.</db:para>
<db:programlisting language="cpp">    } else if (event-&gt;mimeData()-&gt;hasText()) {
        QStringList pieces = event-&gt;mimeData()-&gt;text().split(QRegularExpression(QStringLiteral(&quot;\\s+&quot;)),
                             QString::SkipEmptyParts);
        QPoint position = event-&gt;pos();

        foreach (const QString &amp;piece, pieces) {
            DragLabel *newLabel = new DragLabel(piece, this);
            newLabel-&gt;move(position);
            newLabel-&gt;show();
            newLabel-&gt;setAttribute(Qt::WA_DeleteOnClose);

            position += QPoint(newLabel-&gt;width(), 0);
        }

        event-&gt;acceptProposedAction();
    } else {
        event-&gt;ignore();
    }
}
</db:programlisting>
<db:para>If the event has any other type, we call the event's <db:link xlink:href="qdragmoveevent.xml#ignore-1">ignore</db:link>() method allowing the event to be propagated further.</db:para>
</db:section>
</db:section>
<db:section xml:id="summary">
<db:title>Summary</db:title>
<db:para>We set our main widget's <db:link xlink:href="qwidget.xml#acceptDrops-prop">acceptDrops</db:link> property and reimplemented <db:link xlink:href="qwidget.xml">QWidget</db:link>'s <db:link xlink:href="qwidget.xml#dragEnterEvent">dragEnterEvent</db:link>(), <db:link xlink:href="qwidget.xml#dragMoveEvent">dragMoveEvent</db:link>() and <db:link xlink:href="qwidget.xml#dropEvent">dropEvent</db:link>() event handlers to support content dropped on our widget.</db:para>
<db:para>In addition, we reimplemented the <db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>() function to let the user pick up fridge magnets in the first place.</db:para>
<db:para>Because data is communicated using drag and drop operations and encoded using MIME types, you can run more than one instance of this example, and transfer magnets between them.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/fridgemagnets/draglabel.cpp">draganddrop/fridgemagnets/draglabel.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/fridgemagnets/draglabel.h">draganddrop/fridgemagnets/draglabel.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/fridgemagnets/dragwidget.cpp">draganddrop/fridgemagnets/dragwidget.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/fridgemagnets/dragwidget.h">draganddrop/fridgemagnets/dragwidget.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/fridgemagnets/fridgemagnets.pro">draganddrop/fridgemagnets/fridgemagnets.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/fridgemagnets/fridgemagnets.qrc">draganddrop/fridgemagnets/fridgemagnets.qrc</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/fridgemagnets/main.cpp">draganddrop/fridgemagnets/main.cpp</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
