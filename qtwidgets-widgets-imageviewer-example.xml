<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Image Viewer Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.11.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The example shows how to combine <db:link xlink:href="qlabel.xml">QLabel</db:link> and <db:link xlink:href="qscrollarea.xml">QScrollArea</db:link> to display an image.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para><db:link xlink:href="qlabel.xml">QLabel</db:link> is typically used for displaying text, but it can also display an image. <db:link xlink:href="qscrollarea.xml">QScrollArea</db:link> provides a scrolling view around another widget. If the child widget exceeds the size of the frame, <db:link xlink:href="qscrollarea.xml">QScrollArea</db:link> automatically provides scroll bars.</db:para>
<db:para>The example demonstrates how <db:link xlink:href="qlabel.xml">QLabel</db:link>'s ability to scale its contents (<db:link xlink:href="qlabel.xml#scaledContents-prop">QLabel::scaledContents</db:link>), and <db:link xlink:href="qscrollarea.xml">QScrollArea</db:link>'s ability to automatically resize its contents (<db:link xlink:href="qscrollarea.xml#widgetResizable-prop">QScrollArea::widgetResizable</db:link>), can be used to implement zooming and scaling features. In addition the example shows how to use <db:link xlink:href="qpainter.xml">QPainter</db:link> to print an image.</db:para>
<db:figure>
<db:title>Screenshot of the Image Viewer example</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/imageviewer-example.png"/>
</db:imageobject>
</db:mediaobject>
</db:figure>
<db:para>With the Image Viewer application, the users can view an image of their choice. The <db:guilabel>File</db:guilabel> menu gives the user the possibility to:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:guilabel>Open...</db:guilabel> - Open an image file</db:para>
</db:listitem>
<db:listitem>
<db:para><db:guilabel>Print...</db:guilabel> - Print an image</db:para>
</db:listitem>
<db:listitem>
<db:para><db:guilabel>Exit</db:guilabel> - Exit the application</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Once an image is loaded, the <db:guilabel>View</db:guilabel> menu allows the users to:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:guilabel>Zoom In</db:guilabel> - Scale the image up by 25%</db:para>
</db:listitem>
<db:listitem>
<db:para><db:guilabel>Zoom Out</db:guilabel> - Scale the image down by 25%</db:para>
</db:listitem>
<db:listitem>
<db:para><db:guilabel>Normal Size</db:guilabel> - Show the image at its original size</db:para>
</db:listitem>
<db:listitem>
<db:para><db:guilabel>Fit to Window</db:guilabel> - Stretch the image to occupy the entire window</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In addition the <db:guilabel>Help</db:guilabel> menu provides the users with information about the Image Viewer example in particular, and about Qt in general.</db:para>
<db:section xml:id="imageviewer-class-definition">
<db:title>ImageViewer Class Definition</db:title>
<db:programlisting language="cpp">class ImageViewer : public QMainWindow
{
    Q_OBJECT

public:
    ImageViewer();
    bool loadFile(const QString &amp;amp;);

private slots:
    void open();
    void saveAs();
    void print();
    void copy();
    void paste();
    void zoomIn();
    void zoomOut();
    void normalSize();
    void fitToWindow();
    void about();

private:
    void createActions();
    void createMenus();
    void updateActions();
    bool saveFile(const QString &amp;amp;fileName);
    void setImage(const QImage &amp;amp;newImage);
    void scaleImage(double factor);
    void adjustScrollBar(QScrollBar *scrollBar, double factor);

    QImage image;
    QLabel *imageLabel;
    QScrollArea *scrollArea;
    double scaleFactor;

#ifndef QT_NO_PRINTER
    QPrinter printer;
#endif

    QAction *saveAsAct;
    QAction *printAct;
    QAction *copyAct;
    QAction *zoomInAct;
    QAction *zoomOutAct;
    QAction *normalSizeAct;
    QAction *fitToWindowAct;
};
</db:programlisting>
<db:para>The ImageViewer class inherits from <db:link xlink:href="qmainwindow.xml">QMainWindow</db:link>. We reimplement the constructor, and create several private slots to facilitate the menu entries. In addition we create four private functions.</db:para>
<db:para>We use createActions() and createMenus() when constructing the ImageViewer widget. We use the updateActions() function to update the menu entries when a new image is loaded, or when the <db:guilabel>Fit to Window</db:guilabel> option is toggled. The zoom slots use scaleImage() to perform the zooming. In turn, scaleImage() uses adjustScrollBar() to preserve the focal point after scaling an image.</db:para>
</db:section>
<db:section xml:id="imageviewer-class-implementation">
<db:title>ImageViewer Class Implementation</db:title>
<db:programlisting language="cpp">ImageViewer::ImageViewer()
   : imageLabel(new QLabel)
   , scrollArea(new QScrollArea)
   , scaleFactor(1)
{
    imageLabel-&amp;gt;setBackgroundRole(QPalette::Base);
    imageLabel-&amp;gt;setSizePolicy(QSizePolicy::Ignored, QSizePolicy::Ignored);
    imageLabel-&amp;gt;setScaledContents(true);

    scrollArea-&amp;gt;setBackgroundRole(QPalette::Dark);
    scrollArea-&amp;gt;setWidget(imageLabel);
    scrollArea-&amp;gt;setVisible(false);
    setCentralWidget(scrollArea);

    createActions();

    resize(QGuiApplication::primaryScreen()-&amp;gt;availableSize() * 3 / 5);
}
</db:programlisting>
<db:para>In the constructor we first create the label and the scroll area.</db:para>
<db:para>We set imageLabel's size policy to <db:link xlink:href="qsizepolicy.xml#Policy-enum">ignored</db:link>, making the users able to scale the image to whatever size they want when the <db:guilabel>Fit to Window</db:guilabel> option is turned on. Otherwise, the default size polizy (<db:link xlink:href="qsizepolicy.xml#Policy-enum">preferred</db:link>) will make scroll bars appear when the scroll area becomes smaller than the label's minimum size hint.</db:para>
<db:para>We ensure that the label will scale its contents to fill all available space, to enable the image to scale properly when zooming. If we omitted to set the imageLabel's <db:link xlink:href="qlabel.xml#scaledContents-prop">scaledContents</db:link> property, zooming in would enlarge the <db:link xlink:href="qlabel.xml">QLabel</db:link>, but leave the pixmap at its original size, exposing the <db:link xlink:href="qlabel.xml">QLabel</db:link>'s background.</db:para>
<db:para>We make imageLabel the scroll area's child widget, and we make scrollArea the central widget of the <db:link xlink:href="qmainwindow.xml">QMainWindow</db:link>. At the end we create the associated actions and menus, and customize the ImageViewer's appearance.</db:para>
<db:programlisting language="cpp">static void initializeImageFileDialog(QFileDialog &amp;amp;dialog, QFileDialog::AcceptMode acceptMode)
{
    static bool firstDialog = true;

    if (firstDialog) {
        firstDialog = false;
        const QStringList picturesLocations = QStandardPaths::standardLocations(QStandardPaths::PicturesLocation);
        dialog.setDirectory(picturesLocations.isEmpty() ? QDir::currentPath() : picturesLocations.last());
    }

    QStringList mimeTypeFilters;
    const QByteArrayList supportedMimeTypes = acceptMode == QFileDialog::AcceptOpen
        ? QImageReader::supportedMimeTypes() : QImageWriter::supportedMimeTypes();
    foreach (const QByteArray &amp;amp;mimeTypeName, supportedMimeTypes)
        mimeTypeFilters.append(mimeTypeName);
    mimeTypeFilters.sort();
    dialog.setMimeTypeFilters(mimeTypeFilters);
    dialog.selectMimeTypeFilter(&quot;image/jpeg&quot;);
    if (acceptMode == QFileDialog::AcceptSave)
        dialog.setDefaultSuffix(&quot;jpg&quot;);
}

void ImageViewer::open()
{
    QFileDialog dialog(this, tr(&quot;Open File&quot;));
    initializeImageFileDialog(dialog, QFileDialog::AcceptOpen);

    while (dialog.exec() == QDialog::Accepted &amp;amp;&amp;amp; !loadFile(dialog.selectedFiles().first())) {}
}
</db:programlisting>
<db:para>In the open() slot, we show a file dialog to the user. We compile a list of mime types for use as a filter by querying <db:link xlink:href="qimagereader.xml">QImageReader</db:link> for the available mime type names.</db:para>
<db:para>We show the file dialog until a valid file name is entered or the user cancels.</db:para>
<db:para>The function loadFile() is used to load the image.</db:para>
<db:programlisting language="cpp">bool ImageViewer::loadFile(const QString &amp;amp;fileName)
{
    QImageReader reader(fileName);
    reader.setAutoTransform(true);
    const QImage newImage = reader.read();
    if (newImage.isNull()) {
        QMessageBox::information(this, QGuiApplication::applicationDisplayName(),
                                 tr(&quot;Cannot load %1: %2&quot;)
                                 .arg(QDir::toNativeSeparators(fileName), reader.errorString()));
        return false;
    }
</db:programlisting>
<db:para>In the loadFile() function, we instantiate a <db:link xlink:href="qimagereader.xml">QImageReader</db:link> and enable automatic transformations by calling <db:link xlink:href="qimagereader.xml#setAutoTransform">QImageReader::setAutoTransform</db:link>(). For files in JPEG format, this ensures that portrait mode images of digital cameras are shown correctly by applying the appropriate orientation read from the EXIF meta data stored in the image file.</db:para>
<db:para>We then load the image using <db:link xlink:href="qimagereader.xml#read">QImageReader::read</db:link>(). If this returns a null image, indicating that the file is not an image file, we use a <db:link xlink:href="qmessagebox.xml">QMessageBox</db:link> to alert the user.</db:para>
<db:para>The <db:link xlink:href="qmessagebox.xml">QMessageBox</db:link> class provides a modal dialog with a short message, an icon, and some buttons. As with <db:link xlink:href="qfiledialog.xml">QFileDialog</db:link> the easiest way to create a <db:link xlink:href="qmessagebox.xml">QMessageBox</db:link> is to use its static convenience functions. <db:link xlink:href="qmessagebox.xml">QMessageBox</db:link> provides a range of different messages arranged along two axes: severity (question, information, warning and critical) and complexity (the number of necessary response buttons). In this particular example an information message with an <db:guilabel>OK</db:guilabel> button (the default) is sufficient, since the message is part of a normal operation.</db:para>
<db:programlisting language="cpp">    scaleFactor = 1.0;

    scrollArea-&amp;gt;setVisible(true);
    printAct-&amp;gt;setEnabled(true);
    fitToWindowAct-&amp;gt;setEnabled(true);
    updateActions();

    if (!fitToWindowAct-&amp;gt;isChecked())
        imageLabel-&amp;gt;adjustSize();
}
</db:programlisting>
<db:para>If the format is supported, we display the image in imageLabel by setting the label's <db:link xlink:href="qlabel.xml#pixmap-prop">pixmap</db:link>. Then we enable the <db:guilabel>Print</db:guilabel> and <db:guilabel>Fit to Window</db:guilabel> menu entries and update the rest of the view menu entries. The <db:guilabel>Open</db:guilabel> and <db:guilabel>Exit</db:guilabel> entries are enabled by default.</db:para>
<db:para>If the <db:guilabel>Fit to Window</db:guilabel> option is turned off, the <db:link xlink:href="qscrollarea.xml#widgetResizable-prop">QScrollArea::widgetResizable</db:link> property is false and it is our responsibility (not <db:link xlink:href="qscrollarea.xml">QScrollArea</db:link>'s) to give the <db:link xlink:href="qlabel.xml">QLabel</db:link> a reasonable size based on its contents. We call {<db:link xlink:href="qwidget.xml#adjustSize">QWidget::adjustSize</db:link>()}{adjustSize()} to achieve this, which is essentially the same as</db:para>
<db:programlisting language="cpp">imageLabel-&amp;gt;resize(imageLabel-&amp;gt;pixmap()-&amp;gt;size());
</db:programlisting>
<db:para>In the print() slot, we first make sure that an image has been loaded into the application:</db:para>
<db:programlisting language="cpp">void ImageViewer::print()
{
    Q_ASSERT(imageLabel-&amp;gt;pixmap());
#if QT_CONFIG(printdialog)
</db:programlisting>
<db:para>If the application is built in debug mode, the Q_ASSERT() macro will expand to</db:para>
<db:programlisting language="cpp">if (!imageLabel-&amp;gt;pixmap())
    qFatal(&quot;ASSERT: &quot;imageLabel-&amp;gt;pixmap()&quot; in file ...&quot;);
</db:programlisting>
<db:para>In release mode, the macro simply disappear. The mode can be set in the application's .pro file. One way to do so is to add an option to <db:guilabel>qmake</db:guilabel> when building the application:</db:para>
<db:programlisting language="cpp">qmake &quot;CONFIG += debug&quot; foo.pro
</db:programlisting>
<db:para>or</db:para>
<db:programlisting language="cpp">qmake &quot;CONFIG += release&quot; foo.pro
</db:programlisting>
<db:para>Another approach is to add this line directly to the .pro file.</db:para>
<db:programlisting language="cpp">    QPrintDialog dialog(&amp;amp;printer, this);
    if (dialog.exec()) {
        QPainter painter(&amp;amp;printer);
        QRect rect = painter.viewport();
        QSize size = imageLabel-&amp;gt;pixmap()-&amp;gt;size();
        size.scale(rect.size(), Qt::KeepAspectRatio);
        painter.setViewport(rect.x(), rect.y(), size.width(), size.height());
        painter.setWindow(imageLabel-&amp;gt;pixmap()-&amp;gt;rect());
        painter.drawPixmap(0, 0, *imageLabel-&amp;gt;pixmap());
    }
#endif
}
</db:programlisting>
<db:para>Then we present a print dialog allowing the user to choose a printer and to set a few options. We construct a painter with a <db:link xlink:href="qprinter.xml">QPrinter</db:link> as the paint device. We set the painter's window and viewport in such a way that the image is as large as possible on the paper, but without altering its <db:link xlink:href="qt.xml#AspectRatioMode-enum">aspect ratio</db:link>.</db:para>
<db:para>In the end we draw the pixmap at position (0, 0).</db:para>
<db:programlisting language="cpp">void ImageViewer::zoomIn()
{
    scaleImage(1.25);
}

void ImageViewer::zoomOut()
{
    scaleImage(0.8);
}
</db:programlisting>
<db:para>We implement the zooming slots using the private scaleImage() function. We set the scaling factors to 1.25 and 0.8, respectively. These factor values ensure that a <db:guilabel>Zoom In</db:guilabel> action and a <db:guilabel>Zoom Out</db:guilabel> action will cancel each other (since 1.25 * 0.8 == 1), and in that way the normal image size can be restored using the zooming features.</db:para>
<db:para>The screenshots below show an image in its normal size, and the same image after zooming in:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/imageviewer-original_size.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/imageviewer-zoom_in_1.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/imageviewer-zoom_in_2.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:programlisting language="cpp">void ImageViewer::normalSize()
{
    imageLabel-&amp;gt;adjustSize();
    scaleFactor = 1.0;
}
</db:programlisting>
<db:para>When zooming, we use the <db:link xlink:href="qlabel.xml">QLabel</db:link>'s ability to scale its contents. Such scaling doesn't change the actual size hint of the contents. And since the <db:link xlink:href="qwidget.xml#adjustSize">adjustSize</db:link>() function use those size hint, the only thing we need to do to restore the normal size of the currently displayed image is to call adjustSize() and reset the scale factor to 1.0.</db:para>
<db:programlisting language="cpp">void ImageViewer::fitToWindow()
{
    bool fitToWindow = fitToWindowAct-&amp;gt;isChecked();
    scrollArea-&amp;gt;setWidgetResizable(fitToWindow);
    if (!fitToWindow)
        normalSize();
    updateActions();
}
</db:programlisting>
<db:para>The fitToWindow() slot is called each time the user toggled the <db:guilabel>Fit to Window</db:guilabel> option. If the slot is called to turn on the option, we tell the scroll area to resize its child widget with the <db:link xlink:href="qscrollarea.xml#widgetResizable-prop">QScrollArea::setWidgetResizable</db:link>() function. Then we disable the <db:guilabel>Zoom In</db:guilabel>, <db:guilabel>Zoom Out</db:guilabel> and <db:guilabel>Normal Size</db:guilabel> menu entries using the private updateActions() function.</db:para>
<db:para>If the <db:link xlink:href="qscrollarea.xml#widgetResizable-prop">QScrollArea::widgetResizable</db:link> property is set to false (the default), the scroll area honors the size of its child widget. If this property is set to true, the scroll area will automatically resize the widget in order to avoid scroll bars where they can be avoided, or to take advantage of extra space. But the scroll area will honor the minimum size hint of its child widget independent of the widget resizable property. So in this example we set imageLabel's size policy to <db:link xlink:href="qsizepolicy.xml#Policy-enum">ignored</db:link> in the constructor, to avoid that scroll bars appear when the scroll area becomes smaller than the label's minimum size hint.</db:para>
<db:para>The screenshots below shows an image in its normal size, and the same image with the <db:guilabel>Fit to window</db:guilabel> option turned on. Enlarging the window will stretch the image further, as shown in the third screenshot.</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/imageviewer-original_size.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/imageviewer-fit_to_window_1.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/imageviewer-fit_to_window_2.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>If the slot is called to turn off the option, the {<db:link xlink:href="qscrollarea.xml#widgetResizable-prop">QScrollArea::setWidgetResizable</db:link>} property is set to false. We also restore the image pixmap to its normal size by adjusting the label's size to its content. And in the end we update the view menu entries.</db:para>
<db:programlisting language="cpp">void ImageViewer::about()
{
    QMessageBox::about(this, tr(&quot;About Image Viewer&quot;),
            tr(&quot;&amp;lt;p&amp;gt;The &amp;lt;b&amp;gt;Image Viewer&amp;lt;/b&amp;gt; example shows how to combine QLabel &quot;
               &quot;and QScrollArea to display an image. QLabel is typically used &quot;
               &quot;for displaying a text, but it can also display an image. &quot;
               &quot;QScrollArea provides a scrolling view around another widget. &quot;
               &quot;If the child widget exceeds the size of the frame, QScrollArea &quot;
               &quot;automatically provides scroll bars. &amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;The example &quot;
               &quot;demonstrates how QLabel's ability to scale its contents &quot;
               &quot;(QLabel::scaledContents), and QScrollArea's ability to &quot;
               &quot;automatically resize its contents &quot;
               &quot;(QScrollArea::widgetResizable), can be used to implement &quot;
               &quot;zooming and scaling features. &amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;In addition the example &quot;
               &quot;shows how to use QPainter to print an image.&amp;lt;/p&amp;gt;&quot;));
}
</db:programlisting>
<db:para>We implement the about() slot to create a message box describing what the example is designed to show.</db:para>
<db:programlisting language="cpp">void ImageViewer::createActions()
{
    QMenu *fileMenu = menuBar()-&amp;gt;addMenu(tr(&quot;&amp;amp;File&quot;));

    QAction *openAct = fileMenu-&amp;gt;addAction(tr(&quot;&amp;amp;Open...&quot;), this, &amp;amp;ImageViewer::open);
    openAct-&amp;gt;setShortcut(QKeySequence::Open);

    saveAsAct = fileMenu-&amp;gt;addAction(tr(&quot;&amp;amp;Save As...&quot;), this, &amp;amp;ImageViewer::saveAs);
    saveAsAct-&amp;gt;setEnabled(false);

    printAct = fileMenu-&amp;gt;addAction(tr(&quot;&amp;amp;Print...&quot;), this, &amp;amp;ImageViewer::print);
    printAct-&amp;gt;setShortcut(QKeySequence::Print);
    printAct-&amp;gt;setEnabled(false);

    fileMenu-&amp;gt;addSeparator();

    QAction *exitAct = fileMenu-&amp;gt;addAction(tr(&quot;E&amp;amp;xit&quot;), this, &amp;amp;QWidget::close);
    exitAct-&amp;gt;setShortcut(tr(&quot;Ctrl+Q&quot;));

    QMenu *editMenu = menuBar()-&amp;gt;addMenu(tr(&quot;&amp;amp;Edit&quot;));

    copyAct = editMenu-&amp;gt;addAction(tr(&quot;&amp;amp;Copy&quot;), this, &amp;amp;ImageViewer::copy);
    copyAct-&amp;gt;setShortcut(QKeySequence::Copy);
    copyAct-&amp;gt;setEnabled(false);

    QAction *pasteAct = editMenu-&amp;gt;addAction(tr(&quot;&amp;amp;Paste&quot;), this, &amp;amp;ImageViewer::paste);
    pasteAct-&amp;gt;setShortcut(QKeySequence::Paste);

    QMenu *viewMenu = menuBar()-&amp;gt;addMenu(tr(&quot;&amp;amp;View&quot;));

    zoomInAct = viewMenu-&amp;gt;addAction(tr(&quot;Zoom &amp;amp;In (25%)&quot;), this, &amp;amp;ImageViewer::zoomIn);
    zoomInAct-&amp;gt;setShortcut(QKeySequence::ZoomIn);
    zoomInAct-&amp;gt;setEnabled(false);

    zoomOutAct = viewMenu-&amp;gt;addAction(tr(&quot;Zoom &amp;amp;Out (25%)&quot;), this, &amp;amp;ImageViewer::zoomOut);
    zoomOutAct-&amp;gt;setShortcut(QKeySequence::ZoomOut);
    zoomOutAct-&amp;gt;setEnabled(false);

    normalSizeAct = viewMenu-&amp;gt;addAction(tr(&quot;&amp;amp;Normal Size&quot;), this, &amp;amp;ImageViewer::normalSize);
    normalSizeAct-&amp;gt;setShortcut(tr(&quot;Ctrl+S&quot;));
    normalSizeAct-&amp;gt;setEnabled(false);

    viewMenu-&amp;gt;addSeparator();

    fitToWindowAct = viewMenu-&amp;gt;addAction(tr(&quot;&amp;amp;Fit to Window&quot;), this, &amp;amp;ImageViewer::fitToWindow);
    fitToWindowAct-&amp;gt;setEnabled(false);
    fitToWindowAct-&amp;gt;setCheckable(true);
    fitToWindowAct-&amp;gt;setShortcut(tr(&quot;Ctrl+F&quot;));

    QMenu *helpMenu = menuBar()-&amp;gt;addMenu(tr(&quot;&amp;amp;Help&quot;));

    helpMenu-&amp;gt;addAction(tr(&quot;&amp;amp;About&quot;), this, &amp;amp;ImageViewer::about);
    helpMenu-&amp;gt;addAction(tr(&quot;About &amp;amp;Qt&quot;), &amp;amp;QApplication::aboutQt);
}
</db:programlisting>
<db:para>In the private createAction() function, we create the actions providing the application features and populate a menu with them.</db:para>
<db:para>We assign a short-cut key to each action and connect them to the appropriate slots. We only enable the openAct and exitAct at the time of creation, the others are updated once an image has been loaded into the application. In addition we make the fitToWindowAct <db:link xlink:href="qaction.xml#checkable-prop">checkable</db:link>.</db:para>
<db:para>The <db:link xlink:href="qmenu.xml">QMenu</db:link> class provides a menu widget for use in menu bars, context menus, and other popup menus. The <db:link xlink:href="qmenubar.xml">QMenuBar</db:link> class provides a horizontal menu bar that consists of a list of pull-down menu items. So we put the menus in the ImageViewer's menu bar which we retrieve with the <db:link xlink:href="qmainwindow.xml#menuBar">QMainWindow::menuBar</db:link>() function.</db:para>
<db:programlisting language="cpp">void ImageViewer::updateActions()
{
    saveAsAct-&amp;gt;setEnabled(!image.isNull());
    copyAct-&amp;gt;setEnabled(!image.isNull());
    zoomInAct-&amp;gt;setEnabled(!fitToWindowAct-&amp;gt;isChecked());
    zoomOutAct-&amp;gt;setEnabled(!fitToWindowAct-&amp;gt;isChecked());
    normalSizeAct-&amp;gt;setEnabled(!fitToWindowAct-&amp;gt;isChecked());
}
</db:programlisting>
<db:para>The private updateActions() function enables or disables the <db:guilabel>Zoom In</db:guilabel>, <db:guilabel>Zoom Out</db:guilabel> and <db:guilabel>Normal Size</db:guilabel> menu entries depending on whether the <db:guilabel>Fit to Window</db:guilabel> option is turned on or off.</db:para>
<db:programlisting language="cpp">void ImageViewer::scaleImage(double factor)
{
    Q_ASSERT(imageLabel-&amp;gt;pixmap());
    scaleFactor *= factor;
    imageLabel-&amp;gt;resize(scaleFactor * imageLabel-&amp;gt;pixmap()-&amp;gt;size());

    adjustScrollBar(scrollArea-&amp;gt;horizontalScrollBar(), factor);
    adjustScrollBar(scrollArea-&amp;gt;verticalScrollBar(), factor);

    zoomInAct-&amp;gt;setEnabled(scaleFactor &amp;lt; 3.0);
    zoomOutAct-&amp;gt;setEnabled(scaleFactor &amp;gt; 0.333);
}
</db:programlisting>
<db:para>In scaleImage(), we use the factor parameter to calculate the new scaling factor for the displayed image, and resize imageLabel. Since we set the <db:link xlink:href="qlabel.xml#scaledContents-prop">scaledContents</db:link> property to true in the constructor, the call to <db:link xlink:href="qwidget.xml#size-prop">QWidget::resize</db:link>() will scale the image displayed in the label. We also adjust the scroll bars to preserve the focal point of the image.</db:para>
<db:para>At the end, if the scale factor is less than 33.3% or greater than 300%, we disable the respective menu entry to prevent the image pixmap from becoming too large, consuming too much resources in the window system.</db:para>
<db:programlisting language="cpp">void ImageViewer::adjustScrollBar(QScrollBar *scrollBar, double factor)
{
    scrollBar-&amp;gt;setValue(int(factor * scrollBar-&amp;gt;value()
                            + ((factor - 1) * scrollBar-&amp;gt;pageStep()/2)));
}
</db:programlisting>
<db:para>Whenever we zoom in or out, we need to adjust the scroll bars in consequence. It would have been tempting to simply call</db:para>
<db:programlisting language="cpp">scrollBar-&amp;gt;setValue(int(factor * scrollBar-&amp;gt;value()));
</db:programlisting>
<db:para>but this would make the top-left corner the focal point, not the center. Therefore we need to take into account the scroll bar handle's size (the <db:link xlink:href="qabstractslider.xml#pageStep-prop">page step</db:link>).</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="widgets/imageviewer/imageviewer.cpp">widgets/imageviewer/imageviewer.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/imageviewer/imageviewer.h">widgets/imageviewer/imageviewer.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/imageviewer/imageviewer.pro">widgets/imageviewer/imageviewer.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/imageviewer/main.cpp">widgets/imageviewer/main.cpp</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
