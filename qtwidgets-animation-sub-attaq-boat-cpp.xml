<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Sub-Attaq</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.2.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>This example shows Qt's ability to combine <db:link xlink:href="animation-overview.xml">the animation framework</db:link> and <db:link xlink:href="statemachine-api.xml">the state machine framework</db:link> to create a game.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the QtCore module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Digia.  For licensing terms and
** conditions see http://qt.digia.com/licensing.  For further information
** use the contact form at http://qt.digia.com/contact-us.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Digia gives you certain additional
** rights.  These rights are described in the Digia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3.0 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU General Public License version 3.0 requirements will be
** met: http://www.gnu.org/copyleft/gpl.html.
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

//Own
#include &quot;boat.h&quot;
#include &quot;boat_p.h&quot;
#include &quot;bomb.h&quot;
#include &quot;pixmapitem.h&quot;
#include &quot;graphicsscene.h&quot;
#include &quot;animationmanager.h&quot;
#include &quot;qanimationstate.h&quot;

//Qt
#include &lt;QtCore/QPropertyAnimation&gt;
#include &lt;QtCore/QStateMachine&gt;
#include &lt;QtCore/QHistoryState&gt;
#include &lt;QtCore/QFinalState&gt;
#include &lt;QtCore/QState&gt;
#include &lt;QtCore/QSequentialAnimationGroup&gt;

static QAbstractAnimation *setupDestroyAnimation(Boat *boat)
{
    QSequentialAnimationGroup *group = new QSequentialAnimationGroup(boat);
    for (int i = 1; i &lt;= 4; i++) {
        PixmapItem *step = new PixmapItem(QString(&quot;explosion/boat/step%1&quot;).arg(i),GraphicsScene::Big, boat);
        step-&gt;setZValue(6);
        step-&gt;setOpacity(0);

        //fade-in
        QPropertyAnimation *anim = new QPropertyAnimation(step, &quot;opacity&quot;);
        anim-&gt;setEndValue(1);
        anim-&gt;setDuration(100);
        group-&gt;insertAnimation(i-1, anim);

        //and then fade-out
        QPropertyAnimation *anim2 = new QPropertyAnimation(step, &quot;opacity&quot;);
        anim2-&gt;setEndValue(0);
        anim2-&gt;setDuration(100);
        group-&gt;addAnimation(anim2);
    }

    AnimationManager::self()-&gt;registerAnimation(group);
    return group;
}

Boat::Boat() : PixmapItem(QString(&quot;boat&quot;), GraphicsScene::Big),
    speed(0), bombsAlreadyLaunched(0), direction(Boat::None), movementAnimation(0)
{
    setZValue(4);
    setFlags(QGraphicsItem::ItemIsFocusable);

    //The movement animation used to animate the boat
    movementAnimation = new QPropertyAnimation(this, &quot;pos&quot;);

    //The destroy animation used to explode the boat
    destroyAnimation = setupDestroyAnimation(this);

    //We setup the state machine of the boat
    machine = new QStateMachine(this);
    QState *moving = new QState(machine);
    StopState *stopState = new StopState(this, moving);
    machine-&gt;setInitialState(moving);
    moving-&gt;setInitialState(stopState);
    MoveStateRight *moveStateRight = new MoveStateRight(this, moving);
    MoveStateLeft *moveStateLeft = new MoveStateLeft(this, moving);
    LaunchStateRight *launchStateRight = new LaunchStateRight(this, machine);
    LaunchStateLeft *launchStateLeft = new LaunchStateLeft(this, machine);

    //then setup the transitions for the rightMove state
    KeyStopTransition *leftStopRight = new KeyStopTransition(this, QEvent::KeyPress, Qt::Key_Left);
    leftStopRight-&gt;setTargetState(stopState);
    KeyMoveTransition *leftMoveRight = new KeyMoveTransition(this, QEvent::KeyPress, Qt::Key_Left);
    leftMoveRight-&gt;setTargetState(moveStateRight);
    KeyMoveTransition *rightMoveRight = new KeyMoveTransition(this, QEvent::KeyPress, Qt::Key_Right);
    rightMoveRight-&gt;setTargetState(moveStateRight);
    KeyMoveTransition *rightMoveStop = new KeyMoveTransition(this, QEvent::KeyPress, Qt::Key_Right);
    rightMoveStop-&gt;setTargetState(moveStateRight);

    //then setup the transitions for the leftMove state
    KeyStopTransition *rightStopLeft = new KeyStopTransition(this, QEvent::KeyPress, Qt::Key_Right);
    rightStopLeft-&gt;setTargetState(stopState);
    KeyMoveTransition *rightMoveLeft = new KeyMoveTransition(this, QEvent::KeyPress, Qt::Key_Right);
    rightMoveLeft-&gt;setTargetState(moveStateLeft);
    KeyMoveTransition *leftMoveLeft = new KeyMoveTransition(this, QEvent::KeyPress,Qt::Key_Left);
    leftMoveLeft-&gt;setTargetState(moveStateLeft);
    KeyMoveTransition *leftMoveStop = new KeyMoveTransition(this, QEvent::KeyPress,Qt::Key_Left);
    leftMoveStop-&gt;setTargetState(moveStateLeft);

    //We set up the right move state
    moveStateRight-&gt;addTransition(leftStopRight);
    moveStateRight-&gt;addTransition(leftMoveRight);
    moveStateRight-&gt;addTransition(rightMoveRight);
    stopState-&gt;addTransition(rightMoveStop);

    //We set up the left move state
    moveStateLeft-&gt;addTransition(rightStopLeft);
    moveStateLeft-&gt;addTransition(leftMoveLeft);
    moveStateLeft-&gt;addTransition(rightMoveLeft);
    stopState-&gt;addTransition(leftMoveStop);

    //The animation is finished, it means we reached the border of the screen, the boat is stopped so we move to the stop state
    moveStateLeft-&gt;addTransition(movementAnimation, SIGNAL(finished()), stopState);
    moveStateRight-&gt;addTransition(movementAnimation, SIGNAL(finished()), stopState);

    //We set up the keys for dropping bombs
    KeyLaunchTransition *upFireLeft = new KeyLaunchTransition(this, QEvent::KeyPress, Qt::Key_Up);
    upFireLeft-&gt;setTargetState(launchStateRight);
    KeyLaunchTransition *upFireRight = new KeyLaunchTransition(this, QEvent::KeyPress, Qt::Key_Up);
    upFireRight-&gt;setTargetState(launchStateRight);
    KeyLaunchTransition *upFireStop = new KeyLaunchTransition(this, QEvent::KeyPress, Qt::Key_Up);
    upFireStop-&gt;setTargetState(launchStateRight);
    KeyLaunchTransition *downFireLeft = new KeyLaunchTransition(this, QEvent::KeyPress, Qt::Key_Down);
    downFireLeft-&gt;setTargetState(launchStateLeft);
    KeyLaunchTransition *downFireRight = new KeyLaunchTransition(this, QEvent::KeyPress, Qt::Key_Down);
    downFireRight-&gt;setTargetState(launchStateLeft);
    KeyLaunchTransition *downFireMove = new KeyLaunchTransition(this, QEvent::KeyPress, Qt::Key_Down);
    downFireMove-&gt;setTargetState(launchStateLeft);

    //We set up transitions for fire up
    moveStateRight-&gt;addTransition(upFireRight);
    moveStateLeft-&gt;addTransition(upFireLeft);
    stopState-&gt;addTransition(upFireStop);

    //We set up transitions for fire down
    moveStateRight-&gt;addTransition(downFireRight);
    moveStateLeft-&gt;addTransition(downFireLeft);
    stopState-&gt;addTransition(downFireMove);

    //Finally the launch state should come back to its original state
    QHistoryState *historyState = new QHistoryState(moving);
    launchStateLeft-&gt;addTransition(historyState);
    launchStateRight-&gt;addTransition(historyState);

    QFinalState *final = new QFinalState(machine);

    //This state play the destroyed animation
    QAnimationState *destroyedState = new QAnimationState(machine);
    destroyedState-&gt;setAnimation(destroyAnimation);

    //Play a nice animation when the boat is destroyed
    moving-&gt;addTransition(this, SIGNAL(boatDestroyed()), destroyedState);

    //Transition to final state when the destroyed animation is finished
    destroyedState-&gt;addTransition(destroyedState, SIGNAL(animationFinished()), final);

    //The machine has finished to be executed, then the boat is dead
    connect(machine,SIGNAL(finished()), this, SIGNAL(boatExecutionFinished()));

}

void Boat::run()
{
    //We register animations
    AnimationManager::self()-&gt;registerAnimation(movementAnimation);
    AnimationManager::self()-&gt;registerAnimation(destroyAnimation);
    machine-&gt;start();
}

void Boat::stop()
{
    movementAnimation-&gt;stop();
    machine-&gt;stop();
}

void Boat::updateBoatMovement()
{
    if (speed == 0 || direction == Boat::None) {
        movementAnimation-&gt;stop();
        return;
    }

    movementAnimation-&gt;stop();

    if (direction == Boat::Left) {
        movementAnimation-&gt;setEndValue(QPointF(0,y()));
        movementAnimation-&gt;setDuration(x()/speed*15);
    }
    else /*if (direction == Boat::Right)*/ {
        movementAnimation-&gt;setEndValue(QPointF(scene()-&gt;width()-size().width(),y()));
        movementAnimation-&gt;setDuration((scene()-&gt;width()-size().width()-x())/speed*15);
    }
    movementAnimation-&gt;start();
}

void Boat::destroy()
{
    movementAnimation-&gt;stop();
    emit boatDestroyed();
}

int Boat::bombsLaunched() const
{
    return bombsAlreadyLaunched;
}

void Boat::setBombsLaunched(int number)
{
    if (number &gt; MAX_BOMB) {
        qWarning(&quot;Boat::setBombsLaunched : It impossible to launch that number of bombs&quot;);
        return;
    }
    bombsAlreadyLaunched = number;
}

int Boat::currentSpeed() const
{
    return speed;
}

void Boat::setCurrentSpeed(int speed)
{
    if (speed &gt; 3 || speed &lt; 0) {
        qWarning(&quot;Boat::setCurrentSpeed: The boat can't run on that speed&quot;);
        return;
    }
    this-&gt;speed = speed;
}

enum Boat::Movement Boat::currentDirection() const
{
    return direction;
}

void Boat::setCurrentDirection(Movement direction)
{
    this-&gt;direction = direction;
}

int Boat::type() const
{
    return Type;
}

</db:programlisting>
</db:article>
