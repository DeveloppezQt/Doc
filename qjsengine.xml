<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QJSEngine Class</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt QML Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> class provides an environment for evaluating JavaScript code.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QJSEngine</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Qml)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Qml)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += qml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qqmlengine.xml" xlink:role="class">QQmlEngine</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QJSEngine is part of <db:simplelist><db:member>qtjavascript</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:section xml:id="evaluating-scripts">
<db:title>Evaluating Scripts</db:title>
<db:para>Use <db:link xlink:href="qjsengine.xml#evaluate">evaluate</db:link>() to evaluate script code.</db:para>
<db:programlisting language="cpp">QJSEngine myEngine;
QJSValue three = myEngine.evaluate(&quot;1 + 2&quot;);
</db:programlisting>
<db:para><db:link xlink:href="qjsengine.xml#evaluate">evaluate</db:link>() returns a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> that holds the result of the evaluation. The <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> class provides functions for converting the result to various C++ types (e.g. QJSValue::toString() and QJSValue::toNumber()).</db:para>
<db:para>The following code snippet shows how a script function can be defined and then invoked from C++ using QJSValue::call():</db:para>
<db:programlisting language="cpp">QJSValue fun = myEngine.evaluate(&quot;(function(a, b) { return a + b; })&quot;);
QJSValueList args;
args &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; 2;
QJSValue threeAgain = fun.call(args);
</db:programlisting>
<db:para>As can be seen from the above snippets, a script is provided to the engine in the form of a string. One common way of loading scripts is by reading the contents of a file and passing it to <db:link xlink:href="qjsengine.xml#evaluate">evaluate</db:link>():</db:para>
<db:programlisting language="cpp">QString fileName = &quot;helloworld.qs&quot;;
QFile scriptFile(fileName);
if (!scriptFile.open(QIODevice::ReadOnly))
    // handle error
QTextStream stream(&amp;amp;scriptFile);
QString contents = stream.readAll();
scriptFile.close();
myEngine.evaluate(contents, fileName);
</db:programlisting>
<db:para>Here we pass the name of the file as the second argument to <db:link xlink:href="qjsengine.xml#evaluate">evaluate</db:link>(). This does not affect evaluation in any way; the second argument is a general-purpose string that is stored in the <db:code>Error</db:code> object for debugging purposes.</db:para>
<db:para>For larger pieces of functionality, you may want to encapsulate your code and data into modules. A module is a file that contains script code, variables, etc., and uses export statements to describe its interface towards the rest of the application. With the help of import statements, a module can refer to functionality from other modules. This allows building a scripted application from smaller connected building blocks in a safe way. In contrast, the approach of using <db:link xlink:href="qjsengine.xml#evaluate">evaluate</db:link>() carries the risk that internal variables or functions from one <db:link xlink:href="qjsengine.xml#evaluate">evaluate</db:link>() call accidentally pollute the global object and affect subsequent evaluations.</db:para>
<db:para>The following example provides a module that can add numbers:</db:para>
<db:programlisting language="cpp">export function sum(left, right)
{
    return left + right
}
</db:programlisting>
<db:para>This module can be loaded with QJSEngine::import() if it is saved under the name <db:code>math.mjs</db:code>:</db:para>
<db:programlisting language="cpp">QJSvalue module = myEngine.importModule(&quot;./math.mjs&quot;);
QJSValue sumFunction = module.property(&quot;sum&quot;);
QJSValue result = sumFunction.call(args);
</db:programlisting>
<db:para>Modules can also use functionality from other modules using import statements:</db:para>
<db:programlisting language="cpp">import { sum } from &quot;./math.mjs&quot;;
export function addTwice(left, right)
{
    return sum(left, right) * 2;
}
</db:programlisting>
<db:para>Modules don't have to be files. They can be values registered with <db:link xlink:href="qjsengine.xml#registerModule">QJSEngine::registerModule</db:link>():</db:para>
<db:programlisting language="cpp">import version from &quot;version&quot;;

export function getVersion()
{
    return version;
}
</db:programlisting>
<db:programlisting language="cpp">QJSValue version(610);
myEngine.registerModule(&quot;version&quot;, version);
QJSValue module = myEngine.importModule(&quot;./myprint.mjs&quot;);
QJSValue getVersion = module.property(&quot;getVersion&quot;);
QJSValue result = getVersion.call();
</db:programlisting>
<db:para>Named exports are supported, but because they are treated as members of an object, the default export must be an ECMAScript object. Most of the newXYZ functions in <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> will return an object.</db:para>
<db:programlisting language="cpp">QJSValue name(&quot;Qt6&quot;);
QJSValue obj = myEngine.newObject();
obj.setProperty(&quot;name&quot;, name);
myEngine.registerModule(&quot;info&quot;, obj);
</db:programlisting>
<db:programlisting language="cpp">import { name } from &quot;info&quot;;

export function getName()
{
    return name;
}
</db:programlisting>
</db:section>
<db:section xml:id="engine-configuration">
<db:title>Engine Configuration</db:title>
<db:para>The <db:link xlink:href="qjsengine.xml#globalObject">globalObject</db:link>() function returns the <db:emphasis role="bold">Global Object</db:emphasis> associated with the script engine. Properties of the Global Object are accessible from any script code (i.e. they are global variables). Typically, before evaluating &quot;user&quot; scripts, you will want to configure a script engine by adding one or more properties to the Global Object:</db:para>
<db:programlisting language="cpp">myEngine.globalObject().setProperty(&quot;myNumber&quot;, 123);
...
QJSValue myNumberPlusOne = myEngine.evaluate(&quot;myNumber + 1&quot;);
</db:programlisting>
<db:para>Adding custom properties to the scripting environment is one of the standard means of providing a scripting API that is specific to your application. Usually these custom properties are objects created by the <db:link xlink:href="qjsengine.xml#newQObject">newQObject</db:link>() or <db:link xlink:href="qjsengine.xml#newObject">newObject</db:link>() functions.</db:para>
</db:section>
<db:section xml:id="script-exceptions">
<db:title>Script Exceptions</db:title>
<db:para><db:link xlink:href="qjsengine.xml#evaluate">evaluate</db:link>() can throw a script exception (e.g. due to a syntax error). If it does, then <db:link xlink:href="qjsengine.xml#evaluate">evaluate</db:link>() returns the value that was thrown (typically an <db:code>Error</db:code> object). Use <db:link xlink:href="">QJSValue::isError()</db:link> to check for exceptions.</db:para>
<db:para>For detailed information about the error, use <db:link xlink:href="">QJSValue::toString()</db:link> to obtain an error message, and use <db:link xlink:href="">QJSValue::property()</db:link> to query the properties of the <db:code>Error</db:code> object. The following properties are available:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>name</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>message</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>fileName</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>lineNumber</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>stack</db:code></db:para>
</db:listitem>
</db:itemizedlist>
<db:programlisting language="cpp">QJSValue result = myEngine.evaluate(...);
if (result.isError())
    qDebug()
            &amp;lt;&amp;lt; &quot;Uncaught exception at line&quot;
            &amp;lt;&amp;lt; result.property(&quot;lineNumber&quot;).toInt()
            &amp;lt;&amp;lt; &quot;:&quot; &amp;lt;&amp;lt; result.toString();
</db:programlisting>
</db:section>
<db:section xml:id="script-object-creation">
<db:title>Script Object Creation</db:title>
<db:para>Use <db:link xlink:href="qjsengine.xml#newObject">newObject</db:link>() to create a JavaScript object; this is the C++ equivalent of the script statement <db:code>new Object()</db:code>. You can use the object-specific functionality in <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> to manipulate the script object (e.g. QJSValue::setProperty()). Similarly, use <db:link xlink:href="qjsengine.xml#newArray">newArray</db:link>() to create a JavaScript array object.</db:para>
</db:section>
<db:section xml:id="qobject-integration">
<db:title>QObject Integration</db:title>
<db:para>Use <db:link xlink:href="qjsengine.xml#newQObject">newQObject</db:link>() to wrap a <db:link xlink:href="qobject.xml">QObject</db:link> (or subclass) pointer. <db:link xlink:href="qjsengine.xml#newQObject">newQObject</db:link>() returns a proxy script object; properties, children, and signals and slots of the <db:link xlink:href="qobject.xml">QObject</db:link> are available as properties of the proxy object. No binding code is needed because it is done dynamically using the Qt meta object system.</db:para>
<db:programlisting language="cpp">QPushButton *button = new QPushButton;
QJSValue scriptButton = myEngine.newQObject(button);
myEngine.globalObject().setProperty(&quot;button&quot;, scriptButton);

myEngine.evaluate(&quot;button.checkable = true&quot;);

qDebug() &amp;lt;&amp;lt; scriptButton.property(&quot;checkable&quot;).toBool();
scriptButton.property(&quot;show&quot;).call(); // call the show() slot
</db:programlisting>
<db:para>Use <db:link xlink:href="qjsengine.xml#newQMetaObject-1">newQMetaObject</db:link>() to wrap a <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link>; this gives you a &quot;script representation&quot; of a <db:link xlink:href="qobject.xml">QObject</db:link>-based class. <db:link xlink:href="qjsengine.xml#newQMetaObject-1">newQMetaObject</db:link>() returns a proxy script object; enum values of the class are available as properties of the proxy object.</db:para>
<db:para>Constructors exposed to the meta-object system (using <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link>) can be called from the script to create a new <db:link xlink:href="qobject.xml">QObject</db:link> instance with <db:link xlink:href="qjsengine.xml#ObjectOwnership-enum">JavaScriptOwnership</db:link>. For example, given the following class definition:</db:para>
<db:programlisting language="cpp">class MyObject : public QObject
{
    Q_OBJECT

public:
    Q_INVOKABLE MyObject() {}
};
</db:programlisting>
<db:para>The <db:code>staticMetaObject</db:code> for the class can be exposed to JavaScript like so:</db:para>
<db:programlisting language="cpp">QJSValue jsMetaObject = engine.newQMetaObject(&amp;amp;MyObject::staticMetaObject);
engine.globalObject().setProperty(&quot;MyObject&quot;, jsMetaObject);
</db:programlisting>
<db:para>Instances of the class can then be created in JavaScript:</db:para>
<db:programlisting language="cpp">engine.evaluate(&quot;var myObject = new MyObject()&quot;);
</db:programlisting>
<db:note>
<db:para>Currently only classes using the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro are supported; it is not possible to expose the <db:code>staticMetaObject</db:code> of a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link> class to JavaScript.</db:para>
</db:note>
<db:section xml:id="dynamic-qobject-properties">
<db:title>Dynamic QObject Properties</db:title>
<db:para>Dynamic <db:link xlink:href="qobject.xml">QObject</db:link> properties are not supported. For example, the following code will not work:</db:para>
<db:programlisting language="cpp">QJSEngine engine;

QObject *myQObject = new QObject();
myQObject-&amp;gt;setProperty(&quot;dynamicProperty&quot;, 3);

QJSValue myScriptQObject = engine.newQObject(myQObject);
engine.globalObject().setProperty(&quot;myObject&quot;, myScriptQObject);

qDebug() &amp;lt;&amp;lt; engine.evaluate(&quot;myObject.dynamicProperty&quot;).toInt();
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="extensions">
<db:title>Extensions</db:title>
<db:para><db:link xlink:href="qjsengine.xml">QJSEngine</db:link> provides a compliant ECMAScript implementation. By default, familiar utilities like logging are not available, but they can be installed via the <db:link xlink:href="qjsengine.xml#installExtensions">installExtensions</db:link>() function.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsvalue.xml">QJSValue</db:link></db:member>
<db:member><db:link xlink:href="qtjavascript.xml">Making Applications Scriptable</db:link></db:member>
<db:member><db:link xlink:href="qtqml-javascript-functionlist.xml">List of JavaScript Objects and Functions</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Extension-enum">
<db:title>enum QJSEngine::Extension</db:title>
<db:bridgehead renderas="sect2">flags QJSEngine::Extensions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>Extension</db:enumname>
<db:enumitem>
<db:enumidentifier>TranslationExtension</db:enumidentifier>
<db:enumvalue>0x1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ConsoleExtension</db:enumidentifier>
<db:enumvalue>0x2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>GarbageCollectionExtension</db:enumidentifier>
<db:enumvalue>0x4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AllExtensions</db:enumidentifier>
<db:enumvalue>0xffffffff</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QJSEngine::Extensions</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum is used to specify extensions to be installed via <db:link xlink:href="qjsengine.xml#installExtensions">installExtensions</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsengine.xml">QJSEngine</db:link></db:emphasis>::TranslationExtension</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>Indicates that translation functions (<db:code>qsTr()</db:code>, for example) should be installed. This also installs the Qt.<db:link xlink:href="qjsengine.xml#uiLanguage-prop">uiLanguage</db:link> property.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsengine.xml">QJSEngine</db:link></db:emphasis>::ConsoleExtension</db:code></db:para>
</db:td>
<db:td><db:code>0x2</db:code></db:td>
<db:td>
<db:para>Indicates that console functions (<db:code>console.log()</db:code>, for example) should be installed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsengine.xml">QJSEngine</db:link></db:emphasis>::GarbageCollectionExtension</db:code></db:para>
</db:td>
<db:td><db:code>0x4</db:code></db:td>
<db:td>
<db:para>Indicates that garbage collection functions (<db:code>gc()</db:code>, for example) should be installed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsengine.xml">QJSEngine</db:link></db:emphasis>::AllExtensions</db:code></db:para>
</db:td>
<db:td><db:code>0xffffffff</db:code></db:td>
<db:td>
<db:para>Indicates that all extension should be installed.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para><db:emphasis role="bold">TranslationExtension</db:emphasis></db:para>
<db:para>The relation between script translation functions and C++ translation functions is described in the following table:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Script Function</db:para>
</db:th>
<db:th>
<db:para>Corresponding C++ Function</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>qsTr()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qttranslation-proxy.xml#QT_TR_NOOP">QT_TR_NOOP</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qttranslation-proxy.xml#QT_TR_NOOP">QT_TR_NOOP</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsTranslate()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qcoreapplication.xml#translate">QCoreApplication::translate</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qttranslation-proxy.xml#QT_TRANSLATE_NOOP">QT_TRANSLATE_NOOP</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qttranslation-proxy.xml#QT_TRANSLATE_NOOP">QT_TRANSLATE_NOOP</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsTrId()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qttranslation-proxy.xml#qtTrId">qtTrId</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qttranslation-proxy.xml#QT_TRID_NOOP">QT_TRID_NOOP</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qttranslation-proxy.xml#QT_TRID_NOOP">QT_TRID_NOOP</db:link>()</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This flag also adds an <db:code>arg()</db:code> function to the string prototype.</db:para>
<db:para>For more information, see the <db:link xlink:href="internationalization.xml">Internationalization with Qt</db:link> documentation.</db:para>
<db:para><db:emphasis role="bold">ConsoleExtension</db:emphasis></db:para>
<db:para>The <db:link xlink:href="qtquick-debugging.xml#console-api">console</db:link> object implements a subset of the <db:link xlink:href="https://developer.mozilla.org/en-US/docs/Web/API/Console">Console API</db:link>, which provides familiar logging functions, such as <db:code>console.log()</db:code>.</db:para>
<db:para>The list of functions added is as follows:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>console.assert()</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>console.debug()</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>console.exception()</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>console.info()</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>console.log()</db:code> (equivalent to <db:code>console.debug()</db:code>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>console.error()</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>console.time()</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>console.timeEnd()</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>console.trace()</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>console.count()</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>console.warn()</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>print()</db:code> (equivalent to <db:code>console.debug()</db:code>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For more information, see the <db:link xlink:href="qtquick-debugging.xml#console-api">Console API</db:link> documentation.</db:para>
<db:para><db:emphasis role="bold">GarbageCollectionExtension</db:emphasis></db:para>
<db:para>The <db:code>gc()</db:code> function is equivalent to calling <db:link xlink:href="qjsengine.xml#collectGarbage">collectGarbage</db:link>().</db:para>
<db:para>The <db:code>Extensions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Extension&gt;. </db:code>It stores an OR combination of <db:code>Extension</db:code> values.</db:para>
</db:section>
<db:section xml:id="ObjectOwnership-enum">
<db:title>enum QJSEngine::ObjectOwnership</db:title>
<db:enumsynopsis>
<db:enumname>ObjectOwnership</db:enumname>
<db:enumitem>
<db:enumidentifier>CppOwnership</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>JavaScriptOwnership</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>ObjectOwnership controls whether or not the JavaScript memory manager automatically destroys the <db:link xlink:href="qobject.xml">QObject</db:link> when the corresponding JavaScript object is garbage collected by the engine. The two ownership options are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsengine.xml">QJSEngine</db:link></db:emphasis>::CppOwnership</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The object is owned by C++ code and the JavaScript memory manager will never delete it. The JavaScript destroy() method cannot be used on these objects. This option is similar to QScriptEngine::QtOwnership.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsengine.xml">QJSEngine</db:link></db:emphasis>::JavaScriptOwnership</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The object is owned by JavaScript. When the object is returned to the JavaScript memory manager as the return value of a method call, the JavaScript memory manager will track it and delete it if there are no remaining JavaScript references to it and it has no <db:link xlink:href="qobject.xml#parent">QObject::parent</db:link>(). An object tracked by one <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> will be deleted during that <db:link xlink:href="qjsengine.xml">QJSEngine</db:link>'s destructor. Thus, JavaScript references between objects with JavaScriptOwnership from two different engines will not be valid if one of these engines is deleted. This option is similar to QScriptEngine::ScriptOwnership.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Generally an application doesn't need to set an object's ownership explicitly. The JavaScript memory manager uses a heuristic to set the default ownership. By default, an object that is created by the JavaScript memory manager has JavaScriptOwnership. The exception to this are the root objects created by calling <db:link xlink:href="qqmlcomponent.xml#create">QQmlComponent::create</db:link>() or <db:link xlink:href="qqmlcomponent.xml#beginCreate">QQmlComponent::beginCreate</db:link>(), which have CppOwnership by default. The ownership of these root-level objects is considered to have been transferred to the C++ caller.</db:para>
<db:para>Objects not-created by the JavaScript memory manager have CppOwnership by default. The exception to this are objects returned from C++ method calls; their ownership will be set to JavaScriptOwnership. This applies only to explicit invocations of <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> methods or slots, but not to property getter invocations.</db:para>
<db:para>Calling <db:link xlink:href="qjsengine.xml#setObjectOwnership">setObjectOwnership</db:link>() overrides the default ownership.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtqml-cppintegration-data.xml#data-ownership">Data Ownership</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="uiLanguage-prop">
<db:title>uiLanguage : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>uiLanguage</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">uiLanguage</db:synopsisinfo>
<db:synopsisinfo role="setter">setUiLanguage</db:synopsisinfo>
<db:synopsisinfo role="notifier">uiLanguageChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the language to be used for translating user interface strings</db:para>
<db:para>This property holds the name of the language to be used for user interface string translations. It is exposed for reading and writing as <db:code>Qt.uiLanguage</db:code> when the <db:link xlink:href="qjsengine.xml#Extension-enum">QJSEngine::TranslationExtension</db:link> is installed on the engine. It is always exposed in instances of <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>.</db:para>
<db:para>You can set the value freely and use it in bindings. It is recommended to set it after installing translators in your application. By convention, an empty string means no translation from the language used in the source code is intended to occur.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">uiLanguage</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setUiLanguage</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>language</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">uiLanguageChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QJSEngine">
<db:title>QJSEngine::QJSEngine()</db:title>
<db:constructorsynopsis>
<db:methodname>QJSEngine</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSEngine()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> object.</db:para>
<db:para>The <db:link xlink:href="qjsengine.xml#globalObject">globalObject</db:link>() is initialized to have properties as described in <db:link xlink:href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">ECMA-262</db:link>, Section 15.1.</db:para>
</db:section>
<db:section xml:id="QJSEngine-1">
<db:title>[explicit] QJSEngine::QJSEngine(QObject *<db:emphasis>parent</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QJSEngine</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSEngine(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> object with the given <db:code role="parameter">parent</db:code>.</db:para>
<db:para>The <db:link xlink:href="qjsengine.xml#globalObject">globalObject</db:link>() is initialized to have properties as described in <db:link xlink:href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">ECMA-262</db:link>, Section 15.1.</db:para>
</db:section>
<db:section xml:id="dtor.QJSEngine">
<db:title>[override virtual] QJSEngine::~QJSEngine()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QJSEngine</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QJSEngine() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys this <db:link xlink:href="qjsengine.xml">QJSEngine</db:link>.</db:para>
<db:para>Garbage is not collected from the persistent JS heap during <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> destruction. If you need all memory freed, call <db:link xlink:href="qjsengine.xml#collectGarbage">collectGarbage</db:link>() manually right before destroying the <db:link xlink:href="qjsengine.xml">QJSEngine</db:link>.</db:para>
</db:section>
<db:section xml:id="catchError">
<db:title>[since Qt 6.1] QJSValue QJSEngine::catchError()</db:title>
<db:methodsynopsis>
<db:type>QJSValue</db:type>
<db:methodname>catchError</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue catchError()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If an exception is currently pending, catches it and returns it as a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>. Otherwise returns undefined as <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>. After calling this method <db:link xlink:href="qjsengine.xml#hasError">hasError</db:link>() returns <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
</db:section>
<db:section xml:id="coerceValue">
<db:title>To QJSEngine::coerceValue(const From &amp;<db:emphasis>from</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>To</db:type>
<db:methodname>coerceValue</db:methodname>
<db:methodparam>
<db:type>const From &amp;</db:type>
<db:parameter>from</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">To coerceValue(const From &amp;from)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the given <db:code role="parameter">from</db:code> converted to the template type <db:code>To</db:code>. The conversion is done in JavaScript semantics. Those differ from qvariant_cast's semantics. There are a number of implicit conversions between JavaScript-equivalent types that are not performed by qvariant_cast by default. This method is a generalization of all the other conversion methods in this class.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#fromVariant">fromVariant</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#qvariant_cast">qvariant_cast</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#fromScriptValue">fromScriptValue</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#toScriptValue">toScriptValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="collectGarbage">
<db:title>void QJSEngine::collectGarbage()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>collectGarbage</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void collectGarbage()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Runs the garbage collector.</db:para>
<db:para>The garbage collector will attempt to reclaim memory by locating and disposing of objects that are no longer reachable in the script environment.</db:para>
<db:para>Normally you don't need to call this function; the garbage collector will automatically be invoked when the <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> decides that it's wise to do so (i.e. when a certain number of new objects have been created). However, you can call this function to explicitly request that garbage collection should be performed as soon as possible.</db:para>
</db:section>
<db:section xml:id="evaluate">
<db:title>QJSValue QJSEngine::evaluate(const QString &amp;<db:emphasis>program</db:emphasis>, const QString &amp;<db:emphasis>fileName</db:emphasis> = QString(), int <db:emphasis>lineNumber</db:emphasis> = 1, QStringList *<db:emphasis>exceptionStackTrace</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:type>QJSValue</db:type>
<db:methodname>evaluate</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>program</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>fileName</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>lineNumber</db:parameter>
<db:initializer>1</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QStringList *</db:type>
<db:parameter>exceptionStackTrace</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue evaluate(const QString &amp;program, const QString &amp;fileName, int lineNumber, QStringList *exceptionStackTrace)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Evaluates <db:code role="parameter">program</db:code>, using <db:code role="parameter">lineNumber</db:code> as the base line number, and returns the result of the evaluation.</db:para>
<db:para>The script code will be evaluated in the context of the global object.</db:para>
<db:note>
<db:para>If you need to evaluate inside a QML context, use <db:link xlink:href="qqmlexpression.xml">QQmlExpression</db:link> instead.</db:para>
</db:note>
<db:para>The evaluation of <db:code role="parameter">program</db:code> can cause an <db:link xlink:href="qjsengine.xml#script-exceptions">exception</db:link> in the engine; in this case the return value will be the exception that was thrown (typically an <db:code>Error</db:code> object; see QJSValue::isError()).</db:para>
<db:para><db:code role="parameter">lineNumber</db:code> is used to specify a starting line number for <db:code role="parameter">program</db:code>; line number information reported by the engine that pertains to this evaluation will be based on this argument. For example, if <db:code role="parameter">program</db:code> consists of two lines of code, and the statement on the second line causes a script exception, the exception line number would be <db:code role="parameter">lineNumber</db:code> plus one. When no starting line number is specified, line numbers will be 1-based.</db:para>
<db:para><db:code role="parameter">fileName</db:code> is used for error reporting. For example, in error objects the file name is accessible through the &quot;fileName&quot; property if it is provided with this function.</db:para>
<db:para><db:code role="parameter">exceptionStackTrace</db:code> is used to report whether an uncaught exception was thrown. If you pass a non-null pointer to a <db:link xlink:href="qstringlist.xml">QStringList</db:link> to it, it will set it to list of &quot;stackframe messages&quot; if the script threw an unhandled exception, or an empty list otherwise. A stackframe message has the format function name:line number:column:file name</db:para>
<db:note>
<db:para>In some cases, e.g. for native functions, function name and file name can be empty and line number and column can be -1.</db:para>
</db:note>
<db:note>
<db:para>If an exception was thrown and the exception value is not an Error instance (i.e., QJSValue::isError() returns <db:code>false</db:code>), the exception value will still be returned. Use <db:code>exceptionStackTrace-&gt;isEmpty()</db:code> to distinguish whether the value was a normal or an exceptional return value.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlexpression.xml#evaluate">QQmlExpression::evaluate</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromManagedValue">
<db:title>T QJSEngine::fromManagedValue(const QJSManagedValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fromManagedValue</db:methodname>
<db:methodparam>
<db:type>const QJSManagedValue &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fromManagedValue(const QJSManagedValue &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the given <db:code role="parameter">value</db:code> converted to the template type <db:code>T</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#toManagedValue">toManagedValue</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#coerceValue">coerceValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromPrimitiveValue">
<db:title>T QJSEngine::fromPrimitiveValue(const QJSPrimitiveValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fromPrimitiveValue</db:methodname>
<db:methodparam>
<db:type>const QJSPrimitiveValue &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fromPrimitiveValue(const QJSPrimitiveValue &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the given <db:code role="parameter">value</db:code> converted to the template type <db:code>T</db:code>.</db:para>
<db:para>Since <db:link xlink:href="qjsprimitivevalue.xml">QJSPrimitiveValue</db:link> can only hold int, bool, double, <db:link xlink:href="qstring.xml">QString</db:link>, and the equivalents of JavaScript <db:code>null</db:code> and <db:code>undefined</db:code>, the value will be coerced aggressively if you request any other type.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#toPrimitiveValue">toPrimitiveValue</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#coerceValue">coerceValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromScriptValue">
<db:title>T QJSEngine::fromScriptValue(const QJSValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fromScriptValue</db:methodname>
<db:methodparam>
<db:type>const QJSValue &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fromScriptValue(const QJSValue &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the given <db:code role="parameter">value</db:code> converted to the template type <db:code>T</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#toScriptValue">toScriptValue</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#coerceValue">coerceValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromVariant">
<db:title>T QJSEngine::fromVariant(const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fromVariant</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fromVariant(const QVariant &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the given <db:code role="parameter">value</db:code> converted to the template type <db:code>T</db:code>. The conversion is done in JavaScript semantics. Those differ from qvariant_cast's semantics. There are a number of implicit conversions between JavaScript-equivalent types that are not performed by qvariant_cast by default.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#coerceValue">coerceValue</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#fromScriptValue">fromScriptValue</db:link>()</db:member>
<db:member><db:link xlink:href="qvariant.xml#qvariant_cast">qvariant_cast</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="globalObject">
<db:title>QJSValue QJSEngine::globalObject() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJSValue</db:type>
<db:methodname>globalObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue globalObject() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns this engine's Global Object.</db:para>
<db:para>By default, the Global Object contains the built-in objects that are part of <db:link xlink:href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">ECMA-262</db:link>, such as Math, Date and String. Additionally, you can set properties of the Global Object to make your own extensions available to all script code. Non-local variables in script code will be created as properties of the Global Object, as well as local variables in global code.</db:para>
</db:section>
<db:section xml:id="hasError">
<db:title>[since Qt 6.1] bool QJSEngine::hasError() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasError</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasError() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the last JavaScript execution resulted in an exception or if <db:link xlink:href="qjsengine.xml#throwError">throwError</db:link>() was called. Otherwise returns <db:code>false</db:code>. Mind that <db:link xlink:href="qjsengine.xml#evaluate">evaluate</db:link>() catches any exceptions thrown in the evaluated code.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
</db:section>
<db:section xml:id="importModule">
<db:title>QJSValue QJSEngine::importModule(const QString &amp;<db:emphasis>fileName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QJSValue</db:type>
<db:methodname>importModule</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>fileName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue importModule(const QString &amp;fileName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Imports the module located at <db:code role="parameter">fileName</db:code> and returns a module namespace object that contains all exported variables, constants and functions as properties.</db:para>
<db:para>If this is the first time the module is imported in the engine, the file is loaded from the specified location in either the local file system or the Qt resource system and evaluated as an ECMAScript module. The file is expected to be encoded in UTF-8 text.</db:para>
<db:para>Subsequent imports of the same module will return the previously imported instance. Modules are singletons and remain around until the engine is destroyed.</db:para>
<db:para>The specified <db:code role="parameter">fileName</db:code> will internally be normalized using <db:link xlink:href="qfileinfo.xml#canonicalFilePath">QFileInfo::canonicalFilePath</db:link>(). That means that multiple imports of the same file on disk using different relative paths will load the file only once.</db:para>
<db:note>
<db:para>If an exception is thrown during the loading of the module, the return value will be the exception (typically an <db:code>Error</db:code> object; see QJSValue::isError()).</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#registerModule">registerModule</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="installExtensions">
<db:title>void QJSEngine::installExtensions(QJSEngine::Extensions <db:emphasis>extensions</db:emphasis>, const QJSValue &amp;<db:emphasis>object</db:emphasis> = QJSValue())</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>installExtensions</db:methodname>
<db:methodparam>
<db:type>QJSEngine::Extensions</db:type>
<db:parameter>extensions</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QJSValue &amp;</db:type>
<db:parameter>object</db:parameter>
<db:initializer>QJSValue()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void installExtensions(QJSEngine::Extensions extensions, const QJSValue &amp;object)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Installs JavaScript <db:code role="parameter">extensions</db:code> to add functionality that is not available in a standard ECMAScript implementation.</db:para>
<db:para>The extensions are installed on the given <db:code role="parameter">object</db:code>, or on the <db:link xlink:href="qjsengine.xml#globalObject">Global Object</db:link> if no object is specified.</db:para>
<db:para>Several extensions can be installed at once by <db:code>OR</db:code>-ing the enum values:</db:para>
<db:programlisting language="cpp">installExtensions(QJSEngine::TranslationExtension | QJSEngine::ConsoleExtension);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#Extension-enum">Extension</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isInterrupted">
<db:title>bool QJSEngine::isInterrupted() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isInterrupted</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isInterrupted() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns whether JavaScript execution is currently interrupted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#setInterrupted">setInterrupted</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newArray">
<db:title>QJSValue QJSEngine::newArray(uint <db:emphasis>length</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>QJSValue</db:type>
<db:methodname>newArray</db:methodname>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>length</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue newArray(uint length)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a JavaScript object of class Array with the given <db:code role="parameter">length</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#newObject">newObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newErrorObject">
<db:title>QJSValue QJSEngine::newErrorObject(QJSValue::ErrorType <db:emphasis>errorType</db:emphasis>, const QString &amp;<db:emphasis>message</db:emphasis> = QString())</db:title>
<db:methodsynopsis>
<db:type>QJSValue</db:type>
<db:methodname>newErrorObject</db:methodname>
<db:methodparam>
<db:type>QJSValue::ErrorType</db:type>
<db:parameter>errorType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>message</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue newErrorObject(QJSValue::ErrorType errorType, const QString &amp;message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a JavaScript object of class Error, with <db:code role="parameter">message</db:code> as the error message.</db:para>
<db:para>The prototype of the created object will be <db:code role="parameter">errorType</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#newObject">newObject</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#throwError">throwError</db:link>()</db:member>
<db:member><db:link xlink:href="">QJSValue::isError()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newObject">
<db:title>QJSValue QJSEngine::newObject()</db:title>
<db:methodsynopsis>
<db:type>QJSValue</db:type>
<db:methodname>newObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue newObject()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a JavaScript object of class Object.</db:para>
<db:para>The prototype of the created object will be the Object prototype object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#newArray">newArray</db:link>()</db:member>
<db:member><db:link xlink:href="">QJSValue::setProperty()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newQMetaObject">
<db:title>QJSValue QJSEngine::newQMetaObject(const QMetaObject *<db:emphasis>metaObject</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QJSValue</db:type>
<db:methodname>newQMetaObject</db:methodname>
<db:methodparam>
<db:type>const QMetaObject *</db:type>
<db:parameter>metaObject</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue newQMetaObject(const QMetaObject *metaObject)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a JavaScript object that wraps the given <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> The <db:code role="parameter">metaObject</db:code> must outlive the script engine. It is recommended to only use this method with static metaobjects.</db:para>
<db:para>When called as a constructor, a new instance of the class will be created. Only constructors exposed by <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> will be visible from the script engine.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#newQObject">newQObject</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#qobject-integration">QObject Integration</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newQMetaObject-1">
<db:title>QJSValue QJSEngine::newQMetaObject()</db:title>
<db:methodsynopsis>
<db:type>QJSValue</db:type>
<db:methodname>newQMetaObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue newQMetaObject()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a JavaScript object that wraps the static <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> associated with class <db:code>T</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#newQObject">newQObject</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#qobject-integration">QObject Integration</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newQObject">
<db:title>QJSValue QJSEngine::newQObject(QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QJSValue</db:type>
<db:methodname>newQObject</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue newQObject(QObject *object)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a JavaScript object that wraps the given <db:link xlink:href="qobject.xml">QObject</db:link> <db:code role="parameter">object</db:code>, using <db:link xlink:href="qjsengine.xml#ObjectOwnership-enum">JavaScriptOwnership</db:link>.</db:para>
<db:para>Signals and slots, properties and children of <db:code role="parameter">object</db:code> are available as properties of the created <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>.</db:para>
<db:para>If <db:code role="parameter">object</db:code> is a null pointer, this function returns a null value.</db:para>
<db:para>If a default prototype has been registered for the <db:code role="parameter">object</db:code>'s class (or its superclass, recursively), the prototype of the new script object will be set to be that default prototype.</db:para>
<db:para>If the given <db:code role="parameter">object</db:code> is deleted outside of the engine's control, any attempt to access the deleted <db:link xlink:href="qobject.xml">QObject</db:link>'s members through the JavaScript wrapper object (either by script code or C++) will result in a <db:link xlink:href="qjsengine.xml#script-exceptions">script exception</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QJSValue::toQObject()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newSymbol">
<db:title>[since 6.2] QJSValue QJSEngine::newSymbol(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QJSValue</db:type>
<db:methodname>newSymbol</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue newSymbol(const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a JavaScript object of class Symbol, with value <db:code role="parameter">name</db:code>.</db:para>
<db:para>The prototype of the created object will be the Symbol prototype object.</db:para>
<db:para>This function was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#newObject">newObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="objectOwnership">
<db:title>[static] QJSEngine::ObjectOwnership QJSEngine::objectOwnership(QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QJSEngine::ObjectOwnership</db:type>
<db:methodname>objectOwnership</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSEngine::ObjectOwnership objectOwnership(QObject *object)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the ownership of <db:code role="parameter">object</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#setObjectOwnership">setObjectOwnership</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#ObjectOwnership-enum">QJSEngine::ObjectOwnership</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="registerModule">
<db:title>bool QJSEngine::registerModule(const QString &amp;<db:emphasis>moduleName</db:emphasis>, const QJSValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>registerModule</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>moduleName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QJSValue &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerModule(const QString &amp;moduleName, const QJSValue &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> to serve as a module. After this function is called, all modules that import <db:code role="parameter">moduleName</db:code> will import the value of <db:code role="parameter">value</db:code> instead of loading <db:code role="parameter">moduleName</db:code> from the filesystem.</db:para>
<db:para>Any valid <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> can be registered, but named exports (i.e. <db:code>import { name } from &quot;info&quot;</db:code> are treated as members of an object, so the default export must be created with one of the newXYZ methods of <db:link xlink:href="qjsengine.xml">QJSEngine</db:link>.</db:para>
<db:para>Because this allows modules that do not exist on the filesystem to be imported, scripting applications can use this to provide built-in modules, similar to Node.js.</db:para>
<db:para>Returns <db:code>true</db:code> on success, <db:code>false</db:code> otherwise.</db:para>
<db:note>
<db:para>The <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> <db:code role="parameter">value</db:code> is not called or read until it is used by another module. This means that there is no code to evaluate, so no errors will be seen until another module throws an exception while trying to load this module.</db:para>
</db:note>
<db:warning>
<db:para>Attempting to access a named export from a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> that is not an object will trigger a <db:link xlink:href="qjsengine.xml#script-exceptions">exception</db:link>.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#importModule">importModule</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setInterrupted">
<db:title>void QJSEngine::setInterrupted(bool <db:emphasis>interrupted</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setInterrupted</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>interrupted</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setInterrupted(bool interrupted)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Interrupts or re-enables JavaScript execution.</db:para>
<db:para>If <db:code role="parameter">interrupted</db:code> is <db:code>true</db:code>, any JavaScript executed by this engine immediately aborts and returns an error object until this function is called again with a value of <db:code>false</db:code> for <db:code role="parameter">interrupted</db:code>.</db:para>
<db:para>This function is thread safe. You may call it from a different thread in order to interrupt, for example, an infinite loop in JavaScript.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#isInterrupted">isInterrupted</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setObjectOwnership">
<db:title>[static] void QJSEngine::setObjectOwnership(QObject *<db:emphasis>object</db:emphasis>, QJSEngine::ObjectOwnership <db:emphasis>ownership</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>setObjectOwnership</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QJSEngine::ObjectOwnership</db:type>
<db:parameter>ownership</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setObjectOwnership(QObject *object, QJSEngine::ObjectOwnership ownership)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the <db:code role="parameter">ownership</db:code> of <db:code role="parameter">object</db:code>.</db:para>
<db:para>An object with <db:code>JavaScriptOwnership</db:code> is not garbage collected as long as it still has a parent, even if there are no references to it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#objectOwnership">objectOwnership</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#ObjectOwnership-enum">QJSEngine::ObjectOwnership</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="throwError">
<db:title>[since Qt 5.12] void QJSEngine::throwError(const QString &amp;<db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>throwError</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void throwError(const QString &amp;message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Throws a run-time error (exception) with the given <db:code role="parameter">message</db:code>.</db:para>
<db:para>This method is the C++ counterpart of a <db:code>throw()</db:code> expression in JavaScript. It enables C++ code to report run-time errors to <db:link xlink:href="qjsengine.xml">QJSEngine</db:link>. Therefore it should only be called from C++ code that was invoked by a JavaScript function through <db:link xlink:href="qjsengine.xml">QJSEngine</db:link>.</db:para>
<db:para>When returning from C++, the engine will interrupt the normal flow of execution and call the next pre-registered exception handler with an error object that contains the given <db:code role="parameter">message</db:code>. The error object will point to the location of the top-most context on the JavaScript caller stack; specifically, it will have properties <db:code>lineNumber</db:code>, <db:code>fileName</db:code> and <db:code>stack</db:code>. These properties are described in <db:link xlink:href="qjsengine.xml#script-exceptions">Script Exceptions</db:link>.</db:para>
<db:para>In the following example a C++ method in <db:emphasis>FileAccess.cpp</db:emphasis> throws an error in <db:emphasis>qmlFile.qml</db:emphasis> at the position where <db:code>readFileAsText()</db:code> is called:</db:para>
<db:programlisting language="cpp">// qmlFile.qml
function someFunction() {
  ...
  var text = FileAccess.readFileAsText(&quot;/path/to/file.txt&quot;);
}
</db:programlisting>
<db:programlisting language="cpp">// FileAccess.cpp
// Assuming that FileAccess is a QObject-derived class that has been
// registered as a singleton type and provides an invokable method
// readFileAsText()

QJSValue FileAccess::readFileAsText(const QString &amp;amp; filePath) {
  QFile file(filePath);

  if (!file.open(QIODevice::ReadOnly)) {
    jsEngine-&amp;gt;throwError(file.errorString());
    return QString();
  }

  ...
  return content;
}
</db:programlisting>
<db:para>It is also possible to catch the thrown error in JavaScript:</db:para>
<db:programlisting language="cpp">// qmlFile.qml
function someFunction() {
  ...
  var text;
  try {
    text = FileAccess.readFileAsText(&quot;/path/to/file.txt&quot;);
  } catch (error) {
    console.warn(&quot;In &quot; + error.fileName + &quot;:&quot; + &quot;error.lineNumber&quot; +
                 &quot;: &quot; + error.message);
  }
}
</db:programlisting>
<db:para>If you need a more specific run-time error to describe an exception, you can use the <db:link xlink:href="qjsengine.xml#throwError-1">throwError</db:link>(QJSValue::ErrorType errorType, const QString &amp;message) overload.</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#script-exceptions">Script Exceptions</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="throwError-1">
<db:title>[since Qt 5.12] void QJSEngine::throwError(QJSValue::ErrorType <db:emphasis>errorType</db:emphasis>, const QString &amp;<db:emphasis>message</db:emphasis> = QString())</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>throwError</db:methodname>
<db:methodparam>
<db:type>QJSValue::ErrorType</db:type>
<db:parameter>errorType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>message</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void throwError(QJSValue::ErrorType errorType, const QString &amp;message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads <db:link xlink:href="qjsengine.xml#throwError">throwError</db:link>().</db:para>
<db:para>Throws a run-time error (exception) with the given <db:code role="parameter">errorType</db:code> and <db:code role="parameter">message</db:code>.</db:para>
<db:programlisting language="cpp">// Assuming that DataEntry is a QObject-derived class that has been
// registered as a singleton type and provides an invokable method
// setAge().

void DataEntry::setAge(int age) {
  if (age &amp;lt; 0 || age &amp;gt; 200) {
    jsEngine-&amp;gt;throwError(QJSValue::RangeError,
                         &quot;Age must be between 0 and 200&quot;);
  }
  ...
}
</db:programlisting>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#script-exceptions">Script Exceptions</db:link></db:member>
<db:member><db:link xlink:href="qjsengine.xml#newErrorObject">newErrorObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="throwError-2">
<db:title>[since 6.1] void QJSEngine::throwError(const QJSValue &amp;<db:emphasis>error</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>throwError</db:methodname>
<db:methodparam>
<db:type>const QJSValue &amp;</db:type>
<db:parameter>error</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void throwError(const QJSValue &amp;error)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads <db:link xlink:href="qjsengine.xml#throwError">throwError</db:link>().</db:para>
<db:para>Throws a pre-constructed run-time <db:code role="parameter">error</db:code> (exception). This way you can use <db:link xlink:href="qjsengine.xml#newErrorObject">newErrorObject</db:link>() to create the error and customize it as necessary.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#script-exceptions">Script Exceptions</db:link></db:member>
<db:member><db:link xlink:href="qjsengine.xml#newErrorObject">newErrorObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toManagedValue">
<db:title>QJSManagedValue QJSEngine::toManagedValue(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QJSManagedValue</db:type>
<db:methodname>toManagedValue</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSManagedValue toManagedValue(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> with the given <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#fromManagedValue">fromManagedValue</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#coerceValue">coerceValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPrimitiveValue">
<db:title>QJSPrimitiveValue QJSEngine::toPrimitiveValue(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QJSPrimitiveValue</db:type>
<db:methodname>toPrimitiveValue</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSPrimitiveValue toPrimitiveValue(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a <db:link xlink:href="qjsprimitivevalue.xml">QJSPrimitiveValue</db:link> with the given <db:code role="parameter">value</db:code>.</db:para>
<db:para>Since <db:link xlink:href="qjsprimitivevalue.xml">QJSPrimitiveValue</db:link> can only hold int, bool, double, <db:link xlink:href="qstring.xml">QString</db:link>, and the equivalents of JavaScript <db:code>null</db:code> and <db:code>undefined</db:code>, the value will be coerced aggressively if you pass any other type.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#fromPrimitiveValue">fromPrimitiveValue</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#coerceValue">coerceValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toScriptValue">
<db:title>QJSValue QJSEngine::toScriptValue(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QJSValue</db:type>
<db:methodname>toScriptValue</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue toScriptValue(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> with the given <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsengine.xml#fromScriptValue">fromScriptValue</db:link>()</db:member>
<db:member><db:link xlink:href="qjsengine.xml#coerceValue">coerceValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qjsEnginex">
<db:title>QJSEngine *qjsEngine(const QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QJSEngine *</db:type>
<db:methodname>qjsEngine</db:methodname>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSEngine * qjsEngine(const QObject *object)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> associated with <db:code role="parameter">object</db:code>, if any.</db:para>
<db:para>This function is useful if you have exposed a <db:link xlink:href="qobject.xml">QObject</db:link> to the JavaScript environment and later in your program would like to regain access. It does not require you to keep the wrapper around that was returned from <db:link xlink:href="qjsengine.xml#newQObject">QJSEngine::newQObject</db:link>().</db:para>
</db:section>
</db:section>
</db:article>
