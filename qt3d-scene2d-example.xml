<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt 3D: Scene2D QML Example</db:title>
<db:productname>Qt3D</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt 3D Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A QML application that demonstrates using Qt Quick 2 within a Qt 3D scene.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/scene2d.png"/>
</db:imageobject>
</db:mediaobject>
<db:para><db:emphasis><db:link xlink:href="qml-qtquick-scene2d-scene2d.xml">Scene2D</db:link></db:emphasis> demonstrates rendering a Qt Quick 2 scene into a texture and utilising the texture within a Qt 3D application including handling mouse events. The 3D scene contains a single active camera and renders a 3D Qt logo along with some controls declared with Qt Quick Controls.</db:para>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:emphasis role="bold">Welcome</db:emphasis> mode and select the example from <db:emphasis role="bold">Examples</db:emphasis>. For more information, visit <db:link xlink:href="https://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="setting-up-the-3d-scene">
<db:title>Setting up the 3D Scene</db:title>
<db:para>We set up the 3D scene in an Entity that acts as the root of the object tree. The virtual camera is specified in <db:emphasis>main.qml</db:emphasis>:</db:para>
<db:programlisting language="cpp">    Camera {
        id: camera
        projectionType: CameraLens.PerspectiveProjection
        position: Qt.vector3d( 0.0, 0.0, 20 )
    }
</db:programlisting>
<db:para>The <db:link xlink:href="qml-qt3d-render-rendersettings.xml">RenderSettings</db:link> specify the rendering algorithm used and also enable triangle based picking which is needed to properly handle mouse events when projecting a Qt Quick scene onto 3D geometry:</db:para>
<db:programlisting language="cpp">        RenderSettings {
            activeFrameGraph: ForwardRenderer {
                camera: camera
                clearColor: &quot;white&quot;
            }
            pickingSettings.pickMethod: PickingSettings.TrianglePicking
        },
</db:programlisting>
<db:para>The 3D Qt logo that will be controlled by the controls in the Qt Quick scene is declared with:</db:para>
<db:programlisting language="cpp">    Entity {
        id: logoEntity

        Transform {
            id: logoTransform
            scale: 1
            translation: Qt.vector3d( 0, 0, logoControls.logoCentreZ )
            rotation: fromEulerAngles( logoControls.rotationX,
                                       logoControls.rotationY,
                                       logoControls.rotationZ )
        }

        Mesh {
            id: logoMesh
            source: &quot;Qt_logo.obj&quot;
        }

        PhongMaterial {
            id: logoMaterial
            diffuse: Qt.rgba( logoControls.colorR/255,
                              logoControls.colorG/255,
                              logoControls.colorB/255, 1.0 )
            ambient: Qt.rgba( 0.1, 0.1, 0.1, 1.0 )
            shininess: logoControls.shininess
        }

        components: [ logoTransform, logoMesh, logoMaterial ]
    }
</db:programlisting>
<db:para>It simply consists of a Mesh component to load the geometry; a PhongMaterial component to give it a surface appearance, and a Transform component to specify its postion, orientation, and scale. The properties of these components are bound to properties on the logoControls element which we will discuss next.</db:para>
</db:section>
<db:section xml:id="rendering-qt-quick-into-a-texture">
<db:title>Rendering Qt Quick into a Texture</db:title>
<db:para>We begin by declaring the Entity that will become our control panel. It consists of a <db:link xlink:href="qml-qt3d-render-geometryrenderer.xml">GeometryRenderer</db:link> with a <db:link xlink:href="qml-qt3d-extras-cuboidmesh.xml">CuboidMesh</db:link> view onto which we will place the texture containing a rendering of the Qt Quick scene. In this case we are using a simple cube for the geometry, but we could use any valid 3D geometry as long as it has texture coordinates. The texture coordinates are used for projecting the texture onto the 3D surface, and also for calculating the coordinates of mouse events to be passed to the originating Qt Quick scene.</db:para>
<db:programlisting language="cpp">    Entity {
        id: cube

        components: [cubeTransform, cubeMaterial, cubeMesh, cubePicker]

        property real rotationAngle: 0

        Transform {
            id: cubeTransform
            translation: Qt.vector3d(2, 0, 10)
            scale3D: Qt.vector3d(1, 4, 1)
            rotation: fromAxisAndAngle(Qt.vector3d(0,1,0), cube.rotationAngle)
        }

        CuboidMesh {
            id: cubeMesh
        }
</db:programlisting>
<db:para>We also include an <db:link xlink:href="qml-qt3d-render-objectpicker.xml">ObjectPicker</db:link> component so that we can interact with the controls using the mouse:</db:para>
<db:programlisting language="cpp">        ObjectPicker {
            id: cubePicker
            hoverEnabled: true
            dragEnabled: true

            // Explicitly require a middle click to have the Scene2D grab the mouse
            // events from the picker
            onPressed: {
                if (pick.button === PickEvent.MiddleButton) {
                    qmlTexture.mouseEnabled = !qmlTexture.mouseEnabled
                    logoControls.enabled = !logoControls.enabled
                }
            }
        }
</db:programlisting>
<db:para>For this example we have chosen to use an interaction mechanism whereby you must explicitly middle-click the controls to enable them.</db:para>
<db:para>To apply the texture to the mesh, we make use of the built in TextureMaterial:</db:para>
<db:programlisting language="cpp">        TextureMaterial {
            id: cubeMaterial
            texture: offscreenTexture
        }
</db:programlisting>
<db:para>The final remaining piece is how to render the above texture from a Qt Quick scene. This is done with the <db:link xlink:href="qml-qtquick-scene2d-scene2d.xml">Scene2D</db:link> element:</db:para>
<db:programlisting language="cpp">        Scene2D {
            id: qmlTexture
            output: RenderTargetOutput {
                attachmentPoint: RenderTargetOutput.Color0
                texture: Texture2D {
                    id: offscreenTexture
                    width: 256
                    height: 1024
                    format: Texture.RGBA8_UNorm
                    generateMipMaps: true
                    magnificationFilter: Texture.Linear
                    minificationFilter: Texture.LinearMipMapLinear
                    wrapMode {
                        x: WrapMode.ClampToEdge
                        y: WrapMode.ClampToEdge
</db:programlisting>
<db:para>where we have made use of the <db:link xlink:href="qml-qt3d-render-texture2d.xml">Texture2D</db:link> and <db:link xlink:href="qml-qt3d-render-rendertargetoutput.xml">RenderTargetOutput</db:link> types to create a destination texture and attach it as the output of the <db:link xlink:href="qml-qtquick-scene2d-scene2d.xml">Scene2D</db:link> renderer.</db:para>
<db:para>Next, we tell the <db:link xlink:href="qml-qtquick-scene2d-scene2d.xml">Scene2D</db:link> object which entities may feed it input events and we initially disable the handling of mouse events:</db:para>
<db:programlisting language="cpp">                    }
                }
            }

            entities: [ cube ]
</db:programlisting>
<db:para>Finally, we can specify the Qt Quick scene to render by adding a custom QML component as a child to the <db:link xlink:href="qml-qtquick-scene2d-scene2d.xml">Scene2D</db:link> element:</db:para>
<db:programlisting language="cpp">            LogoControls {
                id: logoControls
                width: offscreenTexture.width
                height: offscreenTexture.height
            }
        }
</db:programlisting>
<db:para>When the mouseEnabled property is set to true by the <db:link xlink:href="qml-qt3d-render-objectpicker.xml">ObjectPicker</db:link>, then the <db:link xlink:href="qml-qtquick-scene2d-scene2d.xml">Scene2D</db:link> object will process mouse events from any ObjectPickers attached to the listed entities. In this way, you have the freedom to use the texture generated by the <db:link xlink:href="qml-qtquick-scene2d-scene2d.xml">Scene2D</db:link> object in any way you wish, even on more than one Entity.</db:para>
<db:para>The <db:emphasis>LogoControls.qml</db:emphasis> file is just a regular Qt Quick 2 scene which in this case also makes use of the Qt Quick Controls components.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qt3d.git/tree/examples/qt3d/scene2d?h=6.1">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
