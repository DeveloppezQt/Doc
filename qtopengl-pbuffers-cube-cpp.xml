<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Pixel Buffers Example</db:title>
<db:productname>QtOpenGL</db:productname>
<db:edition>Qt 5.3.2 Reference Documentation</db:edition>
<db:titleabbrev>QtOpenGL Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Pixel Buffers example demonstrates how to use the QGLPixelBuffer class to render into an off-screen buffer and use the contents as a dynamic texture in a <db:link xlink:href="qglwidget.xml">QGLWidget</db:link>.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** You may use this file under the terms of the BSD license as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names
**     of its contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;cube.h&quot;
#include &quot;glwidget.h&quot;

#include &lt;QtGui/QImage&gt;
#include &lt;QtCore/QPropertyAnimation&gt;

static const qreal speeds[] = { 3.8f, 4.4f, 5.6f };
static const qreal amplitudes[] = { 2.0f, 2.5f, 3.0f };

static inline void qSetColor(float colorVec[], QColor c)
{
    colorVec[0] = c.redF();
    colorVec[1] = c.greenF();
    colorVec[2] = c.blueF();
    colorVec[3] = c.alphaF();
}

int Geometry::append(const QVector3D &amp;a, const QVector3D &amp;n, const QVector2D &amp;t)
{
    int v = vertices.count();
    vertices.append(a);
    normals.append(n);
    texCoords.append(t);
    faces.append(v);
    colors.append(QVector4D(0.6f, 0.6f, 0.6f, 1.0f));
    return v;
}

void Geometry::addQuad(const QVector3D &amp;a, const QVector3D &amp;b,
                           const QVector3D &amp;c, const QVector3D &amp;d,
                           const QVector&lt;QVector2D&gt; &amp;tex)
{
    QVector3D norm = QVector3D::normal(a, b, c);
    // append first triangle
    int aref = append(a, norm, tex[0]);
    append(b, norm, tex[1]);
    int cref = append(c, norm, tex[2]);
    // append second triangle
    faces.append(aref);
    faces.append(cref);
    append(d, norm, tex[3]);
}

void Geometry::loadArrays() const
{
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_NORMAL_ARRAY);
    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
    glEnableClientState(GL_COLOR_ARRAY);
    glVertexPointer(3, GL_FLOAT, 0, vertices.constData());
    glNormalPointer(GL_FLOAT, 0, normals.constData());
    glTexCoordPointer(2, GL_FLOAT, 0, texCoords.constData());
    glColorPointer(4, GL_FLOAT, 0, colors.constData());
}

void Geometry::setColors(int start, GLfloat colorArray[4][4])
{
    int off = faces[start];
    for (int i = 0; i &lt; 4; ++i)
        colors[i + off] = QVector4D(colorArray[i][0],
                                      colorArray[i][1],
                                      colorArray[i][2],
                                      colorArray[i][3]);
}

Tile::Tile(const QVector3D &amp;loc)
    : location(loc)
    , start(0)
    , count(0)
    , useFlatColor(false)
    , geom(0)
{
    qSetColor(faceColor, QColor(Qt::darkGray));
}

void Tile::setColors(GLfloat colorArray[4][4])
{
    useFlatColor = true;
    geom-&gt;setColors(start, colorArray);
}

void Tile::draw() const
{
    QMatrix4x4 mat;
    mat.translate(location);
    mat.rotate(orientation);
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glMultMatrixf(mat.constData());
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, faceColor);
    glDrawElements(GL_TRIANGLES, count, GL_UNSIGNED_SHORT, geom-&gt;indices() + start);
    glPopMatrix();
}

TileBuilder::TileBuilder(Geometry *g, qreal depth, qreal size)
    : verts(4)
    , tex(4)
    , start(g-&gt;count())
    , count(0)
    , geom(g)
{
    // front face - make a square with bottom-left at origin
    verts[br].setX(size);
    verts[tr].setX(size);
    verts[tr].setY(size);
    verts[tl].setY(size);

    // these vert numbers are good for the tex-coords
    for (int i = 0; i &lt; 4; ++i)
        tex[i] = verts[i].toVector2D();

    // now move verts half cube width across so cube is centered on origin
    for (int i = 0; i &lt; 4; ++i)
        verts[i] -= QVector3D(size / 2.0f, size / 2.0f, -depth);

    // add the front face
    g-&gt;addQuad(verts[bl], verts[br], verts[tr], verts[tl], tex);

    count = g-&gt;count() - start;
}

void TileBuilder::initialize(Tile *tile) const
{
    tile-&gt;start = start;
    tile-&gt;count = count;
    tile-&gt;geom = geom;
    qSetColor(tile-&gt;faceColor, color);
}

Tile *TileBuilder::newTile(const QVector3D &amp;loc) const
{
    Tile *tile = new Tile(loc);
    initialize(tile);
    return tile;
}

Cube::Cube(const QVector3D &amp;loc)
    : Tile(loc)
    , rot(0.0f)
    , r(0)
    , animGroup(0)
{
}

Cube::~Cube()
{
}

void Cube::setAltitude(qreal a)
{
    if (location.y() != a)
    {
        location.setY(a);
        emit changed();
    }
}

void Cube::setRange(qreal r)
{
    if (location.x() != r)
    {
        location.setX(r);
        emit changed();
    }
}

void Cube::setRotation(qreal r)
{
    if (r != rot)
    {
        orientation = QQuaternion::fromAxisAndAngle(QVector3D(1.0f, 1.0f, 1.0f), r);
        emit changed();
    }
}

void Cube::removeBounce()
{
    delete animGroup;
    animGroup = 0;
    delete r;
    r = 0;
}

void Cube::startAnimation()
{
    if (r)
    {
        r-&gt;start();
        r-&gt;setCurrentTime(startx);
    }
    if (animGroup)
        animGroup-&gt;start();
    if (rtn)
        rtn-&gt;start();
}

void Cube::setAnimationPaused(bool paused)
{
    if (paused)
    {
        if (r)
            r-&gt;pause();
        if (animGroup)
            animGroup-&gt;pause();
        if (rtn)
            rtn-&gt;pause();
    }
    else
    {
        if (r)
            r-&gt;resume();
        if (animGroup)
            animGroup-&gt;resume();
        if (rtn)
            rtn-&gt;resume();
    }
}

CubeBuilder::CubeBuilder(Geometry *g, qreal depth, qreal size)
    : TileBuilder(g, depth)
    , ix(0)
{
    for (int i = 0; i &lt; 4; ++i)
        verts[i].setZ(size / 2.0f);
    // back face - &quot;extrude&quot; verts down
    QVector&lt;QVector3D&gt; back(verts);
    for (int i = 0; i &lt; 4; ++i)
        back[i].setZ(-size / 2.0f);

    // add the back face
    g-&gt;addQuad(back[br], back[bl], back[tl], back[tr], tex);

    // add the sides
    g-&gt;addQuad(back[bl], back[br], verts[br], verts[bl], tex);
    g-&gt;addQuad(back[br], back[tr], verts[tr], verts[br], tex);
    g-&gt;addQuad(back[tr], back[tl], verts[tl], verts[tr], tex);
    g-&gt;addQuad(back[tl], back[bl], verts[bl], verts[tl], tex);

    count = g-&gt;count() - start;
}

Cube *CubeBuilder::newCube(const QVector3D &amp;loc) const
{
    Cube *c = new Cube(loc);
    initialize(c);
    qreal d = 4000.0f;
    qreal d3 = d / 3.0f;
    // Animate movement from left to right
    c-&gt;r = new QPropertyAnimation(c, &quot;range&quot;);
    c-&gt;r-&gt;setStartValue(-1.3f);
    c-&gt;r-&gt;setEndValue(1.3f);
    c-&gt;startx = ix * d3 * 3.0f;
    c-&gt;r-&gt;setDuration(d * 4.0f);
    c-&gt;r-&gt;setLoopCount(-1);
    c-&gt;r-&gt;setEasingCurve(QEasingCurve(QEasingCurve::CosineCurve));

    c-&gt;animGroup = new QSequentialAnimationGroup(c);

    // Animate movement from bottom to top
    QPropertyAnimation *a_up = new QPropertyAnimation(c, &quot;altitude&quot;, c-&gt;animGroup);
    a_up-&gt;setEndValue(loc.y());
    a_up-&gt;setStartValue(loc.y() + amplitudes[ix]);
    a_up-&gt;setDuration(d / speeds[ix]);
    a_up-&gt;setLoopCount(1);
    a_up-&gt;setEasingCurve(QEasingCurve(QEasingCurve::InQuad));

    // Animate movement from top to bottom
    QPropertyAnimation *a_down = new QPropertyAnimation(c, &quot;altitude&quot;, c-&gt;animGroup);
    a_down-&gt;setEndValue(loc.y() + amplitudes[ix]);
    a_down-&gt;setStartValue(loc.y());
    a_down-&gt;setDuration(d / speeds[ix]);
    a_down-&gt;setLoopCount(1);
    a_down-&gt;setEasingCurve(QEasingCurve(QEasingCurve::OutQuad));

    c-&gt;animGroup-&gt;addAnimation(a_up);
    c-&gt;animGroup-&gt;addAnimation(a_down);
    c-&gt;animGroup-&gt;setLoopCount(-1);

    // Animate rotation
    c-&gt;rtn = new QPropertyAnimation(c, &quot;rotation&quot;);
    c-&gt;rtn-&gt;setStartValue(c-&gt;rot);
    c-&gt;rtn-&gt;setEndValue(359.0f);
    c-&gt;rtn-&gt;setDuration(d * 2.0f);
    c-&gt;rtn-&gt;setLoopCount(-1);
    c-&gt;rtn-&gt;setDuration(d / 2);
    ix = (ix + 1) % 3;
    return c;
}

</db:programlisting>
</db:article>
