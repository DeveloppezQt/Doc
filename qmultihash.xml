<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QMultiHash Class</db:title>
<db:subtitle>template &lt;typename Key, typename T&gt; class QMultiHash</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> class provides a multi-valued hash table.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
<db:para>This class is <db:emphasis>equality-comparable</db:emphasis>.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QMultiHash</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QMultiHash is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qmultihash.xml">QMultiHash</db:link>&lt;Key, T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It provides a hash table that allows multiple values for the same key.</db:para>
<db:para><db:link xlink:href="qmultihash.xml">QMultiHash</db:link> mostly mirrors <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s API. For example, you can use isEmpty() to test whether the hash is empty, and you can traverse a <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> using <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s iterator classes (for example, <db:link xlink:href="qhashiterator.xml">QHashIterator</db:link>). But opposed to <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>, it provides an <db:link xlink:href="qmultihash.xml#insert">insert</db:link>() function that allows the insertion of multiple items with the same key. The <db:link xlink:href="qmultihash.xml#replace">replace</db:link>() function corresponds to <db:link xlink:href="qhash.xml#insert">QHash::insert</db:link>(). It also provides convenient operator+() and operator+=().</db:para>
<db:para>Unlike <db:link xlink:href="qmultimap.xml">QMultiMap</db:link>, <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> does not provide ordering of the inserted items. The only guarantee is that items that share the same key will appear consecutively, from the most recently to the least recently inserted value.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QMultiHash&lt;QString, int&gt; hash1, hash2, hash3;

hash1.insert(&quot;plenty&quot;, 100);
hash1.insert(&quot;plenty&quot;, 2000);
// hash1.size() == 2

hash2.insert(&quot;plenty&quot;, 5000);
// hash2.size() == 1

hash3 = hash1 + hash2;
// hash3.size() == 3
</db:programlisting>
<db:para>Unlike <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>, <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> provides no operator[]. Use <db:link xlink:href="qmultihash.xml#value">value</db:link>() or <db:link xlink:href="qmultihash.xml#replace">replace</db:link>() if you want to access the most recently inserted item with a certain key.</db:para>
<db:para>If you want to retrieve all the values for a single key, you can use values(const Key &amp;key), which returns a <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;:</db:para>
<db:programlisting language="cpp">QList&lt;int&gt; values = hash.values(&quot;plenty&quot;);
for (auto i : std::as_const(values))
    cout &lt;&lt; i &lt;&lt; endl;
</db:programlisting>
<db:para>The items that share the same key are available from most recently to least recently inserted.</db:para>
<db:para>A more efficient approach is to call <db:link xlink:href="qmultihash.xml#find">find</db:link>() to get the STL-style iterator for the first item with a key and iterate from there:</db:para>
<db:programlisting language="cpp">auto i = hash.constFind(&quot;plenty&quot;);
while (i != hash.cend() &amp;&amp; i.key() == &quot;plenty&quot;) {
    cout &lt;&lt; i.value() &lt;&lt; endl;
    ++i;
}
</db:programlisting>
<db:para><db:link xlink:href="qmultihash.xml">QMultiHash</db:link>'s key and value data types must be <db:link xlink:href="containers.xml#assignable-data-types">assignable data types</db:link>. You cannot, for example, store a QWidget as a value; instead, store a QWidget *. In addition, <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>'s key type must provide operator==(), and there must also be a <db:link xlink:href="qmultihash.xml#qHash-23">qHash</db:link>() function in the type's namespace that returns a hash value for an argument of the key's type. See the <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> documentation for details.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link></db:member>
<db:member><db:link xlink:href="qhashiterator.xml">QHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablehashiterator.xml">QMutableHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmultimap.xml">QMultiMap</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="const_key_value_iterator-typedef">
<db:title>QMultiHash::const_key_value_iterator</db:title>
<db:para>The QMultiHash::const_key_value_iterator typedef provides an STL-style const iterator for <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>.</db:para>
<db:para>QMultiHash::const_key_value_iterator is essentially the same as <db:link xlink:href="qmultihash-const-iterator.xml">QMultiHash::const_iterator</db:link> with the difference that operator*() returns a key/value pair instead of a value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="key_value_iterator-typedef">
<db:title>QMultiHash::key_value_iterator</db:title>
<db:para>The QMultiHash::key_value_iterator typedef provides an STL-style iterator for <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>.</db:para>
<db:para>QMultiHash::key_value_iterator is essentially the same as <db:link xlink:href="qmultihash-iterator.xml">QMultiHash::iterator</db:link> with the difference that operator*() returns a key/value pair instead of a value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="emplace">
<db:title>QMultiHash&lt;Key, T&gt;::iterator QMultiHash::emplace(Key &amp;&amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="emplace-1">QMultiHash&lt;Key, T&gt;::iterator QMultiHash::emplace(const Key &amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:para>Inserts a new element into the container. This new element is constructed in-place using <db:code role="parameter">args</db:code> as the arguments for its construction.</db:para>
<db:para>If there is already an item with the same key in the hash, this function will simply create a new one. (This behavior is different from <db:link xlink:href="qmultihash.xml#replace">replace</db:link>(), which overwrites the value of an existing item.)</db:para>
<db:para>Returns an iterator pointing to the new element.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="emplaceReplace">
<db:title>QMultiHash&lt;Key, T&gt;::iterator QMultiHash::emplaceReplace(Key &amp;&amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="emplaceReplace-1">QMultiHash&lt;Key, T&gt;::iterator QMultiHash::emplaceReplace(const Key &amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:para>Inserts a new element into the container. This new element is constructed in-place using <db:code role="parameter">args</db:code> as the arguments for its construction.</db:para>
<db:para>If there is already an item with the same key in the hash, that item's value is replaced with a value constructed from <db:code role="parameter">args</db:code>.</db:para>
<db:para>Returns an iterator pointing to the new element.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#replace">replace</db:link></db:member>
<db:member><db:link xlink:href="qmultihash.xml#emplace">emplace</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value">
<db:title>[noexcept] T QMultiHash::value(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:bridgehead renderas="sect2" xml:id="value-1">[noexcept] T QMultiHash::value(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>defaultValue</db:emphasis>) const</db:bridgehead>
<db:para>Returns the value associated with the <db:code role="parameter">key</db:code>.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function returns <db:code role="parameter">defaultValue</db:code>, or a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> if this parameter has not been supplied.</db:para>
<db:para>If there are multiple items for the <db:code role="parameter">key</db:code> in the hash, the value of the most recently inserted one is returned.</db:para>
</db:section>
<db:section xml:id="key">
<db:title>[noexcept] Key QMultiHash::key(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:bridgehead renderas="sect2" xml:id="key-1">[noexcept] Key QMultiHash::key(const T &amp;<db:emphasis>value</db:emphasis>, const Key &amp;<db:emphasis>defaultKey</db:emphasis>) const</db:bridgehead>
<db:para>Returns the first key mapped to <db:code role="parameter">value</db:code>. If the hash contains no item mapped to <db:code role="parameter">value</db:code>, returns <db:code role="parameter">defaultKey</db:code>, or a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed key</db:link> if this parameter has not been supplied.</db:para>
<db:para>This function can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>'s internal data structure is optimized for fast lookup by key, not by value.</db:para>
</db:section>
<db:section xml:id="asKeyValueRange-1">
<db:title>[since 6.4] auto QMultiHash::asKeyValueRange() &amp;</db:title>
<db:bridgehead renderas="sect2" xml:id="asKeyValueRange">[since 6.4] auto QMultiHash::asKeyValueRange() &amp;&amp;</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="asKeyValueRange-3">[since 6.4] auto QMultiHash::asKeyValueRange() const &amp;</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="asKeyValueRange-2">[since 6.4] auto QMultiHash::asKeyValueRange() const &amp;&amp;</db:bridgehead>
<db:para>Returns a range object that allows iteration over this hash as key/value pairs. For instance, this range object can be used in a range-based for loop, in combination with a structured binding declaration:</db:para>
<db:programlisting language="cpp">QMultiHash&lt;QString, int&gt; hash;
hash.insert(&quot;January&quot;, 1);
hash.insert(&quot;February&quot;, 2);
// ...
hash.insert(&quot;December&quot;, 12);

for (auto [key, value] : hash.asKeyValueRange()) {
    cout &lt;&lt; qPrintable(key) &lt;&lt; &quot;: &quot; &lt;&lt; value &lt;&lt; endl;
    --value; // convert to JS month indexing
}
</db:programlisting>
<db:para>Note that both the key and the value obtained this way are references to the ones in the hash. Specifically, mutating the value will modify the hash itself.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QMultiHash">
<db:title>[noexcept] QMultiHash::QMultiHash()</db:title>
<db:para>Constructs an empty hash.</db:para>
</db:section>
<db:section xml:id="QMultiHash-1">
<db:title>[explicit] QMultiHash::QMultiHash(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code> (which can be a <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> or a <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>).</db:para>
</db:section>
<db:section xml:id="QMultiHash-2">
<db:title>QMultiHash::QMultiHash(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; <db:emphasis>list</db:emphasis>)</db:title>
<db:para>Constructs a multi-hash with a copy of each of the elements in the initializer list <db:code role="parameter">list</db:code>.</db:para>
</db:section>
<db:section xml:id="QMultiHash-3">
<db:title>QMultiHash::QMultiHash(InputIterator <db:emphasis>begin</db:emphasis>, InputIterator <db:emphasis>end</db:emphasis>)</db:title>
<db:para>Constructs a multi-hash with a copy of each of the elements in the iterator range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>). Either the elements iterated by the range must be objects with first and second data members (like std::pair), convertible to Key and to T respectively; or the iterators must have key() and value() member functions, returning a key convertible to Key and a value convertible to T respectively.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QMultiHash&lt;Key, T&gt;::iterator QMultiHash::begin()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::const_iterator QMultiHash::begin() const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
</db:section>
<db:section xml:id="cbegin">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::const_iterator QMultiHash::cbegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::const_iterator QMultiHash::cend() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>[noexcept(...)] void QMultiHash::clear()</db:title>
<db:para>Removes all items from the hash and frees up all memory used by it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::const_iterator QMultiHash::constBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::const_iterator QMultiHash::constEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::const_iterator QMultiHash::constFind(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:para>Returns an iterator pointing to the item with the <db:code role="parameter">key</db:code> and the <db:code role="parameter">value</db:code> in the hash.</db:para>
<db:para>If the hash contains no such item, the function returns <db:link xlink:href="qmultihash.xml#constEnd">constEnd</db:link>().</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
</db:section>
<db:section xml:id="constKeyValueBegin">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::const_key_value_iterator QMultiHash::constKeyValueBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constKeyValueEnd">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::const_key_value_iterator QMultiHash::constKeyValueEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#constKeyValueBegin">constKeyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>[noexcept] bool QMultiHash::contains(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:para>Returns true if the hash contains an item with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>contains()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>[noexcept] qsizetype QMultiHash::count(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:para>Returns the number of items with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>count()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::iterator QMultiHash::end()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::const_iterator QMultiHash::end() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="equal_range">
<db:title>std::pair&lt;QMultiHash&lt;Key, T&gt;::iterator, QMultiHash&lt;Key, T&gt;::iterator&gt; QMultiHash::equal_range(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Returns a pair of iterators delimiting the range of values [first, second), that are stored under <db:code role="parameter">key</db:code>. If the range is empty then both iterators will be equal to <db:link xlink:href="qmultihash.xml#end">end</db:link>().</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
</db:section>
<db:section xml:id="equal_range-3">
<db:title>[noexcept] std::pair&lt;QMultiHash&lt;Key, T&gt;::const_iterator, QMultiHash&lt;Key, T&gt;::const_iterator&gt; QMultiHash::equal_range(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
</db:section>
<db:section xml:id="find">
<db:title>QMultiHash&lt;Key, T&gt;::iterator QMultiHash::find(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Returns an iterator pointing to the item with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>. If the hash contains no such item, the function returns <db:link xlink:href="qmultihash.xml#end">end</db:link>().</db:para>
<db:para>If the hash contains multiple items with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>, the iterator returned points to the most recently inserted item.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
</db:section>
<db:section xml:id="find-7">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::const_iterator QMultiHash::find(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
</db:section>
<db:section xml:id="insert">
<db:title>QMultiHash&lt;Key, T&gt;::iterator QMultiHash::insert(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there is already an item with the same key in the hash, this function will simply create a new one. (This behavior is different from <db:link xlink:href="qmultihash.xml#replace">replace</db:link>(), which overwrites the value of an existing item.)</db:para>
<db:para>Returns an iterator pointing to the new element.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#replace">replace</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyBegin">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::key_iterator QMultiHash::keyBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first key in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyEnd">keyEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyEnd">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::key_iterator QMultiHash::keyEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last key in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyBegin">keyBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueBegin">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::key_value_iterator QMultiHash::keyValueBegin()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyValueEnd">keyValueEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueBegin-1">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::const_key_value_iterator QMultiHash::keyValueBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyValueEnd">keyValueEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueEnd">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::key_value_iterator QMultiHash::keyValueEnd()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueEnd-1">
<db:title>[noexcept] QMultiHash&lt;Key, T&gt;::const_key_value_iterator QMultiHash::keyValueEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keys">
<db:title>QList&lt;Key&gt; QMultiHash::keys() const</db:title>
<db:para>Returns a list containing all the keys in the hash, in an arbitrary order. Keys that occur multiple times in the hash also occur multiple times in the list.</db:para>
<db:para>The order is guaranteed to be the same as that used by <db:link xlink:href="qmultihash.xml#values">values</db:link>().</db:para>
<db:para>This function creates a new list, in <db:link xlink:href="containers.xml#linear-time">linear time</db:link>. The time and memory use that entails can be avoided by iterating from <db:link xlink:href="qmultihash.xml#keyBegin">keyBegin</db:link>() to <db:link xlink:href="qmultihash.xml#keyEnd">keyEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#values">values</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#key">key</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remove">
<db:title>qsizetype QMultiHash::remove(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes all the items that have the <db:code role="parameter">key</db:code> from the hash. Returns the number of items removed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>remove()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remove-1">
<db:title>qsizetype QMultiHash::remove(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Removes all the items that have the <db:code role="parameter">key</db:code> and the value <db:code role="parameter">value</db:code> from the hash. Returns the number of items removed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeIf">
<db:title>[since 6.1] qsizetype QMultiHash::removeIf(Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the multi hash.</db:para>
<db:para>The function supports predicates which take either an argument of type QMultiHash&lt;Key, T&gt;::iterator, or an argument of type std::pair&lt;const Key &amp;, T &amp;&gt;.</db:para>
<db:para>Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#clear">clear</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#take">take</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="replace">
<db:title>QMultiHash&lt;Key, T&gt;::iterator QMultiHash::replace(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there is already an item with the <db:code role="parameter">key</db:code>, that item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there are multiple items with the <db:code role="parameter">key</db:code>, the most recently inserted item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
<db:para>Returns an iterator pointing to the new/updated element.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>[noexcept] void QMultiHash::swap(QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps this multi-hash with <db:code role="parameter">other</db:code>. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="take">
<db:title>T QMultiHash::take(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes the item with the <db:code role="parameter">key</db:code> from the hash and returns the value associated with it.</db:para>
<db:para>If the item does not exist in the hash, the function simply returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If there are multiple items for <db:code role="parameter">key</db:code> in the hash, only the most recently inserted one is removed.</db:para>
<db:para>If you don't use the return value, <db:link xlink:href="qmultihash.xml#remove">remove</db:link>() is more efficient.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="uniqueKeys">
<db:title>QList&lt;Key&gt; QMultiHash::uniqueKeys() const</db:title>
<db:para>Returns a list containing all the keys in the map. Keys that occur multiple times in the map occur only once in the returned list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keys">keys</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#values">values</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unite">
<db:title>[since 6.0] QMultiHash&lt;Key, T&gt; &amp;QMultiHash::unite(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Inserts all the items in the <db:code role="parameter">other</db:code> hash into this hash and returns a reference to this hash.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unite-1">
<db:title>QMultiHash&lt;Key, T&gt; &amp;QMultiHash::unite(const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Inserts all the items in the <db:code role="parameter">other</db:code> hash into this hash and returns a reference to this hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="values">
<db:title>QList&lt;T&gt; QMultiHash::values() const</db:title>
<db:para>Returns a list containing all the values in the hash, in an arbitrary order. If a key is associated with multiple values, all of its values will be in the list, and not just the most recently inserted one.</db:para>
<db:para>The order is guaranteed to be the same as that used by <db:link xlink:href="qmultihash.xml#keys">keys</db:link>().</db:para>
<db:para>This function creates a new list, in <db:link xlink:href="containers.xml#linear-time">linear time</db:link>. The time and memory use that entails can be avoided by iterating from <db:link xlink:href="qmultihash.xml#keyValueBegin">keyValueBegin</db:link>() to <db:link xlink:href="qmultihash.xml#keyValueEnd">keyValueEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keys">keys</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="values-2">
<db:title>QList&lt;T&gt; QMultiHash::values(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a list of all the values associated with the <db:code role="parameter">key</db:code>, from the most recently inserted to the least recently inserted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#count">count</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b">
<db:title>QMultiHash&lt;Key, T&gt; QMultiHash::operator+(const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns a hash that contains all the items in this hash in addition to all the items in <db:code role="parameter">other</db:code>. If a key is common to both hashes, the resulting hash will contain the key multiple times.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq">
<db:title>QMultiHash&lt;Key, T&gt; &amp;QMultiHash::operator+=(const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Inserts all the items in the <db:code role="parameter">other</db:code> hash into this hash and returns a reference to this hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#unite">unite</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>T &amp;QMultiHash::operator[](const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Returns the value associated with the <db:code role="parameter">key</db:code> as a modifiable reference.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function inserts a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> into the hash with the <db:code role="parameter">key</db:code>, and returns a reference to it.</db:para>
<db:para>If the hash contains multiple items with the <db:code role="parameter">key</db:code>, this function returns a reference to the most recently inserted value.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="erase_if-4">
<db:title>[since 6.1] qsizetype erase_if(QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>, Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the multi hash <db:code role="parameter">hash</db:code>.</db:para>
<db:para>The function supports predicates which take either an argument of type QMultiHash&lt;Key, T&gt;::iterator, or an argument of type std::pair&lt;const Key &amp;, T &amp;&gt;.</db:para>
<db:para>Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
</db:section>
<db:section xml:id="qHash-23">
<db:title>[noexcept(...)] size_t qHash(const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Types Key and T must be supported by qHash().</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>[noexcept] bool operator!=(const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns true if <db:code role="parameter">lhs</db:code> multihash is not equal to the <db:code role="parameter">rhs</db:code> multihash; otherwise returns false.</db:para>
<db:para>Two multihashes are considered equal if they contain the same (key, value) pairs.</db:para>
<db:para>This function requires the value type to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt-15">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>)</db:title>
<db:para>Writes the hash <db:code role="parameter">hash</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:para>This function requires the key and value types to implement operator&lt;&lt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>[noexcept] bool operator==(const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns true if <db:code role="parameter">lhs</db:code> multihash equals to the <db:code role="parameter">rhs</db:code> multihash; otherwise returns false.</db:para>
<db:para>Two multihashes are considered equal if they contain the same (key, value) pairs.</db:para>
<db:para>This function requires the value type to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt-14">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>)</db:title>
<db:para>Reads a hash from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">hash</db:code>.</db:para>
<db:para>This function requires the key and value types to implement operator&gt;&gt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
