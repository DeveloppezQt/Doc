<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QMultiHash Class</db:title>
<db:subtitle>template &lt;typename Key, typename T&gt; class QMultiHash</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.3.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> class is a convenience <db:link xlink:href="qhash.xml#qhash">QHash</db:link> subclass that provides multi-valued hashes.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QMultiHash</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QMultiHash is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qmultihash.xml">QMultiHash</db:link>&lt;Key, T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It inherits <db:link xlink:href="qhash.xml#qhash">QHash</db:link> and extends it with a few convenience functions that make it more suitable than <db:link xlink:href="qhash.xml#qhash">QHash</db:link> for storing multi-valued hashes. A multi-valued hash is a hash that allows multiple values with the same key.</db:para>
<db:para><db:link xlink:href="qmultihash.xml">QMultiHash</db:link> mostly mirrors <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s API. For example, you can use isEmpty() to test whether the hash is empty, and you can traverse a <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> using <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s iterator classes (for example, <db:link xlink:href="qhashiterator.xml">QHashIterator</db:link>). But opposed to <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, it provides an <db:link xlink:href="qmultihash.xml#insert">insert</db:link>() function that allows the insertion of multiple items with the same key. The <db:link xlink:href="qmultihash.xml#replace">replace</db:link>() function corresponds to <db:link xlink:href="qhash.xml#insert">QHash::insert</db:link>(). It also provides convenient operator+() and operator+=().</db:para>
<db:para>Unlike <db:link xlink:href="qmultimap.xml">QMultiMap</db:link>, <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> does not provide and ordering of the inserted items. The only guarantee is that items that share the same key will appear consecutively, from the most recently to the least recently inserted value.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QMultiHash&amp;lt;QString, int&amp;gt; hash1, hash2, hash3;

hash1.insert(&quot;plenty&quot;, 100);
hash1.insert(&quot;plenty&quot;, 2000);
// hash1.size() == 2

hash2.insert(&quot;plenty&quot;, 5000);
// hash2.size() == 1

hash3 = hash1 + hash2;
// hash3.size() == 3
</db:programlisting>
<db:para>Unlike <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> provides no operator[]. Use <db:link xlink:href="qmultihash.xml#value">value</db:link>() or <db:link xlink:href="qmultihash.xml#replace">replace</db:link>() if you want to access the most recently inserted item with a certain key.</db:para>
<db:para>If you want to retrieve all the values for a single key, you can use values(const Key &amp;key), which returns a <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; values = hash.values(&quot;plenty&quot;);
for (int i = 0; i &amp;lt; values.size(); ++i)
    cout &amp;lt;&amp;lt; values.at(i) &amp;lt;&amp;lt; Qt::endl;
</db:programlisting>
<db:para>The items that share the same key are available from most recently to least recently inserted.</db:para>
<db:para>A more efficient approach is to call <db:link xlink:href="qmultihash.xml#find-2">find</db:link>() to get the STL-style iterator for the first item with a key and iterate from there:</db:para>
<db:programlisting language="cpp">QMultiHash&amp;lt;QString, int&amp;gt;::iterator i = hash.find(&quot;plenty&quot;);
while (i != hash.end() &amp;amp;&amp;amp; i.key() == &quot;plenty&quot;) {
    cout &amp;lt;&amp;lt; i.value() &amp;lt;&amp;lt; Qt::endl;
    ++i;
}
</db:programlisting>
<db:para><db:link xlink:href="qmultihash.xml">QMultiHash</db:link>'s key and value data types must be <db:link xlink:href="containers.xml#assignable-data-types">assignable data types</db:link>. You cannot, for example, store a QWidget as a value; instead, store a QWidget *. In addition, <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>'s key type must provide operator==(), and there must also be a <db:link xlink:href="qmultihash.xml#qHash">qHash</db:link>() function in the type's namespace that returns a hash value for an argument of the key's type. See the <db:link xlink:href="qhash.xml#qhash">QHash</db:link> documentation for details.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qhash">QHash</db:link></db:member>
<db:member><db:link xlink:href="qhashiterator.xml">QHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablehashiterator.xml">QMutableHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmultimap.xml">QMultiMap</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="const_key_value_iterator-typedef">
<db:title>[since 5.10] QMultiHash::const_key_value_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>const_key_value_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="module">QtCore</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The <db:link xlink:href="qmap.xml#const_key_value_iterator-typedef">QMap::const_key_value_iterator</db:link> typedef provides an STL-style const iterator for <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> and <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>.</db:para>
<db:para>QMultiHash::const_key_value_iterator is essentially the same as <db:link xlink:href="qmultihash-const-iterator.xml">QMultiHash::const_iterator</db:link> with the difference that operator*() returns a key/value pair instead of a value.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="key_value_iterator-typedef">
<db:title>[since 5.10] QMultiHash::key_value_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>key_value_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="module">QtCore</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The <db:link xlink:href="qmap.xml#key_value_iterator-typedef">QMap::key_value_iterator</db:link> typedef provides an STL-style iterator for <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> and <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>.</db:para>
<db:para>QMultiHash::key_value_iterator is essentially the same as <db:link xlink:href="qmultihash-iterator.xml">QMultiHash::iterator</db:link> with the difference that operator*() returns a key/value pair instead of a value.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="emplace-1">
<db:title>QMultiHash::iterator QMultiHash::emplace(Key &amp;&amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="emplace">QMultiHash::iterator QMultiHash::emplace(const Key &amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:para>Inserts a new element into the container. This new element is constructed in-place using <db:code role="parameter">args</db:code> as the arguments for its construction.</db:para>
<db:para>If there is already an item with the same key in the hash, this function will simply create a new one. (This behavior is different from <db:link xlink:href="qmultihash.xml#replace">replace</db:link>(), which overwrites the value of an existing item.)</db:para>
<db:para>Returns an iterator pointing to the new element.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="emplaceReplace-1">
<db:title>QMultiHash::iterator QMultiHash::emplaceReplace(Key &amp;&amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="emplaceReplace">QMultiHash::iterator QMultiHash::emplaceReplace(const Key &amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:para>Inserts a new element into the container. This new element is constructed in-place using <db:code role="parameter">args</db:code> as the arguments for its construction.</db:para>
<db:para>If there is already an item with the same key in the hash, that item's value is replaced with a value constructed from <db:code role="parameter">args</db:code>.</db:para>
<db:para>Returns an iterator pointing to the new element.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#replace">replace</db:link></db:member>
<db:member><db:link xlink:href="qmultihash.xml#emplace">emplace</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value">
<db:title>T QMultiHash::value(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:bridgehead renderas="sect2" xml:id="value-1">T QMultiHash::value(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>defaultValue</db:emphasis>) const</db:bridgehead>
<db:para>Returns the value associated with the <db:code role="parameter">key</db:code>.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function returns <db:code role="parameter">defaultValue</db:code>, or a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> if this parameter has not been supplied.</db:para>
<db:para>If there are multiple items for the <db:code role="parameter">key</db:code> in the hash, the value of the most recently inserted one is returned.</db:para>
</db:section>
<db:section xml:id="key">
<db:title>Key QMultiHash::key(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:bridgehead renderas="sect2" xml:id="key-1">Key QMultiHash::key(const T &amp;<db:emphasis>value</db:emphasis>, const Key &amp;<db:emphasis>defaultKey</db:emphasis>) const</db:bridgehead>
<db:para>Returns the first key mapped to <db:code role="parameter">value</db:code>. If the hash contains no item mapped to <db:code role="parameter">value</db:code>, returns <db:code role="parameter">defaultKey</db:code>, or a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed key</db:link> if this parameter has not been supplied.</db:para>
<db:para>This function can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>'s internal data structure is optimized for fast lookup by key, not by value.</db:para>
</db:section>
<db:section xml:id="QMultiHash">
<db:title>QMultiHash::QMultiHash()</db:title>
<db:constructorsynopsis>
<db:methodname>QMultiHash</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty hash.</db:para>
</db:section>
<db:section xml:id="QMultiHash-1">
<db:title>[since 5.1] QMultiHash::QMultiHash(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; <db:emphasis>list</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QMultiHash</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; list)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a multi-hash with a copy of each of the elements in the initializer list <db:code role="parameter">list</db:code>.</db:para>
<db:para>This function is only available if the program is being compiled in C++11 mode.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
</db:section>
<db:section xml:id="QMultiHash-2">
<db:title>[since 5.14] QMultiHash::QMultiHash(InputIterator <db:emphasis>begin</db:emphasis>, InputIterator <db:emphasis>end</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QMultiHash</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash(InputIterator begin, InputIterator end)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a multi-hash with a copy of each of the elements in the iterator range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>). Either the elements iterated by the range must be objects with first and second data members (like QPair, std::pair, etc.) convertible to Key and to T respectively; or the iterators must have key() and value() member functions, returning a key convertible to Key and a value convertible to T respectively.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
</db:section>
<db:section xml:id="QMultiHash-5">
<db:title>[explicit] QMultiHash::QMultiHash(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QMultiHash</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash(const QHash&lt;Key, T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code> (which can be a <db:link xlink:href="qhash.xml#qhash">QHash</db:link> or a <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>).</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QMultiHash::iterator QMultiHash::begin()</db:title>
<db:methodsynopsis>
<db:type>QMultiHash::iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::iterator begin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>QMultiHash::const_iterator QMultiHash::begin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::const_iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::const_iterator begin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="cbegin">
<db:title>[since 5.0] QMultiHash::const_iterator QMultiHash::cbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::const_iterator</db:type>
<db:methodname>cbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::const_iterator cbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[since 5.0] QMultiHash::const_iterator QMultiHash::cend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::const_iterator</db:type>
<db:methodname>cend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::const_iterator cend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QMultiHash::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all items from the hash and frees up all memory used by it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>QMultiHash::const_iterator QMultiHash::constBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::const_iterator</db:type>
<db:methodname>constBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::const_iterator constBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QMultiHash::const_iterator QMultiHash::constEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::const_iterator</db:type>
<db:methodname>constEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::const_iterator constEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind-1">
<db:title>QMultiHash::const_iterator QMultiHash::constFind(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::const_iterator</db:type>
<db:methodname>constFind</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::const_iterator constFind(const Key &amp;key, const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an iterator pointing to the item with the <db:code role="parameter">key</db:code> and the <db:code role="parameter">value</db:code> in the hash.</db:para>
<db:para>If the hash contains no such item, the function returns <db:link xlink:href="qmultihash.xml#constEnd">constEnd</db:link>().</db:para>
</db:section>
<db:section xml:id="constKeyValueBegin">
<db:title>[since 5.10] QMultiHash::const_key_value_iterator QMultiHash::constKeyValueBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::const_key_value_iterator</db:type>
<db:methodname>constKeyValueBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::const_key_value_iterator constKeyValueBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constKeyValueEnd">
<db:title>[since 5.10] QMultiHash::const_key_value_iterator QMultiHash::constKeyValueEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::const_key_value_iterator</db:type>
<db:methodname>constKeyValueEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::const_key_value_iterator constKeyValueEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#constKeyValueBegin">constKeyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains-1">
<db:title>bool QMultiHash::contains(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(const Key &amp;key, const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the hash contains an item with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>contains()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count-2">
<db:title>qsizetype QMultiHash::count(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>count</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype count(const Key &amp;key, const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of items with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>count()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end">
<db:title>QMultiHash::iterator QMultiHash::end()</db:title>
<db:methodsynopsis>
<db:type>QMultiHash::iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::iterator end()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>QMultiHash::const_iterator QMultiHash::end() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::const_iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::const_iterator end() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="equal_range">
<db:title>[since 5.7] QPair&lt;QMultiHash::iterator, QMultiHash::iterator&gt; QMultiHash::equal_range(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QPair&lt;QMultiHash::iterator, QMultiHash::iterator&gt;</db:type>
<db:methodname>equal_range</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPair&lt;QMultiHash::iterator, QMultiHash::iterator&gt; equal_range(const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pair of iterators delimiting the range of values [first, second), that are stored under <db:code role="parameter">key</db:code>. If the range is empty then both iterators will be equal to <db:link xlink:href="qmultihash.xml#end">end</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="equal_range-1">
<db:title>[since 5.7] QPair&lt;QMultiHash::const_iterator, QMultiHash::const_iterator&gt; QMultiHash::equal_range(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPair&lt;QMultiHash::const_iterator, QMultiHash::const_iterator&gt;</db:type>
<db:methodname>equal_range</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QPair&lt;QMultiHash::const_iterator, QMultiHash::const_iterator&gt; equal_range(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="find-2">
<db:title>QMultiHash::iterator QMultiHash::find(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QMultiHash::iterator</db:type>
<db:methodname>find</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::iterator find(const Key &amp;key, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an iterator pointing to the item with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>. If the hash contains no such item, the function returns <db:link xlink:href="qmultihash.xml#end">end</db:link>().</db:para>
<db:para>If the hash contains multiple items with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>, the iterator returned points to the most recently inserted item.</db:para>
</db:section>
<db:section xml:id="find-3">
<db:title>QMultiHash::const_iterator QMultiHash::find(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::const_iterator</db:type>
<db:methodname>find</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::const_iterator find(const Key &amp;key, const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="insert">
<db:title>QMultiHash::iterator QMultiHash::insert(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QMultiHash::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::iterator insert(const Key &amp;key, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there is already an item with the same key in the hash, this function will simply create a new one. (This behavior is different from <db:link xlink:href="qmultihash.xml#replace">replace</db:link>(), which overwrites the value of an existing item.)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#replace">replace</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyBegin">
<db:title>[since 5.6] QMultiHash::key_iterator QMultiHash::keyBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::key_iterator</db:type>
<db:methodname>keyBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::key_iterator keyBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first key in the hash.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyEnd">keyEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyEnd">
<db:title>[since 5.6] QMultiHash::key_iterator QMultiHash::keyEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::key_iterator</db:type>
<db:methodname>keyEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::key_iterator keyEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last key in the hash.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyBegin">keyBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueBegin">
<db:title>[since 5.10] QMultiHash::key_value_iterator QMultiHash::keyValueBegin()</db:title>
<db:methodsynopsis>
<db:type>QMultiHash::key_value_iterator</db:type>
<db:methodname>keyValueBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::key_value_iterator keyValueBegin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyValueEnd">keyValueEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueBegin-1">
<db:title>[since 5.10] QMultiHash::const_key_value_iterator QMultiHash::keyValueBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::const_key_value_iterator</db:type>
<db:methodname>keyValueBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::const_key_value_iterator keyValueBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyValueEnd">keyValueEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueEnd">
<db:title>[since 5.10] QMultiHash::key_value_iterator QMultiHash::keyValueEnd()</db:title>
<db:methodsynopsis>
<db:type>QMultiHash::key_value_iterator</db:type>
<db:methodname>keyValueEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::key_value_iterator keyValueEnd()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueEnd-1">
<db:title>[since 5.10] QMultiHash::const_key_value_iterator QMultiHash::keyValueEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash::const_key_value_iterator</db:type>
<db:methodname>keyValueEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::const_key_value_iterator keyValueEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keys">
<db:title>QList&lt;Key&gt; QMultiHash::keys() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;Key&gt;</db:type>
<db:methodname>keys</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;Key&gt; keys() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list containing all the keys in the hash, in an arbitrary order. Keys that occur multiple times in the hash also occur multiple times in the list.</db:para>
<db:para>The order is guaranteed to be the same as that used by <db:link xlink:href="qmultihash.xml#values">values</db:link>().</db:para>
<db:para>This function creates a new list, in <db:link xlink:href="containers.xml#linear-time">linear time</db:link>. The time and memory use that entails can be avoided by iterating from <db:link xlink:href="qmultihash.xml#keyBegin">keyBegin</db:link>() to <db:link xlink:href="qmultihash.xml#keyEnd">keyEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#values">values</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#key">key</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remove">
<db:title>qsizetype QMultiHash::remove(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype remove(const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all the items that have the <db:code role="parameter">key</db:code> from the hash. Returns the number of items removed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>remove()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remove-1">
<db:title>qsizetype QMultiHash::remove(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype remove(const Key &amp;key, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all the items that have the <db:code role="parameter">key</db:code> and the value <db:code role="parameter">value</db:code> from the hash. Returns the number of items removed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeIf">
<db:title>[since 6.1] qsizetype QMultiHash::removeIf(Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>removeIf</db:methodname>
<db:methodparam>
<db:type>Predicate</db:type>
<db:parameter>pred</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype removeIf(Predicate pred)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the multi hash.</db:para>
<db:para>The function supports predicates which take either an argument of type QMultiHash&lt;Key, T&gt;::iterator, or an argument of type std::pair&lt;const Key &amp;, T &amp;&gt;.</db:para>
<db:para>Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#clear">clear</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#take">take</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="replace">
<db:title>QMultiHash::iterator QMultiHash::replace(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QMultiHash::iterator</db:type>
<db:methodname>replace</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash::iterator replace(const Key &amp;key, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there is already an item with the <db:code role="parameter">key</db:code>, that item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there are multiple items with the <db:code role="parameter">key</db:code>, the most recently inserted item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QMultiHash::swap(QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QMultiHash&lt;Key, T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps hash <db:code role="parameter">other</db:code> with this hash. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="take">
<db:title>T QMultiHash::take(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>take</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T take(const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the item with the <db:code role="parameter">key</db:code> from the hash and returns the value associated with it.</db:para>
<db:para>If the item does not exist in the hash, the function simply returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If there are multiple items for <db:code role="parameter">key</db:code> in the hash, only the most recently inserted one is removed.</db:para>
<db:para>If you don't use the return value, <db:link xlink:href="qmultihash.xml#remove">remove</db:link>() is more efficient.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="uniqueKeys">
<db:title>[since 5.13] QList&lt;Key&gt; QMultiHash::uniqueKeys() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;Key&gt;</db:type>
<db:methodname>uniqueKeys</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;Key&gt; uniqueKeys() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list containing all the keys in the map. Keys that occur multiple times in the map occur only once in the returned list.</db:para>
<db:para>This function was introduced in Qt 5.13.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keys">keys</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#values">values</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unite">
<db:title>[since 5.13] QMultiHash&lt;Key, T&gt; &amp;QMultiHash::unite(const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:methodname>unite</db:methodname>
<db:methodparam>
<db:type>const QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash&lt;Key, T&gt; &amp; unite(const QMultiHash&lt;Key, T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts all the items in the <db:code role="parameter">other</db:code> hash into this hash and returns a reference to this hash.</db:para>
<db:para>This function was introduced in Qt 5.13.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unite-1">
<db:title>[since 6.0] QMultiHash&lt;Key, T&gt; &amp;QMultiHash::unite(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:methodname>unite</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash&lt;Key, T&gt; &amp; unite(const QHash&lt;Key, T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts all the items in the <db:code role="parameter">other</db:code> hash into this hash and returns a reference to this hash.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="values">
<db:title>QList&lt;T&gt; QMultiHash::values() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>values</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; values() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list containing all the values in the hash, in an arbitrary order. If a key is associated with multiple values, all of its values will be in the list, and not just the most recently inserted one.</db:para>
<db:para>The order is guaranteed to be the same as that used by <db:link xlink:href="qmultihash.xml#keys">keys</db:link>().</db:para>
<db:para>This function creates a new list, in <db:link xlink:href="containers.xml#linear-time">linear time</db:link>. The time and memory use that entails can be avoided by iterating from <db:link xlink:href="qmultihash.xml#keyValueBegin">keyValueBegin</db:link>() to <db:link xlink:href="qmultihash.xml#keyValueEnd">keyValueEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#keys">keys</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="values-1">
<db:title>QList&lt;T&gt; QMultiHash::values(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>values</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; values(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a list of all the values associated with the <db:code role="parameter">key</db:code>, from the most recently inserted to the least recently inserted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#count-2">count</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b">
<db:title>QMultiHash&lt;Key, T&gt; QMultiHash::operator+(const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash&lt;Key, T&gt;</db:type>
<db:methodname>operator+</db:methodname>
<db:methodparam>
<db:type>const QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash&lt;Key, T&gt; operator+(const QMultiHash&lt;Key, T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a hash that contains all the items in this hash in addition to all the items in <db:code role="parameter">other</db:code>. If a key is common to both hashes, the resulting hash will contain the key multiple times.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq">
<db:title>QMultiHash&lt;Key, T&gt; &amp;QMultiHash::operator+=(const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>const QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash&lt;Key, T&gt; &amp; operator+=(const QMultiHash&lt;Key, T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts all the items in the <db:code role="parameter">other</db:code> hash into this hash and returns a reference to this hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#unite">unite</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>T &amp;QMultiHash::operator[](const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; operator[](const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the value associated with the <db:code role="parameter">key</db:code> as a modifiable reference.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function inserts a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> into the hash with the <db:code role="parameter">key</db:code>, and returns a reference to it.</db:para>
<db:para>If the hash contains multiple items with the <db:code role="parameter">key</db:code>, this function returns a reference to the most recently inserted value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="erase_if">
<db:title>[since 6.1] qsizetype erase_if(QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>, Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>erase_if</db:methodname>
<db:methodparam>
<db:type>QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>hash</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Predicate</db:type>
<db:parameter>pred</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype erase_if(QMultiHash&lt;Key, T&gt; &amp;hash, Predicate pred)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the multi hash <db:code role="parameter">hash</db:code>.</db:para>
<db:para>The function supports predicates which take either an argument of type QMultiHash&lt;Key, T&gt;::iterator, or an argument of type std::pair&lt;const Key &amp;, T &amp;&gt;.</db:para>
<db:para>Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
</db:section>
<db:section xml:id="qHash">
<db:title>[since 5.8] size_t qHash(const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QMultiHash&lt;Key, T&gt; &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Type T must be supported by qHash().</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>out</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>hash</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&lt;&lt;(QDataStream &amp;out, const QMultiHash&lt;Key, T&gt; &amp;hash)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the hash <db:code role="parameter">hash</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:para>This function requires the key and value types to implement operator&lt;&lt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>in</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>hash</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&gt;&gt;(QDataStream &amp;in, QMultiHash&lt;Key, T&gt; &amp;hash)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a hash from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">hash</db:code>.</db:para>
<db:para>This function requires the key and value types to implement operator&gt;&gt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
