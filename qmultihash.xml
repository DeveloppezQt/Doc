<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QMultiHash Class</db:title>
<db:subtitle>template &lt;typename Key, typename T&gt; class QMultiHash</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.14.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> class is a convenience <db:link xlink:href="qhash.xml#qhash">QHash</db:link> subclass that provides multi-valued hashes.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QMultiHash</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qhash.xml" xlink:role="class">QHash</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QMultiHash is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qmultihash.xml">QMultiHash</db:link>&lt;Key, T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It inherits <db:link xlink:href="qhash.xml#qhash">QHash</db:link> and extends it with a few convenience functions that make it more suitable than <db:link xlink:href="qhash.xml#qhash">QHash</db:link> for storing multi-valued hashes. A multi-valued hash is a hash that allows multiple values with the same key; <db:link xlink:href="qhash.xml#qhash">QHash</db:link> normally doesn't allow that, unless you call <db:link xlink:href="qhash.xml#insertMulti">QHash::insertMulti</db:link>().</db:para>
<db:para>Because <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> inherits <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, all of <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s functionality also applies to <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>. For example, you can use <db:link xlink:href="qhash.xml#isEmpty">isEmpty</db:link>() to test whether the hash is empty, and you can traverse a <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> using <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s iterator classes (for example, <db:link xlink:href="qhashiterator.xml">QHashIterator</db:link>). But in addition, it provides an <db:link xlink:href="qmultihash.xml#insert">insert</db:link>() function that corresponds to <db:link xlink:href="qhash.xml#insertMulti">QHash::insertMulti</db:link>(), and a <db:link xlink:href="qmultihash.xml#replace">replace</db:link>() function that corresponds to <db:link xlink:href="qhash.xml#insert">QHash::insert</db:link>(). It also provides convenient operator+() and operator+=().</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QMultiHash&amp;lt;QString, int&amp;gt; hash1, hash2, hash3;

hash1.insert(&quot;plenty&quot;, 100);
hash1.insert(&quot;plenty&quot;, 2000);
// hash1.size() == 2

hash2.insert(&quot;plenty&quot;, 5000);
// hash2.size() == 1

hash3 = hash1 + hash2;
// hash3.size() == 3
</db:programlisting>
<db:para>Unlike <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, <db:link xlink:href="qmultihash.xml">QMultiHash</db:link> provides no operator[]. Use <db:link xlink:href="qhash.xml#value">value</db:link>() or <db:link xlink:href="qmultihash.xml#replace">replace</db:link>() if you want to access the most recently inserted item with a certain key.</db:para>
<db:para>If you want to retrieve all the values for a single key, you can use values(const Key &amp;key), which returns a <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; values = hash.values(&quot;plenty&quot;);
for (int i = 0; i &amp;lt; values.size(); ++i)
    cout &amp;lt;&amp;lt; values.at(i) &amp;lt;&amp;lt; Qt::endl;
</db:programlisting>
<db:para>The items that share the same key are available from most recently to least recently inserted.</db:para>
<db:para>A more efficient approach is to call <db:link xlink:href="qmultihash.xml#find">find</db:link>() to get the STL-style iterator for the first item with a key and iterate from there:</db:para>
<db:programlisting language="cpp">QMultiHash&amp;lt;QString, int&amp;gt;::iterator i = hash.find(&quot;plenty&quot;);
while (i != hash.end() &amp;amp;&amp;amp; i.key() == &quot;plenty&quot;) {
    cout &amp;lt;&amp;lt; i.value() &amp;lt;&amp;lt; Qt::endl;
    ++i;
}
</db:programlisting>
<db:para><db:link xlink:href="qmultihash.xml">QMultiHash</db:link>'s key and value data types must be <db:link xlink:href="containers.xml#assignable-data-types">assignable data types</db:link>. You cannot, for example, store a QWidget as a value; instead, store a QWidget *. In addition, <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>'s key type must provide operator==(), and there must also be a <db:link xlink:href="qmultihash.xml#qHash">qHash</db:link>() function in the type's namespace that returns a hash value for an argument of the key's type. See the <db:link xlink:href="qhash.xml#qhash">QHash</db:link> documentation for details.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qhash">QHash</db:link></db:member>
<db:member><db:link xlink:href="qhashiterator.xml">QHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablehashiterator.xml">QMutableHashIterator</db:link></db:member>
<db:member>QMultiMap</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QMultiHash">
<db:title>QMultiHash::QMultiHash()</db:title>
<db:constructorsynopsis>
<db:methodname>QMultiHash</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty hash.</db:para>
</db:section>
<db:section xml:id="QMultiHash-1">
<db:title>[since 5.1] QMultiHash::QMultiHash(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; <db:emphasis>list</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QMultiHash</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; list)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a multi-hash with a copy of each of the elements in the initializer list <db:code role="parameter">list</db:code>.</db:para>
<db:para>This function is only available if the program is being compiled in C++11 mode.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
</db:section>
<db:section xml:id="QMultiHash-2">
<db:title>[since 5.14] QMultiHash::QMultiHash(InputIterator <db:emphasis>begin</db:emphasis>, InputIterator <db:emphasis>end</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QMultiHash</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash(InputIterator begin, InputIterator end)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a multi-hash with a copy of each of the elements in the iterator range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>). Either the elements iterated by the range must be objects with first and second data members (like QPair, std::pair, etc.) convertible to Key and to T respectively; or the iterators must have key() and value() member functions, returning a key convertible to Key and a value convertible to T respectively.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
</db:section>
<db:section xml:id="QMultiHash-3">
<db:title>QMultiHash::QMultiHash(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QMultiHash</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash(const QHash&lt;Key, T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code> (which can be a <db:link xlink:href="qhash.xml#qhash">QHash</db:link> or a <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind">
<db:title>[since 4.3] typename QHash&lt;Key, T&gt;::const_iterator QMultiHash::constFind(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>typename QHash&lt;Key, T&gt;::const_iterator</db:type>
<db:methodname>constFind</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">typename QHash&lt;Key, T&gt;::const_iterator constFind(const Key &amp;key, const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an iterator pointing to the item with the <db:code role="parameter">key</db:code> and the <db:code role="parameter">value</db:code> in the hash.</db:para>
<db:para>If the hash contains no such item, the function returns <db:link xlink:href="qhash.xml#constEnd">constEnd</db:link>().</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#constFind">QHash::constFind</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>[since 4.3] bool QMultiHash::contains(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(const Key &amp;key, const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the hash contains an item with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>; otherwise returns false.</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#contains">QHash::contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>[since 4.3] int QMultiHash::count(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>count</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int count(const Key &amp;key, const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of items with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>.</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#count-1">QHash::count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find">
<db:title>[since 4.3] typename QHash&lt;Key, T&gt;::iterator QMultiHash::find(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>typename QHash&lt;Key, T&gt;::iterator</db:type>
<db:methodname>find</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">typename QHash&lt;Key, T&gt;::iterator find(const Key &amp;key, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an iterator pointing to the item with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>. If the hash contains no such item, the function returns <db:link xlink:href="qhash.xml#end">end</db:link>().</db:para>
<db:para>If the hash contains multiple items with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>, the iterator returned points to the most recently inserted item.</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#find">QHash::find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find-1">
<db:title>[since 4.3] typename QHash&lt;Key, T&gt;::const_iterator QMultiHash::find(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>typename QHash&lt;Key, T&gt;::const_iterator</db:type>
<db:methodname>find</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">typename QHash&lt;Key, T&gt;::const_iterator find(const Key &amp;key, const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
</db:section>
<db:section xml:id="insert">
<db:title>typename QHash&lt;Key, T&gt;::iterator QMultiHash::insert(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>typename QHash&lt;Key, T&gt;::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">typename QHash&lt;Key, T&gt;::iterator insert(const Key &amp;key, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there is already an item with the same key in the hash, this function will simply create a new one. (This behavior is different from <db:link xlink:href="qmultihash.xml#replace">replace</db:link>(), which overwrites the value of an existing item.)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#replace">replace</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remove">
<db:title>[since 4.3] int QMultiHash::remove(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int remove(const Key &amp;key, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all the items that have the <db:code role="parameter">key</db:code> and the value <db:code role="parameter">value</db:code> from the hash. Returns the number of items removed.</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#remove">QHash::remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="replace">
<db:title>typename QHash&lt;Key, T&gt;::iterator QMultiHash::replace(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>typename QHash&lt;Key, T&gt;::iterator</db:type>
<db:methodname>replace</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">typename QHash&lt;Key, T&gt;::iterator replace(const Key &amp;key, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there is already an item with the <db:code role="parameter">key</db:code>, that item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there are multiple items with the <db:code role="parameter">key</db:code>, the most recently inserted item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>[since 4.8] void QMultiHash::swap(QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QMultiHash&lt;Key, T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps hash <db:code role="parameter">other</db:code> with this hash. This operation is very fast and never fails.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
</db:section>
<db:section xml:id="operator-2b">
<db:title>QMultiHash&lt;Key, T&gt; QMultiHash::operator+(const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMultiHash&lt;Key, T&gt;</db:type>
<db:methodname>operator+</db:methodname>
<db:methodparam>
<db:type>const QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash&lt;Key, T&gt; operator+(const QMultiHash&lt;Key, T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a hash that contains all the items in this hash in addition to all the items in <db:code role="parameter">other</db:code>. If a key is common to both hashes, the resulting hash will contain the key multiple times.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq">
<db:title>QMultiHash&lt;Key, T&gt; &amp;QMultiHash::operator+=(const QMultiHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>const QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMultiHash&lt;Key, T&gt; &amp; operator+=(const QMultiHash&lt;Key, T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts all the items in the <db:code role="parameter">other</db:code> hash into this hash and returns a reference to this hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmultihash.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qHash">
<db:title>[since 5.8] int qHash(<db:emphasis>const QMultiHash&lt;Key, T&gt; &amp;</db:emphasis>, <db:emphasis>int</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QMultiHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qHash(const QMultiHash&lt;Key, T&gt; &amp;, int)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Type T must be supported by qHash().</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
</db:section>
</db:section>
</db:article>
