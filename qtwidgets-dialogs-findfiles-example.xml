<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Find Files Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A dialog for finding files in a specified folder.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The Find Files application allows the user to search for files in a specified directory, matching a given file name or wildcard, and containing a specified string (if filled in). The search result is displayed in a table containing the names of the files and their sizes. The application also shows the number of files found.</db:para>
<db:para>The Find Files example illustrates the use of several classes:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qprogressdialog.xml">QProgressDialog</db:link></db:para>
</db:td>
<db:td>
<db:para>Provide feedback on the progress of a search operation</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qfiledialog.xml">QFileDialog</db:link></db:para>
</db:td>
<db:td>
<db:para>Browse through a file list</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qtextstream.xml">QTextStream</db:link></db:para>
</db:td>
<db:td>
<db:para>Use stream operators to read a file</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qtablewidget.xml">QTableWidget</db:link></db:para>
</db:td>
<db:td>
<db:para>Browse through the search results in a table</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qdesktopservices.xml">QDesktopServices</db:link></db:para>
</db:td>
<db:td>
<db:para>Open files in the result list in a suitable application</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:mediaobject>
<db:alt>Screenshot of the Find Files example</db:alt>
<db:imageobject>
<db:imagedata fileref="images/findfiles-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="window-class-definition">
<db:title>Window Class Definition</db:title>
<db:para>The Window class inherits <db:link xlink:href="qwidget.xml">QWidget</db:link>, and is the main application widget. It shows the search options and displays the search results.</db:para>
<db:programlisting language="cpp">class Window : public QWidget
{
    Q_OBJECT

public:
    Window(QWidget *parent = 0);

private slots:
    void browse();
    void find();
    void animateFindClick();
    void openFileOfItem(int row, int column);
    void contextMenu(const QPoint &amp;amp;pos);

private:
    QStringList findFiles(const QStringList &amp;amp;files, const QString &amp;amp;text);
    void showFiles(const QStringList &amp;amp;paths);
    QComboBox *createComboBox(const QString &amp;amp;text = QString());
    void createFilesTable();

    QComboBox *fileComboBox;
    QComboBox *textComboBox;
    QComboBox *directoryComboBox;
    QLabel *filesFoundLabel;
    QPushButton *findButton;
    QTableWidget *filesTable;

    QDir currentDir;
};
</db:programlisting>
<db:para>The application has two private slots:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para>The browse() slot</db:para>
</db:td>
<db:td>
<db:para>Called whenever the user wants to browse for a directory to search in</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>The find() slot</db:para>
</db:td>
<db:td>
<db:para>Called whenever the user launches a search with the <db:guilabel>Find</db:guilabel> button</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>In addition we declare several private functions:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para>findFiles()</db:para>
</db:td>
<db:td>
<db:para>Search for files matching the search parameters</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>showFiles()</db:para>
</db:td>
<db:td>
<db:para>Display the search result</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>ceateButton()</db:para>
</db:td>
<db:td>
<db:para>Construct the widget</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>createComboBox()</db:para>
</db:td>
<db:td>
<db:para>Construct the widget</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>createFilesTable()</db:para>
</db:td>
<db:td>
<db:para>Construct the widget</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="window-class-implementation">
<db:title>Window Class Implementation</db:title>
<db:para>In the constructor we first create the application's widgets.</db:para>
<db:programlisting language="cpp">Window::Window(QWidget *parent)
    : QWidget(parent)
{
    setWindowTitle(tr(&quot;Find Files&quot;));
    QPushButton *browseButton = new QPushButton(tr(&quot;&amp;amp;Browse...&quot;), this);
    connect(browseButton, &amp;amp;QAbstractButton::clicked, this, &amp;amp;Window::browse);
    findButton = new QPushButton(tr(&quot;&amp;amp;Find&quot;), this);
    connect(findButton, &amp;amp;QAbstractButton::clicked, this, &amp;amp;Window::find);

    fileComboBox = createComboBox(tr(&quot;*&quot;));
    connect(fileComboBox-&amp;gt;lineEdit(), &amp;amp;QLineEdit::returnPressed,
            this, &amp;amp;Window::animateFindClick);
    textComboBox = createComboBox();
    connect(textComboBox-&amp;gt;lineEdit(), &amp;amp;QLineEdit::returnPressed,
            this, &amp;amp;Window::animateFindClick);
    directoryComboBox = createComboBox(QDir::toNativeSeparators(QDir::currentPath()));
    connect(directoryComboBox-&amp;gt;lineEdit(), &amp;amp;QLineEdit::returnPressed,
            this, &amp;amp;Window::animateFindClick);

    filesFoundLabel = new QLabel;

    createFilesTable();

    QGridLayout *mainLayout = new QGridLayout(this);
    mainLayout-&amp;gt;addWidget(new QLabel(tr(&quot;Named:&quot;)), 0, 0);
    mainLayout-&amp;gt;addWidget(fileComboBox, 0, 1, 1, 2);
    mainLayout-&amp;gt;addWidget(new QLabel(tr(&quot;Containing text:&quot;)), 1, 0);
    mainLayout-&amp;gt;addWidget(textComboBox, 1, 1, 1, 2);
    mainLayout-&amp;gt;addWidget(new QLabel(tr(&quot;In directory:&quot;)), 2, 0);
    mainLayout-&amp;gt;addWidget(directoryComboBox, 2, 1);
    mainLayout-&amp;gt;addWidget(browseButton, 2, 2);
    mainLayout-&amp;gt;addWidget(filesTable, 3, 0, 1, 3);
    mainLayout-&amp;gt;addWidget(filesFoundLabel, 4, 0, 1, 2);
    mainLayout-&amp;gt;addWidget(findButton, 4, 2);
</db:programlisting>
<db:para>We create the widgets to build up the UI, and we add them to a main layout using <db:link xlink:href="qgridlayout.xml">QGridLayout</db:link>. We have, however, put the Find and Quit buttons and a stretchable space in a separate <db:link xlink:href="qhboxlayout.xml">QHBoxLayout</db:link> first, to make the buttons appear in the Window widget's bottom right corner.</db:para>
<db:para>Alternatively, we could have used Qt Designer to construct a UI file, and <db:link xlink:href="uic.xml">uic</db:link> to generate this code.</db:para>
<db:programlisting language="cpp">    connect(new QShortcut(QKeySequence::Quit, this), &amp;amp;QShortcut::activated,
        qApp, &amp;amp;QApplication::quit);
</db:programlisting>
<db:para>We did not create a <db:link xlink:href="qmenubar.xml">QMenuBar</db:link> with a <db:guilabel>Quit</db:guilabel> menu item; but we would still like to have a keyboard shortcut for quitting. Since we construct a <db:link xlink:href="qshortcut.xml">QShortcut</db:link> with <db:link xlink:href="qkeysequence.xml#StandardKey-enum">QKeySequence::Quit</db:link>, and connect it to <db:link xlink:href="qcoreapplication.xml#quit">QApplication::quit</db:link>(), on most platforms it will be possible to press Control-Q to quit (or whichever standard Quit key is configured on that platform). (On macOS, this is redundant, because every application gets a <db:guilabel>Quit</db:guilabel> menu item automatically; but it helps to make the application portable.)</db:para>
<db:programlisting language="cpp">void Window::browse()
{
    QString directory =
        QDir::toNativeSeparators(QFileDialog::getExistingDirectory(this, tr(&quot;Find Files&quot;), QDir::currentPath()));

    if (!directory.isEmpty()) {
        if (directoryComboBox-&amp;gt;findText(directory) == -1)
            directoryComboBox-&amp;gt;addItem(directory);
        directoryComboBox-&amp;gt;setCurrentIndex(directoryComboBox-&amp;gt;findText(directory));
    }
}
</db:programlisting>
<db:para>The browse() slot presents a file dialog to the user, using the <db:link xlink:href="qfiledialog.xml">QFileDialog</db:link> class. <db:link xlink:href="qfiledialog.xml">QFileDialog</db:link> enables a user to traverse the file system in order to select one or many files or a directory. The easiest way to create a <db:link xlink:href="qfiledialog.xml">QFileDialog</db:link> is to use the convenience static functions.</db:para>
<db:para>Here we use the static <db:link xlink:href="qfiledialog.xml#getExistingDirectory">QFileDialog::getExistingDirectory</db:link>() function which returns an existing directory selected by the user. Then we display the directory in the directory combobox using the <db:link xlink:href="qcombobox.xml#addItem">QComboBox::addItem</db:link>() function and update the current index.</db:para>
<db:para><db:link xlink:href="qcombobox.xml#addItem">QComboBox::addItem</db:link>() adds an item to the combobox with the given text (if not already present in the list), and containing the specified userData. The item is appended to the list of existing items.</db:para>
<db:programlisting language="cpp">void Window::find()
{
    filesTable-&amp;gt;setRowCount(0);

    QString fileName = fileComboBox-&amp;gt;currentText();
    QString text = textComboBox-&amp;gt;currentText();
    QString path = QDir::cleanPath(directoryComboBox-&amp;gt;currentText());
    currentDir = QDir(path);
</db:programlisting>
<db:para>The find() slot is called whenever the user requests a new search by pressing the <db:guilabel>Find</db:guilabel> button.</db:para>
<db:para>First we eliminate any previous search results by setting the table widgets row count to zero. Then we retrieve the specified file name, text, and directory path from the respective comboboxes.</db:para>
<db:programlisting language="cpp">    QStringList filter;
    if (!fileName.isEmpty())
        filter &amp;lt;&amp;lt; fileName;
    QDirIterator it(path, filter, QDir::AllEntries | QDir::NoSymLinks | QDir::NoDotAndDotDot, QDirIterator::Subdirectories);
    QStringList files;
    while (it.hasNext())
        files &amp;lt;&amp;lt; it.next();
    if (!text.isEmpty())
        files = findFiles(files, text);
    files.sort();
    showFiles(files);
}
</db:programlisting>
<db:para>We use the directory's path to create a <db:link xlink:href="qdir.xml">QDir</db:link>; the <db:link xlink:href="qdir.xml">QDir</db:link> class provides access to the directory structure and its contents.</db:para>
<db:para>We use <db:link xlink:href="qdiriterator.xml">QDirIterator</db:link> to iterate over the files that match the specified file name and build a <db:link xlink:href="qstringlist.xml">QStringList</db:link> of paths.</db:para>
<db:para>Then we search through all the files in the list, using the private findFiles() function, eliminating the ones that don't contain the specified text. We sort them (because <db:link xlink:href="qdiriterator.xml">QDirIterator</db:link> did not). And finally, we display the results using the private showFiles() function.</db:para>
<db:para>If the user didn't specify any text, there is no reason to search through the files, so we sort and display the results immediately.</db:para>
<db:mediaobject>
<db:alt>Screenshot of the Progress Dialog</db:alt>
<db:imageobject>
<db:imagedata fileref="images/findfiles_progress_dialog.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">QStringList Window::findFiles(const QStringList &amp;amp;files, const QString &amp;amp;text)
{
    QProgressDialog progressDialog(this);
    progressDialog.setCancelButtonText(tr(&quot;&amp;amp;Cancel&quot;));
    progressDialog.setRange(0, files.size());
    progressDialog.setWindowTitle(tr(&quot;Find Files&quot;));
</db:programlisting>
<db:para>In the private findFiles() function we search through a list of files, looking for the ones that contain a specified text. This can be a very slow operation depending on the number of files as well as their sizes. <db:link xlink:href="qprogressdialog.xml">QProgressDialog</db:link> displays a progress dialog if the application has to search through a large number of files, or if some of the files have a large size. <db:link xlink:href="qprogressdialog.xml">QProgressDialog</db:link> can also allow the user to abort the operation if it takes too much time.</db:para>
<db:programlisting language="cpp">    QMimeDatabase mimeDatabase;
    QStringList foundFiles;

    for (int i = 0; i &amp;lt; files.size(); ++i) {
        progressDialog.setValue(i);
        progressDialog.setLabelText(tr(&quot;Searching file number %1 of %n...&quot;, 0, files.size()).arg(i));
        QCoreApplication::processEvents();
</db:programlisting>
<db:para>We run through the files, one at a time, and for each file we update the <db:link xlink:href="qprogressdialog.xml">QProgressDialog</db:link> value. This property holds the current amount of progress made. We also update the progress dialog's label.</db:para>
<db:para>Then we call the <db:link xlink:href="qcoreapplication.xml#processEvents">QCoreApplication::processEvents</db:link>() function using the <db:link xlink:href="qapplication.xml">QApplication</db:link> object. In this way we interleave the display of the progress made with the process of searching through the files so the application doesn't appear to be frozen.</db:para>
<db:para>The <db:link xlink:href="qapplication.xml">QApplication</db:link> class manages the GUI application's control flow and main settings. It contains the main event loop, where all events from the window system and other sources are processed and dispatched. <db:link xlink:href="qapplication.xml">QApplication</db:link> inherits <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link>. The <db:link xlink:href="qcoreapplication.xml#processEvents">QCoreApplication::processEvents</db:link>() function processes all pending events according to the specified QEventLoop::ProcessEventFlags until there are no more events to process. The default flags are <db:link xlink:href="qeventloop.xml#ProcessEventsFlag-enum">QEventLoop::AllEvents</db:link>.</db:para>
<db:programlisting language="cpp">        const QString fileName = files.at(i);
        const QMimeType mimeType = mimeDatabase.mimeTypeForFile(fileName);
        if (mimeType.isValid() &amp;amp;&amp;amp; !mimeType.inherits(QStringLiteral(&quot;text/plain&quot;))) {
            qWarning() &amp;lt;&amp;lt; &quot;Not searching binary file &quot; &amp;lt;&amp;lt; QDir::toNativeSeparators(fileName);
            continue;
        }
        QFile file(fileName);
        if (file.open(QIODevice::ReadOnly)) {
            QString line;
            QTextStream in(&amp;amp;file);
            while (!in.atEnd()) {
                if (progressDialog.wasCanceled())
                    break;
                line = in.readLine();
                if (line.contains(text, Qt::CaseInsensitive)) {
                    foundFiles &amp;lt;&amp;lt; files[i];
                    break;
                }
            }
        }
    }
    return foundFiles;
}
</db:programlisting>
<db:para>After updating the <db:link xlink:href="qprogressdialog.xml">QProgressDialog</db:link>, we open the file in read-only mode, and read one line at a time using <db:link xlink:href="qtextstream.xml">QTextStream</db:link>.</db:para>
<db:para>The <db:link xlink:href="qtextstream.xml">QTextStream</db:link> class provides a convenient interface for reading and writing text. Using <db:link xlink:href="qtextstream.xml">QTextStream</db:link>'s streaming operators, you can conveniently read and write words, lines and numbers.</db:para>
<db:para>For each line we read we check if the <db:link xlink:href="qprogressdialog.xml">QProgressDialog</db:link> has been canceled. If it has, we abort the operation, otherwise we check if the line contains the specified text. When we find the text within one of the files, we add the file's name to a list of found files that contain the specified text, and start searching a new file.</db:para>
<db:para>Finally, we return the list of the files found.</db:para>
<db:programlisting language="cpp">void Window::showFiles(const QStringList &amp;amp;paths)
{
    for (const QString &amp;amp;filePath : paths) {
        const QString toolTip = QDir::toNativeSeparators(filePath);
        const QString relativePath = QDir::toNativeSeparators(currentDir.relativeFilePath(filePath));
        const qint64 size = QFileInfo(filePath).size();
        QTableWidgetItem *fileNameItem = new QTableWidgetItem(relativePath);
        fileNameItem-&amp;gt;setData(absoluteFileNameRole, QVariant(filePath));
        fileNameItem-&amp;gt;setToolTip(toolTip);
        fileNameItem-&amp;gt;setFlags(fileNameItem-&amp;gt;flags() ^ Qt::ItemIsEditable);
        QTableWidgetItem *sizeItem = new QTableWidgetItem(QLocale().formattedDataSize(size));
        sizeItem-&amp;gt;setData(absoluteFileNameRole, QVariant(filePath));
        sizeItem-&amp;gt;setToolTip(toolTip);
        sizeItem-&amp;gt;setTextAlignment(Qt::AlignRight | Qt::AlignVCenter);
        sizeItem-&amp;gt;setFlags(sizeItem-&amp;gt;flags() ^ Qt::ItemIsEditable);

        int row = filesTable-&amp;gt;rowCount();
        filesTable-&amp;gt;insertRow(row);
        filesTable-&amp;gt;setItem(row, 0, fileNameItem);
        filesTable-&amp;gt;setItem(row, 1, sizeItem);
    }
    filesFoundLabel-&amp;gt;setText(tr(&quot;%n file(s) found (Double click on a file to open it)&quot;, 0, paths.size()));
    filesFoundLabel-&amp;gt;setWordWrap(true);
}
</db:programlisting>
<db:para>Both the findFiles() and showFiles() functions are called from the find() slot. In the showFiles() function we run through the provided list of file names, adding each relative file name to the first column in the table widget and retrieving the file's size using <db:link xlink:href="qfileinfo.xml">QFileInfo</db:link> for the second column. We use <db:link xlink:href="qlocale.xml#formattedDataSize">QLocale::formattedDataSize</db:link>() to format the file size in a human-readable form. For later use, we set the absolute path as a data on the <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link> using the the role absoluteFileNameRole defined to be <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::UserRole</db:link> + 1.</db:para>
<db:programlisting language="cpp">enum { absoluteFileNameRole = Qt::UserRole + 1 };
</db:programlisting>
<db:para>This allows for retrieving the name of an item using a convenience function:</db:para>
<db:programlisting language="cpp">static inline QString fileNameOfItem(const QTableWidgetItem *item)
{
    return item-&amp;gt;data(absoluteFileNameRole).toString();
}
</db:programlisting>
<db:para>We also update the total number of files found.</db:para>
<db:programlisting language="cpp">QComboBox *Window::createComboBox(const QString &amp;amp;text)
{
    QComboBox *comboBox = new QComboBox;
    comboBox-&amp;gt;setEditable(true);
    comboBox-&amp;gt;addItem(text);
    comboBox-&amp;gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    return comboBox;
}
</db:programlisting>
<db:para>The private createComboBox() function is also called from the contructor. We create a <db:link xlink:href="qcombobox.xml">QComboBox</db:link> with the given text, and make it editable.</db:para>
<db:para>When the user enters a new string in an editable combobox, the widget may or may not insert it, and it can insert it in several locations, depending on the <db:link xlink:href="qcombobox.xml#InsertPolicy-enum">QComboBox::InsertPolicy</db:link>. The default policy is is <db:link xlink:href="qcombobox.xml#InsertPolicy-enum">QComboBox::InsertAtBottom</db:link>.</db:para>
<db:para>Then we add the provided text to the combobox, and specify the widget's size policies, before we return a pointer to the combobox.</db:para>
<db:programlisting language="cpp">void Window::createFilesTable()
{
    filesTable = new QTableWidget(0, 2);
    filesTable-&amp;gt;setSelectionBehavior(QAbstractItemView::SelectRows);

    QStringList labels;
    labels &amp;lt;&amp;lt; tr(&quot;Filename&quot;) &amp;lt;&amp;lt; tr(&quot;Size&quot;);
    filesTable-&amp;gt;setHorizontalHeaderLabels(labels);
    filesTable-&amp;gt;horizontalHeader()-&amp;gt;setSectionResizeMode(0, QHeaderView::Stretch);
    filesTable-&amp;gt;verticalHeader()-&amp;gt;hide();
    filesTable-&amp;gt;setShowGrid(false);
    filesTable-&amp;gt;setContextMenuPolicy(Qt::CustomContextMenu);
    connect(filesTable, &amp;amp;QTableWidget::customContextMenuRequested,
            this, &amp;amp;Window::contextMenu);
    connect(filesTable, &amp;amp;QTableWidget::cellActivated,
            this, &amp;amp;Window::openFileOfItem);
}
</db:programlisting>
<db:para>The private createFilesTable() function is called from the constructor. In this function we create the <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link> that will display the search results. We set its horizontal headers and their resize mode.</db:para>
<db:para><db:link xlink:href="qtablewidget.xml">QTableWidget</db:link> inherits <db:link xlink:href="qtableview.xml">QTableView</db:link> which provides a default model/view implementation of a table view. The <db:link xlink:href="qtableview.xml#horizontalHeader">QTableView::horizontalHeader</db:link>() function returns the table view's horizontal header as a <db:link xlink:href="qheaderview.xml">QHeaderView</db:link>. The <db:link xlink:href="qheaderview.xml">QHeaderView</db:link> class provides a header row or header column for item views, and the QHeaderView::setResizeMode() function sets the constraints on how the section in the header can be resized.</db:para>
<db:para>Finally, we hide the <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link>'s vertical headers using the <db:link xlink:href="qwidget.xml#hide">QWidget::hide</db:link>() function, and remove the default grid drawn for the table using the <db:link xlink:href="qtableview.xml#showGrid-prop">QTableView::setShowGrid</db:link>() function.</db:para>
<db:programlisting language="cpp">void Window::openFileOfItem(int row, int /* column */)
{
    const QTableWidgetItem *item = filesTable-&amp;gt;item(row, 0);
    openFile(fileNameOfItem(item));
}

static inline void openFile(const QString &amp;amp;fileName)
{
    QDesktopServices::openUrl(QUrl::fromLocalFile(fileName));
}
</db:programlisting>
<db:para>The openFileOfItem() slot is invoked when the user double clicks on a cell in the table. The <db:link xlink:href="qdesktopservices.xml#openUrl">QDesktopServices::openUrl</db:link>() knows how to open a file given the file name.</db:para>
<db:programlisting language="cpp">    filesTable-&amp;gt;setContextMenuPolicy(Qt::CustomContextMenu);
    connect(filesTable, &amp;amp;QTableWidget::customContextMenuRequested,
            this, &amp;amp;Window::contextMenu);
    connect(filesTable, &amp;amp;QTableWidget::cellActivated,
            this, &amp;amp;Window::openFileOfItem);
void Window::contextMenu(const QPoint &amp;amp;pos)
{
    const QTableWidgetItem *item = filesTable-&amp;gt;itemAt(pos);
    if (!item)
        return;
    QMenu menu;
#ifndef QT_NO_CLIPBOARD
    QAction *copyAction = menu.addAction(&quot;Copy Name&quot;);
#endif
    QAction *openAction = menu.addAction(&quot;Open&quot;);
    QAction *action = menu.exec(filesTable-&amp;gt;mapToGlobal(pos));
    if (!action)
        return;
    const QString fileName = fileNameOfItem(item);
    if (action == openAction)
        openFile(fileName);
#ifndef QT_NO_CLIPBOARD
    else if (action == copyAction)
        QGuiApplication::clipboard()-&amp;gt;setText(QDir::toNativeSeparators(fileName));
#endif
}
</db:programlisting>
<db:para>We set the context menu policy to of the table view to <db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::CustomContextMenu</db:link> and connect a slot contextMenu() to its signal customContextMenuRequested(). We retrieve the absolute file name from the data of the <db:link xlink:href="qtablewidgetitem.xml">QTableWidgetItem</db:link> and populate the context menu with actions offering to copy the file name and to open the file.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="dialogs/findfiles/findfiles.pro">dialogs/findfiles/findfiles.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="dialogs/findfiles/main.cpp">dialogs/findfiles/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="dialogs/findfiles/window.cpp">dialogs/findfiles/window.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="dialogs/findfiles/window.h">dialogs/findfiles/window.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
