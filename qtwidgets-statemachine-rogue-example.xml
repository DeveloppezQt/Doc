<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Rogue Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Rogue example shows how to use the Qt state machine for event handling.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/rogue-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>This example implements a simple text based game. Do you see the @ in the screenshot? That's you, the rogue. The # characters are walls, and the dots represent floor. In a real game, other ASCII characters would represent all kinds of objects and creatures, for instance, ancient dragons (Ds) or food rations (%s). But let's not get carried away. In this game, the rogue is simply running around in an empty room.</db:para>
<db:para>The rogue is moved with the keypad (2, 4, 8, 6). That aside, we have implemented a quit command that triggers if the player types q. The player is then asked if he/she really wants to quit.</db:para>
<db:para>Most games have commands that need more than one key press (we think of consecutive presses, i.e., not of several keys being pressed at the same time). In this game, only the quit command falls under this category, but for the sake of argument, let's imagine a fully-fledged game with a rich set of commands. If we were to implement these by catching key events in <db:link xlink:href="qwidget.xml#keyPressEvent">keyPressEvent</db:link>(), we would have to keep a lot of class member variables to track the sequence of keys already typed (or find some other way of deducing the current state of a command). This can easily lead to spaghetti, which is–as we all well know, I'm sure–unpleasant. With a state machine, on the other hand, separate states can wait for a single key press, and that makes our lives a lot simpler.</db:para>
<db:para>The example consists of two classes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Window draws the text display of the game and sets up the state machine. The window also has a status bar above the area in which the rouge moves.</db:para>
</db:listitem>
<db:listitem>
<db:para>MovementTransition is a transition that carries out a single move of the rogue.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Before we embark on a code walkthrough, it is necessary to take a closer look at the design of the machine. Here is a state chart that shows what we want to achieve:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/rogue-statechart.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The input state waits for a key press to start a new command. When receiving a key it recognizes, it transitions to one of the two commands of the game; though, as we will see, movement is handled by the transition itself. The quit state waits for the player to answer yes or no (by typing y or n) when asked whether he/she really wants to quit the game.</db:para>
<db:para>The chart demonstrates how we use one state to wait for a single key press. The press received may trigger one of the transitions connected to the state.</db:para>
<db:section xml:id="window-class-definition">
<db:title>Window Class Definition</db:title>
<db:para>The Window class is a widget that draws the text display of the game. It also sets up the state machine, i.e., creates and connects the states in the machine. It is the key events from this widget that are used by the machine.</db:para>
<db:programlisting language="cpp">class Window : public QWidget
{
    Q_OBJECT
    Q_PROPERTY(QString status READ status WRITE setStatus)

public:
    enum Direction { Up, Down, Left, Right };

    Window();

    void movePlayer(Direction direction);
    void setStatus(const QString &amp;status);
    QString status() const;

    QSize sizeHint() const Q_DECL_OVERRIDE;

protected:
    void paintEvent(QPaintEvent *event) Q_DECL_OVERRIDE;
</db:programlisting>
<db:para>Direction specifies the direction in which the rogue is to move. We use this in movePlayer(), which moves the rogue and repaints the window. The game has a status line above the area in which the rogue moves. The status property contains the text of this line. We use a property because the <db:link xlink:href="qstate.xml">QState</db:link> class allows setting any Qt <db:link xlink:href="properties.xml">property</db:link> when entered. More on this later.</db:para>
<db:programlisting language="cpp">private:
    void buildMachine();
    void setupMap();

    QChar map[WIDTH][HEIGHT];
    int pX, pY;

    QStateMachine *machine;
    QString myStatus;
};
</db:programlisting>
<db:para>The map is an array with the characters that are currently displayed. We set up the array in setupMap(), and update it when the rogue is moved. pX and pY is the current position of the rogue. WIDTH and HEIGHT are macros specifying the dimensions of the map.</db:para>
<db:para>The paintEvent() function is left out of this walkthrough. We also do not discuss other code that does not concern the state machine (the setupMap(), status(), setStatus(), movePlayer(), and sizeHint() functions). If you wish to take a look at the code, click on the link for the window.cpp file at the top of this page.</db:para>
</db:section>
<db:section xml:id="window-class-implementation">
<db:title>Window Class Implementation</db:title>
<db:para>Here is the constructor of Window:</db:para>
<db:programlisting language="cpp">Window::Window()
{
    pX = 5;
    pY = 5;
    ...
    setupMap();
    buildMachine();
}
</db:programlisting>
<db:para>The player starts off at position (5, 5). We then set up the map and statemachine. Let's proceed with the buildMachine() function:</db:para>
<db:programlisting language="cpp">void Window::buildMachine()
{
    machine = new QStateMachine;

    QState *inputState = new QState(machine);
    inputState-&gt;assignProperty(this, &quot;status&quot;, &quot;Move the rogue with 2, 4, 6, and 8&quot;);

    MovementTransition *transition = new MovementTransition(this);
    inputState-&gt;addTransition(transition);
</db:programlisting>
<db:para>We enter inputState when the machine is started and from the quitState if the user wants to continue playing. We then set the status to a helpful reminder of how to play the game.</db:para>
<db:para>First, the Movement transition is added to the input state. This will enable the rogue to be moved with the keypad. Notice that we don't set a target state for the movement transition. This will cause the transition to be triggered (and the <db:link xlink:href="qabstracttransition.xml#onTransition">onTransition</db:link>() function to be invoked), but the machine will not leave the inputState. If we had set inputState as the target state, we would first have left and then entered the inputState again.</db:para>
<db:programlisting language="cpp">    QState *quitState = new QState(machine);
    quitState-&gt;assignProperty(this, &quot;status&quot;, &quot;Really quit(y/n)?&quot;);

    QKeyEventTransition *yesTransition = new
        QKeyEventTransition(this, QEvent::KeyPress, Qt::Key_Y);
    yesTransition-&gt;setTargetState(new QFinalState(machine));
    quitState-&gt;addTransition(yesTransition);

    QKeyEventTransition *noTransition =
        new QKeyEventTransition(this, QEvent::KeyPress, Qt::Key_N);
    noTransition-&gt;setTargetState(inputState);
    quitState-&gt;addTransition(noTransition);
</db:programlisting>
<db:para>When we enter quitState, we update the status bar of the window.</db:para>
<db:para>QKeyEventTransition is a utility class that removes the hassle of implementing transitions for <db:link xlink:href="qkeyevent.xml">QKeyEvent</db:link>s. We simply need to specify the key on which the transition should trigger and the target state of the transition.</db:para>
<db:programlisting language="cpp">    QKeyEventTransition *quitTransition =
        new QKeyEventTransition(this, QEvent::KeyPress, Qt::Key_Q);
    quitTransition-&gt;setTargetState(quitState);
    inputState-&gt;addTransition(quitTransition);
</db:programlisting>
<db:para>The transition from inputState allows triggering the quit state when the player types q.</db:para>
<db:programlisting language="cpp">    machine-&gt;setInitialState(inputState);

    connect(machine, SIGNAL(finished()), qApp, SLOT(quit()));

    machine-&gt;start();
}
</db:programlisting>
<db:para>The machine is set up, so it's time to start it.</db:para>
</db:section>
<db:section xml:id="the-movementtransition-class">
<db:title>The MovementTransition Class</db:title>
<db:para>MovementTransition is triggered when the player request the rogue to be moved (by typing 2, 4, 6, or 8) when the machine is in the inputState.</db:para>
<db:programlisting language="cpp">class MovementTransition : public QEventTransition
{
    Q_OBJECT

public:
    MovementTransition(Window *window) :
        QEventTransition(window, QEvent::KeyPress) {
        this-&gt;window = window;
    }
</db:programlisting>
<db:para>In the constructor, we tell <db:link xlink:href="qeventtransition.xml">QEventTransition</db:link> to only send <db:link xlink:href="qevent.xml#Type-enum">KeyPress</db:link> events to the <db:link xlink:href="qabstracttransition.xml#eventTest">eventTest</db:link>() function:</db:para>
<db:programlisting language="cpp">protected:
    bool eventTest(QEvent *event) Q_DECL_OVERRIDE {
        if (event-&gt;type() == QEvent::StateMachineWrapped &amp;&amp;
            static_cast&lt;QStateMachine::WrappedEvent *&gt;(event)-&gt;event()-&gt;type() == QEvent::KeyPress) {
            QEvent *wrappedEvent = static_cast&lt;QStateMachine::WrappedEvent *&gt;(event)-&gt;event();

            QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(wrappedEvent);
            int key = keyEvent-&gt;key();

            return key == Qt::Key_2 || key == Qt::Key_8 || key == Qt::Key_6 ||
                   key == Qt::Key_4 || key == Qt::Key_Down || key == Qt::Key_Up ||
                   key == Qt::Key_Right || key == Qt::Key_Left;
        }
        return false;
    }
</db:programlisting>
<db:para>The KeyPress events come wrapped in <db:link xlink:href="qstatemachine-wrappedevent.xml">QStateMachine::WrappedEvent</db:link>s. event must be confirmed to be a wrapped event because Qt uses other events internally. After that, it is simply a matter of checking which key has been pressed.</db:para>
<db:para>Let's move on to the onTransition() function:</db:para>
<db:programlisting language="cpp">    void onTransition(QEvent *event) Q_DECL_OVERRIDE {
        QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(
            static_cast&lt;QStateMachine::WrappedEvent *&gt;(event)-&gt;event());

        int key = keyEvent-&gt;key();
        switch (key) {
            case Qt::Key_Left:
            case Qt::Key_4:
                window-&gt;movePlayer(Window::Left);
                break;
            case Qt::Key_Up:
            case Qt::Key_8:
                window-&gt;movePlayer(Window::Up);
                break;
            case Qt::Key_Right:
            case Qt::Key_6:
                window-&gt;movePlayer(Window::Right);
                break;
            case Qt::Key_Down:
            case Qt::Key_2:
                window-&gt;movePlayer(Window::Down);
                break;
            default:
                ;
        }
    }
</db:programlisting>
<db:para>When onTransition() is invoked, we know that we have a <db:link xlink:href="qevent.xml#Type-enum">KeyPress</db:link> event with 2, 4, 6, or 8, and can ask Window to move the player.</db:para>
</db:section>
<db:section xml:id="the-roguelike-tradition">
<db:title>The Roguelike Tradition</db:title>
<db:para>You might have been wondering why the game features a rogue. Well, these kinds of text based dungeon exploration games date back to a game called, yes, &quot;Rogue&quot;. Although outflanked by the technology of modern 3D computer games, roguelikes have a solid community of hard-core, devoted followers.</db:para>
<db:para>Playing these games can be surprisingly addictive (despite the lack of graphics). Angband, the perhaps most well-known rougelike, is found here: <db:link xlink:href="http://rephial.org/">http://rephial.org/</db:link>.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="statemachine/rogue/main.cpp">statemachine/rogue/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="statemachine/rogue/movementtransition.h">statemachine/rogue/movementtransition.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="statemachine/rogue/rogue.pro">statemachine/rogue/rogue.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="statemachine/rogue/window.cpp">statemachine/rogue/window.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="statemachine/rogue/window.h">statemachine/rogue/window.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
