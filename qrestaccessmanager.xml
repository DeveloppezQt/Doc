<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRestAccessManager Class</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qrestaccessmanager.xml">QRestAccessManager</db:link> is a convenience wrapper for <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>.</db:para>
<db:para>This class was introduced in Qt 6.7.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QRestAccessManager</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.7</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Network)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Network)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += network</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QRestAccessManager is part of <db:simplelist><db:member><db:link xlink:href="network.xml">Network Programming API</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qrestaccessmanager.xml">QRestAccessManager</db:link> is a convenience wrapper on top of <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>. It amends datatypes and HTTP methods that are useful for typical RESTful client applications.</db:para>
<db:para>The usual Qt networking features are accessible by configuring the wrapped <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> directly. <db:link xlink:href="qrestaccessmanager.xml">QRestAccessManager</db:link> does not take ownership of the wrapped <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>.</db:para>
<db:para><db:link xlink:href="qrestaccessmanager.xml">QRestAccessManager</db:link> and related <db:link xlink:href="qrestreply.xml">QRestReply</db:link> classes can only be used in the thread they live in. See <db:link xlink:href="qobject.xml#thread-affinity">QObject thread affinity</db:link> for more information.</db:para>
<db:section xml:id="issuing-network-requests-and-handling-replies">
<db:title>Issuing Network Requests and Handling Replies</db:title>
<db:para>Network requests are initiated with a function call corresponding to the desired HTTP method, such as get() and post().</db:para>
<db:section xml:id="using-signals-and-slots">
<db:title>Using Signals and Slots</db:title>
<db:para>The function returns a <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>* object, whose signals can be used to follow up on the completion of the request in a traditional Qt-signals-and-slots way.</db:para>
<db:para>Here's an example of how you could send a GET request and handle the response:</db:para>
<db:programlisting language="cpp">QNetworkReply *reply = manager-&gt;get(request);
QObject::connect(reply, &amp;QNetworkReply::finished, this, [reply]() {
    // The reply may be wrapped in the finish handler:
    QRestReply restReply(reply);
    if (restReply.isSuccess())
        // ...
});
</db:programlisting>
</db:section>
<db:section xml:id="using-callbacks-and-context-objects">
<db:title>Using Callbacks and Context Objects</db:title>
<db:para>The functions also take a context object of <db:link xlink:href="qobject.xml">QObject</db:link> (subclass) type and a callback function as parameters. The callback takes one <db:link xlink:href="qrestreply.xml">QRestReply</db:link>&amp; as a parameter. The callback can be any callable, including a pointer-to-member-function.</db:para>
<db:para>These callbacks are invoked when the reply has finished processing (also in the case the processing finished due to an error).</db:para>
<db:para>The context object can be nullptr, although, generally speaking, this is discouraged. Using a valid context object ensures that if the context object is destroyed during request processing, the callback will not be called. Stray callbacks which access a destroyed context is a source of application misbehavior.</db:para>
<db:para>Here's an example of how you could send a GET request and check the response:</db:para>
<db:programlisting language="cpp">// With lambda
manager-&gt;get(request, this, [this](QRestReply &amp;reply) {
    if (reply.isSuccess()) {
        // ...
    }
});
// With member function
manager-&gt;get(request, this, &amp;MyClass::handleFinished);
</db:programlisting>
<db:para>Many of the functions take in data for sending to a server. The data is supplied as the second parameter after the request.</db:para>
<db:para>Here's an example of how you could send a POST request and check the response:</db:para>
<db:programlisting language="cpp">QJsonDocument myJson;
// ...
manager-&gt;post(request, myJson, this, [this](QRestReply &amp;reply) {
    if (!reply.isSuccess()) {
        // ...
    }
    if (std::optional json = reply.readJson()) {
        // use *json
    }
});
</db:programlisting>
<db:para>The provided <db:link xlink:href="qrestreply.xml">QRestReply</db:link>&amp; is valid only while the callback executes. If you need it for longer, you can either move it to another <db:link xlink:href="qrestreply.xml">QRestReply</db:link>, or construct a new one and initialize it with the <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> (see <db:link xlink:href="qrestreply.xml#networkReply">QRestReply::networkReply</db:link>()).</db:para>
</db:section>
<db:section xml:id="supported-data-types">
<db:title>Supported data types</db:title>
<db:para>The following table summarizes the methods and the supported data types. X means support.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Data type</db:para>
</db:th>
<db:th>
<db:para>get()</db:para>
</db:th>
<db:th>
<db:para>post()</db:para>
</db:th>
<db:th>
<db:para>put()</db:para>
</db:th>
<db:th>
<db:para>head()</db:para>
</db:th>
<db:th>
<db:para>patch()</db:para>
</db:th>
<db:th>
<db:para>deleteResource()</db:para>
</db:th>
<db:th>
<db:para>sendCustomRequest()</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>No data</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> *)</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> **)</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qhttpmultipart.xml">QHttpMultiPart</db:link></db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qiodevice.xml">QIODevice</db:link></db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
<db:td>
<db:para>-</db:para>
</db:td>
<db:td>
<db:para>X</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>*) <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> is sent in <db:link xlink:href="qjsondocument.xml#JsonFormat-enum">QJsonDocument::Compact</db:link> format, and the Content-Type header is set to application/json if the Content-Type header was not set</db:para>
<db:para>**) <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> is converted to and treated as a <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link></db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrestreply.xml">QRestReply</db:link></db:member>
<db:member><db:link xlink:href="qnetworkrequestfactory.xml">QNetworkRequestFactory</db:link></db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QRestAccessManager">
<db:title>[explicit] QRestAccessManager::QRestAccessManager(QNetworkAccessManager *<db:emphasis>manager</db:emphasis>, QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:para>Constructs a <db:link xlink:href="qrestaccessmanager.xml">QRestAccessManager</db:link> object and sets <db:code role="parameter">parent</db:code> as the parent object, and <db:code role="parameter">manager</db:code> as the underlying <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> which is used for communication.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrestaccessmanager.xml#networkAccessManager">networkAccessManager</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QRestAccessManager">
<db:title>[override virtual noexcept] QRestAccessManager::~QRestAccessManager()</db:title>
<db:para>Destroys the <db:link xlink:href="qrestaccessmanager.xml">QRestAccessManager</db:link> object.</db:para>
</db:section>
<db:section xml:id="deleteResource">
<db:title>QNetworkReply *QRestAccessManager::deleteResource(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>Issues an HTTP DELETE based on <db:code role="parameter">request</db:code>.</db:para>
<db:para>The optional <db:code role="parameter">callback</db:code> and <db:code role="parameter">context</db:code> object can be provided for handling the request completion as illustrated below:</db:para>
<db:programlisting language="cpp">manager-&gt;deleteResource(request, this, [this](QRestReply &amp;reply) {
    if (reply.isSuccess())
        // ...
});
</db:programlisting>
<db:para>Alternatively the signals of the returned <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>* object can be used. For further information see <db:link xlink:href="qrestaccessmanager.xml#issuing-network-requests-and-handling-replies">Issuing Network Requests and Handling Replies</db:link>.</db:para>
<db:para>deleteResource() request does not support providing data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrestreply.xml">QRestReply</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="get">
<db:title>QNetworkReply *QRestAccessManager::get(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>Issues an HTTP GET based on <db:code role="parameter">request</db:code>.</db:para>
<db:para>The optional <db:code role="parameter">callback</db:code> and <db:code role="parameter">context</db:code> object can be provided for handling the request completion as illustrated below:</db:para>
<db:programlisting language="cpp">manager-&gt;get(request, this, [this](QRestReply &amp;reply) {
    if (!reply.isSuccess())
        // handle error
    if (std::optional json = reply.readJson())
        // use *json
});
</db:programlisting>
<db:para>Alternatively the signals of the returned <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>* object can be used. For further information see <db:link xlink:href="qrestaccessmanager.xml#issuing-network-requests-and-handling-replies">Issuing Network Requests and Handling Replies</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrestreply.xml">QRestReply</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="get-1">
<db:title>QNetworkReply *QRestAccessManager::get(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>Issues an HTTP GET based on <db:code role="parameter">request</db:code> and provided <db:code role="parameter">data</db:code>.</db:para>
<db:para>The optional <db:code role="parameter">callback</db:code> and <db:code role="parameter">context</db:code> object can be provided for handling the request completion as illustrated below:</db:para>
<db:programlisting language="cpp">manager-&gt;get(request, myData, this, [this](QRestReply &amp;reply) {
    if (reply.isSuccess())
        // ...
});
</db:programlisting>
<db:para>Alternatively the signals of the returned <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>* object can be used. For further information see <db:link xlink:href="qrestaccessmanager.xml#issuing-network-requests-and-handling-replies">Issuing Network Requests and Handling Replies</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrestreply.xml">QRestReply</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="get-6">
<db:title>QNetworkReply *QRestAccessManager::get(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, QIODevice *<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="get-7">
<db:title>QNetworkReply *QRestAccessManager::get(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QJsonDocument &amp;<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="head">
<db:title>QNetworkReply *QRestAccessManager::head(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>Issues an HTTP HEAD based on <db:code role="parameter">request</db:code>.</db:para>
<db:para>The optional <db:code role="parameter">callback</db:code> and <db:code role="parameter">context</db:code> object can be provided for handling the request completion as illustrated below:</db:para>
<db:programlisting language="cpp">manager-&gt;head(request, this, [this](QRestReply &amp;reply) {
    if (reply.isSuccess())
        // ...
});
</db:programlisting>
<db:para>Alternatively the signals of the returned <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>* object can be used. For further information see <db:link xlink:href="qrestaccessmanager.xml#issuing-network-requests-and-handling-replies">Issuing Network Requests and Handling Replies</db:link>.</db:para>
<db:para>head() request does not support providing data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrestreply.xml">QRestReply</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="networkAccessManager">
<db:title>QNetworkAccessManager *QRestAccessManager::networkAccessManager() const</db:title>
<db:para>Returns the underlying <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> instance.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="patch">
<db:title>QNetworkReply *QRestAccessManager::patch(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QJsonDocument &amp;<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>Issues an HTTP PATCH based on <db:code role="parameter">request</db:code>.</db:para>
<db:para>The optional <db:code role="parameter">callback</db:code> and <db:code role="parameter">context</db:code> object can be provided for handling the request completion as illustrated below:</db:para>
<db:programlisting language="cpp">manager-&gt;patch(request, myData, this, [this](QRestReply &amp;reply) {
    if (reply.isSuccess())
        // ...
});
</db:programlisting>
<db:para>Alternatively the signals of the returned <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>* object can be used. For further information see <db:link xlink:href="qrestaccessmanager.xml#issuing-network-requests-and-handling-replies">Issuing Network Requests and Handling Replies</db:link>.</db:para>
<db:para>The patch() method always requires <db:code role="parameter">data</db:code> parameter. The following data types are supported:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> *)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> **)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qiodevice.xml">QIODevice</db:link>*</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>*) Sent in <db:link xlink:href="qjsondocument.xml#JsonFormat-enum">QJsonDocument::Compact</db:link> format, and the Content-Type header is set to application/json if the Content-Type header was not set **) <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> is converted to and treated as a <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link></db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrestreply.xml">QRestReply</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="patch-5">
<db:title>QNetworkReply *QRestAccessManager::patch(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, QIODevice *<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="patch-6">
<db:title>QNetworkReply *QRestAccessManager::patch(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="patch-7">
<db:title>QNetworkReply *QRestAccessManager::patch(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QVariantMap &amp;<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="post">
<db:title>QNetworkReply *QRestAccessManager::post(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QJsonDocument &amp;<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>Issues an HTTP POST based on <db:code role="parameter">request</db:code>.</db:para>
<db:para>The optional <db:code role="parameter">callback</db:code> and <db:code role="parameter">context</db:code> object can be provided for handling the request completion as illustrated below:</db:para>
<db:programlisting language="cpp">manager-&gt;post(request, myData, this, [this](QRestReply &amp;reply) {
    if (reply.isSuccess())
        // ...
});
</db:programlisting>
<db:para>Alternatively, the signals of the returned <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>* object can be used. For further information see <db:link xlink:href="qrestaccessmanager.xml#issuing-network-requests-and-handling-replies">Issuing Network Requests and Handling Replies</db:link>.</db:para>
<db:para>The post() method always requires <db:code role="parameter">data</db:code> parameter. The following data types are supported:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> *)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> **)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qhttpmultipart.xml">QHttpMultiPart</db:link>*</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qiodevice.xml">QIODevice</db:link>*</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>*) Sent in <db:link xlink:href="qjsondocument.xml#JsonFormat-enum">QJsonDocument::Compact</db:link> format, and the Content-Type header is set to application/json if the Content-Type header was not set **) <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> is converted to and treated as a <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link></db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrestreply.xml">QRestReply</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="post-6">
<db:title>QNetworkReply *QRestAccessManager::post(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, QHttpMultiPart *<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="post-7">
<db:title>QNetworkReply *QRestAccessManager::post(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, QIODevice *<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="post-8">
<db:title>QNetworkReply *QRestAccessManager::post(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="post-9">
<db:title>QNetworkReply *QRestAccessManager::post(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QVariantMap &amp;<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="put">
<db:title>QNetworkReply *QRestAccessManager::put(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QJsonDocument &amp;<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>Issues an HTTP PUT based on <db:code role="parameter">request</db:code>.</db:para>
<db:para>The optional <db:code role="parameter">callback</db:code> and <db:code role="parameter">context</db:code> object can be provided for handling the request completion as illustrated below:</db:para>
<db:programlisting language="cpp">manager-&gt;put(request, myData, this, [this](QRestReply &amp;reply) {
    if (reply.isSuccess())
        // ...
});
</db:programlisting>
<db:para>Alternatively the signals of the returned <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>* object can be used. For further information see <db:link xlink:href="qrestaccessmanager.xml#issuing-network-requests-and-handling-replies">Issuing Network Requests and Handling Replies</db:link>.</db:para>
<db:para>The put() method always requires <db:code role="parameter">data</db:code> parameter. The following data types are supported:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> *)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> **)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qhttpmultipart.xml">QHttpMultiPart</db:link>*</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qiodevice.xml">QIODevice</db:link>*</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>*) Sent in <db:link xlink:href="qjsondocument.xml#JsonFormat-enum">QJsonDocument::Compact</db:link> format, and the Content-Type header is set to application/json if the Content-Type header was not set **) <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> is converted to and treated as a <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link></db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrestreply.xml">QRestReply</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="put-6">
<db:title>QNetworkReply *QRestAccessManager::put(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, QHttpMultiPart *<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="put-7">
<db:title>QNetworkReply *QRestAccessManager::put(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, QIODevice *<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="put-8">
<db:title>QNetworkReply *QRestAccessManager::put(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="put-9">
<db:title>QNetworkReply *QRestAccessManager::put(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QVariantMap &amp;<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="sendCustomRequest">
<db:title>QNetworkReply *QRestAccessManager::sendCustomRequest(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>method</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>Issues <db:code role="parameter">request</db:code> based HTTP request with custom <db:code role="parameter">method</db:code> and the provided <db:code role="parameter">data</db:code>.</db:para>
<db:para>The optional <db:code role="parameter">callback</db:code> and <db:code role="parameter">context</db:code> object can be provided for handling the request completion as illustrated below:</db:para>
<db:programlisting language="cpp">manager-&gt;sendCustomRequest(request, &quot;MYMETHOD&quot;,  myData,  this, [this](QRestReply &amp;reply) {
    if (reply.isSuccess())
        // ...
});
</db:programlisting>
<db:para>Alternatively the signals of the returned <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>* object can be used. For further information see <db:link xlink:href="qrestaccessmanager.xml#issuing-network-requests-and-handling-replies">Issuing Network Requests and Handling Replies</db:link>.</db:para>
</db:section>
<db:section xml:id="sendCustomRequest-4">
<db:title>QNetworkReply *QRestAccessManager::sendCustomRequest(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>method</db:emphasis>, QHttpMultiPart *<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="sendCustomRequest-5">
<db:title>QNetworkReply *QRestAccessManager::sendCustomRequest(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>method</db:emphasis>, QIODevice *<db:emphasis>data</db:emphasis>, const QRestAccessManager::ContextTypeForFunctor&lt;Functor&gt; *<db:emphasis>context</db:emphasis>, Functor &amp;&amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
</db:section>
</db:article>
