<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QQuickGraphicsConfiguration Class</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para><db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link> controls lower level graphics settings for the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>.</db:para>
<db:para>This class was introduced in Qt 6.0.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QQuickGraphicsConfiguration</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Quick)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Quick)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += quick</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link> class is a container for low-level graphics settings that can affect how the underlying graphics API, such as Vulkan, is initialized by the Qt Quick scene graph. It can also control certain aspects of the scene graph renderer.</db:para>
<db:note>
<db:para>Setting a <db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link> on a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> must happen early enough, before the scene graph is initialized for the first time for that window. With on-screen windows this means the call must be done before invoking show() on the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> or <db:link xlink:href="qquickview.xml">QQuickView</db:link>. With <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> the configuration must be finalized before calling <db:link xlink:href="qquickrendercontrol.xml#initialize">initialize</db:link>().</db:para>
</db:note>
<db:section xml:id="configuration-for-external-rendering-engines-or-xr-apis">
<db:title>Configuration for External Rendering Engines or XR APIs</db:title>
<db:para>When constructing and showing a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> that uses Vulkan to render, a Vulkan instance (<db:code>VkInstance</db:code>), a physical device (<db:code>VkPhysicalDevice</db:code>), a device (<db:code>VkDevice</db:code>) and associated objects (queues, pools) are initialized through the Vulkan API. The same is mostly true when using <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> to redirect the rendering into a custom render target, such as a texture. While <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> construction is under the application's control then, the initialization of other graphics objects happen the same way in <db:link xlink:href="qquickrendercontrol.xml#initialize">QQuickRenderControl::initialize</db:link>() as with an on-screen <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>.</db:para>
<db:para>For the majority of applications no additional configuration is needed because Qt Quick provides reasonable defaults for many low-level graphics settings, for example which device extensions to enable.</db:para>
<db:para>This will not alway be sufficient, however. In advanced use cases, when integrating direct Vulkan or other graphics API content, or when integrating with an external 3D or VR engine, such as, OpenXR, the application will want to specify its own set of settings when it comes to details, such as which device extensions to enable.</db:para>
<db:para>That is what this class enables. It allows specifying, for example, a list of device extensions that is then picked up by the scene graph when using Vulkan, or graphics APIs where the concept is applicable. Where some concepts are not applicable, the related settings are simply ignored.</db:para>
<db:para>Examples of functions in this category are <db:link xlink:href="qquickgraphicsconfiguration.xml#preferredInstanceExtensions">preferredInstanceExtensions</db:link>() and <db:link xlink:href="qquickgraphicsconfiguration.xml#setDeviceExtensions">setDeviceExtensions</db:link>().</db:para>
</db:section>
<db:section xml:id="qt-quick-scene-graph-renderer-configuration">
<db:title>Qt Quick Scene Graph Renderer Configuration</db:title>
<db:para>Another class of settings are related to the scene graph's renderer. In some cases applications may want to control certain behavior,such as using the depth buffer when rendering 2D content. In Qt 5 such settings were either not controllable at all, or were managed through environment variables. In Qt 6, <db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link> provides a new home for these settings, while keeping support for the legacy environment variables, where applicable.</db:para>
<db:para>An example in this category is <db:link xlink:href="qquickgraphicsconfiguration.xml#setDepthBufferFor2D">setDepthBufferFor2D</db:link>().</db:para>
</db:section>
<db:section xml:id="graphics-device-configuration">
<db:title>Graphics Device Configuration</db:title>
<db:para>When the graphics instance and device objects (for example, the VkInstance and VkDevice with Vulkan, the ID3D11Device with Direct 3D, etc.) are created by Qt when initializing a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>, there are settings which applications or libraries will want to control under certain circumstances.</db:para>
<db:para>Before Qt 6.5, some of such settings were available to control via environment variables. For example, <db:code>QSG_RHI_DEBUG_LAYER</db:code> or <db:code>QSG_RHI_PREFER_SOFTWARE_RENDERER</db:code>. These are still available and continue to function as before. <db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link> provides C++ setters in addition.</db:para>
<db:para>For example, the following main() function opens a <db:link xlink:href="qquickview.xml">QQuickView</db:link> while specifying that the Vulkan validation or Direct3D debug layer should be enabled:</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);

    QQuickGraphicsConfiguration config;
    config.setDebugLayer(true);

    QQuickView *view = new QQuickView;
    view-&amp;gt;setGraphicsConfiguration(config);

    view-&amp;gt;setSource(QUrl::fromLocalFile(&quot;myqmlfile.qml&quot;));
    view-&amp;gt;show();
    return app.exec();
}
</db:programlisting>
</db:section>
<db:section xml:id="pipeline-cache-save-and-load">
<db:title>Pipeline Cache Save and Load</db:title>
<db:para>Qt Quick supports storing the graphics/compute pipeline cache to disk, and reloading it in subsequent runs of an application. What exactly the pipeline cache contains, how lookups work, and what exactly gets accelerated all depend on the Qt RHI backend and the underlying native graphics API that is used at run time. Different 3D APIs have different concepts when it comes to shaders, programs, and pipeline state objects, and corresponding cache mechanisms. The high level pipeline cache concept here abstracts all this to storing and retrieving a single binary blob to and from a file.</db:para>
<db:note>
<db:para>Storing the cache on disk can lead to improvements, sometimes significant, in subsequent runs of the application.</db:para>
</db:note>
<db:para>When the same shader program and/or pipeline state is encountered as in a previous run, a number of operations are likely skipped, leading to faster shader and material initialization times, which means startup may become faster and lags and &quot;janks&quot; during rendering may be reduced or avoided.</db:para>
<db:para>When running with a graphics API where retrieving and reloading the pipeline cache (or shader/program binaries) is not applicable or not supported, attempting to use a file to save and load the cache has no effect.</db:para>
<db:note>
<db:para>In many cases the retrieved data is dependent on and tied to the graphics driver (and possibly the exact version of it). Qt performs the necessary checks automatically, by storing additional metadata in the pipeline cache file. If the data in the file does not match the graphics device and driver version at run time, the contents will be ignored transparently to the application. It is therefore safe to reference a cache that was generated on another device or driver.</db:para>
</db:note>
<db:para>There are exceptions to the driver dependency problem, most notably Direct 3D 11, where the &quot;pipeline cache&quot; is used only to store the results of runtime HLSL-&gt;DXBC compilation and is therefore device and vendor independent.</db:para>
<db:para>In some cases it may be desirable to improve the very first run of the application, by &quot;pre-seeding&quot; the cache. This is possible by shipping the cache file saved from a previous run, and referencing it on another machine or device. This way, the application or device has the shader programs/pipelines that have been encountered before in the run that saved the cache file available already during its first run. Shipping and deploying the cache file only makes sense if the device and graphics drivers are the same on the target system, otherwise the cache file is ignored if the device or driver version does not match (with the exception of D3D11), as described above.</db:para>
<db:para>Once the cache contents is loaded, there is still a chance that the application builds graphics and compute pipelines that have not been encountered in previous runs. In this cases the cache is grown, with the pipelines / shader programs added to it. If the application also chooses to save the contents (perhaps to the same file even), then both the old and new pipelines will get stored. Loading from and saving to the same file in every run allows an ever growing cache that stores all encountered pipelines and shader programs.</db:para>
<db:para>In practice the Qt pipeline cache can be expected to map to the following native graphics API features:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Vulkan - <db:link xlink:href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html">VkPipelineCache</db:link> - Saving the pipeline cache effectively stores the blob retrieved from <db:link xlink:href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPipelineCacheData.html">vkGetPipelineCacheData</db:link>, with additional metadata to safely identify the device and the driver since the pipeline cache blob is dependent on the exact driver.</db:para>
</db:listitem>
<db:listitem>
<db:para>Metal - <db:link xlink:href="https://developer.apple.com/documentation/metal/mtlbinaryarchive?language=objc">MTLBinaryArchive</db:link> - With pipeline cache saving enabled, Qt stores all render and compute pipelines encountered into an MTLBinaryArchive. Saving the pipeline cache stores the blob retrieved from the archive, with additional metadata to identify the device. <db:emphasis role="bold">Note:</db:emphasis> currently MTLBinaryArchive usage is disabled on macOS and iOS due to various issues on some hardware and OS versions.</db:para>
</db:listitem>
<db:listitem>
<db:para>OpenGL - There is no native concept of pipelines, the &quot;pipeline cache&quot; stores a collection of program binaries retrieved via <db:link xlink:href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml">glGetProgramBinary</db:link>. The program binaries are packaged into a single blob, with additional metadata to identify the device, driver, and its version that the binaries were retrieved from. Persistent caching of program binaries is not new in Qt: Qt 5 already had similar functionality in <db:link xlink:href="qopenglshaderprogram.xml">QOpenGLShaderProgram</db:link>, see <db:link xlink:href="qopenglshaderprogram.xml#addCacheableShaderFromSourceCode">addCacheableShaderFromSourceCode</db:link>() for example. In fact that mechanism is always active in Qt 6 as well when using Qt Quick with OpenGL. However, when using the new, graphics API independent pipeline cache abstraction provided here, the Qt 5 era program binary cache gets automatically disabled, since the same content is packaged in the &quot;pipeline cache&quot; now.</db:para>
</db:listitem>
<db:listitem>
<db:para>Direct 3D 11 - There is no native concept of pipelines or retrieving binaries for the second phase compilation (where the vendor independent, intermediate bytecode is compiled into the device specific instruction set). Drivers will typically employ their own caching system on that level. Instead, the Qt Quick &quot;pipeline cache&quot; is used to speed up cases where the shaders contain HLSL source code that needs to be compiled into the intermediate bytecode format first. This can present significant performance improvements in application and libraries that compose shader code at run time, because in subsequent runs the potentially expensive, uncached calls to <db:link xlink:href="https://docs.microsoft.com/en-us/windows/win32/api/d3dcompiler/nf-d3dcompiler-d3dcompile">D3DCompile()</db:link> can be avoided if the bytecode is already available for the encountered HLSL shader. A good example is Qt Quick 3D, where the runtime-generated shaders for materials imply having to deal with HLSL source code. Saving and reloading the Qt Quick pipeline cache can therefore bring considerable improvements in scenes with one or more <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> items in them. A counterexample may be Qt Quick itself: as most built-in shaders for 2D content ship with DirectX bytecode generated at build time, the cache is not going to present any significant improvements.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>All this is independent from the shader processing performed by the <db:link xlink:href="qtshadertools-index.xml">Qt Shader Tools</db:link> module and its command-line tools such as <db:code>qsb</db:code>. As an example, take Vulkan. Having the Vulkan-compatible GLSL source code compiled to SPIR-V either at offline or build time (directly via qsb or CMake) is good, because the expensive compilation from source form is avoided at run time. SPIR-V is however a vendor-independent intermediate format. At runtime, when constructing graphics or compute pipelines, there is likely another round of compilation happening, this time from the intermediate format to the vendor-specific instruction set of the GPU (and this may be dependent on certain state in the graphics pipeline and the render targets as well). The pipeline cache helps with this latter phase.</db:para>
<db:note>
<db:para>Many graphics API implementation employ their own persistent disk cache transparently to the applications. Using the pipeline cache feature of Qt Quick will likely provide improvements in this case, but the gains might be smaller.</db:para>
</db:note>
<db:para>Call <db:link xlink:href="qquickgraphicsconfiguration.xml#setPipelineCacheSaveFile">setPipelineCacheSaveFile</db:link>() and <db:link xlink:href="qquickgraphicsconfiguration.xml#setPipelineCacheLoadFile">setPipelineCacheLoadFile</db:link>() to control which files a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> or <db:link xlink:href="qquickview.xml">QQuickView</db:link> saves and loads the pipeline cache to/from.</db:para>
<db:para>To get an idea of the effects of enabling disk storage of the pipeline cache, enable the most important scenegraph and graphics logs either via the environment variable <db:code>QSG_INFO=1</db:code>, or both the <db:code>qt.scenegraph.general</db:code> and <db:code>qt.rhi.general</db:code> logging categories. When closing the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>, there is log message like the following:</db:para>
<db:programlisting language="cpp" role="bad">Total time spent on pipeline creation during the lifetime of the QRhi was 123 ms
</db:programlisting>
<db:para>This gives an approximate idea of how much time was spent in graphics and compute pipeline creation (which may include various stages of shader compilation) during the lifetime of the window.</db:para>
<db:para>When loading from a pipeline cache file is enabled, this is confirmed with a message:</db:para>
<db:programlisting language="cpp" role="bad">Attempting to seed pipeline cache from 'filename'
</db:programlisting>
<db:para>Similarly, to check if saving of the cache is successfully enabled, look for a message such as this:</db:para>
<db:programlisting language="cpp" role="bad">Writing pipeline cache contents to 'filename'
</db:programlisting>
</db:section>
<db:section xml:id="the-automatic-pipeline-cache">
<db:title>The Automatic Pipeline Cache</db:title>
<db:para>When no filename is provided for save and load, the automatic pipeline caching strategy is used. This involves storing data to the application-specific cache location of the system (<db:link xlink:href="qstandardpaths.xml#StandardLocation-enum">QStandardPaths::CacheLocation</db:link>).</db:para>
<db:para>This can be disabled by one of the following means:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Set the application attribute <db:link xlink:href="qt.xml#ApplicationAttribute-enum">Qt::AA_DisableShaderDiskCache</db:link>. (completely disables the automatic storage)</db:para>
</db:listitem>
<db:listitem>
<db:para>Set the environment variable QT_DISABLE_SHADER_DISK_CACHE to a non-zero value. (completely disables the automatic storage)</db:para>
</db:listitem>
<db:listitem>
<db:para>Set the environment variable QSG_RHI_DISABLE_SHADER_DISK_CACHE to a non-zero value. (completely disables the automatic storage)</db:para>
</db:listitem>
<db:listitem>
<db:para>Call setAutomaticPiplineCache() with the enable argument set to false. (completely disables the automatic storage)</db:para>
</db:listitem>
<db:listitem>
<db:para>Set a filename by calling <db:link xlink:href="qquickgraphicsconfiguration.xml#setPipelineCacheLoadFile">setPipelineCacheLoadFile</db:link>(). (only disables loading from the automatic storage, prefering the specified file instead)</db:para>
</db:listitem>
<db:listitem>
<db:para>Set a filename by calling <db:link xlink:href="qquickgraphicsconfiguration.xml#setPipelineCacheSaveFile">setPipelineCacheSaveFile</db:link>(). (only disables writing to the automatic storage, prefering the specified file instead)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The first two are existing mechanisms that are used since Qt 5.9 to control the OpenGL program binary cache. For compatibility and familiarity the same attribute and environment variable are supported for Qt 6's enhanced pipeline cache.</db:para>
<db:para>The automatic pipeline cache uses a single file per application, but a different one for each RHI backend (graphics API). This means that changing to another graphics API in the next run of the application will not lead to losing the pipeline cache generated in the previous run. Applications with multiple <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> instances shown simultaneously may however not benefit 100% since the automatic cache can only store the data collected from one RHI object at a time. (and with the default <db:code>threaded</db:code> render loop each window has its own RHI as rendering operates independently on dedicated threads). To fully benefit from the disk cache in application with multiple windows, prefer setting the filename explicitly, per-window via <db:link xlink:href="qquickgraphicsconfiguration.xml#setPipelineCacheSaveFile">setPipelineCacheSaveFile</db:link>().</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#setGraphicsConfiguration">QQuickWindow::setGraphicsConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:member>
<db:member><db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QQuickGraphicsConfiguration">
<db:title>QQuickGraphicsConfiguration::QQuickGraphicsConfiguration()</db:title>
<db:constructorsynopsis>
<db:methodname>QQuickGraphicsConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickGraphicsConfiguration()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a default <db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link> that does not specify any additional settings for the scene graph to take into account.</db:para>
</db:section>
<db:section xml:id="dtor.QQuickGraphicsConfiguration">
<db:title>QQuickGraphicsConfiguration::~QQuickGraphicsConfiguration()</db:title>
<db:destructorsynopsis>
<db:methodname>~QQuickGraphicsConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QQuickGraphicsConfiguration()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destructor.</db:para>
</db:section>
<db:section xml:id="deviceExtensions">
<db:title>QByteArrayList QQuickGraphicsConfiguration::deviceExtensions() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArrayList</db:type>
<db:methodname>deviceExtensions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArrayList deviceExtensions() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of the requested additional device extensions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#setDeviceExtensions">setDeviceExtensions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isAutomaticPipelineCacheEnabled">
<db:title>[since 6.5] bool QQuickGraphicsConfiguration::isAutomaticPipelineCacheEnabled() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isAutomaticPipelineCacheEnabled</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isAutomaticPipelineCacheEnabled() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the automatic pipeline cache is enabled.</db:para>
<db:para>By default this is true, unless certain application attributes or environment variables are set. See <db:link xlink:href="qquickgraphicsconfiguration.xml#the-automatic-pipeline-cache">The Automatic Pipeline Cache</db:link> for more information.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#setAutomaticPipelineCache">setAutomaticPipelineCache</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isDebugLayerEnabled">
<db:title>bool QQuickGraphicsConfiguration::isDebugLayerEnabled() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isDebugLayerEnabled</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isDebugLayerEnabled() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the debug/validation layers are to be enabled.</db:para>
<db:para>By default the value is false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#setDebugLayer">setDebugLayer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isDebugMarkersEnabled">
<db:title>bool QQuickGraphicsConfiguration::isDebugMarkersEnabled() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isDebugMarkersEnabled</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isDebugMarkersEnabled() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if debug markers are enabled.</db:para>
<db:para>By default the value is false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#setDebugMarkers">setDebugMarkers</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isDepthBufferEnabledFor2D">
<db:title>bool QQuickGraphicsConfiguration::isDepthBufferEnabledFor2D() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isDepthBufferEnabledFor2D</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isDepthBufferEnabledFor2D() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if depth buffer usage is enabled for 2D content.</db:para>
<db:para>By default the value is true, unless the <db:code>QSG_NO_DEPTH_BUFFER</db:code> environment variable is set.</db:para>
</db:section>
<db:section xml:id="pipelineCacheLoadFile">
<db:title>QString QQuickGraphicsConfiguration::pipelineCacheLoadFile() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>pipelineCacheLoadFile</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString pipelineCacheLoadFile() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the currently set filename for loading the pipeline cache.</db:para>
<db:para>By default the value is an empty string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#setPipelineCacheLoadFile">setPipelineCacheLoadFile</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pipelineCacheSaveFile">
<db:title>QString QQuickGraphicsConfiguration::pipelineCacheSaveFile() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>pipelineCacheSaveFile</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString pipelineCacheSaveFile() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the currently set filename for storing the pipeline cache.</db:para>
<db:para>By default the value is an empty string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#setPipelineCacheSaveFile">setPipelineCacheSaveFile</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="preferredInstanceExtensions">
<db:title>[static, since 6.1] QByteArrayList QQuickGraphicsConfiguration::preferredInstanceExtensions()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArrayList</db:type>
<db:methodname>preferredInstanceExtensions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArrayList preferredInstanceExtensions()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of Vulkan instance extensions Qt Quick prefers to have enabled on the VkInstance.</db:para>
<db:para>In most cases Qt Quick is responsible for creating a <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link>. This function is not relevant then. On the other hand, when using <db:link xlink:href="qquickrendercontrol.xml">QQuickRenderControl</db:link> in combination with Vulkan-based rendering, it is the application's responsibility to create a <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> and associate it with the (offscreen) <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>. In this case, it is expected that the application queries the list of instance extensions to enable, and passes them to <db:link xlink:href="qvulkaninstance.xml#setExtensions">QVulkanInstance::setExtensions</db:link>() before calling <db:link xlink:href="qvulkaninstance.xml#create">QVulkanInstance::create</db:link>().</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
</db:section>
<db:section xml:id="prefersSoftwareDevice">
<db:title>bool QQuickGraphicsConfiguration::prefersSoftwareDevice() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>prefersSoftwareDevice</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool prefersSoftwareDevice() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if a software rasterizer-based graphics device is prioritized.</db:para>
<db:para>By default the value is false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#setPreferSoftwareDevice">setPreferSoftwareDevice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAutomaticPipelineCache">
<db:title>[since 6.5] void QQuickGraphicsConfiguration::setAutomaticPipelineCache(bool <db:emphasis>enable</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setAutomaticPipelineCache</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enable</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setAutomaticPipelineCache(bool enable)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Changes the usage of the automatic pipeline cache based on <db:code role="parameter">enable</db:code>.</db:para>
<db:para>The default value is true, unless certain application attributes or environment variables are set. See <db:link xlink:href="qquickgraphicsconfiguration.xml#the-automatic-pipeline-cache">The Automatic Pipeline Cache</db:link> for more information.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#isAutomaticPipelineCacheEnabled">isAutomaticPipelineCacheEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDebugLayer">
<db:title>[since 6.5] void QQuickGraphicsConfiguration::setDebugLayer(bool <db:emphasis>enable</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDebugLayer</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enable</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDebugLayer(bool enable)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Enables the graphics API implementation's debug or validation layers, if available.</db:para>
<db:para>In practice this is supported with Vulkan and Direct 3D 11, assuming the necessary support (validation layers, Windows SDK) is installed and available at runtime. When <db:code role="parameter">enable</db:code> is true, Qt will attempt to enable the standard validation layer on the VkInstance, or set <db:code>D3D11_CREATE_DEVICE_DEBUG</db:code> on the graphics device.</db:para>
<db:para>For Metal on macOS, set the environment variable <db:code>METAL_DEVICE_WRAPPER_TYPE=1</db:code> instead before launching the application.</db:para>
<db:para>Calling this function with <db:code role="parameter">enable</db:code> set to true is equivalent to setting the environment variable <db:code>QSG_RHI_DEBUG_LAYER</db:code> to a non-zero value.</db:para>
<db:para>The default value is false.</db:para>
<db:note>
<db:para>Enabling debug or validation layers may have a non-insignificant performance impact. Shipping applications to production with the flag enabled is strongly discouraged.</db:para>
</db:note>
<db:note>
<db:para>Be aware that due to differences in the design of the underlying graphics APIs, this setting cannot always be a per-<db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> setting, even though each <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> has their own <db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link>. With Vulkan in particular, the instance object (VkInstance) is only created once and then used by all windows in the application. Therefore, enabling the validation layer is something that affects all windows. This also means that attempting to enable validation via a window that only gets shown after some other windows have already started rendering has no effect with Vulkan. Other APIs, such as D3D11, expose the debug layer concept as a per-device (ID3D11Device) setting, and so it is controlled on a true per-window basis (assuming the scenegraph render loop uses a dedicated graphics device/context for each <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>).</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#isDebugLayerEnabled">isDebugLayerEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDebugMarkers">
<db:title>[since 6.5] void QQuickGraphicsConfiguration::setDebugMarkers(bool <db:emphasis>enable</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDebugMarkers</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enable</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDebugMarkers(bool enable)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Where applicable, <db:code role="parameter">enable</db:code> controls inserting debug markers and object names into the graphics command stream.</db:para>
<db:para>Some frameworks, such as Qt Quick 3D, have the ability to annotate the graphics objects they create (buffers, textures) with names and also indicate the beginning and end of render passes in the command buffer. These are then visible in frame captures made with tools like <db:link xlink:href="https://renderdoc.org/">RenderDoc</db:link> or XCode.</db:para>
<db:para>Graphics APIs where this can be expected to be supported are Vulkan (if VK_EXT_debug_utils is available), Direct 3D 11, and Metal.</db:para>
<db:para>Calling this function with <db:code role="parameter">enable</db:code> set to true is equivalent to setting the environment variable <db:code>QSG_RHI_PROFILE</db:code> to a non-zero value.</db:para>
<db:para>The default value is false.</db:para>
<db:note>
<db:para>Enabling debug markers may have a performance impact. Shipping applications to production with the flag enabled is not recommended.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#isDebugMarkersEnabled">isDebugMarkersEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDepthBufferFor2D">
<db:title>void QQuickGraphicsConfiguration::setDepthBufferFor2D(bool <db:emphasis>enable</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDepthBufferFor2D</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enable</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDepthBufferFor2D(bool enable)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the usage of depth buffer for 2D content to <db:code role="parameter">enable</db:code>. When disabled, the Qt Quick scene graph never writes into the depth buffer.</db:para>
<db:para>By default the value is true, unless the <db:code>QSG_NO_DEPTH_BUFFER</db:code> environment variable is set.</db:para>
<db:para>The default value of true is the most optimal setting for the vast majority of scenes. Disabling depth buffer usage reduces the efficiency of the scene graph's batching.</db:para>
<db:para>There are cases however, when allowing the 2D content write to the depth buffer is not ideal. Consider a 3D scene as an &quot;overlay&quot; on top the 2D scene, rendered via Qt Quick 3D using a <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> with <db:link xlink:href="qml-qtquick3d-view3d.xml#renderMode-prop">renderMode</db:link> set to <db:code>Overlay</db:code>. In this case, having the depth buffer filled by 2D content can cause unexpected results. This is because the way the 2D scene graph renderer generates and handles depth values is not necessarily compatible with how a 3D scene works. This may end up in depth value clashes, collisions, and unexpected depth test failures. Therefore, the robust approach here is to call this function with <db:code role="parameter">enable</db:code> set to false, and disable depth buffer writes for the 2D content in the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>.</db:para>
<db:note>
<db:para>This flag is not fully identical to setting the <db:code>QSG_NO_DEPTH_BUFFER</db:code> environment variable. This flag does not control the depth-stencil buffers' presence. It is rather relevant for the rendering pipeline. To force not having depth/stencil attachments at all, set <db:code>QSG_NO_DEPTH_BUFFER</db:code> and <db:code>QSG_NO_STENCIL_BUFFER</db:code>. Be aware however that such a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>, and any Item layers in it, may then become incompatible with items, such as <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> with certain operating modes, because 3D content requires a depth buffer. Calling this function is always safe, but can mean that resources, such as depth buffers, are created even though they are not actively used.</db:para>
</db:note>
</db:section>
<db:section xml:id="setDeviceExtensions">
<db:title>void QQuickGraphicsConfiguration::setDeviceExtensions(const QByteArrayList &amp;<db:emphasis>extensions</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDeviceExtensions</db:methodname>
<db:methodparam>
<db:type>const QByteArrayList &amp;</db:type>
<db:parameter>extensions</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDeviceExtensions(const QByteArrayList &amp;extensions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the list of additional <db:code role="parameter">extensions</db:code> to enable on the graphics device (such as, the <db:code>VkDevice</db:code>).</db:para>
<db:para>When rendering with a graphics API where the concept is not applicable, <db:code role="parameter">extensions</db:code> will be ignored.</db:para>
<db:note>
<db:para>The list specifies additional, extra extensions. Qt Quick always enables extensions that are required by the scene graph.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#deviceExtensions">deviceExtensions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPipelineCacheLoadFile">
<db:title>[since 6.5] void QQuickGraphicsConfiguration::setPipelineCacheLoadFile(const QString &amp;<db:emphasis>filename</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPipelineCacheLoadFile</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>filename</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPipelineCacheLoadFile(const QString &amp;filename)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the <db:code role="parameter">filename</db:code> where the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is expected to load the initial contents of its graphics/compute pipeline cache from. The default value is empty, which means pipeline cache loading is disabled.</db:para>
<db:para>See <db:link xlink:href="qquickgraphicsconfiguration.xml#pipeline-cache-save-and-load">Pipeline Cache Save and Load</db:link> for a discussion on pipeline caches.</db:para>
<db:para>Persistently storing the pipeline cache can lead to performance improvements in future runs of the application since expensive shader compilation and pipeline construction steps may be avoided.</db:para>
<db:para>If and when the loading of the file's contents happens is not defined, apart from that it will happen at some point during the initialization of the scenegraph of the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>. Therefore, the file must continue to exist after calling this function. <db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link> only stores the filename, it cannot perform any actual I/O and graphics operations on its own. The real work is going to happen later on, possibly on another thread.</db:para>
<db:para>When running with a graphics API where retrieving and reloading the pipeline cache (or shader/program binaries) is not applicable or not supported, calling this function has no effect.</db:para>
<db:para>Calling this function is mostly equivalent to setting the environment variable <db:code>QSG_RHI_PIPELINE_CACHE_LOAD</db:code> to <db:code role="parameter">filename</db:code>, with one important difference: this function controls the pipeline cache storage for the associated <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> only. Applications with multiple <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> or <db:link xlink:href="qquickview.xml">QQuickView</db:link> instances can therefore store and later reload the cache contents via files dedicated to each window. The environment variable does not allow this.</db:para>
<db:note>
<db:para>If the data in the file does not match the graphics device and driver version at run time, the contents will be ignored, transparently to the application. This applies to a number of graphics APIs, and the necessary checks are taken care of by Qt. There are exceptions, most notably Direct 3D 11, where the &quot;pipeline cache&quot; is used only to store the results of runtime HLSL-&gt;DXBC compilation and is therefore device and vendor independent.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#pipelineCacheLoadFile">pipelineCacheLoadFile</db:link>()</db:member>
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#setPipelineCacheSaveFile">setPipelineCacheSaveFile</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPipelineCacheSaveFile">
<db:title>[since 6.5] void QQuickGraphicsConfiguration::setPipelineCacheSaveFile(const QString &amp;<db:emphasis>filename</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPipelineCacheSaveFile</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>filename</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPipelineCacheSaveFile(const QString &amp;filename)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the <db:code role="parameter">filename</db:code> where the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is expected to store its graphics/compute pipeline cache contents. The default value is empty, which means pipeline cache loading is disabled.</db:para>
<db:para>See <db:link xlink:href="qquickgraphicsconfiguration.xml#pipeline-cache-save-and-load">Pipeline Cache Save and Load</db:link> for a discussion on pipeline caches.</db:para>
<db:para>Persistently storing the pipeline cache can lead to performance improvements in future runs of the application since expensive shader compilation and pipeline construction steps may be avoided.</db:para>
<db:para>If and when the writing of the file happens is not defined. It will likely happen at some point when tearing down the scenegraph due to closing the window. Therefore, applications should not assume availability of the file until the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> is fully destructed. <db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link> only stores the filename, it does not perform any actual I/O and graphics operations on its own.</db:para>
<db:para>When running with a graphics API where retrieving the pipeline cache (or shader/program binaries) is not applicable or not supported, calling this function has no effect.</db:para>
<db:para>Calling this function is mostly equivalent to setting the environment variable <db:code>QSG_RHI_PIPELINE_CACHE_SAVE</db:code> to <db:code role="parameter">filename</db:code>, with one important difference: this function controls the pipeline cache storage for the associated <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> only. Applications with multiple <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> or <db:link xlink:href="qquickview.xml">QQuickView</db:link> instances can therefore store and later reload the cache contents via files dedicated to each window. The environment variable does not allow this.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#pipelineCacheSaveFile">pipelineCacheSaveFile</db:link>()</db:member>
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#pipelineCacheLoadFile">pipelineCacheLoadFile</db:link>()</db:member>
<db:member>setPipelineCacheSaveFile()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPreferSoftwareDevice">
<db:title>[since 6.5] void QQuickGraphicsConfiguration::setPreferSoftwareDevice(bool <db:emphasis>enable</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPreferSoftwareDevice</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enable</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPreferSoftwareDevice(bool enable)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Requests choosing an adapter or physical device that uses software-based rasterization. Applicable only when the underlying API has support for enumerating adapters (for example, Direct 3D or Vulkan), and is ignored otherwise.</db:para>
<db:para>If the graphics API implementation has no such graphics adapter or physical device available, the request is ignored. With Direct 3D it can be expected that a <db:link xlink:href="https://docs.microsoft.com/en-us/windows/win32/direct3darticles/directx-warp">WARP</db:link>-based rasterizer is always available. With Vulkan, the flag only has an effect if Mesa's <db:code>lavapipe</db:code>, or some other physical device reporting <db:code>VK_PHYSICAL_DEVICE_TYPE_CPU</db:code> is available.</db:para>
<db:para>Calling this function with <db:code role="parameter">enable</db:code> set to true is equivalent to setting the environment variable <db:code>QSG_RHI_PREFER_SOFTWARE_RENDERER</db:code> to a non-zero value.</db:para>
<db:para>The default value is false.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickgraphicsconfiguration.xml#prefersSoftwareDevice">prefersSoftwareDevice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
