<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Icons Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Icons example shows how <db:link xlink:href="qicon.xml">QIcon</db:link> can generate pixmaps reflecting an icon's state, mode and size.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &lt;QtWidgets&gt;

#include &quot;iconpreviewarea.h&quot;
#include &quot;iconsizespinbox.h&quot;
#include &quot;imagedelegate.h&quot;
#include &quot;mainwindow.h&quot;

enum { OtherSize = QStyle::PM_CustomBase };

MainWindow::MainWindow()
{
    QWidget *centralWidget = new QWidget(this);
    setCentralWidget(centralWidget);

    createActions();

    QGridLayout *mainLayout = new QGridLayout(centralWidget);

    QGroupBox *previewGroupBox = new QGroupBox(tr(&quot;Preview&quot;));
    previewArea = new IconPreviewArea(previewGroupBox);
    QVBoxLayout *previewLayout = new QVBoxLayout(previewGroupBox);
    previewLayout-&gt;addWidget(previewArea);

    mainLayout-&gt;addWidget(previewGroupBox, 0, 0, 1, 2);
    mainLayout-&gt;addWidget(createImagesGroupBox(), 1, 0);
    QVBoxLayout *vBox = new QVBoxLayout;
    vBox-&gt;addWidget(createIconSizeGroupBox());
    vBox-&gt;addWidget(createHighDpiIconSizeGroupBox());
    vBox-&gt;addItem(new QSpacerItem(0, 0, QSizePolicy::Ignored, QSizePolicy::MinimumExpanding));
    mainLayout-&gt;addLayout(vBox, 1, 1);
    createContextMenu();

    setWindowTitle(tr(&quot;Icons&quot;));
    checkCurrentStyle();
    sizeButtonGroup-&gt;button(OtherSize)-&gt;click();
}

void MainWindow::show()
{
    QMainWindow::show();
    connect(windowHandle(), &amp;QWindow::screenChanged, this, &amp;MainWindow::screenChanged);
    screenChanged();
}

void MainWindow::about()
{
    QMessageBox::about(this, tr(&quot;About Icons&quot;),
            tr(&quot;The &lt;b&gt;Icons&lt;/b&gt; example illustrates how Qt renders an icon in &quot;
               &quot;different modes (active, normal, disabled, and selected) and &quot;
               &quot;states (on and off) based on a set of images.&quot;));
}

void MainWindow::changeStyle(bool checked)
{
    if (!checked)
        return;

    const QAction *action = qobject_cast&lt;QAction *&gt;(sender());
    QStyle *style = QStyleFactory::create(action-&gt;data().toString());
    Q_ASSERT(style);
    QApplication::setStyle(style);

    foreach (QAbstractButton *button, sizeButtonGroup-&gt;buttons()) {
        const QStyle::PixelMetric metric = static_cast&lt;QStyle::PixelMetric&gt;(sizeButtonGroup-&gt;id(button));
        const int value = style-&gt;pixelMetric(metric);
        switch (metric) {
        case QStyle::PM_SmallIconSize:
            button-&gt;setText(tr(&quot;Small (%1 x %1)&quot;).arg(value));
            break;
        case QStyle::PM_LargeIconSize:
            button-&gt;setText(tr(&quot;Large (%1 x %1)&quot;).arg(value));
            break;
        case QStyle::PM_ToolBarIconSize:
            button-&gt;setText(tr(&quot;Toolbars (%1 x %1)&quot;).arg(value));
            break;
        case QStyle::PM_ListViewIconSize:
            button-&gt;setText(tr(&quot;List views (%1 x %1)&quot;).arg(value));
            break;
        case QStyle::PM_IconViewIconSize:
            button-&gt;setText(tr(&quot;Icon views (%1 x %1)&quot;).arg(value));
            break;
        case QStyle::PM_TabBarIconSize:
            button-&gt;setText(tr(&quot;Tab bars (%1 x %1)&quot;).arg(value));
            break;
        default:
            break;
        }
    }

    triggerChangeSize();
}

void MainWindow::changeSize(int id, bool checked)
{
    if (!checked)
        return;

    const bool other = id == int(OtherSize);
    const int extent = other
        ? otherSpinBox-&gt;value()
        : QApplication::style()-&gt;pixelMetric(static_cast&lt;QStyle::PixelMetric&gt;(id));

    previewArea-&gt;setSize(QSize(extent, extent));
    otherSpinBox-&gt;setEnabled(other);
}

void MainWindow::triggerChangeSize()
{
    changeSize(sizeButtonGroup-&gt;checkedId(), true);
}

void MainWindow::changeIcon()
{
    QIcon icon;

    for (int row = 0; row &lt; imagesTable-&gt;rowCount(); ++row) {
        const QTableWidgetItem *fileItem = imagesTable-&gt;item(row, 0);
        const QTableWidgetItem *modeItem = imagesTable-&gt;item(row, 1);
        const QTableWidgetItem *stateItem = imagesTable-&gt;item(row, 2);

        if (fileItem-&gt;checkState() == Qt::Checked) {
            const int modeIndex = IconPreviewArea::iconModeNames().indexOf(modeItem-&gt;text());
            Q_ASSERT(modeIndex &gt;= 0);
            const int stateIndex = IconPreviewArea::iconStateNames().indexOf(stateItem-&gt;text());
            Q_ASSERT(stateIndex &gt;= 0);
            const QIcon::Mode mode = IconPreviewArea::iconModes().at(modeIndex);
            const QIcon::State state = IconPreviewArea::iconStates().at(stateIndex);

            const QString fileName = fileItem-&gt;data(Qt::UserRole).toString();
            QImage image(fileName);
            if (!image.isNull())
                icon.addPixmap(QPixmap::fromImage(image), mode, state);
        }
    }

    previewArea-&gt;setIcon(icon);
}

void MainWindow::addSampleImages()
{
    addImages(QLatin1String(SRCDIR) + QLatin1String(&quot;/images&quot;));
}

void MainWindow::addOtherImages()
{
    static bool firstInvocation = true;
    QString directory;
    if (firstInvocation) {
        firstInvocation = false;
        directory = QStandardPaths::standardLocations(QStandardPaths::PicturesLocation).value(0, QString());
    }
    addImages(directory);
}

void MainWindow::addImages(const QString &amp;directory)
{
    QFileDialog fileDialog(this, tr(&quot;Open Images&quot;), directory);
    QStringList mimeTypeFilters;
    foreach (const QByteArray &amp;mimeTypeName, QImageReader::supportedMimeTypes())
        mimeTypeFilters.append(mimeTypeName);
    mimeTypeFilters.sort();
    fileDialog.setMimeTypeFilters(mimeTypeFilters);
    fileDialog.selectMimeTypeFilter(QLatin1String(&quot;image/png&quot;));
    fileDialog.setAcceptMode(QFileDialog::AcceptOpen);
    fileDialog.setFileMode(QFileDialog::ExistingFiles);
    if (!nativeFileDialogAct-&gt;isChecked())
        fileDialog.setOption(QFileDialog::DontUseNativeDialog);
    if (fileDialog.exec() == QDialog::Accepted)
        loadImages(fileDialog.selectedFiles());
}

void MainWindow::loadImages(const QStringList &amp;fileNames)
{
    foreach (const QString &amp;fileName, fileNames) {
        const int row = imagesTable-&gt;rowCount();
        imagesTable-&gt;setRowCount(row + 1);
        const QFileInfo fileInfo(fileName);
        const QString imageName = fileInfo.baseName();
        const QString fileName2x = fileInfo.absolutePath()
            + QLatin1Char('/') + imageName + QLatin1String(&quot;@2x.&quot;) + fileInfo.suffix();
        const QFileInfo fileInfo2x(fileName2x);
        const QImage image(fileName);
        const QString toolTip =
            tr(&quot;Directory: %1\nFile: %2\nFile@2x: %3\nSize: %4x%5&quot;)
               .arg(QDir::toNativeSeparators(fileInfo.absolutePath()), fileInfo.fileName())
               .arg(fileInfo2x.exists() ? fileInfo2x.fileName() : tr(&quot;&lt;None&gt;&quot;))
               .arg(image.width()).arg(image.height());
        QTableWidgetItem *fileItem = new QTableWidgetItem(imageName);
        fileItem-&gt;setData(Qt::UserRole, fileName);
        fileItem-&gt;setIcon(QPixmap::fromImage(image));
        fileItem-&gt;setFlags((fileItem-&gt;flags() | Qt::ItemIsUserCheckable) &amp; ~Qt::ItemIsEditable);
        fileItem-&gt;setToolTip(toolTip);

        QIcon::Mode mode = QIcon::Normal;
        QIcon::State state = QIcon::Off;
        if (guessModeStateAct-&gt;isChecked()) {
            if (imageName.contains(QLatin1String(&quot;_act&quot;), Qt::CaseInsensitive))
                mode = QIcon::Active;
            else if (imageName.contains(QLatin1String(&quot;_dis&quot;), Qt::CaseInsensitive))
                mode = QIcon::Disabled;
            else if (imageName.contains(QLatin1String(&quot;_sel&quot;), Qt::CaseInsensitive))
                mode = QIcon::Selected;

            if (imageName.contains(QLatin1String(&quot;_on&quot;), Qt::CaseInsensitive))
                state = QIcon::On;
        }

        imagesTable-&gt;setItem(row, 0, fileItem);
        QTableWidgetItem *modeItem =
            new QTableWidgetItem(IconPreviewArea::iconModeNames().at(IconPreviewArea::iconModes().indexOf(mode)));
        modeItem-&gt;setToolTip(toolTip);
        imagesTable-&gt;setItem(row, 1, modeItem);
        QTableWidgetItem *stateItem =
            new QTableWidgetItem(IconPreviewArea::iconStateNames().at(IconPreviewArea::iconStates().indexOf(state)));
        stateItem-&gt;setToolTip(toolTip);
        imagesTable-&gt;setItem(row, 2, stateItem);
        imagesTable-&gt;openPersistentEditor(modeItem);
        imagesTable-&gt;openPersistentEditor(stateItem);

        fileItem-&gt;setCheckState(Qt::Checked);
    }
}

void MainWindow::useHighDpiPixmapsChanged(int checkState)
{
    QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps, checkState == Qt::Checked);
    changeIcon();
}

void MainWindow::removeAllImages()
{
    imagesTable-&gt;setRowCount(0);
    changeIcon();
}

QWidget *MainWindow::createImagesGroupBox()
{
    QGroupBox *imagesGroupBox = new QGroupBox(tr(&quot;Images&quot;));

    imagesTable = new QTableWidget;
    imagesTable-&gt;setSelectionMode(QAbstractItemView::NoSelection);
    imagesTable-&gt;setItemDelegate(new ImageDelegate(this));

    QStringList labels;
    labels &lt;&lt; tr(&quot;Image&quot;) &lt;&lt; tr(&quot;Mode&quot;) &lt;&lt; tr(&quot;State&quot;);

    imagesTable-&gt;horizontalHeader()-&gt;setDefaultSectionSize(90);
    imagesTable-&gt;setColumnCount(3);
    imagesTable-&gt;setHorizontalHeaderLabels(labels);
    imagesTable-&gt;horizontalHeader()-&gt;setSectionResizeMode(0, QHeaderView::Stretch);
    imagesTable-&gt;horizontalHeader()-&gt;setSectionResizeMode(1, QHeaderView::Fixed);
    imagesTable-&gt;horizontalHeader()-&gt;setSectionResizeMode(2, QHeaderView::Fixed);
    imagesTable-&gt;verticalHeader()-&gt;hide();

    connect(imagesTable, &amp;QTableWidget::itemChanged,
            this, &amp;MainWindow::changeIcon);

    QVBoxLayout *layout = new QVBoxLayout(imagesGroupBox);
    layout-&gt;addWidget(imagesTable);
    return imagesGroupBox;
}

QWidget *MainWindow::createIconSizeGroupBox()
{
    QGroupBox *iconSizeGroupBox = new QGroupBox(tr(&quot;Icon Size&quot;));

    sizeButtonGroup = new QButtonGroup(this);
    sizeButtonGroup-&gt;setExclusive(true);

    typedef void (QButtonGroup::*QButtonGroupIntBoolSignal)(int, bool);
    connect(sizeButtonGroup, static_cast&lt;QButtonGroupIntBoolSignal&gt;(&amp;QButtonGroup::buttonToggled),
            this, &amp;MainWindow::changeSize);

    QRadioButton *smallRadioButton = new QRadioButton;
    sizeButtonGroup-&gt;addButton(smallRadioButton, QStyle::PM_SmallIconSize);
    QRadioButton *largeRadioButton = new QRadioButton;
    sizeButtonGroup-&gt;addButton(largeRadioButton, QStyle::PM_LargeIconSize);
    QRadioButton *toolBarRadioButton = new QRadioButton;
    sizeButtonGroup-&gt;addButton(toolBarRadioButton, QStyle::PM_ToolBarIconSize);
    QRadioButton *listViewRadioButton = new QRadioButton;
    sizeButtonGroup-&gt;addButton(listViewRadioButton, QStyle::PM_ListViewIconSize);
    QRadioButton *iconViewRadioButton = new QRadioButton;
    sizeButtonGroup-&gt;addButton(iconViewRadioButton, QStyle::PM_IconViewIconSize);
    QRadioButton *tabBarRadioButton = new QRadioButton;
    sizeButtonGroup-&gt;addButton(tabBarRadioButton, QStyle::PM_TabBarIconSize);
    QRadioButton *otherRadioButton = new QRadioButton(tr(&quot;Other:&quot;));
    sizeButtonGroup-&gt;addButton(otherRadioButton, OtherSize);
    otherSpinBox = new IconSizeSpinBox;
    otherSpinBox-&gt;setRange(8, 256);
    const QString spinBoxToolTip =
        tr(&quot;Enter a custom size within %1..%2&quot;)
           .arg(otherSpinBox-&gt;minimum()).arg(otherSpinBox-&gt;maximum());
    otherSpinBox-&gt;setValue(64);
    otherSpinBox-&gt;setToolTip(spinBoxToolTip);
    otherRadioButton-&gt;setToolTip(spinBoxToolTip);

    typedef void (QSpinBox::*QSpinBoxIntSignal)(int);
    connect(otherSpinBox, static_cast&lt;QSpinBoxIntSignal&gt;(&amp;QSpinBox::valueChanged),
            this, &amp;MainWindow::triggerChangeSize);

    QHBoxLayout *otherSizeLayout = new QHBoxLayout;
    otherSizeLayout-&gt;addWidget(otherRadioButton);
    otherSizeLayout-&gt;addWidget(otherSpinBox);
    otherSizeLayout-&gt;addStretch();

    QGridLayout *layout = new QGridLayout(iconSizeGroupBox);
    layout-&gt;addWidget(smallRadioButton, 0, 0);
    layout-&gt;addWidget(largeRadioButton, 1, 0);
    layout-&gt;addWidget(toolBarRadioButton, 2, 0);
    layout-&gt;addWidget(listViewRadioButton, 0, 1);
    layout-&gt;addWidget(iconViewRadioButton, 1, 1);
    layout-&gt;addWidget(tabBarRadioButton, 2, 1);
    layout-&gt;addLayout(otherSizeLayout, 3, 0, 1, 2);
    layout-&gt;setRowStretch(4, 1);
    return iconSizeGroupBox;
}

void MainWindow::screenChanged()
{
    devicePixelRatioLabel-&gt;setText(QString::number(devicePixelRatioF()));
    if (const QWindow *window = windowHandle()) {
        const QScreen *screen = window-&gt;screen();
        const QString screenDescription =
            tr(&quot;\&quot;%1\&quot; (%2x%3)&quot;).arg(screen-&gt;name())
               .arg(screen-&gt;geometry().width()).arg(screen-&gt;geometry().height());
        screenNameLabel-&gt;setText(screenDescription);
    }
    changeIcon();
}

QWidget *MainWindow::createHighDpiIconSizeGroupBox()
{
    QGroupBox *highDpiGroupBox = new QGroupBox(tr(&quot;High DPI Scaling&quot;));
    QFormLayout *layout = new QFormLayout(highDpiGroupBox);
    devicePixelRatioLabel = new QLabel(highDpiGroupBox);
    screenNameLabel = new QLabel(highDpiGroupBox);
    layout-&gt;addRow(tr(&quot;Screen:&quot;), screenNameLabel);
    layout-&gt;addRow(tr(&quot;Device pixel ratio:&quot;), devicePixelRatioLabel);
    QCheckBox *highDpiPixmapsCheckBox = new QCheckBox(QLatin1String(&quot;Qt::AA_UseHighDpiPixmaps&quot;));
    highDpiPixmapsCheckBox-&gt;setChecked(QCoreApplication::testAttribute(Qt::AA_UseHighDpiPixmaps));
    connect(highDpiPixmapsCheckBox, &amp;QCheckBox::stateChanged, this, &amp;MainWindow::useHighDpiPixmapsChanged);
    layout-&gt;addRow(highDpiPixmapsCheckBox);
    return highDpiGroupBox;
}

void MainWindow::createActions()
{
    QMenu *fileMenu = menuBar()-&gt;addMenu(tr(&quot;&amp;File&quot;));

    addSampleImagesAct = new QAction(tr(&quot;Add &amp;Sample Images...&quot;), this);
    addSampleImagesAct-&gt;setShortcut(tr(&quot;Ctrl+A&quot;));
    connect(addSampleImagesAct, &amp;QAction::triggered, this, &amp;MainWindow::addSampleImages);
    fileMenu-&gt;addAction(addSampleImagesAct);

    addOtherImagesAct = new QAction(tr(&quot;&amp;Add Images...&quot;), this);
    addOtherImagesAct-&gt;setShortcut(QKeySequence::Open);
    connect(addOtherImagesAct, &amp;QAction::triggered, this, &amp;MainWindow::addOtherImages);
    fileMenu-&gt;addAction(addOtherImagesAct);

    removeAllImagesAct = new QAction(tr(&quot;&amp;Remove All Images&quot;), this);
    removeAllImagesAct-&gt;setShortcut(tr(&quot;Ctrl+R&quot;));
    connect(removeAllImagesAct, &amp;QAction::triggered,
            this, &amp;MainWindow::removeAllImages);
    fileMenu-&gt;addAction(removeAllImagesAct);

    fileMenu-&gt;addSeparator();

    QAction *exitAct = fileMenu-&gt;addAction(tr(&quot;&amp;Quit&quot;), this, &amp;QWidget::close);
    exitAct-&gt;setShortcuts(QKeySequence::Quit);

    QMenu *viewMenu = menuBar()-&gt;addMenu(tr(&quot;&amp;View&quot;));

    styleActionGroup = new QActionGroup(this);
    foreach (const QString &amp;styleName, QStyleFactory::keys()) {
        QAction *action = new QAction(tr(&quot;%1 Style&quot;).arg(styleName), styleActionGroup);
        action-&gt;setData(styleName);
        action-&gt;setCheckable(true);
        connect(action, &amp;QAction::triggered, this, &amp;MainWindow::changeStyle);
        viewMenu-&gt;addAction(action);
    }

    QMenu *settingsMenu = menuBar()-&gt;addMenu(tr(&quot;&amp;Settings&quot;));

    guessModeStateAct = new QAction(tr(&quot;&amp;Guess Image Mode/State&quot;), this);
    guessModeStateAct-&gt;setCheckable(true);
    guessModeStateAct-&gt;setChecked(true);
    settingsMenu-&gt;addAction(guessModeStateAct);

    nativeFileDialogAct = new QAction(tr(&quot;&amp;Use Native File Dialog&quot;), this);
    nativeFileDialogAct-&gt;setCheckable(true);
    nativeFileDialogAct-&gt;setChecked(true);
    settingsMenu-&gt;addAction(nativeFileDialogAct);

    QMenu *helpMenu = menuBar()-&gt;addMenu(tr(&quot;&amp;Help&quot;));
    helpMenu-&gt;addAction(tr(&quot;&amp;About&quot;), this, &amp;MainWindow::about);
    helpMenu-&gt;addAction(tr(&quot;About &amp;Qt&quot;), qApp, &amp;QApplication::aboutQt);
}

void MainWindow::createContextMenu()
{
    imagesTable-&gt;setContextMenuPolicy(Qt::ActionsContextMenu);
    imagesTable-&gt;addAction(addSampleImagesAct);
    imagesTable-&gt;addAction(addOtherImagesAct);
    imagesTable-&gt;addAction(removeAllImagesAct);
}

void MainWindow::checkCurrentStyle()
{
    foreach (QAction *action, styleActionGroup-&gt;actions()) {
        QString styleName = action-&gt;data().toString();
        QScopedPointer&lt;QStyle&gt; candidate(QStyleFactory::create(styleName));
        Q_ASSERT(!candidate.isNull());
        if (candidate-&gt;metaObject()-&gt;className()
                == QApplication::style()-&gt;metaObject()-&gt;className()) {
            action-&gt;trigger();
            return;
        }
    }
}

</db:programlisting>
</db:article>
