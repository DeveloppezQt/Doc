<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Fetch More Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.14.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Fetch More example shows how to add items to an item view model on demand.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/fetchmore-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>This example consists of a dialog where you can enter a directory name in the <db:guilabel>Directory</db:guilabel> edit field. The application loads and visualizes all files it finds as you are typing. It is not required to press [Enter] to launch the search.</db:para>
<db:para>When you have large - or perhaps even infinite - data sets, you will need to add items to the model in batches, and preferably only when the items are needed by the view (i.e., when they are visible in the view).</db:para>
<db:para>In this example, we implement <db:code>FileListModel</db:code> - an item view model containing the entries of a directory. We also have <db:code>Window</db:code>, which sets up the GUI and feeds the model with directories.</db:para>
<db:para>Let's take a tour of <db:code>FileListModel</db:code>'s code.</db:para>
<db:section xml:id="filelistmodel-class-definition">
<db:title>FileListModel Class Definition</db:title>
<db:para>The <db:code>FileListModel</db:code> inherits QAbstractListModel and contains the contents of a directory. It will add items to itself only when requested to do so by the view.</db:para>
<db:programlisting language="cpp">class FileListModel : public QAbstractListModel
{
    Q_OBJECT

public:
    FileListModel(QObject *parent = nullptr);

    int rowCount(const QModelIndex &amp;amp;parent = QModelIndex()) const override;
    QVariant data(const QModelIndex &amp;amp;index, int role = Qt::DisplayRole) const override;

signals:
    void numberPopulated(int number);

public slots:
    void setDirPath(const QString &amp;amp;path);

protected:
    bool canFetchMore(const QModelIndex &amp;amp;parent) const override;
    void fetchMore(const QModelIndex &amp;amp;parent) override;

private:
    QStringList fileList;
    int fileCount;
};
</db:programlisting>
<db:para>The secret lies in the reimplementation of <db:link xlink:href="">fetchMore()</db:link> and <db:link xlink:href="">canFetchMore()</db:link> from QAbstractItemModel. These functions are called by the item view when it needs more items.</db:para>
<db:para>The <db:code>setDirPath()</db:code> function sets the directory the model will work on. We emit <db:code>numberPopulated()</db:code> each time we add a batch of items to the model.</db:para>
<db:para>We keep all directory entries in <db:code>fileList</db:code>. <db:code>fileCount</db:code> is the number of items that have been added to the model.</db:para>
</db:section>
<db:section xml:id="filelistmodel-class-implementation">
<db:title>FileListModel Class Implementation</db:title>
<db:para>We start by checking out the <db:code>setDirPath()</db:code>.</db:para>
<db:programlisting language="cpp">void FileListModel::setDirPath(const QString &amp;amp;path)
{
    QDir dir(path);

    beginResetModel();
    fileList = dir.entryList();
    fileCount = 0;
    endResetModel();
}
</db:programlisting>
<db:para>We use a QDir to get the contents of the directory. We need to inform QAbstractItemModel that we want to remove all items - if any - from the model.</db:para>
<db:programlisting language="cpp">bool FileListModel::canFetchMore(const QModelIndex &amp;amp;parent) const
{
    if (parent.isValid())
        return false;
    return (fileCount &amp;lt; fileList.size());
}
</db:programlisting>
<db:para>The <db:code>canFetchMore()</db:code> function is called by the view when it needs more items. We return true if there still are entries that we have not added to the model; otherwise, we return false.</db:para>
<db:para>And now, the <db:code>fetchMore()</db:code> function itself:</db:para>
<db:programlisting language="cpp">void FileListModel::fetchMore(const QModelIndex &amp;amp;parent)
{
    if (parent.isValid())
        return;
    int remainder = fileList.size() - fileCount;
    int itemsToFetch = qMin(100, remainder);

    if (itemsToFetch &amp;lt;= 0)
        return;

    beginInsertRows(QModelIndex(), fileCount, fileCount + itemsToFetch - 1);

    fileCount += itemsToFetch;

    endInsertRows();

    emit numberPopulated(itemsToFetch);
}
</db:programlisting>
<db:para>We first calculate the number of items to fetch. <db:link xlink:href="">beginInsertRows()</db:link> and <db:link xlink:href="">endInsertRows()</db:link> are mandatory for QAbstractItemModel to keep up with the row insertions. Finally, we emit <db:code>numberPopulated()</db:code>, which is picked up by <db:code>Window</db:code>.</db:para>
<db:para>To complete the tour, we also look at <db:code>rowCount()</db:code> and <db:code>data()</db:code>.</db:para>
<db:programlisting language="cpp">int FileListModel::rowCount(const QModelIndex &amp;amp;parent) const
{
    return parent.isValid() ? 0 : fileCount;
}

QVariant FileListModel::data(const QModelIndex &amp;amp;index, int role) const
{
    if (!index.isValid())
        return QVariant();

    if (index.row() &amp;gt;= fileList.size() || index.row() &amp;lt; 0)
        return QVariant();

    if (role == Qt::DisplayRole) {
        return fileList.at(index.row());
    } else if (role == Qt::BackgroundRole) {
        int batch = (index.row() / 100) % 2;
        if (batch == 0)
            return qApp-&amp;gt;palette().base();
        else
            return qApp-&amp;gt;palette().alternateBase();
    }
    return QVariant();
}
</db:programlisting>
<db:para>Notice that the row count is only the items we have added so far, i.e., not the number of entries in the directory.</db:para>
<db:para>In <db:code>data()</db:code>, we return the appropriate entry from the <db:code>fileList</db:code>. We also separate the batches with a different background color.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/itemviews/fetchmore?h=5.14">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
