<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Fetch More Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.4.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Fetch More example shows how two add items to an item view model on demand.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/fetchmore-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The user of the example can enter a directory in the <db:guilabel>Directory</db:guilabel> line edit. The contents of the directory will be listed in the list view below.</db:para>
<db:para>When you have large - or perhaps even infinite - data sets, you will need to add items to the model in batches, and preferably only when the items are needed by the view (i.e., when they are visible in the view).</db:para>
<db:para>In this example, we implement <db:code>FileListModel</db:code> - an item view model containing the entries of a directory. We also have <db:code>Window</db:code>, which sets up the GUI and feeds the model with directories.</db:para>
<db:para>Let's take a tour of <db:code>FileListModel</db:code>'s code.</db:para>
<db:section xml:id="filelistmodel-class-definition">
<db:title>FileListModel Class Definition</db:title>
<db:para>The <db:code>FileListModel</db:code> inherits <db:link xlink:href="qabstractlistmodel.xml">QAbstractListModel</db:link> and contains the contents of a directory. It will add items to itself only when requested to do so by the view.</db:para>
<db:programlisting language="cpp">class FileListModel : public QAbstractListModel
{
    Q_OBJECT

public:
    FileListModel(QObject *parent = 0);

    int rowCount(const QModelIndex &amp;parent = QModelIndex()) const Q_DECL_OVERRIDE;
    QVariant data(const QModelIndex &amp;index, int role = Qt::DisplayRole) const Q_DECL_OVERRIDE;

signals:
    void numberPopulated(int number);

public slots:
    void setDirPath(const QString &amp;path);

protected:
    bool canFetchMore(const QModelIndex &amp;parent) const Q_DECL_OVERRIDE;
    void fetchMore(const QModelIndex &amp;parent) Q_DECL_OVERRIDE;

private:
    QStringList fileList;
    int fileCount;
};
</db:programlisting>
<db:para>The secret lies in the reimplementation of <db:link xlink:href="qabstractitemmodel.xml#fetchMore">fetchMore</db:link>() and <db:link xlink:href="qabstractitemmodel.xml#canFetchMore">canFetchMore</db:link>() from <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link>. These functions are called by the item view when it needs more items.</db:para>
<db:para>The <db:code>setDirPath()</db:code> function sets the directory the model will work on. We emit <db:code>numberPopulated()</db:code> each time we add a batch of items to the model.</db:para>
<db:para>We keep all directory entries in <db:code>fileList</db:code>. <db:code>fileCount</db:code> is the number of items that have been added to the model.</db:para>
</db:section>
<db:section xml:id="filelistmodel-class-implementation">
<db:title>FileListModel Class Implementation</db:title>
<db:para>We start by checking out the <db:code>setDirPath()</db:code>.</db:para>
<db:programlisting language="cpp">void FileListModel::setDirPath(const QString &amp;path)
{
    QDir dir(path);

    beginResetModel();
    fileList = dir.entryList();
    fileCount = 0;
    endResetModel();
}
</db:programlisting>
<db:para>We use a <db:link xlink:href="qdir.xml">QDir</db:link> to get the contents of the directory. We need to inform <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link> that we want to remove all items - if any - from the model.</db:para>
<db:programlisting language="cpp">bool FileListModel::canFetchMore(const QModelIndex &amp; /* index */) const
{
    if (fileCount &lt; fileList.size())
        return true;
    else
        return false;
}
</db:programlisting>
<db:para>The <db:code>canFetchMore()</db:code> function is called by the view when it needs more items. We return true if there still are entries that we have not added to the model; otherwise, we return false.</db:para>
<db:para>And now, the <db:code>fetchMore()</db:code> function itself:</db:para>
<db:programlisting language="cpp">void FileListModel::fetchMore(const QModelIndex &amp; /* index */)
{
    int remainder = fileList.size() - fileCount;
    int itemsToFetch = qMin(100, remainder);

    beginInsertRows(QModelIndex(), fileCount, fileCount+itemsToFetch-1);

    fileCount += itemsToFetch;

    endInsertRows();

    emit numberPopulated(itemsToFetch);
}
</db:programlisting>
<db:para>We first calculate the number of items to fetch. <db:link xlink:href="qabstractitemmodel.xml#beginInsertRows">beginInsertRows</db:link>() and <db:link xlink:href="qabstractitemmodel.xml#endInsertRows">endInsertRows</db:link>() are mandatory for <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link> to keep up with the row insertions. Finally, we emit <db:code>numberPopulated()</db:code>, which is picked up by <db:code>Window</db:code>.</db:para>
<db:para>To complete the tour, we also look at <db:code>rowCount()</db:code> and <db:code>data()</db:code>.</db:para>
<db:programlisting language="cpp">int FileListModel::rowCount(const QModelIndex &amp; /* parent */) const
{
    return fileCount;
}

QVariant FileListModel::data(const QModelIndex &amp;index, int role) const
{
    if (!index.isValid())
        return QVariant();

    if (index.row() &gt;= fileList.size() || index.row() &lt; 0)
        return QVariant();

    if (role == Qt::DisplayRole) {
        return fileList.at(index.row());
    } else if (role == Qt::BackgroundRole) {
        int batch = (index.row() / 100) % 2;
        if (batch == 0)
            return qApp-&gt;palette().base();
        else
            return qApp-&gt;palette().alternateBase();
    }
    return QVariant();
}
</db:programlisting>
<db:para>Notice that the row count is only the items we have added so far, i.e., not the number of entries in the directory.</db:para>
<db:para>In <db:code>data()</db:code>, we return the appropriate entry from the <db:code>fileList</db:code>. We also separate the batches with a different background color.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="itemviews/fetchmore/fetchmore.pro">itemviews/fetchmore/fetchmore.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="itemviews/fetchmore/filelistmodel.cpp">itemviews/fetchmore/filelistmodel.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="itemviews/fetchmore/filelistmodel.h">itemviews/fetchmore/filelistmodel.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="itemviews/fetchmore/main.cpp">itemviews/fetchmore/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="itemviews/fetchmore/window.cpp">itemviews/fetchmore/window.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="itemviews/fetchmore/window.h">itemviews/fetchmore/window.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
