<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QScatterDataProxy Class</db:title>
<db:productname>QtDataVis3D</db:productname>
<db:edition>Qt Data Visualization | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qscatterdataproxy.xml">QScatterDataProxy</db:link> class is the data proxy for 3D scatter graphs.</db:para>
<db:para>This class was introduced in QtDataVisualization 1.0.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QScatterDataProxy</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>QtDataVisualization 1.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS DataVisualization)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::DataVisualization)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += datavisualization</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qitemmodelscatterdataproxy.xml" xlink:role="class">QItemModelScatterDataProxy</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Instantiated By</db:term>
<db:listitem>
<db:para>qml-qtdatavisualization-scatterdataproxy.xml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qabstractdataproxy.xml" xlink:role="class">QAbstractDataProxy</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qitemmodelscatterdataproxy.xml" xlink:role="class">QItemModelScatterDataProxy</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A scatter data proxy handles adding, inserting, changing, and removing data items.</db:para>
<db:para><db:link xlink:href="qscatterdataproxy.xml">QScatterDataProxy</db:link> takes ownership of all QtDataVisualization::QScatterDataArray and <db:link xlink:href="qscatterdataitem.xml">QScatterDataItem</db:link> objects passed to it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtdatavisualization-data-handling.xml">Qt Data Visualization Data Handling</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="itemCount-prop">
<db:title>[read-only] itemCount : const int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>itemCount</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">itemCount</db:synopsisinfo>
<db:synopsisinfo role="notifier">itemCountChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the number of items in the array.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">itemCount</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">itemCountChanged</db:emphasis>(<db:type>int</db:type> <db:emphasis>count</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="series-prop">
<db:title>[read-only] series : QScatter3DSeries* const</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QScatter3DSeries*</db:type>
<db:varname>series</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">series</db:synopsisinfo>
<db:synopsisinfo role="notifier">seriesChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the series this proxy is attached to.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qscatter3dseries.xml">QScatter3DSeries</db:link></db:type> *<db:emphasis role="bold">series</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">seriesChanged</db:emphasis>(<db:type><db:link xlink:href="qscatter3dseries.xml">QScatter3DSeries</db:link></db:type> *<db:emphasis>series</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QScatterDataProxy">
<db:title>[explicit] QScatterDataProxy::QScatterDataProxy(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QScatterDataProxy</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QScatterDataProxy(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs <db:link xlink:href="qscatterdataproxy.xml">QScatterDataProxy</db:link> with the given <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QScatterDataProxy">
<db:title>[virtual] QScatterDataProxy::~QScatterDataProxy()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QScatterDataProxy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QScatterDataProxy()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Deletes the scatter data proxy.</db:para>
</db:section>
<db:section xml:id="addItem">
<db:title>int QScatterDataProxy::addItem(const QScatterDataItem &amp;<db:emphasis>item</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>addItem</db:methodname>
<db:methodparam>
<db:type>const QScatterDataItem &amp;</db:type>
<db:parameter>item</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int addItem(const QScatterDataItem &amp;item)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds the item <db:code role="parameter">item</db:code> to the end of the array.</db:para>
<db:para>Returns the index of the added item.</db:para>
</db:section>
<db:section xml:id="addItems">
<db:title>int QScatterDataProxy::addItems(const QScatterDataArray &amp;<db:emphasis>items</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>addItems</db:methodname>
<db:methodparam>
<db:type>const QScatterDataArray &amp;</db:type>
<db:parameter>items</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int addItems(const QScatterDataArray &amp;items)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds the items specified by <db:code role="parameter">items</db:code> to the end of the array.</db:para>
<db:para>Returns the index of the first added item.</db:para>
</db:section>
<db:section xml:id="array">
<db:title>const QScatterDataArray *QScatterDataProxy::array() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QScatterDataArray *</db:type>
<db:methodname>array</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QScatterDataArray * array() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the pointer to the data array.</db:para>
</db:section>
<db:section xml:id="arrayReset">
<db:title>void QScatterDataProxy::arrayReset()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>arrayReset</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void arrayReset()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the data array is reset. If the contents of the whole array are changed without calling <db:link xlink:href="qscatterdataproxy.xml#resetArray">resetArray</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="insertItem">
<db:title>void QScatterDataProxy::insertItem(int <db:emphasis>index</db:emphasis>, const QScatterDataItem &amp;<db:emphasis>item</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>insertItem</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QScatterDataItem &amp;</db:type>
<db:parameter>item</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void insertItem(int index, const QScatterDataItem &amp;item)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts the item <db:code role="parameter">item</db:code> to the position <db:code role="parameter">index</db:code>. If the index is equal to the data array size, the item is added to the array.</db:para>
</db:section>
<db:section xml:id="insertItems">
<db:title>void QScatterDataProxy::insertItems(int <db:emphasis>index</db:emphasis>, const QScatterDataArray &amp;<db:emphasis>items</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>insertItems</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QScatterDataArray &amp;</db:type>
<db:parameter>items</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void insertItems(int index, const QScatterDataArray &amp;items)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts the items specified by <db:code role="parameter">items</db:code> to the position <db:code role="parameter">index</db:code>. If the index is equal to data array size, the items are added to the array.</db:para>
</db:section>
<db:section xml:id="itemAt">
<db:title>const QScatterDataItem *QScatterDataProxy::itemAt(int <db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QScatterDataItem *</db:type>
<db:methodname>itemAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QScatterDataItem * itemAt(int index) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the pointer to the item at the index <db:code role="parameter">index</db:code>. It is guaranteed to be valid only until the next call that modifies data.</db:para>
</db:section>
<db:section xml:id="itemsAdded">
<db:title>void QScatterDataProxy::itemsAdded(int <db:emphasis>startIndex</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>itemsAdded</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>startIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void itemsAdded(int startIndex, int count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the number of items specified by <db:code role="parameter">count</db:code> is added starting at the position <db:code role="parameter">startIndex</db:code>. If items are added to the array without calling <db:link xlink:href="qscatterdataproxy.xml#addItem">addItem</db:link>() or <db:link xlink:href="qscatterdataproxy.xml#addItems">addItems</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="itemsChanged">
<db:title>void QScatterDataProxy::itemsChanged(int <db:emphasis>startIndex</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>itemsChanged</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>startIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void itemsChanged(int startIndex, int count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the number of items specified by <db:code role="parameter">count</db:code> is changed starting at the position <db:code role="parameter">startIndex</db:code>. If items are changed in the array without calling <db:link xlink:href="qscatterdataproxy.xml#setItem">setItem</db:link>() or <db:link xlink:href="qscatterdataproxy.xml#setItems">setItems</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="itemsInserted">
<db:title>void QScatterDataProxy::itemsInserted(int <db:emphasis>startIndex</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>itemsInserted</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>startIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void itemsInserted(int startIndex, int count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the number of items specified by <db:code role="parameter">count</db:code> is inserted starting at the position <db:code role="parameter">startIndex</db:code>. If items are inserted into the array without calling <db:link xlink:href="qscatterdataproxy.xml#insertItem">insertItem</db:link>() or <db:link xlink:href="qscatterdataproxy.xml#insertItems">insertItems</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="itemsRemoved">
<db:title>void QScatterDataProxy::itemsRemoved(int <db:emphasis>startIndex</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>itemsRemoved</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>startIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void itemsRemoved(int startIndex, int count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the number of rows specified by <db:code role="parameter">count</db:code> is removed starting at the position <db:code role="parameter">startIndex</db:code>. The index may be larger than the current array size if items are removed from the end. If items are removed from the array without calling <db:link xlink:href="qscatterdataproxy.xml#removeItems">removeItems</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="removeItems">
<db:title>void QScatterDataProxy::removeItems(int <db:emphasis>index</db:emphasis>, int <db:emphasis>removeCount</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeItems</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>removeCount</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeItems(int index, int removeCount)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the number of items specified by <db:code role="parameter">removeCount</db:code> starting at the position <db:code role="parameter">index</db:code>. Attempting to remove items past the end of the array does nothing.</db:para>
</db:section>
<db:section xml:id="resetArray">
<db:title>void QScatterDataProxy::resetArray(QScatterDataArray *<db:emphasis>newArray</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resetArray</db:methodname>
<db:methodparam>
<db:type>QScatterDataArray *</db:type>
<db:parameter>newArray</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resetArray(QScatterDataArray *newArray)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Takes ownership of the array <db:code role="parameter">newArray</db:code>. Clears the existing array if the new array differs from it. If the arrays are the same, this function just triggers the <db:link xlink:href="qscatterdataproxy.xml#arrayReset">arrayReset</db:link>() signal.</db:para>
<db:para>Passing a null array deletes the old array and creates a new empty array.</db:para>
</db:section>
<db:section xml:id="setItem">
<db:title>void QScatterDataProxy::setItem(int <db:emphasis>index</db:emphasis>, const QScatterDataItem &amp;<db:emphasis>item</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setItem</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QScatterDataItem &amp;</db:type>
<db:parameter>item</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setItem(int index, const QScatterDataItem &amp;item)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces the item at the position <db:code role="parameter">index</db:code> with the item <db:code role="parameter">item</db:code>.</db:para>
</db:section>
<db:section xml:id="setItems">
<db:title>void QScatterDataProxy::setItems(int <db:emphasis>index</db:emphasis>, const QScatterDataArray &amp;<db:emphasis>items</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setItems</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QScatterDataArray &amp;</db:type>
<db:parameter>items</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setItems(int index, const QScatterDataArray &amp;items)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces the items starting from the position <db:code role="parameter">index</db:code> with the items specified by <db:code role="parameter">items</db:code>.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="QScatterDataArray-typedef">
<db:title>QScatterDataArray</db:title>
<db:typedefsynopsis>
<db:typedefname>QScatterDataArray</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>A list of <db:link xlink:href="qscatterdataitem.xml">QScatterDataItem</db:link> objects.</db:para>
</db:section>
</db:section>
</db:article>
