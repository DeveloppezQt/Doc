<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QHash Class</db:title>
<db:subtitle>template &lt;typename Key, typename T&gt; class QHash</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qhash.xml#qhash">QHash</db:link> class is a template class that provides a hash-table-based dictionary.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QHash</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QHash is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;Key, T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores (key, value) pairs and provides very fast lookup of the value associated with a key.</db:para>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link> provides very similar functionality to <db:link xlink:href="qmap.xml">QMap</db:link>. The differences are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link> provides faster lookups than <db:link xlink:href="qmap.xml">QMap</db:link>. (See <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for details.)</db:para>
</db:listitem>
<db:listitem>
<db:para>When iterating over a <db:link xlink:href="qmap.xml">QMap</db:link>, the items are always sorted by key. With <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, the items are arbitrarily ordered.</db:para>
</db:listitem>
<db:listitem>
<db:para>The key type of a <db:link xlink:href="qmap.xml">QMap</db:link> must provide operator&lt;(). The key type of a <db:link xlink:href="qhash.xml#qhash">QHash</db:link> must provide operator==() and a global hash function called <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() (see <db:link xlink:href="qhash.xml#qhash">qHash</db:link>).</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Here's an example <db:link xlink:href="qhash.xml#qhash">QHash</db:link> with <db:link xlink:href="qstring.xml">QString</db:link> keys and int values:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QString, int&amp;gt; hash;
</db:programlisting>
<db:para>To insert a (key, value) pair into the hash, you can use operator[]():</db:para>
<db:programlisting language="cpp">hash[&quot;one&quot;] = 1;
hash[&quot;three&quot;] = 3;
hash[&quot;seven&quot;] = 7;
</db:programlisting>
<db:para>This inserts the following three (key, value) pairs into the <db:link xlink:href="qhash.xml#qhash">QHash</db:link>: (&quot;one&quot;, 1), (&quot;three&quot;, 3), and (&quot;seven&quot;, 7). Another way to insert items into the hash is to use <db:link xlink:href="qhash.xml#insert">insert</db:link>():</db:para>
<db:programlisting language="cpp">hash.insert(&quot;twelve&quot;, 12);
</db:programlisting>
<db:para>To look up a value, use operator[]() or <db:link xlink:href="qhash.xml#value">value</db:link>():</db:para>
<db:programlisting language="cpp">int num1 = hash[&quot;thirteen&quot;];
int num2 = hash.value(&quot;thirteen&quot;);
</db:programlisting>
<db:para>If there is no item with the specified key in the hash, these functions return a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:para>If you want to check whether the hash contains a particular key, use <db:link xlink:href="qhash.xml#contains">contains</db:link>():</db:para>
<db:programlisting language="cpp">int timeout = 30;
if (hash.contains(&quot;TIMEOUT&quot;))
    timeout = hash.value(&quot;TIMEOUT&quot;);
</db:programlisting>
<db:para>There is also a <db:link xlink:href="qhash.xml#value">value</db:link>() overload that uses its second argument as a default value if there is no item with the specified key:</db:para>
<db:programlisting language="cpp">int timeout = hash.value(&quot;TIMEOUT&quot;, 30);
</db:programlisting>
<db:para>In general, we recommend that you use <db:link xlink:href="qhash.xml#contains">contains</db:link>() and <db:link xlink:href="qhash.xml#value">value</db:link>() rather than operator[]() for looking up a key in a hash. The reason is that operator[]() silently inserts an item into the hash if no item exists with the same key (unless the hash is const). For example, the following code snippet will create 1000 items in memory:</db:para>
<db:programlisting language="cpp">// WRONG
QHash&amp;lt;int, QWidget *&amp;gt; hash;
...
for (int i = 0; i &amp;lt; 1000; ++i) {
    if (hash[i] == okButton)
        cout &amp;lt;&amp;lt; &quot;Found button at index &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; Qt::endl;
}
</db:programlisting>
<db:para>To avoid this problem, replace hash[i] with hash.value(i) in the code above.</db:para>
<db:para>Internally, <db:link xlink:href="qhash.xml#qhash">QHash</db:link> uses a hash table to perform lookups. This hash table automatically grows to provide fast lookups without wasting too much memory. You can still control the size of the hash table by calling <db:link xlink:href="qhash.xml#reserve">reserve</db:link>() if you already know approximately how many items the <db:link xlink:href="qhash.xml#qhash">QHash</db:link> will contain, but this isn't necessary to obtain good performance. You can also call <db:link xlink:href="qhash.xml#capacity">capacity</db:link>() to retrieve the hash table's size.</db:para>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link> will not shrink automatically if items are removed from the table. To minimize the memory used by the hash, call <db:link xlink:href="qhash.xml#squeeze">squeeze</db:link>().</db:para>
<db:para>If you want to navigate through all the (key, value) pairs stored in a <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, you can use an iterator. <db:link xlink:href="qhash.xml#qhash">QHash</db:link> provides both <db:link xlink:href="java-style-iterators.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qhashiterator.xml">QHashIterator</db:link> and <db:link xlink:href="qmutablehashiterator.xml">QMutableHashIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qhash-const-iterator.xml">QHash::const_iterator</db:link> and <db:link xlink:href="qhash-iterator.xml">QHash::iterator</db:link>). Here's how to iterate over a <db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, int&gt; using a Java-style iterator:</db:para>
<db:programlisting language="cpp">QHashIterator&amp;lt;QString, int&amp;gt; i(hash);
while (i.hasNext()) {
    i.next();
    cout &amp;lt;&amp;lt; i.key() &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; i.value() &amp;lt;&amp;lt; Qt::endl;
}
</db:programlisting>
<db:para>Here's the same code, but using an STL-style iterator:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QString, int&amp;gt;::const_iterator i = hash.constBegin();
while (i != hash.constEnd()) {
    cout &amp;lt;&amp;lt; i.key() &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; i.value() &amp;lt;&amp;lt; Qt::endl;
    ++i;
}
</db:programlisting>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link> is unordered, so an iterator's sequence cannot be assumed to be predictable. If ordering by key is required, use a <db:link xlink:href="qmap.xml">QMap</db:link>.</db:para>
<db:para>A <db:link xlink:href="qhash.xml#qhash">QHash</db:link> allows only one value per key. If you call <db:link xlink:href="qhash.xml#insert">insert</db:link>() with a key that already exists in the <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, the previous value is erased. For example:</db:para>
<db:programlisting language="cpp">hash.insert(&quot;plenty&quot;, 100);
hash.insert(&quot;plenty&quot;, 2000);
// hash.value(&quot;plenty&quot;) == 2000
</db:programlisting>
<db:para>If you need to store multiple entries for the same key in the hash table, use <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>.</db:para>
<db:para>If you only need to extract the values from a hash (not the keys), you can also use <db:link xlink:href="containers.xml#foreach">foreach</db:link>:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QString, int&amp;gt; hash;
...
foreach (int value, hash)
    cout &amp;lt;&amp;lt; value &amp;lt;&amp;lt; Qt::endl;
</db:programlisting>
<db:para>Items can be removed from the hash in several ways. One way is to call <db:link xlink:href="qhash.xml#remove">remove</db:link>(); this will remove any item with the given key. Another way is to use <db:link xlink:href="qmutablehashiterator.xml#remove">QMutableHashIterator::remove</db:link>(). In addition, you can clear the entire hash using <db:link xlink:href="qhash.xml#clear">clear</db:link>().</db:para>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s key and value data types must be <db:link xlink:href="containers.xml#assignable-data-types">assignable data types</db:link>. You cannot, for example, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> as a value; instead, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> *.</db:para>
<db:anchor xml:id="qhashx"/>
<db:section xml:id="the-hashing-function">
<db:title>The hashing function</db:title>
<db:para>A <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s key type has additional requirements other than being an assignable data type: it must provide operator==(), and there must also be a hashing function that returns a hash value for an argument of the key's type.</db:para>
<db:para>The hashing function computes a numeric value based on a key. It can use any algorithm imaginable, as long as it always returns the same value if given the same argument. In other words, if e1 == e2, then hash(e1) == hash(e2) must hold as well. However, to obtain good performance, the hashing function should attempt to return different hash values for different keys to the largest extent possible.</db:para>
<db:para>A hashing function for a key type K may be provided in two different ways.</db:para>
<db:para>The first way is by having an overload of qHash() in K's namespace. The qHash() function must have one of these signatures:</db:para>
<db:programlisting language="cpp">size_t qHash(K key);
size_t qHash(const K &amp;amp;key);

size_t qHash(K key, size_t seed);
size_t qHash(const K &amp;amp;key, size_t seed);
</db:programlisting>
<db:para>The two-arguments overloads take an unsigned integer that should be used to seed the calculation of the hash function. This seed is provided by <db:link xlink:href="qhash.xml#qhash">QHash</db:link> in order to prevent a family of <db:link xlink:href="qhash.xml#algorithmic-complexity-attacks">algorithmic complexity attacks</db:link>. If both a one-argument and a two-arguments overload are defined for a key type, the latter is used by <db:link xlink:href="qhash.xml#qhash">QHash</db:link> (note that you can simply define a two-arguments version, and use a default value for the seed parameter).</db:para>
<db:para>The second way to provide a hashing function is by specializing the std::hash class for the key type K, and providing a suitable function call operator for it:</db:para>
<db:programlisting language="cpp">namespace std {
template &amp;lt;&amp;gt; struct hash&amp;lt;K&amp;gt;
{
    // seed is optional
    size_t operator()(const K &amp;amp;key, size_t seed = 0) const;
};
}
</db:programlisting>
<db:para>The seed argument has the same meaning as for qHash(), and may be left out.</db:para>
<db:para>This second way allows to reuse the same hash function between <db:link xlink:href="qhash.xml#qhash">QHash</db:link> and the C++ Standard Library unordered associative containers. If both a qHash() overload and a std::hash specializations are provided for a type, then the qHash() overload is preferred.</db:para>
<db:para>Here's a partial list of the C++ and Qt types that can serve as keys in a <db:link xlink:href="qhash.xml#qhash">QHash</db:link>: any integer type (char, unsigned long, etc.), any pointer type, <db:link xlink:href="qchar.xml">QChar</db:link>, <db:link xlink:href="qstring.xml">QString</db:link>, and <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. For all of these, the &lt;QHash&gt; header defines a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function that computes an adequate hash value. Many other Qt classes also declare a <db:link xlink:href="qhash.xml#qhash">qHash</db:link> overload for their type; please refer to the documentation of each class.</db:para>
<db:para>If you want to use other types as the key, make sure that you provide operator==() and a hash implementation.</db:para>
<db:para>The convenience <db:link xlink:href="qhash.xml#qHashMulti">qHashMulti</db:link>() function can be used to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for a custom type, where one usually wants to produce a hash value from multiple fields:</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">#ifndef EMPLOYEE_H
#define EMPLOYEE_H

class Employee
{
public:
    Employee() {}
    Employee(const QString &amp;amp;name, QDate dateOfBirth);
    ...

private:
    QString myName;
    QDate myDateOfBirth;
};

inline bool operator==(const Employee &amp;amp;e1, const Employee &amp;amp;e2)
{
    return e1.name() == e2.name()
           &amp;amp;&amp;amp; e1.dateOfBirth() == e2.dateOfBirth();
}

inline size_t qHash(const Employee &amp;amp;key, size_t seed)
{
    return qHashMulti(seed, key.name(), key.dateOfBirth());
}

#endif // EMPLOYEE_H
</db:programlisting>
<db:para>In the example above, we've relied on Qt's own implementation of <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for <db:link xlink:href="qstring.xml">QString</db:link> and <db:link xlink:href="qdate.xml">QDate</db:link> to give us a hash value for the employee's name and date of birth respectively.</db:para>
<db:para>Note that the implementation of the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() will give the same results (for the same inputs) across different Qt versions.</db:para>
</db:section>
<db:section xml:id="algorithmic-complexity-attacks">
<db:title>Algorithmic complexity attacks</db:title>
<db:para>All hash tables are vulnerable to a particular class of denial of service attacks, in which the attacker carefully pre-computes a set of different keys that are going to be hashed in the same bucket of a hash table (or even have the very same hash value). The attack aims at getting the worst-case algorithmic behavior (O(n) instead of amortized O(1), see <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for the details) when the data is fed into the table.</db:para>
<db:para>In order to avoid this worst-case behavior, the calculation of the hash value done by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() can be salted by a random seed, that nullifies the attack's extent. This seed is automatically generated by <db:link xlink:href="qhash.xml#qhash">QHash</db:link> once per process, and then passed by <db:link xlink:href="qhash.xml#qhash">QHash</db:link> as the second argument of the two-arguments overload of the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function.</db:para>
<db:para>This randomization of <db:link xlink:href="qhash.xml#qhash">QHash</db:link> is enabled by default. Even though programs should never depend on a particular <db:link xlink:href="qhash.xml#qhash">QHash</db:link> ordering, there may be situations where you temporarily need deterministic behavior, for example for debugging or regression testing. To disable the randomization, define the environment variable QT_HASH_SEED to have the value 0. Alternatively, you can call the <db:link xlink:href="qhash.xml#qSetGlobalQHashSeed">qSetGlobalQHashSeed</db:link>() function with the value 0.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhashiterator.xml">QHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablehashiterator.xml">QMutableHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmap.xml">QMap</db:link></db:member>
<db:member><db:link xlink:href="qset.xml">QSet</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QHash::ConstIterator</db:title>
<db:typedefsynopsis>
<db:typedefname>ConstIterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qhash-const-iterator.xml">QHash::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>QHash::Iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>Iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qhash-iterator.xml">QHash::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="const_key_value_iterator-typedef">
<db:title>[since 5.10] QHash::const_key_value_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>const_key_value_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="module">QtCore</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The QHash::const_key_value_iterator typedef provides an STL-style const iterator for <db:link xlink:href="qhash.xml#qhash">QHash</db:link>.</db:para>
<db:para>QHash::const_key_value_iterator is essentially the same as <db:link xlink:href="qhash-const-iterator.xml">QHash::const_iterator</db:link> with the difference that operator*() returns a key/value pair instead of a value.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>[alias] QHash::difference_type</db:title>
<db:typedefsynopsis>
<db:typedefname>difference_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="key_type-typedef">
<db:title>[alias] QHash::key_type</db:title>
<db:typedefsynopsis>
<db:typedefname>key_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for Key. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="key_value_iterator-typedef">
<db:title>[since 5.10] QHash::key_value_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>key_value_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="module">QtCore</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The QHash::key_value_iterator typedef provides an STL-style iterator for <db:link xlink:href="qhash.xml#qhash">QHash</db:link>.</db:para>
<db:para>QHash::key_value_iterator is essentially the same as <db:link xlink:href="qhash-iterator.xml">QHash::iterator</db:link> with the difference that operator*() returns a key/value pair instead of a value.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapped_type-typedef">
<db:title>[alias] QHash::mapped_type</db:title>
<db:typedefsynopsis>
<db:typedefname>mapped_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>[alias] QHash::size_type</db:title>
<db:typedefsynopsis>
<db:typedefname>size_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="emplace-1">
<db:title>QHash::iterator QHash::emplace(Key &amp;&amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="emplace">QHash::iterator QHash::emplace(const Key &amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:para>Inserts a new element into the container. This new element is constructed in-place using <db:code role="parameter">args</db:code> as the arguments for its construction.</db:para>
<db:para>Returns an iterator pointing to the new element.</db:para>
</db:section>
<db:section xml:id="QHashxx">
<db:title>QHash::QHash()</db:title>
<db:constructorsynopsis>
<db:methodname>QHash</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QHash-1">
<db:title>[since 5.1] QHash::QHash(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; <db:emphasis>list</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QHash</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; list)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a hash with a copy of each of the elements in the initializer list <db:code role="parameter">list</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
</db:section>
<db:section xml:id="QHash-2">
<db:title>QHash::QHash(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QHash</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash(const QHash&lt;Key, T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:para>This operation occurs in <db:link xlink:href="containers.xml#constant-time">constant time</db:link>, because <db:link xlink:href="qhash.xml#qhash">QHash</db:link> is <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>. This makes returning a <db:link xlink:href="qhash.xml#qhash">QHash</db:link> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and this takes <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QHash-3">
<db:title>[since 5.2] QHash::QHash(QHash&lt;Key, T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QHash</db:methodname>
<db:methodparam>
<db:type>QHash&lt;Key, T&gt; &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash(QHash&lt;Key, T&gt; &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Move-constructs a <db:link xlink:href="qhash.xml#qhash">QHash</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="QHash-4">
<db:title>[since 5.14] QHash::QHash(InputIterator <db:emphasis>begin</db:emphasis>, InputIterator <db:emphasis>end</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QHash</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash(InputIterator begin, InputIterator end)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a hash with a copy of each of the elements in the iterator range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>). Either the elements iterated by the range must be objects with first and second data members (like QPair, std::pair, etc.) convertible to Key and to T respectively; or the iterators must have key() and value() member functions, returning a key convertible to Key and a value convertible to T respectively.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
</db:section>
<db:section xml:id="dtor.QHash">
<db:title>QHash::~QHash()</db:title>
<db:destructorsynopsis>
<db:methodname>~QHash</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QHash()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the hash. References to the values in the hash and all iterators of this hash become invalid.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QHash::iterator QHash::begin()</db:title>
<db:methodsynopsis>
<db:type>QHash::iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::iterator begin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>QHash::const_iterator QHash::begin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator begin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="capacity">
<db:title>qsizetype QHash::capacity() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>capacity</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype capacity() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of buckets in the <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal hash table.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the hash, call <db:link xlink:href="qhash.xml#size">size</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>[since 5.0] QHash::const_iterator QHash::cbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>cbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator cbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[since 5.0] QHash::const_iterator QHash::cend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>cend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator cend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QHash::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all items from the hash and frees up all memory used by it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>QHash::const_iterator QHash::constBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>constBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator constBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QHash::const_iterator QHash::constEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>constEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator constEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind">
<db:title>QHash::const_iterator QHash::constFind(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>constFind</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator constFind(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an iterator pointing to the item with the <db:code role="parameter">key</db:code> in the hash.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function returns <db:link xlink:href="qhash.xml#constEnd">constEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#find">find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constKeyValueBegin">
<db:title>[since 5.10] QHash::const_key_value_iterator QHash::constKeyValueBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_key_value_iterator</db:type>
<db:methodname>constKeyValueBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_key_value_iterator constKeyValueBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constKeyValueEnd">
<db:title>[since 5.10] QHash::const_key_value_iterator QHash::constKeyValueEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_key_value_iterator</db:type>
<db:methodname>constKeyValueEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_key_value_iterator constKeyValueEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#constKeyValueBegin">constKeyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>bool QHash::contains(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the hash contains an item with the <db:code role="parameter">key</db:code>; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#count-1">count</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#contains-1">QMultiHash::contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>qsizetype QHash::count(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>count</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype count(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of items associated with the <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count-1">
<db:title>qsizetype QHash::count() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>count</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype count() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qhash.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="empty">
<db:title>bool QHash::empty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>empty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool empty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qhash.xml#isEmpty">isEmpty</db:link>(), returning true if the hash is empty; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="end">
<db:title>QHash::iterator QHash::end()</db:title>
<db:methodsynopsis>
<db:type>QHash::iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::iterator end()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>QHash::const_iterator QHash::end() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator end() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="erase">
<db:title>[since 5.7] QHash::iterator QHash::erase(QHash::const_iterator <db:emphasis>pos</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QHash::const_iterator</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::iterator erase(QHash::const_iterator pos)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the (key, value) pair associated with the iterator <db:code role="parameter">pos</db:code> from the hash, and returns an iterator to the next item in the hash.</db:para>
<db:para>This function never causes <db:link xlink:href="qhash.xml#qhash">QHash</db:link> to rehash its internal data structure. This means that it can safely be called while iterating, and won't affect the order of items in the hash. For example:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QObject *, int&amp;gt; objectHash;
...
QHash&amp;lt;QObject *, int&amp;gt;::iterator i = objectHash.find(obj);
while (i != objectHash.end() &amp;amp;&amp;amp; i.key() == obj) {
    if (i.value() == 0) {
        i = objectHash.erase(i);
    } else {
        ++i;
    }
}
</db:programlisting>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#take">take</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#find">find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find">
<db:title>QHash::iterator QHash::find(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash::iterator</db:type>
<db:methodname>find</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::iterator find(const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an iterator pointing to the item with the <db:code role="parameter">key</db:code> in the hash.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function returns <db:link xlink:href="qhash.xml#end">end</db:link>().</db:para>
<db:para>If the hash contains multiple items with the <db:code role="parameter">key</db:code>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here's some code that iterates over all the items with the same key:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QString, int&amp;gt; hash;
...
QHash&amp;lt;QString, int&amp;gt;::const_iterator i = hash.find(&quot;HDR&quot;);
while (i != hash.end() &amp;amp;&amp;amp; i.key() == &quot;HDR&quot;) {
    cout &amp;lt;&amp;lt; i.value() &amp;lt;&amp;lt; Qt::endl;
    ++i;
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#value">value</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#values">values</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find-1">
<db:title>QHash::const_iterator QHash::find(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>find</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator find(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="insert">
<db:title>QHash::iterator QHash::insert(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::iterator insert(const Key &amp;key, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there is already an item with the <db:code role="parameter">key</db:code>, that item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
</db:section>
<db:section xml:id="insert-1">
<db:title>[since 5.15] void QHash::insert(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void insert(const QHash&lt;Key, T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts all the items in the <db:code role="parameter">other</db:code> hash into this hash.</db:para>
<db:para>If a key is common to both hashes, its value will be replaced with the value stored in <db:code role="parameter">other</db:code>.</db:para>
<db:note>
<db:para>If <db:code role="parameter">other</db:code> contains multiple entries with the same key then the final value of the key is undefined.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.15.</db:para>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QHash::isEmpty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isEmpty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isEmpty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the hash contains no items; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="key">
<db:title>Key QHash::key(const T &amp;<db:emphasis>value</db:emphasis>, const Key &amp;<db:emphasis>defaultKey</db:emphasis> = Key()) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>Key</db:type>
<db:methodname>key</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>defaultKey</db:parameter>
<db:initializer>Key()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">Key key(const T &amp;value, const Key &amp;defaultKey) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the first key mapped to <db:code role="parameter">value</db:code>, or <db:code role="parameter">defaultKey</db:code> if the hash contains no item mapped to <db:code role="parameter">value</db:code>.</db:para>
<db:para>This function can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal data structure is optimized for fast lookup by key, not by value.</db:para>
</db:section>
<db:section xml:id="keyBegin">
<db:title>[since 5.6] QHash::key_iterator QHash::keyBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::key_iterator</db:type>
<db:methodname>keyBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::key_iterator keyBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first key in the hash.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyEnd">keyEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyEnd">
<db:title>[since 5.6] QHash::key_iterator QHash::keyEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::key_iterator</db:type>
<db:methodname>keyEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::key_iterator keyEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last key in the hash.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyBegin">keyBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueBegin">
<db:title>[since 5.10] QHash::key_value_iterator QHash::keyValueBegin()</db:title>
<db:methodsynopsis>
<db:type>QHash::key_value_iterator</db:type>
<db:methodname>keyValueBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::key_value_iterator keyValueBegin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueEnd">keyValueEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueBegin-1">
<db:title>[since 5.10] QHash::const_key_value_iterator QHash::keyValueBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_key_value_iterator</db:type>
<db:methodname>keyValueBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_key_value_iterator keyValueBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueEnd">keyValueEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueEnd">
<db:title>[since 5.10] QHash::key_value_iterator QHash::keyValueEnd()</db:title>
<db:methodsynopsis>
<db:type>QHash::key_value_iterator</db:type>
<db:methodname>keyValueEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::key_value_iterator keyValueEnd()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueEnd-1">
<db:title>[since 5.10] QHash::const_key_value_iterator QHash::keyValueEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_key_value_iterator</db:type>
<db:methodname>keyValueEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_key_value_iterator keyValueEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keys">
<db:title>QList&lt;Key&gt; QHash::keys() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;Key&gt;</db:type>
<db:methodname>keys</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;Key&gt; keys() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list containing all the keys in the hash, in an arbitrary order.</db:para>
<db:para>The order is guaranteed to be the same as that used by <db:link xlink:href="qhash.xml#values">values</db:link>().</db:para>
<db:para>This function creates a new list, in <db:link xlink:href="containers.xml#linear-time">linear time</db:link>. The time and memory use that entails can be avoided by iterating from <db:link xlink:href="qhash.xml#keyBegin">keyBegin</db:link>() to <db:link xlink:href="qhash.xml#keyEnd">keyEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#values">values</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#key">key</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keys-1">
<db:title>QList&lt;Key&gt; QHash::keys(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;Key&gt;</db:type>
<db:methodname>keys</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;Key&gt; keys(const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a list containing all the keys associated with value <db:code role="parameter">value</db:code>, in an arbitrary order.</db:para>
<db:para>This function can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal data structure is optimized for fast lookup by key, not by value.</db:para>
</db:section>
<db:section xml:id="load_factor">
<db:title>float QHash::load_factor() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>float</db:type>
<db:methodname>load_factor</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">float load_factor() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current load factor of the <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal hash table. This is the same as <db:link xlink:href="qhash.xml#capacity">capacity</db:link>()/<db:link xlink:href="qhash.xml#size">size</db:link>(). The implementation used will aim to keep the load factor between 0.25 and 0.5. This avoids having too many hash table collisions that would degrade performance.</db:para>
<db:para>Even with a low load factor, the implementation of the hash table has a very low memory overhead.</db:para>
<db:para>This method purely exists for diagnostic purposes and you should rarely need to call it yourself.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remove">
<db:title>bool QHash::remove(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool remove(const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the item that has the <db:code role="parameter">key</db:code> from the hash. Returns true if the key exists in the hash and the item has been removed, and false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#clear">clear</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#take">take</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeIf">
<db:title>[since 6.1] qsizetype QHash::removeIf(Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>removeIf</db:methodname>
<db:methodparam>
<db:type>Predicate</db:type>
<db:parameter>pred</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype removeIf(Predicate pred)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the hash.</db:para>
<db:para>The function supports predicates which take either an argument of type QHash&lt;Key, T&gt;::iterator, or an argument of type std::pair&lt;const Key &amp;, T &amp;&gt;.</db:para>
<db:para>Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#clear">clear</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#take">take</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reserve">
<db:title>void QHash::reserve(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>reserve</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void reserve(qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Ensures that the <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal hash table has space to store at least <db:code role="parameter">size</db:code> items without having to grow the hash table.</db:para>
<db:para>This implies that the hash table will contain at least 2 * <db:code role="parameter">size</db:code> buckets to ensure good performance</db:para>
<db:para>This function is useful for code that needs to build a huge hash and wants to avoid repeated reallocation. For example:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QString, int&amp;gt; hash;
hash.reserve(20000);
for (int i = 0; i &amp;lt; 20000; ++i)
    hash.insert(keys[i], values[i]);
</db:programlisting>
<db:para>Ideally, <db:code role="parameter">size</db:code> should be the maximum number of items expected in the hash. <db:link xlink:href="qhash.xml#qhash">QHash</db:link> will then choose the smallest possible number of buckets that will allow storing <db:code role="parameter">size</db:code> items in the table without having to grow the internal hash table. If <db:code role="parameter">size</db:code> is an underestimate, the worst that will happen is that the <db:link xlink:href="qhash.xml#qhash">QHash</db:link> will be a bit slower.</db:para>
<db:para>In general, you will rarely ever need to call this function. <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal hash table automatically grows to provide good performance without wasting too much memory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#squeeze">squeeze</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>qsizetype QHash::size() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype size() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of items in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#count-1">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="squeeze">
<db:title>void QHash::squeeze()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>squeeze</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void squeeze()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reduces the size of the <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal hash table to save memory.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s memory usage. In general, you will rarely ever need to call this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QHash::swap(QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QHash&lt;Key, T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps hash <db:code role="parameter">other</db:code> with this hash. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="take">
<db:title>T QHash::take(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>take</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T take(const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the item with the <db:code role="parameter">key</db:code> from the hash and returns the value associated with it.</db:para>
<db:para>If the item does not exist in the hash, the function simply returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:para>If you don't use the return value, <db:link xlink:href="qhash.xml#remove">remove</db:link>() is more efficient.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value">
<db:title>T QHash::value(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>defaultValue</db:emphasis> = T()) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>T()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T value(const Key &amp;key, const T &amp;defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the value associated with the <db:code role="parameter">key</db:code>.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function returns <db:code role="parameter">defaultValue</db:code>, which is a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> if the parameter has not been specified.</db:para>
</db:section>
<db:section xml:id="values">
<db:title>QList&lt;T&gt; QHash::values() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>values</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; values() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list containing all the values in the hash, in an arbitrary order.</db:para>
<db:para>The order is guaranteed to be the same as that used by <db:link xlink:href="qhash.xml#keys">keys</db:link>().</db:para>
<db:para>This function creates a new list, in <db:link xlink:href="containers.xml#linear-time">linear time</db:link>. The time and memory use that entails can be avoided by iterating from <db:link xlink:href="qhash.xml#keyValueBegin">keyValueBegin</db:link>() to <db:link xlink:href="qhash.xml#keyValueEnd">keyValueEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keys">keys</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>QTypeTraits::compare_eq_result&lt;U&gt; QHash::operator!=(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QTypeTraits::compare_eq_result&lt;U&gt;</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QTypeTraits::compare_eq_result&lt;U&gt; operator!=(const QHash&lt;Key, T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if <db:code role="parameter">other</db:code> is not equal to this hash; otherwise returns false.</db:para>
<db:para>Two hashes are considered equal if they contain the same (key, value) pairs.</db:para>
<db:para>This function requires the value type to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QHash&lt;Key, T&gt; &amp;QHash::operator=(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash&lt;Key, T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash&lt;Key, T&gt; &amp; operator=(const QHash&lt;Key, T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">other</db:code> to this hash and returns a reference to this hash.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[since 5.2] QHash&lt;Key, T&gt; &amp;QHash::operator=(QHash&lt;Key, T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash&lt;Key, T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QHash&lt;Key, T&gt; &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash&lt;Key, T&gt; &amp; operator=(QHash&lt;Key, T&gt; &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qhash.xml#qhash">QHash</db:link> instance.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>QTypeTraits::compare_eq_result&lt;U&gt; QHash::operator==(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QTypeTraits::compare_eq_result&lt;U&gt;</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QTypeTraits::compare_eq_result&lt;U&gt; operator==(const QHash&lt;Key, T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if <db:code role="parameter">other</db:code> is equal to this hash; otherwise returns false.</db:para>
<db:para>Two hashes are considered equal if they contain the same (key, value) pairs.</db:para>
<db:para>This function requires the value type to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>T &amp;QHash::operator[](const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; operator[](const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the value associated with the <db:code role="parameter">key</db:code> as a modifiable reference.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function inserts a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> into the hash with the <db:code role="parameter">key</db:code>, and returns a reference to it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>const T QHash::operator[](const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T operator[](const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qhash.xml#value">value</db:link>().</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="erase_if">
<db:title>[since 6.1] qsizetype erase_if(QHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>, Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>erase_if</db:methodname>
<db:methodparam>
<db:type>QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>hash</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Predicate</db:type>
<db:parameter>pred</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype erase_if(QHash&lt;Key, T&gt; &amp;hash, Predicate pred)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the hash <db:code role="parameter">hash</db:code>.</db:para>
<db:para>The function supports predicates which take either an argument of type QHash&lt;Key, T&gt;::iterator, or an argument of type std::pair&lt;const Key &amp;, T &amp;&gt;.</db:para>
<db:para>Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
</db:section>
<db:section xml:id="qGlobalQHashSeed">
<db:title>[since 5.6] int qGlobalQHashSeed()</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qGlobalQHashSeed</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qGlobalQHashSeed()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current global <db:link xlink:href="qhash.xml#qhash">QHash</db:link> seed.</db:para>
<db:para>The seed is set in any newly created <db:link xlink:href="qhash.xml#qhash">QHash</db:link>. See <db:link xlink:href="qhash.xml#qhash">qHash</db:link> about how this seed is being used by <db:link xlink:href="qhash.xml#qhash">QHash</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qSetGlobalQHashSeed">qSetGlobalQHashSeed</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHash">
<db:title>[since 5.0] size_t qHash(const QUrl &amp;<db:emphasis>url</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QUrl &amp;url, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">url</db:code>. If specified, <db:code role="parameter">seed</db:code> is used to initialize the hash.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-1x">
<db:title>[since 5.0] size_t qHash(const QDateTime &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QDateTime &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QDateTime &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-2x">
<db:title>[since 5.0] size_t qHash(QDate <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>QDate</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(QDate key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-3x">
<db:title>[since 5.0] size_t qHash(QTime <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>QTime</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(QTime key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-4x">
<db:title>[since 5.7] size_t qHash(const std::pair&lt;T1, T2&gt; &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const std::pair&lt;T1, T2&gt; &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const std::pair&lt;T1, T2&gt; &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Types T1 and T2 must be supported by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="qHash-5">
<db:title>[constexpr, since 5.0] size_t qHash(char <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(char key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-6">
<db:title>[constexpr, since 5.0] size_t qHash(uchar <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>uchar</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(uchar key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-7">
<db:title>[constexpr, since 5.0] size_t qHash(signed char <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>signed char</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(signed char key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-8">
<db:title>[constexpr, since 5.0] size_t qHash(ushort <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>ushort</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">8</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(ushort key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-9">
<db:title>[constexpr, since 5.0] size_t qHash(short <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>short</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">9</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(short key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-10">
<db:title>[constexpr, since 5.0] size_t qHash(uint <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">10</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(uint key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-11">
<db:title>[constexpr, since 5.0] size_t qHash(int <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">11</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(int key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-12">
<db:title>[constexpr, since 5.0] size_t qHash(ulong <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>ulong</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">12</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(ulong key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-13">
<db:title>[constexpr, since 5.0] size_t qHash(long <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>long</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">13</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(long key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-14">
<db:title>[constexpr, since 5.0] size_t qHash(quint64 <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">14</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(quint64 key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-15">
<db:title>[constexpr, since 5.0] size_t qHash(qint64 <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">15</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(qint64 key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-16">
<db:title>[constexpr, since 6.0] size_t qHash(char16_t <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>char16_t</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">16</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(char16_t key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-17">
<db:title>[constexpr, since 6.0] size_t qHash(char32_t <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>char32_t</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">17</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(char32_t key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-18">
<db:title>[constexpr, since 6.0] size_t qHash(wchar_t <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>wchar_t</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">18</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(wchar_t key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-19">
<db:title>[since 5.3] size_t qHash(float <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>float</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">19</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(float key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="qHash-20">
<db:title>[since 5.3] size_t qHash(double <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>double</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">20</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(double key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="qHash-21">
<db:title>[since 5.3] size_t qHash(long double <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>long double</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">21</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(long double key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="qHash-22">
<db:title>[constexpr, since 5.0] size_t qHash(const QChar <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QChar</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">22</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QChar key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-23">
<db:title>[since 5.0] size_t qHash(const QByteArray &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">23</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QByteArray &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-24">
<db:title>[since 6.0] size_t qHash(const QByteArrayView &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QByteArrayView &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">24</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QByteArrayView &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-25">
<db:title>[since 5.0] size_t qHash(const QBitArray &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QBitArray &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">25</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QBitArray &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-26">
<db:title>[since 5.0] size_t qHash(const QString &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">26</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QString &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-27">
<db:title>[since 5.0] size_t qHash(QLatin1String <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>QLatin1String</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">27</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(QLatin1String key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-28">
<db:title>[since 5.0] size_t qHash(const T *<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const T *</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">28</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const T *key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-29">
<db:title>[constexpr, since 6.0] size_t qHash(std::nullptr_t <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>std::nullptr_t</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">29</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(std::nullptr_t key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-30">
<db:title>[since 5.8] size_t qHash(const QHash&lt;Key, T&gt; &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">30</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QHash&lt;Key, T&gt; &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Type T must be supported by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
</db:section>
<db:section xml:id="qHash-31">
<db:title>[since 6.0] size_t qHash(QPoint <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>QPoint</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">31</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(QPoint key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-32">
<db:title>[since 5.5] size_t qHash(const QSet&lt;T&gt; &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">32</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QSet&lt;T&gt; &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>The hash value is independent of the order of elements in <db:code role="parameter">key</db:code>, that is, sets that contain the same elements hash to the same value.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
</db:section>
<db:section xml:id="qHash-33">
<db:title>[since 5.6] size_t qHash(const QVersionNumber &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QVersionNumber &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">33</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QVersionNumber &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="qHash-34">
<db:title>[since 6.0] size_t qHash(const QTypeRevision &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QTypeRevision &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">34</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QTypeRevision &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHashBits">
<db:title>[since 5.4] size_t qHashBits(const void *<db:emphasis>p</db:emphasis>, size_t <db:emphasis>len</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHashBits</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>p</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHashBits(const void *p, size_t len, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the memory block of size <db:code role="parameter">len</db:code> pointed to by <db:code role="parameter">p</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Use this function only to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types. For example, here's how you could implement a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overload for std::vector&lt;int&gt;:</db:para>
<db:programlisting language="cpp">inline size_t qHash(const std::vector&amp;lt;int&amp;gt; &amp;amp;key, size_t seed = 0)
{
    if (key.empty())
        return seed;
    else
        return qHashBits(&amp;amp;key.front(), key.size() * sizeof(int), seed);
}
</db:programlisting>
<db:para>This takes advantage of the fact that std::vector lays out its data contiguously. If that is not the case, or the contained type has padding, you should use <db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>() instead.</db:para>
<db:para>It bears repeating that the implementation of qHashBits() - like the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt - may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that qHashBits() will give the same results (for the same inputs) across different Qt versions.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRangeCommutative">qHashRangeCommutative</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHashMulti">
<db:title>[constexpr, since 6.0] size_t qHashMulti(size_t <db:emphasis>seed</db:emphasis>, const T &amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHashMulti</db:methodname>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;...</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHashMulti(size_t seed, const T &amp;... args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">args</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation, by successively applying <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() to each element and combining the hash values into a single one.</db:para>
<db:para>Note that the order of the arguments is significant. If order does not matter, use <db:link xlink:href="qhash.xml#qHashMultiCommutative">qHashMultiCommutative</db:link>() instead. If you are hashing raw memory, use <db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>(); if you are hashing a range, use <db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>().</db:para>
<db:para>This function is provided as a convenience to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types. For example, here's how you could implement a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overload for a class Employee:</db:para>
<db:programlisting language="cpp">#ifndef EMPLOYEE_H
#define EMPLOYEE_H

class Employee
{
public:
    Employee() {}
    Employee(const QString &amp;amp;name, QDate dateOfBirth);
    ...

private:
    QString myName;
    QDate myDateOfBirth;
};

inline bool operator==(const Employee &amp;amp;e1, const Employee &amp;amp;e2)
{
    return e1.name() == e2.name()
           &amp;amp;&amp;amp; e1.dateOfBirth() == e2.dateOfBirth();
}

inline size_t qHash(const Employee &amp;amp;key, size_t seed)
{
    return qHashMulti(seed, key.name(), key.dateOfBirth());
}

#endif // EMPLOYEE_H
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashMultiCommutative">qHashMultiCommutative</db:link></db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHashMultiCommutative">
<db:title>[constexpr, since 6.0] size_t qHashMultiCommutative(size_t <db:emphasis>seed</db:emphasis>, const T &amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHashMultiCommutative</db:methodname>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;...</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHashMultiCommutative(size_t seed, const T &amp;... args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">args</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation, by successively applying <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() to each element and combining the hash values into a single one.</db:para>
<db:para>The order of the arguments is insignificant. If order does matter, use <db:link xlink:href="qhash.xml#qHashMulti">qHashMulti</db:link>() instead, as it may produce better quality hashing. If you are hashing raw memory, use <db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>(); if you are hashing a range, use <db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>().</db:para>
<db:para>This function is provided as a convenience to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashMulti">qHashMulti</db:link></db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHashRange">
<db:title>[since 5.5] size_t qHashRange(InputIterator <db:emphasis>first</db:emphasis>, InputIterator <db:emphasis>last</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHashRange</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>first</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>last</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHashRange(InputIterator first, InputIterator last, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the range [<db:code role="parameter">first</db:code>,<db:code role="parameter">last</db:code>), using <db:code role="parameter">seed</db:code> to seed the calculation, by successively applying <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() to each element and combining the hash values into a single one.</db:para>
<db:para>The return value of this function depends on the order of elements in the range. That means that</db:para>
<db:programlisting language="cpp">{0, 1, 2}
</db:programlisting>
<db:para>and</db:para>
<db:programlisting language="cpp">{1, 2, 0}
</db:programlisting>
<db:para>hash to <db:emphasis role="bold">different</db:emphasis> values. If order does not matter, for example for hash tables, use <db:link xlink:href="qhash.xml#qHashRangeCommutative">qHashRangeCommutative</db:link>() instead. If you are hashing raw memory, use <db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>().</db:para>
<db:para>Use this function only to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types. For example, here's how you could implement a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overload for std::vector&lt;int&gt;:</db:para>
<db:programlisting language="cpp">inline size_t qHash(const std::vector&amp;lt;int&amp;gt; &amp;amp;key, size_t seed = 0)
{
    return qHashRange(key.begin(), key.end(), seed);
}
</db:programlisting>
<db:para>It bears repeating that the implementation of qHashRange() - like the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt - may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that qHashRange() will give the same results (for the same inputs) across different Qt versions, even if <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for the element type would.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRangeCommutative">qHashRangeCommutative</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHashRangeCommutative">
<db:title>[since 5.5] size_t qHashRangeCommutative(InputIterator <db:emphasis>first</db:emphasis>, InputIterator <db:emphasis>last</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHashRangeCommutative</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>first</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>last</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHashRangeCommutative(InputIterator first, InputIterator last, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the range [<db:code role="parameter">first</db:code>,<db:code role="parameter">last</db:code>), using <db:code role="parameter">seed</db:code> to seed the calculation, by successively applying <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() to each element and combining the hash values into a single one.</db:para>
<db:para>The return value of this function does not depend on the order of elements in the range. That means that</db:para>
<db:programlisting language="cpp">{0, 1, 2}
</db:programlisting>
<db:para>and</db:para>
<db:programlisting language="cpp">{1, 2, 0}
</db:programlisting>
<db:para>hash to the <db:emphasis role="bold">same</db:emphasis> values. If order matters, for example, for vectors and arrays, use <db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>() instead. If you are hashing raw memory, use <db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>().</db:para>
<db:para>Use this function only to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types. For example, here's how you could implement a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overload for std::unordered_set&lt;int&gt;:</db:para>
<db:programlisting language="cpp">inline size_t qHash(const std::unordered_set&amp;lt;int&amp;gt; &amp;amp;key, size_t seed = 0)
{
    return qHashRangeCommutative(key.begin(), key.end(), seed);
}
</db:programlisting>
<db:para>It bears repeating that the implementation of qHashRangeCommutative() - like the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt - may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that qHashRangeCommutative() will give the same results (for the same inputs) across different Qt versions, even if <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for the element type would.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qSetGlobalQHashSeed">
<db:title>[since 5.6] void qSetGlobalQHashSeed(int <db:emphasis>newSeed</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qSetGlobalQHashSeed</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>newSeed</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qSetGlobalQHashSeed(int newSeed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the global <db:link xlink:href="qhash.xml#qhash">QHash</db:link> seed to <db:code role="parameter">newSeed</db:code>.</db:para>
<db:para>Manually setting the global <db:link xlink:href="qhash.xml#qhash">QHash</db:link> seed value should be done only for testing and debugging purposes, when deterministic and reproducible behavior on a <db:link xlink:href="qhash.xml#qhash">QHash</db:link> is needed. We discourage to do it in production code as it can make your application susceptible to <db:link xlink:href="qhash.xml#algorithmic-complexity-attacks">algorithmic complexity attacks</db:link>.</db:para>
<db:para>From Qt 5.10 and onwards, the only allowed values are 0 and -1. Passing the value -1 will reinitialize the global <db:link xlink:href="qhash.xml#qhash">QHash</db:link> seed to a random value, while the value of 0 is used to request a stable algorithm for C++ primitive types types (like int) and string types (<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qbytearray.xml">QByteArray</db:link>).</db:para>
<db:para>The seed is set in any newly created <db:link xlink:href="qhash.xml#qhash">QHash</db:link>. See <db:link xlink:href="qhash.xml#qhash">qHash</db:link> about how this seed is being used by <db:link xlink:href="qhash.xml#qhash">QHash</db:link>.</db:para>
<db:para>If the environment variable QT_HASH_SEED is set, calling this function will result in a no-op.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qGlobalQHashSeed">qGlobalQHashSeed</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt">
<db:title>QDataStreamIfHasOStreamOperators&lt;Key, T&gt; operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStreamIfHasOStreamOperators&lt;Key, T&gt;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>out</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>hash</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStreamIfHasOStreamOperators&lt;Key, T&gt; operator&lt;&lt;(QDataStream &amp;out, const QHash&lt;Key, T&gt; &amp;hash)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the hash <db:code role="parameter">hash</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:para>This function requires the key and value types to implement operator&lt;&lt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStreamIfHasIStreamOperators&lt;Key, T&gt; operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStreamIfHasIStreamOperators&lt;Key, T&gt;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>in</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>hash</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStreamIfHasIStreamOperators&lt;Key, T&gt; operator&gt;&gt;(QDataStream &amp;in, QHash&lt;Key, T&gt; &amp;hash)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a hash from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">hash</db:code>.</db:para>
<db:para>This function requires the key and value types to implement operator&gt;&gt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
