<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QHash Class</db:title>
<db:subtitle>template &lt;typename Key, typename T&gt; class QHash</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> class is a template class that provides a hash-table-based dictionary.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
<db:para>This class is <db:emphasis>equality-comparable</db:emphasis>.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QHash</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QHash is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>&lt;Key, T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores (key, value) pairs and provides very fast lookup of the value associated with a key.</db:para>
<db:para><db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> provides very similar functionality to <db:link xlink:href="qmap.xml">QMap</db:link>. The differences are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> provides faster lookups than <db:link xlink:href="qmap.xml">QMap</db:link>. (See <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for details.)</db:para>
</db:listitem>
<db:listitem>
<db:para>When iterating over a <db:link xlink:href="qmap.xml">QMap</db:link>, the items are always sorted by key. With <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>, the items are arbitrarily ordered.</db:para>
</db:listitem>
<db:listitem>
<db:para>The key type of a <db:link xlink:href="qmap.xml">QMap</db:link> must provide operator&lt;(). The key type of a <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> must provide operator==() and a global hash function called <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() (see <db:link xlink:href="qhash.xml#the-hashing-function">qHash</db:link>).</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Here's an example <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> with <db:link xlink:href="qstring.xml">QString</db:link> keys and int values:</db:para>
<db:programlisting language="cpp">QHash&lt;QString, int&gt; hash;
</db:programlisting>
<db:para>To insert a (key, value) pair into the hash, you can use operator[]():</db:para>
<db:programlisting language="cpp">hash[&quot;one&quot;] = 1;
hash[&quot;three&quot;] = 3;
hash[&quot;seven&quot;] = 7;
</db:programlisting>
<db:para>This inserts the following three (key, value) pairs into the <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>: (&quot;one&quot;, 1), (&quot;three&quot;, 3), and (&quot;seven&quot;, 7). Another way to insert items into the hash is to use <db:link xlink:href="qhash.xml#insert">insert</db:link>():</db:para>
<db:programlisting language="cpp">hash.insert(&quot;twelve&quot;, 12);
</db:programlisting>
<db:para>To look up a value, use operator[]() or value():</db:para>
<db:programlisting language="cpp">int num1 = hash[&quot;thirteen&quot;];
int num2 = hash.value(&quot;thirteen&quot;);
</db:programlisting>
<db:para>If there is no item with the specified key in the hash, these functions return a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:para>If you want to check whether the hash contains a particular key, use <db:link xlink:href="qhash.xml#contains">contains</db:link>():</db:para>
<db:programlisting language="cpp">int timeout = 30;
if (hash.contains(&quot;TIMEOUT&quot;))
    timeout = hash.value(&quot;TIMEOUT&quot;);
</db:programlisting>
<db:para>There is also a value() overload that uses its second argument as a default value if there is no item with the specified key:</db:para>
<db:programlisting language="cpp">int timeout = hash.value(&quot;TIMEOUT&quot;, 30);
</db:programlisting>
<db:para>In general, we recommend that you use <db:link xlink:href="qhash.xml#contains">contains</db:link>() and value() rather than operator[]() for looking up a key in a hash. The reason is that operator[]() silently inserts an item into the hash if no item exists with the same key (unless the hash is const). For example, the following code snippet will create 1000 items in memory:</db:para>
<db:programlisting language="cpp">// WRONG
QHash&lt;int, QWidget *&gt; hash;
...
for (int i = 0; i &lt; 1000; ++i) {
    if (hash[i] == okButton)
        cout &lt;&lt; &quot;Found button at index &quot; &lt;&lt; i &lt;&lt; endl;
}
</db:programlisting>
<db:para>To avoid this problem, replace hash[i] with hash.value(i) in the code above.</db:para>
<db:para>Internally, <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> uses a hash table to perform lookups. This hash table automatically grows to provide fast lookups without wasting too much memory. You can still control the size of the hash table by calling <db:link xlink:href="qhash.xml#reserve">reserve</db:link>() if you already know approximately how many items the <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> will contain, but this isn't necessary to obtain good performance. You can also call <db:link xlink:href="qhash.xml#capacity">capacity</db:link>() to retrieve the hash table's size.</db:para>
<db:para><db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> will not shrink automatically if items are removed from the table. To minimize the memory used by the hash, call <db:link xlink:href="qhash.xml#squeeze">squeeze</db:link>().</db:para>
<db:para>If you want to navigate through all the (key, value) pairs stored in a <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>, you can use an iterator. <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> provides both <db:link xlink:href="java-style-iterators.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qhashiterator.xml">QHashIterator</db:link> and <db:link xlink:href="qmutablehashiterator.xml">QMutableHashIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qhash-const-iterator.xml">QHash::const_iterator</db:link> and <db:link xlink:href="qhash-iterator.xml">QHash::iterator</db:link>). Here's how to iterate over a <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, int&gt; using a Java-style iterator:</db:para>
<db:programlisting language="cpp">QHashIterator&lt;QString, int&gt; i(hash);
while (i.hasNext()) {
    i.next();
    cout &lt;&lt; qPrintable(i.key()) &lt;&lt; &quot;: &quot; &lt;&lt; i.value() &lt;&lt; endl;
}
</db:programlisting>
<db:para>Here's the same code, but using an STL-style iterator:</db:para>
<db:programlisting language="cpp">for (auto i = hash.cbegin(), end = hash.cend(); i != end; ++i)
    cout &lt;&lt; qPrintable(i.key()) &lt;&lt; &quot;: &quot; &lt;&lt; i.value() &lt;&lt; endl;
</db:programlisting>
<db:para><db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> is unordered, so an iterator's sequence cannot be assumed to be predictable. If ordering by key is required, use a <db:link xlink:href="qmap.xml">QMap</db:link>.</db:para>
<db:para>A <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> allows only one value per key. If you call <db:link xlink:href="qhash.xml#insert">insert</db:link>() with a key that already exists in the <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>, the previous value is erased. For example:</db:para>
<db:programlisting language="cpp">hash.insert(&quot;plenty&quot;, 100);
hash.insert(&quot;plenty&quot;, 2000);
// hash.value(&quot;plenty&quot;) == 2000
</db:programlisting>
<db:para>If you need to store multiple entries for the same key in the hash table, use <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>.</db:para>
<db:para>If you only need to extract the values from a hash (not the keys), you can also use range-based for:</db:para>
<db:programlisting language="cpp">QHash&lt;QString, int&gt; hash;
...
for (int value : std::as_const(hash))
    cout &lt;&lt; value &lt;&lt; endl;
</db:programlisting>
<db:para>Items can be removed from the hash in several ways. One way is to call <db:link xlink:href="qhash.xml#remove">remove</db:link>(); this will remove any item with the given key. Another way is to use <db:link xlink:href="qmutablehashiterator.xml#remove">QMutableHashIterator::remove</db:link>(). In addition, you can clear the entire hash using <db:link xlink:href="qhash.xml#clear">clear</db:link>().</db:para>
<db:para><db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s key and value data types must be <db:link xlink:href="containers.xml#assignable-data-types">assignable data types</db:link>. You cannot, for example, store a QWidget as a value; instead, store a QWidget *.</db:para>
<db:anchor xml:id="qhashx"/>
<db:section xml:id="the-hashing-function">
<db:title>The hashing function</db:title>
<db:para>A <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s key type has additional requirements other than being an assignable data type: it must provide operator==(), and there must also be a hashing function that returns a hash value for an argument of the key's type.</db:para>
<db:para>The hashing function computes a numeric value based on a key. It can use any algorithm imaginable, as long as it always returns the same value if given the same argument. In other words, if e1 == e2, then hash(e1) == hash(e2) must hold as well. However, to obtain good performance, the hashing function should attempt to return different hash values for different keys to the largest extent possible.</db:para>
<db:para>A hashing function for a key type K may be provided in two different ways.</db:para>
<db:para>The first way is by having an overload of qHash() in K's namespace. The qHash() function must have one of these signatures:</db:para>
<db:programlisting language="cpp">size_t qHash(K key, size_t seed);
size_t qHash(const K &amp;key, size_t seed);

size_t qHash(K key);        // deprecated, do not use
size_t qHash(const K &amp;key); // deprecated, do not use
</db:programlisting>
<db:para>The two-arguments overloads take an unsigned integer that should be used to seed the calculation of the hash function. This seed is provided by <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> in order to prevent a family of <db:link xlink:href="qhash.xml#algorithmic-complexity-attacks">algorithmic complexity attacks</db:link>.</db:para>
<db:note>
<db:para>In Qt 6 it is possible to define a qHash() overload taking only one argument; support for this is deprecated. Starting with Qt 7, it will be mandatory to use a two-arguments overload. If both a one-argument and a two-arguments overload are defined for a key type, the latter is used by <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> (note that you can simply define a two-arguments version, and use a default value for the seed parameter).</db:para>
</db:note>
<db:para>The second way to provide a hashing function is by specializing the std::hash class for the key type K, and providing a suitable function call operator for it:</db:para>
<db:programlisting language="cpp">namespace std {
template &lt;&gt; struct hash&lt;K&gt;
{
    // seed is optional
    size_t operator()(const K &amp;key, size_t seed = 0) const;
};
}
</db:programlisting>
<db:para>The seed argument has the same meaning as for qHash(), and may be left out.</db:para>
<db:para>This second way allows to reuse the same hash function between <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> and the C++ Standard Library unordered associative containers. If both a qHash() overload and a std::hash specializations are provided for a type, then the qHash() overload is preferred.</db:para>
<db:para>Here's a partial list of the C++ and Qt types that can serve as keys in a <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>: any integer type (char, unsigned long, etc.), any pointer type, <db:link xlink:href="qchar.xml">QChar</db:link>, <db:link xlink:href="qstring.xml">QString</db:link>, and <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. For all of these, the &lt;QHash&gt; header defines a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function that computes an adequate hash value. Many other Qt classes also declare a <db:link xlink:href="qhash.xml#the-hashing-function">qHash</db:link> overload for their type; please refer to the documentation of each class.</db:para>
<db:para>If you want to use other types as the key, make sure that you provide operator==() and a hash implementation.</db:para>
<db:para>The convenience <db:link xlink:href="qhash.xml#qHashMulti">qHashMulti</db:link>() function can be used to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for a custom type, where one usually wants to produce a hash value from multiple fields:</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">#ifndef EMPLOYEE_H
#define EMPLOYEE_H

class Employee
{
public:
    Employee() {}
    Employee(const QString &amp;name, QDate dateOfBirth);
    ...

private:
    QString myName;
    QDate myDateOfBirth;
};

inline bool operator==(const Employee &amp;e1, const Employee &amp;e2)
{
    return e1.name() == e2.name()
           &amp;&amp; e1.dateOfBirth() == e2.dateOfBirth();
}

inline size_t qHash(const Employee &amp;key, size_t seed)
{
    return qHashMulti(seed, key.name(), key.dateOfBirth());
}

#endif // EMPLOYEE_H
</db:programlisting>
<db:para>In the example above, we've relied on Qt's own implementation of <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for <db:link xlink:href="qstring.xml">QString</db:link> and <db:link xlink:href="qdate.xml">QDate</db:link> to give us a hash value for the employee's name and date of birth respectively.</db:para>
<db:para>Note that the implementation of the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() will give the same results (for the same inputs) across different Qt versions.</db:para>
</db:section>
<db:section xml:id="algorithmic-complexity-attacks">
<db:title>Algorithmic complexity attacks</db:title>
<db:para>All hash tables are vulnerable to a particular class of denial of service attacks, in which the attacker carefully pre-computes a set of different keys that are going to be hashed in the same bucket of a hash table (or even have the very same hash value). The attack aims at getting the worst-case algorithmic behavior (O(n) instead of amortized O(1), see <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for the details) when the data is fed into the table.</db:para>
<db:para>In order to avoid this worst-case behavior, the calculation of the hash value done by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() can be salted by a random seed, that nullifies the attack's extent. This seed is automatically generated by <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> once per process, and then passed by <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> as the second argument of the two-arguments overload of the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function.</db:para>
<db:para>This randomization of <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> is enabled by default. Even though programs should never depend on a particular <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> ordering, there may be situations where you temporarily need deterministic behavior, for example for debugging or regression testing. To disable the randomization, define the environment variable QT_HASH_SEED to have the value 0. Alternatively, you can call the <db:link xlink:href="qhashseed.xml#setDeterministicGlobalSeed">QHashSeed::setDeterministicGlobalSeed</db:link>() function.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhashiterator.xml">QHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablehashiterator.xml">QMutableHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmap.xml">QMap</db:link></db:member>
<db:member><db:link xlink:href="qset.xml">QSet</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QHash::ConstIterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qhash-const-iterator.xml">QHash::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>QHash::Iterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qhash-iterator.xml">QHash::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="const_key_value_iterator-typedef">
<db:title>QHash::const_key_value_iterator</db:title>
<db:para>The QHash::const_key_value_iterator typedef provides an STL-style const iterator for <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>.</db:para>
<db:para>QHash::const_key_value_iterator is essentially the same as <db:link xlink:href="qhash-const-iterator.xml">QHash::const_iterator</db:link> with the difference that operator*() returns a key/value pair instead of a value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>[alias] QHash::difference_type</db:title>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="key_type-typedef">
<db:title>[alias] QHash::key_type</db:title>
<db:para>Typedef for Key. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="key_value_iterator-typedef">
<db:title>QHash::key_value_iterator</db:title>
<db:para>The QHash::key_value_iterator typedef provides an STL-style iterator for <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>.</db:para>
<db:para>QHash::key_value_iterator is essentially the same as <db:link xlink:href="qhash-iterator.xml">QHash::iterator</db:link> with the difference that operator*() returns a key/value pair instead of a value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapped_type-typedef">
<db:title>[alias] QHash::mapped_type</db:title>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>[alias] QHash::size_type</db:title>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="value-2">
<db:title>[noexcept] T QHash::value(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:bridgehead renderas="sect2" xml:id="value-3">[noexcept] T QHash::value(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>defaultValue</db:emphasis>) const</db:bridgehead>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the value associated with the <db:code role="parameter">key</db:code>.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function returns <db:code role="parameter">defaultValue</db:code>, or a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> if this parameter has not been supplied.</db:para>
</db:section>
<db:section xml:id="key">
<db:title>[noexcept] Key QHash::key(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:bridgehead renderas="sect2" xml:id="key-1">[noexcept] Key QHash::key(const T &amp;<db:emphasis>value</db:emphasis>, const Key &amp;<db:emphasis>defaultKey</db:emphasis>) const</db:bridgehead>
<db:para>Returns the first key mapped to <db:code role="parameter">value</db:code>. If the hash contains no item mapped to <db:code role="parameter">value</db:code>, returns <db:code role="parameter">defaultKey</db:code>, or a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed key</db:link> if this parameter has not been supplied.</db:para>
<db:para>This function can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s internal data structure is optimized for fast lookup by key, not by value.</db:para>
</db:section>
<db:section xml:id="asKeyValueRange-1">
<db:title>[since 6.4] auto QHash::asKeyValueRange() &amp;</db:title>
<db:bridgehead renderas="sect2" xml:id="asKeyValueRange">[since 6.4] auto QHash::asKeyValueRange() &amp;&amp;</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="asKeyValueRange-3">[since 6.4] auto QHash::asKeyValueRange() const &amp;</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="asKeyValueRange-2">[since 6.4] auto QHash::asKeyValueRange() const &amp;&amp;</db:bridgehead>
<db:para>Returns a range object that allows iteration over this hash as key/value pairs. For instance, this range object can be used in a range-based for loop, in combination with a structured binding declaration:</db:para>
<db:programlisting language="cpp">QHash&lt;QString, int&gt; hash;
hash.insert(&quot;January&quot;, 1);
hash.insert(&quot;February&quot;, 2);
// ...
hash.insert(&quot;December&quot;, 12);

for (auto [key, value] : hash.asKeyValueRange()) {
    cout &lt;&lt; qPrintable(key) &lt;&lt; &quot;: &quot; &lt;&lt; value &lt;&lt; endl;
    --value; // convert to JS month indexing
}
</db:programlisting>
<db:para>Note that both the key and the value obtained this way are references to the ones in the hash. Specifically, mutating the value will modify the hash itself.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="emplace">
<db:title>QHash&lt;Key, T&gt;::iterator QHash::emplace(Key &amp;&amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="emplace-1">QHash&lt;Key, T&gt;::iterator QHash::emplace(const Key &amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:para>Inserts a new element into the container. This new element is constructed in-place using <db:code role="parameter">args</db:code> as the arguments for its construction.</db:para>
<db:para>Returns an iterator pointing to the new element.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
</db:section>
<db:section xml:id="tryEmplace">
<db:title>[since 6.9] QHash&lt;Key, T&gt;::TryEmplaceResult QHash::tryEmplace(K &amp;&amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="tryEmplace-1">[since 6.9] QHash&lt;Key, T&gt;::TryEmplaceResult QHash::tryEmplace(Key &amp;&amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="tryEmplace-2">[since 6.9] QHash&lt;Key, T&gt;::TryEmplaceResult QHash::tryEmplace(const Key &amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value constructed from <db:code role="parameter">args</db:code>. If an item with <db:code role="parameter">key</db:code> already exists, no insertion takes place.</db:para>
<db:para>Returns an instance of <db:link xlink:href="qhash-tryemplaceresult.xml">TryEmplaceResult</db:link>, a structure that holds an <db:link xlink:href="qhash-tryemplaceresult.xml#iterator-var">iterator</db:link> to the newly created item, or to the pre-existing item that prevented the insertion, and a boolean, <db:link xlink:href="qhash-tryemplaceresult.xml#inserted-var">inserted</db:link>, denoting whether the insertion took place.</db:para>
<db:para>For example, this can be used to avoid the pattern of comparing old and new size or double-lookups. Where you might previously have written code like:</db:para>
<db:programlisting language="cpp">QHash&lt;int, MyType&gt; hash;
// [...]
int myKey = getKey();
qsizetype oldSize = hash.size();
MyType &amp;elem = hash[myKey];
if (oldSize != hash.size()) // Size changed: new element!
    initialize(elem);
// [use elem...]
</db:programlisting>
<db:para>You can instead write:</db:para>
<db:programlisting language="cpp">QHash&lt;int, MyType&gt; hash;
// [...]
int myKey = getKey();
auto result = hash.tryEmplace(myKey);
if (result.inserted) // New element!
    initialize(*result.iterator);
// [use result.iterator...]
</db:programlisting>
<db:para>This function was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#emplace">emplace</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#tryInsert">tryInsert</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#insertOrAssign">insertOrAssign</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="tryInsert">
<db:title>[since 6.9] QHash&lt;Key, T&gt;::TryEmplaceResult QHash::tryInsert(K &amp;&amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="tryInsert-1">[since 6.9] QHash&lt;Key, T&gt;::TryEmplaceResult QHash::tryInsert(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>. If an item with <db:code role="parameter">key</db:code> already exists, no insertion takes place.</db:para>
<db:para>Returns an instance of <db:link xlink:href="qhash-tryemplaceresult.xml">TryEmplaceResult</db:link>, a structure that holds an <db:link xlink:href="qhash-tryemplaceresult.xml#iterator-var">iterator</db:link> to the newly created item, or to the pre-existing item that prevented the insertion, and a boolean, <db:link xlink:href="qhash-tryemplaceresult.xml#inserted-var">inserted</db:link>, denoting whether the insertion took place.</db:para>
<db:para>This function was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#tryEmplace">tryEmplace</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#insertOrAssign">insertOrAssign</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="try_emplace-3">
<db:title>[since 6.9] QHash&lt;Key, T&gt;::key_value_iterator QHash::try_emplace(QHash&lt;Key, T&gt;::const_iterator <db:emphasis>hint</db:emphasis>, K &amp;&amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="try_emplace-4">[since 6.9] QHash&lt;Key, T&gt;::key_value_iterator QHash::try_emplace(QHash&lt;Key, T&gt;::const_iterator <db:emphasis>hint</db:emphasis>, Key &amp;&amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="try_emplace-5">[since 6.9] QHash&lt;Key, T&gt;::key_value_iterator QHash::try_emplace(QHash&lt;Key, T&gt;::const_iterator <db:emphasis>hint</db:emphasis>, const Key &amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value constructed from <db:code role="parameter">args</db:code>. If an item with <db:code role="parameter">key</db:code> already exists, no insertion takes place.</db:para>
<db:para>Returns the iterator of the inserted item, or to the item that prevented the insertion.</db:para>
<db:para><db:code role="parameter">hint</db:code> is ignored.</db:para>
<db:para>These functions are provided for compatibility with the standard library.</db:para>
<db:para>This function was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#emplace">emplace</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#tryEmplace">tryEmplace</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#tryInsert">tryInsert</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#insertOrAssign">insertOrAssign</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="try_emplace">
<db:title>[since 6.9] std::pair&lt;QHash&lt;Key, T&gt;::key_value_iterator, bool&gt; QHash::try_emplace(K &amp;&amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="try_emplace-1">[since 6.9] std::pair&lt;QHash&lt;Key, T&gt;::key_value_iterator, bool&gt; QHash::try_emplace(Key &amp;&amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="try_emplace-2">[since 6.9] std::pair&lt;QHash&lt;Key, T&gt;::key_value_iterator, bool&gt; QHash::try_emplace(const Key &amp;<db:emphasis>key</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:bridgehead>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value constructed from <db:code role="parameter">args</db:code>. If an item with <db:code role="parameter">key</db:code> already exists, no insertion takes place.</db:para>
<db:para>Returns a pair consisting of an iterator to the inserted item (or to the item that prevented the insertion), and a bool denoting whether the insertion took place.</db:para>
<db:para>These functions are provided for compatibility with the standard library.</db:para>
<db:para>This function was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#emplace">emplace</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#tryEmplace">tryEmplace</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#tryInsert">tryInsert</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#insertOrAssign">insertOrAssign</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insertOrAssign">
<db:title>[since 6.9] QHash&lt;Key, T&gt;::TryEmplaceResult QHash::insertOrAssign(K &amp;&amp;<db:emphasis>key</db:emphasis>, Value &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="insertOrAssign-1">[since 6.9] QHash&lt;Key, T&gt;::TryEmplaceResult QHash::insertOrAssign(Key &amp;&amp;<db:emphasis>key</db:emphasis>, Value &amp;&amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="insertOrAssign-2">[since 6.9] QHash&lt;Key, T&gt;::TryEmplaceResult QHash::insertOrAssign(const Key &amp;<db:emphasis>key</db:emphasis>, Value &amp;&amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Attempts to insert an item with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>. If an item with <db:code role="parameter">key</db:code> already exists its value is overwritten with <db:code role="parameter">value</db:code>.</db:para>
<db:para>Returns an instance of <db:link xlink:href="qhash-tryemplaceresult.xml">TryEmplaceResult</db:link>, a structure that holds an <db:link xlink:href="qhash-tryemplaceresult.xml#iterator-var">iterator</db:link> to the item, and a boolean, <db:link xlink:href="qhash-tryemplaceresult.xml#inserted-var">inserted</db:link>, denoting whether the item was newly created (true) or if it previously existed (false).</db:para>
<db:para>This function was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#tryEmplace">tryEmplace</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#tryInsert">tryInsert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert_or_assign">
<db:title>[since 6.9] std::pair&lt;QHash&lt;Key, T&gt;::key_value_iterator, bool&gt; QHash::insert_or_assign(K &amp;&amp;<db:emphasis>key</db:emphasis>, Value &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="insert_or_assign-1">[since 6.9] std::pair&lt;QHash&lt;Key, T&gt;::key_value_iterator, bool&gt; QHash::insert_or_assign(Key &amp;&amp;<db:emphasis>key</db:emphasis>, Value &amp;&amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="insert_or_assign-2">[since 6.9] std::pair&lt;QHash&lt;Key, T&gt;::key_value_iterator, bool&gt; QHash::insert_or_assign(const Key &amp;<db:emphasis>key</db:emphasis>, Value &amp;&amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Attempts to insert an item with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>. If an item with <db:code role="parameter">key</db:code> already exists its value is overwritten with <db:code role="parameter">value</db:code>.</db:para>
<db:para>Returns a pair consisting of an iterator pointing to the item, and a boolean, denoting whether the item was newly created (true) or if it previously existed (false).</db:para>
<db:para>These functions are provided for compatibility with the standard library.</db:para>
<db:para>This function was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#tryEmplace">tryEmplace</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#tryInsert">tryInsert</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#insertOrAssign">insertOrAssign</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert_or_assign-3">
<db:title>[since 6.9] QHash&lt;Key, T&gt;::key_value_iterator QHash::insert_or_assign(QHash&lt;Key, T&gt;::const_iterator <db:emphasis>hint</db:emphasis>, K &amp;&amp;<db:emphasis>key</db:emphasis>, Value &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="insert_or_assign-4">[since 6.9] QHash&lt;Key, T&gt;::key_value_iterator QHash::insert_or_assign(QHash&lt;Key, T&gt;::const_iterator <db:emphasis>hint</db:emphasis>, Key &amp;&amp;<db:emphasis>key</db:emphasis>, Value &amp;&amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="insert_or_assign-5">[since 6.9] QHash&lt;Key, T&gt;::key_value_iterator QHash::insert_or_assign(QHash&lt;Key, T&gt;::const_iterator <db:emphasis>hint</db:emphasis>, const Key &amp;<db:emphasis>key</db:emphasis>, Value &amp;&amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Attempts to insert an item with the <db:code role="parameter">key</db:code> and <db:code role="parameter">value</db:code>. If an item with <db:code role="parameter">key</db:code> already exists its value is overwritten with <db:code role="parameter">value</db:code>.</db:para>
<db:para>Returns a pair consisting of an iterator pointing to the item, and a boolean, denoting whether the item was newly created (true) or if it previously existed (false).</db:para>
<db:para><db:code role="parameter">hint</db:code> is ignored.</db:para>
<db:para>These functions are provided for compatibility with the standard library.</db:para>
<db:para>This function was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#tryEmplace">tryEmplace</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#insertOrAssign">insertOrAssign</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QHashxx">
<db:title>[noexcept] QHash::QHash()</db:title>
<db:para>Constructs an empty hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QHash-3">
<db:title>QHash::QHash(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; <db:emphasis>list</db:emphasis>)</db:title>
<db:para>Constructs a hash with a copy of each of the elements in the initializer list <db:code role="parameter">list</db:code>.</db:para>
</db:section>
<db:section xml:id="QHash-4">
<db:title>QHash::QHash(InputIterator <db:emphasis>begin</db:emphasis>, InputIterator <db:emphasis>end</db:emphasis>)</db:title>
<db:para>Constructs a hash with a copy of each of the elements in the iterator range [<db:code role="parameter">begin</db:code>, <db:code role="parameter">end</db:code>). Either the elements iterated by the range must be objects with first and second data members (like std::pair), convertible to Key and to T respectively; or the iterators must have key() and value() member functions, returning a key convertible to Key and a value convertible to T respectively.</db:para>
</db:section>
<db:section xml:id="QHash-2">
<db:title>[noexcept] QHash::QHash(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:para>This operation occurs in <db:link xlink:href="containers.xml#constant-time">constant time</db:link>, because <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> is <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>. This makes returning a <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and this takes <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QHash-1">
<db:title>[noexcept] QHash::QHash(QHash&lt;Key, T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-constructs a <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
</db:section>
<db:section xml:id="dtor.QHash">
<db:title>QHash::~QHash()</db:title>
<db:para>Destroys the hash. References to the values in the hash and all iterators of this hash become invalid.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QHash&lt;Key, T&gt;::iterator QHash::begin()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>[noexcept] QHash&lt;Key, T&gt;::const_iterator QHash::begin() const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
</db:section>
<db:section xml:id="capacity">
<db:title>[noexcept] qsizetype QHash::capacity() const</db:title>
<db:para>Returns the number of buckets in the <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s internal hash table.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the hash, call <db:link xlink:href="qhash.xml#size">size</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>[noexcept] QHash&lt;Key, T&gt;::const_iterator QHash::cbegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[noexcept] QHash&lt;Key, T&gt;::const_iterator QHash::cend() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>[noexcept(...)] void QHash::clear()</db:title>
<db:para>Removes all items from the hash and frees up all memory used by it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>[noexcept] QHash&lt;Key, T&gt;::const_iterator QHash::constBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>[noexcept] QHash&lt;Key, T&gt;::const_iterator QHash::constEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind">
<db:title>[noexcept] QHash&lt;Key, T&gt;::const_iterator QHash::constFind(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns an iterator pointing to the item with the <db:code role="parameter">key</db:code> in the hash.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function returns <db:link xlink:href="qhash.xml#constEnd">constEnd</db:link>().</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#find">find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constKeyValueBegin">
<db:title>[noexcept] QHash&lt;Key, T&gt;::const_key_value_iterator QHash::constKeyValueBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constKeyValueEnd">
<db:title>[noexcept] QHash&lt;Key, T&gt;::const_key_value_iterator QHash::constKeyValueEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#constKeyValueBegin">constKeyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>[noexcept] bool QHash::contains(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns true if the hash contains an item with the <db:code role="parameter">key</db:code>; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#count-2">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>[noexcept] qsizetype QHash::count(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns the number of items associated with the <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count-2">
<db:title>[noexcept] qsizetype QHash::count() const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qhash.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="empty">
<db:title>[noexcept] bool QHash::empty() const</db:title>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qhash.xml#isEmpty">isEmpty</db:link>(), returning true if the hash is empty; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="end">
<db:title>[noexcept] QHash&lt;Key, T&gt;::iterator QHash::end()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>[noexcept] QHash&lt;Key, T&gt;::const_iterator QHash::end() const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
</db:section>
<db:section xml:id="erase">
<db:title>QHash&lt;Key, T&gt;::iterator QHash::erase(QHash&lt;Key, T&gt;::const_iterator <db:emphasis>pos</db:emphasis>)</db:title>
<db:para>Removes the (key, value) pair associated with the iterator <db:code role="parameter">pos</db:code> from the hash, and returns an iterator to the next item in the hash.</db:para>
<db:para>This function never causes <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> to rehash its internal data structure. This means that it can safely be called while iterating, and won't affect the order of items in the hash. For example:</db:para>
<db:programlisting language="cpp">QHash&lt;QObject *, int&gt; objectHash;
...
QHash&lt;QObject *, int&gt;::iterator i = objectHash.find(obj);
while (i != objectHash.end() &amp;&amp; i.key() == obj) {
    if (i.value() == 0) {
        i = objectHash.erase(i);
    } else {
        ++i;
    }
}
</db:programlisting>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#take">take</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#find">find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find">
<db:title>QHash&lt;Key, T&gt;::iterator QHash::find(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Returns an iterator pointing to the item with the <db:code role="parameter">key</db:code> in the hash.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function returns <db:link xlink:href="qhash.xml#end">end</db:link>().</db:para>
<db:para>If the hash contains multiple items with the <db:code role="parameter">key</db:code>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here's some code that iterates over all the items with the same key:</db:para>
<db:programlisting language="cpp">QHash&lt;QString, int&gt; hash;
...
QHash&lt;QString, int&gt;::const_iterator i = hash.find(&quot;HDR&quot;);
while (i != hash.end() &amp;&amp; i.key() == &quot;HDR&quot;) {
    cout &lt;&lt; i.value() &lt;&lt; endl;
    ++i;
}
</db:programlisting>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">value()</db:link></db:member>
<db:member><db:link xlink:href="qhash.xml#values">values</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find-3">
<db:title>[noexcept] QHash&lt;Key, T&gt;::const_iterator QHash::find(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
</db:section>
<db:section xml:id="insert">
<db:title>void QHash::insert(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Inserts all the items in the <db:code role="parameter">other</db:code> hash into this hash.</db:para>
<db:para>If a key is common to both hashes, its value will be replaced with the value stored in <db:code role="parameter">other</db:code>.</db:para>
</db:section>
<db:section xml:id="insert-1">
<db:title>QHash&lt;Key, T&gt;::iterator QHash::insert(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there is already an item with the <db:code role="parameter">key</db:code>, that item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
<db:para>Returns an iterator pointing to the new/updated element.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
</db:section>
<db:section xml:id="isEmpty">
<db:title>[noexcept] bool QHash::isEmpty() const</db:title>
<db:para>Returns true if the hash contains no items; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyBegin">
<db:title>[noexcept] QHash&lt;Key, T&gt;::key_iterator QHash::keyBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first key in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyEnd">keyEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyEnd">
<db:title>[noexcept] QHash&lt;Key, T&gt;::key_iterator QHash::keyEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last key in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyBegin">keyBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueBegin">
<db:title>QHash&lt;Key, T&gt;::key_value_iterator QHash::keyValueBegin()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueEnd">keyValueEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueBegin-1">
<db:title>[noexcept] QHash&lt;Key, T&gt;::const_key_value_iterator QHash::keyValueBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueEnd">keyValueEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueEnd">
<db:title>QHash&lt;Key, T&gt;::key_value_iterator QHash::keyValueEnd()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueEnd-1">
<db:title>[noexcept] QHash&lt;Key, T&gt;::const_key_value_iterator QHash::keyValueEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keys">
<db:title>QList&lt;Key&gt; QHash::keys() const</db:title>
<db:para>Returns a list containing all the keys in the hash, in an arbitrary order.</db:para>
<db:para>The order is guaranteed to be the same as that used by <db:link xlink:href="qhash.xml#values">values</db:link>().</db:para>
<db:para>This function creates a new list, in <db:link xlink:href="containers.xml#linear-time">linear time</db:link>. The time and memory use that entails can be avoided by iterating from <db:link xlink:href="qhash.xml#keyBegin">keyBegin</db:link>() to <db:link xlink:href="qhash.xml#keyEnd">keyEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#values">values</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#key">key</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keys-1">
<db:title>QList&lt;Key&gt; QHash::keys(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a list containing all the keys associated with value <db:code role="parameter">value</db:code>, in an arbitrary order.</db:para>
<db:para>This function can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s internal data structure is optimized for fast lookup by key, not by value.</db:para>
</db:section>
<db:section xml:id="load_factor">
<db:title>[noexcept] float QHash::load_factor() const</db:title>
<db:para>Returns the current load factor of the <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s internal hash table. This is the same as <db:link xlink:href="qhash.xml#capacity">capacity</db:link>()/<db:link xlink:href="qhash.xml#size">size</db:link>(). The implementation used will aim to keep the load factor between 0.25 and 0.5. This avoids having too many hash table collisions that would degrade performance.</db:para>
<db:para>Even with a low load factor, the implementation of the hash table has a very low memory overhead.</db:para>
<db:para>This method purely exists for diagnostic purposes and you should rarely need to call it yourself.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remove">
<db:title>bool QHash::remove(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes the item that has the <db:code role="parameter">key</db:code> from the hash. Returns true if the key exists in the hash and the item has been removed, and false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#clear">clear</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#take">take</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeIf">
<db:title>[since 6.1] qsizetype QHash::removeIf(Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the hash.</db:para>
<db:para>The function supports predicates which take either an argument of type QHash&lt;Key, T&gt;::iterator, or an argument of type std::pair&lt;const Key &amp;, T &amp;&gt;.</db:para>
<db:para>Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#clear">clear</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#take">take</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reserve">
<db:title>void QHash::reserve(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Ensures that the <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s internal hash table has space to store at least <db:code role="parameter">size</db:code> items without having to grow the hash table.</db:para>
<db:para>This implies that the hash table will contain at least 2 * <db:code role="parameter">size</db:code> buckets to ensure good performance</db:para>
<db:para>This function is useful for code that needs to build a huge hash and wants to avoid repeated reallocation. For example:</db:para>
<db:programlisting language="cpp">QHash&lt;QString, int&gt; hash;
hash.reserve(20000);
for (int i = 0; i &lt; 20000; ++i)
    hash.insert(keys[i], values[i]);
</db:programlisting>
<db:para>Ideally, <db:code role="parameter">size</db:code> should be the maximum number of items expected in the hash. <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> will then choose the smallest possible number of buckets that will allow storing <db:code role="parameter">size</db:code> items in the table without having to grow the internal hash table. If <db:code role="parameter">size</db:code> is an underestimate, the worst that will happen is that the <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> will be a bit slower.</db:para>
<db:para>In general, you will rarely ever need to call this function. <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s internal hash table automatically grows to provide good performance without wasting too much memory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#squeeze">squeeze</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>[noexcept] qsizetype QHash::size() const</db:title>
<db:para>Returns the number of items in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#count-2">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="squeeze">
<db:title>void QHash::squeeze()</db:title>
<db:para>Reduces the size of the <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s internal hash table to save memory.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>'s memory usage. In general, you will rarely ever need to call this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>[noexcept] void QHash::swap(QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps this hash with <db:code role="parameter">other</db:code>. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="take">
<db:title>T QHash::take(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes the item with the <db:code role="parameter">key</db:code> from the hash and returns the value associated with it.</db:para>
<db:para>If the item does not exist in the hash, the function simply returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:para>If you don't use the return value, <db:link xlink:href="qhash.xml#remove">remove</db:link>() is more efficient.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="values">
<db:title>QList&lt;T&gt; QHash::values() const</db:title>
<db:para>Returns a list containing all the values in the hash, in an arbitrary order.</db:para>
<db:para>The order is guaranteed to be the same as that used by <db:link xlink:href="qhash.xml#keys">keys</db:link>().</db:para>
<db:para>This function creates a new list, in <db:link xlink:href="containers.xml#linear-time">linear time</db:link>. The time and memory use that entails can be avoided by iterating from <db:link xlink:href="qhash.xml#keyValueBegin">keyValueBegin</db:link>() to <db:link xlink:href="qhash.xml#keyValueEnd">keyValueEnd</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keys">keys</db:link>()</db:member>
<db:member><db:link xlink:href="">value()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>[noexcept] QHash&lt;Key, T&gt; &amp;QHash::operator=(QHash&lt;Key, T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> instance.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[noexcept(...)] QHash&lt;Key, T&gt; &amp;QHash::operator=(const QHash&lt;Key, T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Assigns <db:code role="parameter">other</db:code> to this hash and returns a reference to this hash.</db:para>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>T &amp;QHash::operator[](const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Returns the value associated with the <db:code role="parameter">key</db:code> as a modifiable reference.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function inserts a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> into the hash with the <db:code role="parameter">key</db:code>, and returns a reference to it.</db:para>
<db:warning>
<db:para>Returned iterators/references should be considered invalidated the next time you call a non-const function on the hash, or when the hash is destroyed.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="">value()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-3">
<db:title>[noexcept] const T QHash::operator[](const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as value().</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="erase_if-1">
<db:title>[since 6.1] qsizetype erase_if(QHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>, Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the hash <db:code role="parameter">hash</db:code>.</db:para>
<db:para>The function supports predicates which take either an argument of type QHash&lt;Key, T&gt;::iterator, or an argument of type std::pair&lt;const Key &amp;, T &amp;&gt;.</db:para>
<db:para>Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
</db:section>
<db:section xml:id="qHash">
<db:title>[constexpr noexcept, since 6.5] size_t qHash(Enum <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:note>
<db:para>Prior to Qt 6.5, unscoped enums relied on the integer overloads of this function due to implicit conversion to their underlying integer types. For scoped enums, you had to implement an overload yourself. This is still the backwards-compatible fix to remain compatible with older Qt versions.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.5.</db:para>
</db:section>
<db:section xml:id="qHash-1x">
<db:title>[noexcept] size_t qHash(QDate <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-36">
<db:title>[constexpr noexcept] size_t qHash(ulong <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-37">
<db:title>[constexpr noexcept] size_t qHash(ushort <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-38">
<db:title>[constexpr noexcept, since 6.0] size_t qHash(wchar_t <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-2x">
<db:title>[noexcept] size_t qHash(QLatin1StringView <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-3x">
<db:title>[noexcept, since 6.0] size_t qHash(QPoint <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-4x">
<db:title>[noexcept] size_t qHash(QTime <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-5">
<db:title>[constexpr noexcept, since 6.9] size_t qHash(T <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis>)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:note>
<db:para>This is <db:link xlink:href="qhash.xml#the-hashing-function">qHash</db:link>(bool), constrained to accept only arguments of type bool, not arguments of types that merely convert to bool.</db:para>
</db:note>
<db:note>
<db:para>In Qt versions prior to 6.9, this overload was unintendedly provided by an undocumented 1-to-2-arg <db:link xlink:href="qhash.xml#the-hashing-function">qHash</db:link> adapter template function, with identical behavior.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.9.</db:para>
</db:section>
<db:section xml:id="qHash-6">
<db:title>[constexpr noexcept] size_t qHash(char <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-7">
<db:title>[constexpr noexcept, since 6.0] size_t qHash(char16_t <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-8">
<db:title>[constexpr noexcept, since 6.0] size_t qHash(char32_t <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-9">
<db:title>[constexpr noexcept, since 6.0] size_t qHash(char8_t <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-10">
<db:title>[noexcept] size_t qHash(const QBitArray &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-11">
<db:title>[noexcept] size_t qHash(const QByteArray &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-12">
<db:title>[constexpr noexcept] size_t qHash(const QChar <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-13">
<db:title>size_t qHash(const QDateTime &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-14">
<db:title>[noexcept(...)] size_t qHash(const QHash&lt;Key, T&gt; &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Types Key and T must be supported by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>().</db:para>
</db:section>
<db:section xml:id="qHash-15">
<db:title>[noexcept(...)] size_t qHash(const QSet&lt;T&gt; &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Type T must be supported by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>().</db:para>
<db:para>The hash value is independent of the order of elements in <db:code role="parameter">key</db:code>, that is, sets that contain the same elements hash to the same value.</db:para>
</db:section>
<db:section xml:id="qHash-16">
<db:title>[noexcept] size_t qHash(const QString &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-17">
<db:title>[since 6.0] size_t qHash(const QTypeRevision &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-18">
<db:title>[noexcept] size_t qHash(const QUrl &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-19">
<db:title>size_t qHash(const QVersionNumber &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-20">
<db:title>[noexcept] size_t qHash(const T *<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-21">
<db:title>[noexcept(...)] size_t qHash(const std::pair&lt;T1, T2&gt; &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Types T1 and T2 must be supported by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>().</db:para>
</db:section>
<db:section xml:id="qHash-22">
<db:title>[noexcept] size_t qHash(double <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-23">
<db:title>[noexcept] size_t qHash(float <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-24">
<db:title>[constexpr noexcept] size_t qHash(int <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-25">
<db:title>[constexpr noexcept] size_t qHash(long <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-26">
<db:title>[noexcept] size_t qHash(long double <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-27">
<db:title>[constexpr noexcept, since 6.8] size_t qHash(qint128 <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:note>
<db:para>This function is only available on platforms that support a native 128-bit integer type.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.8.</db:para>
</db:section>
<db:section xml:id="qHash-28">
<db:title>[constexpr noexcept] size_t qHash(qint64 <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-29">
<db:title>[constexpr noexcept, since 6.8] size_t qHash(quint128 <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:note>
<db:para>This function is only available on platforms that support a native 128-bit integer type.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.8.</db:para>
</db:section>
<db:section xml:id="qHash-30">
<db:title>[constexpr noexcept] size_t qHash(quint64 <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-31">
<db:title>[constexpr noexcept] size_t qHash(short <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-32">
<db:title>[constexpr noexcept] size_t qHash(signed char <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-33">
<db:title>[constexpr noexcept, since 6.0] size_t qHash(std::nullptr_t <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="qHash-34">
<db:title>[constexpr noexcept] size_t qHash(uchar <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHash-35">
<db:title>[constexpr noexcept] size_t qHash(uint <db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
</db:section>
<db:section xml:id="qHashBits">
<db:title>[noexcept] size_t qHashBits(const void *<db:emphasis>p</db:emphasis>, size_t <db:emphasis>len</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the memory block of size <db:code role="parameter">len</db:code> pointed to by <db:code role="parameter">p</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Use this function only to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types. For example, here's how you could implement a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overload for std::vector&lt;int&gt;:</db:para>
<db:programlisting language="cpp">inline size_t qHash(const std::vector&lt;int&gt; &amp;key, size_t seed = 0)
{
    if (key.empty())
        return seed;
    else
        return qHashBits(&amp;key.front(), key.size() * sizeof(int), seed);
}
</db:programlisting>
<db:para>This takes advantage of the fact that std::vector lays out its data contiguously. If that is not the case, or the contained type has padding, you should use <db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>() instead.</db:para>
<db:para>It bears repeating that the implementation of qHashBits() - like the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt - may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that qHashBits() will give the same results (for the same inputs) across different Qt versions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRangeCommutative">qHashRangeCommutative</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHashMulti">
<db:title>[constexpr noexcept(...), since 6.0] size_t qHashMulti(size_t <db:emphasis>seed</db:emphasis>, const T &amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">args</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation, by successively applying <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() to each element and combining the hash values into a single one.</db:para>
<db:para>Note that the order of the arguments is significant. If order does not matter, use <db:link xlink:href="qhash.xml#qHashMultiCommutative">qHashMultiCommutative</db:link>() instead. If you are hashing raw memory, use <db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>(); if you are hashing a range, use <db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>().</db:para>
<db:para>This function is provided as a convenience to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types. For example, here's how you could implement a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overload for a class Employee:</db:para>
<db:programlisting language="cpp">#ifndef EMPLOYEE_H
#define EMPLOYEE_H

class Employee
{
public:
    Employee() {}
    Employee(const QString &amp;name, QDate dateOfBirth);
    ...

private:
    QString myName;
    QDate myDateOfBirth;
};

inline bool operator==(const Employee &amp;e1, const Employee &amp;e2)
{
    return e1.name() == e2.name()
           &amp;&amp; e1.dateOfBirth() == e2.dateOfBirth();
}

inline size_t qHash(const Employee &amp;key, size_t seed)
{
    return qHashMulti(seed, key.name(), key.dateOfBirth());
}

#endif // EMPLOYEE_H
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashMultiCommutative">qHashMultiCommutative</db:link></db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHashMultiCommutative">
<db:title>[constexpr noexcept(...), since 6.0] size_t qHashMultiCommutative(size_t <db:emphasis>seed</db:emphasis>, const T &amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">args</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation, by successively applying <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() to each element and combining the hash values into a single one.</db:para>
<db:para>The order of the arguments is insignificant. If order does matter, use <db:link xlink:href="qhash.xml#qHashMulti">qHashMulti</db:link>() instead, as it may produce better quality hashing. If you are hashing raw memory, use <db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>(); if you are hashing a range, use <db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>().</db:para>
<db:para>This function is provided as a convenience to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashMulti">qHashMulti</db:link></db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHashRange">
<db:title>[noexcept(...)] size_t qHashRange(InputIterator <db:emphasis>first</db:emphasis>, InputIterator <db:emphasis>last</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the range [<db:code role="parameter">first</db:code>,<db:code role="parameter">last</db:code>), using <db:code role="parameter">seed</db:code> to seed the calculation, by successively applying <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() to each element and combining the hash values into a single one.</db:para>
<db:para>The return value of this function depends on the order of elements in the range. That means that</db:para>
<db:programlisting language="cpp">{0, 1, 2}
</db:programlisting>
<db:para>and</db:para>
<db:programlisting language="cpp">{1, 2, 0}
</db:programlisting>
<db:para>hash to <db:emphasis role="bold">different</db:emphasis> values. If order does not matter, for example for hash tables, use <db:link xlink:href="qhash.xml#qHashRangeCommutative">qHashRangeCommutative</db:link>() instead. If you are hashing raw memory, use <db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>().</db:para>
<db:para>Use this function only to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types. For example, here's how you could implement a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overload for std::vector&lt;int&gt;:</db:para>
<db:programlisting language="cpp">inline size_t qHash(const std::vector&lt;int&gt; &amp;key, size_t seed = 0)
{
    return qHashRange(key.begin(), key.end(), seed);
}
</db:programlisting>
<db:para>It bears repeating that the implementation of qHashRange() - like the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt - may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that qHashRange() will give the same results (for the same inputs) across different Qt versions, even if <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for the element type would.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRangeCommutative">qHashRangeCommutative</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHashRangeCommutative">
<db:title>[noexcept(...)] size_t qHashRangeCommutative(InputIterator <db:emphasis>first</db:emphasis>, InputIterator <db:emphasis>last</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the range [<db:code role="parameter">first</db:code>,<db:code role="parameter">last</db:code>), using <db:code role="parameter">seed</db:code> to seed the calculation, by successively applying <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() to each element and combining the hash values into a single one.</db:para>
<db:para>The return value of this function does not depend on the order of elements in the range. That means that</db:para>
<db:programlisting language="cpp">{0, 1, 2}
</db:programlisting>
<db:para>and</db:para>
<db:programlisting language="cpp">{1, 2, 0}
</db:programlisting>
<db:para>hash to the <db:emphasis role="bold">same</db:emphasis> values. If order matters, for example, for vectors and arrays, use <db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>() instead. If you are hashing raw memory, use <db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>().</db:para>
<db:para>Use this function only to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types. For example, here's how you could implement a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overload for std::unordered_set&lt;int&gt;:</db:para>
<db:programlisting language="cpp">inline size_t qHash(const std::unordered_set&lt;int&gt; &amp;key, size_t seed = 0)
{
    return qHashRangeCommutative(key.begin(), key.end(), seed);
}
</db:programlisting>
<db:para>It bears repeating that the implementation of qHashRangeCommutative() - like the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt - may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that qHashRangeCommutative() will give the same results (for the same inputs) across different Qt versions, even if <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for the element type would.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>[noexcept] bool operator!=(const QHash&lt;Key, T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const QHash&lt;Key, T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns true if <db:code role="parameter">lhs</db:code> hash is not equal to <db:code role="parameter">rhs</db:code> hash; otherwise returns false.</db:para>
<db:para>Two hashes are considered equal if they contain the same (key, value) pairs.</db:para>
<db:para>This function requires the value type to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt-8">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>)</db:title>
<db:para>Writes the hash <db:code role="parameter">hash</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:para>This function requires the key and value types to implement operator&lt;&lt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>[noexcept] bool operator==(const QHash&lt;Key, T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const QHash&lt;Key, T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns true if <db:code role="parameter">lhs</db:code> hash is equal to <db:code role="parameter">rhs</db:code> hash; otherwise returns false.</db:para>
<db:para>Two hashes are considered equal if they contain the same (key, value) pairs.</db:para>
<db:para>This function requires the value type to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt-6">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>)</db:title>
<db:para>Reads a hash from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">hash</db:code>.</db:para>
<db:para>This function requires the key and value types to implement operator&gt;&gt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QHash</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qhash.xml">QHash</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-related-non-members">
<db:title>Obsolete Related Non-Members</db:title>
<db:section xml:id="qGlobalQHashSeed">
<db:title>[deprecated in 6.6] int qGlobalQHashSeed()</db:title>
<db:para>This function is deprecated since 6.6. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qhashseed.xml#globalSeed">QHashSeed::globalSeed</db:link>() instead.</db:para>
<db:para>Returns the current global <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> seed.</db:para>
<db:para>The seed is set in any newly created <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>. See <db:link xlink:href="qhash.xml#the-hashing-function">qHash</db:link> about how this seed is being used by <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhashseed.xml">QHashSeed</db:link></db:member>
<db:member><db:link xlink:href="qhashseed.xml#globalSeed">QHashSeed::globalSeed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qSetGlobalQHashSeed">
<db:title>[deprecated in 6.6] void qSetGlobalQHashSeed(int <db:emphasis>newSeed</db:emphasis>)</db:title>
<db:para>This function is deprecated since 6.6. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qhashseed.xml">QHashSeed</db:link> instead.</db:para>
<db:para>Sets the global <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> seed to <db:code role="parameter">newSeed</db:code>.</db:para>
<db:para>Manually setting the global <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> seed value should be done only for testing and debugging purposes, when deterministic and reproducible behavior on a <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> is needed. We discourage to do it in production code as it can make your application susceptible to <db:link xlink:href="qhash.xml#algorithmic-complexity-attacks">algorithmic complexity attacks</db:link>.</db:para>
<db:para>From Qt 5.10 and onwards, the only allowed values are 0 and -1. Passing the value -1 will reinitialize the global <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link> seed to a random value, while the value of 0 is used to request a stable algorithm for C++ primitive types types (like int) and string types (<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qbytearray.xml">QByteArray</db:link>).</db:para>
<db:para>The seed is set in any newly created <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>. See <db:link xlink:href="qhash.xml#the-hashing-function">qHash</db:link> about how this seed is being used by <db:link xlink:href="qhash.xml#the-hashing-function">QHash</db:link>.</db:para>
<db:para>If the environment variable QT_HASH_SEED is set, calling this function will result in a no-op.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhashseed.xml#globalSeed">QHashSeed::globalSeed</db:link>()</db:member>
<db:member><db:link xlink:href="qhashseed.xml">QHashSeed</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
