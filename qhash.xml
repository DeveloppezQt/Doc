<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QHash Class</db:title>
<db:subtitle>template &lt;typename Key, typename T&gt; class QHash</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> class is a template class that provides a hash-table-based dictionary.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QHash</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qmultihash.xml" xlink:role="class">QMultiHash</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QHash is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>&lt;Key, T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores (key, value) pairs and provides very fast lookup of the value associated with a key.</db:para>
<db:para><db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> provides very similar functionality to <db:link xlink:href="qmap.xml">QMap</db:link>. The differences are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> provides faster lookups than <db:link xlink:href="qmap.xml">QMap</db:link>. (See <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for details.)</db:para>
</db:listitem>
<db:listitem>
<db:para>When iterating over a <db:link xlink:href="qmap.xml">QMap</db:link>, the items are always sorted by key. With <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>, the items are arbitrarily ordered.</db:para>
</db:listitem>
<db:listitem>
<db:para>The key type of a <db:link xlink:href="qmap.xml">QMap</db:link> must provide operator&lt;(). The key type of a <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> must provide operator==() and a global hash function called <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() (see <db:link xlink:href="qhash.xml#the-qhash-hashing-function">qHash</db:link>).</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Here's an example <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> with <db:link xlink:href="qstring.xml">QString</db:link> keys and <db:code>int</db:code> values:</db:para>
<db:programlisting language="cpp">QHash&lt;QString, int&gt; hash;
</db:programlisting>
<db:para>To insert a (key, value) pair into the hash, you can use operator[]():</db:para>
<db:programlisting language="cpp">hash[&quot;one&quot;] = 1;
hash[&quot;three&quot;] = 3;
hash[&quot;seven&quot;] = 7;
</db:programlisting>
<db:para>This inserts the following three (key, value) pairs into the <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>: (&quot;one&quot;, 1), (&quot;three&quot;, 3), and (&quot;seven&quot;, 7). Another way to insert items into the hash is to use insert():</db:para>
<db:programlisting language="cpp">hash.insert(&quot;twelve&quot;, 12);
</db:programlisting>
<db:para>To look up a value, use operator[]() or value():</db:para>
<db:programlisting language="cpp">int num1 = hash[&quot;thirteen&quot;];
int num2 = hash.value(&quot;thirteen&quot;);
</db:programlisting>
<db:para>If there is no item with the specified key in the hash, these functions return a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:para>If you want to check whether the hash contains a particular key, use <db:link xlink:href="qml-geoshape.xml#contains">contains()</db:link>:</db:para>
<db:programlisting language="cpp">int timeout = 30;
if (hash.contains(&quot;TIMEOUT&quot;))
    timeout = hash.value(&quot;TIMEOUT&quot;);
</db:programlisting>
<db:para>There is also a value() overload that uses its second argument as a default value if there is no item with the specified key:</db:para>
<db:programlisting language="cpp">int timeout = hash.value(&quot;TIMEOUT&quot;, 30);
</db:programlisting>
<db:para>In general, we recommend that you use <db:link xlink:href="qml-geoshape.xml#contains">contains()</db:link> and value() rather than operator[]() for looking up a key in a hash. The reason is that operator[]() silently inserts an item into the hash if no item exists with the same key (unless the hash is const). For example, the following code snippet will create 1000 items in memory:</db:para>
<db:programlisting language="cpp">// WRONG
QHash&lt;int, QWidget *&gt; hash;
...
for (int i = 0; i &lt; 1000; ++i) {
    if (hash[i] == okButton)
        cout &lt;&lt; &quot;Found button at index &quot; &lt;&lt; i &lt;&lt; endl;
}
</db:programlisting>
<db:para>To avoid this problem, replace <db:code>hash[i]</db:code> with <db:code>hash.value(i)</db:code> in the code above.</db:para>
<db:para>Internally, <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> uses a hash table to perform lookups. Unlike Qt 3's <db:code>QDict</db:code> class, which needed to be initialized with a prime number, <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>'s hash table automatically grows and shrinks to provide fast lookups without wasting too much memory. You can still control the size of the hash table by calling reserve() if you already know approximately how many items the <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> will contain, but this isn't necessary to obtain good performance. You can also call capacity() to retrieve the hash table's size.</db:para>
<db:para>If you want to navigate through all the (key, value) pairs stored in a <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>, you can use an iterator. <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> provides both <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qhashiterator.xml">QHashIterator</db:link> and <db:link xlink:href="qmutablehashiterator.xml">QMutableHashIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qhash-const-iterator.xml">QHash::const_iterator</db:link> and <db:link xlink:href="qhash-iterator.xml">QHash::iterator</db:link>). Here's how to iterate over a <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, int&gt; using a Java-style iterator:</db:para>
<db:programlisting language="cpp">QHashIterator&lt;QString, int&gt; i(hash);
while (i.hasNext()) {
    i.next();
    cout &lt;&lt; i.key() &lt;&lt; &quot;: &quot; &lt;&lt; i.value() &lt;&lt; endl;
}
</db:programlisting>
<db:para>Here's the same code, but using an STL-style iterator:</db:para>
<db:programlisting language="cpp">QHash&lt;QString, int&gt;::const_iterator i = hash.constBegin();
while (i != hash.constEnd()) {
    cout &lt;&lt; i.key() &lt;&lt; &quot;: &quot; &lt;&lt; i.value() &lt;&lt; endl;
    ++i;
}
</db:programlisting>
<db:para><db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> is unordered, so an iterator's sequence cannot be assumed to be predictable. If ordering by key is required, use a <db:link xlink:href="qmap.xml">QMap</db:link>.</db:para>
<db:para>Normally, a <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> allows only one value per key. If you call insert() with a key that already exists in the <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>, the previous value is erased. For example:</db:para>
<db:programlisting language="cpp">hash.insert(&quot;plenty&quot;, 100);
hash.insert(&quot;plenty&quot;, 2000);
// hash.value(&quot;plenty&quot;) == 2000
</db:programlisting>
<db:para>However, you can store multiple values per key by using insertMulti() instead of insert() (or using the convenience subclass <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>). If you want to retrieve all the values for a single key, you can use values(const Key &amp;key), which returns a <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;:</db:para>
<db:programlisting language="cpp">QList&lt;int&gt; values = hash.values(&quot;plenty&quot;);
for (int i = 0; i &lt; values.size(); ++i)
    cout &lt;&lt; values.at(i) &lt;&lt; endl;
</db:programlisting>
<db:para>The items that share the same key are available from most recently to least recently inserted. A more efficient approach is to call find() to get the iterator for the first item with a key and iterate from there:</db:para>
<db:programlisting language="cpp">QHash&lt;QString, int&gt;::iterator i = hash.find(&quot;plenty&quot;);
while (i != hash.end() &amp;&amp; i.key() == &quot;plenty&quot;) {
    cout &lt;&lt; i.value() &lt;&lt; endl;
    ++i;
}
</db:programlisting>
<db:para>If you only need to extract the values from a hash (not the keys), you can also use <db:link xlink:href="containers.xml#the-foreach-keyword">foreach</db:link>:</db:para>
<db:programlisting language="cpp">QHash&lt;QString, int&gt; hash;
...
foreach (int value, hash)
    cout &lt;&lt; value &lt;&lt; endl;
</db:programlisting>
<db:para>Items can be removed from the hash in several ways. One way is to call remove(); this will remove any item with the given key. Another way is to use QMutableHashIterator::remove(). In addition, you can clear the entire hash using clear().</db:para>
<db:para><db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>'s key and value data types must be <db:link xlink:href="containers.xml#assignable-data-types">assignable data types</db:link>. You cannot, for example, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> as a value; instead, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> *.</db:para>
<db:anchor xml:id="qhashx"/>
<db:section xml:id="the-qhash-hashing-function">
<db:title>The qHash() hashing function</db:title>
<db:para>A <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>'s key type has additional requirements other than being an assignable data type: it must provide operator==(), and there must also be a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function in the type's namespace that returns a hash value for an argument of the key's type.</db:para>
<db:para>The <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function computes a numeric value based on a key. It can use any algorithm imaginable, as long as it always returns the same value if given the same argument. In other words, if <db:code>e1 == e2</db:code>, then <db:code>qHash(e1) == qHash(e2)</db:code> must hold as well. However, to obtain good performance, the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function should attempt to return different hash values for different keys to the largest extent possible.</db:para>
<db:para>For a key type <db:code>K</db:code>, the <db:link xlink:href="qhash.xml#the-qhash-hashing-function">qHash</db:link> function must have one of these signatures:</db:para>
<db:programlisting language="cpp">uint qHash(K key);
uint qHash(const K &amp;key);

uint qHash(K key, uint seed);
uint qHash(const K &amp;key, uint seed);
</db:programlisting>
<db:para>The two-arguments overloads take an unsigned integer that should be used to seed the calculation of the hash function. This seed is provided by <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> in order to prevent a family of <db:link xlink:href="qhash.xml#algorithmic-complexity-attacks">algorithmic complexity attacks</db:link>. If both a one-argument and a two-arguments overload are defined for a key type, the latter is used by <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> (note that you can simply define a two-arguments version, and use a default value for the seed parameter).</db:para>
<db:para>Here's a partial list of the C++ and Qt types that can serve as keys in a <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>: any integer type (char, unsigned long, etc.), any pointer type, <db:link xlink:href="qchar.xml">QChar</db:link>, <db:link xlink:href="qstring.xml">QString</db:link>, and <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. For all of these, the <db:code>&lt;QHash&gt;</db:code> header defines a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function that computes an adequate hash value. Many other Qt classes also declare a <db:link xlink:href="qhash.xml#the-qhash-hashing-function">qHash</db:link> overload for their type; please refer to the documentation of each class.</db:para>
<db:para>If you want to use other types as the key, make sure that you provide operator==() and a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() implementation.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">#ifndef EMPLOYEE_H
#define EMPLOYEE_H

class Employee
{
public:
    Employee() {}
    Employee(const QString &amp;name, const QDate &amp;dateOfBirth);
    ...

private:
    QString myName;
    QDate myDateOfBirth;
};

inline bool operator==(const Employee &amp;e1, const Employee &amp;e2)
{
    return e1.name() == e2.name()
           &amp;&amp; e1.dateOfBirth() == e2.dateOfBirth();
}

inline uint qHash(const Employee &amp;key, uint seed)
{
    return qHash(key.name(), seed) ^ key.dateOfBirth().day();
}

#endif // EMPLOYEE_H
</db:programlisting>
<db:para>In the example above, we've relied on Qt's global <db:link xlink:href="qhash.xml#the-qhash-hashing-function">qHash</db:link>(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;, uint) to give us a hash value for the employee's name, and XOR'ed this with the day they were born to help produce unique hashes for people with the same name.</db:para>
<db:para>Note that the implementation of the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() will give the same results (for the same inputs) across different Qt versions.</db:para>
</db:section>
<db:section xml:id="algorithmic-complexity-attacks">
<db:title>Algorithmic complexity attacks</db:title>
<db:para>All hash tables are vulnerable to a particular class of denial of service attacks, in which the attacker carefully pre-computes a set of different keys that are going to be hashed in the same bucket of a hash table (or even have the very same hash value). The attack aims at getting the worst-case algorithmic behavior (O(n) instead of amortized O(1), see <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for the details) when the data is fed into the table.</db:para>
<db:para>In order to avoid this worst-case behavior, the calculation of the hash value done by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() can be salted by a random seed, that nullifies the attack's extent. This seed is automatically generated by <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> once per process, and then passed by <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> as the second argument of the two-arguments overload of the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function.</db:para>
<db:para>This randomization of <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> is enabled by default. Even though programs should never depend on a particular <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> ordering, there may be situations where you temporarily need deterministic behavior, for example for debugging or regression testing. To disable the randomization, define the environment variable <db:code>QT_HASH_SEED</db:code>. The contents of that variable, interpreted as a decimal value, will be used as the seed for <db:link xlink:href="qhash.xml#qHash">qHash</db:link>(). Alternatively, you can call the <db:link xlink:href="qhash.xml#qSetGlobalQHashSeed">qSetGlobalQHashSeed</db:link>() function.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhashiterator.xml">QHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablehashiterator.xml">QMutableHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmap.xml">QMap</db:link></db:member>
<db:member><db:link xlink:href="qset.xml">QSet</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QHash::ConstIterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qhash-const-iterator.xml">QHash::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>QHash::Iterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qhash-iterator.xml">QHash::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>QHash::difference_type</db:title>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="key_type-typedef">
<db:title>QHash::key_type</db:title>
<db:para>Typedef for Key. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="mapped_type-typedef">
<db:title>QHash::mapped_type</db:title>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>QHash::size_type</db:title>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qGlobalQHashSeed">
<db:title>[since 5.6] int qGlobalQHashSeed()</db:title>
<db:para>Returns the current global <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> seed.</db:para>
<db:para>The seed is set in any newly created <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>. See <db:link xlink:href="qhash.xml#the-qhash-hashing-function">qHash</db:link> about how this seed is being used by <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qSetGlobalQHashSeed">qSetGlobalQHashSeed</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHash">
<db:title>[noexcept, since 5.0] uint qHash(QLatin1String <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-1">
<db:title>[noexcept, since 5.0] uint qHash(char <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-2">
<db:title>[noexcept, since 5.0] uint qHash(const QBitArray &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-3">
<db:title>[noexcept, since 5.0] uint qHash(const QByteArray &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-4">
<db:title>[noexcept, since 5.0] uint qHash(const QChar <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-5">
<db:title>[noexcept, since 5.0] uint qHash(const QDate &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-6">
<db:title>[since 5.0] uint qHash(const QDateTime &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-7">
<db:title>[noexcept, since 5.0] uint qHash(const QString &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-8">
<db:title>[noexcept, since 5.0] uint qHash(const QStringRef &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-9">
<db:title>[noexcept, since 5.0] uint qHash(const QTime &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-10">
<db:title>[noexcept, since 5.0] uint qHash(const QUrl &amp;<db:emphasis>url</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">url</db:code>. If specified, <db:code role="parameter">seed</db:code> is used to initialize the hash.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-11">
<db:title>[since 5.6] uint qHash(const QVersionNumber &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="qHash-12">
<db:title>[noexcept, since 5.3] uint qHash(double <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="qHash-13">
<db:title>[noexcept, since 5.3] uint qHash(float <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="qHash-14">
<db:title>[noexcept, since 5.0] uint qHash(int <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-15">
<db:title>[noexcept, since 5.0] uint qHash(long <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-16">
<db:title>[noexcept, since 5.3] uint qHash(long double <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="qHash-17">
<db:title>[noexcept, since 5.0] uint qHash(qint64 <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-18">
<db:title>[noexcept, since 5.0] uint qHash(quint64 <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-19">
<db:title>[noexcept, since 5.0] uint qHash(short <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-20">
<db:title>[noexcept, since 5.0] uint qHash(signed char <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-21">
<db:title>[noexcept, since 5.0] uint qHash(uchar <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-22">
<db:title>[noexcept, since 5.0] uint qHash(uint <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-23">
<db:title>[noexcept, since 5.0] uint qHash(ulong <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-24">
<db:title>[noexcept, since 5.0] uint qHash(ushort <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHashBits">
<db:title>[noexcept, since 5.4] uint qHashBits(const void *<db:emphasis>p</db:emphasis>, size_t <db:emphasis>len</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:para>Returns the hash value for the memory block of size <db:code role="parameter">len</db:code> pointed to by <db:code role="parameter">p</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Use this function only to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types. For example, here's how you could implement a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overload for std::vector&lt;int&gt;:</db:para>
<db:programlisting language="cpp">inline uint qHash(const std::vector&lt;int&gt; &amp;key, uint seed = 0)
{
    if (key.empty())
        return seed;
    else
        return qHashBits(&amp;key.front(), key.size() * sizeof(int), seed);
}
</db:programlisting>
<db:para>This takes advantage of the fact that std::vector lays out its data contiguously. If that is not the case, or the contained type has padding, you should use qHashRange() instead.</db:para>
<db:para>It bears repeating that the implementation of qHashBits() - like the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt - may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that qHashBits() will give the same results (for the same inputs) across different Qt versions.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">qHashRange()</db:link></db:member>
<db:member><db:link xlink:href="">qHashRangeCommutative()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qSetGlobalQHashSeed">
<db:title>[since 5.6] void qSetGlobalQHashSeed(int <db:emphasis>newSeed</db:emphasis>)</db:title>
<db:para>Sets the global <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> seed to <db:code role="parameter">newSeed</db:code>.</db:para>
<db:para>Manually setting the global <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> seed value should be done only for testing and debugging purposes, when deterministic and reproducible behavior on a <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> is needed. We discourage to do it in production code as it can make your application susceptible to <db:link xlink:href="qhash.xml#algorithmic-complexity-attacks">algorithmic complexity attacks</db:link>.</db:para>
<db:para>The seed is set in any newly created <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>. See <db:link xlink:href="qhash.xml#the-qhash-hashing-function">qHash</db:link> about how this seed is being used by <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>.</db:para>
<db:para>If the environment variable <db:code>QT_HASH_SEED</db:code> is set, calling this function will result in a no-op.</db:para>
<db:para>Passing the value -1 will reinitialize the global <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> seed to a random value.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qGlobalQHashSeed">qGlobalQHashSeed</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
