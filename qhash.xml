<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QHash Class</db:title>
<db:subtitle>template &lt;typename Key, typename T&gt; class QHash</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.11.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qhash.xml#qhash">QHash</db:link> class is a template class that provides a hash-table-based dictionary.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QHash</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qmultihash.xml" xlink:role="class">QMultiHash</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QHash is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;Key, T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores (key, value) pairs and provides very fast lookup of the value associated with a key.</db:para>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link> provides very similar functionality to <db:link xlink:href="qmap.xml">QMap</db:link>. The differences are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link> provides faster lookups than <db:link xlink:href="qmap.xml">QMap</db:link>. (See <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for details.)</db:para>
</db:listitem>
<db:listitem>
<db:para>When iterating over a <db:link xlink:href="qmap.xml">QMap</db:link>, the items are always sorted by key. With <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, the items are arbitrarily ordered.</db:para>
</db:listitem>
<db:listitem>
<db:para>The key type of a <db:link xlink:href="qmap.xml">QMap</db:link> must provide operator&lt;(). The key type of a <db:link xlink:href="qhash.xml#qhash">QHash</db:link> must provide operator==() and a global hash function called <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() (see <db:link xlink:href="qhash.xml#qhash">qHash</db:link>).</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Here's an example <db:link xlink:href="qhash.xml#qhash">QHash</db:link> with <db:link xlink:href="qstring.xml">QString</db:link> keys and int values:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QString, int&amp;gt; hash;
</db:programlisting>
<db:para>To insert a (key, value) pair into the hash, you can use operator[]():</db:para>
<db:programlisting language="cpp">hash[&quot;one&quot;] = 1;
hash[&quot;three&quot;] = 3;
hash[&quot;seven&quot;] = 7;
</db:programlisting>
<db:para>This inserts the following three (key, value) pairs into the <db:link xlink:href="qhash.xml#qhash">QHash</db:link>: (&quot;one&quot;, 1), (&quot;three&quot;, 3), and (&quot;seven&quot;, 7). Another way to insert items into the hash is to use <db:link xlink:href="qhash.xml#insert">insert</db:link>():</db:para>
<db:programlisting language="cpp">hash.insert(&quot;twelve&quot;, 12);
</db:programlisting>
<db:para>To look up a value, use operator[]() or <db:link xlink:href="qhash.xml#value">value</db:link>():</db:para>
<db:programlisting language="cpp">int num1 = hash[&quot;thirteen&quot;];
int num2 = hash.value(&quot;thirteen&quot;);
</db:programlisting>
<db:para>If there is no item with the specified key in the hash, these functions return a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:para>If you want to check whether the hash contains a particular key, use <db:link xlink:href="qhash.xml#contains">contains</db:link>():</db:para>
<db:programlisting language="cpp">int timeout = 30;
if (hash.contains(&quot;TIMEOUT&quot;))
    timeout = hash.value(&quot;TIMEOUT&quot;);
</db:programlisting>
<db:para>There is also a <db:link xlink:href="qhash.xml#value">value</db:link>() overload that uses its second argument as a default value if there is no item with the specified key:</db:para>
<db:programlisting language="cpp">int timeout = hash.value(&quot;TIMEOUT&quot;, 30);
</db:programlisting>
<db:para>In general, we recommend that you use <db:link xlink:href="qhash.xml#contains">contains</db:link>() and <db:link xlink:href="qhash.xml#value">value</db:link>() rather than operator[]() for looking up a key in a hash. The reason is that operator[]() silently inserts an item into the hash if no item exists with the same key (unless the hash is const). For example, the following code snippet will create 1000 items in memory:</db:para>
<db:programlisting language="cpp">// WRONG
QHash&amp;lt;int, QWidget *&amp;gt; hash;
...
for (int i = 0; i &amp;lt; 1000; ++i) {
    if (hash[i] == okButton)
        cout &amp;lt;&amp;lt; &quot;Found button at index &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;
}
</db:programlisting>
<db:para>To avoid this problem, replace hash[i] with hash.value(i) in the code above.</db:para>
<db:para>Internally, <db:link xlink:href="qhash.xml#qhash">QHash</db:link> uses a hash table to perform lookups. Unlike Qt 3's QDict class, which needed to be initialized with a prime number, <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s hash table automatically grows and shrinks to provide fast lookups without wasting too much memory. You can still control the size of the hash table by calling <db:link xlink:href="qhash.xml#reserve">reserve</db:link>() if you already know approximately how many items the <db:link xlink:href="qhash.xml#qhash">QHash</db:link> will contain, but this isn't necessary to obtain good performance. You can also call <db:link xlink:href="qhash.xml#capacity">capacity</db:link>() to retrieve the hash table's size.</db:para>
<db:para>If you want to navigate through all the (key, value) pairs stored in a <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, you can use an iterator. <db:link xlink:href="qhash.xml#qhash">QHash</db:link> provides both <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qhashiterator.xml">QHashIterator</db:link> and <db:link xlink:href="qmutablehashiterator.xml">QMutableHashIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qhash-const-iterator.xml">QHash::const_iterator</db:link> and <db:link xlink:href="qhash-iterator.xml">QHash::iterator</db:link>). Here's how to iterate over a <db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, int&gt; using a Java-style iterator:</db:para>
<db:programlisting language="cpp">QHashIterator&amp;lt;QString, int&amp;gt; i(hash);
while (i.hasNext()) {
    i.next();
    cout &amp;lt;&amp;lt; i.key() &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; i.value() &amp;lt;&amp;lt; endl;
}
</db:programlisting>
<db:para>Here's the same code, but using an STL-style iterator:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QString, int&amp;gt;::const_iterator i = hash.constBegin();
while (i != hash.constEnd()) {
    cout &amp;lt;&amp;lt; i.key() &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; i.value() &amp;lt;&amp;lt; endl;
    ++i;
}
</db:programlisting>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link> is unordered, so an iterator's sequence cannot be assumed to be predictable. If ordering by key is required, use a <db:link xlink:href="qmap.xml">QMap</db:link>.</db:para>
<db:para>Normally, a <db:link xlink:href="qhash.xml#qhash">QHash</db:link> allows only one value per key. If you call <db:link xlink:href="qhash.xml#insert">insert</db:link>() with a key that already exists in the <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, the previous value is erased. For example:</db:para>
<db:programlisting language="cpp">hash.insert(&quot;plenty&quot;, 100);
hash.insert(&quot;plenty&quot;, 2000);
// hash.value(&quot;plenty&quot;) == 2000
</db:programlisting>
<db:para>However, you can store multiple values per key by using <db:link xlink:href="qhash.xml#insertMulti">insertMulti</db:link>() instead of <db:link xlink:href="qhash.xml#insert">insert</db:link>() (or using the convenience subclass <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>). If you want to retrieve all the values for a single key, you can use values(const Key &amp;key), which returns a <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; values = hash.values(&quot;plenty&quot;);
for (int i = 0; i &amp;lt; values.size(); ++i)
    cout &amp;lt;&amp;lt; values.at(i) &amp;lt;&amp;lt; endl;
</db:programlisting>
<db:para>The items that share the same key are available from most recently to least recently inserted. A more efficient approach is to call <db:link xlink:href="qhash.xml#find">find</db:link>() to get the iterator for the first item with a key and iterate from there:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QString, int&amp;gt;::iterator i = hash.find(&quot;plenty&quot;);
while (i != hash.end() &amp;amp;&amp;amp; i.key() == &quot;plenty&quot;) {
    cout &amp;lt;&amp;lt; i.value() &amp;lt;&amp;lt; endl;
    ++i;
}
</db:programlisting>
<db:para>If you only need to extract the values from a hash (not the keys), you can also use <db:link xlink:href="containers.xml#foreach">foreach</db:link>:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QString, int&amp;gt; hash;
...
foreach (int value, hash)
    cout &amp;lt;&amp;lt; value &amp;lt;&amp;lt; endl;
</db:programlisting>
<db:para>Items can be removed from the hash in several ways. One way is to call <db:link xlink:href="qhash.xml#remove">remove</db:link>(); this will remove any item with the given key. Another way is to use <db:link xlink:href="qmutablehashiterator.xml#remove">QMutableHashIterator::remove</db:link>(). In addition, you can clear the entire hash using <db:link xlink:href="qhash.xml#clear">clear</db:link>().</db:para>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s key and value data types must be <db:link xlink:href="containers.xml#assignable-data-types">assignable data types</db:link>. You cannot, for example, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> as a value; instead, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> *.</db:para>
<db:anchor xml:id="qhashx"/>
<db:section xml:id="the-qhash-hashing-function">
<db:title>The qHash() hashing function</db:title>
<db:para>A <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s key type has additional requirements other than being an assignable data type: it must provide operator==(), and there must also be a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function in the type's namespace that returns a hash value for an argument of the key's type.</db:para>
<db:para>The <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function computes a numeric value based on a key. It can use any algorithm imaginable, as long as it always returns the same value if given the same argument. In other words, if e1 == e2, then qHash(e1) == qHash(e2) must hold as well. However, to obtain good performance, the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function should attempt to return different hash values for different keys to the largest extent possible.</db:para>
<db:para>For a key type K, the <db:link xlink:href="qhash.xml#qhash">qHash</db:link> function must have one of these signatures:</db:para>
<db:programlisting language="cpp">uint qHash(K key);
uint qHash(const K &amp;amp;key);

uint qHash(K key, uint seed);
uint qHash(const K &amp;amp;key, uint seed);
</db:programlisting>
<db:para>The two-arguments overloads take an unsigned integer that should be used to seed the calculation of the hash function. This seed is provided by <db:link xlink:href="qhash.xml#qhash">QHash</db:link> in order to prevent a family of <db:link xlink:href="qhash.xml#algorithmic-complexity-attacks">algorithmic complexity attacks</db:link>. If both a one-argument and a two-arguments overload are defined for a key type, the latter is used by <db:link xlink:href="qhash.xml#qhash">QHash</db:link> (note that you can simply define a two-arguments version, and use a default value for the seed parameter).</db:para>
<db:para>Here's a partial list of the C++ and Qt types that can serve as keys in a <db:link xlink:href="qhash.xml#qhash">QHash</db:link>: any integer type (char, unsigned long, etc.), any pointer type, <db:link xlink:href="qchar.xml">QChar</db:link>, <db:link xlink:href="qstring.xml">QString</db:link>, and <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. For all of these, the &lt;QHash&gt; header defines a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function that computes an adequate hash value. Many other Qt classes also declare a <db:link xlink:href="qhash.xml#qhash">qHash</db:link> overload for their type; please refer to the documentation of each class.</db:para>
<db:para>If you want to use other types as the key, make sure that you provide operator==() and a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() implementation.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">#ifndef EMPLOYEE_H
#define EMPLOYEE_H

class Employee
{
public:
    Employee() {}
    Employee(const QString &amp;amp;name, const QDate &amp;amp;dateOfBirth);
    ...

private:
    QString myName;
    QDate myDateOfBirth;
};

inline bool operator==(const Employee &amp;amp;e1, const Employee &amp;amp;e2)
{
    return e1.name() == e2.name()
           &amp;amp;&amp;amp; e1.dateOfBirth() == e2.dateOfBirth();
}

inline uint qHash(const Employee &amp;amp;key, uint seed)
{
    return qHash(key.name(), seed) ^ key.dateOfBirth().day();
}

#endif // EMPLOYEE_H
</db:programlisting>
<db:para>In the example above, we've relied on Qt's global <db:link xlink:href="qhash.xml#qhash">qHash</db:link>(const <db:link xlink:href="qstring.xml">QString</db:link> &amp;, uint) to give us a hash value for the employee's name, and XOR'ed this with the day they were born to help produce unique hashes for people with the same name.</db:para>
<db:para>Note that the implementation of the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() will give the same results (for the same inputs) across different Qt versions.</db:para>
</db:section>
<db:section xml:id="algorithmic-complexity-attacks">
<db:title>Algorithmic complexity attacks</db:title>
<db:para>All hash tables are vulnerable to a particular class of denial of service attacks, in which the attacker carefully pre-computes a set of different keys that are going to be hashed in the same bucket of a hash table (or even have the very same hash value). The attack aims at getting the worst-case algorithmic behavior (O(n) instead of amortized O(1), see <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for the details) when the data is fed into the table.</db:para>
<db:para>In order to avoid this worst-case behavior, the calculation of the hash value done by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() can be salted by a random seed, that nullifies the attack's extent. This seed is automatically generated by <db:link xlink:href="qhash.xml#qhash">QHash</db:link> once per process, and then passed by <db:link xlink:href="qhash.xml#qhash">QHash</db:link> as the second argument of the two-arguments overload of the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function.</db:para>
<db:para>This randomization of <db:link xlink:href="qhash.xml#qhash">QHash</db:link> is enabled by default. Even though programs should never depend on a particular <db:link xlink:href="qhash.xml#qhash">QHash</db:link> ordering, there may be situations where you temporarily need deterministic behavior, for example for debugging or regression testing. To disable the randomization, define the environment variable QT_HASH_SEED to have the value 0. Alternatively, you can call the <db:link xlink:href="qhash.xml#qSetGlobalQHashSeed">qSetGlobalQHashSeed</db:link>() function with the value 0.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhashiterator.xml">QHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablehashiterator.xml">QMutableHashIterator</db:link></db:member>
<db:member><db:link xlink:href="qmap.xml">QMap</db:link></db:member>
<db:member><db:link xlink:href="qset.xml">QSet</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QHash::ConstIterator</db:title>
<db:typedefsynopsis>
<db:typedefname>ConstIterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qhash-const-iterator.xml">QHash::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>QHash::Iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>Iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qhash-iterator.xml">QHash::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="const_key_value_iterator-typedef">
<db:title>[since 5.10] QHash::const_key_value_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>const_key_value_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="module">QtCore</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The <db:link xlink:href="qmap.xml#const_key_value_iterator-typedef">QMap::const_key_value_iterator</db:link> typedef provides an STL-style const iterator for <db:link xlink:href="qhash.xml#qhash">QHash</db:link> and <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>.</db:para>
<db:para>QHash::const_key_value_iterator is essentially the same as <db:link xlink:href="qhash-const-iterator.xml">QHash::const_iterator</db:link> with the difference that operator*() returns a key/value pair instead of a value.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>QHash::difference_type</db:title>
<db:typedefsynopsis>
<db:typedefname>difference_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="key_type-typedef">
<db:title>QHash::key_type</db:title>
<db:typedefsynopsis>
<db:typedefname>key_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for Key. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="key_value_iterator-typedef">
<db:title>[since 5.10] QHash::key_value_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>key_value_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="module">QtCore</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The <db:link xlink:href="qmap.xml#key_value_iterator-typedef">QMap::key_value_iterator</db:link> typedef provides an STL-style iterator for <db:link xlink:href="qhash.xml#qhash">QHash</db:link> and <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>.</db:para>
<db:para>QHash::key_value_iterator is essentially the same as <db:link xlink:href="qhash-iterator.xml">QHash::iterator</db:link> with the difference that operator*() returns a key/value pair instead of a value.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qkeyvalueiterator.xml">QKeyValueIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapped_type-typedef">
<db:title>QHash::mapped_type</db:title>
<db:typedefsynopsis>
<db:typedefname>mapped_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>QHash::size_type</db:title>
<db:typedefsynopsis>
<db:typedefname>size_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QHashxx">
<db:title>QHash::QHash()</db:title>
<db:constructorsynopsis>
<db:methodname>QHash</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QHash-1">
<db:title>[since 5.1] QHash::QHash(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; <db:emphasis>list</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QHash</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; list)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a hash with a copy of each of the elements in the initializer list <db:code role="parameter">list</db:code>.</db:para>
<db:para>This function is only available if the program is being compiled in C++11 mode.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
</db:section>
<db:section xml:id="QHash-2">
<db:title>QHash::QHash(const QHash&lt;K, V&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QHash</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;K, V&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash(const QHash&lt;K, V&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:para>This operation occurs in <db:link xlink:href="containers.xml#constant-time">constant time</db:link>, because <db:link xlink:href="qhash.xml#qhash">QHash</db:link> is <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>. This makes returning a <db:link xlink:href="qhash.xml#qhash">QHash</db:link> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and this takes <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QHash-3">
<db:title>[since 5.2] QHash::QHash(QHash&lt;K, V&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QHash</db:methodname>
<db:methodparam>
<db:type>QHash&lt;K, V&gt; &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash(QHash&lt;K, V&gt; &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Move-constructs a <db:link xlink:href="qhash.xml#qhash">QHash</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="dtor.QHash">
<db:title>QHash::~QHash()</db:title>
<db:destructorsynopsis>
<db:methodname>~QHash</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QHash()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the hash. References to the values in the hash and all iterators of this hash become invalid.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QHash::iterator QHash::begin()</db:title>
<db:methodsynopsis>
<db:type>QHash::iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::iterator begin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>QHash::const_iterator QHash::begin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator begin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="capacity">
<db:title>int QHash::capacity() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>capacity</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int capacity() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of buckets in the <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal hash table.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the hash, call <db:link xlink:href="qhash.xml#size">size</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>[since 5.0] QHash::const_iterator QHash::cbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>cbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator cbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[since 5.0] QHash::const_iterator QHash::cend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>cend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator cend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QHash::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all items from the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>QHash::const_iterator QHash::constBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>constBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator constBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QHash::const_iterator QHash::constEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>constEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator constEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind">
<db:title>[since 4.1] QHash::const_iterator QHash::constFind(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>constFind</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator constFind(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an iterator pointing to the item with the <db:code role="parameter">key</db:code> in the hash.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function returns <db:link xlink:href="qhash.xml#constEnd">constEnd</db:link>().</db:para>
<db:para>This function was introduced in Qt 4.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#find">find</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#constFind">QMultiHash::constFind</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constKeyValueBegin">
<db:title>[since 5.10] QHash::const_key_value_iterator QHash::constKeyValueBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_key_value_iterator</db:type>
<db:methodname>constKeyValueBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_key_value_iterator constKeyValueBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constKeyValueEnd">
<db:title>[since 5.10] QHash::const_key_value_iterator QHash::constKeyValueEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_key_value_iterator</db:type>
<db:methodname>constKeyValueEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_key_value_iterator constKeyValueEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#constKeyValueBegin">constKeyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>bool QHash::contains(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the hash contains an item with the <db:code role="parameter">key</db:code>; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#count-1">count</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#contains">QMultiHash::contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>int QHash::count(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>count</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int count(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of items associated with the <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#insertMulti">insertMulti</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count-1">
<db:title>int QHash::count() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>count</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int count() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qhash.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="empty">
<db:title>bool QHash::empty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>empty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool empty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qhash.xml#isEmpty">isEmpty</db:link>(), returning true if the hash is empty; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="end">
<db:title>QHash::iterator QHash::end()</db:title>
<db:methodsynopsis>
<db:type>QHash::iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::iterator end()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>QHash::const_iterator QHash::end() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator end() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="equal_range">
<db:title>[since 5.7] QPair&lt;QHash::iterator, QHash::iterator&gt; QHash::equal_range(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QPair&lt;QHash::iterator, QHash::iterator&gt;</db:type>
<db:methodname>equal_range</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPair&lt;QHash::iterator, QHash::iterator&gt; equal_range(const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pair of iterators delimiting the range of values [first, second), that are stored under <db:code role="parameter">key</db:code>. If the range is empty then both iterators will be equal to <db:link xlink:href="qhash.xml#end">end</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="equal_range-1">
<db:title>[since 5.7] QPair&lt;QHash::const_iterator, QHash::const_iterator&gt; QHash::equal_range(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPair&lt;QHash::const_iterator, QHash::const_iterator&gt;</db:type>
<db:methodname>equal_range</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QPair&lt;QHash::const_iterator, QHash::const_iterator&gt; equal_range(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="erase">
<db:title>[since 5.7] QHash::iterator QHash::erase(QHash::const_iterator <db:emphasis>pos</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QHash::const_iterator</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::iterator erase(QHash::const_iterator pos)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the (key, value) pair associated with the iterator <db:code role="parameter">pos</db:code> from the hash, and returns an iterator to the next item in the hash.</db:para>
<db:para>Unlike <db:link xlink:href="qhash.xml#remove">remove</db:link>() and <db:link xlink:href="qhash.xml#take">take</db:link>(), this function never causes <db:link xlink:href="qhash.xml#qhash">QHash</db:link> to rehash its internal data structure. This means that it can safely be called while iterating, and won't affect the order of items in the hash. For example:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QObject *, int&amp;gt; objectHash;
...
QHash&amp;lt;QObject *, int&amp;gt;::iterator i = objectHash.find(obj);
while (i != objectHash.end() &amp;amp;&amp;amp; i.key() == obj) {
    if (i.value() == 0) {
        i = objectHash.erase(i);
    } else {
        ++i;
    }
}
</db:programlisting>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#take">take</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#find">find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase-1">
<db:title>QHash::iterator QHash::erase(QHash::iterator <db:emphasis>pos</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QHash::iterator</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::iterator erase(QHash::iterator pos)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="find">
<db:title>QHash::iterator QHash::find(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash::iterator</db:type>
<db:methodname>find</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::iterator find(const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an iterator pointing to the item with the <db:code role="parameter">key</db:code> in the hash.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function returns <db:link xlink:href="qhash.xml#end">end</db:link>().</db:para>
<db:para>If the hash contains multiple items with the <db:code role="parameter">key</db:code>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here's some code that iterates over all the items with the same key:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QString, int&amp;gt; hash;
...
QHash&amp;lt;QString, int&amp;gt;::const_iterator i = hash.find(&quot;HDR&quot;);
while (i != hash.end() &amp;amp;&amp;amp; i.key() == &quot;HDR&quot;) {
    cout &amp;lt;&amp;lt; i.value() &amp;lt;&amp;lt; endl;
    ++i;
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#value">value</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#values">values</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#find">QMultiHash::find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find-1">
<db:title>QHash::const_iterator QHash::find(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_iterator</db:type>
<db:methodname>find</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_iterator find(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="insert">
<db:title>QHash::iterator QHash::insert(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::iterator insert(const Key &amp;key, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there is already an item with the <db:code role="parameter">key</db:code>, that item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there are multiple items with the <db:code role="parameter">key</db:code>, the most recently inserted item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#insertMulti">insertMulti</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insertMulti">
<db:title>QHash::iterator QHash::insertMulti(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash::iterator</db:type>
<db:methodname>insertMulti</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::iterator insertMulti(const Key &amp;key, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts a new item with the <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there is already an item with the same key in the hash, this function will simply create a new one. (This behavior is different from <db:link xlink:href="qhash.xml#insert">insert</db:link>(), which overwrites the value of an existing item.)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#values">values</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QHash::isEmpty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isEmpty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isEmpty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the hash contains no items; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="key">
<db:title>const Key QHash::key(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const Key</db:type>
<db:methodname>key</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const Key key(const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the first key mapped to <db:code role="parameter">value</db:code>.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">value</db:code>, the function returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed key</db:link>.</db:para>
<db:para>This function can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal data structure is optimized for fast lookup by key, not by value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#value">value</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#keys">keys</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="key-1">
<db:title>[since 4.3] const Key QHash::key(const T &amp;<db:emphasis>value</db:emphasis>, const Key &amp;<db:emphasis>defaultKey</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const Key</db:type>
<db:methodname>key</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>defaultKey</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const Key key(const T &amp;value, const Key &amp;defaultKey) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the first key mapped to <db:code role="parameter">value</db:code>, or <db:code role="parameter">defaultKey</db:code> if the hash contains no item mapped to <db:code role="parameter">value</db:code>.</db:para>
<db:para>This function can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal data structure is optimized for fast lookup by key, not by value.</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
</db:section>
<db:section xml:id="keyBegin">
<db:title>[since 5.6] QHash::key_iterator QHash::keyBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::key_iterator</db:type>
<db:methodname>keyBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::key_iterator keyBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first key in the hash.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyEnd">keyEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyEnd">
<db:title>[since 5.6] QHash::key_iterator QHash::keyEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::key_iterator</db:type>
<db:methodname>keyEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::key_iterator keyEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last key in the hash.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyBegin">keyBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueBegin">
<db:title>[since 5.10] QHash::key_value_iterator QHash::keyValueBegin()</db:title>
<db:methodsynopsis>
<db:type>QHash::key_value_iterator</db:type>
<db:methodname>keyValueBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::key_value_iterator keyValueBegin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueEnd">keyValueEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueBegin-1">
<db:title>[since 5.10] QHash::const_key_value_iterator QHash::keyValueBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_key_value_iterator</db:type>
<db:methodname>keyValueBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_key_value_iterator keyValueBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueEnd">keyValueEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueEnd">
<db:title>[since 5.10] QHash::key_value_iterator QHash::keyValueEnd()</db:title>
<db:methodsynopsis>
<db:type>QHash::key_value_iterator</db:type>
<db:methodname>keyValueEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::key_value_iterator keyValueEnd()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyValueEnd-1">
<db:title>[since 5.10] QHash::const_key_value_iterator QHash::keyValueEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHash::const_key_value_iterator</db:type>
<db:methodname>keyValueEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash::const_key_value_iterator keyValueEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary entry after the last entry in the hash.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keyValueBegin">keyValueBegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keys">
<db:title>QList&lt;Key&gt; QHash::keys() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;Key&gt;</db:type>
<db:methodname>keys</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;Key&gt; keys() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list containing all the keys in the hash, in an arbitrary order. Keys that occur multiple times in the hash (because items were inserted with <db:link xlink:href="qhash.xml#insertMulti">insertMulti</db:link>(), or <db:link xlink:href="qhash.xml#unite">unite</db:link>() was used) also occur multiple times in the list.</db:para>
<db:para>To obtain a list of unique keys, where each key from the map only occurs once, use <db:link xlink:href="qhash.xml#uniqueKeys">uniqueKeys</db:link>().</db:para>
<db:para>The order is guaranteed to be the same as that used by <db:link xlink:href="qhash.xml#values">values</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#uniqueKeys">uniqueKeys</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#values">values</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#key">key</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keys-1">
<db:title>QList&lt;Key&gt; QHash::keys(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;Key&gt;</db:type>
<db:methodname>keys</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;Key&gt; keys(const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a list containing all the keys associated with value <db:code role="parameter">value</db:code>, in an arbitrary order.</db:para>
<db:para>This function can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal data structure is optimized for fast lookup by key, not by value.</db:para>
</db:section>
<db:section xml:id="remove">
<db:title>int QHash::remove(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int remove(const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all the items that have the <db:code role="parameter">key</db:code> from the hash. Returns the number of items removed which is usually 1 but will be 0 if the key isn't in the hash, or greater than 1 if <db:link xlink:href="qhash.xml#insertMulti">insertMulti</db:link>() has been used with the <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#clear">clear</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#take">take</db:link>()</db:member>
<db:member><db:link xlink:href="qmultihash.xml#remove">QMultiHash::remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reserve">
<db:title>void QHash::reserve(int <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>reserve</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void reserve(int size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Ensures that the <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal hash table consists of at least <db:code role="parameter">size</db:code> buckets.</db:para>
<db:para>This function is useful for code that needs to build a huge hash and wants to avoid repeated reallocation. For example:</db:para>
<db:programlisting language="cpp">QHash&amp;lt;QString, int&amp;gt; hash;
hash.reserve(20000);
for (int i = 0; i &amp;lt; 20000; ++i)
    hash.insert(keys[i], values[i]);
</db:programlisting>
<db:para>Ideally, <db:code role="parameter">size</db:code> should be slightly more than the maximum number of items expected in the hash. <db:code role="parameter">size</db:code> doesn't have to be prime, because <db:link xlink:href="qhash.xml#qhash">QHash</db:link> will use a prime number internally anyway. If <db:code role="parameter">size</db:code> is an underestimate, the worst that will happen is that the <db:link xlink:href="qhash.xml#qhash">QHash</db:link> will be a bit slower.</db:para>
<db:para>In general, you will rarely ever need to call this function. <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal hash table automatically shrinks or grows to provide good performance without wasting too much memory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#squeeze">squeeze</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>int QHash::size() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int size() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of items in the hash.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#count-1">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="squeeze">
<db:title>void QHash::squeeze()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>squeeze</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void squeeze()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reduces the size of the <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal hash table to save memory.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s memory usage. In general, you will rarely ever need to call this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>[since 4.8] void QHash::swap(QHash&lt;K, V&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QHash&lt;K, V&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QHash&lt;K, V&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps hash <db:code role="parameter">other</db:code> with this hash. This operation is very fast and never fails.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
</db:section>
<db:section xml:id="take">
<db:title>T QHash::take(const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>take</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T take(const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the item with the <db:code role="parameter">key</db:code> from the hash and returns the value associated with it.</db:para>
<db:para>If the item does not exist in the hash, the function simply returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If there are multiple items for <db:code role="parameter">key</db:code> in the hash, only the most recently inserted one is removed.</db:para>
<db:para>If you don't use the return value, <db:link xlink:href="qhash.xml#remove">remove</db:link>() is more efficient.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="uniqueKeys">
<db:title>[since 4.2] QList&lt;Key&gt; QHash::uniqueKeys() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;Key&gt;</db:type>
<db:methodname>uniqueKeys</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;Key&gt; uniqueKeys() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list containing all the keys in the map. Keys that occur multiple times in the map (because items were inserted with <db:link xlink:href="qhash.xml#insertMulti">insertMulti</db:link>(), or <db:link xlink:href="qhash.xml#unite">unite</db:link>() was used) occur only once in the returned list.</db:para>
<db:para>This function was introduced in Qt 4.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keys">keys</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#values">values</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unite">
<db:title>QHash&lt;K, V&gt; &amp;QHash::unite(const QHash&lt;K, V&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash&lt;K, V&gt; &amp;</db:type>
<db:methodname>unite</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;K, V&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash&lt;K, V&gt; &amp; unite(const QHash&lt;K, V&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts all the items in the <db:code role="parameter">other</db:code> hash into this hash. If a key is common to both hashes, the resulting hash will contain the key multiple times.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#insertMulti">insertMulti</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value">
<db:title>const T QHash::value(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const T value(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the value associated with the <db:code role="parameter">key</db:code>.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If there are multiple items for the <db:code role="parameter">key</db:code> in the hash, the value of the most recently inserted one is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#key">key</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#values">values</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value-1">
<db:title>const T QHash::value(const Key &amp;<db:emphasis>key</db:emphasis>, const T &amp;<db:emphasis>defaultValue</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>defaultValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T value(const Key &amp;key, const T &amp;defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>If the hash contains no item with the given <db:code role="parameter">key</db:code>, the function returns <db:code role="parameter">defaultValue</db:code>.</db:para>
</db:section>
<db:section xml:id="values">
<db:title>QList&lt;T&gt; QHash::values() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>values</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; values() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list containing all the values in the hash, in an arbitrary order. If a key is associated with multiple values, all of its values will be in the list, and not just the most recently inserted one.</db:para>
<db:para>The order is guaranteed to be the same as that used by <db:link xlink:href="qhash.xml#keys">keys</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#keys">keys</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="values-1">
<db:title>QList&lt;T&gt; QHash::values(const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>values</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; values(const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a list of all the values associated with the <db:code role="parameter">key</db:code>, from the most recently inserted to the least recently inserted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#count-1">count</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#insertMulti">insertMulti</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QHash::operator!=(const QHash&lt;K, V&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;K, V&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QHash&lt;K, V&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if <db:code role="parameter">other</db:code> is not equal to this hash; otherwise returns false.</db:para>
<db:para>Two hashes are considered equal if they contain the same (key, value) pairs.</db:para>
<db:para>This function requires the value type to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QHash&lt;K, V&gt; &amp;QHash::operator=(const QHash&lt;K, V&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash&lt;K, V&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;K, V&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash&lt;K, V&gt; &amp; operator=(const QHash&lt;K, V&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">other</db:code> to this hash and returns a reference to this hash.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[since 5.2] QHash&lt;K, V&gt; &amp;QHash::operator=(QHash&lt;K, V&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QHash&lt;K, V&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QHash&lt;K, V&gt; &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QHash&lt;K, V&gt; &amp; operator=(QHash&lt;K, V&gt; &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qhash.xml#qhash">QHash</db:link> instance.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QHash::operator==(const QHash&lt;K, V&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;K, V&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QHash&lt;K, V&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if <db:code role="parameter">other</db:code> is equal to this hash; otherwise returns false.</db:para>
<db:para>Two hashes are considered equal if they contain the same (key, value) pairs.</db:para>
<db:para>This function requires the value type to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>T &amp;QHash::operator[](const Key &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; operator[](const Key &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the value associated with the <db:code role="parameter">key</db:code> as a modifiable reference.</db:para>
<db:para>If the hash contains no item with the <db:code role="parameter">key</db:code>, the function inserts a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link> into the hash with the <db:code role="parameter">key</db:code>, and returns a reference to it. If the hash contains multiple items with the <db:code role="parameter">key</db:code>, this function returns a reference to the most recently inserted value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>const T QHash::operator[](const Key &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>const Key &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T operator[](const Key &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qhash.xml#value">value</db:link>().</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qGlobalQHashSeed">
<db:title>[since 5.6] int qGlobalQHashSeed()</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qGlobalQHashSeed</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qGlobalQHashSeed()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current global <db:link xlink:href="qhash.xml#qhash">QHash</db:link> seed.</db:para>
<db:para>The seed is set in any newly created <db:link xlink:href="qhash.xml#qhash">QHash</db:link>. See <db:link xlink:href="qhash.xml#qhash">qHash</db:link> about how this seed is being used by <db:link xlink:href="qhash.xml#qhash">QHash</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qSetGlobalQHashSeed">qSetGlobalQHashSeed</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHash">
<db:title>[since 5.0] uint qHash(const QUrl &amp;<db:emphasis>url</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QUrl &amp;url, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">url</db:code>. If specified, <db:code role="parameter">seed</db:code> is used to initialize the hash.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-1x">
<db:title>[since 5.0] uint qHash(const QDateTime &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QDateTime &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QDateTime &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-2x">
<db:title>[since 5.0] uint qHash(const QDate &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QDate &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QDate &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-3x">
<db:title>[since 5.0] uint qHash(const QTime &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QTime &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QTime &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-4">
<db:title>[since 5.0] uint qHash(const QPair&lt;T1, T2&gt; &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QPair&lt;T1, T2&gt; &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QPair&lt;T1, T2&gt; &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Types T1 and T2 must be supported by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-5">
<db:title>[since 5.7] uint qHash(const std::pair&lt;T1, T2&gt; &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const std::pair&lt;T1, T2&gt; &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const std::pair&lt;T1, T2&gt; &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Types T1 and T2 must be supported by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>().</db:para>
<db:note>
<db:para>The return type of this function is <db:emphasis>not</db:emphasis> the same as that of</db:para>
</db:note>
<db:programlisting language="cpp">qHash(qMakePair(key.first, key.second), seed);
</db:programlisting>
<db:para>The two functions use different hashing algorithms; due to binary compatibility constraints, we cannot change the <db:link xlink:href="qpair.xml">QPair</db:link> algorithm to match the std::pair one before Qt 6.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="qHash-6">
<db:title>[since 5.0] uint qHash(char <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(char key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-7">
<db:title>[since 5.0] uint qHash(uchar <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>uchar</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(uchar key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-8">
<db:title>[since 5.0] uint qHash(signed char <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>signed char</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">8</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(signed char key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-9">
<db:title>[since 5.0] uint qHash(ushort <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>ushort</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">9</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(ushort key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-10">
<db:title>[since 5.0] uint qHash(short <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>short</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">10</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(short key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-11">
<db:title>[since 5.0] uint qHash(uint <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">11</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(uint key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-12">
<db:title>[since 5.0] uint qHash(int <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">12</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(int key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-13">
<db:title>[since 5.0] uint qHash(ulong <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>ulong</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">13</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(ulong key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-14">
<db:title>[since 5.0] uint qHash(long <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>long</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">14</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(long key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-15">
<db:title>[since 5.0] uint qHash(quint64 <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">15</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(quint64 key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-16">
<db:title>[since 5.0] uint qHash(qint64 <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">16</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(qint64 key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-17">
<db:title>[since 5.3] uint qHash(float <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>float</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">17</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(float key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="qHash-18">
<db:title>[since 5.3] uint qHash(double <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>double</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">18</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(double key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="qHash-19">
<db:title>[since 5.3] uint qHash(long double <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>long double</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">19</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(long double key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
</db:section>
<db:section xml:id="qHash-20">
<db:title>[since 5.0] uint qHash(const QChar <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QChar</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">20</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QChar key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-21">
<db:title>[since 5.0] uint qHash(const QByteArray &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">21</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QByteArray &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-22">
<db:title>[since 5.0] uint qHash(const QBitArray &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QBitArray &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">22</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QBitArray &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-23">
<db:title>[since 5.0] uint qHash(const QString &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">23</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QString &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-24">
<db:title>[since 5.0] uint qHash(const QStringRef &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QStringRef &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">24</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QStringRef &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-25">
<db:title>[since 5.0] uint qHash(QLatin1String <db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>QLatin1String</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">25</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(QLatin1String key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-26">
<db:title>[since 5.0] uint qHash(const T *<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const T *</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">26</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const T *key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="qHash-27">
<db:title>[since 5.8] uint qHash(const QHash&lt;Key, T&gt; &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">27</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QHash&lt;Key, T&gt; &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Type T must be supported by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
</db:section>
<db:section xml:id="qHash-28">
<db:title>[since 5.5] uint qHash(const QSet&lt;T&gt; &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">28</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QSet&lt;T&gt; &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>The hash value is independent of the order of elements in <db:code role="parameter">key</db:code>, that is, sets that contain the same elements hash to the same value.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
</db:section>
<db:section xml:id="qHash-29">
<db:title>[since 5.6] uint qHash(const QVersionNumber &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QVersionNumber &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">29</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QVersionNumber &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="qHashBits">
<db:title>[since 5.4] uint qHashBits(const void *<db:emphasis>p</db:emphasis>, size_t <db:emphasis>len</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHashBits</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>p</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHashBits(const void *p, size_t len, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the memory block of size <db:code role="parameter">len</db:code> pointed to by <db:code role="parameter">p</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>Use this function only to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types. For example, here's how you could implement a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overload for std::vector&lt;int&gt;:</db:para>
<db:programlisting language="cpp">inline uint qHash(const std::vector&amp;lt;int&amp;gt; &amp;amp;key, uint seed = 0)
{
    if (key.empty())
        return seed;
    else
        return qHashBits(&amp;amp;key.front(), key.size() * sizeof(int), seed);
}
</db:programlisting>
<db:para>This takes advantage of the fact that std::vector lays out its data contiguously. If that is not the case, or the contained type has padding, you should use <db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>() instead.</db:para>
<db:para>It bears repeating that the implementation of qHashBits() - like the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt - may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that qHashBits() will give the same results (for the same inputs) across different Qt versions.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRangeCommutative">qHashRangeCommutative</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHashRange">
<db:title>[since 5.5] uint qHashRange(InputIterator <db:emphasis>first</db:emphasis>, InputIterator <db:emphasis>last</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHashRange</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>first</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>last</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHashRange(InputIterator first, InputIterator last, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the range [<db:code role="parameter">first</db:code>,<db:code role="parameter">last</db:code>), using <db:code role="parameter">seed</db:code> to seed the calculation, by successively applying <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() to each element and combining the hash values into a single one.</db:para>
<db:para>The return value of this function depends on the order of elements in the range. That means that</db:para>
<db:programlisting language="cpp">{0, 1, 2}
</db:programlisting>
<db:para>and</db:para>
<db:programlisting language="cpp">{1, 2, 0}
</db:programlisting>
<db:para>hash to <db:emphasis role="bold">different</db:emphasis> values. If order does not matter, for example for hash tables, use <db:link xlink:href="qhash.xml#qHashRangeCommutative">qHashRangeCommutative</db:link>() instead. If you are hashing raw memory, use <db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>().</db:para>
<db:para>Use this function only to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types. For example, here's how you could implement a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overload for std::vector&lt;int&gt;:</db:para>
<db:programlisting language="cpp">inline uint qHash(const std::vector&amp;lt;int&amp;gt; &amp;amp;key, uint seed = 0)
{
    return qHashRange(key.begin(), key.end(), seed);
}
</db:programlisting>
<db:para>It bears repeating that the implementation of qHashRange() - like the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt - may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that qHashRange() will give the same results (for the same inputs) across different Qt versions, even if <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for the element type would.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRangeCommutative">qHashRangeCommutative</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHashRangeCommutative">
<db:title>[since 5.5] uint qHashRangeCommutative(InputIterator <db:emphasis>first</db:emphasis>, InputIterator <db:emphasis>last</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHashRangeCommutative</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>first</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>last</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHashRangeCommutative(InputIterator first, InputIterator last, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for the range [<db:code role="parameter">first</db:code>,<db:code role="parameter">last</db:code>), using <db:code role="parameter">seed</db:code> to seed the calculation, by successively applying <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() to each element and combining the hash values into a single one.</db:para>
<db:para>The return value of this function does not depend on the order of elements in the range. That means that</db:para>
<db:programlisting language="cpp">{0, 1, 2}
</db:programlisting>
<db:para>and</db:para>
<db:programlisting language="cpp">{1, 2, 0}
</db:programlisting>
<db:para>hash to the <db:emphasis role="bold">same</db:emphasis> values. If order matters, for example, for vectors and arrays, use <db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>() instead. If you are hashing raw memory, use <db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>().</db:para>
<db:para>Use this function only to implement <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for your own custom types. For example, here's how you could implement a <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overload for std::unordered_set&lt;int&gt;:</db:para>
<db:programlisting language="cpp">inline uint qHash(const std::unordered_set&amp;lt;int&amp;gt; &amp;amp;key, uint seed = 0)
{
    return qHashRangeCommutative(key.begin(), key.end(), seed);
}
</db:programlisting>
<db:para>It bears repeating that the implementation of qHashRangeCommutative() - like the <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() overloads offered by Qt - may change at any time. You <db:emphasis role="bold">must not</db:emphasis> rely on the fact that qHashRangeCommutative() will give the same results (for the same inputs) across different Qt versions, even if <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() for the element type would.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qHashBits">qHashBits</db:link>()</db:member>
<db:member><db:link xlink:href="qhash.xml#qHashRange">qHashRange</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qSetGlobalQHashSeed">
<db:title>[since 5.6] void qSetGlobalQHashSeed(int <db:emphasis>newSeed</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qSetGlobalQHashSeed</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>newSeed</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qSetGlobalQHashSeed(int newSeed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the global <db:link xlink:href="qhash.xml#qhash">QHash</db:link> seed to <db:code role="parameter">newSeed</db:code>.</db:para>
<db:para>Manually setting the global <db:link xlink:href="qhash.xml#qhash">QHash</db:link> seed value should be done only for testing and debugging purposes, when deterministic and reproducible behavior on a <db:link xlink:href="qhash.xml#qhash">QHash</db:link> is needed. We discourage to do it in production code as it can make your application susceptible to <db:link xlink:href="qhash.xml#algorithmic-complexity-attacks">algorithmic complexity attacks</db:link>.</db:para>
<db:para>From Qt 5.10 and onwards, the only allowed values are 0 and -1. Passing the value -1 will reinitialize the global <db:link xlink:href="qhash.xml#qhash">QHash</db:link> seed to a random value, while the value of 0 is used to request a stable algorithm for C++ primitive types types (like int) and string types (<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qbytearray.xml">QByteArray</db:link>).</db:para>
<db:para>The seed is set in any newly created <db:link xlink:href="qhash.xml#qhash">QHash</db:link>. See <db:link xlink:href="qhash.xml#qhash">qHash</db:link> about how this seed is being used by <db:link xlink:href="qhash.xml#qhash">QHash</db:link>.</db:para>
<db:para>If the environment variable QT_HASH_SEED is set, calling this function will result in a no-op.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhash.xml#qGlobalQHashSeed">qGlobalQHashSeed</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>out</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>hash</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&lt;&lt;(QDataStream &amp;out, const QHash&lt;Key, T&gt; &amp;hash)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the hash <db:code role="parameter">hash</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:para>This function requires the key and value types to implement operator&lt;&lt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QHash&lt;Key, T&gt; &amp;<db:emphasis>hash</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>in</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QHash&lt;Key, T&gt; &amp;</db:type>
<db:parameter>hash</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&gt;&gt;(QDataStream &amp;in, QHash&lt;Key, T&gt; &amp;hash)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a hash from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">hash</db:code>.</db:para>
<db:para>This function requires the key and value types to implement operator&gt;&gt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
