<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QPointer Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QPointer</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qpointer.xml">QPointer</db:link> class is a template class that provides guarded pointers to <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
<db:para>This class is <db:emphasis>equality-comparable</db:emphasis>.</db:para>
<db:para>This class is <db:emphasis role="bold">equality-comparable</db:emphasis> with QPointer&lt;X&gt;, X*, and std::nullptr_t.</db:para>
<db:para>Where X and T are compatible types, which means that they are either the same (except for their cv-qualifiers), or one is a base type of the other.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QPointer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QPointer is part of <db:simplelist><db:member>objectmodel</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A guarded pointer, <db:link xlink:href="qpointer.xml">QPointer</db:link>&lt;T&gt;, behaves like a normal C++ pointer T *, except that it is automatically cleared when the referenced object is destroyed (unlike normal C++ pointers, which become &quot;dangling pointers&quot; in such cases). T must be a subclass of <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
<db:para>Guarded pointers are useful whenever you need to store a pointer to a <db:link xlink:href="qobject.xml">QObject</db:link> that is owned by someone else, and therefore might be destroyed while you still hold a reference to it. You can safely test the pointer for validity.</db:para>
<db:para>Note that Qt 5 introduces a slight change in behavior when using <db:link xlink:href="qpointer.xml">QPointer</db:link>.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>When using <db:link xlink:href="qpointer.xml">QPointer</db:link> on a QWidget (or a subclass of QWidget), previously the <db:link xlink:href="qpointer.xml">QPointer</db:link> would be cleared by the QWidget destructor. Now, the <db:link xlink:href="qpointer.xml">QPointer</db:link> is cleared by the <db:link xlink:href="qobject.xml">QObject</db:link> destructor (since this is when <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link> objects are cleared). Any QPointers tracking a widget will <db:emphasis role="bold">NOT</db:emphasis> be cleared before the QWidget destructor destroys the children for the widget being tracked.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Qt also provides <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link>, an implementation of a reference-counted shared pointer object, which can be used to maintain a collection of references to an individual pointer.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">    QPointer&lt;QLabel&gt; label = new QLabel;
    label-&gt;setText(&quot;&amp;Status:&quot;);
    ...
    if (label)
        label-&gt;show();
</db:programlisting>
<db:para>If the QLabel is deleted in the meantime, the label variable will hold nullptr instead of an invalid address, and the last line will never be executed.</db:para>
<db:para>The functions and operators available with a <db:link xlink:href="qpointer.xml">QPointer</db:link> are the same as those available with a normal unguarded pointer, except the pointer arithmetic operators (+, -, ++, and --), which are normally used only with arrays of objects.</db:para>
<db:para>Use QPointers like normal pointers and you will not need to read this class documentation.</db:para>
<db:para>For creating guarded pointers, you can construct or assign to them from a T* or from another guarded pointer of the same type. You can compare them with each other using operator==() and operator!=(), or test for nullptr with <db:link xlink:href="qpointer.xml#isNull">isNull</db:link>(). You can dereference them using either the *x or the x-&gt;member notation.</db:para>
<db:para>A guarded pointer will automatically cast to a T *, so you can freely mix guarded and unguarded pointers. This means that if you have a <db:link xlink:href="qpointer.xml">QPointer</db:link>&lt;QWidget&gt;, you can pass it to a function that requires a QWidget *. For this reason, it is of little value to declare functions to take a <db:link xlink:href="qpointer.xml">QPointer</db:link> as a parameter; just use normal pointers. Use a <db:link xlink:href="qpointer.xml">QPointer</db:link> when you are storing a pointer over time.</db:para>
<db:para>Note that class T must inherit <db:link xlink:href="qobject.xml">QObject</db:link>, or a compilation or link error will result.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml">QObject</db:link></db:member>
<db:member><db:link xlink:href="qobjectcleanuphandler.xml">QObjectCleanupHandler</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QPointer">
<db:title>[noexcept] QPointer::QPointer()</db:title>
<db:bridgehead renderas="sect2" xml:id="QPointer-4">[constexpr noexcept] QPointer::QPointer(<db:emphasis>std::nullptr_t</db:emphasis>)</db:bridgehead>
<db:para>Constructs a guarded pointer with value nullptr.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qpointer.xml#isNull">isNull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QPointer-1">
<db:title>[noexcept, since 6.6] QPointer::QPointer(QPointer&lt;X&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="QPointer-3">[noexcept, since 6.6] QPointer::QPointer(const QPointer&lt;X&gt; &amp;<db:emphasis>other</db:emphasis>)</db:bridgehead>
<db:para>Conversion constructor. Constructs a new <db:link xlink:href="qpointer.xml">QPointer</db:link> by moving or copying from <db:code role="parameter">other</db:code>.</db:para>
<db:para>The moved-from <db:link xlink:href="qpointer.xml">QPointer</db:link> is reset to nullptr.</db:para>
<db:note>
<db:para>These constructors participate in overload resolution only if X* is convertible to T*.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
<db:section xml:id="QPointer-2">
<db:title>QPointer::QPointer(T *<db:emphasis>p</db:emphasis>)</db:title>
<db:para>Constructs a guarded pointer that points to the same object that <db:code role="parameter">p</db:code> points to.</db:para>
</db:section>
<db:section xml:id="dtor.QPointer">
<db:title>QPointer::~QPointer()</db:title>
<db:para>Destroys the guarded pointer. Just like a normal pointer, destroying a guarded pointer does <db:emphasis>not</db:emphasis> destroy the object being pointed to.</db:para>
</db:section>
<db:section xml:id="clear">
<db:title>[noexcept] void QPointer::clear()</db:title>
<db:para>Clears this <db:link xlink:href="qpointer.xml">QPointer</db:link> object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qpointer.xml#isNull">isNull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>[noexcept] T *QPointer::data() const</db:title>
<db:para>Returns the pointer to the object being guarded.</db:para>
</db:section>
<db:section xml:id="get">
<db:title>[noexcept, since 6.0] T *QPointer::get() const</db:title>
<db:para>Same as <db:link xlink:href="qpointer.xml#data">data</db:link>(). This function is provided for STL compatibility.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="isNull">
<db:title>[noexcept] bool QPointer::isNull() const</db:title>
<db:para>Returns true if the referenced object has been destroyed or if there is no referenced object; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="swap">
<db:title>[noexcept] void QPointer::swap(QPointer&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps this pointer with <db:code role="parameter">other</db:code>. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="operator-T--2a">
<db:title>[noexcept] T *QPointer::operator T *() const</db:title>
<db:para>Cast operator; implements pointer semantics. Because of this function you can pass a <db:link xlink:href="qpointer.xml">QPointer</db:link>&lt;T&gt; to a function where a T* is required.</db:para>
</db:section>
<db:section xml:id="operator-2a">
<db:title>[noexcept] T &amp;QPointer::operator*() const</db:title>
<db:para>Dereference operator; implements pointer semantics. Just use this operator as you would with a normal C++ pointer.</db:para>
</db:section>
<db:section xml:id="operator--gt">
<db:title>[noexcept] T *QPointer::operator-&gt;() const</db:title>
<db:para>Overloaded arrow operator; implements pointer semantics. Just use this operator as you would with a normal C++ pointer.</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>[noexcept, since 6.6.1] QPointer&lt;T&gt; &amp;QPointer::operator=(QPointer&lt;X&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Conversion move-assignment operator. Makes this guarded pointer guard the same object guarded by <db:code role="parameter">other</db:code> and resets <db:code role="parameter">other</db:code> to nullptr.</db:para>
<db:section xml:id="constraints">
<db:title>Constraints</db:title>
<db:para>Participates in overload resolution only if X* is convertible to T*.</db:para>
</db:section>
<db:section>
<db:title>Notes</db:title>
<db:para>This function was introduced in Qt 6.6.1.</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QPointer&lt;T&gt; &amp;QPointer::operator=(T *<db:emphasis>p</db:emphasis>)</db:title>
<db:para>Assignment operator. This guarded pointer will now point to the same object that <db:code role="parameter">p</db:code> points to.</db:para>
</db:section>
<db:section xml:id="operator-eq-2">
<db:title>[noexcept, since 6.6] QPointer&lt;T&gt; &amp;QPointer::operator=(const QPointer&lt;X&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Conversion assignment operator. Makes this guarded pointer guard the same object guarded by <db:code role="parameter">other</db:code>.</db:para>
<db:section xml:id="constraints">
<db:title>Constraints</db:title>
<db:para>Participates in overload resolution only if X* is convertible to T*.</db:para>
</db:section>
<db:section>
<db:title>Notes</db:title>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="operator-not-eq">
<db:title>[noexcept] bool operator!=(X *const &amp;<db:emphasis>lhs</db:emphasis>, const QPointer&lt;T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Inequality operator. Returns true if <db:code role="parameter">lhs</db:code> and the guarded pointer <db:code role="parameter">rhs</db:code> are not pointing to the same object, otherwise returns false.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-1">
<db:title>[noexcept] bool operator!=(const QPointer&lt;T&gt; &amp;<db:emphasis>lhs</db:emphasis>, X *const &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Inequality operator. Returns true if <db:code role="parameter">rhs</db:code> and the guarded pointer <db:code role="parameter">lhs</db:code> are not pointing to the same object, otherwise returns false.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-2">
<db:title>[noexcept(...)] bool operator!=(const QPointer&lt;T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const QPointer&lt;X&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Inequality operator. Returns true if the guarded pointers <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code> are not pointing to the same object, otherwise returns false.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-3">
<db:title>[noexcept] bool operator!=(const QPointer&lt;T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const std::nullptr_t &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Inequality operator. Returns true if the pointer guarded by <db:code role="parameter">lhs</db:code> is a valid (ie not nullptr) pointer, otherwise returns false.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-4">
<db:title>[noexcept] bool operator!=(const std::nullptr_t &amp;<db:emphasis>lhs</db:emphasis>, const QPointer&lt;T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Inequality operator. Returns true if the pointer guarded by <db:code role="parameter">rhs</db:code> is a valid (ie not nullptr) pointer, otherwise returns false.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>[noexcept] bool operator==(X *const &amp;<db:emphasis>lhs</db:emphasis>, const QPointer&lt;T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Equality operator. Returns true if <db:code role="parameter">lhs</db:code> and the guarded pointer <db:code role="parameter">rhs</db:code> are pointing to the same object, otherwise returns false.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-1">
<db:title>[noexcept] bool operator==(const QPointer&lt;T&gt; &amp;<db:emphasis>lhs</db:emphasis>, X *const &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Equality operator. Returns true if <db:code role="parameter">rhs</db:code> and the guarded pointer <db:code role="parameter">lhs</db:code> are pointing to the same object, otherwise returns false.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-2">
<db:title>[noexcept(...)] bool operator==(const QPointer&lt;T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const QPointer&lt;X&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Equality operator. Returns true if the guarded pointers <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code> are pointing to the same object, otherwise returns false.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-3">
<db:title>[noexcept] bool operator==(const QPointer&lt;T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const std::nullptr_t &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Equality operator. Returns true if the pointer guarded by <db:code role="parameter">lhs</db:code> is nullptr, otherwise returns false.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-4">
<db:title>[noexcept] bool operator==(const std::nullptr_t &amp;<db:emphasis>lhs</db:emphasis>, const QPointer&lt;T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Equality operator. Returns true if the pointer guarded by <db:code role="parameter">rhs</db:code> is nullptr, otherwise returns false.</db:para>
</db:section>
</db:section>
</db:article>
