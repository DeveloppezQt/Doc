<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QPointer Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QPointer</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qpointer.xml">QPointer</db:link> class is a template class that provides guarded pointers to <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QPointer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QPointer is part of <db:simplelist><db:member>objectmodel</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A guarded pointer, <db:link xlink:href="qpointer.xml">QPointer</db:link>&lt;T&gt;, behaves like a normal C++ pointer T *, except that it is automatically set to 0 when the referenced object is destroyed (unlike normal C++ pointers, which become &quot;dangling pointers&quot; in such cases). T must be a subclass of <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
<db:para>Guarded pointers are useful whenever you need to store a pointer to a <db:link xlink:href="qobject.xml">QObject</db:link> that is owned by someone else, and therefore might be destroyed while you still hold a reference to it. You can safely test the pointer for validity.</db:para>
<db:para>Note that Qt 5 introduces a slight change in behavior when using <db:link xlink:href="qpointer.xml">QPointer</db:link>.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>When using <db:link xlink:href="qpointer.xml">QPointer</db:link> on a <db:link xlink:href="qwidget.xml">QWidget</db:link> (or a subclass of <db:link xlink:href="qwidget.xml">QWidget</db:link>), previously the <db:link xlink:href="qpointer.xml">QPointer</db:link> would be cleared by the <db:link xlink:href="qwidget.xml">QWidget</db:link> destructor. Now, the <db:link xlink:href="qpointer.xml">QPointer</db:link> is cleared by the <db:link xlink:href="qobject.xml">QObject</db:link> destructor (since this is when <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link> objects are cleared). Any QPointers tracking a widget will <db:emphasis role="bold">NOT</db:emphasis> be cleared before the <db:link xlink:href="qwidget.xml">QWidget</db:link> destructor destroys the children for the widget being tracked.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Qt also provides <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link>, an implementation of a reference-counted shared pointer object, which can be used to maintain a collection of references to an individual pointer.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">    QPointer&lt;QLabel&gt; label = new QLabel;
    label-&gt;setText(&quot;&amp;Status:&quot;);
    ...
    if (label)
        label-&gt;show();
</db:programlisting>
<db:para>If the <db:link xlink:href="qlabel.xml">QLabel</db:link> is deleted in the meantime, the label variable will hold 0 instead of an invalid address, and the last line will never be executed.</db:para>
<db:para>The functions and operators available with a <db:link xlink:href="qpointer.xml">QPointer</db:link> are the same as those available with a normal unguarded pointer, except the pointer arithmetic operators (+, -, ++, and --), which are normally used only with arrays of objects.</db:para>
<db:para>Use QPointers like normal pointers and you will not need to read this class documentation.</db:para>
<db:para>For creating guarded pointers, you can construct or assign to them from a T* or from another guarded pointer of the same type. You can compare them with each other using operator==() and operator!=(), or test for 0 with isNull(). You can dereference them using either the *x or the x-&gt;member notation.</db:para>
<db:para>A guarded pointer will automatically cast to a T *, so you can freely mix guarded and unguarded pointers. This means that if you have a <db:link xlink:href="qpointer.xml">QPointer</db:link>&lt;<db:link xlink:href="qwidget.xml">QWidget</db:link>&gt;, you can pass it to a function that requires a <db:link xlink:href="qwidget.xml">QWidget</db:link> *. For this reason, it is of little value to declare functions to take a <db:link xlink:href="qpointer.xml">QPointer</db:link> as a parameter; just use normal pointers. Use a <db:link xlink:href="qpointer.xml">QPointer</db:link> when you are storing a pointer over time.</db:para>
<db:para>Note that class T must inherit <db:link xlink:href="qobject.xml">QObject</db:link>, or a compilation or link error will result.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml">QObject</db:link></db:member>
<db:member><db:link xlink:href="qobjectcleanuphandler.xml">QObjectCleanupHandler</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:article>
