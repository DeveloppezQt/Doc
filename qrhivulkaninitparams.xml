<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title></db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Vulkan specific initialization parameters.</db:para>
<db:para>This struct was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>rhi/qrhi.h</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui-private</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:note>
<db:para>This is a RHI API with limited compatibility guarantees, see <db:link xlink:href="qrhi.xml">QRhi</db:link> for details.</db:para>
</db:note>
<db:para>A Vulkan-based <db:link xlink:href="qrhi.xml">QRhi</db:link> needs at minimum a valid <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link>. It is up to the user to ensure this is available and initialized. This is typically done in main() similarly to the following:</db:para>
<db:programlisting language="cpp" role="bad">int main(int argc, char **argv)
{
    ...

    QVulkanInstance inst;
    inst.setLayers({ &quot;VK_LAYER_KHRONOS_validation&quot; }); // for debugging only, not for release builds
    inst.setExtensions(QRhiVulkanInitParams::preferredInstanceExtensions());
    if (!inst.create())
        qFatal(&quot;Vulkan not available&quot;);

    ...
}
</db:programlisting>
<db:para>This example enables the <db:link xlink:href="https://github.com/KhronosGroup/Vulkan-ValidationLayers">Vulkan validation layers</db:link>, when they are available, and also enables the instance-level extensions <db:link xlink:href="qrhi.xml">QRhi</db:link> reports as desirable (such as, VK_KHR_get_physical_device_properties2), as long as they are supported by the Vulkan implementation at run time.</db:para>
<db:para>The former is optional, and is useful during the development phase <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> conveniently redirects messages and warnings to <db:link xlink:href="qtlogging.xml#qDebug">qDebug</db:link>. Avoid enabling it in production builds, however. The latter is strongly recommended, and is important in order to make certain features functional (for example, <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::CustomInstanceStepRate</db:link>).</db:para>
<db:para>Once this is done, a Vulkan-based <db:link xlink:href="qrhi.xml">QRhi</db:link> can be created by passing the instance and a <db:link xlink:href="qwindow.xml">QWindow</db:link> with its surface type set to <db:link xlink:href="qsurface.xml#SurfaceType-enum">QSurface::VulkanSurface</db:link>:</db:para>
<db:programlisting language="cpp" role="bad">QRhiVulkanInitParams params;
params.inst = vulkanInstance;
params.window = window;
rhi = QRhi::create(QRhi::Vulkan, &amp;params);
</db:programlisting>
<db:para>The window is optional and can be omitted. This is not recommended however because there is then no way to ensure presenting is supported while choosing a graphics queue.</db:para>
<db:note>
<db:para>Even when a window is specified, <db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link> objects can be created for other windows as well, as long as they all have their <db:link xlink:href="qwindow.xml#surfaceType">QWindow::surfaceType</db:link>() set to <db:link xlink:href="qsurface.xml#SurfaceType-enum">QSurface::VulkanSurface</db:link>.</db:para>
</db:note>
<db:para>To request additional extensions to be enabled on the Vulkan device, list them in <db:link xlink:href="qrhivulkaninitparams.xml#deviceExtensions-var">deviceExtensions</db:link>. This can be relevant when integrating with native Vulkan rendering code.</db:para>
<db:para>It is expected that the backend's desired list of instance extensions will be queried by calling the static function <db:link xlink:href="qrhivulkaninitparams.xml#preferredInstanceExtensions">preferredInstanceExtensions</db:link>() before initializing a <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link>. The returned list can be safely passed to <db:link xlink:href="qvulkaninstance.xml#setExtensions">QVulkanInstance::setExtensions</db:link>() as-is, because unsupported extensions are filtered out automatically. If this is not done, certain features, such as <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::CustomInstanceStepRate</db:link> may be reported as unsupported even when the Vulkan implementation on the system has support for the relevant functionality.</db:para>
<db:para>For full functionality the <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> needs to have API 1.1 enabled, when available. This means calling <db:link xlink:href="qvulkaninstance.xml#setApiVersion">QVulkanInstance::setApiVersion</db:link>() with 1.1 or higher whenever <db:link xlink:href="qvulkaninstance.xml#supportedApiVersion">QVulkanInstance::supportedApiVersion</db:link>() reports that at least Vulkan 1.1 is supported. If this is not done, certain features, such as <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::RenderTo3DTextureSlice</db:link> may be reported as unsupported even when the Vulkan implementation on the system supports Vulkan 1.1 or newer.</db:para>
<db:section xml:id="working-with-existing-vulkan-devices">
<db:title>Working with existing Vulkan devices</db:title>
<db:para>When interoperating with another graphics engine, it may be necessary to get a <db:link xlink:href="qrhi.xml">QRhi</db:link> instance that uses the same Vulkan device. This can be achieved by passing a pointer to a <db:link xlink:href="qrhivulkannativehandles.xml">QRhiVulkanNativeHandles</db:link> to <db:link xlink:href="qrhi.xml#create">QRhi::create</db:link>().</db:para>
<db:para>The physical device must always be set to a non-null value. If the intention is to just specify a physical device, but leave the rest of the VkDevice and queue creation to <db:link xlink:href="qrhi.xml">QRhi</db:link>, then no other members need to be filled out in the struct. For example, this is the case when working with OpenXR.</db:para>
<db:para>To adopt an existing <db:code>VkDevice</db:code>, the device field must be set to a non-null value as well. In addition, the graphics queue family index is required. The queue index is optional, as the default of 0 is often suitable.</db:para>
<db:para>Optionally, an existing command pool object can be specified as well. Also optionally, vmemAllocator can be used to share the same <db:link xlink:href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">Vulkan memory allocator</db:link> between two <db:link xlink:href="qrhi.xml">QRhi</db:link> instances.</db:para>
<db:para>The <db:link xlink:href="qrhi.xml">QRhi</db:link> does not take ownership of any of the external objects.</db:para>
<db:para>Applications are encouraged to query the list of desired device extensions by calling the static function <db:link xlink:href="qrhivulkaninitparams.xml#preferredExtensionsForImportedDevice">preferredExtensionsForImportedDevice</db:link>(), and enable them on the VkDevice. Otherwise certain <db:link xlink:href="qrhi.xml">QRhi</db:link> features may not be available.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="preferredExtensionsForImportedDevice">
<db:title>[static] QByteArrayList QRhiVulkanInitParams::preferredExtensionsForImportedDevice()</db:title>
<db:para>Returns the list of device extensions that are expected to be enabled on the <db:code>VkDevice</db:code> when creating a Vulkan-based <db:link xlink:href="qrhi.xml">QRhi</db:link> with an externally created <db:code>VkDevice</db:code> object.</db:para>
</db:section>
<db:section xml:id="preferredInstanceExtensions">
<db:title>[static] QByteArrayList QRhiVulkanInitParams::preferredInstanceExtensions()</db:title>
<db:para>Returns the list of instance extensions that are expected to be enabled on the <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> that is used for the Vulkan-based <db:link xlink:href="qrhi.xml">QRhi</db:link>.</db:para>
<db:para>The returned list can be safely passed to <db:link xlink:href="qvulkaninstance.xml#setExtensions">QVulkanInstance::setExtensions</db:link>() as-is, because unsupported extensions are filtered out automatically.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-variable-documentation">
<db:title>Member Variable Documentation</db:title>
<db:section xml:id="deviceExtensions-var">
<db:title>QByteArrayList QRhiVulkanInitParams::deviceExtensions</db:title>
<db:para>Optional, empty by default. The list of Vulkan device extensions to enable. Unsupported extensions are ignored gracefully.</db:para>
</db:section>
<db:section xml:id="inst-var">
<db:title>QVulkanInstance * QRhiVulkanInitParams::inst</db:title>
<db:para>The <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> that has already been successfully <db:link xlink:href="qvulkaninstance.xml#create">created</db:link>, required.</db:para>
</db:section>
<db:section xml:id="window-var">
<db:title>QWindow * QRhiVulkanInitParams::window</db:title>
<db:para>Optional, but recommended when targeting a <db:link xlink:href="qwindow.xml">QWindow</db:link>.</db:para>
</db:section>
</db:section>
</db:article>
