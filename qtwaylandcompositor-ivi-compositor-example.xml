<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>IVI Compositor</db:title>
<db:productname>QtWaylandCompositor</db:productname>
<db:edition>Qt Wayland Compositor | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Wayland Compositor Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>IVI Compositor is an example that demonstrates how to use the <db:link xlink:href="qml-qtwayland-compositor-iviapplication-iviapplication.xml">IviApplication</db:link> extension.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="introduction">
<db:title>Introduction</db:title>
<db:para>This example demonstrates using the <db:link xlink:href="qml-qtwayland-compositor-iviapplication-iviapplication.xml">IviApplication</db:link> shell extension in a Wayland display server (also known as a Wayland compositor).</db:para>
<db:para>For an introduction to the basic principles of creating a <db:link xlink:href="qtwaylandcompositor-index.xml">Qt Wayland Compositor</db:link> with Qt, see the <db:link xlink:href="qtwaylandcompositor-minimal-qml-example.xml">Minimal QML example</db:link>.</db:para>
</db:section>
<db:section xml:id="the-protocol">
<db:title>The Protocol</db:title>
<db:para><db:link xlink:href="qml-qtwayland-compositor-iviapplication-iviapplication.xml">IviApplication</db:link> is a <db:link xlink:href="qtwaylandcompositor-shellextensions.xml">shell extension</db:link> that was designed specifically for making In-vehice Infotainment systems.</db:para>
<db:para>It is a minimalistic protocol, and only provides the following functionality:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>The client can identify itself with an <db:emphasis>IVI-id</db:emphasis>.</db:para>
</db:listitem>
<db:listitem>
<db:para>The server can request that the client resizes itself.</db:para>
</db:listitem>
</db:orderedlist>
<db:section xml:id="the-identification-numbers">
<db:title>The Identification Numbers</db:title>
<db:para>In a typical <db:link xlink:href="qml-qtwayland-compositor-iviapplication-iviapplication.xml">IviApplication</db:link> setup, you will have a predefined set of applications that can connect to the server. Since these applications are already known when the system is designed, they can be assigned hardcoded numbers that identify them. Given that the client and server agree on these numbers ahead of time, semantics can be built into the ID numbers.</db:para>
<db:para>For instance, if a client identifies itself as the navigation application, the server can recognize this and allocate a large, centered part of the screen for its window. An application identifying itself as a clock, on the other hand, might be delegated to a smaller area in the margins of the screen.</db:para>
<db:para>By default, Qt applications will advertise their system PIDs (&quot;process IDs&quot;) as the <db:emphasis>IVI-id</db:emphasis>. The client can override this by setting <db:code>QT_IVI_SURFACE_ID</db:code> in its environment before connecting to the server.</db:para>
</db:section>
</db:section>
<db:section xml:id="the-example">
<db:title>The Example</db:title>
<db:para>A Qt Wayland Compositor may support multiple shell extensions at once, but the <db:emphasis>IVICompositor example</db:emphasis> only supports the <db:link xlink:href="qml-qtwayland-compositor-iviapplication-iviapplication.xml">IviApplication</db:link> protocol. This means that the clients have to also support this shell extension in order to connect to the server.</db:para>
<db:para>The compositor window in the example is split into two horizontally: A left area which is designated for a specialized application with the id &quot;1337&quot;, and a right area which is for all other applications.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/ivi-compositor-1.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="creating-the-layout">
<db:title>Creating the Layout</db:title>
<db:para>The layout of the window is created inside a <db:link xlink:href="qml-qtwayland-compositor-waylandoutput.xml">WaylandOutput</db:link>. This typically corresponds to a physical screen available to the compositor. If a single <db:link xlink:href="qml-qtwayland-compositor-waylandoutput.xml">WaylandOutput</db:link> is created, as in the <db:emphasis>IVICompositor example</db:emphasis>, it will usually correspond to the primary screen.</db:para>
<db:programlisting language="qml">WaylandOutput {
    sizeFollowsWindow: true
    window: Window {
        width: 1024
        height: 768
        visible: true
        Rectangle {
            id: leftArea
            width: parent.width / 2
            height: parent.height
            anchors.left: parent.left
            color: &quot;cornflowerblue&quot;
            Text {
                anchors.centerIn: parent
                text: &quot;Ivi surface with id 1337&quot;
            }
        }
        Rectangle {
            id: rightArea
            width: parent.width / 2
            height: parent.height
            anchors.right: parent.right
            color: &quot;burlywood&quot;
            Text {
                anchors.centerIn: parent
                text: &quot;Other surfaces&quot;
            }
        }
    }
}
</db:programlisting>
<db:para>The code creates a <db:link xlink:href="qml-qtwayland-compositor-waylandoutput.xml">WaylandOutput</db:link> for the screen and creates a <db:link xlink:href="qtwaylandcompositor-minimal-cpp-example.xml#window">Window</db:link> on this as the top level container of all compositor contents. Inside this window, it creates two rectangles that will serve as containers for applications as they connect.</db:para>
</db:section>
<db:section xml:id="connecting-clients">
<db:title>Connecting Clients</db:title>
<db:para>If no additional configuration has been done, a Qt application will connect with an <db:emphasis>IVI-id</db:emphasis> equal to its process ID. For instance, if we run another Qt example application with <db:code>-platform wayland</db:code>, it will be delegated to the right-hand side of the layout, granted that its ID is different from &quot;1337&quot;.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/ivi-compositor-2.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>However, if we set the <db:code>QT_IVI_SURFACE_ID</db:code> environment variable to &quot;1337&quot; before starting the example, it will be delegated to the left-hand side of the layout.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/ivi-compositor-3.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>When a client connects to the <db:code>IVIApplication</db:code> interface, it will emit the <db:code>iviSurfaceCreated</db:code> signal. This is where the positioning of the application's surface is handled.</db:para>
<db:programlisting language="qml">IviApplication {
    onIviSurfaceCreated: (iviSurface) =&amp;gt;  {
        var surfaceArea = iviSurface.iviId === 1337 ? leftArea : rightArea;
        var item = chromeComponent.createObject(surfaceArea, { &quot;shellSurface&quot;: iviSurface } );
        item.handleResized();
    }
}
</db:programlisting>
<db:para>The <db:code>iviSurfaceCreated</db:code> signal receives an <db:link xlink:href="qml-qtwayland-compositor-iviapplication-ivisurface.xml">IviSurface</db:link> argument which can be used to access the client's ID. The compositor then creates a <db:link xlink:href="qml-qtwayland-compositor-shellsurfaceitem.xml">ShellSurfaceItem</db:link> for the surface (as defined by the <db:code>chromeComponent</db:code>). <db:code>ShellSurfaceItem</db:code> is the class used for placing shell surfaces into the Qt Quick scene, and you will see this same pattern in all the Qt Wayland Compositor examples.</db:para>
<db:para>What makes the <db:emphasis>IVICompositor example</db:emphasis> special is that it checks the <db:code>iviId</db:code> property of the incoming shell surface and decides on a parent for the <db:link xlink:href="qml-qtwayland-compositor-shellsurfaceitem.xml">ShellSurfaceItem</db:link> depending on what this is. If the ID is equal to &quot;1337&quot; it will be parented to the <db:code>leftArea</db:code>, and if not it will be in the <db:code>rightArea</db:code>.</db:para>
<db:para>The implementation of the <db:link xlink:href="qml-qtwayland-compositor-shellsurfaceitem.xml">ShellSurfaceItem</db:link> handles resizing by informing the client whenever the size changes (which can happen if the compositor is running inside a desktop-style windowing system and its window is resized).</db:para>
<db:programlisting language="qml">onWidthChanged: handleResized()
onHeightChanged: handleResized()
function handleResized() {
    if (width &amp;gt; 0 &amp;amp;&amp;amp; height &amp;gt; 0)
        shellSurface.sendConfigure(Qt.size(width, height));
}
</db:programlisting>
<db:para>The <db:code>sendConfigure()</db:code> method is defined in <db:link xlink:href="qml-qtwayland-compositor-iviapplication-ivisurface.xml">IviSurface</db:link> and will send an event to the client. The client will receive a resize event with the new size, so it can relayout its contents.</db:para>
<db:para>If multiple applications connect to the same area in the layout, they will simply be stacked according to normal Qt Quick ordering rules. There are no built-in mechanisms for closing applications or managing state, but this can easily be added as ordinary Qt Quick code.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtwayland.git/tree/examples/wayland/ivi-compositor?h=6.7">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
