<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QVideoFilterRunnable Class</db:title>
<db:productname>QtMultimedia</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Multimedia Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qvideofilterrunnable.xml">QVideoFilterRunnable</db:link> class represents the implementation of a filter that owns all graphics and computational resources, and performs the actual filtering or calculations.</db:para>
<db:para>This class was introduced in Qt 5.5.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QVideoFilterRunnable</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.5</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += multimedia</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QVideoFilterRunnable is part of <db:simplelist><db:member>multimedia</db:member><db:member>multimedia_video</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Video filters are split into <db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> and corresponding <db:link xlink:href="qvideofilterrunnable.xml">QVideoFilterRunnable</db:link> instances, similar to <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> and <db:link xlink:href="qsgnode.xml">QSGNode</db:link>. This is necessary to support threaded rendering scenarios. When using the threaded render loop of the Qt Quick scene graph, all rendering happens on a dedicated thread. <db:link xlink:href="qvideofilterrunnable.xml">QVideoFilterRunnable</db:link> instances always live on this thread and all its functions, <db:link xlink:href="qvideofilterrunnable.xml#run">run</db:link>(), the constructor, and the destructor, are guaranteed to be invoked on that thread with the OpenGL context bound. <db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> instances live on the main (GUI) thread, like any other <db:link xlink:href="qobject.xml">QObject</db:link> and <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> instances created from QML.</db:para>
<db:para>Once created, <db:link xlink:href="qvideofilterrunnable.xml">QVideoFilterRunnable</db:link> instances are managed by Qt Multimedia and will be automatically destroyed and recreated when necessary, for example when the scene graph is invalidated or the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> changes or is closed. Creation happens via the <db:link xlink:href="qabstractvideofilter.xml#createFilterRunnable">QAbstractVideoFilter::createFilterRunnable</db:link>() factory function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="RunFlag-enum">
<db:title>enum QVideoFilterRunnable::RunFlag</db:title>
<db:bridgehead renderas="sect2">flags QVideoFilterRunnable::RunFlags</db:bridgehead>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideofilterrunnable.xml">QVideoFilterRunnable</db:link></db:emphasis>::LastInChain</db:code></db:para>
</db:td>
<db:td><db:code>0x01</db:code></db:td>
<db:td>
<db:para>Indicates that the filter runnable's associated <db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> is the last in the corresponding <db:link xlink:href="qml-qtmultimedia-videooutput.xml">VideoOutput</db:link> type's filters list, meaning that the returned frame is the one that is going to be presented to the scene graph without invoking any further filters.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>RunFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;RunFlag&gt;. </db:code>It stores an OR combination of <db:code>RunFlag</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="run">
<db:title>[pure virtual] QVideoFrame QVideoFilterRunnable::run(QVideoFrame *<db:emphasis>input</db:emphasis>, const QVideoSurfaceFormat &amp;<db:emphasis>surfaceFormat</db:emphasis>, QVideoFilterRunnable::RunFlags <db:emphasis>flags</db:emphasis>)</db:title>
<db:para>Reimplement this function to perform filtering or computation on the <db:code role="parameter">input</db:code> video frame. Like the constructor and destructor, this function is always called on the render thread with the OpenGL context bound.</db:para>
<db:para>Implementations that do not modify the video frame can simply return <db:code role="parameter">input</db:code>.</db:para>
<db:para>It is safe to access properties of the associated <db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> instance from this function.</db:para>
<db:para><db:code role="parameter">input</db:code> will not be mapped, it is up to this function to call <db:link xlink:href="qvideoframe.xml#map">QVideoFrame::map</db:link>() and <db:link xlink:href="qvideoframe.xml#unmap">QVideoFrame::unmap</db:link>() as necessary.</db:para>
<db:para><db:code role="parameter">surfaceFormat</db:code> provides additional information, for example it can be used to determine which way is up in the input image as that is important for filters to operate on multiple platforms with multiple cameras.</db:para>
<db:para><db:code role="parameter">flags</db:code> contains additional information about the filter's invocation. For example the <db:link xlink:href="qvideofilterrunnable.xml#RunFlag-enum">LastInChain</db:link> flag indicates that the filter is the last in a <db:link xlink:href="qml-qtmultimedia-videooutput.xml">VideoOutput</db:link>'s associated filter list. This can be very useful in cases where multiple filters are chained together and the work is performed on image data in some custom format (for example a format specific to some computer vision framework). To avoid conversion on every filter in the chain, all intermediate filters can return a <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> hosting data in the custom format. Only the last, where the flag is set, returns a <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> in a format compatible with Qt.</db:para>
<db:para>Filters that want to expose the results of their computation to Javascript code in QML can declare their own custom signals in the <db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> subclass to indicate the completion of the operation. For filters that only calculate some results and do not modify the video frame, it is also possible to operate asynchronously. They can queue the necessary operations using the compute API and return from this function without emitting any signals. The signal indicating the completion is then emitted only when the compute API indicates that the operations were done and the results are available. Note that it is strongly recommended to represent the filter's output data as a separate instance of <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> or a <db:link xlink:href="qobject.xml">QObject</db:link>-derived class which is passed as a parameter to the signal and becomes exposed to the Javascript engine. In case of <db:link xlink:href="qobject.xml">QObject</db:link> the ownership of this object is controlled by the standard QML rules: if it has no parent, ownership is transferred to the Javascript engine, otherwise it stays with the emitter. Note that the signal connection may be queued,for example when using the threaded render loop of Qt Quick, and so the object must stay valid for a longer time, destroying it right after calling this function is not safe. Using a dedicated results object is guaranteed to be safe even when using threaded rendering. The same is not necessarily true for properties on the <db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> instance itself: properties can safely be read in run() since the gui thread is blocked during that time but writing may become problematic.</db:para>
<db:note>
<db:para>Avoid time consuming operations in this function as they block the entire rendering of the application.</db:para>
</db:note>
<db:note>
<db:para>The handleType() and pixelFormat() of <db:code role="parameter">input</db:code> is completely up to the video decoding backend on the platform in use. On some platforms different forms of input are used depending on the graphics stack. For example, when playing back videos on Windows with the WMF backend, <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> contains OpenGL-wrapped Direct3D textures in case of using ANGLE, but regular pixel data when using desktop OpenGL (opengl32.dll). Similarly, the video file format will often decide if the data is RGB or YUV, but this may also depend on the decoder and the configuration in use. The returned video frame does not have to be in the same format as the input, for example a filter with an input of a <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> backed by system memory can output a <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> with an OpenGL texture handle.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:member>
<db:member><db:link xlink:href="qvideosurfaceformat.xml">QVideoSurfaceFormat</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
