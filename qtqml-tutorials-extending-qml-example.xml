<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Writing QML Extensions with C++</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Qml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Tutorial about extending QML with Qt C++.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The <db:link xlink:href="qtqml-index.xml">Qt Qml</db:link> module provides a set of APIs for extending QML through C++ extensions. You can write extensions to add your own QML types, extend existing Qt types, or call C/C++ functions that are not accessible from ordinary QML code.</db:para>
<db:para>This tutorial shows how to write a QML extension using C++ that includes core QML features, including properties, signals and bindings. It also shows how extensions can be deployed through plugins.</db:para>
<db:para>Many of the topics covered in this tutorial are documented in further detail in <db:link xlink:href="qtqml-cppintegration-overview.xml">Overview - QML and C++ Integration</db:link> and its documentation sub-topics. In particular, you may be interested in the sub-topics <db:link xlink:href="qtqml-cppintegration-exposecppattributes.xml">Exposing Attributes of C++ Classes to QML</db:link> and <db:link xlink:href="qtqml-cppintegration-definetypes.xml">Defining QML Types from C++</db:link>.</db:para>
<db:section xml:id="opening-the-tutorial-sources">
<db:title>Opening the Tutorial Sources</db:title>
<db:para>The code in this tutorial is available as part of the Qt sources. If you installed Qt with the Qt Online Installer, you can find the sources in the Qt installation directory under Examples/Qt-6.9.1/qml/tutorials/extending-qml/.</db:para>
</db:section>
<db:section xml:id="creating-project-from-scratch">
<db:title>Creating Project from Scratch</db:title>
<db:para>Alternatively, you can follow the tutorial by creating the sources from scratch: For each chapter, create a new project using the <db:emphasis>Qt Quick Application</db:emphasis> template in Qt Creator, as instructed in <db:link xlink:href="https://doc.qt.io/qtcreator/quick-projects.html">Qt Creator: Create Qt Quick Applications</db:link>. Then follow along by adapting and extending the generated skeleton code.</db:para>
</db:section>
<db:section xml:id="chapter-1-creating-a-new-type">
<db:title>Chapter 1: Creating a New Type</db:title>
<db:para>extending-qml/chapter1-basics</db:para>
<db:para>A common task when extending QML is to provide a new QML type that supports some custom functionality beyond what is provided by the built-in <db:link xlink:href="">Qt Quick types</db:link>. For example, this could be done to implement particular data models, or provide types with custom painting and drawing capabilities, or access system features like network programming that are not accessible through built-in QML features.</db:para>
<db:para>In this tutorial, we will show how to use the C++ classes in the Qt Quick module to extend QML. The end result will be a simple Pie Chart display implemented by several custom QML types connected together through QML features like bindings and signals, and made available to the QML runtime through a plugin.</db:para>
<db:para>To begin with, let's create a new QML type called &quot;PieChart&quot; that has two properties: a name and a color. We will make it available in an importable type namespace called &quot;Charts&quot;, with a version of 1.0.</db:para>
<db:para>We want this PieChart type to be usable from QML like this:</db:para>
<db:programlisting language="qml">import Charts

PieChart {
    width: 100; height: 100
    name: &quot;A simple pie chart&quot;
    color: &quot;red&quot;
}
</db:programlisting>
<db:para>To do this, we need a C++ class that encapsulates this PieChart type and its properties. Since QML makes extensive use of Qt's <db:link xlink:href="metaobjects.xml">meta object system</db:link>, this new class must:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Inherit from <db:link xlink:href="qobject.xml">QObject</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Declare its properties using the <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link> macro</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="class-declaration">
<db:title>Class Declaration</db:title>
<db:para>Here is our PieChart class, defined in piechart.h:</db:para>
<db:programlisting language="cpp">#include &lt;QtQuick/QQuickPaintedItem&gt;
#include &lt;QColor&gt;

class PieChart : public QQuickPaintedItem
{
    Q_OBJECT
    Q_PROPERTY(QString name READ name WRITE setName FINAL)
    Q_PROPERTY(QColor color READ color WRITE setColor FINAL)
    QML_ELEMENT

public:
    PieChart(QQuickItem *parent = nullptr);

    QString name() const;
    void setName(const QString &amp;name);

    QColor color() const;
    void setColor(const QColor &amp;color);

    void paint(QPainter *painter) override;

private:
    QString m_name;
    QColor m_color;
};
</db:programlisting>
<db:para>The class inherits from QQuickPaintedItem because we want to override QQuickPaintedItem::paint() to perform drawing operations with the <db:link xlink:href="qpainter.xml">QPainter</db:link> API. If the class just represented some data type and was not an item that actually needed to be displayed, it could simply inherit from <db:link xlink:href="qobject.xml">QObject</db:link>. Or, if we want to extend the functionality of an existing <db:link xlink:href="qobject.xml">QObject</db:link>-based class, it could inherit from that class instead. Alternatively, if we want to create a visual item that doesn't need to perform drawing operations with the <db:link xlink:href="qpainter.xml">QPainter</db:link> API, we can just subclass QQuickItem.</db:para>
<db:para>The PieChart class defines the two properties, name and color, with the <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link> macro, and overrides QQuickPaintedItem::paint(). The PieChart class is registered using the <db:link xlink:href="qqmlintegration-h.xml#QML_ELEMENT">QML_ELEMENT</db:link> macro, to allow it to be used from QML. If you don't register the class, App.qml won't be able to create a PieChart.</db:para>
</db:section>
<db:section xml:id="qmake-setup">
<db:title>qmake Setup</db:title>
<db:para>For the registration to take effect, the qmltypes option is added to CONFIG in the project file and a QML_IMPORT_NAME and QML_IMPORT_MAJOR_VERSION are given:</db:para>
<db:programlisting language="cpp">CONFIG += qmltypes
QML_IMPORT_NAME = Charts
QML_IMPORT_MAJOR_VERSION = 1
</db:programlisting>
</db:section>
<db:section xml:id="cmake-setup">
<db:title>CMake Setup</db:title>
<db:para>Similarly, for the registration to take effect when using CMake, use the <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> command:</db:para>
<db:programlisting language="cpp">qt_add_qml_module(chapter1-basics
    URI Charts
    QML_FILES App.qml
    DEPENDENCIES QtQuick
)
</db:programlisting>
</db:section>
<db:section xml:id="class-implementation">
<db:title>Class Implementation</db:title>
<db:para>The class implementation in piechart.cpp simply sets and returns the m_name and m_color values as appropriate, and implements paint() to draw a simple pie chart:</db:para>
<db:programlisting language="cpp">PieChart::PieChart(QQuickItem *parent)
    : QQuickPaintedItem(parent)
{
}
...
void PieChart::paint(QPainter *painter)
{
    QPen pen(m_color, 2);
    painter-&gt;setPen(pen);
    painter-&gt;setRenderHints(QPainter::Antialiasing, true);
    painter-&gt;drawPie(boundingRect().adjusted(1, 1, -1, -1), 90 * 16, 290 * 16);
}
</db:programlisting>
</db:section>
<db:section xml:id="qml-usage">
<db:title>QML Usage</db:title>
<db:para>Now that we have defined the PieChart type, we will use it from QML. The App.qml file creates a PieChart item and displays the pie chart's details using a standard QML Text item:</db:para>
<db:programlisting language="qml">import Charts
import QtQuick

Item {
    width: 300; height: 200

    PieChart {
        id: aPieChart
        anchors.centerIn: parent
        width: 100; height: 100
        name: &quot;A simple pie chart&quot;
        color: &quot;red&quot;
    }

    Text {
        anchors { bottom: parent.bottom; horizontalCenter: parent.horizontalCenter; bottomMargin: 20 }
        text: aPieChart.name
    }
}
</db:programlisting>
<db:para>Notice that although the color is specified as a string in QML, it is automatically converted to a <db:link xlink:href="qcolor.xml">QColor</db:link> object for the PieChart color property. Automatic conversions are provided for various other <db:link xlink:href="qtqml-typesystem-valuetypes.xml">value types</db:link>. For example, a string like &quot;640x480&quot; can be automatically converted to a <db:link xlink:href="qsize.xml">QSize</db:link> value.</db:para>
<db:para>We'll also create a C++ application that uses a QQuickView to run and display App.qml.</db:para>
<db:para>Here is the application main.cpp:</db:para>
<db:programlisting language="cpp">#include &quot;piechart.h&quot;
#include &lt;QtQuick/QQuickView&gt;
#include &lt;QGuiApplication&gt;

int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);

    QQuickView view;
    view.setResizeMode(QQuickView::SizeRootObjectToView);
    view.loadFromModule(&quot;Charts&quot;, &quot;App&quot;);
    view.show();
    return QGuiApplication::exec();
}
</db:programlisting>
</db:section>
<db:section xml:id="project-build">
<db:title>Project Build</db:title>
<db:para>To build the project we include the files, link against the libraries, and define a type namespace called &quot;Charts&quot; with version 1.0 for any types exposed to QML.</db:para>
<db:para>Using qmake:</db:para>
<db:programlisting language="cpp">QT += qml quick

CONFIG += qmltypes
QML_IMPORT_NAME = Charts
QML_IMPORT_MAJOR_VERSION = 1

HEADERS += piechart.h
SOURCES += piechart.cpp \
           main.cpp

RESOURCES += chapter1-basics.qrc

DESTPATH = $$[QT_INSTALL_EXAMPLES]/qml/tutorials/extending-qml/chapter1-basics
target.path = $$DESTPATH
INSTALLS += target

</db:programlisting>
<db:para>Using CMake:</db:para>
<db:programlisting language="cpp"># Copyright (C) 2022 The Qt Company Ltd.
# SPDX-License-Identifier: LicenseRef-Qt-Commercial OR BSD-3-Clause

cmake_minimum_required(VERSION 3.16)
project(chapter1-basics LANGUAGES CXX)

find_package(Qt6 REQUIRED COMPONENTS Core Gui Qml Quick)

qt_standard_project_setup(REQUIRES 6.8)

qt_add_executable(chapter1-basics
    main.cpp
    piechart.cpp piechart.h
)

set_target_properties(chapter1-basics PROPERTIES
    WIN32_EXECUTABLE TRUE
    MACOSX_BUNDLE TRUE
)

target_link_libraries(chapter1-basics PUBLIC
    Qt6::Core
    Qt6::Gui
    Qt6::Qml
    Qt6::Quick
)
qt_add_qml_module(chapter1-basics
    URI Charts
    QML_FILES App.qml
    DEPENDENCIES QtQuick
)
install(TARGETS chapter1-basics
    BUNDLE  DESTINATION .
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
)

qt_generate_deploy_qml_app_script(
    TARGET chapter1-basics
    OUTPUT_SCRIPT deploy_script
    MACOS_BUNDLE_POST_BUILD
    NO_UNSUPPORTED_PLATFORM_ERROR
    DEPLOY_USER_QML_MODULES_ON_UNSUPPORTED_PLATFORM
)
install(SCRIPT ${deploy_script})

</db:programlisting>
<db:para>Now we can build and run the application:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/extending-tutorial-chapter1.png"/>
</db:imageobject>
</db:mediaobject>
<db:note>
<db:para>You may see a warning <db:emphasis>Expression ... depends on non-bindable properties: PieChart::name</db:emphasis>. This happens because we add a binding to the writable name property, but haven't yet defined a notify signal for it. The QML engine therefore cannot update the binding if the name value changes. This is addressed in the following chapters.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="chapter-2-connecting-to-c-methods-and-signals">
<db:title>Chapter 2: Connecting to C++ Methods and Signals</db:title>
<db:para>extending-qml/chapter2-methods</db:para>
<db:para>Suppose we want PieChart to have a &quot;clearChart()&quot; method that erases the chart and then emits a &quot;chartCleared&quot; signal. Our App.qml would be able to call clearChart() and receive chartCleared() signals like this:</db:para>
<db:programlisting language="qml">import Charts
import QtQuick

Item {
    width: 300; height: 200

    PieChart {
        id: aPieChart
        anchors.centerIn: parent
        width: 100; height: 100
        color: &quot;red&quot;

        onChartCleared: console.log(&quot;The chart has been cleared&quot;)
    }

    MouseArea {
        anchors.fill: parent
        onClicked: aPieChart.clearChart()
    }

    Text {
        anchors { bottom: parent.bottom; horizontalCenter: parent.horizontalCenter; bottomMargin: 20 }
        text: &quot;Click anywhere to clear the chart&quot;
    }
}
</db:programlisting>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/extending-tutorial-chapter2.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>To do this, we add a clearChart() method and a chartCleared() signal to our C++ class:</db:para>
<db:programlisting language="cpp">class PieChart : public QQuickPaintedItem
{
    ...
public:
    ...
    Q_INVOKABLE void clearChart();

signals:
    void chartCleared();
    ...
};
</db:programlisting>
<db:para>The use of <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> makes the clearChart() method available to the Qt Meta-Object system, and in turn, to QML.</db:para>
<db:note>
<db:para>You can also declare the method as a Qt slot instead of using <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link>, because public and protected slots are also callable from QML (you cannot call private slots).</db:para>
</db:note>
<db:para>The clearChart() method changes the color to <db:link xlink:href="qt.xml#GlobalColor-enum">Qt::transparent</db:link>, repaints the chart, then emits the chartCleared() signal:</db:para>
<db:programlisting language="cpp">void PieChart::clearChart()
{
    setColor(QColor(Qt::transparent));
    update();

    emit chartCleared();
}
</db:programlisting>
<db:para>Now when we run the application and click the window, the pie chart disappears, and the application outputs:</db:para>
<db:programlisting language="cpp" role="bad">qml: The chart has been cleared
</db:programlisting>
</db:section>
<db:section xml:id="chapter-3-adding-property-bindings">
<db:title>Chapter 3: Adding Property Bindings</db:title>
<db:para>extending-qml/chapter3-bindings</db:para>
<db:para>Property binding is a powerful feature of QML that allows values of different types to be synchronized automatically. It uses signals to notify and update other types' values when property values are changed.</db:para>
<db:para>Let's enable property bindings for the color property. That means if we have code like this:</db:para>
<db:programlisting language="qml">import Charts
import QtQuick

Item {
    width: 300; height: 200

    Row {
        anchors.centerIn: parent
        spacing: 20

        PieChart {
            id: chartA
            width: 100; height: 100
            color: &quot;red&quot;
        }

        PieChart {
            id: chartB
            width: 100; height: 100
            color: chartA.color
        }
    }

    MouseArea {
        anchors.fill: parent
        onClicked: { chartA.color = &quot;blue&quot; }
    }

    Text {
        anchors { bottom: parent.bottom; horizontalCenter: parent.horizontalCenter; bottomMargin: 20 }
        text: &quot;Click anywhere to change the chart color&quot;
    }
}
</db:programlisting>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/extending-tutorial-chapter3.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The &quot;color: chartA.color&quot; statement binds the color value of chartB to the color of chartA. Whenever chartA's color value changes, chartB's color value updates to the same value. When the window is clicked, the onClicked handler in the MouseArea changes the color of chartA, thereby changing both charts to the color blue.</db:para>
<db:para>It's easy to enable property binding for the color property. We add a <db:link xlink:href="properties.xml">NOTIFY</db:link> feature to its <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>() declaration to indicate that a &quot;colorChanged&quot; signal is emitted whenever the value changes.</db:para>
<db:programlisting language="cpp">class PieChart : public QQuickPaintedItem
{
    ...
    Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged FINAL)
public:
    ...
signals:
    void colorChanged();
    ...
};
</db:programlisting>
<db:para>Then, we emit this signal in setColor():</db:para>
<db:programlisting language="cpp">void PieChart::setColor(const QColor &amp;color)
{
    if (color != m_color) {
        m_color = color;
        update();   // repaint with the new color
        emit colorChanged();
    }
}
</db:programlisting>
<db:para>It's important for setColor() to check that the color value has actually changed before emitting colorChanged(). This ensures the signal is not emitted unnecessarily and also prevents loops when other types respond to the value change.</db:para>
<db:para>The use of bindings is essential to QML. You should always add NOTIFY signals for properties if they are able to be implemented, so that your properties can be used in bindings. Properties that cannot be bound cannot be automatically updated and cannot be used as flexibly in QML. Also, since bindings are invoked so often and relied upon in QML usage, users of your custom QML types may see unexpected behavior if bindings are not implemented.</db:para>
</db:section>
<db:section xml:id="chapter-4-using-custom-property-types">
<db:title>Chapter 4: Using Custom Property Types</db:title>
<db:para>extending-qml/chapter4-customPropertyTypes</db:para>
<db:para>The PieChart type currently has a string-type property and a color-type property. It could have many other types of properties. For example, it could have an int-type property to store an identifier for each chart:</db:para>
<db:programlisting language="cpp">// C++
class PieChart : public QQuickPaintedItem
{
    Q_PROPERTY(int chartId READ chartId WRITE setChartId NOTIFY chartIdChanged)
    ...

public:
    void setChartId(int chartId);
    int chartId() const;
    ...

signals:
    void chartIdChanged();
};

// QML
PieChart {
    ...
    chartId: 100
}
</db:programlisting>
<db:para>Aside from int, we could use various other property types. Many of the Qt data types such as <db:link xlink:href="qcolor.xml">QColor</db:link>, <db:link xlink:href="qsize.xml">QSize</db:link> and <db:link xlink:href="qrect.xml">QRect</db:link> are automatically supported from QML. (See <db:link xlink:href="qtqml-cppintegration-data.xml">Data Type Conversion Between QML and C++</db:link> documentation for a full list.)</db:para>
<db:para>If we want to create a property whose type is not supported by QML by default, we need to register the type with the QML engine.</db:para>
<db:para>For example, let's replace the use of the property with a type called &quot;<db:link xlink:href="qml-qtcharts-pieslice.xml">PieSlice</db:link>&quot; that has a color property. Instead of assigning a color, we assign an PieSlice value which itself contains a color:</db:para>
<db:programlisting language="qml">import Charts
import QtQuick

Item {
    width: 300; height: 200

    PieChart {
        id: chart
        anchors.centerIn: parent
        width: 100; height: 100

        pieSlice: PieSlice {
            anchors.fill: parent
            color: &quot;red&quot;
        }
    }

    Component.onCompleted: console.log(&quot;The pie is colored &quot; + chart.pieSlice.color)
}
</db:programlisting>
<db:para>Like PieChart, this new PieSlice type inherits from QQuickPaintedItem and declares its properties with <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>():</db:para>
<db:programlisting language="cpp">class PieSlice : public QQuickPaintedItem
{
    Q_OBJECT
    Q_PROPERTY(QColor color READ color WRITE setColor FINAL)
    QML_ELEMENT

public:
    PieSlice(QQuickItem *parent = nullptr);

    QColor color() const;
    void setColor(const QColor &amp;color);

    void paint(QPainter *painter) override;

private:
    QColor m_color;
};
</db:programlisting>
<db:para>To use it in PieChart, we modify the color property declaration and associated method signatures:</db:para>
<db:programlisting language="cpp">class PieChart : public QQuickItem
{
    Q_OBJECT
    Q_PROPERTY(PieSlice* pieSlice READ pieSlice WRITE setPieSlice FINAL)
    ...
public:
    ...
    PieSlice *pieSlice() const;
    void setPieSlice(PieSlice *pieSlice);
    ...
};
</db:programlisting>
<db:para>There is one thing to be aware of when implementing setPieSlice(). The PieSlice is a visual item, so it must be set as a child of the PieChart using QQuickItem::setParentItem() so that the PieChart knows to paint this child item when its contents are drawn:</db:para>
<db:programlisting language="cpp">void PieChart::setPieSlice(PieSlice *pieSlice)
{
    m_pieSlice = pieSlice;
    pieSlice-&gt;setParentItem(this);
}
</db:programlisting>
<db:para>Like the PieChart type, the PieSlice type has to be exposted to QML using <db:link xlink:href="qqmlintegration-h.xml#QML_ELEMENT">QML_ELEMENT</db:link>.</db:para>
<db:programlisting language="cpp">class PieSlice : public QQuickPaintedItem
{
    Q_OBJECT
    Q_PROPERTY(QColor color READ color WRITE setColor FINAL)
    QML_ELEMENT

public:
    PieSlice(QQuickItem *parent = nullptr);

    QColor color() const;
    void setColor(const QColor &amp;color);

    void paint(QPainter *painter) override;

private:
    QColor m_color;
};
    ...
</db:programlisting>
<db:para>As with PieChart, we add the &quot;Charts&quot; type namespace, version 1.0, to our build file:</db:para>
<db:para>Using qmake:</db:para>
<db:programlisting language="cpp">QT += qml quick

CONFIG += qmltypes
QML_IMPORT_NAME = Charts
QML_IMPORT_MAJOR_VERSION = 1

HEADERS += piechart.h \
           pieslice.h
SOURCES += piechart.cpp \
           pieslice.cpp \
           main.cpp

RESOURCES += chapter4-customPropertyTypes.qrc

DESTPATH = $$[QT_INSTALL_EXAMPLES]/qml/tutorials/extending-qml/chapter4-customPropertyTypes
target.path = $$DESTPATH
INSTALLS += target

</db:programlisting>
<db:para>Using CMake:</db:para>
<db:programlisting language="cpp">    ...
qt_add_executable(chapter4-customPropertyTypes
    main.cpp
    piechart.cpp piechart.h
    pieslice.cpp pieslice.h
)
qt_add_qml_module(chapter4-customPropertyTypes
    URI Charts
    QML_FILES App.qml
    DEPENDENCIES QtQuick
)
    ...
</db:programlisting>
</db:section>
<db:section xml:id="chapter-5-using-list-property-types">
<db:title>Chapter 5: Using List Property Types</db:title>
<db:para>extending-qml/chapter5-listproperties</db:para>
<db:para>Right now, a PieChart can only have one PieSlice. Ideally a chart would have multiple slices, with different colors and sizes. To do this, we could have a slices property that accepts a list of PieSlice items:</db:para>
<db:programlisting language="qml">pragma ComponentBehavior: Bound
import Charts
import QtQuick

Item {
    width: 300; height: 200

    PieChart {
        id: chart
        anchors.centerIn: parent
        width: 100; height: 100

        component Slice: PieSlice {
            parent: chart
            anchors.fill: parent
        }

        slices: [
            Slice {
                color: &quot;red&quot;
                fromAngle: 0
                angleSpan: 110
            },
            Slice {
                color: &quot;black&quot;
                fromAngle: 110
                angleSpan: 50
            },
            Slice {
                color: &quot;blue&quot;
                fromAngle: 160
                angleSpan: 100
            }
        ]
    }
}
</db:programlisting>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/extending-tutorial-chapter5.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>To do this, we replace the pieSlice property in PieChart with a slices property, declared as a <db:link xlink:href="qqmllistproperty.xml">QQmlListProperty</db:link> type. The <db:link xlink:href="qqmllistproperty.xml">QQmlListProperty</db:link> class enables the creation of list properties in types exposed to QML. We replace the pieSlice() function with a slices() function that returns a list of slices. We also use a <db:link xlink:href="qlist.xml">QList</db:link> to store the internal list of slices as m_slices:</db:para>
<db:programlisting language="cpp">class PieChart : public QQuickItem
{
    Q_OBJECT
    Q_PROPERTY(QQmlListProperty&lt;PieSlice&gt; slices READ slices FINAL)
    ...
public:
    ...
    QQmlListProperty&lt;PieSlice&gt; slices();

private:
    QString m_name;
    QList&lt;PieSlice *&gt; m_slices;
};
</db:programlisting>
<db:para>Although the slices property does not have an associated WRITE function, it is still modifiable because of the way <db:link xlink:href="qqmllistproperty.xml">QQmlListProperty</db:link> works. In the PieChart implementation, we implement PieChart::slices() to return a <db:link xlink:href="qqmllistproperty.xml">QQmlListProperty</db:link> value:</db:para>
<db:programlisting language="cpp">QQmlListProperty&lt;PieSlice&gt; PieChart::slices()
{
    return QQmlListProperty&lt;PieSlice&gt;(this, &amp;m_slices);
}
</db:programlisting>
<db:para>This synthesizes the necessary functions to interact with the list from QML. The resulting <db:link xlink:href="qqmllistproperty.xml">QQmlListProperty</db:link> is a <db:emphasis>view</db:emphasis> into the list. Alternately, you can manually provide the individual access functions for the list. This is necessary if your list is not a <db:link xlink:href="qlist.xml">QList</db:link> or if you want to restrict or otherwise customize QML access to your list. In most cases, however, the constructor taking a <db:link xlink:href="qlist.xml">QList</db:link> pointer is the safest and easiest option.</db:para>
<db:para>The PieSlice class has also been modified to include fromAngle and angleSpan properties and to draw the slice according to these values. This is a straightforward modification if you have read the previous pages in this tutorial, so the code is not shown here.</db:para>
</db:section>
<db:section xml:id="chapter-6-writing-an-extension-plugin">
<db:title>Chapter 6: Writing an Extension Plugin</db:title>
<db:para>extending-qml/chapter6-plugins</db:para>
<db:para>Currently the PieChart and PieSlice types are used by App.qml, which is displayed using a QQuickView in a C++ application. An alternative way to use our QML extension is to create a plugin library to make it available to the QML engine as a new QML import module. This allows the PieChart and PieSlice types to be registered into a type namespace which can be imported by any QML application, instead of restricting these types to be only used by the one application.</db:para>
<db:para>The steps for creating a plugin are described in <db:link xlink:href="qtqml-modules-cppplugins.xml">Creating C++ Plugins for QML</db:link>. To start with, we create a plugin class named ChartsPlugin. It subclasses <db:link xlink:href="qqmlengineextensionplugin.xml">QQmlEngineExtensionPlugin</db:link> and uses the <db:link xlink:href="qtplugin.xml#Q_PLUGIN_METADATA">Q_PLUGIN_METADATA</db:link>() macro to register the plugin with the Qt meta object system.</db:para>
<db:para>Here is the ChartsPlugin definition in chartsplugin.h:</db:para>
<db:programlisting language="cpp">#include &lt;QQmlEngineExtensionPlugin&gt;

class ChartsPlugin : public QQmlEngineExtensionPlugin
{
    Q_OBJECT
    Q_PLUGIN_METADATA(IID QQmlEngineExtensionInterface_iid)
};
</db:programlisting>
<db:para>Then, we configure the build file to define the project as a plugin library.</db:para>
<db:para>Using qmake:</db:para>
<db:programlisting language="cpp">TEMPLATE = lib
CONFIG += plugin qmltypes
QT += qml quick

QML_IMPORT_NAME = Charts
QML_IMPORT_MAJOR_VERSION = 1

TARGET = $$qtLibraryTarget(chartsplugin)

HEADERS += piechart.h \
           pieslice.h \
           chartsplugin.h

SOURCES += piechart.cpp \
           pieslice.cpp

DESTPATH=$$[QT_INSTALL_EXAMPLES]/qml/tutorials/extending-qml/chapter6-plugins/$$QML_IMPORT_NAME

target.path=$$DESTPATH
qmldir.files=$$PWD/qmldir
qmldir.path=$$DESTPATH
INSTALLS += target qmldir

CONFIG += install_ok  # Do not cargo-cult this!

OTHER_FILES += qmldir

# Copy the qmldir file to the same folder as the plugin binary
cpqmldir.files = qmldir
cpqmldir.path = .
COPIES += cpqmldir

</db:programlisting>
<db:para>Using CMake:</db:para>
<db:programlisting language="cpp"># Copyright (C) 2022 The Qt Company Ltd.
# SPDX-License-Identifier: LicenseRef-Qt-Commercial OR BSD-3-Clause

qt6_policy(SET QTP0001 NEW)
qt6_add_qml_module(chartsplugin
    URI &quot;Charts&quot;
    PLUGIN_TARGET chartsplugin
    DEPENDENCIES QtQuick
)

target_sources(chartsplugin PRIVATE
    piechart.cpp piechart.h
    pieslice.cpp pieslice.h
)

target_link_libraries(chartsplugin PRIVATE
    Qt6::Core
    Qt6::Gui
    Qt6::Qml
    Qt6::Quick
)

install(TARGETS chartsplugin
    RUNTIME DESTINATION &quot;${CMAKE_INSTALL_BINDIR}/Charts&quot;
    LIBRARY DESTINATION &quot;${CMAKE_INSTALL_BINDIR}/Charts&quot;
)
install(FILES ${CMAKE_CURRENT_BINARY_DIR}/qmldir
    DESTINATION &quot;${CMAKE_INSTALL_BINDIR}/Charts&quot;
)

</db:programlisting>
<db:para>When building this example on Windows or Linux, the Charts directory will be located at the same level as the application that uses our new import module. This way, the QML engine will find our module as the default search path for QML imports includes the directory of the application executable. On macOS, the plugin binary is copied to Contents/PlugIns in the the application bundle. With qmake, this path is set in chapter6-plugins/app.pro:</db:para>
<db:programlisting language="cpp">macos:!qtConfig(static) {
    charts.files = $$OUT_PWD/Charts
    charts.path = Contents/PlugIns
    QMAKE_BUNDLE_DATA += charts
}

</db:programlisting>
<db:para>To account for this, we also need to add this location as a <db:link xlink:href="qtqml-syntax-imports.xml#qml-import-path">QML import path</db:link> in main.cpp:</db:para>
<db:programlisting language="cpp">    QQuickView view;
#ifdef Q_OS_MACOS
    view.engine()-&gt;addImportPath(app.applicationDirPath() + &quot;/../PlugIns&quot;);
#endif
    ...
</db:programlisting>
<db:para>Defining custom import paths is useful also when there are multiple applications using the same QML imports.</db:para>
<db:para>The .pro file also contains additional magic to ensure that the <db:link xlink:href="qtqml-modules-qmldir.xml">module definition qmldir file</db:link> is always copied to the same location as the plugin binary.</db:para>
<db:para>The qmldir file declares the module name and the plugin that is made available by the module:</db:para>
<db:programlisting language="cpp">module Charts
optional plugin chartsplugin
typeinfo plugins.qmltypes
depends QtQuick
prefer :/qt/qml/Charts/

</db:programlisting>
<db:para>Now we have a QML module that can be imported to any application, provided that the QML engine knows where to find it. The example contains an executable that loads App.qml, which uses the import Charts 1.0 statement. Alternatively, you can load the QML file using the <db:link xlink:href="">qml tool</db:link>, setting the import path to the current directory so that it finds the qmldir file:</db:para>
<db:programlisting language="cpp">qml -I . App.qml
</db:programlisting>
<db:para>The module &quot;Charts&quot; will be loaded by the QML engine, and the types provided by that module will be available for use in any QML document which imports it.</db:para>
</db:section>
<db:section xml:id="chapter-7-summary">
<db:title>Chapter 7: Summary</db:title>
<db:para>In this tutorial, we've shown the basic steps for creating a QML extension:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Define new QML types by subclassing <db:link xlink:href="qobject.xml">QObject</db:link> and registering them with <db:link xlink:href="qqmlintegration-h.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlintegration-h.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:para>
</db:listitem>
<db:listitem>
<db:para>Add callable methods using <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> or Qt slots, and connect to Qt signals with an onSignal syntax</db:para>
</db:listitem>
<db:listitem>
<db:para>Add property bindings by defining <db:link xlink:href="properties.xml">NOTIFY</db:link> signals</db:para>
</db:listitem>
<db:listitem>
<db:para>Define custom property types if the built-in types are not sufficient</db:para>
</db:listitem>
<db:listitem>
<db:para>Define list property types using <db:link xlink:href="qqmllistproperty.xml">QQmlListProperty</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Create a plugin library by defining a Qt plugin and writing a <db:link xlink:href="qtqml-modules-qmldir.xml">qmldir</db:link> file</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The <db:link xlink:href="qtqml-cppintegration-overview.xml">QML and C++ Integration overview</db:link> documentation shows other useful features that can be added to QML extensions. For example, we could use <db:link xlink:href="qtqml-syntax-objectattributes.xml#default-properties">default properties</db:link> to allow slices to be added without using the slices property:</db:para>
<db:programlisting language="cpp" role="bad">PieChart {
    PieSlice { ... }
    PieSlice { ... }
    PieSlice { ... }
}
</db:programlisting>
<db:para>Or randomly add and remove slices from time to time using <db:link xlink:href="qtqml-cppintegration-definetypes.xml#property-value-sources">property value sources</db:link>:</db:para>
<db:programlisting language="cpp" role="bad">PieChart {
    PieSliceRandomizer on slices {}
}
</db:programlisting>
<db:note>
<db:para>To continue learning about QML extensions and features follow the <db:link xlink:href="qtqml-tutorials-extending-qml-advanced-example.xml">Writing advanced QML Extensions with C++</db:link> tutorial.</db:para>
</db:note>
</db:section>
</db:article>
