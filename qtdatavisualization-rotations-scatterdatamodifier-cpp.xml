<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Rotations Example</db:title>
<db:productname>QtDataVisualization</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Using rotated scatter items.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the Qt Data Visualization module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:GPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3 or (at your option) any later version
** approved by the KDE Free Qt Foundation. The licenses are as published by
** the Free Software Foundation and appearing in the file LICENSE.GPL3
** included in the packaging of this file. Please review the following
** information to ensure the GNU General Public License requirements will
** be met: https://www.gnu.org/licenses/gpl-3.0.html.
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;scatterdatamodifier.h&quot;
#include &lt;QtDataVisualization/qscatterdataproxy.h&gt;
#include &lt;QtDataVisualization/qvalue3daxis.h&gt;
#include &lt;QtDataVisualization/q3dscene.h&gt;
#include &lt;QtDataVisualization/q3dcamera.h&gt;
#include &lt;QtDataVisualization/qscatter3dseries.h&gt;
#include &lt;QtDataVisualization/q3dtheme.h&gt;
#include &lt;QtDataVisualization/QCustom3DItem&gt;
#include &lt;QtCore/qmath.h&gt;

using namespace QtDataVisualization;

static const float verticalRange = 8.0f;
static const float horizontalRange = verticalRange;
static const float ellipse_a = horizontalRange / 3.0f;
static const float ellipse_b = verticalRange;
static const float doublePi = float(M_PI) * 2.0f;
static const float radiansToDegrees = 360.0f / doublePi;
static const float animationFrames = 30.0f;

ScatterDataModifier::ScatterDataModifier(Q3DScatter *scatter)
    : m_graph(scatter),
      m_fieldLines(12),
      m_arrowsPerLine(16),
      m_magneticField(new QScatter3DSeries),
      m_sun(new QCustom3DItem),
      m_magneticFieldArray(0),
      m_angleOffset(0.0f),
      m_angleStep(doublePi / m_arrowsPerLine / animationFrames)
{
    m_graph-&gt;setShadowQuality(QAbstract3DGraph::ShadowQualityNone);
    m_graph-&gt;scene()-&gt;activeCamera()-&gt;setCameraPreset(Q3DCamera::CameraPresetFront);

    // Magnetic field lines use custom narrow arrow
    m_magneticField-&gt;setItemSize(0.2f);
    m_magneticField-&gt;setMesh(QAbstract3DSeries::MeshUserDefined);
    m_magneticField-&gt;setUserDefinedMesh(QStringLiteral(&quot;:/mesh/narrowarrow.obj&quot;));
    QLinearGradient fieldGradient(0, 0, 16, 1024);
    fieldGradient.setColorAt(0.0, Qt::black);
    fieldGradient.setColorAt(1.0, Qt::white);
    m_magneticField-&gt;setBaseGradient(fieldGradient);
    m_magneticField-&gt;setColorStyle(Q3DTheme::ColorStyleRangeGradient);

    // For 'sun' we use a custom large sphere
    m_sun-&gt;setScaling(QVector3D(0.07f, 0.07f, 0.07f));
    m_sun-&gt;setMeshFile(QStringLiteral(&quot;:/mesh/largesphere.obj&quot;));
    QImage sunColor = QImage(2, 2, QImage::Format_RGB32);
    sunColor.fill(QColor(0xff, 0xbb, 0x00));
    m_sun-&gt;setTextureImage(sunColor);

    m_graph-&gt;addSeries(m_magneticField);
    m_graph-&gt;addCustomItem(m_sun);

    // Configure the axes according to the data
    m_graph-&gt;axisX()-&gt;setRange(-horizontalRange, horizontalRange);
    m_graph-&gt;axisY()-&gt;setRange(-verticalRange, verticalRange);
    m_graph-&gt;axisZ()-&gt;setRange(-horizontalRange, horizontalRange);
    m_graph-&gt;axisX()-&gt;setSegmentCount(int(horizontalRange));
    m_graph-&gt;axisZ()-&gt;setSegmentCount(int(horizontalRange));

    QObject::connect(&amp;m_rotationTimer, &amp;QTimer::timeout, this,
                     &amp;ScatterDataModifier::triggerRotation);

    toggleRotation();
    generateData();
}

ScatterDataModifier::~ScatterDataModifier()
{
    delete m_graph;
}

void ScatterDataModifier::generateData()
{
    // Reusing existing array is computationally cheaper than always generating new array, even if
    // all data items change in the array, if the array size doesn't change.
    if (!m_magneticFieldArray)
        m_magneticFieldArray = new QScatterDataArray;

    int arraySize = m_fieldLines * m_arrowsPerLine;
    if (arraySize != m_magneticFieldArray-&gt;size())
        m_magneticFieldArray-&gt;resize(arraySize);

    QScatterDataItem *ptrToDataArray = &amp;m_magneticFieldArray-&gt;first();

    for (float i = 0; i &lt; m_fieldLines; i++) {
        float horizontalAngle = (doublePi * i) / m_fieldLines;
        float xCenter = ellipse_a * qCos(horizontalAngle);
        float zCenter = ellipse_a * qSin(horizontalAngle);

        // Rotate - arrow always tangential to origin
        QQuaternion yRotation = QQuaternion::fromAxisAndAngle(0.0f, 1.0f, 0.0f, horizontalAngle * radiansToDegrees);

        for (float j = 0; j &lt; m_arrowsPerLine; j++) {
            // Calculate point on ellipse centered on origin and parallel to x-axis
            float verticalAngle = ((doublePi * j) / m_arrowsPerLine) + m_angleOffset;
            float xUnrotated = ellipse_a * qCos(verticalAngle);
            float y = ellipse_b * qSin(verticalAngle);

            // Rotate the ellipse around y-axis
            float xRotated = xUnrotated * qCos(horizontalAngle);
            float zRotated = xUnrotated * qSin(horizontalAngle);

            // Add offset
            float x = xCenter + xRotated;
            float z = zCenter + zRotated;

            QQuaternion zRotation = QQuaternion::fromAxisAndAngle(0.0f, 0.0f, 1.0f, verticalAngle * radiansToDegrees);
            QQuaternion totalRotation = yRotation * zRotation;

            ptrToDataArray-&gt;setPosition(QVector3D(x, y, z));
            ptrToDataArray-&gt;setRotation(totalRotation);
            ptrToDataArray++;
        }
    }

    if (m_graph-&gt;selectedSeries() == m_magneticField)
        m_graph-&gt;clearSelection();

    m_magneticField-&gt;dataProxy()-&gt;resetArray(m_magneticFieldArray);
}

void ScatterDataModifier::setFieldLines(int lines)
{
    m_fieldLines = lines;
    generateData();
}

void ScatterDataModifier::setArrowsPerLine(int arrows)
{
    m_angleOffset = 0.0f;
    m_angleStep = doublePi / m_arrowsPerLine / animationFrames;
    m_arrowsPerLine = arrows;
    generateData();
}

void ScatterDataModifier::triggerRotation()
{
    m_angleOffset += m_angleStep;
    generateData();
}

void ScatterDataModifier::toggleSun()
{
    m_sun-&gt;setVisible(!m_sun-&gt;isVisible());
}

void ScatterDataModifier::toggleRotation()
{
    if (m_rotationTimer.isActive())
        m_rotationTimer.stop();
    else
        m_rotationTimer.start(15);
}

</db:programlisting>
</db:article>
