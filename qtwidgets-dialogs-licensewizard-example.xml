<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>License Wizard Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 6.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The License Wizard example shows how to implement complex wizards in Qt.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:alt>Screenshot of the License Wizard example</db:alt>
<db:imageobject>
<db:imagedata fileref="images/licensewizard-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Most wizards have a linear structure, with page 1 followed by page 2 and so on until the last page. The <db:link xlink:href="qtwidgets-dialogs-trivialwizard-example.xml">Trivial Wizard</db:link> example shows how to create such wizards.</db:para>
<db:para>Some wizards are more complex in that they allow different traversal paths based on the information provided by the user. The License Wizard example illustrates this. It provides five wizard pages; depending on which options are selected, the user can reach different pages.</db:para>
<db:mediaobject>
<db:alt>The License Wizard pages</db:alt>
<db:imageobject>
<db:imagedata fileref="images/licensewizard-flow.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The example consists of the following classes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>LicenseWizard inherits <db:link xlink:href="qwizard.xml">QWizard</db:link> and implements a non-linear five-page wizard that leads the user through the process of choosing a license agreement.</db:para>
</db:listitem>
<db:listitem>
<db:para>IntroPage, EvaluatePage, RegisterPage, DetailsPage, and ConclusionPage are <db:link xlink:href="qwizardpage.xml">QWizardPage</db:link> subclasses that implement the wizard pages.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="the-licensewizard-class">
<db:title>The LicenseWizard Class</db:title>
<db:para>The LicenseWizard class derives from <db:link xlink:href="qwizard.xml">QWizard</db:link> and provides a five-page wizard that guides the user through the process of registering their copy of a fictitious software product. Here's the class definition:</db:para>
<db:programlisting language="cpp">class LicenseWizard : public QWizard
{
    Q_OBJECT

public:
    enum { Page_Intro, Page_Evaluate, Page_Register, Page_Details,
           Page_Conclusion };

    LicenseWizard(QWidget *parent = nullptr);

private slots:
    void showHelp();
};
</db:programlisting>
<db:para>The class's public API is limited to a constructor and an enum. The enum defines the IDs associated with the various pages:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Class name</db:para>
</db:th>
<db:th>
<db:para>Enum value</db:para>
</db:th>
<db:th>
<db:para>Page ID</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>IntroPage</db:para>
</db:td>
<db:td>
<db:para>Page_Intro</db:para>
</db:td>
<db:td>
<db:para>0</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>EvaluatePage</db:para>
</db:td>
<db:td>
<db:para>Page_Evaluate</db:para>
</db:td>
<db:td>
<db:para>1</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>RegisterPage</db:para>
</db:td>
<db:td>
<db:para>Page_Register</db:para>
</db:td>
<db:td>
<db:para>2</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>DetailsPage</db:para>
</db:td>
<db:td>
<db:para>Page_Details</db:para>
</db:td>
<db:td>
<db:para>3</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>ConclusionPage</db:para>
</db:td>
<db:td>
<db:para>Page_Conclusion</db:para>
</db:td>
<db:td>
<db:para>4</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>For this example, the IDs are arbitrary. The only constraints are that they must be unique and different from -1. IDs allow us to refer to pages.</db:para>
<db:programlisting language="cpp">LicenseWizard::LicenseWizard(QWidget *parent)
    : QWizard(parent)
{
    setPage(Page_Intro, new IntroPage);
    setPage(Page_Evaluate, new EvaluatePage);
    setPage(Page_Register, new RegisterPage);
    setPage(Page_Details, new DetailsPage);
    setPage(Page_Conclusion, new ConclusionPage);

    setStartId(Page_Intro);
</db:programlisting>
<db:para>In the constructor, we create the five pages, insert them into the wizard using <db:link xlink:href="qwizard.xml#setPage">QWizard::setPage</db:link>(), and set Page_Intro to be the first page.</db:para>
<db:programlisting language="cpp">#ifndef Q_OS_MAC
    setWizardStyle(ModernStyle);
#endif
</db:programlisting>
<db:para>We set the style to <db:link xlink:href="qwizard.xml#WizardStyle-enum">ModernStyle</db:link> on all platforms except macOS,</db:para>
<db:programlisting language="cpp">    setOption(HaveHelpButton, true);
    setPixmap(QWizard::LogoPixmap, QPixmap(&quot;:/images/logo.png&quot;));

    connect(this, &amp;amp;QWizard::helpRequested, this, &amp;amp;LicenseWizard::showHelp);

    setWindowTitle(tr(&quot;License Wizard&quot;));
}
</db:programlisting>
<db:para>We configure the <db:link xlink:href="qwizard.xml">QWizard</db:link> to show a <db:guilabel>Help</db:guilabel> button, which is connected to our showHelp() slot. We also set the <db:link xlink:href="qwizard.xml#WizardPixmap-enum">LogoPixmap</db:link> for all pages that have a header (i.e., EvaluatePage, RegisterPage, and DetailsPage).</db:para>
<db:programlisting language="cpp">void LicenseWizard::showHelp()
{
    static QString lastHelpMessage;

    QString message;

    switch (currentId()) {
    case Page_Intro:
        message = tr(&quot;The decision you make here will affect which page you &quot;
                     &quot;get to see next.&quot;);
        break;
    ...
    default:
        message = tr(&quot;This help is likely not to be of any help.&quot;);
    }

    if (lastHelpMessage == message)
        message = tr(&quot;Sorry, I already gave what help I could. &quot;
                     &quot;Maybe you should try asking a human?&quot;);

    QMessageBox::information(this, tr(&quot;License Wizard Help&quot;), message);

    lastHelpMessage = message;
}
</db:programlisting>
<db:para>In showHelp(), we display help texts that are appropriate for the current page. If the user clicks <db:guilabel>Help</db:guilabel> twice for the same page, we say, &quot;Sorry, I already gave what help I could. Maybe you should try asking a human?&quot;</db:para>
</db:section>
<db:section xml:id="the-intropage-class">
<db:title>The IntroPage Class</db:title>
<db:para>The pages are defined in licensewizard.h and implemented in licensewizard.cpp, together with LicenseWizard.</db:para>
<db:para>Here's the definition and implementation of IntroPage:</db:para>
<db:programlisting language="cpp">class IntroPage : public QWizardPage
{
    Q_OBJECT

public:
    IntroPage(QWidget *parent = nullptr);

    int nextId() const override;

private:
    QLabel *topLabel;
    QRadioButton *registerRadioButton;
    QRadioButton *evaluateRadioButton;
};

IntroPage::IntroPage(QWidget *parent)
    : QWizardPage(parent)
{
    setTitle(tr(&quot;Introduction&quot;));
    setPixmap(QWizard::WatermarkPixmap, QPixmap(&quot;:/images/watermark.png&quot;));

    topLabel = new QLabel(tr(&quot;This wizard will help you register your copy of &quot;
                             &quot;&amp;lt;i&amp;gt;Super Product One&amp;lt;/i&amp;gt;&amp;amp;trade; or start &quot;
                             &quot;evaluating the product.&quot;));
    topLabel-&amp;gt;setWordWrap(true);

    registerRadioButton = new QRadioButton(tr(&quot;&amp;amp;Register your copy&quot;));
    evaluateRadioButton = new QRadioButton(tr(&quot;&amp;amp;Evaluate the product for 30 &quot;
                                              &quot;days&quot;));
    registerRadioButton-&amp;gt;setChecked(true);

    QVBoxLayout *layout = new QVBoxLayout;
    layout-&amp;gt;addWidget(topLabel);
    layout-&amp;gt;addWidget(registerRadioButton);
    layout-&amp;gt;addWidget(evaluateRadioButton);
    setLayout(layout);
}
</db:programlisting>
<db:para>A page inherits from <db:link xlink:href="qwizardpage.xml">QWizardPage</db:link>. We set a <db:link xlink:href="qwizardpage.xml#title-prop">title</db:link> and a <db:link xlink:href="qwizard.xml#WizardPixmap-enum">watermark pixmap</db:link>. By not setting any <db:link xlink:href="qwizardpage.xml#subTitle-prop">subTitle</db:link>, we ensure that no header is displayed for this page. (On Windows, it is customary for wizards to display a watermark pixmap on the first and last pages, and to have a header on the other pages.)</db:para>
<db:programlisting language="cpp">int IntroPage::nextId() const
{
    if (evaluateRadioButton-&amp;gt;isChecked()) {
        return LicenseWizard::Page_Evaluate;
    } else {
        return LicenseWizard::Page_Register;
    }
}
</db:programlisting>
<db:para>The nextId() function returns the ID for EvaluatePage if the <db:guilabel>Evaluate the product for 30 days</db:guilabel> option is checked; otherwise it returns the ID for RegisterPage.</db:para>
</db:section>
<db:section xml:id="the-evaluatepage-class">
<db:title>The EvaluatePage Class</db:title>
<db:para>The EvaluatePage is slightly more involved:</db:para>
<db:programlisting language="cpp">class EvaluatePage : public QWizardPage
{
    Q_OBJECT

public:
    EvaluatePage(QWidget *parent = nullptr);

    int nextId() const override;

private:
    QLabel *nameLabel;
    QLabel *emailLabel;
    QLineEdit *nameLineEdit;
    QLineEdit *emailLineEdit;
};

EvaluatePage::EvaluatePage(QWidget *parent)
    : QWizardPage(parent)
{
    setTitle(tr(&quot;Evaluate &amp;lt;i&amp;gt;Super Product One&amp;lt;/i&amp;gt;&amp;amp;trade;&quot;));
    setSubTitle(tr(&quot;Please fill both fields. Make sure to provide a valid &quot;
                   &quot;email address (e.g., john.smith@example.com).&quot;));

    nameLabel = new QLabel(tr(&quot;N&amp;amp;ame:&quot;));
    nameLineEdit = new QLineEdit;
    ...
    registerField(&quot;evaluate.name*&quot;, nameLineEdit);
    registerField(&quot;evaluate.email*&quot;, emailLineEdit);
    ...
}
</db:programlisting>
<db:para>First, we set the page's <db:link xlink:href="qwizardpage.xml#title-prop">title</db:link> and <db:link xlink:href="qwizardpage.xml#subTitle-prop">subTitle</db:link>.</db:para>
<db:para>Then we create the child widgets, create <db:link xlink:href="qwizard.xml#registering-and-using-fields">wizard fields</db:link> associated with them, and put them into layouts. The fields are created with an asterisk (*) next to their name. This makes them <db:link xlink:href="qwizard.xml#mandatory-fields">mandatory fields</db:link>, that is, fields that must be filled before the user can press the <db:guilabel>Next</db:guilabel> button (<db:guilabel>Continue</db:guilabel> on macOS). The fields' values can be accessed from any other page using <db:link xlink:href="qwizardpage.xml#field">QWizardPage::field</db:link>().</db:para>
<db:para>Resetting the page amounts to clearing the two text fields.</db:para>
<db:programlisting language="cpp">int EvaluatePage::nextId() const
{
    return LicenseWizard::Page_Conclusion;
}
</db:programlisting>
<db:para>The next page is always the ConclusionPage.</db:para>
</db:section>
<db:section xml:id="the-conclusionpage-class">
<db:title>The ConclusionPage Class</db:title>
<db:para>The RegisterPage and DetailsPage are very similar to EvaluatePage. Let's go directly to the ConclusionPage:</db:para>
<db:programlisting language="cpp">class ConclusionPage : public QWizardPage
{
    Q_OBJECT

public:
    ConclusionPage(QWidget *parent = nullptr);

    void initializePage() override;
    int nextId() const override;
    void setVisible(bool visible) override;

private slots:
    void printButtonClicked();

private:
    QLabel *bottomLabel;
    QCheckBox *agreeCheckBox;
};
</db:programlisting>
<db:para>This time, we reimplement <db:link xlink:href="qwizardpage.xml#initializePage">QWizardPage::initializePage</db:link>() and <db:link xlink:href="qwidget.xml#visible-prop">QWidget::setVisible</db:link>(), in addition to <db:link xlink:href="qwizardpage.xml#nextId">nextId</db:link>(). We also declare a private slot: printButtonClicked().</db:para>
<db:programlisting language="cpp">int IntroPage::nextId() const
{
    if (evaluateRadioButton-&amp;gt;isChecked()) {
        return LicenseWizard::Page_Evaluate;
    } else {
        return LicenseWizard::Page_Register;
    }
}
</db:programlisting>
<db:para>The default implementation of <db:link xlink:href="qwizardpage.xml#nextId">QWizardPage::nextId</db:link>() returns the page with the next ID, or -1 if the current page has the highest ID. This behavior would work here, because Page_Conclusion equals 5 and there is no page with a higher ID, but to avoid relying on such subtle behavior, we reimplement <db:link xlink:href="qwizardpage.xml#nextId">nextId</db:link>() to return -1.</db:para>
<db:programlisting language="cpp">void ConclusionPage::initializePage()
{
    QString licenseText;

    if (wizard()-&amp;gt;hasVisitedPage(LicenseWizard::Page_Evaluate)) {
        licenseText = tr(&quot;&amp;lt;u&amp;gt;Evaluation License Agreement:&amp;lt;/u&amp;gt; &quot;
                         &quot;You can use this software for 30 days and make one &quot;
                         &quot;backup, but you are not allowed to distribute it.&quot;);
    } else if (wizard()-&amp;gt;hasVisitedPage(LicenseWizard::Page_Details)) {
        const QString emailAddress = field(&quot;details.email&quot;).toString();
        licenseText = tr(&quot;&amp;lt;u&amp;gt;First-Time License Agreement:&amp;lt;/u&amp;gt; &quot;
                         &quot;You can use this software subject to the license &quot;
                         &quot;you will receive by email sent to %1.&quot;).arg(emailAddress);
    } else {
        licenseText = tr(&quot;&amp;lt;u&amp;gt;Upgrade License Agreement:&amp;lt;/u&amp;gt; &quot;
                         &quot;This software is licensed under the terms of your &quot;
                         &quot;current license.&quot;);
    }
    bottomLabel-&amp;gt;setText(licenseText);
}
</db:programlisting>
<db:para>We use <db:link xlink:href="qwizard.xml#hasVisitedPage">QWizard::hasVisitedPage</db:link>() to determine the type of license agreement the user has chosen. If the user filled the EvaluatePage, the license text refers to an Evaluation License Agreement. If the user filled the DetailsPage, the license text is a First-Time License Agreement. If the user provided an upgrade key and skipped the DetailsPage, the license text is an Update License Agreement.</db:para>
<db:programlisting language="cpp">void ConclusionPage::setVisible(bool visible)
{
    QWizardPage::setVisible(visible);

    if (visible) {
        wizard()-&amp;gt;setButtonText(QWizard::CustomButton1, tr(&quot;&amp;amp;Print&quot;));
        wizard()-&amp;gt;setOption(QWizard::HaveCustomButton1, true);
        connect(wizard(), &amp;amp;QWizard::customButtonClicked,
                this, &amp;amp;ConclusionPage::printButtonClicked);
    } else {
        wizard()-&amp;gt;setOption(QWizard::HaveCustomButton1, false);
        disconnect(wizard(), &amp;amp;QWizard::customButtonClicked,
                   this, &amp;amp;ConclusionPage::printButtonClicked);
    }
}
</db:programlisting>
<db:para>We want to display a <db:guilabel>Print</db:guilabel> button in the wizard when the ConclusionPage is up. One way to accomplish this is to reimplement <db:link xlink:href="qwidget.xml#visible-prop">QWidget::setVisible</db:link>():</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If the page is shown, we set the <db:link xlink:href="qwizard.xml#WizardButton-enum">CustomButton1</db:link> button's text to <db:guilabel><db:emphasis role="underline">P</db:emphasis>rint</db:guilabel>, we enable the <db:link xlink:href="qwizard.xml#WizardOption-enum">HaveCustomButton1</db:link> option, and we connect the <db:link xlink:href="qwizard.xml">QWizard</db:link>'s <db:link xlink:href="qwizard.xml#customButtonClicked">customButtonClicked</db:link>() signal to our printButtonClicked() slot.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the page is hidden, we disable the <db:link xlink:href="qwizard.xml#WizardOption-enum">HaveCustomButton1</db:link> option and disconnect the printButtonClicked() slot.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/dialogs/licensewizard?h=6.6">Example project @ code.qt.io</db:link></db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwizard.xml">QWizard</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-dialogs-trivialwizard-example.xml">Trivial Wizard Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
