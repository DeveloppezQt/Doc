<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>qt_add_protobuf</db:title>
<db:productname>QtProtobuf</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Protobuf Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Generates Qt-based C++ source code using a protobuf schema.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:anchor xml:id="qt6-add-protobuf"/>
<db:para>Generates Qt-based C++ source code using a protobuf schema</db:para>
<db:note>
<db:para>This command is in technology preview and may change in future releases.</db:para>
</db:note>
<db:para>This command was introduced in Qt 6.5.</db:para>
<db:para>Usually <db:code>qtprotobufgen</db:code> would be invoked through CMake using the <db:code>qt_add_protobuf</db:code> macro.</db:para>
<db:programlisting language="cpp" role="bad">qt_add_protobuf(&amp;lt;target&amp;gt;
    PROTO_FILES &amp;lt;file&amp;gt; ...
    [COPY_COMMENTS]
    [GENERATE_PACKAGE_SUBFOLDERS]
    [EXTRA_NAMESPACE &amp;lt;namespace&amp;gt;]
    [EXPORT_MACRO &amp;lt;infix&amp;gt;]
    [PROTO_INCLUDES &amp;lt;path&amp;gt; ...]
    [OUTPUT_DIRECTORY &amp;lt;dir&amp;gt;]
    [OUTPUT_HEADERS &amp;lt;var&amp;gt;]
    [OUTPUT_TARGETS &amp;lt;var&amp;gt;]
)
</db:programlisting>
<db:para>The source files generated by <db:code>qtprotobufgen</db:code> are then added to the target. If the target already exists, the files are <db:emphasis>added</db:emphasis> to the target source list. If the target doesn't exist, it is created as a library which you must link to.</db:para>
<db:section xml:id="arguments">
<db:title>Arguments</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>COPY_COMMENTS</db:code> Copies comments from <db:code>.proto</db:code> files. If provided in the parameter list, comments related to messages and fields are copied to generated header files.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>GENERATE_PACKAGE_SUBFOLDERS</db:code> generates a folder structure for the generated files matching the <db:code>.proto</db:code> file's package name. For example <db:code>package io.qt.test;</db:code> would put the generated files into <db:code>io/qt/test/</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>EXTRA_NAMESPACE</db:code> is an optional namespace that will be used for the generated classes. The classes are always generated in a namespace whose name is the same as the package name specified in the <db:code>.proto</db:code> file. If this option is used then everything will be nested inside the extra namespace.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>EXPORT_MACRO</db:code> is the base name of the symbol export macro used for the generated code. The generated macro name is constructed as <db:code>QPB_&lt;EXPORT_MACRO&gt;_EXPORT</db:code>. If the option is not set, the macro is not generated.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>PROTO_FILES</db:code> is the list of <db:code>.proto</db:code> files that will be used in the generation procedure.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>PROTO_INCLUDES</db:code> is the list of directories that will be searched for dependencies.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>OUTPUT_DIRECTORY</db:code> is the directory where the generated files will be put. By default, the current directory (while evaluating the function) is used.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>OUTPUT_HEADERS</db:code> can be used to specify a variable that will hold the list of headers created by the function. This list can be useful for custom project install rules.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>OUTPUT_TARGETS</db:code> can be used to specify a variable that will hold the list of targets created by the function. This list can be useful for custom project install rules.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="resolving-dependencies-between-protobuf-targets">
<db:title>Resolving dependencies between protobuf targets</db:title>
<db:para>The <db:code>qt_add_protobuf</db:code> command doesn't consider the dependencies between <db:code>.proto</db:code> files that are used to generate code for different targets.</db:para>
<db:para>The project may have two or more <db:code>.proto</db:code> files with dependencies:</db:para>
<db:programlisting language="cpp" role="bad">syntax = &quot;proto3&quot;;

package test.messages;

message MyMessage {
    int32 myField = 1;
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">syntax = &quot;proto3&quot;;

import &quot;test_messages.proto&quot;;

package test.extensions;

message MyExtension {
    test.messages.MyMessage baseMessage = 1;
    int32 extension = 2;
}
</db:programlisting>
<db:para>The above <db:code>.proto</db:code> files can be used to generate the standalone libraries:</db:para>
<db:programlisting language="cpp" role="bad">qt_add_protobuf(test_messages
    PROTO_FILES
        test_messages.proto
)
...
qt_add_protobuf(test_extensions
    PROTO_FILES
        test_extensions.proto
)
...
</db:programlisting>
<db:para>Since the <db:code>test_extensions</db:code> target depends on messages from the <db:code>test_messages</db:code> target, users need to link to such targets manually in their <db:code>CMake</db:code> scripts:</db:para>
<db:programlisting language="cpp" role="bad">target_link_libraries(test_extensions PUBLIC test_messages)
</db:programlisting>
<db:note>
<db:para>It's recommended to use the <db:code>PUBLIC</db:code> linking scope, since messages from <db:code>test_messages</db:code> target are referenced in header files that belong to the <db:code>test_extensions</db:code> target, so targets that link to <db:code>test_extensions</db:code> should have the <db:code>test_messages</db:code> target as a transitive dependency.</db:para>
</db:note>
</db:section>
<db:section xml:id="example">
<db:title>Example</db:title>
<db:programlisting language="cpp" role="bad">cmake_minimum_required(VERSION 3.16...3.22)
project(MyThings)

find_package(Qt6 REQUIRED COMPONENTS Protobuf)
qt_standard_project_setup()

qt_add_protobuf(MyMessages
    GENERATE_PACKAGE_SUBFOLDERS
    PROTO_FILES
        path/to/message.proto
        path/to/other_message.proto
    PROTO_INCLUDES
        /path/to/proto/include
)

qt_add_executable(MyApp main.cpp)

target_link_libraries(MyApp PRIVATE MyMessages)
</db:programlisting>
<db:para>In the example above we generate a library called <db:code>MyMessages</db:code> which contains the message types defined in the paths passed to the <db:code>PROTO_FILES</db:code> option. We use the <db:code>GENERATE_PACKAGE_SUBFOLDERS</db:code> option to generate a folder structure for the generated files. And the <db:code>PROTO_INCLUDES</db:code> option tells protoc to look for dependencies/imports in the specified directories.</db:para>
<db:para>We then create a target for an executable called <db:code>MyApp</db:code> which we link to the <db:code>MyMessages</db:code> library.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtprotobufgen-qt-tool.xml">The qtprotobufgen Tool</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
