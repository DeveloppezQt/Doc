<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>qt_add_protobuf</db:title>
<db:productname>QtProtobuf</db:productname>
<db:edition>Qt 6.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Protobuf Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Generates Qt-based C++ source code using a protobuf schema.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:anchor xml:id="qt6-add-protobuf"/>
<db:para>Generates Qt-based C++ source code using a protobuf schema</db:para>
<db:note>
<db:para>This command is in technology preview and may change in future releases.</db:para>
</db:note>
<db:para>This command was introduced in Qt 6.5.</db:para>
<db:para>Usually <db:code>qtprotobufgen</db:code> would be invoked through CMake using the <db:code>qt_add_protobuf</db:code> command.</db:para>
<db:programlisting language="cpp" role="bad">qt_add_protobuf(&amp;lt;target&amp;gt;
    PROTO_FILES &amp;lt;file&amp;gt; ...
    [COPY_COMMENTS]
    [GENERATE_PACKAGE_SUBFOLDERS]
    [EXTRA_NAMESPACE &amp;lt;namespace&amp;gt;]
    [EXPORT_MACRO &amp;lt;infix&amp;gt;]
    [QML [QML_URI &amp;lt;uri&amp;gt;]]
    [PROTO_INCLUDES &amp;lt;path&amp;gt; ...]
    [OUTPUT_DIRECTORY &amp;lt;dir&amp;gt;]
    [OUTPUT_HEADERS &amp;lt;var&amp;gt;]
    [OUTPUT_TARGETS &amp;lt;var&amp;gt;]
)
</db:programlisting>
<db:para>The source files generated by <db:code>qtprotobufgen</db:code> are then added to the target. If the target already exists, the files are <db:emphasis>added</db:emphasis> to the target source list. If the target doesn't exist, it is created as a library which you must link to.</db:para>
<db:section xml:id="arguments">
<db:title>Arguments</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>COPY_COMMENTS</db:code> copies comments from <db:code>.proto</db:code> files. If provided in the parameter list, comments related to messages and fields are copied to generated header files.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>GENERATE_PACKAGE_SUBFOLDERS</db:code> generates a folder structure for the generated files matching the <db:code>.proto</db:code> file's package name. For example, <db:code>package io.qt.test;</db:code> would put the generated files into <db:code>io/qt/test/</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>EXTRA_NAMESPACE</db:code> is an optional namespace that will be used for the generated classes. The classes are always generated in a namespace whose name is the same as the package name specified in the <db:code>.proto</db:code> file. If this option is used, then everything will be nested inside the extra namespace.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>EXPORT_MACRO</db:code> is the base name of the symbol export macro used for the generated code. The generated macro name is constructed as <db:code>QPB_&lt;EXPORT_MACRO&gt;_EXPORT</db:code>. If the option is not set, the macro is not generated.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>QML</db:code> enables <db:link xlink:href="qprotobufmessage.xml">QProtobufMessage</db:link> types in QML context by registering them as a QML module. Protobuf types can extend an existing QML module. See code examples:</db:para>
<db:programlisting language="cpp" role="bad">qt_add_qml_module(targetname
    ...
)

qt_add_protobuf(targetname
    QML
    ...
)
</db:programlisting>
<db:programlisting language="cpp" role="bad">qt_add_executable(targetname
    ...
)

qt_add_protobuf(targetname
    QML
    ...
)
</db:programlisting>
<db:para>If <db:code>qt_add_protobuf</db:code> is called with a non-existing target or the target is not a QML module, a new QML module will be created implicitly. In case of the new QML module creation, the <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> command is called inside the <db:code>qt_add_protobuf</db:code> command. See code example:</db:para>
<db:programlisting language="cpp" role="bad">qt_add_executable(targetname
    ...
)

qt_add_protobuf(targetplugin
    QML
    QML_URI proto.uri.example
)
</db:programlisting>
<db:para>Every QML module has to define a <db:code>URI</db:code> name. Other QML modules may use this name in <db:link xlink:href="qtqml-syntax-imports.xml">import statements</db:link> to import the module into a user application. Use the <db:code>QML_URI</db:code> option to set the <db:code>URI</db:code> name. It has to be specified in dotted notation, e.g. <db:code>Qt.Protobuf.Package</db:code>. If <db:code>QML_URI</db:code> is omitted, then the protobuf package name will be used as the module <db:code>URI</db:code>.</db:para>
<db:note>
<db:para>If <db:code>QML_URI</db:code> is passed to <db:code>qt_add_protobuf</db:code> command but <db:code>target</db:code> already exists, <db:code>QML_URI</db:code> argument will be ignored.</db:para>
</db:note>
<db:note>
<db:para>If the <db:code>QML_URI</db:code> is skipped, all *.proto files specified in the <db:code>qt_add_protobuf</db:code> command should have the same <db:code>protobuf</db:code> package name, since it shall be used as a default <db:code>URI</db:code> for the resulting QML module.</db:para>
</db:note>
<db:note>
<db:para>You should avoid creating several QML modules with the same <db:code>QML_URI</db:code> or proto package name, because it leads to import error in QML context.</db:para>
</db:note>
</db:listitem>
<db:listitem>
<db:para><db:code>QML_URI</db:code> enables <db:link xlink:href="qprotobufmessage.xml">QProtobufMessage</db:link> types in the QML context by registering them in a QML module via the provided <db:code>URI</db:code> import path. The <db:code>URI</db:code> option will be used in the line of the generated <db:code>qmldir</db:code> file, and also used to form the target path by replacing dots with forward slashes.</db:para>
<db:note>
<db:para>Read <db:link xlink:href="qtqml-modules-identifiedmodules.xml">Identified Modules</db:link> for further in-depth discussion of the <db:code>URI</db:code>.</db:para>
</db:note>
</db:listitem>
<db:listitem>
<db:para><db:code>PROTO_FILES</db:code> is the list of <db:code>.proto</db:code> files that will be used in the generation procedure.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>PROTO_INCLUDES</db:code> is the list of directories that will be searched for dependencies.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>OUTPUT_DIRECTORY</db:code> is the directory where the generated files will be put. By default, the current directory (while evaluating the function) is used.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>OUTPUT_HEADERS</db:code> can be used to specify a variable that will hold the list of headers created by the function. This list can be useful for custom project install rules.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>OUTPUT_TARGETS</db:code> can be used to specify a variable that will hold the list of targets created by the function. This list can be useful for custom project install rules.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="resolving-dependencies-between-protobuf-targets">
<db:title>Resolving dependencies between protobuf targets</db:title>
<db:para>The <db:code>qt_add_protobuf</db:code> command doesn't consider the dependencies between <db:code>.proto</db:code> files that are used to generate code for different targets.</db:para>
<db:para>The project may have two or more <db:code>.proto</db:code> files with dependencies:</db:para>
<db:programlisting language="cpp" role="bad">syntax = &quot;proto3&quot;;

package test.messages;

message MyMessage {
    int32 myField = 1;
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">syntax = &quot;proto3&quot;;

import &quot;test_messages.proto&quot;;

package test.extensions;

message MyExtension {
    test.messages.MyMessage baseMessage = 1;
    int32 extension = 2;
}
</db:programlisting>
<db:para>The above <db:code>.proto</db:code> files can be used to generate the standalone libraries:</db:para>
<db:programlisting language="cpp" role="bad">qt_add_protobuf(test_messages
    PROTO_FILES
        test_messages.proto
)
...
qt_add_protobuf(test_extensions
    PROTO_FILES
        test_extensions.proto
)
...
</db:programlisting>
<db:para>Since the <db:code>test_extensions</db:code> target depends on messages from the <db:code>test_messages</db:code> target, users need to link to such targets manually in their <db:code>CMake</db:code> scripts:</db:para>
<db:programlisting language="cpp" role="bad">target_link_libraries(test_extensions PUBLIC test_messages)
</db:programlisting>
<db:note>
<db:para>It's recommended to use the <db:code>PUBLIC</db:code> linking scope, since messages from <db:code>test_messages</db:code> target are referenced in header files that belong to the <db:code>test_extensions</db:code> target, so targets that link to <db:code>test_extensions</db:code> should have the <db:code>test_messages</db:code> target as a transitive dependency.</db:para>
</db:note>
</db:section>
<db:section xml:id="example">
<db:title>Example</db:title>
<db:section xml:id="using-qt-add-protobuf">
<db:title>Using qt_add_protobuf</db:title>
<db:programlisting language="cpp" role="bad">cmake_minimum_required(VERSION 3.16...3.22)
project(MyThings)

find_package(Qt6 REQUIRED COMPONENTS Protobuf)
qt_standard_project_setup()

qt_add_protobuf(MyMessages
    GENERATE_PACKAGE_SUBFOLDERS
    PROTO_FILES
        path/to/message.proto
        path/to/other_message.proto
    PROTO_INCLUDES
        /path/to/proto/include
)

qt_add_executable(MyApp main.cpp)

target_link_libraries(MyApp PRIVATE MyMessages)
</db:programlisting>
<db:para>In the example above, we generate a library called <db:code>MyMessages</db:code>, which contains the message types defined in the paths passed to the <db:code>PROTO_FILES</db:code> option. The <db:code>GENERATE_PACKAGE_SUBFOLDERS</db:code> option to generate a folder structure for the generated files. And the <db:code>PROTO_INCLUDES</db:code> option tells protoc to look for dependencies or imports in the specified directories. We create a target for an executable called <db:code>MyApp</db:code>, which we link to the <db:code>MyMessages</db:code> library.</db:para>
</db:section>
<db:section xml:id="qml-extended-protobuf-example">
<db:title>QML extended protobuf example</db:title>
<db:programlisting language="cpp" role="bad">cmake_minimum_required(VERSION 3.16...3.22)
project(MyThings)

find_package(Qt6 REQUIRED COMPONENTS Protobuf Quick)
qt_standard_project_setup()

qt_add_protobuf(MyMessagesPlugin
    QML
    QML_URI my.messages.module.uri
    PROTO_FILES
        path/to/message.proto
        path/to/other_message.proto
    PROTO_INCLUDES
        /path/to/proto/include
)

qt_add_protobuf(MyApp
    QML
    PROTO_FILES
        path/to/internal_message.proto
    PROTO_INCLUDES
        /path/to/proto/include
)

qt_add_qml_module(MyApp
    URI example.uri
    VERSION 1.0
    QML_FILES qml/main.qml
)

qt_add_executable(MyApp main.cpp)
target_link_libraries(MyApp PRIVATE Quick)
</db:programlisting>
<db:para>In the QML extended example above, by the first <db:code>qt_add_protobuf</db:code> call, we generate a QML module called <db:code>MyMessagesPlugin</db:code>, which contains the message types defined in the paths passed to the <db:code>PROTO_FILES</db:code> option. We use the <db:code>QML</db:code> option, that enables proto message types registration in the <db:code>QML</db:code> context. The registered types will be available in <db:code>QML</db:code> by importing a path that is set by the <db:code>QML_URI</db:code>. By second <db:code>qt_add_protobuf</db:code> call we add auto-generated code into the existing <db:code>MyApp</db:code> QML module. The <db:code>QML_URI</db:code> is not required in such cases. Finally, we create a target for an executable called <db:code>MyApp</db:code>, which has a QML module for the graphical part and loads <db:code>MyMessagesPlugin</db:code> into the main.qml file via the <db:code>my.messages.module.uri</db:code> import.</db:para>
</db:section>
<db:section xml:id="installing-standalone-qt-protobuf-library">
<db:title>Installing standalone Qt Protobuf library</db:title>
<db:para>The <db:link xlink:href="qt-add-protobuf.xml">qt_add_protobuf</db:link> command also produces lists of artifacts for further installation. You can read these artifacts by specifying <db:code>OUTPUT_HEADERS</db:code>, and <db:code>OUTPUT_TARGETS</db:code> arguments as follows:</db:para>
<db:programlisting language="cpp" role="bad">qt_add_protobuf(MyProtoLib
    PROTO_FILES
        mylib.proto
    OUTPUT_HEADERS
        public_headers
    OUTPUT_TARGETS
        generated_targets
)
</db:programlisting>
<db:para>The command stores the list of the header files and targets produced by the <db:code>qt_add_protobuf</db:code> command to the <db:code>public_headers</db:code> and <db:code>generated_targets</db:code> variables accordingly.</db:para>
<db:para>Use the standard CMake <db:code>install</db:code> command to install the artifacts and generate the <db:code>config</db:code> files for your library:</db:para>
<db:programlisting language="cpp" role="bad">include(GNUInstallDirs)
set_target_properties(MyProtoLib PROPERTIES
    PUBLIC_HEADER
        &quot;${public_headers}&quot;
    INTERFACE_INCLUDE_DIRECTORIES
        &quot;$&amp;lt;INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR}&amp;gt;&quot;
)
install(TARGETS ${generated_targets} EXPORT MyProtoLibTargets
    PUBLIC_HEADER
        DESTINATION &quot;${CMAKE_INSTALL_INCLUDEDIR}&quot;
)
install(EXPORT MyProtoLibTargets NAMESPACE MyProtoLib:: DESTINATION lib/cmake/MyProtoLib)
</db:programlisting>
<db:para>Then use the generated <db:code>MyProtoLibTargets</db:code> config in the package config file. You can read more about the package creation process in the official <db:link xlink:href="https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-packages">CMake documentation</db:link>.</db:para>
<db:para>After installation the library is available as the standalone CMake package:</db:para>
<db:programlisting language="cpp" role="bad">find_package(Qt6 COMPONENTS Protobuf)
find_package(MyProtoLib CONFIG)

add_executable(MyApp main.cpp)
target_link_libraries(MyApp PRIVATE MyProtoLib::MyProtoLib Qt6::Protobuf)
</db:programlisting>
<db:note>
<db:para>qt_add_protobuf doesn't implicitly add <db:code>Qt Protobuf</db:code> module as the transitive dependency, neither for the <db:code>MyProtoLib</db:code> target nor for the <db:code>MyProtoLib</db:code> CMake package. Therefore, the <db:code>Qt Protobuf</db:code> module lookup and the explicit linking of <db:code>MyApp</db:code> to <db:code>Qt6::Protobuf</db:code> are mandatory.</db:para>
</db:note>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtprotobufgen-qt-tool.xml">The qtprotobufgen Tool</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
