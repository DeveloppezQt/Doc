<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QQuickRhiItemRenderer Class</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link> implements the rendering logic of a <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link>.</db:para>
<db:para><db:emphasis role="bold">This class is under development and is subject to change.</db:emphasis></db:para>
<db:para>This class was introduced in Qt 6.7.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QQuickRhiItemRenderer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.7</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Quick)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Quick)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += quick</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Status</db:term>
<db:listitem>
<db:para>Preliminary</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:para><db:emphasis role="bold">This class is under development and is subject to change.</db:emphasis></db:para>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:note>
<db:para><db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> and <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link> are in tech preview in Qt 6.7. <db:emphasis role="bold">The API is under development and subject to change.</db:emphasis></db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link></db:member>
<db:member><db:link xlink:href="qrhi.xml">QRhi</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QQuickRhiItemRenderer">
<db:title>QQuickRhiItemRenderer::QQuickRhiItemRenderer()</db:title>
<db:para>Constructs a new renderer.</db:para>
<db:para>This function is called on the rendering thread during the scene graph sync phase when the GUI thread is blocked.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitem.xml#createRenderer">QQuickRhiItem::createRenderer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QQuickRhiItemRenderer">
<db:title>[virtual noexcept] QQuickRhiItemRenderer::~QQuickRhiItemRenderer()</db:title>
<db:para>The Renderer is automatically deleted when the scene graph resources for the <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> item are cleaned up.</db:para>
<db:para>This function is called on the rendering thread.</db:para>
<db:para>Under certain conditions it is normal and expected that the renderer object is destroyed and then recreated. This is because the renderer's lifetime effectively follows the underlying scene graph node. For example, when changing the parent of a <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> object so that it then belongs to a different <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>, the scene graph nodes are all dropped and recreated due to the window change. This will also involve dropping and creating a new <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link>.</db:para>
<db:para>Unlike <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>, <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link> has no need to implement additional code paths for releasing (or early-relasing) graphics resources created via <db:link xlink:href="qrhi.xml">QRhi</db:link>. It is sufficient to release everything in the destructor, or rely on smart pointers.</db:para>
</db:section>
<db:section xml:id="colorTexture">
<db:title>[protected] QRhiTexture *QQuickRhiItemRenderer::colorTexture() const</db:title>
<db:para>Returns the texture serving as the color buffer for the item.</db:para>
<db:para>Must only be called from <db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>() and <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>().</db:para>
<db:para>Unlike the depth-stencil buffer and the <db:link xlink:href="qrhirendertarget.xml">QRhiRenderTarget</db:link>, this texture is always available and is managed by the <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link>, independent of the value of <db:link xlink:href="qquickrhiitem.xml#isAutoRenderTargetEnabled">isAutoRenderTargetEnabled</db:link>.</db:para>
<db:note>
<db:para>When <db:link xlink:href="qquickrhiitem.xml#sampleCount-prop">sampleCount</db:link> is larger than 1, and so multisample antialiasing is enabled, the return value is <db:code>nullptr</db:code>. Instead, query the <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> by calling <db:link xlink:href="qquickrhiitemrenderer.xml#msaaColorBuffer">msaaColorBuffer</db:link>().</db:para>
</db:note>
<db:note>
<db:para>The backing texture size and sample count can also be queried via the <db:link xlink:href="qrhirendertarget.xml">QRhiRenderTarget</db:link> returned from <db:link xlink:href="qquickrhiitemrenderer.xml#renderTarget">renderTarget</db:link>(). This can be more convenient and compact than querying from the <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> or <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link>, because it works regardless of multisampling is in use or not.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#msaaColorBuffer">msaaColorBuffer</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#depthStencilBuffer">depthStencilBuffer</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#renderTarget">renderTarget</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#resolveTexture">resolveTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="depthStencilBuffer">
<db:title>[protected] QRhiRenderBuffer *QQuickRhiItemRenderer::depthStencilBuffer() const</db:title>
<db:para>Returns the depth-stencil buffer used by the item's rendering.</db:para>
<db:para>Must only be called from <db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>() and <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>().</db:para>
<db:para>Available only when <db:link xlink:href="qquickrhiitem.xml#isAutoRenderTargetEnabled">isAutoRenderTargetEnabled</db:link> is <db:code>true</db:code>. Otherwise the returned value is <db:code>nullptr</db:code> and it is up the reimplementation of <db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>() to create and manage a depth-stencil buffer and a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#colorTexture">colorTexture</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#renderTarget">renderTarget</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="initialize">
<db:title>[pure virtual protected] void QQuickRhiItemRenderer::initialize(QRhiCommandBuffer *<db:emphasis>cb</db:emphasis>)</db:title>
<db:para>Called when the item is initialized for the first time, when the associated texture's size, format, or sample count changes, or when the <db:link xlink:href="qrhi.xml">QRhi</db:link> or texture change for any reason. The function is expected to maintain (create if not yet created, adjust and rebuild if the size has changed) the graphics resources used by the rendering code in <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>().</db:para>
<db:para>To query the <db:link xlink:href="qrhi.xml">QRhi</db:link>, <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>, and other related objects, call <db:link xlink:href="qquickrhiitemrenderer.xml#rhi">rhi</db:link>(), <db:link xlink:href="qquickrhiitemrenderer.xml#colorTexture">colorTexture</db:link>(), <db:link xlink:href="qquickrhiitemrenderer.xml#depthStencilBuffer">depthStencilBuffer</db:link>(), and <db:link xlink:href="qquickrhiitemrenderer.xml#renderTarget">renderTarget</db:link>().</db:para>
<db:para>When the item size changes, the <db:link xlink:href="qrhi.xml">QRhi</db:link> object, the color buffer texture, and the depth stencil buffer objects are all the same instances (so the getters return the same pointers) as before, but the color and depth/stencil buffers will likely have been rebuilt, meaning the size and the underlying native texture resource may be different than in the last invocation.</db:para>
<db:para>Reimplementations should also be prepared that the <db:link xlink:href="qrhi.xml">QRhi</db:link> object and the color buffer texture may change between invocations of this function. For example, when the item is reparented so that it belongs to a new <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>, the the <db:link xlink:href="qrhi.xml">QRhi</db:link> and all related resources managed by the <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> will be different instances than before in the subsequent call to this function. Is is then important that all existing <db:link xlink:href="qrhi.xml">QRhi</db:link> resources previously created by the subclass are destroyed because they belong to the previous <db:link xlink:href="qrhi.xml">QRhi</db:link> that should not be used anymore.</db:para>
<db:para>When <db:link xlink:href="qquickrhiitem.xml#isAutoRenderTargetEnabled">isAutoRenderTargetEnabled</db:link> is <db:code>true</db:code>, which is the default, a depth-stencil <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> and a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> associated with the <db:link xlink:href="qquickrhiitemrenderer.xml#colorTexture">colorTexture</db:link>() (or <db:link xlink:href="qquickrhiitemrenderer.xml#msaaColorBuffer">msaaColorBuffer</db:link>()) and the depth-stencil buffer are created and managed automatically. Reimplementations of initialize() and <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>() can query those objects via <db:link xlink:href="qquickrhiitemrenderer.xml#depthStencilBuffer">depthStencilBuffer</db:link>() and <db:link xlink:href="qquickrhiitemrenderer.xml#renderTarget">renderTarget</db:link>(). When <db:link xlink:href="qquickrhiitem.xml#isAutoRenderTargetEnabled">isAutoRenderTargetEnabled</db:link> is set to <db:code>false</db:code>, these objects are no longer created and managed automatically. Rather, it will be up the the initialize() implementation to create buffers and set up the render target as it sees fit. When manually managing additional color or depth-stencil attachments for the render target, their size and sample count must always follow the size and sample count of <db:link xlink:href="qquickrhiitemrenderer.xml#colorTexture">colorTexture</db:link>() (or <db:link xlink:href="qquickrhiitemrenderer.xml#msaaColorBuffer">msaaColorBuffer</db:link>()), otherwise rendering or 3D API validation errors may occur.</db:para>
<db:para>The subclass-created graphics resources are expected to be released in the destructor implementation of the subclass.</db:para>
<db:para><db:code role="parameter">cb</db:code> is the <db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link> for the current frame. The function is called with a frame being recorded, but without an active render pass. The command buffer is provided primarily to allow enqueuing <db:link xlink:href="qrhicommandbuffer.xml#resourceUpdate">resource updates</db:link> without deferring to <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>().</db:para>
<db:para>This function is called on the render thread, if there is one.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="msaaColorBuffer">
<db:title>[protected] QRhiRenderBuffer *QQuickRhiItemRenderer::msaaColorBuffer() const</db:title>
<db:para>Returns the renderbuffer serving as the multisample color buffer for the item.</db:para>
<db:para>Must only be called from <db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>() and <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>().</db:para>
<db:para>When <db:link xlink:href="qquickrhiitem.xml#sampleCount-prop">sampleCount</db:link> is larger than 1, and so multisample antialising is enabled, the returned <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> has a matching sample count and serves as the color buffer. Graphics pipelines used to render into this buffer must be created with the same sample count, and the depth-stencil buffer's sample count must match as well. The multisample content is expected to be resolved into the texture returned from <db:link xlink:href="qquickrhiitemrenderer.xml#resolveTexture">resolveTexture</db:link>(). When <db:link xlink:href="qquickrhiitem.xml#isAutoRenderTargetEnabled">isAutoRenderTargetEnabled</db:link> is <db:code>true</db:code>, <db:link xlink:href="qquickrhiitemrenderer.xml#renderTarget">renderTarget</db:link>() is set up automatically to do this, by setting up msaaColorBuffer() as the renderbuffer of color attachment 0 and <db:link xlink:href="qquickrhiitemrenderer.xml#resolveTexture">resolveTexture</db:link>() as its resolveTexture.</db:para>
<db:para>When MSAA is not in use, the return value is <db:code>nullptr</db:code>. Use <db:link xlink:href="qquickrhiitemrenderer.xml#colorTexture">colorTexture</db:link>() instead then.</db:para>
<db:para>Depending on the underlying 3D graphics API, there may be no practical difference between multisample textures and color renderbuffers with a sample count larger than 1 (<db:link xlink:href="qrhi.xml">QRhi</db:link> may just map both to the same native resource type). Some older APIs however may differentiate between textures and renderbuffers. In order to support OpenGL ES 3.0, where multisample renderbuffers are available, but multisample textures are not, <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> always performs MSAA by using a multisample <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> as the color attachment (and never a multisample <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>).</db:para>
<db:note>
<db:para>The backing texture size and sample count can also be queried via the <db:link xlink:href="qrhirendertarget.xml">QRhiRenderTarget</db:link> returned from <db:link xlink:href="qquickrhiitemrenderer.xml#renderTarget">renderTarget</db:link>(). This can be more convenient and compact than querying from the <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> or <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link>, because it works regardless of multisampling is in use or not.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#colorTexture">colorTexture</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#depthStencilBuffer">depthStencilBuffer</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#renderTarget">renderTarget</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#resolveTexture">resolveTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="render">
<db:title>[pure virtual protected] void QQuickRhiItemRenderer::render(QRhiCommandBuffer *<db:emphasis>cb</db:emphasis>)</db:title>
<db:para>Called when the backing color buffer's contents needs updating.</db:para>
<db:para>There is always at least one call to <db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>() before this function is called.</db:para>
<db:para>To request updates, call <db:link xlink:href="qquickitem.xml#update">QQuickItem::update</db:link>() when calling from QML or from C++ code on the main/GUI thread (e.g. when in a property setter), or <db:link xlink:href="qquickrhiitemrenderer.xml#update">update</db:link>() when calling from within a <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link> callback. Calling <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link>'s <db:link xlink:href="qquickrhiitemrenderer.xml#update">update</db:link>() from within render() will lead to triggering updates continuously.</db:para>
<db:para><db:code role="parameter">cb</db:code> is the <db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link> for the current frame. The function is called with a frame being recorded, but without an active render pass.</db:para>
<db:para>This function is called on the render thread, if there is one.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#synchronize">synchronize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="renderTarget">
<db:title>[protected] QRhiRenderTarget *QQuickRhiItemRenderer::renderTarget() const</db:title>
<db:para>Returns the render target object that must be used with <db:link xlink:href="qrhicommandbuffer.xml#beginPass">QRhiCommandBuffer::beginPass</db:link>() in reimplementations of <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>().</db:para>
<db:para>Must only be called from <db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>() and <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>().</db:para>
<db:para>Available only when <db:link xlink:href="qquickrhiitem.xml#isAutoRenderTargetEnabled">isAutoRenderTargetEnabled</db:link> is <db:code>true</db:code>. Otherwise the returned value is <db:code>nullptr</db:code> and it is up the reimplementation of <db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>() to create and manage a depth-stencil buffer and a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link>.</db:para>
<db:para>When creating <db:link xlink:href="qrhigraphicspipeline.xml">graphics pipelines</db:link>, a <db:link xlink:href="qrhirenderpassdescriptor.xml">QRhiRenderPassDescriptor</db:link> is needed. This can be queried from the returned <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> by calling <db:link xlink:href="">renderPassDescriptor()</db:link>.</db:para>
<db:note>
<db:para>The returned <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> always reports a <db:link xlink:href="">devicePixelRatio()</db:link> of <db:code>1</db:code>. This is because only swapchains and the associated window have a concept of device pixel ratio, not textures, and the render target here always refers to a texture. If the on-screen scale factor is relevant for rendering, query and store it via the item's <db:code>window()-&gt;effectiveDevicePixelRatio()</db:code> in <db:link xlink:href="qquickrhiitemrenderer.xml#synchronize">synchronize</db:link>(). When doing so, always prefer using <db:link xlink:href="qquickwindow.xml#effectiveDevicePixelRatio">effectiveDevicePixelRatio</db:link>() over the base class' <db:link xlink:href="qwindow.xml#devicePixelRatio">devicePixelRatio</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#colorTexture">colorTexture</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#depthStencilBuffer">depthStencilBuffer</db:link>()</db:member>
<db:member><db:link xlink:href="qquickwindow.xml#effectiveDevicePixelRatio">QQuickWindow::effectiveDevicePixelRatio</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resolveTexture">
<db:title>[protected] QRhiTexture *QQuickRhiItemRenderer::resolveTexture() const</db:title>
<db:para>Returns the non-multisample texture to which the multisample content is resolved.</db:para>
<db:para>The result is <db:code>nullptr</db:code> when multisample antialiasing is not enabled.</db:para>
<db:para>Must only be called from <db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>() and <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>().</db:para>
<db:para>With MSAA enabled, this is the texture that gets used by the item's underlying scene graph node when texturing a quad in the main render pass of Qt Quick. However, the <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link>'s rendering must target the (multisample) <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> returned from <db:link xlink:href="qquickrhiitemrenderer.xml#msaaColorBuffer">msaaColorBuffer</db:link>(). When <db:link xlink:href="qquickrhiitem.xml#isAutoRenderTargetEnabled">isAutoRenderTargetEnabled</db:link> is <db:code>true</db:code>, this is taken care of by the <db:link xlink:href="qrhirendertarget.xml">QRhiRenderTarget</db:link> returned from <db:link xlink:href="qquickrhiitemrenderer.xml#renderTarget">renderTarget</db:link>(). Otherwise, it is up to the subclass code to correctly configure a render target object with both the color buffer and resolve textures.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#colorTexture">colorTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rhi">
<db:title>[protected] QRhi *QQuickRhiItemRenderer::rhi() const</db:title>
<db:para>Returns the current <db:link xlink:href="qrhi.xml">QRhi</db:link> object.</db:para>
<db:para>Must only be called from <db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>() and <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>().</db:para>
</db:section>
<db:section xml:id="synchronize">
<db:title>[pure virtual protected] void QQuickRhiItemRenderer::synchronize(QQuickRhiItem *<db:emphasis>item</db:emphasis>)</db:title>
<db:para>This function is called on the render thread, if there is one, while the main/GUI thread is blocked. It is called from <db:link xlink:href="qquickitem.xml#updatePaintNode">the <db:code role="parameter">item</db:code>'s synchronize step</db:link>, and allows reading and writing data belonging to the main and render threads. Typically property values stored in the <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> are copied into the <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link>, so that they can be safely read afterwards in <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>() when the render and main threads continue to work in parallel.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="update">
<db:title>[protected] void QQuickRhiItemRenderer::update()</db:title>
<db:para>Call this function when the content of the offscreen color buffer should be updated. (i.e. to request that <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>() is called again; the call will happen at a later point, and note that updates are typically throttled to the presentation rate)</db:para>
<db:para>This function can be called from <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>() to schedule an update.</db:para>
<db:note>
<db:para>This function should be used from inside the renderer. To update the item on the GUI thread, use <db:link xlink:href="qquickitem.xml#update">QQuickRhiItem::update</db:link>().</db:para>
</db:note>
</db:section>
</db:section>
</db:article>
