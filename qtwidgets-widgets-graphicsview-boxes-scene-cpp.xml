<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Boxes</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Combines advanced OpenGL rendering with the Graphics View framework.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the demonstration applications of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &amp;lt;QDebug&amp;gt;
#include &quot;scene.h&quot;
#include &amp;lt;QtCore/QRandomGenerator&amp;gt;
#include &amp;lt;QtGui/qmatrix4x4.h&amp;gt;
#include &amp;lt;QtGui/qvector3d.h&amp;gt;
#include &amp;lt;qmath.h&amp;gt;

#include &quot;3rdparty/fbm.h&quot;

void checkGLErrors(const QString&amp;amp; prefix)
{
    switch (glGetError()) {
    case GL_NO_ERROR:
        //qDebug() &amp;lt;&amp;lt; prefix &amp;lt;&amp;lt; tr(&quot;No error.&quot;);
        break;
    case GL_INVALID_ENUM:
        qDebug() &amp;lt;&amp;lt; prefix &amp;lt;&amp;lt; QObject::tr(&quot;Invalid enum.&quot;);
        break;
    case GL_INVALID_VALUE:
        qDebug() &amp;lt;&amp;lt; prefix &amp;lt;&amp;lt; QObject::tr(&quot;Invalid value.&quot;);
        break;
    case GL_INVALID_OPERATION:
        qDebug() &amp;lt;&amp;lt; prefix &amp;lt;&amp;lt; QObject::tr(&quot;Invalid operation.&quot;);
        break;
    case GL_STACK_OVERFLOW:
        qDebug() &amp;lt;&amp;lt; prefix &amp;lt;&amp;lt; QObject::tr(&quot;Stack overflow.&quot;);
        break;
    case GL_STACK_UNDERFLOW:
        qDebug() &amp;lt;&amp;lt; prefix &amp;lt;&amp;lt; QObject::tr(&quot;Stack underflow.&quot;);
        break;
    case GL_OUT_OF_MEMORY:
        qDebug() &amp;lt;&amp;lt; prefix &amp;lt;&amp;lt; QObject::tr(&quot;Out of memory.&quot;);
        break;
    default:
        qDebug() &amp;lt;&amp;lt; prefix &amp;lt;&amp;lt; QObject::tr(&quot;Unknown error.&quot;);
        break;
    }
}

//============================================================================//
//                                  ColorEdit                                 //
//============================================================================//

ColorEdit::ColorEdit(QRgb initialColor, int id)
    : m_color(initialColor), m_id(id)
{
    QHBoxLayout *layout = new QHBoxLayout;
    setLayout(layout);
    layout-&amp;gt;setContentsMargins(0, 0, 0, 0);

    m_lineEdit = new QLineEdit(QString::number(m_color, 16));
    layout-&amp;gt;addWidget(m_lineEdit);

    m_button = new QFrame;
    QPalette palette = m_button-&amp;gt;palette();
    palette.setColor(QPalette::Window, QColor(m_color));
    m_button-&amp;gt;setPalette(palette);
    m_button-&amp;gt;setAutoFillBackground(true);
    m_button-&amp;gt;setMinimumSize(32, 0);
    m_button-&amp;gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Preferred);
    m_button-&amp;gt;setFrameStyle(QFrame::StyledPanel | QFrame::Sunken);
    layout-&amp;gt;addWidget(m_button);

    connect(m_lineEdit, SIGNAL(editingFinished()), this, SLOT(editDone()));
}

void ColorEdit::editDone()
{
    bool ok;
    QRgb newColor = m_lineEdit-&amp;gt;text().toUInt(&amp;amp;ok, 16);
    if (ok)
        setColor(newColor);
}

void ColorEdit::mousePressEvent(QMouseEvent *event)
{
    if (event-&amp;gt;button() == Qt::LeftButton) {
        QColor color(m_color);
        QColorDialog dialog(color, 0);
        dialog.setOption(QColorDialog::ShowAlphaChannel, true);
// The ifdef block is a workaround for the beta, TODO: remove when bug 238525 is fixed
#if 0 // Used to be included in Qt4 for Q_WS_MAC
        dialog.setOption(QColorDialog::DontUseNativeDialog, true);
#endif
        dialog.move(280, 120);
        if (dialog.exec() == QDialog::Rejected)
            return;
        QRgb newColor = dialog.selectedColor().rgba();
        if (newColor == m_color)
            return;
        setColor(newColor);
    }
}

void ColorEdit::setColor(QRgb color)
{
    m_color = color;
    m_lineEdit-&amp;gt;setText(QString::number(m_color, 16)); // &quot;Clean up&quot; text
    QPalette palette = m_button-&amp;gt;palette();
    palette.setColor(QPalette::Window, QColor(m_color));
    m_button-&amp;gt;setPalette(palette);
    emit colorChanged(m_color, m_id);
}

//============================================================================//
//                                  FloatEdit                                 //
//============================================================================//

FloatEdit::FloatEdit(float initialValue, int id)
    : m_value(initialValue), m_id(id)
{
    QHBoxLayout *layout = new QHBoxLayout;
    setLayout(layout);
    layout-&amp;gt;setContentsMargins(0, 0, 0, 0);

    m_lineEdit = new QLineEdit(QString::number(m_value));
    layout-&amp;gt;addWidget(m_lineEdit);

    connect(m_lineEdit, SIGNAL(editingFinished()), this, SLOT(editDone()));
}

void FloatEdit::editDone()
{
    bool ok;
    float newValue = m_lineEdit-&amp;gt;text().toFloat(&amp;amp;ok);
    if (ok) {
        m_value = newValue;
        m_lineEdit-&amp;gt;setText(QString::number(m_value)); // &quot;Clean up&quot; text
        emit valueChanged(m_value, m_id);
    }
}

//============================================================================//
//                           TwoSidedGraphicsWidget                           //
//============================================================================//

TwoSidedGraphicsWidget::TwoSidedGraphicsWidget(QGraphicsScene *scene)
    : QObject(scene)
    , m_current(0)
    , m_angle(0)
    , m_delta(0)
{
    for (int i = 0; i &amp;lt; 2; ++i)
        m_proxyWidgets[i] = 0;
}

void TwoSidedGraphicsWidget::setWidget(int index, QWidget *widget)
{
    if (index &amp;lt; 0 || index &amp;gt;= 2)
    {
        qWarning(&quot;TwoSidedGraphicsWidget::setWidget: Index out of bounds, index == %d&quot;, index);
        return;
    }

    GraphicsWidget *proxy = new GraphicsWidget;
    proxy-&amp;gt;setWidget(widget);

    if (m_proxyWidgets[index])
        delete m_proxyWidgets[index];
    m_proxyWidgets[index] = proxy;

    proxy-&amp;gt;setCacheMode(QGraphicsItem::ItemCoordinateCache);
    proxy-&amp;gt;setZValue(1e30); // Make sure the dialog is drawn on top of all other (OpenGL) items

    if (index != m_current)
        proxy-&amp;gt;setVisible(false);

    qobject_cast&amp;lt;QGraphicsScene *&amp;gt;(parent())-&amp;gt;addItem(proxy);
}

QWidget *TwoSidedGraphicsWidget::widget(int index)
{
    if (index &amp;lt; 0 || index &amp;gt;= 2)
    {
        qWarning(&quot;TwoSidedGraphicsWidget::widget: Index out of bounds, index == %d&quot;, index);
        return 0;
    }
    return m_proxyWidgets[index]-&amp;gt;widget();
}

void TwoSidedGraphicsWidget::flip()
{
    m_delta = (m_current == 0 ? 9 : -9);
    animateFlip();
}

void TwoSidedGraphicsWidget::animateFlip()
{
    m_angle += m_delta;
    if (m_angle == 90) {
        int old = m_current;
        m_current ^= 1;
        m_proxyWidgets[old]-&amp;gt;setVisible(false);
        m_proxyWidgets[m_current]-&amp;gt;setVisible(true);
        m_proxyWidgets[m_current]-&amp;gt;setGeometry(m_proxyWidgets[old]-&amp;gt;geometry());
    }

    QRectF r = m_proxyWidgets[m_current]-&amp;gt;boundingRect();
    m_proxyWidgets[m_current]-&amp;gt;setTransform(QTransform()
        .translate(r.width() / 2, r.height() / 2)
        .rotate(m_angle - 180 * m_current, Qt::YAxis)
        .translate(-r.width() / 2, -r.height() / 2));

    if ((m_current == 0 &amp;amp;&amp;amp; m_angle &amp;gt; 0) || (m_current == 1 &amp;amp;&amp;amp; m_angle &amp;lt; 180))
        QTimer::singleShot(25, this, SLOT(animateFlip()));
}

QVariant GraphicsWidget::itemChange(GraphicsItemChange change, const QVariant &amp;amp;value)
{
    if (change == ItemPositionChange &amp;amp;&amp;amp; scene()) {
        QRectF rect = boundingRect();
        QPointF pos = value.toPointF();
        QRectF sceneRect = scene()-&amp;gt;sceneRect();
        if (pos.x() + rect.left() &amp;lt; sceneRect.left())
            pos.setX(sceneRect.left() - rect.left());
        else if (pos.x() + rect.right() &amp;gt;= sceneRect.right())
            pos.setX(sceneRect.right() - rect.right());
        if (pos.y() + rect.top() &amp;lt; sceneRect.top())
            pos.setY(sceneRect.top() - rect.top());
        else if (pos.y() + rect.bottom() &amp;gt;= sceneRect.bottom())
            pos.setY(sceneRect.bottom() - rect.bottom());
        return pos;
    }
    return QGraphicsProxyWidget::itemChange(change, value);
}

void GraphicsWidget::resizeEvent(QGraphicsSceneResizeEvent *event)
{
    setCacheMode(QGraphicsItem::NoCache);
    setCacheMode(QGraphicsItem::ItemCoordinateCache);
    QGraphicsProxyWidget::resizeEvent(event);
}

void GraphicsWidget::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    painter-&amp;gt;setRenderHint(QPainter::Antialiasing, false);
    QGraphicsProxyWidget::paint(painter, option, widget);
    //painter-&amp;gt;setRenderHint(QPainter::Antialiasing, true);
}

//============================================================================//
//                             RenderOptionsDialog                            //
//============================================================================//

RenderOptionsDialog::RenderOptionsDialog()
    : QDialog(0, Qt::CustomizeWindowHint | Qt::WindowTitleHint)
{
    setWindowOpacity(0.75);
    setWindowTitle(tr(&quot;Options (double click to flip)&quot;));
    QGridLayout *layout = new QGridLayout;
    setLayout(layout);
    layout-&amp;gt;setColumnStretch(1, 1);

    int row = 0;

    QCheckBox *check = new QCheckBox(tr(&quot;Dynamic cube map&quot;));
    check-&amp;gt;setCheckState(Qt::Unchecked);
    // Dynamic cube maps are only enabled when multi-texturing and render to texture are available.
    check-&amp;gt;setEnabled(glActiveTexture &amp;amp;&amp;amp; glGenFramebuffersEXT);
    connect(check, SIGNAL(stateChanged(int)), this, SIGNAL(dynamicCubemapToggled(int)));
    layout-&amp;gt;addWidget(check, 0, 0, 1, 2);
    ++row;

    QPalette palette;

    // Load all .par files
    // .par files have a simple syntax for specifying user adjustable uniform variables.
    QSet&amp;lt;QByteArray&amp;gt; uniforms;
    QList&amp;lt;QString&amp;gt; filter = QStringList(&quot;*.par&quot;);
    QList&amp;lt;QFileInfo&amp;gt; files = QDir(&quot;:/res/boxes/&quot;).entryInfoList(filter, QDir::Files | QDir::Readable);

    foreach (QFileInfo fileInfo, files) {
        QFile file(fileInfo.absoluteFilePath());
        if (file.open(QIODevice::ReadOnly)) {
            while (!file.atEnd()) {
                QList&amp;lt;QByteArray&amp;gt; tokens = file.readLine().simplified().split(' ');
                QList&amp;lt;QByteArray&amp;gt;::const_iterator it = tokens.begin();
                if (it == tokens.end())
                    continue;
                QByteArray type = *it;
                if (++it == tokens.end())
                    continue;
                QByteArray name = *it;
                bool singleElement = (tokens.size() == 3); // type, name and one value
                char counter[10] = &quot;000000000&quot;;
                int counterPos = 8; // position of last digit
                while (++it != tokens.end()) {
                    m_parameterNames &amp;lt;&amp;lt; name;
                    if (!singleElement) {
                        m_parameterNames.back() += '[';
                        m_parameterNames.back() += counter + counterPos;
                        m_parameterNames.back() += ']';
                        int j = 8; // position of last digit
                        ++counter[j];
                        while (j &amp;gt; 0 &amp;amp;&amp;amp; counter[j] &amp;gt; '9') {
                            counter[j] = '0';
                            ++counter[--j];
                        }
                        if (j &amp;lt; counterPos)
                            counterPos = j;
                    }

                    if (type == &quot;color&quot;) {
                        layout-&amp;gt;addWidget(new QLabel(m_parameterNames.back()));
                        bool ok;
                        ColorEdit *colorEdit = new ColorEdit(it-&amp;gt;toUInt(&amp;amp;ok, 16), m_parameterNames.size() - 1);
                        m_parameterEdits &amp;lt;&amp;lt; colorEdit;
                        layout-&amp;gt;addWidget(colorEdit);
                        connect(colorEdit, SIGNAL(colorChanged(QRgb,int)), this, SLOT(setColorParameter(QRgb,int)));
                        ++row;
                    } else if (type == &quot;float&quot;) {
                        layout-&amp;gt;addWidget(new QLabel(m_parameterNames.back()));
                        bool ok;
                        FloatEdit *floatEdit = new FloatEdit(it-&amp;gt;toFloat(&amp;amp;ok), m_parameterNames.size() - 1);
                        m_parameterEdits &amp;lt;&amp;lt; floatEdit;
                        layout-&amp;gt;addWidget(floatEdit);
                        connect(floatEdit, SIGNAL(valueChanged(float,int)), this, SLOT(setFloatParameter(float,int)));
                        ++row;
                    }
                }
            }
            file.close();
        }
    }

    layout-&amp;gt;addWidget(new QLabel(tr(&quot;Texture:&quot;)));
    m_textureCombo = new QComboBox;
    connect(m_textureCombo, SIGNAL(currentIndexChanged(int)), this, SIGNAL(textureChanged(int)));
    layout-&amp;gt;addWidget(m_textureCombo);
    ++row;

    layout-&amp;gt;addWidget(new QLabel(tr(&quot;Shader:&quot;)));
    m_shaderCombo = new QComboBox;
    connect(m_shaderCombo, SIGNAL(currentIndexChanged(int)), this, SIGNAL(shaderChanged(int)));
    layout-&amp;gt;addWidget(m_shaderCombo);
    ++row;

    layout-&amp;gt;setRowStretch(row, 1);
}

int RenderOptionsDialog::addTexture(const QString &amp;amp;name)
{
    m_textureCombo-&amp;gt;addItem(name);
    return m_textureCombo-&amp;gt;count() - 1;
}

int RenderOptionsDialog::addShader(const QString &amp;amp;name)
{
    m_shaderCombo-&amp;gt;addItem(name);
    return m_shaderCombo-&amp;gt;count() - 1;
}

void RenderOptionsDialog::emitParameterChanged()
{
    foreach (ParameterEdit *edit, m_parameterEdits)
        edit-&amp;gt;emitChange();
}

void RenderOptionsDialog::setColorParameter(QRgb color, int id)
{
    emit colorParameterChanged(m_parameterNames[id], color);
}

void RenderOptionsDialog::setFloatParameter(float value, int id)
{
    emit floatParameterChanged(m_parameterNames[id], value);
}

void RenderOptionsDialog::mouseDoubleClickEvent(QMouseEvent *event)
{
    if (event-&amp;gt;button() == Qt::LeftButton)
        emit doubleClicked();
}

//============================================================================//
//                                 ItemDialog                                 //
//============================================================================//

ItemDialog::ItemDialog()
    : QDialog(0, Qt::CustomizeWindowHint | Qt::WindowTitleHint)
{
    setWindowTitle(tr(&quot;Items (double click to flip)&quot;));
    setWindowOpacity(0.75);
    resize(160, 100);

    QVBoxLayout *layout = new QVBoxLayout;
    setLayout(layout);
    QPushButton *button;

    button = new QPushButton(tr(&quot;Add Qt box&quot;));
    layout-&amp;gt;addWidget(button);
    connect(button, SIGNAL(clicked()), this, SLOT(triggerNewQtBox()));

    button = new QPushButton(tr(&quot;Add circle&quot;));
    layout-&amp;gt;addWidget(button);
    connect(button, SIGNAL(clicked()), this, SLOT(triggerNewCircleItem()));

    button = new QPushButton(tr(&quot;Add square&quot;));
    layout-&amp;gt;addWidget(button);
    connect(button, SIGNAL(clicked()), this, SLOT(triggerNewSquareItem()));

    layout-&amp;gt;addStretch(1);
}

void ItemDialog::triggerNewQtBox()
{
    emit newItemTriggered(QtBoxItem);
}

void ItemDialog::triggerNewCircleItem()
{
    emit newItemTriggered(CircleItem);
}

void ItemDialog::triggerNewSquareItem()
{
    emit newItemTriggered(SquareItem);
}

void ItemDialog::mouseDoubleClickEvent(QMouseEvent *event)
{
    if (event-&amp;gt;button() == Qt::LeftButton)
        emit doubleClicked();
}

//============================================================================//
//                                    Scene                                   //
//============================================================================//

const static char environmentShaderText[] =
    &quot;uniform samplerCube env;&quot;
    &quot;void main() {&quot;
        &quot;gl_FragColor = textureCube(env, gl_TexCoord[1].xyz);&quot;
    &quot;}&quot;;

Scene::Scene(int width, int height, int maxTextureSize)
    : m_distExp(600)
    , m_frame(0)
    , m_maxTextureSize(maxTextureSize)
    , m_currentShader(0)
    , m_currentTexture(0)
    , m_dynamicCubemap(false)
    , m_updateAllCubemaps(true)
    , m_box(0)
    , m_vertexShader(0)
    , m_environmentShader(0)
    , m_environmentProgram(0)
{
    setSceneRect(0, 0, width, height);

    m_trackBalls[0] = TrackBall(0.05f, QVector3D(0, 1, 0), TrackBall::Sphere);
    m_trackBalls[1] = TrackBall(0.005f, QVector3D(0, 0, 1), TrackBall::Sphere);
    m_trackBalls[2] = TrackBall(0.0f, QVector3D(0, 1, 0), TrackBall::Plane);

    m_renderOptions = new RenderOptionsDialog;
    m_renderOptions-&amp;gt;move(20, 120);
    m_renderOptions-&amp;gt;resize(m_renderOptions-&amp;gt;sizeHint());

    connect(m_renderOptions, SIGNAL(dynamicCubemapToggled(int)), this, SLOT(toggleDynamicCubemap(int)));
    connect(m_renderOptions, SIGNAL(colorParameterChanged(QString,QRgb)), this, SLOT(setColorParameter(QString,QRgb)));
    connect(m_renderOptions, SIGNAL(floatParameterChanged(QString,float)), this, SLOT(setFloatParameter(QString,float)));
    connect(m_renderOptions, SIGNAL(textureChanged(int)), this, SLOT(setTexture(int)));
    connect(m_renderOptions, SIGNAL(shaderChanged(int)), this, SLOT(setShader(int)));

    m_itemDialog = new ItemDialog;
    connect(m_itemDialog, SIGNAL(newItemTriggered(ItemDialog::ItemType)), this, SLOT(newItem(ItemDialog::ItemType)));

    TwoSidedGraphicsWidget *twoSided = new TwoSidedGraphicsWidget(this);
    twoSided-&amp;gt;setWidget(0, m_renderOptions);
    twoSided-&amp;gt;setWidget(1, m_itemDialog);

    connect(m_renderOptions, SIGNAL(doubleClicked()), twoSided, SLOT(flip()));
    connect(m_itemDialog, SIGNAL(doubleClicked()), twoSided, SLOT(flip()));

    addItem(new QtBox(64, width - 64, height - 64));
    addItem(new QtBox(64, width - 64, 64));
    addItem(new QtBox(64, 64, height - 64));
    addItem(new QtBox(64, 64, 64));

    initGL();

    m_timer = new QTimer(this);
    m_timer-&amp;gt;setInterval(20);
    connect(m_timer, SIGNAL(timeout()), this, SLOT(update()));
    m_timer-&amp;gt;start();

    m_time.start();
}

Scene::~Scene()
{
    if (m_box)
        delete m_box;
    foreach (GLTexture *texture, m_textures)
        if (texture) delete texture;
    if (m_mainCubemap)
        delete m_mainCubemap;
    foreach (QGLShaderProgram *program, m_programs)
        if (program) delete program;
    if (m_vertexShader)
        delete m_vertexShader;
    foreach (QGLShader *shader, m_fragmentShaders)
        if (shader) delete shader;
    foreach (GLRenderTargetCube *rt, m_cubemaps)
        if (rt) delete rt;
    if (m_environmentShader)
        delete m_environmentShader;
    if (m_environmentProgram)
        delete m_environmentProgram;
}

void Scene::initGL()
{
    m_box = new GLRoundedBox(0.25f, 1.0f, 10);

    m_vertexShader = new QGLShader(QGLShader::Vertex);
    m_vertexShader-&amp;gt;compileSourceFile(QLatin1String(&quot;:/res/boxes/basic.vsh&quot;));

    QStringList list;
    list &amp;lt;&amp;lt; &quot;:/res/boxes/cubemap_posx.jpg&quot; &amp;lt;&amp;lt; &quot;:/res/boxes/cubemap_negx.jpg&quot; &amp;lt;&amp;lt; &quot;:/res/boxes/cubemap_posy.jpg&quot;
         &amp;lt;&amp;lt; &quot;:/res/boxes/cubemap_negy.jpg&quot; &amp;lt;&amp;lt; &quot;:/res/boxes/cubemap_posz.jpg&quot; &amp;lt;&amp;lt; &quot;:/res/boxes/cubemap_negz.jpg&quot;;
    m_environment = new GLTextureCube(list, qMin(1024, m_maxTextureSize));
    m_environmentShader = new QGLShader(QGLShader::Fragment);
    m_environmentShader-&amp;gt;compileSourceCode(environmentShaderText);
    m_environmentProgram = new QGLShaderProgram;
    m_environmentProgram-&amp;gt;addShader(m_vertexShader);
    m_environmentProgram-&amp;gt;addShader(m_environmentShader);
    m_environmentProgram-&amp;gt;link();

    const int NOISE_SIZE = 128; // for a different size, B and BM in fbm.c must also be changed
    m_noise = new GLTexture3D(NOISE_SIZE, NOISE_SIZE, NOISE_SIZE);
    QRgb *data = new QRgb[NOISE_SIZE * NOISE_SIZE * NOISE_SIZE];
    memset(data, 0, NOISE_SIZE * NOISE_SIZE * NOISE_SIZE * sizeof(QRgb));
    QRgb *p = data;
    float pos[3];
    for (int k = 0; k &amp;lt; NOISE_SIZE; ++k) {
        pos[2] = k * (0x20 / (float)NOISE_SIZE);
        for (int j = 0; j &amp;lt; NOISE_SIZE; ++j) {
            for (int i = 0; i &amp;lt; NOISE_SIZE; ++i) {
                for (int byte = 0; byte &amp;lt; 4; ++byte) {
                    pos[0] = (i + (byte &amp;amp; 1) * 16) * (0x20 / (float)NOISE_SIZE);
                    pos[1] = (j + (byte &amp;amp; 2) * 8) * (0x20 / (float)NOISE_SIZE);
                    *p |= (int)(128.0f * (noise3(pos) + 1.0f)) &amp;lt;&amp;lt; (byte * 8);
                }
                ++p;
            }
        }
    }
    m_noise-&amp;gt;load(NOISE_SIZE, NOISE_SIZE, NOISE_SIZE, data);
    delete[] data;

    m_mainCubemap = new GLRenderTargetCube(512);

    QStringList filter;
    QList&amp;lt;QFileInfo&amp;gt; files;

    // Load all .png files as textures
    m_currentTexture = 0;
    filter = QStringList(&quot;*.png&quot;);
    files = QDir(&quot;:/res/boxes/&quot;).entryInfoList(filter, QDir::Files | QDir::Readable);

    foreach (QFileInfo file, files) {
        GLTexture *texture = new GLTexture2D(file.absoluteFilePath(), qMin(256, m_maxTextureSize), qMin(256, m_maxTextureSize));
        if (texture-&amp;gt;failed()) {
            delete texture;
            continue;
        }
        m_textures &amp;lt;&amp;lt; texture;
        m_renderOptions-&amp;gt;addTexture(file.baseName());
    }

    if (m_textures.size() == 0)
        m_textures &amp;lt;&amp;lt; new GLTexture2D(qMin(64, m_maxTextureSize), qMin(64, m_maxTextureSize));

    // Load all .fsh files as fragment shaders
    m_currentShader = 0;
    filter = QStringList(&quot;*.fsh&quot;);
    files = QDir(&quot;:/res/boxes/&quot;).entryInfoList(filter, QDir::Files | QDir::Readable);
    foreach (QFileInfo file, files) {
        QGLShaderProgram *program = new QGLShaderProgram;
        QGLShader* shader = new QGLShader(QGLShader::Fragment);
        shader-&amp;gt;compileSourceFile(file.absoluteFilePath());
        // The program does not take ownership over the shaders, so store them in a vector so they can be deleted afterwards.
        program-&amp;gt;addShader(m_vertexShader);
        program-&amp;gt;addShader(shader);
        if (!program-&amp;gt;link()) {
            qWarning(&quot;Failed to compile and link shader program&quot;);
            qWarning(&quot;Vertex shader log:&quot;);
            qWarning() &amp;lt;&amp;lt; m_vertexShader-&amp;gt;log();
            qWarning() &amp;lt;&amp;lt; &quot;Fragment shader log ( file =&quot; &amp;lt;&amp;lt; file.absoluteFilePath() &amp;lt;&amp;lt; &quot;):&quot;;
            qWarning() &amp;lt;&amp;lt; shader-&amp;gt;log();
            qWarning(&quot;Shader program log:&quot;);
            qWarning() &amp;lt;&amp;lt; program-&amp;gt;log();

            delete shader;
            delete program;
            continue;
        }

        m_fragmentShaders &amp;lt;&amp;lt; shader;
        m_programs &amp;lt;&amp;lt; program;
        m_renderOptions-&amp;gt;addShader(file.baseName());

        program-&amp;gt;bind();
        m_cubemaps &amp;lt;&amp;lt; ((program-&amp;gt;uniformLocation(&quot;env&quot;) != -1) ? new GLRenderTargetCube(qMin(256, m_maxTextureSize)) : 0);
        program-&amp;gt;release();
    }

    if (m_programs.size() == 0)
        m_programs &amp;lt;&amp;lt; new QGLShaderProgram;

    m_renderOptions-&amp;gt;emitParameterChanged();
}

static void loadMatrix(const QMatrix4x4&amp;amp; m)
{
    // static to prevent glLoadMatrixf to fail on certain drivers
    static GLfloat mat[16];
    const float *data = m.constData();
    for (int index = 0; index &amp;lt; 16; ++index)
        mat[index] = data[index];
    glLoadMatrixf(mat);
}

// If one of the boxes should not be rendered, set excludeBox to its index.
// If the main box should not be rendered, set excludeBox to -1.
void Scene::renderBoxes(const QMatrix4x4 &amp;amp;view, int excludeBox)
{
    QMatrix4x4 invView = view.inverted();

    // If multi-texturing is supported, use three saplers.
    if (glActiveTexture) {
        glActiveTexture(GL_TEXTURE0);
        m_textures[m_currentTexture]-&amp;gt;bind();
        glActiveTexture(GL_TEXTURE2);
        m_noise-&amp;gt;bind();
        glActiveTexture(GL_TEXTURE1);
    } else {
        m_textures[m_currentTexture]-&amp;gt;bind();
    }

    glDisable(GL_LIGHTING);
    glDisable(GL_CULL_FACE);

    QMatrix4x4 viewRotation(view);
    viewRotation(3, 0) = viewRotation(3, 1) = viewRotation(3, 2) = 0.0f;
    viewRotation(0, 3) = viewRotation(1, 3) = viewRotation(2, 3) = 0.0f;
    viewRotation(3, 3) = 1.0f;
    loadMatrix(viewRotation);
    glScalef(20.0f, 20.0f, 20.0f);

    // Don't render the environment if the environment texture can't be set for the correct sampler.
    if (glActiveTexture) {
        m_environment-&amp;gt;bind();
        m_environmentProgram-&amp;gt;bind();
        m_environmentProgram-&amp;gt;setUniformValue(&quot;tex&quot;, GLint(0));
        m_environmentProgram-&amp;gt;setUniformValue(&quot;env&quot;, GLint(1));
        m_environmentProgram-&amp;gt;setUniformValue(&quot;noise&quot;, GLint(2));
        m_box-&amp;gt;draw();
        m_environmentProgram-&amp;gt;release();
        m_environment-&amp;gt;unbind();
    }

    loadMatrix(view);

    glEnable(GL_CULL_FACE);
    glEnable(GL_LIGHTING);

    for (int i = 0; i &amp;lt; m_programs.size(); ++i) {
        if (i == excludeBox)
            continue;

        glPushMatrix();
        QMatrix4x4 m;
        m.rotate(m_trackBalls[1].rotation());
        glMultMatrixf(m.constData());

        glRotatef(360.0f * i / m_programs.size(), 0.0f, 0.0f, 1.0f);
        glTranslatef(2.0f, 0.0f, 0.0f);
        glScalef(0.3f, 0.6f, 0.6f);

        if (glActiveTexture) {
            if (m_dynamicCubemap &amp;amp;&amp;amp; m_cubemaps[i])
                m_cubemaps[i]-&amp;gt;bind();
            else
                m_environment-&amp;gt;bind();
        }
        m_programs[i]-&amp;gt;bind();
        m_programs[i]-&amp;gt;setUniformValue(&quot;tex&quot;, GLint(0));
        m_programs[i]-&amp;gt;setUniformValue(&quot;env&quot;, GLint(1));
        m_programs[i]-&amp;gt;setUniformValue(&quot;noise&quot;, GLint(2));
        m_programs[i]-&amp;gt;setUniformValue(&quot;view&quot;, view);
        m_programs[i]-&amp;gt;setUniformValue(&quot;invView&quot;, invView);
        m_box-&amp;gt;draw();
        m_programs[i]-&amp;gt;release();

        if (glActiveTexture) {
            if (m_dynamicCubemap &amp;amp;&amp;amp; m_cubemaps[i])
                m_cubemaps[i]-&amp;gt;unbind();
            else
                m_environment-&amp;gt;unbind();
        }
        glPopMatrix();
    }

    if (-1 != excludeBox) {
        QMatrix4x4 m;
        m.rotate(m_trackBalls[0].rotation());
        glMultMatrixf(m.constData());

        if (glActiveTexture) {
            if (m_dynamicCubemap)
                m_mainCubemap-&amp;gt;bind();
            else
                m_environment-&amp;gt;bind();
        }

        m_programs[m_currentShader]-&amp;gt;bind();
        m_programs[m_currentShader]-&amp;gt;setUniformValue(&quot;tex&quot;, GLint(0));
        m_programs[m_currentShader]-&amp;gt;setUniformValue(&quot;env&quot;, GLint(1));
        m_programs[m_currentShader]-&amp;gt;setUniformValue(&quot;noise&quot;, GLint(2));
        m_programs[m_currentShader]-&amp;gt;setUniformValue(&quot;view&quot;, view);
        m_programs[m_currentShader]-&amp;gt;setUniformValue(&quot;invView&quot;, invView);
        m_box-&amp;gt;draw();
        m_programs[m_currentShader]-&amp;gt;release();

        if (glActiveTexture) {
            if (m_dynamicCubemap)
                m_mainCubemap-&amp;gt;unbind();
            else
                m_environment-&amp;gt;unbind();
        }
    }

    if (glActiveTexture) {
        glActiveTexture(GL_TEXTURE2);
        m_noise-&amp;gt;unbind();
        glActiveTexture(GL_TEXTURE0);
    }
    m_textures[m_currentTexture]-&amp;gt;unbind();
}

void Scene::setStates()
{
    //glClearColor(0.25f, 0.25f, 0.5f, 1.0f);

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_CULL_FACE);
    glEnable(GL_LIGHTING);
    //glEnable(GL_COLOR_MATERIAL);
    glEnable(GL_TEXTURE_2D);
    glEnable(GL_NORMALIZE);

    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadIdentity();

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();

    setLights();

    float materialSpecular[] = {0.5f, 0.5f, 0.5f, 1.0f};
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, materialSpecular);
    glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 32.0f);
}

void Scene::setLights()
{
    glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
    //float lightColour[] = {1.0f, 1.0f, 1.0f, 1.0f};
    float lightDir[] = {0.0f, 0.0f, 1.0f, 0.0f};
    //glLightfv(GL_LIGHT0, GL_DIFFUSE, lightColour);
    //glLightfv(GL_LIGHT0, GL_SPECULAR, lightColour);
    glLightfv(GL_LIGHT0, GL_POSITION, lightDir);
    glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, 1.0f);
    glEnable(GL_LIGHT0);
}

void Scene::defaultStates()
{
    //glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

    glDisable(GL_DEPTH_TEST);
    glDisable(GL_CULL_FACE);
    glDisable(GL_LIGHTING);
    //glDisable(GL_COLOR_MATERIAL);
    glDisable(GL_TEXTURE_2D);
    glDisable(GL_LIGHT0);
    glDisable(GL_NORMALIZE);

    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();

    glMatrixMode(GL_PROJECTION);
    glPopMatrix();

    glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, 0.0f);
    float defaultMaterialSpecular[] = {0.0f, 0.0f, 0.0f, 1.0f};
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, defaultMaterialSpecular);
    glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 0.0f);
}

void Scene::renderCubemaps()
{
    // To speed things up, only update the cubemaps for the small cubes every N frames.
    const int N = (m_updateAllCubemaps ? 1 : 3);

    QMatrix4x4 mat;
    GLRenderTargetCube::getProjectionMatrix(mat, 0.1f, 100.0f);

    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    loadMatrix(mat);

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();

    QVector3D center;

    const float eachAngle = 2 * M_PI / m_cubemaps.size();
    for (int i = m_frame % N; i &amp;lt; m_cubemaps.size(); i += N) {
        if (0 == m_cubemaps[i])
            continue;

        float angle = i * eachAngle;

        center = m_trackBalls[1].rotation().rotatedVector(QVector3D(std::cos(angle), std::sin(angle), 0.0f));

        for (int face = 0; face &amp;lt; 6; ++face) {
            m_cubemaps[i]-&amp;gt;begin(face);

            GLRenderTargetCube::getViewMatrix(mat, face);
            QVector4D v = QVector4D(-center.x(), -center.y(), -center.z(), 1.0);
            mat.setColumn(3, mat * v);

            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
            renderBoxes(mat, i);

            m_cubemaps[i]-&amp;gt;end();
        }
    }

    for (int face = 0; face &amp;lt; 6; ++face) {
        m_mainCubemap-&amp;gt;begin(face);
        GLRenderTargetCube::getViewMatrix(mat, face);

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        renderBoxes(mat, -1);

        m_mainCubemap-&amp;gt;end();
    }

    glPopMatrix();

    glMatrixMode(GL_PROJECTION);
    glPopMatrix();

    m_updateAllCubemaps = false;
}

void Scene::drawBackground(QPainter *painter, const QRectF &amp;amp;)
{
    float width = float(painter-&amp;gt;device()-&amp;gt;width());
    float height = float(painter-&amp;gt;device()-&amp;gt;height());

    painter-&amp;gt;beginNativePainting();
    setStates();

    if (m_dynamicCubemap)
        renderCubemaps();

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glMatrixMode(GL_PROJECTION);
    qgluPerspective(60.0, width / height, 0.01, 15.0);

    glMatrixMode(GL_MODELVIEW);

    QMatrix4x4 view;
    view.rotate(m_trackBalls[2].rotation());
    view(2, 3) -= 2.0f * std::exp(m_distExp / 1200.0f);
    renderBoxes(view);

    defaultStates();
    ++m_frame;

    painter-&amp;gt;endNativePainting();
}

QPointF Scene::pixelPosToViewPos(const QPointF&amp;amp; p)
{
    return QPointF(2.0 * float(p.x()) / width() - 1.0,
                   1.0 - 2.0 * float(p.y()) / height());
}

void Scene::mouseMoveEvent(QGraphicsSceneMouseEvent *event)
{
    QGraphicsScene::mouseMoveEvent(event);
    if (event-&amp;gt;isAccepted())
        return;

    if (event-&amp;gt;buttons() &amp;amp; Qt::LeftButton) {
        m_trackBalls[0].move(pixelPosToViewPos(event-&amp;gt;scenePos()), m_trackBalls[2].rotation().conjugated());
        event-&amp;gt;accept();
    } else {
        m_trackBalls[0].release(pixelPosToViewPos(event-&amp;gt;scenePos()), m_trackBalls[2].rotation().conjugated());
    }

    if (event-&amp;gt;buttons() &amp;amp; Qt::RightButton) {
        m_trackBalls[1].move(pixelPosToViewPos(event-&amp;gt;scenePos()), m_trackBalls[2].rotation().conjugated());
        event-&amp;gt;accept();
    } else {
        m_trackBalls[1].release(pixelPosToViewPos(event-&amp;gt;scenePos()), m_trackBalls[2].rotation().conjugated());
    }

    if (event-&amp;gt;buttons() &amp;amp; Qt::MidButton) {
        m_trackBalls[2].move(pixelPosToViewPos(event-&amp;gt;scenePos()), QQuaternion());
        event-&amp;gt;accept();
    } else {
        m_trackBalls[2].release(pixelPosToViewPos(event-&amp;gt;scenePos()), QQuaternion());
    }
}

void Scene::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    QGraphicsScene::mousePressEvent(event);
    if (event-&amp;gt;isAccepted())
        return;

    if (event-&amp;gt;buttons() &amp;amp; Qt::LeftButton) {
        m_trackBalls[0].push(pixelPosToViewPos(event-&amp;gt;scenePos()), m_trackBalls[2].rotation().conjugated());
        event-&amp;gt;accept();
    }

    if (event-&amp;gt;buttons() &amp;amp; Qt::RightButton) {
        m_trackBalls[1].push(pixelPosToViewPos(event-&amp;gt;scenePos()), m_trackBalls[2].rotation().conjugated());
        event-&amp;gt;accept();
    }

    if (event-&amp;gt;buttons() &amp;amp; Qt::MidButton) {
        m_trackBalls[2].push(pixelPosToViewPos(event-&amp;gt;scenePos()), QQuaternion());
        event-&amp;gt;accept();
    }
}

void Scene::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    QGraphicsScene::mouseReleaseEvent(event);
    if (event-&amp;gt;isAccepted())
        return;

    if (event-&amp;gt;button() == Qt::LeftButton) {
        m_trackBalls[0].release(pixelPosToViewPos(event-&amp;gt;scenePos()), m_trackBalls[2].rotation().conjugated());
        event-&amp;gt;accept();
    }

    if (event-&amp;gt;button() == Qt::RightButton) {
        m_trackBalls[1].release(pixelPosToViewPos(event-&amp;gt;scenePos()), m_trackBalls[2].rotation().conjugated());
        event-&amp;gt;accept();
    }

    if (event-&amp;gt;button() == Qt::MidButton) {
        m_trackBalls[2].release(pixelPosToViewPos(event-&amp;gt;scenePos()), QQuaternion());
        event-&amp;gt;accept();
    }
}

void Scene::wheelEvent(QGraphicsSceneWheelEvent * event)
{
    QGraphicsScene::wheelEvent(event);
    if (!event-&amp;gt;isAccepted()) {
        m_distExp += event-&amp;gt;delta();
        if (m_distExp &amp;lt; -8 * 120)
            m_distExp = -8 * 120;
        if (m_distExp &amp;gt; 10 * 120)
            m_distExp = 10 * 120;
        event-&amp;gt;accept();
    }
}

void Scene::setShader(int index)
{
    if (index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; m_fragmentShaders.size())
        m_currentShader = index;
}

void Scene::setTexture(int index)
{
    if (index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; m_textures.size())
        m_currentTexture = index;
}

void Scene::toggleDynamicCubemap(int state)
{
    if ((m_dynamicCubemap = (state == Qt::Checked)))
        m_updateAllCubemaps = true;
}

void Scene::setColorParameter(const QString &amp;amp;name, QRgb color)
{
    // set the color in all programs
    foreach (QGLShaderProgram *program, m_programs) {
        program-&amp;gt;bind();
        program-&amp;gt;setUniformValue(program-&amp;gt;uniformLocation(name), QColor(color));
        program-&amp;gt;release();
    }
}

void Scene::setFloatParameter(const QString &amp;amp;name, float value)
{
    // set the color in all programs
    foreach (QGLShaderProgram *program, m_programs) {
        program-&amp;gt;bind();
        program-&amp;gt;setUniformValue(program-&amp;gt;uniformLocation(name), value);
        program-&amp;gt;release();
    }
}

void Scene::newItem(ItemDialog::ItemType type)
{
    QSize size = sceneRect().size().toSize();
    switch (type) {
    case ItemDialog::QtBoxItem:
        addItem(new QtBox(64, QRandomGenerator::global()-&amp;gt;bounded(size.width() - 64) + 32,
                          QRandomGenerator::global()-&amp;gt;bounded(size.height() - 64) + 32));
        break;
    case ItemDialog::CircleItem:
        addItem(new CircleItem(64, QRandomGenerator::global()-&amp;gt;bounded(size.width() - 64) + 32,
                               QRandomGenerator::global()-&amp;gt;bounded(size.height() - 64) + 32));
        break;
    case ItemDialog::SquareItem:
        addItem(new SquareItem(64, QRandomGenerator::global()-&amp;gt;bounded(size.width() - 64) + 32,
                               QRandomGenerator::global()-&amp;gt;bounded(size.height() - 64) + 32));
        break;
    default:
        break;
    }
}

</db:programlisting>
</db:article>
