<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Models and Views in Qt Quick</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>how to display and form data in Qt Quick.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Simply put, applications need to form data and display the data. Qt Quick has the notion of <db:emphasis>models</db:emphasis>, <db:emphasis>views</db:emphasis>, and <db:emphasis>delegates</db:emphasis> to display data. They modularize the visualization of data in order to give the developer or designer control over the different aspects of the data. A developer can swap a list view with a grid view with little changes to the data. Similarly, encapsulating an instance of the data in a delegate allows the developer to dictate how to present or handle the data.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/modelview-overview.png"/>
</db:imageobject>
</db:mediaobject>
<db:itemizedlist>
<db:listitem>
<db:para><db:emphasis role="bold">Model</db:emphasis> - contains the data and its structure. There are several QML types for creating models.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">View</db:emphasis> - a container that displays the data. The view might display the data in a list or a grid.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Delegate</db:emphasis> - dictates how the data should appear in the view. The delegate takes each data in the model and encapsulates it. The data is accessible through the delegate.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>To visualize data, bind the view's <db:code>model</db:code> property to a model and the <db:code>delegate</db:code> property to a component or another compatible type.</db:para>
<db:section xml:id="displaying-data-with-views">
<db:title>Displaying Data with Views</db:title>
<db:para>Views are containers for collections of items. They are feature-rich and can be customizable to meet style or behavior requirements.</db:para>
<db:anchor xml:id="qtquick-views"/>
<db:para>A set of standard views are provided in the basic set of Qt Quick graphical types:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> - arranges items in a horizontal or vertical list</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick-gridview.xml">GridView</db:link> - arranges items in a grid within the available space</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick-pathview.xml">PathView</db:link> - arranges items on a path</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>These types have properties and behaviors exclusive to each type. Visit their respective documentation for more information.</db:para>
<db:section xml:id="decorating-views">
<db:title>Decorating Views</db:title>
<db:para>Views allow visual customization through <db:emphasis>decoration</db:emphasis> properties such as the <db:code>header</db:code>, <db:code>footer</db:code>, and <db:code>section</db:code> properties. By binding an object, usually another visual object, to these properties, the views are decoratable. A footer may include a <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link> type showcasing borders or a header that displays a logo on top of the list.</db:para>
<db:para>Suppose that a specific club wants to decorate its members list with its brand colors. A member list is in a <db:code>model</db:code> and the <db:code>delegate</db:code> will display the model's content.</db:para>
<db:programlisting language="qml">ListModel {
    id: nameModel
    ListElement { name: &quot;Alice&quot; }
    ListElement { name: &quot;Bob&quot; }
    ListElement { name: &quot;Jane&quot; }
    ListElement { name: &quot;Harry&quot; }
    ListElement { name: &quot;Wendy&quot; }
}
Component {
    id: nameDelegate
    Text {
        text: name;
        font.pixelSize: 24
    }
}
</db:programlisting>
<db:para>The club may decorate the members list by binding visual objects to the <db:code>header</db:code> and <db:code>footer</db:code> properties. The visual object may be defined inline, in another file, or in a <db:link xlink:href="qml-qtqml-component.xml">Component</db:link> type.</db:para>
<db:programlisting language="qml">ListView {
    anchors.fill: parent
    clip: true
    model: nameModel
    delegate: nameDelegate
    header: bannercomponent
    footer: Rectangle {
        width: parent.width; height: 30;
        gradient: clubcolors
    }
    highlight: Rectangle {
        width: parent.width
        color: &quot;lightgray&quot;
    }
}

Component {     //instantiated when header is processed
    id: bannercomponent
    Rectangle {
        id: banner
        width: parent.width; height: 50
        gradient: clubcolors
        border {color: &quot;#9EDDF2&quot;; width: 2}
        Text {
            anchors.centerIn: parent
            text: &quot;Club Members&quot;
            font.pixelSize: 32
        }
    }
}
Gradient {
    id: clubcolors
    GradientStop { position: 0.0; color: &quot;#8EE2FE&quot;}
    GradientStop { position: 0.66; color: &quot;#7ED2EE&quot;}
}
</db:programlisting>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/listview-decorations.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
<db:section xml:id="mouse-and-touch-handling">
<db:title>Mouse and Touch Handling</db:title>
<db:para>The views handle dragging and flicking of their content, however they do not handle touch interaction with the individual delegates. In order for the delegates to react to touch input, e.g. to set the <db:code>currentIndex</db:code>, a <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> with the appropriate touch handling logic must be provided by the delegate.</db:para>
<db:para>Note that if <db:code>highlightRangeMode</db:code> is set to <db:code>StrictlyEnforceRange</db:code> the currentIndex will be affected by dragging/flicking the view, since the view will always ensure that the <db:code>currentIndex</db:code> is within the highlight range specified.</db:para>
</db:section>
<db:section xml:id="listview-sections">
<db:title>ListView Sections</db:title>
<db:para><db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> contents may be grouped into <db:emphasis>sections</db:emphasis>, where related list items are labeled according to their sections. Further, the sections may be decorated with <db:link xlink:href="qtquick-modelviewsdata-modelview.xml#view-delegates">delegates</db:link>.</db:para>
<db:para>A list may contain a list indicating people's names and the team on which team the person belongs.</db:para>
<db:programlisting language="qml">ListModel {
    id: nameModel
    ListElement { name: &quot;Alice&quot;; team: &quot;Crypto&quot; }
    ListElement { name: &quot;Bob&quot;; team: &quot;Crypto&quot; }
    ListElement { name: &quot;Jane&quot;; team: &quot;QA&quot; }
    ListElement { name: &quot;Victor&quot;; team: &quot;QA&quot; }
    ListElement { name: &quot;Wendy&quot;; team: &quot;Graphics&quot; }
}
Component {
    id: nameDelegate
    Text {
        text: name;
        font.pixelSize: 24
        anchors.left: parent.left
        anchors.leftMargin: 2
    }
}
</db:programlisting>
<db:para>The <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> type has the <db:code>section</db:code> <db:link xlink:href="qtqml-syntax-objectattributes.xml#attached-properties-and-attached-signal-handlers">attached property</db:link> that can combine adjacent and related types into a section. The <db:code>section.property</db:code> determines which list type property to use as sections. The <db:code>section.criteria</db:code> can dictate how the section names are displayed and the <db:code>section.delegate</db:code> is similar to the views' <db:link xlink:href="qtquick-modelviewsdata-modelview.xml#view-delegates">delegate</db:link> property.</db:para>
<db:programlisting language="qml">ListView {
    anchors.fill: parent
    model: nameModel
    delegate: nameDelegate
    focus: true
    highlight: Rectangle {
        color: &quot;lightblue&quot;
        width: parent.width
    }
    section {
        property: &quot;team&quot;
        criteria: ViewSection.FullString
        delegate: Rectangle {
            color: &quot;#b0dfb0&quot;
            width: parent.width
            height: childrenRect.height + 4
            Text { anchors.horizontalCenter: parent.horizontalCenter
                font.pixelSize: 16
                font.bold: true
                text: section
            }
        }
    }
}
</db:programlisting>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/listview-section.png"/>
</db:imageobject>
</db:mediaobject>
<db:anchor xml:id="qml-view-delegate"/>
</db:section>
</db:section>
<db:section xml:id="view-delegates">
<db:title>View Delegates</db:title>
<db:para>Views need a <db:emphasis>delegate</db:emphasis> to visually represent an item in a list. A view will visualize each item list according to the template defined by the delegate. Items in a model are accessible through the <db:code>index</db:code> property as well as the item's properties.</db:para>
<db:programlisting language="qml">Component {
    id: petdelegate
    Text {
        id: label
        font.pixelSize: 24
        text: if (index == 0)
            label.text = type + &quot; (default)&quot;
        else
            text: type
    }
}
</db:programlisting>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/listview-setup.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="accessing-views-and-models-from-delegates">
<db:title>Accessing Views and Models from Delegates</db:title>
<db:para>The list view to which the delegate is bound is accessible from the delegate through the <db:code>ListView.view</db:code> property. Likewise, the <db:link xlink:href="qml-qtquick-gridview.xml">GridView</db:link> <db:code>GridView.view</db:code> is available to delegates. The corresponding model and its properties, therefore, are available through <db:code>ListView.view.model</db:code>. In addition, any defined signals or methods in the model are also accessible.</db:para>
<db:para>This mechanism is useful when you want to use the same delegate for a number of views, for example, but you want decorations or other features to be different for each view, and you would like these different settings to be properties of each of the views. Similarly, it might be of interest to access or show some properties of the model.</db:para>
<db:para>In the following example, the delegate shows the property <db:emphasis>language</db:emphasis> of the model, and the color of one of the fields depends on the property <db:emphasis>fruit_color</db:emphasis> of the view.</db:para>
<db:programlisting language="qml">Rectangle {
     width: 200; height: 200

    ListModel {
        id: fruitModel
        property string language: &quot;en&quot;
        ListElement {
            name: &quot;Apple&quot;
            cost: 2.45
        }
        ListElement {
            name: &quot;Orange&quot;
            cost: 3.25
        }
        ListElement {
            name: &quot;Banana&quot;
            cost: 1.95
        }
    }

    Component {
        id: fruitDelegate
        Row {
                id: fruit
                Text { text: &quot; Fruit: &quot; + name; color: fruit.ListView.view.fruit_color }
                Text { text: &quot; Cost: $&quot; + cost }
                Text { text: &quot; Language: &quot; + fruit.ListView.view.model.language }
        }
    }

    ListView {
        property color fruit_color: &quot;green&quot;
        model: fruitModel
        delegate: fruitDelegate
        anchors.fill: parent
    }
}
</db:programlisting>
<db:anchor xml:id="qml-data-models"/>
</db:section>
</db:section>
<db:section xml:id="models">
<db:title>Models</db:title>
<db:para>Data is provided to the delegate via named data roles which the delegate may bind to. Here is a <db:link xlink:href="qml-qtqml-models-listmodel.xml">ListModel</db:link> with two roles, <db:emphasis>type</db:emphasis> and <db:emphasis>age</db:emphasis>, and a <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> with a delegate that binds to these roles to display their values:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Item {
    width: 200; height: 250

    ListModel {
        id: myModel
        ListElement { type: &quot;Dog&quot;; age: 8 }
        ListElement { type: &quot;Cat&quot;; age: 5 }
    }

    Component {
        id: myDelegate
        Text { text: type + &quot;, &quot; + age }
    }

    ListView {
        anchors.fill: parent
        model: myModel
        delegate: myDelegate
    }
}
</db:programlisting>
<db:para>If there is a naming clash between the model's properties and the delegate's properties, the roles can be accessed with the qualified <db:emphasis>model</db:emphasis> name instead. For example, if a <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> type had <db:emphasis>type</db:emphasis> or <db:emphasis>age</db:emphasis> properties, the text in the above example would display those property values instead of the <db:emphasis>type</db:emphasis> and <db:emphasis>age</db:emphasis> values from the model item. In this case, the properties could have been referenced as <db:code>model.type</db:code> and <db:code>model.age</db:code> instead to ensure the delegate displays the property values from the model item.</db:para>
<db:para>A special <db:emphasis>index</db:emphasis> role containing the index of the item in the model is also available to the delegate. Note this index is set to -1 if the item is removed from the model. If you bind to the index role, be sure that the logic accounts for the possibility of index being -1, i.e. that the item is no longer valid. (Usually the item will shortly be destroyed, but it is possible to delay delegate destruction in some views via a <db:code>delayRemove</db:code> attached property.)</db:para>
<db:para>Models that do not have named roles (such as the <db:link xlink:href="qml-qtqml-models-listmodel.xml">ListModel</db:link> shown below) will have the data provided via the <db:emphasis>modelData</db:emphasis> role. The <db:emphasis>modelData</db:emphasis> role is also provided for models that have only one role. In this case the <db:emphasis>modelData</db:emphasis> role contains the same data as the named role.</db:para>
<db:para>QML provides several types of data models among the built-in set of QML types. In addition, models can be created with Qt C++ and then made available to <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> for use by QML components. For information about creating these models, visit the <db:link xlink:href="qtquick-modelviewsdata-cppmodels.xml">Using C++ Models with Qt Quick Views</db:link> and <db:link xlink:href="qtqml-typesystem-topic.xml#qml-object-types">creating QML types</db:link> articles.</db:para>
<db:para>Positioning of items from a model can be achieved using a <db:link xlink:href="qml-qtquick-repeater.xml">Repeater</db:link>.</db:para>
<db:section xml:id="listmodel">
<db:title>ListModel</db:title>
<db:para><db:link xlink:href="qml-qtqml-models-listmodel.xml">ListModel</db:link> is a simple hierarchy of types specified in QML. The available roles are specified by the <db:link xlink:href="qml-qtqml-models-listelement.xml">ListElement</db:link> properties.</db:para>
<db:programlisting language="qml">ListModel {
    id: fruitModel

    ListElement {
        name: &quot;Apple&quot;
        cost: 2.45
    }
    ListElement {
        name: &quot;Orange&quot;
        cost: 3.25
    }
    ListElement {
        name: &quot;Banana&quot;
        cost: 1.95
    }
}
</db:programlisting>
<db:para>The above model has two roles, <db:emphasis>name</db:emphasis> and <db:emphasis>cost</db:emphasis>. These can be bound to by a <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> delegate, for example:</db:para>
<db:programlisting language="qml">ListView {
    anchors.fill: parent
    model: fruitModel
    delegate: Row {
        Text { text: &quot;Fruit: &quot; + name }
        Text { text: &quot;Cost: $&quot; + cost }
    }
}
</db:programlisting>
<db:para><db:link xlink:href="qml-qtqml-models-listmodel.xml">ListModel</db:link> provides methods to manipulate the <db:link xlink:href="qml-qtqml-models-listmodel.xml">ListModel</db:link> directly via JavaScript. In this case, the first item inserted determines the roles available to any views that are using the model. For example, if an empty <db:link xlink:href="qml-qtqml-models-listmodel.xml">ListModel</db:link> is created and populated via JavaScript, the roles provided by the first insertion are the only roles that will be shown in the view:</db:para>
<db:programlisting language="qml">ListModel { id: fruitModel }
    ...
MouseArea {
    anchors.fill: parent
    onClicked: fruitModel.append({&quot;cost&quot;: 5.95, &quot;name&quot;:&quot;Pizza&quot;})
}
</db:programlisting>
<db:para>When the <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> is clicked, <db:code>fruitModel</db:code> will have two roles, <db:emphasis>cost</db:emphasis> and <db:emphasis>name</db:emphasis>. Even if subsequent roles are added, only the first two will be handled by views using the model. To reset the roles available in the model, call <db:link xlink:href="qml-qtqml-models-listmodel.xml#clear-method">ListModel::clear</db:link>().</db:para>
</db:section>
<db:section xml:id="xmllistmodel">
<db:title>XmlListModel</db:title>
<db:para><db:link xlink:href="qml-qtquick-xmllistmodel-xmllistmodel.xml">XmlListModel</db:link> allows construction of a model from an XML data source. The roles are specified via the <db:link xlink:href="qml-qtquick-xmllistmodel-xmlrole.xml">XmlRole</db:link> type. The type needs to be imported.</db:para>
<db:programlisting language="cpp">import QtQuick.XmlListModel 2.0
</db:programlisting>
<db:para>The following model has three roles, <db:emphasis>title</db:emphasis>, <db:emphasis>link</db:emphasis> and <db:emphasis>description</db:emphasis>:</db:para>
<db:programlisting language="qml">XmlListModel {
     id: feedModel
     source: &quot;http://rss.news.yahoo.com/rss/oceania&quot;
     query: &quot;/rss/channel/item&quot;
     XmlRole { name: &quot;title&quot;; query: &quot;title/string()&quot; }
     XmlRole { name: &quot;link&quot;; query: &quot;link/string()&quot; }
     XmlRole { name: &quot;description&quot;; query: &quot;description/string()&quot; }
}
</db:programlisting>
<db:para>The <db:link xlink:href="qtquick-demos-rssnews-example.xml">RSS News demo</db:link> shows how <db:link xlink:href="qml-qtquick-xmllistmodel-xmllistmodel.xml">XmlListModel</db:link> can be used to display an RSS feed.</db:para>
</db:section>
<db:section xml:id="visualitemmodel">
<db:title>VisualItemModel</db:title>
<db:para><db:link xlink:href="qml-visualitemmodel.xml">VisualItemModel</db:link> allows QML items to be provided as a model.</db:para>
<db:para>This model contains both the data and delegate; the child items of a <db:link xlink:href="qml-visualitemmodel.xml">VisualItemModel</db:link> provide the contents of the delegate. The model does not provide any roles.</db:para>
<db:programlisting language="qml">VisualItemModel {
    id: itemModel
    Rectangle { height: 30; width: 80; color: &quot;red&quot; }
    Rectangle { height: 30; width: 80; color: &quot;green&quot; }
    Rectangle { height: 30; width: 80; color: &quot;blue&quot; }
}

ListView {
    anchors.fill: parent
    model: itemModel
}
</db:programlisting>
<db:para>Note that in the above example there is no delegate required. The items of the model itself provide the visual types that will be positioned by the view.</db:para>
</db:section>
<db:section xml:id="integers-as-models">
<db:title>Integers as Models</db:title>
<db:para>An integer can be used as a model that contains a certain number of types. In this case, the model does not have any data roles.</db:para>
<db:para>The following example creates a <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> with five elements:</db:para>
<db:programlisting language="qml">Item {
    width: 200; height: 250

    Component {
        id: itemDelegate
        Text { text: &quot;I am item number: &quot; + index }
    }

    ListView {
        anchors.fill: parent
        model: 5
        delegate: itemDelegate
    }

}
</db:programlisting>
</db:section>
<db:section xml:id="object-instances-as-models">
<db:title>Object Instances as Models</db:title>
<db:para>An object instance can be used to specify a model with a single object type. The properties of the object are provided as roles.</db:para>
<db:para>The example below creates a list with one item, showing the color of the <db:emphasis>myText</db:emphasis> text. Note the use of the fully qualified <db:emphasis>model.color</db:emphasis> property to avoid clashing with <db:emphasis>color</db:emphasis> property of the Text type in the delegate.</db:para>
<db:programlisting language="qml">Rectangle {
    width: 200; height: 250

    Text {
        id: myText
        text: &quot;Hello&quot;
        color: &quot;#dd44ee&quot;
    }

    Component {
        id: myDelegate
        Text { text: model.color }
    }

    ListView {
        anchors.fill: parent
        anchors.topMargin: 30
        model: myText
        delegate: myDelegate
    }
}
</db:programlisting>
<db:anchor xml:id="qml-c-models"/>
</db:section>
<db:section xml:id="c-data-models">
<db:title>C++ Data Models</db:title>
<db:para>Models can be defined in C++ and then made available to QML. This mechanism is useful for exposing existing C++ data models or otherwise complex datasets to QML.</db:para>
<db:para>For information, visit the <db:link xlink:href="qtquick-modelviewsdata-cppmodels.xml">Using C++ Models with Qt Quick Views</db:link> article.</db:para>
</db:section>
</db:section>
<db:section xml:id="repeaters">
<db:title>Repeaters</db:title>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/repeater-index.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
<db:para>Repeaters create items from a template for use with positioners, using data from a model. Combining repeaters and positioners is an easy way to lay out lots of items. A <db:link xlink:href="qml-qtquick-repeater.xml">Repeater</db:link> item is placed inside a positioner, and generates items that the enclosing positioner arranges.</db:para>
<db:para>Each Repeater creates a number of items by combining each element of data from a model, specified using the <db:link xlink:href="qml-qtquick-repeater.xml#model-prop">model</db:link> property, with the template item, defined as a child item within the Repeater. The total number of items is determined by the amount of data in the model.</db:para>
<db:para>The following example shows a repeater used with a Grid item to arrange a set of Rectangle items. The Repeater item creates a series of 24 rectangles for the Grid item to position in a 5 by 5 arrangement.</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Rectangle {
    width: 400; height: 400; color: &quot;black&quot;

    Grid {
        x: 5; y: 5
        rows: 5; columns: 5; spacing: 10

        Repeater { model: 24
                   Rectangle { width: 70; height: 70
                               color: &quot;lightgreen&quot;

                               Text { text: index
                                      font.pointSize: 30
                                      anchors.centerIn: parent } }
        }
    }
}
</db:programlisting>
<db:para>The number of items created by a Repeater is held by its <db:link xlink:href="qml-qtquick-repeater.xml#count-prop">count</db:link> property. It is not possible to set this property to determine the number of items to be created. Instead, as in the above example, we use an integer as the model. This is explained in the <db:link xlink:href="qtquick-modelviewsdata-modelview.xml#integers-as-models">QML Data Models</db:link> document.</db:para>
<db:para>It is also possible to use a delegate as the template for the items created by a Repeater. This is specified using the <db:link xlink:href="qml-qtquick-repeater.xml#delegate-prop">delegate</db:link> property.</db:para>
</db:section>
<db:section xml:id="using-transitions">
<db:title>Using Transitions</db:title>
<db:para>Transitions can be used to animate items that are added to, moved within, or removed from a positioner.</db:para>
<db:para>Transitions for adding items apply to items that are created as part of a positioner, as well as those that are reparented to become children of a positioner.</db:para>
<db:para>Transitions for removing items apply to items within a positioner that are deleted, as well as those that are removed from a positioner and given new parents in a document.</db:para>
<db:note>
<db:para>Changing the opacity of items to zero will not cause them to disappear from the positioner. They can be removed and re-added by changing the visible property.</db:para>
</db:note>
</db:section>
</db:article>
