<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSignalSpy Class</db:title>
<db:productname>QtTestLib</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Test Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link> class enables introspection of signal emission.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSignalSpy</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Test)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Test)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += testlib</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qlist.xml" xlink:role="class">QList</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link> can connect to any signal of any object and records its emission. <db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link> itself is a list of <db:link xlink:href="qvariant.xml">QVariant</db:link> lists. Each emission of the signal will append one item to the list, containing the arguments of the signal.</db:para>
<db:para>The following example records all signal emissions for the <db:code>clicked()</db:code> signal of a QCheckBox:</db:para>
<db:programlisting language="cpp">QCheckBox *box = ...;
QSignalSpy spy(box, SIGNAL(clicked(bool)));

// do something that triggers the signal
box-&gt;animateClick();

QCOMPARE(spy.count(), 1); // make sure the signal was emitted exactly one time
QList&lt;QVariant&gt; arguments = spy.takeFirst(); // take the first signal

QVERIFY(arguments.at(0).toBool() == true); // verify the first argument
</db:programlisting>
<db:para><db:code>spy.takeFirst()</db:code> returns the arguments for the first emitted signal, as a list of <db:link xlink:href="qvariant.xml">QVariant</db:link> objects. The <db:code>clicked()</db:code> signal has a single bool argument, which is stored as the first entry in the list of arguments.</db:para>
<db:para>The example below catches a signal from a custom object:</db:para>
<db:programlisting language="cpp">QSignalSpy spy(myCustomObject, SIGNAL(mySignal(int,QString,double)));

myCustomObject-&gt;doSomething(); // trigger emission of the signal

QList&lt;QVariant&gt; arguments = spy.takeFirst();
QVERIFY(arguments.at(0).typeId() == QMetaType::Int);
QVERIFY(arguments.at(1).typeId() == QMetaType::QString);
QVERIFY(arguments.at(2).typeId() == QMetaType::Double);
</db:programlisting>
<db:note>
<db:para>Non-standard data types need to be registered, using the <db:link xlink:href="qmetatype.xml#qRegisterMetaType">qRegisterMetaType</db:link>() function, before you can create a <db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link>. For example:</db:para>
</db:note>
<db:programlisting language="cpp">qRegisterMetaType&lt;SomeStruct&gt;();
QSignalSpy spy(&amp;model, SIGNAL(whatever(SomeStruct)));
</db:programlisting>
<db:para>To retrieve the instance, you can use <db:link xlink:href="qvariant.xml#qvariant_cast">qvariant_cast</db:link>:</db:para>
<db:programlisting language="cpp">// get the first argument from the first received signal:
SomeStruct result = qvariant_cast&lt;SomeStruct&gt;(spy.at(0).at(0));
</db:programlisting>
<db:section xml:id="verifying-signal-emissions">
<db:title>Verifying Signal Emissions</db:title>
<db:para>The <db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link> class provides an elegant mechanism for capturing the list of signals emitted by an object. However, you should verify its validity after construction. The constructor does a number of sanity checks, such as verifying that the signal to be spied upon actually exists. To make the diagnosis of test failures easier, the results of these checks should be checked by calling <db:code>QVERIFY(spy.isValid())</db:code> before proceeding further with a test.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QSignalSpy">
<db:title>QSignalSpy::QSignalSpy(const QObject *<db:emphasis>object</db:emphasis>, PointerToMemberFunction <db:emphasis>signal</db:emphasis>)</db:title>
<db:para>Constructs a new <db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link> that listens for emissions of the <db:code role="parameter">signal</db:code> from the <db:link xlink:href="qobject.xml">QObject</db:link> <db:code role="parameter">object</db:code>. If <db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link> is not able to listen for a valid signal (for example, because <db:code role="parameter">object</db:code> is <db:code>nullptr</db:code> or <db:code role="parameter">signal</db:code> does not denote a valid signal of <db:code role="parameter">object</db:code>), an explanatory warning message will be output using <db:link xlink:href="qtlogging.xml#qWarning">qWarning</db:link>() and subsequent calls to <db:code>isValid()</db:code> will return false.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QSignalSpy spy(myPushButton, &amp;QPushButton::clicked);
</db:programlisting>
</db:section>
<db:section xml:id="QSignalSpy-1">
<db:title>QSignalSpy::QSignalSpy(const QObject *<db:emphasis>obj</db:emphasis>, QMetaMethod <db:emphasis>signal</db:emphasis>)</db:title>
<db:para>Constructs a new <db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link> that listens for emissions of the <db:code role="parameter">signal</db:code> from the <db:link xlink:href="qobject.xml">QObject</db:link> <db:code role="parameter">obj</db:code>. If <db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link> is not able to listen for a valid signal (for example, because <db:code role="parameter">obj</db:code> is <db:code>nullptr</db:code> or <db:code role="parameter">signal</db:code> does not denote a valid signal of <db:code role="parameter">obj</db:code>), an explanatory warning message will be output using <db:link xlink:href="qtlogging.xml#qWarning">qWarning</db:link>() and subsequent calls to <db:code>isValid()</db:code> will return false.</db:para>
<db:para>This constructor is convenient to use when Qt's meta-object system is heavily used in a test.</db:para>
<db:para>Basic usage example:</db:para>
<db:programlisting language="cpp">QObject object;
auto mo = object.metaObject();
auto signalIndex = mo-&gt;indexOfSignal(&quot;objectNameChanged(QString)&quot;);
auto signal = mo-&gt;method(signalIndex);

QSignalSpy spy(&amp;object, signal);
object.setObjectName(&quot;A new object name&quot;);
QCOMPARE(spy.count(), 1);
</db:programlisting>
<db:para>Imagine we need to check whether all properties of the <db:link xlink:href="qwindow.xml">QWindow</db:link> class that represent minimum and maximum dimensions are properly writable. The following example demonstrates one of the approaches:</db:para>
<db:programlisting language="cpp">void tst_QWindow::writeMinMaxDimensionalProps_data()
    QTest::addColumn&lt;int&gt;(&quot;propertyIndex&quot;);

    // Collect all relevant properties
    static const auto mo = QWindow::staticMetaObject;
    for (int i = mo.propertyOffset(); i &lt; mo.propertyCount(); ++i) {
        auto property = mo.property(i);

        // ...that have type int
        if (property.type() == QVariant::Int) {
            static const QRegularExpression re(&quot;^minimum|maximum&quot;);
            const auto name = property.name();

            // ...and start with &quot;minimum&quot; or &quot;maximum&quot;
            if (re.match(name).hasMatch()) {
                QTest::addRow(&quot;%s&quot;, name) &lt;&lt; i;
            }
        }
    }
}

void tst_QWindow::writeMinMaxDimensionalProps()
{
    QFETCH(int, propertyIndex);

    auto property = QWindow::staticMetaObject.property(propertyIndex);
    QVERIFY(property.isWritable());
    QVERIFY(property.hasNotifySignal());

    QWindow window;
    QSignalSpy spy(&amp;window, property.notifySignal());

    QVERIFY(property.write(&amp;window, 42));
    QCOMPARE(spy.count(), 1);
}
</db:programlisting>
</db:section>
<db:section xml:id="QSignalSpy-2">
<db:title>[explicit] QSignalSpy::QSignalSpy(const QObject *<db:emphasis>object</db:emphasis>, const char *<db:emphasis>signal</db:emphasis>)</db:title>
<db:para>Constructs a new <db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link> that listens for emissions of the <db:code role="parameter">signal</db:code> from the <db:link xlink:href="qobject.xml">QObject</db:link> <db:code role="parameter">object</db:code>. If <db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link> is not able to listen for a valid signal (for example, because <db:code role="parameter">object</db:code> is <db:code>nullptr</db:code> or <db:code role="parameter">signal</db:code> does not denote a valid signal of <db:code role="parameter">object</db:code>), an explanatory warning message will be output using <db:link xlink:href="qtlogging.xml#qWarning">qWarning</db:link>() and subsequent calls to <db:code>isValid()</db:code> will return false.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QSignalSpy spy(myPushButton, SIGNAL(clicked(bool)));
</db:programlisting>
</db:section>
<db:section xml:id="dtor.QSignalSpy">
<db:title>[noexcept] QSignalSpy::~QSignalSpy()</db:title>
<db:para>Destructor.</db:para>
</db:section>
<db:section xml:id="isValid">
<db:title>[noexcept] bool QSignalSpy::isValid() const</db:title>
<db:para>Returns <db:code>true</db:code> if the signal spy listens to a valid signal, otherwise false.</db:para>
</db:section>
<db:section xml:id="signal">
<db:title>QByteArray QSignalSpy::signal() const</db:title>
<db:para>Returns the normalized signal the spy is currently listening to.</db:para>
</db:section>
<db:section xml:id="wait">
<db:title>bool QSignalSpy::wait(int <db:emphasis>timeout</db:emphasis>)</db:title>
<db:para>This is an overloaded function, equivalent passing <db:code role="parameter">timeout</db:code> to the chrono overload:</db:para>
<db:programlisting language="cpp">wait(std::chrono::milliseconds{timeout});
</db:programlisting>
<db:para>Returns <db:code>true</db:code> if the signal was emitted at least once in <db:code role="parameter">timeout</db:code>, otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="wait-1">
<db:title>[since 6.6] bool QSignalSpy::wait(std::chrono::milliseconds <db:emphasis>timeout</db:emphasis> = std::chrono::seconds{5})</db:title>
<db:para>Starts an event loop that runs until the given signal is received or <db:code role="parameter">timeout</db:code> has passed, whichever happens first.</db:para>
<db:para><db:code role="parameter">timeout</db:code> is any valid std::chrono::duration (std::chrono::seconds, std::chrono::milliseconds ...etc).</db:para>
<db:para>Returns <db:code>true</db:code> if the signal was emitted at least once in <db:code role="parameter">timeout</db:code>, otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">using namespace std::chrono_literals;
QSignalSpy spy(object, signal);
spy.wait(2s);
</db:programlisting>
<db:para>This function was introduced in Qt 6.6.</db:para>
</db:section>
</db:section>
</db:article>
