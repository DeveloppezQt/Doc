<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Native IPC Keys</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>An overview of keys for <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> and <db:link xlink:href="qsystemsemaphore.xml">QSystemSemaphore</db:link>.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> and <db:link xlink:href="qsystemsemaphore.xml">QSystemSemaphore</db:link> classes identify their resource using a system-wide identifier known as a &quot;key&quot;. The low-level key value as well as the key type are encapsulated in Qt using the <db:link xlink:href="qnativeipckey.xml">QNativeIpcKey</db:link> class. That class also provides the proper means of exchanging the key with other processes, by way of <db:link xlink:href="qnativeipckey.xml#toString">QNativeIpcKey::toString</db:link>() and <db:link xlink:href="qnativeipckey.xml#fromString">QNativeIpcKey::fromString</db:link>().</db:para>
<db:para>Qt currently supports three distinct backends for those two classes, which match the values available in the <db:link xlink:href="qnativeipckey.xml#Type-enum">QNativeIpcKey::Type</db:link> enumeration.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>POSIX Realtime extensions (IEEE 1003.1b, POSIX.1b)</db:para>
</db:listitem>
<db:listitem>
<db:para>X/Open System Interfaces (XSI) or System V (SVr4), though also now part of POSIX</db:para>
</db:listitem>
<db:listitem>
<db:para>Windows primitives</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>As the name indicates, the Windows primitives are only available on the Windows operating system, where they are the default backend. The other two are usually both available on Unix operating systems. The following table provides an overview of typical availability since Qt 6.6:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Operating system</db:para>
</db:th>
<db:th>
<db:para>POSIX</db:para>
</db:th>
<db:th>
<db:para>System V</db:para>
</db:th>
<db:th>
<db:para>Windows</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Android</db:para>
</db:td>
<db:td>
</db:td>
<db:td>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>INTEGRITY</db:para>
</db:td>
<db:td>
</db:td>
<db:td>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QNX</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
<db:td>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>macOS</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
<db:td>
<db:para>Usually (1)</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Other Apple OSes</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
<db:td>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Other Unix systems</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Windows</db:para>
</db:td>
<db:td>
<db:para>Rarely (2)</db:para>
</db:td>
<db:td>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:note>
<db:para>1 Sandboxed macOS applications, which include all applications distributed via the Apple App Store, may not use System V objects.</db:para>
</db:note>
<db:note>
<db:para>2 Some GCC-compatible C runtimes on Windows provide POSIX-compatible shared memory support, but this is rare. It is always absent with the Microsoft compiler.</db:para>
</db:note>
<db:para>To determine whether a given key type is supported, applications should call QSharedMemory::isKeyTypeSupported() and QSystemSemaphore::isKeyTypeSupported().</db:para>
<db:para><db:link xlink:href="qnativeipckey.xml">QNativeIpcKey</db:link> also provides support for compatibility with Qt applications prior to its introduction. The following sections detail the limitations of the backends, the contents of the string keys themselves, and compatibility.</db:para>
<db:section xml:id="cross-platform-safe-key-format">
<db:title>Cross-platform safe key format</db:title>
<db:para><db:link xlink:href="qnativeipckey.xml#setNativeKey">QNativeIpcKey::setNativeKey</db:link>() and <db:link xlink:href="qnativeipckey.xml#nativeKey">QNativeIpcKey::nativeKey</db:link>() handle the low-level native key, which may be used with the native APIs and shared with other, non-Qt processes (see below for the API). This format is not usually cross-platform, so both <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> and <db:link xlink:href="qsystemsemaphore.xml">QSystemSemaphore</db:link> provide a function to translate a cross-platform identifier string to the native key: QSharedMemory::platformSafeKey() and QSystemSemaphore::platformSafeKey().</db:para>
<db:para>The length of the cross-platform key on most platforms is the same as that of a file name, but is severely limited on Apple platforms to only 30 usable bytes (be mindful of UTF-8 encoding if using characters outside the US-ASCII range). The format of the key is also similar to that of a file path component, meaning it should not contain any characters not allowed in file names, in particular those that separate path components (slash and backslash), with the exception of sandboxed applications on Apple operating systems. The following are good examples of cross-platform keys: &quot;myapp&quot;, &quot;org.example.myapp&quot;, &quot;org.example.myapp-12345&quot;. Note that it is up to the caller to prevent oversized keys, and to ensure that the key contains legal characters on the respective platform. Qt will silently truncate keys that are too long.</db:para>
<db:para><db:emphasis role="bold">Apple sandbox limitations:</db:emphasis> if the application is running inside of a sandbox in an Apple operating system, the key must be in a very specific format: &lt;application group identifier&gt;/&lt;custom identifier&gt;. Sandboxing is implied for all applications distributed through the Apple App Store. See Apple's documentation <db:link xlink:href="https://developer.apple.com/library/archive/documentation/Security/Conceptual/AppSandboxDesignGuide/AppSandboxInDepth/AppSandboxInDepth.html#//apple_ref/doc/uid/TP40011183-CH3-SW24">here</db:link> and <db:link xlink:href="https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_security_application-groups">here</db:link> for more information, including how to obtain the application's group identifier.</db:para>
</db:section>
<db:section xml:id="native-key-format">
<db:title>Native key format</db:title>
<db:para>This section details the format of the native keys of the supported backends.</db:para>
<db:section xml:id="posix-realtime">
<db:title>POSIX Realtime</db:title>
<db:para>Native keys resemble file names and may contain any character that file names do, except for a slash. POSIX requires the first character in the key name to be a slash and leaves undetermined whether any additional slashes are permitted. On most operating systems, the key length is the same as a file name, but it is limited to 32 characters on Apple operating systems (this includes the first slash and the terminating null, so only 30 usable characters are possible).</db:para>
<db:para>The following are good examples of native POSIX keys: &quot;/myapp&quot;, &quot;/org.example.myapp&quot;, &quot;/org.example.myapp-12345&quot;.</db:para>
<db:para>QSharedMemory::platformSafeKey() and QSystemSemaphore::platformSafeKey() simply prepend the slash. On Apple operating systems, they also truncate the result to the available size.</db:para>
</db:section>
<db:section xml:id="windows">
<db:title>Windows</db:title>
<db:para>Windows key types are NT <db:link xlink:href="https://learn.microsoft.com/en-us/windows/win32/sync/object-namespaces">kernel object names</db:link> and may be up to MAX_PATH (260) characters in length. They look like relative paths (that is, they don't start with a backslash or a drive letter), but unlike file names on Windows, they are case-sensitive.</db:para>
<db:para>The following are good examples of native Windows keys: &quot;myapp&quot;, &quot;org.example.myapp&quot;, &quot;org.example.myapp-12345&quot;.</db:para>
<db:para>QSharedMemory::platformSafeKey() and QSystemSemaphore::platformSafeKey() insert a prefix to disambiguate shared memory and system semaphores, respectively.</db:para>
</db:section>
<db:section xml:id="x-open-system-interfaces-xsi-system-v">
<db:title>X/Open System Interfaces (XSI) / System V</db:title>
<db:para>System V keys take the form of the name of a file in the system, and thus have the exact same limitations as file paths do. Both <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> and <db:link xlink:href="qsystemsemaphore.xml">QSystemSemaphore</db:link> will create this file if it does not exist when creating the object. If auto-removal is disabled, it may also be shared between <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> and <db:link xlink:href="qsystemsemaphore.xml">QSystemSemaphore</db:link> without conflict and can be any extant file (for example, it can be the process executable itself, see <db:link xlink:href="qcoreapplication.xml#applicationFilePath">QCoreApplication::applicationFilePath</db:link>()). The path should be an absolute one to avoid mistakes due to different current directories.</db:para>
<db:para>QSharedMemory::platformSafeKey() and QSystemSemaphore::platformSafeKey() always return an absolute path. If the input was already absolute, they will return their input unchanged. Otherwise, they will prepend a suitable path where the application usually has permission to create files in.</db:para>
</db:section>
</db:section>
<db:section xml:id="ownership">
<db:title>Ownership</db:title>
<db:para>Shared memory and system semaphore objects need to be created before use, which is accomplished with <db:link xlink:href="qsharedmemory.xml#create">QSharedMemory::create</db:link>() or by passing <db:link xlink:href="qsystemsemaphore.xml#AccessMode-enum">QSystemSemaphore::Create</db:link> to the constructor, respectively.</db:para>
<db:para>On Unix systems, the Qt classes that created the object will be responsible for cleaning up the object in question. Therefore, if the application with that C++ object exits uncleanly (a crash, <db:link xlink:href="qtlogging.xml#qFatal">qFatal</db:link>(), etc.), the object may be left behind. If that happens, applications may fail to create the object again and should instead attach to an existing one. For example, for <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link>:</db:para>
<db:programlisting language="cpp">if (!shm.create(4096) &amp;&amp; shm.error() == QSharedMemory::AlreadyExists)
    shm.attach();
</db:programlisting>
<db:para>Re-attaching to a <db:link xlink:href="qsystemsemaphore.xml">QSystemSemaphore</db:link> is probably unwise, as the token counter in it is probably in an unknown state and therefore may lead to deadlocks.</db:para>
<db:section xml:id="ownership-posix-realtime-6">
<db:title>POSIX Realtime</db:title>
<db:para>POSIX Realtime object ownership is patterned after files, in the sense that they exist independent of any process using them or not. Qt is unable to determine if the object is still in use, so auto-removal will remove it even then, which will make attaching to the same object impossible but otherwise not affecting existing attachments.</db:para>
<db:para>Prior to Qt 6.6, Qt never cleaned up POSIX Realtime objects, except on QNX.</db:para>
</db:section>
<db:section xml:id="ownership-x-open-system-interfaces-xsi-system-v-7">
<db:title>X/Open System Interfaces (XSI) / System V</db:title>
<db:para>There are two resources managed by the Qt classes: the file the key refers to and the object itself. <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> manages the object cooperatively: the last attachment is responsible for removing the object itself and then removing the key file. <db:link xlink:href="qsystemsemaphore.xml">QSystemSemaphore</db:link> will remove the object if and only if it was passed <db:link xlink:href="qsystemsemaphore.xml#AccessMode-enum">QSystemSemaphore::Create</db:link>; additionally, if it created the key file, it will remove that too.</db:para>
<db:para>Since Qt 6.6, it is possible to ask either class not to clean up.</db:para>
</db:section>
<db:section xml:id="ownership-windows-8">
<db:title>Windows</db:title>
<db:para>The operating system owns the object and will clean up after the last handle to the object is closed.</db:para>
</db:section>
</db:section>
<db:section xml:id="interoperability-with-old-qt-applications">
<db:title>Interoperability with old Qt applications</db:title>
<db:para>The <db:link xlink:href="qnativeipckey.xml">QNativeIpcKey</db:link> class was introduced in Qt 6.6. Prior to this version, <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> and <db:link xlink:href="qsystemsemaphore.xml">QSystemSemaphore</db:link> backends were determined at the time of Qt's own build. For Windows systems, it was always the Windows backend. For Unix systems, it defaulted to the System V backend if the configuration script determined it was available. If it was not available, it fell back to the POSIX one. The POSIX backend could be explicitly selected using the -feature-ipc_posix option to the Qt configure script; if it was enabled, the QT_POSIX_IPC macro would be defined.</db:para>
<db:para>Qt 6.6 retains the configure script option but it no longer controls the availability of the backends. Instead, it changes what <db:link xlink:href="qnativeipckey.xml#legacyDefaultTypeForOs">QNativeIpcKey::legacyDefaultTypeForOs</db:link>() will return. Applications that need to retain compatibility must use this key type exclusively to guarantee interoperability.</db:para>
<db:para>The API in both <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> and <db:link xlink:href="qsystemsemaphore.xml">QSystemSemaphore</db:link> had the concept of a cross-platform key, which is now deprecated in favor of using QSharedMemory::legacyNativeKey() and QSystemSemaphore::legacyNativeKey(). Those two functions produce the same native key as the deprecated functions did in prior versions. If the old code was for example:</db:para>
<db:programlisting language="cpp">QSharedMemory shm(&quot;org.example.myapplication&quot;);
QSystemSemaphore sem(&quot;org.example.myapplication&quot;);
</db:programlisting>
<db:para>It can be updated to be:</db:para>
<db:programlisting language="cpp">QSharedMemory shm(QSharedMemory::legacyNativeKey(&quot;org.example.myapplication&quot;));
QSystemSemaphore sem(QSystemSemaphore::legacyNativeKey(&quot;org.example.myapplication&quot;));
</db:programlisting>
<db:para>If the two applications exchanged native keys, there is no need to update code such as:</db:para>
<db:programlisting language="cpp">QSharedMemory shm;
shm.setNativeKey(key);
</db:programlisting>
<db:para>Though if the older application did accept a native key, the new one may opt to use platformSafeKey() with a second argument of <db:link xlink:href="qnativeipckey.xml#legacyDefaultTypeForOs">QNativeIpcKey::legacyDefaultTypeForOs</db:link>().</db:para>
<db:section xml:id="interoperability-with-old-qt-applications-x-open-system-interfaces-xsi-system-v-10">
<db:title>X/Open System Interfaces (XSI) / System V</db:title>
<db:para>Never use existing files for <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> keys, as the old Qt application may attempt to remove it. Instead, let <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> create it.</db:para>
</db:section>
</db:section>
<db:section xml:id="interoperability-with-non-qt-applications">
<db:title>Interoperability with non-Qt applications</db:title>
<db:para>Interoperability with non-Qt applications is possible, with some limitations:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Creation of shared memory segments must not race</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> support for locking the segment is unavailable</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Communication with non-Qt applications must always be through the native key.</db:para>
<db:para><db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> always maps the entire segment to memory. The non-Qt application may choose to only map a subset of it to memory, with no ill effects.</db:para>
<db:section xml:id="interoperability-with-non-qt-applications-posix-realtime-12">
<db:title>POSIX Realtime</db:title>
<db:para>POSIX shared memory can be opened using <db:link xlink:href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/shm_open.html">shm_open()</db:link> and POSIX system semaphores can be opened using <db:link xlink:href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_open.html">sem_open()</db:link>.</db:para>
<db:para>Both of those functions take a name parameter that is the result of <db:link xlink:href="qnativeipckey.xml#nativeKey">QNativeIpcKey::nativeKey</db:link>(), encoded for file names using <db:link xlink:href="qfile.xml#encodeName">QFile::encodeName</db:link>() / <db:link xlink:href="qfile.xml#decodeName">QFile::decodeName</db:link>().</db:para>
</db:section>
<db:section xml:id="interoperability-with-non-qt-applications-windows-13">
<db:title>Windows</db:title>
<db:para>Windows shared memory objects can be opened using <db:link xlink:href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-createfilemappingw">CreateFileMappingW</db:link> and Windows system semaphore objects can be opened using <db:link xlink:href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createsemaphorew">CreateSemaphoreW</db:link>. Despite the name of both functions starting with &quot;Create&quot;, they are able to attach to existing objects.</db:para>
<db:para>The lpName parameter to those functions is the result of <db:link xlink:href="qnativeipckey.xml#nativeKey">QNativeIpcKey::nativeKey</db:link>(), without transformation.</db:para>
<db:para>If the foreign application uses the non-Unicode version of those functions (ending in &quot;A&quot;), the name can be converted to and from 8-bit using <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
</db:section>
<db:section xml:id="interoperability-with-non-qt-applications-x-open-system-interfaces-xsi-system-v-14">
<db:title>X/Open System Interfaces (XSI) / System V</db:title>
<db:para>System V shared memory can be obtained using <db:link xlink:href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/shmget.html">shmget()</db:link> and System V system semaphores can be obtained using <db:link xlink:href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/semget.html">semget()</db:link>.</db:para>
<db:para>The key parameter to either of those functions is the result of the <db:link xlink:href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/ftok.html">ftok()</db:link> function when passed the file name obtained from <db:link xlink:href="qnativeipckey.xml#nativeKey">QNativeIpcKey::nativeKey</db:link>() with an id of 81 or 0x51 (the ASCII capital letter 'Q').</db:para>
<db:para>System V semaphore objects may contain multiple semaphores, but <db:link xlink:href="qsystemsemaphore.xml">QSystemSemaphore</db:link> only uses the first one (number 0 for sem_num).</db:para>
<db:para>Both <db:link xlink:href="qsharedmemory.xml">QSharedMemory</db:link> and <db:link xlink:href="qsystemsemaphore.xml">QSystemSemaphore</db:link> default to removing the object using the IPC_RMID operation to shmctl() and semctl() respectively if they are the last attachment.</db:para>
</db:section>
</db:section>
</db:article>
