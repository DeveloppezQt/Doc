<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Container Classes</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt's template-based container classes.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="introduction">
<db:title>Introduction</db:title>
<db:para>The Qt library provides a set of general purpose template-based container classes. These classes can be used to store items of a specified type. For example, if you need a resizable array of <db:link xlink:href="qstring.xml">QString</db:link>s, use <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>&gt;.</db:para>
<db:para>These container classes are designed to be lighter, safer, and easier to use than the STL containers. If you are unfamiliar with the STL, or prefer to do things the &quot;Qt way&quot;, you can use these classes instead of the STL classes.</db:para>
<db:para>The container classes are <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>, they are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>, and they are optimized for speed, low memory consumption, and minimal inline code expansion, resulting in smaller executables. In addition, they are <db:link xlink:href="threads-reentrancy.xml">thread-safe</db:link> in situations where they are used as read-only containers by all threads used to access them.</db:para>
<db:para>The containers provide iterators for traversal. <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> are the most efficient ones and can be used together with Qt's and STL's <db:link xlink:href="qtalgorithms.xml">generic algorithms</db:link>. <db:link xlink:href="java-style-iterators.xml#java-style-iterators">Java-style Iterators</db:link> are provided for backwards compatibility.</db:para>
<db:note>
<db:para>Since Qt 5.14, range constructors are available for most of the container classes. <db:link xlink:href="qmultimap.xml">QMultiMap</db:link> is a notable exception. Their use is encouraged in place of the various from/to methods. For example:</db:para>
</db:note>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list { 1, 2, 3, 4, 4, 5 };
QSet&amp;lt;int&amp;gt; set(list.begin(), list.end());
/*
    Will generate a QSet containing 1, 2, 3, 4, 5.
*/
</db:programlisting>
</db:section>
<db:section xml:id="the-container-classes">
<db:title>The Container Classes</db:title>
<db:para>Qt provides the following sequential containers: <db:link xlink:href="qlist.xml">QList</db:link>, <db:link xlink:href="qstack.xml">QStack</db:link>, and <db:link xlink:href="qqueue.xml">QQueue</db:link>. For most applications, <db:link xlink:href="qlist.xml">QList</db:link> is the best type to use. It provides very fast appends. If you really need a linked-list, use std::list. <db:link xlink:href="qstack.xml">QStack</db:link> and <db:link xlink:href="qqueue.xml">QQueue</db:link> are convenience classes that provide LIFO and FIFO semantics.</db:para>
<db:para>Qt also provides these associative containers: <db:link xlink:href="qmap.xml">QMap</db:link>, <db:link xlink:href="qmultimap.xml">QMultiMap</db:link>, <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>, and <db:link xlink:href="qset.xml">QSet</db:link>. The &quot;Multi&quot; containers conveniently support multiple values associated with a single key. The &quot;Hash&quot; containers provide faster lookup by using a hash function instead of a binary search on a sorted set.</db:para>
<db:para>As special cases, the <db:link xlink:href="qcache.xml">QCache</db:link> and <db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link> classes provide efficient hash-lookup of objects in a limited cache storage.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Class</db:para>
</db:th>
<db:th>
<db:para>Summary</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;</db:para>
</db:td>
<db:td>
<db:para>This is by far the most commonly used container class. It stores a list of values of a given type (T) that can be accessed by index. Internally, it stores an array of values of a given type at adjacent positions in memory. Inserting at the front or in the middle of a list can be quite slow, because it can lead to large numbers of items having to be moved by one position in memory.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>&lt;T, Prealloc&gt;</db:para>
</db:td>
<db:td>
<db:para>This provides a low-level variable-length array. It can be used instead of <db:link xlink:href="qlist.xml">QList</db:link> in places where speed is particularly important.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qstack.xml">QStack</db:link>&lt;T&gt;</db:para>
</db:td>
<db:td>
<db:para>This is a convenience subclass of <db:link xlink:href="qlist.xml">QList</db:link> that provides &quot;last in, first out&quot; (LIFO) semantics. It adds the following functions to those already present in <db:link xlink:href="qlist.xml">QList</db:link>: <db:link xlink:href="qstack.xml#push">push</db:link>(), <db:link xlink:href="qstack.xml#pop">pop</db:link>(), and <db:link xlink:href="qstack.xml#top">top</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qqueue.xml">QQueue</db:link>&lt;T&gt;</db:para>
</db:td>
<db:td>
<db:para>This is a convenience subclass of <db:link xlink:href="qlist.xml">QList</db:link> that provides &quot;first in, first out&quot; (FIFO) semantics. It adds the following functions to those already present in <db:link xlink:href="qlist.xml">QList</db:link>: <db:link xlink:href="qqueue.xml#enqueue">enqueue</db:link>(), <db:link xlink:href="qqueue.xml#dequeue">dequeue</db:link>(), and <db:link xlink:href="qqueue.xml#head">head</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt;</db:para>
</db:td>
<db:td>
<db:para>This provides a single-valued mathematical set with fast lookups.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmap.xml">QMap</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para>This provides a dictionary (associative array) that maps keys of type Key to values of type T. Normally each key is associated with a single value. <db:link xlink:href="qmap.xml">QMap</db:link> stores its data in Key order; if order doesn't matter <db:link xlink:href="qhash.xml#qhash">QHash</db:link> is a faster alternative.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmultimap.xml">QMultiMap</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para>This is a convenience subclass of <db:link xlink:href="qmap.xml">QMap</db:link> that provides a nice interface for multi-valued maps, i.e. maps where one key can be associated with multiple values.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para>This has almost the same API as <db:link xlink:href="qmap.xml">QMap</db:link>, but provides significantly faster lookups. <db:link xlink:href="qhash.xml#qhash">QHash</db:link> stores its data in an arbitrary order.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmultihash.xml">QMultiHash</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para>This is a convenience subclass of <db:link xlink:href="qhash.xml#qhash">QHash</db:link> that provides a nice interface for multi-valued hashes.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Containers can be nested. For example, it is perfectly possible to use a <db:link xlink:href="qmap.xml">QMap</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qlist.xml">QList</db:link>&lt;int&gt;&gt;, where the key type is <db:link xlink:href="qstring.xml">QString</db:link> and the value type <db:link xlink:href="qlist.xml">QList</db:link>&lt;int&gt;.</db:para>
<db:para>The containers are defined in individual header files with the same name as the container (e.g., &lt;QList&gt;). For convenience, the containers are forward declared in &lt;QtContainerFwd&gt;.</db:para>
<db:anchor xml:id="assignable-data-type"/>
<db:anchor xml:id="assignable-data-types"/>
<db:para>The values stored in the various containers can be of any <db:emphasis>assignable data type</db:emphasis>. To qualify, a type must provide a copy constructor, and an assignment operator. For some operations a default constructor is also required. This covers most data types you are likely to want to store in a container, including basic types such as int and double, pointer types, and Qt data types such as <db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qdate.xml">QDate</db:link>, and <db:link xlink:href="qtime.xml">QTime</db:link>, but it doesn't cover <db:link xlink:href="qobject.xml">QObject</db:link> or any <db:link xlink:href="qobject.xml">QObject</db:link> subclass (<db:link xlink:href="qwidget.xml">QWidget</db:link>, <db:link xlink:href="qdialog.xml">QDialog</db:link>, <db:link xlink:href="qtimer.xml">QTimer</db:link>, etc.). If you attempt to instantiate a <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qwidget.xml">QWidget</db:link>&gt;, the compiler will complain that <db:link xlink:href="qwidget.xml">QWidget</db:link>'s copy constructor and assignment operators are disabled. If you want to store these kinds of objects in a container, store them as pointers, for example as <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qwidget.xml">QWidget</db:link> *&gt;.</db:para>
<db:para>Here's an example custom data type that meets the requirement of an assignable data type:</db:para>
<db:programlisting language="cpp">class Employee
{
public:
    Employee() {}
    Employee(const Employee &amp;amp;other);

    Employee &amp;amp;operator=(const Employee &amp;amp;other);

private:
    QString myName;
    QDate myDateOfBirth;
};
</db:programlisting>
<db:para>If we don't provide a copy constructor or an assignment operator, C++ provides a default implementation that performs a member-by-member copy. In the example above, that would have been sufficient. Also, if you don't provide any constructors, C++ provides a default constructor that initializes its member using default constructors. Although it doesn't provide any explicit constructors or assignment operator, the following data type can be stored in a container:</db:para>
<db:programlisting language="cpp">struct Movie
{
    int id;
    QString title;
    QDate releaseDate;
};
</db:programlisting>
<db:para>Some containers have additional requirements for the data types they can store. For example, the Key type of a <db:link xlink:href="qmap.xml">QMap</db:link>&lt;Key, T&gt; must provide operator&lt;(). Such special requirements are documented in a class's detailed description. In some cases, specific functions have special requirements; these are described on a per-function basis. The compiler will always emit an error if a requirement isn't met.</db:para>
<db:para>Qt's containers provide operator&lt;&lt;() and operator&gt;&gt;() so that they can easily be read and written using a <db:link xlink:href="qdatastream.xml">QDataStream</db:link>. This means that the data types stored in the container must also support operator&lt;&lt;() and operator&gt;&gt;(). Providing such support is straightforward; here's how we could do it for the Movie struct above:</db:para>
<db:programlisting language="cpp">QDataStream &amp;amp;operator&amp;lt;&amp;lt;(QDataStream &amp;amp;out, const Movie &amp;amp;movie)
{
    out &amp;lt;&amp;lt; (quint32)movie.id &amp;lt;&amp;lt; movie.title
        &amp;lt;&amp;lt; movie.releaseDate;
    return out;
}

QDataStream &amp;amp;operator&amp;gt;&amp;gt;(QDataStream &amp;amp;in, Movie &amp;amp;movie)
{
    quint32 id;
    QDate date;

    in &amp;gt;&amp;gt; id &amp;gt;&amp;gt; movie.title &amp;gt;&amp;gt; date;
    movie.id = (int)id;
    movie.releaseDate = date;
    return in;
}
</db:programlisting>
<db:anchor xml:id="default-constructed-value"/>
<db:para>The documentation of certain container class functions refer to <db:emphasis>default-constructed values</db:emphasis>; for example, <db:link xlink:href="qlist.xml">QList</db:link> automatically initializes its items with default-constructed values, and <db:link xlink:href="qmap.xml#value">QMap::value</db:link>() returns a default-constructed value if the specified key isn't in the map. For most value types, this simply means that a value is created using the default constructor (e.g. an empty string for <db:link xlink:href="qstring.xml">QString</db:link>). But for primitive types like int and double, as well as for pointer types, the C++ language doesn't specify any initialization; in those cases, Qt's containers automatically initialize the value to 0.</db:para>
</db:section>
<db:section xml:id="the-iterator-classes">
<db:title>The Iterator Classes</db:title>
<db:para>Iterators provide a uniform means to access items in a container. Qt's container classes provide two types of iterators: STL-style iterators and Java-style iterators. Iterators of both types are invalidated when the data in the container is modified or detached from <db:link xlink:href="implicit-sharing.xml">implicitly shared copies</db:link> due to a call to a non-const member function.</db:para>
<db:section xml:id="stl-style-iterators">
<db:title>STL-Style Iterators</db:title>
<db:para>STL-style iterators have been available since the release of Qt 2.0. They are compatible with Qt's and STL's <db:link xlink:href="qtalgorithms.xml">generic algorithms</db:link> and are optimized for speed.</db:para>
<db:para>For each container class, there are two STL-style iterator types: one that provides read-only access and one that provides read-write access. Read-only iterators should be used wherever possible because they are faster than read-write iterators.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Containers</db:para>
</db:th>
<db:th>
<db:para>Read-only iterator</db:para>
</db:th>
<db:th>
<db:para>Read-write iterator</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, <db:link xlink:href="qstack.xml">QStack</db:link>&lt;T&gt;, <db:link xlink:href="qqueue.xml">QQueue</db:link>&lt;T&gt;</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;::const_iterator</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;::iterator</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt;</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt;::const_iterator</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt;::iterator</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmap.xml">QMap</db:link>&lt;Key, T&gt;, <db:link xlink:href="qmultimap.xml">QMultiMap</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmap.xml">QMap</db:link>&lt;Key, T&gt;::const_iterator</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmap.xml">QMap</db:link>&lt;Key, T&gt;::iterator</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;Key, T&gt;, <db:link xlink:href="qmultihash.xml">QMultiHash</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;Key, T&gt;::const_iterator</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;Key, T&gt;::iterator</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The API of the STL iterators is modelled on pointers in an array. For example, the ++ operator advances the iterator to the next item, and the * operator returns the item that the iterator points to. In fact, for <db:link xlink:href="qlist.xml">QList</db:link> and <db:link xlink:href="qstack.xml">QStack</db:link>, which store their items at adjacent memory positions, the <db:link xlink:href="qlist-iterator.xml">iterator</db:link> type is just a typedef for T *, and the <db:link xlink:href="qlist-iterator.xml">const_iterator</db:link> type is just a typedef for const T *.</db:para>
<db:para>In this discussion, we will concentrate on <db:link xlink:href="qlist.xml">QList</db:link> and <db:link xlink:href="qmap.xml">QMap</db:link>. The iterator types for <db:link xlink:href="qset.xml">QSet</db:link> have exactly the same interface as <db:link xlink:href="qlist.xml">QList</db:link>'s iterators; similarly, the iterator types for <db:link xlink:href="qhash.xml#qhash">QHash</db:link> have the same interface as <db:link xlink:href="qmap.xml">QMap</db:link>'s iterators.</db:para>
<db:para>Here's a typical loop for iterating through all the elements of a <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>&gt; in order and converting them to lowercase:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list;
list &amp;lt;&amp;lt; &quot;A&quot; &amp;lt;&amp;lt; &quot;B&quot; &amp;lt;&amp;lt; &quot;C&quot; &amp;lt;&amp;lt; &quot;D&quot;;

QList&amp;lt;QString&amp;gt;::iterator i;
for (i = list.begin(); i != list.end(); ++i)
    *i = (*i).toLower();
</db:programlisting>
<db:para>STL-style iterators point directly at items. The <db:link xlink:href="qlist.xml#begin">begin</db:link>() function of a container returns an iterator that points to the first item in the container. The <db:link xlink:href="qlist.xml#end">end</db:link>() function of a container returns an iterator to the imaginary item one position past the last item in the container. <db:link xlink:href="qlist.xml#end">end</db:link>() marks an invalid position; it must never be dereferenced. It is typically used in a loop's break condition. If the list is empty, <db:link xlink:href="qlist.xml#begin">begin</db:link>() equals <db:link xlink:href="qlist.xml#end">end</db:link>(), so we never execute the loop.</db:para>
<db:para>The diagram below shows the valid iterator positions as red arrows for a list containing four items:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/stliterators1.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Iterating backward with an STL-style iterator is done with reverse iterators:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; list;
list &amp;lt;&amp;lt; &quot;A&quot; &amp;lt;&amp;lt; &quot;B&quot; &amp;lt;&amp;lt; &quot;C&quot; &amp;lt;&amp;lt; &quot;D&quot;;

QList&amp;lt;QString&amp;gt;::reverse_iterator i;
for (i = list.rbegin(); i != list.rend(); ++i)
    *i = i-&amp;gt;toLower();
</db:programlisting>
<db:para>In the code snippets so far, we used the unary * operator to retrieve the item (of type <db:link xlink:href="qstring.xml">QString</db:link>) stored at a certain iterator position, and we then called <db:link xlink:href="qstring.xml#toLower">QString::toLower</db:link>() on it. Most C++ compilers also allow us to write i-&gt;toLower(), but some don't.</db:para>
<db:para>For read-only access, you can use const_iterator, <db:link xlink:href="qlist.xml#constBegin">constBegin</db:link>(), and <db:link xlink:href="qlist.xml#constEnd">constEnd</db:link>(). For example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt;::const_iterator i;
for (i = list.constBegin(); i != list.constEnd(); ++i)
    qDebug() &amp;lt;&amp;lt; *i;
</db:programlisting>
<db:para>The following table summarizes the STL-style iterators' API:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Expression</db:para>
</db:th>
<db:th>
<db:para>Behavior</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>*i</db:para>
</db:td>
<db:td>
<db:para>Returns the current item</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>++i</db:para>
</db:td>
<db:td>
<db:para>Advances the iterator to the next item</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i += n</db:para>
</db:td>
<db:td>
<db:para>Advances the iterator by n items</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>--i</db:para>
</db:td>
<db:td>
<db:para>Moves the iterator back by one item</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i -= n</db:para>
</db:td>
<db:td>
<db:para>Moves the iterator back by n items</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>i - j</db:para>
</db:td>
<db:td>
<db:para>Returns the number of items between iterators i and j</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The ++ and -- operators are available both as prefix (++i, --i) and postfix (i++, i--) operators. The prefix versions modify the iterators and return a reference to the modified iterator; the postfix versions take a copy of the iterator before they modify it, and return that copy. In expressions where the return value is ignored, we recommend that you use the prefix operators (++i, --i), as these are slightly faster.</db:para>
<db:para>For non-const iterator types, the return value of the unary * operator can be used on the left side of the assignment operator.</db:para>
<db:para>For <db:link xlink:href="qmap.xml">QMap</db:link> and <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, the * operator returns the value component of an item. If you want to retrieve the key, call key() on the iterator. For symmetry, the iterator types also provide a value() function to retrieve the value. For example, here's how we would print all items in a <db:link xlink:href="qmap.xml">QMap</db:link> to the console:</db:para>
<db:programlisting language="cpp">QMap&amp;lt;int, int&amp;gt; map;
...
QMap&amp;lt;int, int&amp;gt;::const_iterator i;
for (i = map.constBegin(); i != map.constEnd(); ++i)
    qDebug() &amp;lt;&amp;lt; i.key() &amp;lt;&amp;lt; ':' &amp;lt;&amp;lt; i.value();
</db:programlisting>
<db:para>Thanks to <db:link xlink:href="implicit-sharing.xml">implicit sharing</db:link>, it is very inexpensive for a function to return a container per value. The Qt API contains dozens of functions that return a <db:link xlink:href="qlist.xml">QList</db:link> or <db:link xlink:href="qstringlist.xml">QStringList</db:link> per value (e.g., <db:link xlink:href="qsplitter.xml#sizes">QSplitter::sizes</db:link>()). If you want to iterate over these using an STL iterator, you should always take a copy of the container and iterate over the copy. For example:</db:para>
<db:programlisting language="cpp">// RIGHT
const QList&amp;lt;int&amp;gt; sizes = splitter-&amp;gt;sizes();
QList&amp;lt;int&amp;gt;::const_iterator i;
for (i = sizes.begin(); i != sizes.end(); ++i)
    ...

// WRONG
QList&amp;lt;int&amp;gt;::const_iterator i;
for (i = splitter-&amp;gt;sizes().begin();
        i != splitter-&amp;gt;sizes().end(); ++i)
    ...
</db:programlisting>
<db:para>This problem doesn't occur with functions that return a const or non-const reference to a container.</db:para>
<db:section xml:id="implicit-sharing-iterator-problem">
<db:title>Implicit sharing iterator problem</db:title>
<db:para><db:link xlink:href="implicit-sharing.xml">Implicit sharing</db:link> has another consequence on STL-style iterators: you should avoid copying a container while iterators are active on that container. The iterators point to an internal structure, and if you copy a container you should be very careful with your iterators. E.g:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; a, b;
a.resize(100000); // make a big list filled with 0.

QList&amp;lt;int&amp;gt;::iterator i = a.begin();
// WRONG way of using the iterator i:
b = a;
/*
    Now we should be careful with iterator i since it will point to shared data
    If we do *i = 4 then we would change the shared instance (both vectors)
    The behavior differs from STL containers. Avoid doing such things in Qt.
*/

a[0] = 5;
/*
    Container a is now detached from the shared data,
    and even though i was an iterator from the container a, it now works as an iterator in b.
    Here the situation is that (*i) == 0.
*/

b.clear(); // Now the iterator i is completely invalid.

int j = *i; // Undefined behavior!
/*
    The data from b (which i pointed to) is gone.
    This would be well-defined with STL containers (and (*i) == 5),
    but with QList this is likely to crash.
*/
</db:programlisting>
<db:para>The above example only shows a problem with <db:link xlink:href="qlist.xml">QList</db:link>, but the problem exists for all the implicitly shared Qt containers.</db:para>
</db:section>
</db:section>
<db:section xml:id="java-style-iterators">
<db:title>Java-Style Iterators</db:title>
<db:para><db:link xlink:href="java-style-iterators.xml#java-style-iterators">Java-Style iterators</db:link> were introduced in Qt 4. Their API is modelled on Java's iterator classes. New code should should prefer <db:link xlink:href="containers.xml#stl-style-iterators">STL-Style Iterators</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="container-keywords">
<db:title>Container keywords</db:title>
<db:anchor xml:id="foreach"/>
<db:section xml:id="the-foreach-keyword">
<db:title>The foreach Keyword</db:title>
<db:para><db:link xlink:href="foreach-keyword.xml#foreach-keyword">The foreach keyword</db:link> is discouraged, new code should prefer C++11 range-based loops.</db:para>
<db:anchor xml:id="forever"/>
</db:section>
<db:section xml:id="the-forever-keyword">
<db:title>The forever keyword.</db:title>
<db:para>In addition to foreach, Qt also provides a forever pseudo-keyword for infinite loops:</db:para>
<db:programlisting language="cpp">forever {
    ...
}
</db:programlisting>
<db:para>If you're worried about namespace pollution, you can disable these macros by adding the following line to your .pro file:</db:para>
<db:programlisting language="cpp">CONFIG += no_keywords
</db:programlisting>
<db:note>
<db:para>The alternative macros <db:link xlink:href="qtglobal.xml#Q_FOREACH">Q_FOREACH</db:link> and <db:link xlink:href="qtglobal.xml#Q_FOREVER">Q_FOREVER</db:link> remain defined regardless.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="qt-containers-compared-with-std-containers">
<db:title>Qt containers compared with std containers</db:title>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Qt container</db:para>
</db:th>
<db:th>
<db:para>Closest std container</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;</db:para>
</db:td>
<db:td>
<db:para>Similar to std::vector&lt;T&gt;</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> and <db:link xlink:href="qvector.xml">QVector</db:link> were unified in Qt 6. Both use the datamodel from <db:link xlink:href="qvector.xml">QVector</db:link>. <db:link xlink:href="qvector.xml">QVector</db:link> is now an alias to <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:para>This means that <db:link xlink:href="qlist.xml">QList</db:link> is not implemented as a linked list, so if you need constant time insert, delete, append or prepend, consider std::list&lt;T&gt;. See <db:link xlink:href="qlist.xml">QList</db:link> for details.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>&lt;T, Prealloc&gt;</db:para>
</db:td>
<db:td>
<db:para>Resembles a mix of std::array&lt;T&gt; and std::vector&lt;T&gt;.</db:para>
<db:para>For performance reasons, <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> lives on the stack unless resized. Resizing it automatically causes it to use the heap instead.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qstack.xml">QStack</db:link>&lt;T&gt;</db:para>
</db:td>
<db:td>
<db:para>Similar to std::stack&lt;T&gt;, inherits from <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qqueue.xml">QQueue</db:link>&lt;T&gt;</db:para>
</db:td>
<db:td>
<db:para>Similar to std::queue&lt;T&gt;, inherits from <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt;</db:para>
</db:td>
<db:td>
<db:para>Similar to std::set&lt;T&gt;. Internally, <db:link xlink:href="qset.xml">QSet</db:link> is implemented with a <db:link xlink:href="qhash.xml#qhash">QHash</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmap.xml">QMap</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para>Similar to std::map&lt;T&gt;.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmultimap.xml">QMultiMap</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para>Similar to std::multimap&lt;T&gt;.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para>Most similar to std::map&lt;T&gt;.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmultihash.xml">QMultiHash</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para>Most similar to std::multimap&lt;T&gt;.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="qt-containers-and-std-algorithms">
<db:title>Qt containers and std algorithms</db:title>
<db:para>You can used Qt containers with functions from #include &lt;algorithm&gt;.</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; list { 2, 3, 1 };

std::sort(list.begin(), list.end());
/*
    Sort the list, now contains { 1, 2, 3 }
*/

std::reverse(list.begin(), list.end());
/*
    Reverse the list, now contains { 3, 2, 1 }
*/

int even_elements =
        std::count_if(list.begin(), list.end(), [](int element) { return (element % 2 == 0); });
/*
    Count how many elements that are even numbers, 1
*/
</db:programlisting>
</db:section>
<db:section xml:id="other-container-like-classes">
<db:title>Other Container-Like Classes</db:title>
<db:para>Qt includes other template classes that resemble containers in some respects. These classes don't provide iterators and cannot be used with the foreach keyword.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qcache.xml">QCache</db:link>&lt;Key, T&gt; provides a cache to store objects of a certain type T associated with keys of type Key.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qcontiguouscache.xml">QContiguousCache</db:link>&lt;T&gt; provides an efficient way of caching data that is typically accessed in a contiguous way.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Additional non-template types that compete with Qt's template containers are <db:link xlink:href="qbitarray.xml">QBitArray</db:link>, <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, <db:link xlink:href="qstring.xml">QString</db:link>, and <db:link xlink:href="qstringlist.xml">QStringList</db:link>.</db:para>
</db:section>
<db:section xml:id="algorithmic-complexity">
<db:title>Algorithmic Complexity</db:title>
<db:para>Algorithmic complexity is concerned about how fast (or slow) each function is as the number of items in the container grow. For example, inserting an item in the middle of a std::list is an extremely fast operation, irrespective of the number of items stored in the list. On the other hand, inserting an item in the middle of a <db:link xlink:href="qlist.xml">QList</db:link> is potentially very expensive if the <db:link xlink:href="qlist.xml">QList</db:link> contains many items, since half of the items must be moved one position in memory.</db:para>
<db:para>To describe algorithmic complexity, we use the following terminology, based on the &quot;big Oh&quot; notation:</db:para>
<db:anchor xml:id="constant-time"/>
<db:anchor xml:id="logarithmic-time"/>
<db:anchor xml:id="linear-time"/>
<db:anchor xml:id="linear-logarithmic-time"/>
<db:anchor xml:id="quadratic-time"/>
<db:itemizedlist>
<db:listitem>
<db:para><db:emphasis role="bold">Constant time:</db:emphasis> O(1). A function is said to run in constant time if it requires the same amount of time no matter how many items are present in the container. One example is <db:link xlink:href="qlist.xml#push_back">QList::push_back</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Logarithmic time:</db:emphasis> O(log <db:emphasis>n</db:emphasis>). A function that runs in logarithmic time is a function whose running time is proportional to the logarithm of the number of items in the container. One example is the binary search algorithm.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Linear time:</db:emphasis> O(<db:emphasis>n</db:emphasis>). A function that runs in linear time will execute in a time directly proportional to the number of items stored in the container. One example is <db:link xlink:href="qlist.xml#insert">QList::insert</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Linear-logarithmic time:</db:emphasis> O(<db:emphasis>n</db:emphasis> log <db:emphasis>n</db:emphasis>). A function that runs in linear-logarithmic time is asymptotically slower than a linear-time function, but faster than a quadratic-time function.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Quadratic time:</db:emphasis> O(<db:emphasis>n</db:emphasis>Â²). A quadratic-time function executes in a time that is proportional to the square of the number of items stored in the container.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The following table summarizes the algorithmic complexity of the sequential container <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
</db:th>
<db:th>
<db:para>Index lookup</db:para>
</db:th>
<db:th>
<db:para>Insertion</db:para>
</db:th>
<db:th>
<db:para>Prepending</db:para>
</db:th>
<db:th>
<db:para>Appending</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;</db:para>
</db:td>
<db:td>
<db:para>O(1)</db:para>
</db:td>
<db:td>
<db:para>O(n)</db:para>
</db:td>
<db:td>
<db:para>O(n)</db:para>
</db:td>
<db:td>
<db:para>Amort. O(1)</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>In the table, &quot;Amort.&quot; stands for &quot;amortized behavior&quot;. For example, &quot;Amort. O(1)&quot; means that if you call the function only once, you might get O(<db:emphasis>n</db:emphasis>) behavior, but if you call it multiple times (e.g., <db:emphasis>n</db:emphasis> times), the average behavior will be O(1).</db:para>
<db:para>The following table summarizes the algorithmic complexity of Qt's associative containers and sets:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th rowspan="2">
</db:th>
<db:th colspan="2">
<db:para>Key lookup</db:para>
</db:th>
<db:th colspan="2">
<db:para>Insertion</db:para>
</db:th>
</db:tr>
<db:tr>
<db:th>
<db:para>Average</db:para>
</db:th>
<db:th>
<db:para>Worst case</db:para>
</db:th>
<db:th>
<db:para>Average</db:para>
</db:th>
<db:th>
<db:para>Worst case</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmap.xml">QMap</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para>O(log <db:emphasis>n</db:emphasis>)</db:para>
</db:td>
<db:td>
<db:para>O(log <db:emphasis>n</db:emphasis>)</db:para>
</db:td>
<db:td>
<db:para>O(log <db:emphasis>n</db:emphasis>)</db:para>
</db:td>
<db:td>
<db:para>O(log <db:emphasis>n</db:emphasis>)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmultimap.xml">QMultiMap</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para>O(log <db:emphasis>n</db:emphasis>)</db:para>
</db:td>
<db:td>
<db:para>O(log <db:emphasis>n</db:emphasis>)</db:para>
</db:td>
<db:td>
<db:para>O(log <db:emphasis>n</db:emphasis>)</db:para>
</db:td>
<db:td>
<db:para>O(log <db:emphasis>n</db:emphasis>)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;Key, T&gt;</db:para>
</db:td>
<db:td>
<db:para>Amort. O(1)</db:para>
</db:td>
<db:td>
<db:para>O(<db:emphasis>n</db:emphasis>)</db:para>
</db:td>
<db:td>
<db:para>Amort. O(1)</db:para>
</db:td>
<db:td>
<db:para>O(<db:emphasis>n</db:emphasis>)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qset.xml">QSet</db:link>&lt;Key&gt;</db:para>
</db:td>
<db:td>
<db:para>Amort. O(1)</db:para>
</db:td>
<db:td>
<db:para>O(<db:emphasis>n</db:emphasis>)</db:para>
</db:td>
<db:td>
<db:para>Amort. O(1)</db:para>
</db:td>
<db:td>
<db:para>O(<db:emphasis>n</db:emphasis>)</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>With <db:link xlink:href="qlist.xml">QList</db:link>, <db:link xlink:href="qhash.xml#qhash">QHash</db:link>, and <db:link xlink:href="qset.xml">QSet</db:link>, the performance of appending items is amortized O(log <db:emphasis>n</db:emphasis>). It can be brought down to O(1) by calling <db:link xlink:href="qlist.xml#reserve">QList::reserve</db:link>(), <db:link xlink:href="qhash.xml#reserve">QHash::reserve</db:link>(), or <db:link xlink:href="qset.xml#reserve">QSet::reserve</db:link>() with the expected number of items before you insert the items. The next section discusses this topic in more depth.</db:para>
</db:section>
<db:section xml:id="optimizations-for-primitive-and-relocatable-types">
<db:title>Optimizations for Primitive and Relocatable Types</db:title>
<db:para>Qt containers can use optimized code paths if the stored elements are relocatable or even primitive. However, whether types are primitive or relocatable cannot be detected in all cases. You can declare your types to be primitive or relocatable by using the <db:link xlink:href="qtglobal.xml#Q_DECLARE_TYPEINFO">Q_DECLARE_TYPEINFO</db:link> macro with the Q_PRIMITIVE_TYPE flag or the Q_RELOCATABLE_TYPE flag. See the documentation of <db:link xlink:href="qtglobal.xml#Q_DECLARE_TYPEINFO">Q_DECLARE_TYPEINFO</db:link> for further details and usage examples.</db:para>
<db:para>If you do not use <db:link xlink:href="qtglobal.xml#Q_DECLARE_TYPEINFO">Q_DECLARE_TYPEINFO</db:link>, Qt will use <db:link xlink:href="https://en.cppreference.com/w/cpp/types/is_trivial">std::is_trivial_v&lt;T&gt;</db:link> to indentify primitive types and it will require both <db:link xlink:href="https://en.cppreference.com/w/cpp/types/is_trivially_copyable">std::is_trivially_copyable_v&lt;T&gt;</db:link> and <db:link xlink:href="https://en.cppreference.com/w/cpp/types/is_destructible">std::is_trivially_destructible_v&lt;T&gt;</db:link> to identify relocatable types. This is always a safe choice, albeit of maybe suboptimal performance.</db:para>
</db:section>
<db:section xml:id="growth-strategies">
<db:title>Growth Strategies</db:title>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, <db:link xlink:href="qstring.xml">QString</db:link>, and <db:link xlink:href="qbytearray.xml">QByteArray</db:link> store their items contiguously in memory; <db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;Key, T&gt; keeps a hash table whose size is proportional to the number of items in the hash. To avoid reallocating the data every single time an item is added at the end of the container, these classes typically allocate more memory than necessary.</db:para>
<db:para>Consider the following code, which builds a <db:link xlink:href="qstring.xml">QString</db:link> from another <db:link xlink:href="qstring.xml">QString</db:link>:</db:para>
<db:programlisting language="cpp">QString onlyLetters(const QString &amp;amp;in)
{
    QString out;
    for (int j = 0; j &amp;lt; in.size(); ++j) {
        if (in[j].isLetter())
            out += in[j];
    }
    return out;
}
</db:programlisting>
<db:para>We build the string out dynamically by appending one character to it at a time. Let's assume that we append 15000 characters to the <db:link xlink:href="qstring.xml">QString</db:link> string. Then the following 11 reallocations (out of a possible 15000) occur when <db:link xlink:href="qstring.xml">QString</db:link> runs out of space: 8, 24, 56, 120, 248, 504, 1016, 2040, 4088, 8184, 16376. At the end, the <db:link xlink:href="qstring.xml">QString</db:link> has 16376 Unicode characters allocated, 15000 of which are occupied.</db:para>
<db:para>The values above may seem a bit strange, but there is a guiding principle. It advances by doubling the size each time. More precisely, it advances to the next power of two, minus 16 bytes. 16 bytes corresponds to eight characters, as <db:link xlink:href="qstring.xml">QString</db:link> uses UTF-16 internally.</db:para>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link> uses the same algorithm as <db:link xlink:href="qstring.xml">QString</db:link>, but 16 bytes correspond to 16 characters.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; also uses that algorithm, but 16 bytes correspond to 16/sizeof(T) elements.</db:para>
<db:para><db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;Key, T&gt; is a totally different case. <db:link xlink:href="qhash.xml#qhash">QHash</db:link>'s internal hash table grows by powers of two, and each time it grows, the items are relocated in a new bucket, computed as <db:link xlink:href="qhash.xml#qhash">qHash</db:link>(<db:emphasis>key</db:emphasis>) % <db:link xlink:href="qhash.xml#capacity">QHash::capacity</db:link>() (the number of buckets). This remark applies to <db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt; and <db:link xlink:href="qcache.xml">QCache</db:link>&lt;Key, T&gt; as well.</db:para>
<db:para>For most applications, the default growing algorithm provided by Qt does the trick. If you need more control, <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, <db:link xlink:href="qhash.xml#qhash">QHash</db:link>&lt;Key, T&gt;, <db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt;, <db:link xlink:href="qstring.xml">QString</db:link>, and <db:link xlink:href="qbytearray.xml">QByteArray</db:link> provide a trio of functions that allow you to check and specify how much memory to use to store the items:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qstring.xml#capacity">capacity</db:link>() returns the number of items for which memory is allocated (for <db:link xlink:href="qhash.xml#qhash">QHash</db:link> and <db:link xlink:href="qset.xml">QSet</db:link>, the number of buckets in the hash table).</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qstring.xml#reserve">reserve</db:link>(<db:emphasis>size</db:emphasis>) explicitly preallocates memory for <db:emphasis>size</db:emphasis> items.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qstring.xml#squeeze">squeeze</db:link>() frees any memory not required to store the items.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>If you know approximately how many items you will store in a container, you can start by calling <db:link xlink:href="qstring.xml#reserve">reserve</db:link>(), and when you are done populating the container, you can call <db:link xlink:href="qstring.xml#squeeze">squeeze</db:link>() to release the extra preallocated memory.</db:para>
</db:section>
</db:article>
