<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QVideoFrame Class</db:title>
<db:productname>QtMultimedia</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Multimedia Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> class represents a frame of video data.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QVideoFrame</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += multimedia</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QVideoFrame is part of <db:simplelist><db:member>multimedia</db:member><db:member>multimedia_video</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> encapsulates the pixel data of a video frame, and information about the frame.</db:para>
<db:para>Video frames can come from several places - decoded <db:link xlink:href="qmediaplayer.xml">media</db:link>, a <db:link xlink:href="qcamera.xml">camera</db:link>, or generated programmatically. The way pixels are described in these frames can vary greatly, and some pixel formats offer greater compression opportunities at the expense of ease of use.</db:para>
<db:para>The pixel contents of a video frame can be mapped to memory using the <db:link xlink:href="qvideoframe.xml#map">map</db:link>() function. While mapped, the video data can accessed using the <db:link xlink:href="qvideoframe.xml#bits">bits</db:link>() function, which returns a pointer to a buffer. The total size of this buffer is given by the <db:link xlink:href="qvideoframe.xml#mappedBytes">mappedBytes</db:link>() function, and the size of each line is given by <db:link xlink:href="qvideoframe.xml#bytesPerLine">bytesPerLine</db:link>(). The return value of the <db:link xlink:href="qvideoframe.xml#handle">handle</db:link>() function may also be used to access frame data using the internal buffer's native APIs (for example - an OpenGL texture handle).</db:para>
<db:para>A video frame can also have timestamp information associated with it. These timestamps can be used by an implementation of <db:link xlink:href="qabstractvideosurface.xml">QAbstractVideoSurface</db:link> to determine when to start and stop displaying the frame, but not all surfaces might respect this setting.</db:para>
<db:para>The video pixel data in a <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> is encapsulated in a <db:link xlink:href="qabstractvideobuffer.xml">QAbstractVideoBuffer</db:link>. A <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> may be constructed from any buffer type by subclassing the <db:link xlink:href="qabstractvideobuffer.xml">QAbstractVideoBuffer</db:link> class.</db:para>
<db:note>
<db:para>Since video frames can be expensive to copy, <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> is explicitly shared, so any change made to a video frame will also apply to any copies.</db:para>
</db:note>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="FieldType-enum">
<db:title>enum QVideoFrame::FieldType</db:title>
<db:para>Specifies the field an interlaced video frame belongs to.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::ProgressiveFrame</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The frame is not interlaced.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::TopField</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The frame contains a top field.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::BottomField</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The frame contains a bottom field.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::InterlacedFrame</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The frame contains a merged top and bottom field.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="PixelFormat-enum">
<db:title>enum QVideoFrame::PixelFormat</db:title>
<db:para>Enumerates video data types.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_Invalid</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The frame is invalid.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_ARGB32</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 32-bit ARGB format (0xAARRGGBB). This is equivalent to <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_ARGB32</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_ARGB32_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The frame stored using a premultiplied 32-bit ARGB format (0xAARRGGBB). This is equivalent to <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_ARGB32_Premultiplied</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_RGB32</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The frame stored using a 32-bit RGB format (0xffRRGGBB). This is equivalent to <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_RGB32</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_RGB24</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 24-bit RGB format (8-8-8). This is equivalent to <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_RGB888</db:link></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_RGB565</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 16-bit RGB format (5-6-5). This is equivalent to <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_RGB16</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_RGB555</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 16-bit RGB format (5-5-5). This is equivalent to <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_RGB555</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_ARGB8565_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 24-bit premultiplied ARGB format (8-5-6-5).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_BGRA32</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 32-bit BGRA format (0xBBGGRRAA).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_BGRA32_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>The frame is stored using a premultiplied 32bit BGRA format.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_BGR32</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 32-bit BGR format (0xBBGGRRff).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_BGR24</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 24-bit BGR format (0xBBGGRR).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_BGR565</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 16-bit BGR format (5-6-5).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_BGR555</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 16-bit BGR format (5-5-5).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_BGRA5658_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 24-bit premultiplied BGRA format (5-6-5-8).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_AYUV444</db:code></db:para>
</db:td>
<db:td><db:code>15</db:code></db:td>
<db:td>
<db:para>The frame is stored using a packed 32-bit AYUV format (0xAAYYUUVV).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_AYUV444_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>16</db:code></db:td>
<db:td>
<db:para>The frame is stored using a packed premultiplied 32-bit AYUV format (0xAAYYUUVV).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_YUV444</db:code></db:para>
</db:td>
<db:td><db:code>17</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 24-bit packed YUV format (8-8-8).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_YUV420P</db:code></db:para>
</db:td>
<db:td><db:code>18</db:code></db:td>
<db:td>
<db:para>The frame is stored using an 8-bit per component planar YUV format with the U and V planes horizontally and vertically sub-sampled, i.e. the height and width of the U and V planes are half that of the Y plane.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_YV12</db:code></db:para>
</db:td>
<db:td><db:code>19</db:code></db:td>
<db:td>
<db:para>The frame is stored using an 8-bit per component planar YVU format with the V and U planes horizontally and vertically sub-sampled, i.e. the height and width of the V and U planes are half that of the Y plane.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_UYVY</db:code></db:para>
</db:td>
<db:td><db:code>20</db:code></db:td>
<db:td>
<db:para>The frame is stored using an 8-bit per component packed YUV format with the U and V planes horizontally sub-sampled (U-Y-V-Y), i.e. two horizontally adjacent pixels are stored as a 32-bit macropixel which has a Y value for each pixel and common U and V values.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_YUYV</db:code></db:para>
</db:td>
<db:td><db:code>21</db:code></db:td>
<db:td>
<db:para>The frame is stored using an 8-bit per component packed YUV format with the U and V planes horizontally sub-sampled (Y-U-Y-V), i.e. two horizontally adjacent pixels are stored as a 32-bit macropixel which has a Y value for each pixel and common U and V values.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_NV12</db:code></db:para>
</db:td>
<db:td><db:code>22</db:code></db:td>
<db:td>
<db:para>The frame is stored using an 8-bit per component semi-planar YUV format with a Y plane (Y) followed by a horizontally and vertically sub-sampled, packed UV plane (U-V).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_NV21</db:code></db:para>
</db:td>
<db:td><db:code>23</db:code></db:td>
<db:td>
<db:para>The frame is stored using an 8-bit per component semi-planar YUV format with a Y plane (Y) followed by a horizontally and vertically sub-sampled, packed VU plane (V-U).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_IMC1</db:code></db:para>
</db:td>
<db:td><db:code>24</db:code></db:td>
<db:td>
<db:para>The frame is stored using an 8-bit per component planar YUV format with the U and V planes horizontally and vertically sub-sampled. This is similar to the Format_YUV420P type, except that the bytes per line of the U and V planes are padded out to the same stride as the Y plane.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_IMC2</db:code></db:para>
</db:td>
<db:td><db:code>25</db:code></db:td>
<db:td>
<db:para>The frame is stored using an 8-bit per component planar YUV format with the U and V planes horizontally and vertically sub-sampled. This is similar to the Format_YUV420P type, except that the lines of the U and V planes are interleaved, i.e. each line of U data is followed by a line of V data creating a single line of the same stride as the Y data.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_IMC3</db:code></db:para>
</db:td>
<db:td><db:code>26</db:code></db:td>
<db:td>
<db:para>The frame is stored using an 8-bit per component planar YVU format with the V and U planes horizontally and vertically sub-sampled. This is similar to the Format_YV12 type, except that the bytes per line of the V and U planes are padded out to the same stride as the Y plane.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_IMC4</db:code></db:para>
</db:td>
<db:td><db:code>27</db:code></db:td>
<db:td>
<db:para>The frame is stored using an 8-bit per component planar YVU format with the V and U planes horizontally and vertically sub-sampled. This is similar to the Format_YV12 type, except that the lines of the V and U planes are interleaved, i.e. each line of V data is followed by a line of U data creating a single line of the same stride as the Y data.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_Y8</db:code></db:para>
</db:td>
<db:td><db:code>28</db:code></db:td>
<db:td>
<db:para>The frame is stored using an 8-bit greyscale format.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_Y16</db:code></db:para>
</db:td>
<db:td><db:code>29</db:code></db:td>
<db:td>
<db:para>The frame is stored using a 16-bit linear greyscale format. Little endian.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_Jpeg</db:code></db:para>
</db:td>
<db:td><db:code>30</db:code></db:td>
<db:td>
<db:para>The frame is stored in compressed Jpeg format.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_CameraRaw</db:code></db:para>
</db:td>
<db:td><db:code>31</db:code></db:td>
<db:td>
<db:para>The frame is stored using a device specific camera raw format.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_AdobeDng</db:code></db:para>
</db:td>
<db:td><db:code>32</db:code></db:td>
<db:td>
<db:para>The frame is stored using raw Adobe Digital Negative (DNG) format.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link></db:emphasis>::Format_User</db:code></db:para>
</db:td>
<db:td><db:code>1000</db:code></db:td>
<db:td>
<db:para>Start value for user defined pixel formats.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QVideoFrame">
<db:title>QVideoFrame::QVideoFrame()</db:title>
<db:para>Constructs a null video frame.</db:para>
</db:section>
<db:section xml:id="QVideoFrame-1">
<db:title>QVideoFrame::QVideoFrame(const QImage &amp;<db:emphasis>image</db:emphasis>)</db:title>
<db:para>Constructs a video frame from an <db:code role="parameter">image</db:code>.</db:para>
<db:note>
<db:para>This will construct an invalid video frame if there is no frame type equivalent to the image format.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#pixelFormatFromImageFormat">pixelFormatFromImageFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVideoFrame-3">
<db:title>QVideoFrame::QVideoFrame(QAbstractVideoBuffer *<db:emphasis>buffer</db:emphasis>, const QSize &amp;<db:emphasis>size</db:emphasis>, QVideoFrame::PixelFormat <db:emphasis>format</db:emphasis>)</db:title>
<db:para>Constructs a video frame from a <db:code role="parameter">buffer</db:code> with the given pixel <db:code role="parameter">format</db:code> and <db:code role="parameter">size</db:code> in pixels.</db:para>
<db:note>
<db:para>This doesn't increment the reference count of the video buffer.</db:para>
</db:note>
</db:section>
<db:section xml:id="QVideoFrame-4">
<db:title>QVideoFrame::QVideoFrame(int <db:emphasis>bytes</db:emphasis>, const QSize &amp;<db:emphasis>size</db:emphasis>, int <db:emphasis>bytesPerLine</db:emphasis>, QVideoFrame::PixelFormat <db:emphasis>format</db:emphasis>)</db:title>
<db:para>Constructs a video frame of the given pixel <db:code role="parameter">format</db:code> and <db:code role="parameter">size</db:code> in pixels.</db:para>
<db:para>The <db:code role="parameter">bytesPerLine</db:code> (stride) is the length of each scan line in bytes, and <db:code role="parameter">bytes</db:code> is the total number of bytes that must be allocated for the frame.</db:para>
</db:section>
<db:section xml:id="QVideoFrame-2">
<db:title>QVideoFrame::QVideoFrame(const QVideoFrame &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Constructs a shallow copy of <db:code role="parameter">other</db:code>. Since <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> is explicitly shared, these two instances will reflect the same frame.</db:para>
</db:section>
<db:section xml:id="dtor.QVideoFrame">
<db:title>[noexcept] QVideoFrame::~QVideoFrame()</db:title>
<db:para>Destroys a video frame.</db:para>
</db:section>
<db:section xml:id="availableMetaData">
<db:title>QVariantMap QVideoFrame::availableMetaData() const</db:title>
<db:para>Returns any extra metadata associated with this frame.</db:para>
</db:section>
<db:section xml:id="bits">
<db:title>uchar *QVideoFrame::bits()</db:title>
<db:para>Returns a pointer to the start of the frame data buffer.</db:para>
<db:para>This value is only valid while the frame data is <db:link xlink:href="qvideoframe.xml#map">mapped</db:link>.</db:para>
<db:para>Changes made to data accessed via this pointer (when mapped with write access) are only guaranteed to have been persisted when <db:link xlink:href="qvideoframe.xml#unmap">unmap</db:link>() is called and when the buffer has been mapped for writing.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#mappedBytes">mappedBytes</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#bytesPerLine">bytesPerLine</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bits-1">
<db:title>const uchar *QVideoFrame::bits() const</db:title>
<db:para>Returns a pointer to the start of the frame data buffer.</db:para>
<db:para>This value is only valid while the frame data is <db:link xlink:href="qvideoframe.xml#map">mapped</db:link>.</db:para>
<db:para>If the buffer was not mapped with read access, the contents of this buffer will initially be uninitialized.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#mappedBytes">mappedBytes</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#bytesPerLine">bytesPerLine</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bits-2">
<db:title>[since 5.4] uchar *QVideoFrame::bits(int <db:emphasis>plane</db:emphasis>)</db:title>
<db:para>Returns a pointer to the start of the frame data buffer for a <db:code role="parameter">plane</db:code>.</db:para>
<db:para>This value is only valid while the frame data is <db:link xlink:href="qvideoframe.xml#map">mapped</db:link>.</db:para>
<db:para>Changes made to data accessed via this pointer (when mapped with write access) are only guaranteed to have been persisted when <db:link xlink:href="qvideoframe.xml#unmap">unmap</db:link>() is called and when the buffer has been mapped for writing.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#mappedBytes">mappedBytes</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#bytesPerLine">bytesPerLine</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#planeCount">planeCount</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bits-3">
<db:title>[since 5.4] const uchar *QVideoFrame::bits(int <db:emphasis>plane</db:emphasis>) const</db:title>
<db:para>Returns a pointer to the start of the frame data buffer for a <db:code role="parameter">plane</db:code>.</db:para>
<db:para>This value is only valid while the frame data is <db:link xlink:href="qvideoframe.xml#map">mapped</db:link>.</db:para>
<db:para>If the buffer was not mapped with read access, the contents of this buffer will initially be uninitialized.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#mappedBytes">mappedBytes</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#bytesPerLine">bytesPerLine</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#planeCount">planeCount</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesPerLine">
<db:title>int QVideoFrame::bytesPerLine() const</db:title>
<db:para>Returns the number of bytes in a scan line.</db:para>
<db:note>
<db:para>For planar formats this is the bytes per line of the first plane only. The bytes per line of subsequent planes should be calculated as per the frame <db:link xlink:href="qvideoframe.xml#PixelFormat-enum">pixel format</db:link>.</db:para>
</db:note>
<db:para>This value is only valid while the frame data is <db:link xlink:href="qvideoframe.xml#map">mapped</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#bits">bits</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#mappedBytes">mappedBytes</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesPerLine-1">
<db:title>[since 5.4] int QVideoFrame::bytesPerLine(int <db:emphasis>plane</db:emphasis>) const</db:title>
<db:para>Returns the number of bytes in a scan line of a <db:code role="parameter">plane</db:code>.</db:para>
<db:para>This value is only valid while the frame data is <db:link xlink:href="qvideoframe.xml#map">mapped</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#bits">bits</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#mappedBytes">mappedBytes</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#planeCount">planeCount</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="endTime">
<db:title>qint64 QVideoFrame::endTime() const</db:title>
<db:para>Returns the presentation time (in microseconds) when a frame should stop being displayed.</db:para>
<db:para>An invalid time is represented as -1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#setEndTime">setEndTime</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fieldType">
<db:title>QVideoFrame::FieldType QVideoFrame::fieldType() const</db:title>
<db:para>Returns the field an interlaced video frame belongs to.</db:para>
<db:para>If the video is not interlaced this will return WholeFrame.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#setFieldType">setFieldType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="handle">
<db:title>QVariant QVideoFrame::handle() const</db:title>
<db:para>Returns a type specific handle to a video frame's buffer.</db:para>
<db:para>For an OpenGL texture this would be the texture ID.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractvideobuffer.xml#handle">QAbstractVideoBuffer::handle</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="handleType">
<db:title>QAbstractVideoBuffer::HandleType QVideoFrame::handleType() const</db:title>
<db:para>Returns the type of a video frame's handle.</db:para>
</db:section>
<db:section xml:id="height">
<db:title>int QVideoFrame::height() const</db:title>
<db:para>Returns the height of a video frame.</db:para>
</db:section>
<db:section xml:id="imageFormatFromPixelFormat">
<db:title>[static] QImage::Format QVideoFrame::imageFormatFromPixelFormat(QVideoFrame::PixelFormat <db:emphasis>format</db:emphasis>)</db:title>
<db:para>Returns an image format equivalent to a video frame pixel <db:code role="parameter">format</db:code>. If there is no equivalent format <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_Invalid</db:link> is returned instead.</db:para>
<db:note>
<db:para>In general <db:link xlink:href="qimage.xml">QImage</db:link> does not handle YUV formats.</db:para>
</db:note>
</db:section>
<db:section xml:id="isMapped">
<db:title>bool QVideoFrame::isMapped() const</db:title>
<db:para>Identifies if a video frame's contents are currently mapped to system memory.</db:para>
<db:para>This is a convenience function which checks that the <db:link xlink:href="qabstractvideobuffer.xml#MapMode-enum">MapMode</db:link> of the frame is not equal to <db:link xlink:href="qabstractvideobuffer.xml#MapMode-enum">QAbstractVideoBuffer::NotMapped</db:link>.</db:para>
<db:para>Returns true if the contents of the video frame are mapped to system memory, and false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#mapMode">mapMode</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractvideobuffer.xml#MapMode-enum">QAbstractVideoBuffer::MapMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isReadable">
<db:title>bool QVideoFrame::isReadable() const</db:title>
<db:para>Identifies if the mapped contents of a video frame were read from the frame when it was mapped.</db:para>
<db:para>This is a convenience function which checks if the <db:link xlink:href="qabstractvideobuffer.xml#MapMode-enum">MapMode</db:link> contains the <db:link xlink:href="qabstractvideobuffer.xml#MapMode-enum">QAbstractVideoBuffer::WriteOnly</db:link> flag.</db:para>
<db:para>Returns true if the contents of the mapped memory were read from the video frame, and false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#mapMode">mapMode</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractvideobuffer.xml#MapMode-enum">QAbstractVideoBuffer::MapMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QVideoFrame::isValid() const</db:title>
<db:para>Identifies whether a video frame is valid.</db:para>
<db:para>An invalid frame has no video buffer associated with it.</db:para>
<db:para>Returns true if the frame is valid, and false if it is not.</db:para>
</db:section>
<db:section xml:id="isWritable">
<db:title>bool QVideoFrame::isWritable() const</db:title>
<db:para>Identifies if the mapped contents of a video frame will be persisted when the frame is unmapped.</db:para>
<db:para>This is a convenience function which checks if the <db:link xlink:href="qabstractvideobuffer.xml#MapMode-enum">MapMode</db:link> contains the <db:link xlink:href="qabstractvideobuffer.xml#MapMode-enum">QAbstractVideoBuffer::WriteOnly</db:link> flag.</db:para>
<db:para>Returns true if the video frame will be updated when unmapped, and false otherwise.</db:para>
<db:note>
<db:para>The result of altering the data of a frame that is mapped in read-only mode is undefined. Depending on the buffer implementation the changes may be persisted, or worse alter a shared buffer.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#mapMode">mapMode</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractvideobuffer.xml#MapMode-enum">QAbstractVideoBuffer::MapMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="map">
<db:title>bool QVideoFrame::map(QAbstractVideoBuffer::MapMode <db:emphasis>mode</db:emphasis>)</db:title>
<db:para>Maps the contents of a video frame to system (CPU addressable) memory.</db:para>
<db:para>In some cases the video frame data might be stored in video memory or otherwise inaccessible memory, so it is necessary to map a frame before accessing the pixel data. This may involve copying the contents around, so avoid mapping and unmapping unless required.</db:para>
<db:para>The map <db:code role="parameter">mode</db:code> indicates whether the contents of the mapped memory should be read from and/or written to the frame. If the map mode includes the <db:code>QAbstractVideoBuffer::ReadOnly</db:code> flag the mapped memory will be populated with the content of the video frame when initially mapped. If the map mode includes the <db:code>QAbstractVideoBuffer::WriteOnly</db:code> flag the content of the possibly modified mapped memory will be written back to the frame when unmapped.</db:para>
<db:para>While mapped the contents of a video frame can be accessed directly through the pointer returned by the <db:link xlink:href="qvideoframe.xml#bits">bits</db:link>() function.</db:para>
<db:para>When access to the data is no longer needed, be sure to call the <db:link xlink:href="qvideoframe.xml#unmap">unmap</db:link>() function to release the mapped memory and possibly update the video frame contents.</db:para>
<db:para>If the video frame has been mapped in read only mode, it is permissible to map it multiple times in read only mode (and unmap it a corresponding number of times). In all other cases it is necessary to unmap the frame first before mapping a second time.</db:para>
<db:note>
<db:para>Writing to memory that is mapped as read-only is undefined, and may result in changes to shared data or crashes.</db:para>
</db:note>
<db:para>Returns true if the frame was mapped to memory in the given <db:code role="parameter">mode</db:code> and false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#unmap">unmap</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#mapMode">mapMode</db:link>()</db:member>
<db:member><db:link xlink:href="qvideoframe.xml#bits">bits</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapMode">
<db:title>QAbstractVideoBuffer::MapMode QVideoFrame::mapMode() const</db:title>
<db:para>Returns the mode a video frame was mapped to system memory in.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractvideobuffer.xml#MapMode-enum">QAbstractVideoBuffer::MapMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mappedBytes">
<db:title>int QVideoFrame::mappedBytes() const</db:title>
<db:para>Returns the number of bytes occupied by the mapped frame data.</db:para>
<db:para>This value is only valid while the frame data is <db:link xlink:href="qvideoframe.xml#map">mapped</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#map">map</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="metaData">
<db:title>QVariant QVideoFrame::metaData(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns any metadata for this frame for the given <db:code role="parameter">key</db:code>.</db:para>
<db:para>This might include frame specific information from a camera, or subtitles from a decoded video stream.</db:para>
<db:para>See the documentation for the relevant video frame producer for further information about available metadata.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#setMetaData">setMetaData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pixelFormat">
<db:title>QVideoFrame::PixelFormat QVideoFrame::pixelFormat() const</db:title>
<db:para>Returns the color format of a video frame.</db:para>
</db:section>
<db:section xml:id="pixelFormatFromImageFormat">
<db:title>[static] QVideoFrame::PixelFormat QVideoFrame::pixelFormatFromImageFormat(QImage::Format <db:emphasis>format</db:emphasis>)</db:title>
<db:para>Returns a video pixel format equivalent to an image <db:code role="parameter">format</db:code>. If there is no equivalent format QVideoFrame::InvalidType is returned instead.</db:para>
<db:note>
<db:para>In general <db:link xlink:href="qimage.xml">QImage</db:link> does not handle YUV formats.</db:para>
</db:note>
</db:section>
<db:section xml:id="planeCount">
<db:title>[since 5.4] int QVideoFrame::planeCount() const</db:title>
<db:para>Returns the number of planes in the video frame.</db:para>
<db:para>This value is only valid while the frame data is <db:link xlink:href="qvideoframe.xml#map">mapped</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#map">map</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setEndTime">
<db:title>void QVideoFrame::setEndTime(qint64 <db:emphasis>time</db:emphasis>)</db:title>
<db:para>Sets the presentation <db:code role="parameter">time</db:code> (in microseconds) when a frame should stop being displayed.</db:para>
<db:para>An invalid time is represented as -1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#endTime">endTime</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFieldType">
<db:title>void QVideoFrame::setFieldType(QVideoFrame::FieldType <db:emphasis>field</db:emphasis>)</db:title>
<db:para>Sets the <db:code role="parameter">field</db:code> an interlaced video frame belongs to.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#fieldType">fieldType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMetaData">
<db:title>void QVideoFrame::setMetaData(const QString &amp;<db:emphasis>key</db:emphasis>, const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Sets the metadata for the given <db:code role="parameter">key</db:code> to <db:code role="parameter">value</db:code>.</db:para>
<db:para>If <db:code role="parameter">value</db:code> is a null variant, any metadata for this key will be removed.</db:para>
<db:para>The producer of the video frame might use this to associate certain data with this frame, or for an intermediate processor to add information for a consumer of this frame.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#metaData">metaData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setStartTime">
<db:title>void QVideoFrame::setStartTime(qint64 <db:emphasis>time</db:emphasis>)</db:title>
<db:para>Sets the presentation <db:code role="parameter">time</db:code> (in microseconds) when the frame should initially be displayed.</db:para>
<db:para>An invalid time is represented as -1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#startTime">startTime</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>QSize QVideoFrame::size() const</db:title>
<db:para>Returns the dimensions of a video frame.</db:para>
</db:section>
<db:section xml:id="startTime">
<db:title>qint64 QVideoFrame::startTime() const</db:title>
<db:para>Returns the presentation time (in microseconds) when the frame should be displayed.</db:para>
<db:para>An invalid time is represented as -1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#setStartTime">setStartTime</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unmap">
<db:title>void QVideoFrame::unmap()</db:title>
<db:para>Releases the memory mapped by the <db:link xlink:href="qvideoframe.xml#map">map</db:link>() function.</db:para>
<db:para>If the <db:link xlink:href="qabstractvideobuffer.xml#MapMode-enum">MapMode</db:link> included the <db:link xlink:href="qabstractvideobuffer.xml#MapMode-enum">QAbstractVideoBuffer::WriteOnly</db:link> flag this will persist the current content of the mapped memory to the video frame.</db:para>
<db:para>unmap() should not be called if <db:link xlink:href="qvideoframe.xml#map">map</db:link>() function failed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvideoframe.xml#map">map</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="width">
<db:title>int QVideoFrame::width() const</db:title>
<db:para>Returns the width of a video frame.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QVideoFrame::operator!=(const QVideoFrame &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> and <db:code role="parameter">other</db:code> do not reflect the same frame.</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QVideoFrame &amp;QVideoFrame::operator=(const QVideoFrame &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Assigns the contents of <db:code role="parameter">other</db:code> to this video frame. Since <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> is explicitly shared, these two instances will reflect the same frame.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QVideoFrame::operator==(const QVideoFrame &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> and <db:code role="parameter">other</db:code> reflect the same frame.</db:para>
</db:section>
</db:section>
</db:article>
