<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QAtomicScopedValueRollback Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QAtomicScopedValueRollback</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Provides a <db:link xlink:href="qscopedvaluerollback.xml">QScopedValueRollback</db:link> for atomic variables.</db:para>
<db:para>This class was introduced in Qt 6.7.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QAtomicScopedValueRollback</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.7</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QAtomicScopedValueRollback is part of <db:simplelist><db:member>misc</db:member><db:member>tools</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qatomicscopedvaluerollback.xml">QAtomicScopedValueRollback</db:link> class resets an atomic variable to its prior value on destruction. It can be used to revert state when an exception is thrown without the need to write try-catch blocks.</db:para>
<db:para>It can also be used to manage variables that are temporarily set, such as reentrancy guards. By using this class, the variable will be reset whether the function is exited normally, exited early by a return statement, or exited by an exception.</db:para>
<db:para>The class works on std::atomic and the Qt atomic classes: QBasicAtomicInteger, <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>, <db:link xlink:href="qatomicint.xml">QAtomicInt</db:link>, QBasicAtomicPointer and <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link>.</db:para>
<db:anchor xml:id="memory-order"/>
<db:para>The memory accesses to the atomic variable <db:code role="parameter">var</db:code> are specified using the value of mo. The memory order follows this mapping: </db:para>
<db:itemizedlist>
<db:listitem>
<db:para>When writing to the atomic variable:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>An acquire ordering performs a relaxed operation instead.</db:para>
</db:listitem>
<db:listitem>
<db:para>A hybrid acquire-release ordering performs a release operation instead.</db:para>
</db:listitem>
</db:itemizedlist>
</db:listitem>
<db:listitem>
<db:para>When reading from the atomic variable:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>A release ordering performs a relaxed operation instead.</db:para>
</db:listitem>
<db:listitem>
<db:para>A consume ordering performs a consume operation.</db:para>
</db:listitem>
<db:listitem>
<db:para>A hybrid acquire-release ordering performs an acquire operation instead.</db:para>
</db:listitem>
</db:itemizedlist>
</db:listitem>
</db:itemizedlist>
<db:para>Otherwise, the default memory order is sequential consistent ordering.</db:para>
<db:note>
<db:para>You should never name the template arguments explicitly, but exclusively use Class Template Argument Deduction (CTAD) and let the compiler pick the template argument.</db:para>
</db:note>
<db:note>
<db:para>There is a chance that other threads modify the variable too, which means you may lose updates performed by other threads between the call to the <db:link xlink:href="qatomicscopedvaluerollback.xml">QAtomicScopedValueRollback</db:link> constructor and <db:link xlink:href="qatomicscopedvaluerollback.xml#commit">commit</db:link>() or between <db:link xlink:href="qatomicscopedvaluerollback.xml#commit">commit</db:link>() and the destructor.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscopedvaluerollback.xml">QScopedValueRollback</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QAtomicScopedValueRollback">
<db:title>[explicit constexpr] QAtomicScopedValueRollback::QAtomicScopedValueRollback(QBasicAtomicInteger&lt;T&gt; &amp;<db:emphasis>var</db:emphasis>, std::memory_order <db:emphasis>mo</db:emphasis> = std::memory_order_seq_cst)</db:title>
<db:bridgehead renderas="sect2" xml:id="QAtomicScopedValueRollback-1">[explicit constexpr] QAtomicScopedValueRollback::QAtomicScopedValueRollback(QBasicAtomicPointer&lt;std::remove_pointer_t&lt;T&gt;&gt; &amp;<db:emphasis>var</db:emphasis>, std::memory_order <db:emphasis>mo</db:emphasis> = std::memory_order_seq_cst)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="QAtomicScopedValueRollback-2">[explicit constexpr] QAtomicScopedValueRollback::QAtomicScopedValueRollback(std::atomic&lt;T&gt; &amp;<db:emphasis>var</db:emphasis>, std::memory_order <db:emphasis>mo</db:emphasis> = std::memory_order_seq_cst)</db:bridgehead>
<db:para>Records the value of <db:code role="parameter">var</db:code> in order to restore it on destruction.</db:para>
<db:para>This is equivalent to:</db:para>
<db:programlisting language="cpp">T old_value = var.load(mo);
// And in the destructor: var.store(old_value, mo);
</db:programlisting>
<db:para>The mo adjustment for the load is described in the <db:link xlink:href="qatomicscopedvaluerollback.xml#memory-order">Memory Order</db:link> section.</db:para>
</db:section>
<db:section xml:id="QAtomicScopedValueRollback-3">
<db:title>[explicit constexpr] QAtomicScopedValueRollback::QAtomicScopedValueRollback(QBasicAtomicInteger&lt;T&gt; &amp;<db:emphasis>var</db:emphasis>, T <db:emphasis>value</db:emphasis>, std::memory_order <db:emphasis>mo</db:emphasis> = std::memory_order_seq_cst)</db:title>
<db:bridgehead renderas="sect2" xml:id="QAtomicScopedValueRollback-4">[explicit constexpr] QAtomicScopedValueRollback::QAtomicScopedValueRollback(QBasicAtomicPointer&lt;std::remove_pointer_t&lt;T&gt;&gt; &amp;<db:emphasis>var</db:emphasis>, T <db:emphasis>value</db:emphasis>, std::memory_order <db:emphasis>mo</db:emphasis> = std::memory_order_seq_cst)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="QAtomicScopedValueRollback-5">[explicit constexpr] QAtomicScopedValueRollback::QAtomicScopedValueRollback(std::atomic&lt;T&gt; &amp;<db:emphasis>var</db:emphasis>, T <db:emphasis>value</db:emphasis>, std::memory_order <db:emphasis>mo</db:emphasis> = std::memory_order_seq_cst)</db:bridgehead>
<db:para>Assigns <db:code role="parameter">value</db:code> to <db:code role="parameter">var</db:code> and stores the prior value of <db:code role="parameter">var</db:code> internally for reverting on destruction.</db:para>
<db:para>This is equivalent to:</db:para>
<db:programlisting language="cpp">T old_value = var.exchange(new_value, mo);
// And in the destructor: var.store(old_value, mo);
</db:programlisting>
</db:section>
<db:section xml:id="dtor.QAtomicScopedValueRollback">
<db:title>QAtomicScopedValueRollback::~QAtomicScopedValueRollback()</db:title>
<db:para>Restores the stored value that was current at construction time, or at the last call to <db:link xlink:href="qatomicscopedvaluerollback.xml#commit">commit</db:link>(), to the managed variable.</db:para>
<db:para>This is equivalent to:</db:para>
<db:programlisting language="cpp">// In the constructor: T old_value = var.load(mo);
// or: T old_value = exchange(new_value, mo);
var.store(old_value, mo);
</db:programlisting>
<db:para>Where mo is the same as the one initially passed to the constructor. See <db:link xlink:href="qatomicscopedvaluerollback.xml#memory-order">Memory Order</db:link> for the meaning of mo.</db:para>
</db:section>
<db:section xml:id="commit">
<db:title>void QAtomicScopedValueRollback::commit()</db:title>
<db:para>Updates the stored value to the managed variable's current value, loaded with the same memory order as on construction.</db:para>
<db:para>This updated value will be restored on destruction, instead of the original prior value.</db:para>
<db:para>This is equivalent to:</db:para>
<db:programlisting language="cpp">// Given constructor: T old_value = var.load(mo);
old_value = var.load(mo);  // referesh it
// And, in the destructor: var.store(old_value, mo);
</db:programlisting>
<db:para>Where mo is the same as the one initially passed to the constructor. See <db:link xlink:href="qatomicscopedvaluerollback.xml#memory-order">Memory Order</db:link> for the meaning of mo.</db:para>
</db:section>
</db:section>
</db:article>
