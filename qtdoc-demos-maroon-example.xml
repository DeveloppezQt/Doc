<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Quick Demo - Maroon in Trouble</db:title>
<db:productname>QtDoc</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A Qt Quick game for touch devices that uses <db:link xlink:href="qml-qtquick-spritesequence.xml">SpriteSequence</db:link>, <db:link xlink:href="qml-qtquick-particles-particlesystem.xml">ParticleSystem</db:link>, Emitter, and Wander types to animate objects and the <db:link xlink:href="qml-qtmultimedia-soundeffect.xml">SoundEffect</db:link> type to play sound effects.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquick-demo-maroon-med-2.png"/>
</db:imageobject>
</db:mediaobject>
<db:para><db:emphasis>Maroon in Trouble</db:emphasis> demonstrates QML features that are useful when developing games:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Using custom QML types to create different screens for different stages of the game.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using the <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> and <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> types to construct a game background.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using the <db:link xlink:href="qml-qtquick-sequentialanimation.xml">SequentialAnimation</db:link>, <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link>, <db:link xlink:href="qml-qtquick-particles-particlesystem.xml">ParticleSystem</db:link>, <db:link xlink:href="qml-qtquick-particles-emitter.xml">Emitter</db:link>, and <db:link xlink:href="qml-qtquick-particles-wander.xml">Wander</db:link> types to animate background objects.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using the <db:link xlink:href="qtquick-debugging.xml#timer">Timer</db:link> and <db:link xlink:href="qml-qtquick-repeater.xml">Repeater</db:link> types to display a countdown sequence before starting the game.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using a custom QML type with custom properties to construct a game board.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using the <db:link xlink:href="qml-qtquick-spritesequence.xml">SpriteSequence</db:link> and <db:link xlink:href="qml-qtquick-sprite.xml">Sprite</db:link> types to add animated objects to the game board.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using a custom QML type that uses the <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> type with some custom properties to add a menu where the players can buy objects.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using custom properties with private functions to keep track of game statistics and a custom QML type to display them to the players.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using the <db:link xlink:href="qml-qtqml-statemachine-state.xml">State</db:link> type with JavaScript functions to manage game states.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using the <db:link xlink:href="qml-qtmultimedia-soundeffect.xml">SoundEffect</db:link> type to play individual sound effects depending on the object type and the action applied to the object.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using signal handlers to specify keyboard shortcuts for some game actions.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using resource files to package game resources for deployment and delivery.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="http://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:emphasis role="bold">Welcome</db:emphasis> mode and select the example from <db:emphasis role="bold">Examples</db:emphasis>. For more information, visit <db:link xlink:href="http://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="adding-screens">
<db:title>Adding Screens</db:title>
<db:para>In the Maroon in Trouble app, we use the following custom types that are each defined in a separate .qml file to create the game screens:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>NewGameScreen.qml</db:para>
</db:listitem>
<db:listitem>
<db:para>GameCanvas.qml</db:para>
</db:listitem>
<db:listitem>
<db:para>GameOverScreen.qml</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>To use the custom types, we add an import statement to the main QML file, maroon.qml that imports the folder called content where the types are located:</db:para>
<db:programlisting language="cpp">import &quot;content&quot;
</db:programlisting>
<db:para>We use the screen types at different stages of the game. The NewGameScreen type is used to create the screen that appears when the players start the app. In NewGameScreen.qml, we use an <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> type to create a New Game button that the players can press to start a new game.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquick-demo-maroon-med-1.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Tapping the button initiates a countdown timer that triggers the creation of the game canvas by using the GameCanvas type. Another <db:link xlink:href="qtquick-debugging.xml#timer">Timer</db:link> type spawns mobs of fish inside bubbles that the players must free before they reach the surface. The players can tap on the screen to open a menu where they can buy different types of weapons (melee, ranged, and bombs) to burst the bubbles.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquick-demo-maroon-med-2.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>When the game finishes, a screen created by using the GameOverScreen type appears. On this screen, the players can see their score and start a new game.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquick-demo-maroon-med-3.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:para>The screens are all created on the same background and use some of the same images and animations.</db:para>
</db:section>
<db:section xml:id="constructing-the-background">
<db:title>Constructing the Background</db:title>
<db:para>In the maroon.qml file, we use an <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> type with the id root and a fixed width and height to create a main window for the game:</db:para>
<db:programlisting language="cpp">Item {
    id: root
    width: 320
    height: 480
    property var gameState
    property bool passedSplash: false
</db:programlisting>
<db:para>We declare two custom properties for the root item, gameState and passedSplash that we will use later to manage game states.</db:para>
<db:para>We use an <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> item to display the game background image:</db:para>
<db:programlisting language="cpp">    Image {
        source:&quot;content/gfx/background.png&quot;
        anchors.bottom: view.bottom
</db:programlisting>
<db:para>We want to be able to load the background image only once at app startup and still use different scenes for the game screens. Therefore, background.png is three times the length of the root item and displays a scene that stretches from the bottom of sea to the sky above the horizon.</db:para>
<db:para>We use the anchors.bottom property to anchor the background image to the bottom of the <db:link xlink:href="qml-qtquick-column.xml">Column</db:link> layout that we use to position the screens:</db:para>
<db:programlisting language="cpp">    Column {
        id: view
        y: -(height - 480)
        width: 320

        GameOverScreen { gameCanvas: canvas }
</db:programlisting>
<db:para>We set a negative value for the y property to set the first scene at the bottom of the sea. We calculate the position by subtracting the height of a screen from the height property.</db:para>
<db:para>Within the column layout, we use an <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> type to add objects to the background. Within the item, we use <db:link xlink:href="10-qdoc-commands-tablesandlists.xml#row">Row</db:link> layout objects to position <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> objects that display waves on the game canvas and the game over screen:</db:para>
<db:programlisting language="cpp">        Item {
            id: canvasArea
            width: 320
            height: 480

            Row {
                height: childrenRect.height
                Image {
                    id: wave
                    y: 30
                    source:&quot;content/gfx/wave.png&quot;
                }
                Image {
                    y: 30
                    source:&quot;content/gfx/wave.png&quot;
                }
    ...
            Row {
                opacity: 0.5
                Image {
                    id: wave2
                    y: 25
                    source: &quot;content/gfx/wave.png&quot;
                }
                Image {
                    y: 25
                    source: &quot;content/gfx/wave.png&quot;
                }
</db:programlisting>
<db:para>The second row of waves is positioned on the y axis with a slight offset to the first row. We also use the opacity property to make the waves appear lighter in color than the first two waves, which gives the background some depth.</db:para>
<db:para>We use <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> objects to also display sunlight on the new game screen and on the game canvas:</db:para>
<db:programlisting language="cpp">            Image {
                source: &quot;content/gfx/sunlight.png&quot;
                opacity: 0.02
                y: 0
                anchors.horizontalCenter: parent.horizontalCenter
    ...
            Image {
                source: &quot;content/gfx/sunlight.png&quot;
                opacity: 0.04
                y: 20
                anchors.horizontalCenter: parent.horizontalCenter
</db:programlisting>
<db:para>We set the opacity property of the images to 0.02 and 0.04 to give some depth to the rays of sunshine. We use the y property to position the images at fixed locations on the y axis and the anchors.horizontalCenter property to center them horizontally in relation to their parent.</db:para>
<db:para>We use an <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> type to display an image that adds a deepening shadow to the background:</db:para>
<db:programlisting language="cpp">            Image {
                source: &quot;content/gfx/grid.png&quot;
                opacity: 0.5
            }
</db:programlisting>
<db:para>We set the opacity property of the image to 0.5 to make the background visible behind the shadow.</db:para>
<db:para>To make the background more interesting, we animate some of the objects we added to it.</db:para>
</db:section>
<db:section xml:id="animating-background-objects">
<db:title>Animating Background Objects</db:title>
<db:para>We use <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link> to move the waves horizontally across the screen in opposite directions and <db:link xlink:href="qml-qtquick-sequentialanimation.xml">SequentialAnimation</db:link> with <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link> to move them up and down.</db:para>
<db:para>We apply the number animation to the x property of wave as a property value source to animate the x value from its current value to the -(wave.width), over 16 seconds. We set the loops property to Animation.Infinite to repeat the animation indefinitely:</db:para>
<db:programlisting language="cpp">                NumberAnimation on x { from: 0; to: -(wave.width); duration: 16000; loops: Animation.Infinite }
</db:programlisting>
<db:para>We apply the sequential animation to the y property of the image as a property value source to animate the y value. We use one number animation to animate the image from the y position of two below the value of y to two above it, over 1600 milliseconds. We use another number animation to subsequently animate the image in the opposite direction, again over 1600 milliseconds. The animation is repeated indefinitely:</db:para>
<db:programlisting language="cpp">                SequentialAnimation on y {
                    loops: Animation.Infinite
                    NumberAnimation { from: y - 2; to: y + 2; duration: 1600; easing.type: Easing.InOutQuad }
                    NumberAnimation { from: y + 2; to: y - 2; duration: 1600; easing.type: Easing.InOutQuad }
                }
</db:programlisting>
<db:para>We use the easing curve of the type Easing.InOutQuad for a quintic (t^5) function to accelerate the motion until halfway and then decelerate it.</db:para>
<db:para>We use sequential animation and number animation to animate wave2 similarly to wave, but in the opposite direction:</db:para>
<db:programlisting language="cpp">                SequentialAnimation on y {
                    loops: Animation.Infinite
                    NumberAnimation { from: y + 2; to: y - 2; duration: 1600; easing.type: Easing.InOutQuad }
                    NumberAnimation { from: y - 2; to: y + 2; duration: 1600; easing.type: Easing.InOutQuad }
                }
</db:programlisting>
<db:para>We use sequential animation to rotate the rays of sunlight in degrees clockwise around an origin point that we set to Item.Top in the transformOrigin property. The animation is repeated indefinitely:</db:para>
<db:programlisting language="cpp">                transformOrigin: Item.Top
                SequentialAnimation on rotation {
                    loops: Animation.Infinite
                    NumberAnimation { from: -10; to: 10; duration: 8000; easing.type: Easing.InOutSine }
                    NumberAnimation { from: 10; to: -10; duration: 8000; easing.type: Easing.InOutSine }
                }
</db:programlisting>
<db:para>We use one number animation to rotate the image from -10 degrees to 10 degrees over 8 seconds and another to subsequently rotate it from 10 degrees to -10 degrees over the same duration.</db:para>
<db:para>We use the easing curve of the type Easing.InOutSine for a sinusoidal (sin(t)) function to accelerate the motion until halfway and then decelerate it.</db:para>
<db:para>We use sequential animation and number animation to animate another sunlight.png image similarly, but in the opposite direction:</db:para>
<db:programlisting language="cpp">                transformOrigin: Item.Top
                SequentialAnimation on rotation {
                    loops: Animation.Infinite
                    NumberAnimation { from: 10; to: -10; duration: 8000; easing.type: Easing.InOutSine }
                    NumberAnimation { from: -10; to: 10; duration: 8000; easing.type: Easing.InOutSine }
                }
</db:programlisting>
<db:para>For examples of using <db:link xlink:href="qml-qtquick-sequentialanimation.xml">SequentialAnimation</db:link> and <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link> on the x and y properties and the width and height properties, see NewGameScreen.qml.</db:para>
</db:section>
<db:section xml:id="emitting-particles">
<db:title>Emitting Particles</db:title>
<db:para>In addition to animation, we use particles to generate motion on the game screens. We use the <db:link xlink:href="qml-qtquick-particles-particlesystem.xml">ParticleSystem</db:link> QML type in maroon.qml to make bubbles appear at the bottom of the new game screen and game canvas and slowly float towards the top on varying trajectories.</db:para>
<db:para>To use the <db:link xlink:href="qml-qtquick-particles-particlesystem.xml">ParticleSystem</db:link> type, we must import <db:link xlink:href="qtquick-particles-qmlmodule.xml">Qt Quick Particles QML Types</db:link>:</db:para>
<db:programlisting language="cpp">import QtQuick.Particles 2.0
</db:programlisting>
<db:para>To have the particles appear on the game background, we place the <db:link xlink:href="qml-qtquick-particles-particlesystem.xml">ParticleSystem</db:link> type within the <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> type that displays the game background:</db:para>
<db:programlisting language="cpp">    Image {
        source:&quot;content/gfx/background.png&quot;
        anchors.bottom: view.bottom

        ParticleSystem {
            id: particles
            anchors.fill: parent
</db:programlisting>
<db:para>In the <db:link xlink:href="qml-qtquick-particles-particlesystem.xml">ParticleSystem</db:link>, we use an <db:link xlink:href="qml-qtquick-particles-emitter.xml">Emitter</db:link> type to emit particles from the location of the emitter at the rate of two per second with the life span of 15 seconds:</db:para>
<db:programlisting language="cpp">            Emitter {
                width: parent.width
                height: 150
                anchors.bottom: parent.bottom
                anchors.bottomMargin: 3
                startTime: 15000

                emitRate: 2
                lifeSpan: 15000

                acceleration: PointDirection{ y: -6; xVariation: 2; yVariation: 2 }

                size: 24
                sizeVariation: 16
            }
</db:programlisting>
<db:para>The acceleration property uses the <db:link xlink:href="qml-qtquick-particles-pointdirection.xml">PointDirection</db:link> type to specify random variation of the x and y coordinates, so that the bubbles appear inside a rectangular area around the emitter that is anchored to the bottom of the image.</db:para>
<db:para>The size property sets the base size of the particles at the beginning of their life to 24 pixels and the sizeVariation property randomly increases or decreases the particle size by up to 16 pixels, so that we get bubbles in different sizes.</db:para>
<db:para>As emitters have no visualization, we use the <db:link xlink:href="qml-qtquick-particles-imageparticle.xml">ImageParticle</db:link> type to render the catch.png image at the particle location:</db:para>
<db:programlisting language="cpp">            ImageParticle {
                id: bubble
                anchors.fill: parent
                source: &quot;content/gfx/catch.png&quot;
                opacity: 0.25
            }
</db:programlisting>
<db:para>A <db:link xlink:href="qml-qtquick-particles-wander.xml">Wander</db:link> type applies a random trajectory to the particles, so that the bubbles follow random routes from the bottom to the top.</db:para>
<db:programlisting language="cpp">            Wander {
                xVariance: 25;
                pace: 25;
            }
</db:programlisting>
<db:para>For another example of using the <db:link xlink:href="qml-qtquick-particles-particlesystem.xml">ParticleSystem</db:link> type, see the GameOverScreen.qml file, where an <db:link xlink:href="qml-qtquick-particles-imageparticle.xml">ImageParticle</db:link> type is used to make clouds move across the sky.</db:para>
</db:section>
<db:section xml:id="using-timers">
<db:title>Using Timers</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquick-demo-maroon-med-4.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:para>In maroon.qml, we use the <db:link xlink:href="qtquick-debugging.xml#timer">Timer</db:link> type with a <db:link xlink:href="qml-qtquick-repeater.xml">Repeater</db:link> type to display a countdown sequence before using another timer to start a new game. Both timers are started simultaneously in the &quot;gameOn&quot; state, that is when the players tap the New Game button and passedSplash is true. This is explained in more detail in <db:link xlink:href="qtdoc-demos-maroon-example.xml#managing-game-states">Managing Game States</db:link>.</db:para>
<db:para>We use the countdownTimer to display the countdown sequence:</db:para>
<db:programlisting language="cpp">            Timer {
                id: countdownTimer
                interval: 1000
                running: root.countdown &amp;lt; 5
                repeat: true
                onTriggered: root.countdown++
            }
</db:programlisting>
<db:para>The onTriggered signal handler is called when the timer is triggered to increment the value of the countdown custom property.</db:para>
<db:para>We set the repeat property to true to specify that the timer is triggered at the interval of 1 second as long as the value of countdown is less than 5.</db:para>
<db:para>The countdown property is defined in the root item with an initial value of 10, so that countdownTimer is not running by default:</db:para>
<db:programlisting language="cpp">    property int countdown: 10
</db:programlisting>
<db:para>Each time the timer is triggered, an image from the countdown sequence is displayed. We use a <db:link xlink:href="qml-qtquick-repeater.xml">Repeater</db:link> type to instantiate the <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> delegate in the context of the repeater's parent, canvasArea item, seeded with data from the model:</db:para>
<db:programlisting language="cpp">            Repeater {
                model: [&quot;content/gfx/text-blank.png&quot;, &quot;content/gfx/text-3.png&quot;, &quot;content/gfx/text-2.png&quot;, &quot;content/gfx/text-1.png&quot;, &quot;content/gfx/text-go.png&quot;]
                delegate: Image {
                    visible: root.countdown &amp;lt;= index
                    opacity: root.countdown == index ? 0.5 : 0.1
                    scale: root.countdown &amp;gt;= index ? 1.0 : 0.0
                    source: modelData
                    Behavior on opacity { NumberAnimation {} }
                    Behavior on scale { NumberAnimation {} }
                }
            }
</db:programlisting>
<db:para>We scale the images from 0.0 to 1.0 and use the visible property to hide the images for the previous steps as the countdown progresses. We also raise the opacity of the image that matches the current countdown step, keeping the others nearly transparent.</db:para>
<db:para>By animating the changes in the opacity and scale properties using a <db:link xlink:href="qml-qtquick-behavior.xml">Behavior</db:link> type, we achieve a countdown sequence where numbers zoom in towards the players.</db:para>
</db:section>
<db:section xml:id="constructing-the-game-board">
<db:title>Constructing the Game Board</db:title>
<db:para>To construct the game board, we use the GameCanvas custom type that is defined in GameCanvas.qml.</db:para>
<db:para>In maroon.qml, we use the GameCanvas type to display the game canvas at the position of 32 on the x axis and 20 pixels from the bottom of its parent item, canvasArea:</db:para>
<db:programlisting language="cpp">            GameCanvas {
                id: canvas
                anchors.bottom: parent.bottom
                anchors.bottomMargin: 20
                x: 32
                focus: true
            }
</db:programlisting>
<db:para>We set the focus property to true to give canvas active focus on startup.</db:para>
<db:para>In GameCanvas.qml, we use an <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> type and define custom properties for it to create a grid of equally sized squares divided to 4 columns on 6 rows:</db:para>
<db:programlisting language="cpp">Item {
    id: grid

    property int squareSize: 64
    property int rows: 6
    property int cols: 4
    property Item canvas: grid
</db:programlisting>
<db:para>We use the custom properties to set the width and height of the grid item as the amount of columns and rows multiplied by square size:</db:para>
<db:programlisting language="cpp">    width: cols * squareSize
    height: rows * squareSize
</db:programlisting>
<db:para>We use an <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> type with a <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> type to display a help button that the players can tap to view an image that contains instructions for playing the game:</db:para>
<db:programlisting language="cpp">    Image {
        id: helpButton
        z: 1010
        source: &quot;gfx/button-help.png&quot;
        function goAway() {
            helpMA.enabled = false;
            helpButton.opacity = 0;
        }
        function comeBack() {
            helpMA.enabled = true;
            helpButton.opacity = 1;
        }
        Behavior on opacity { NumberAnimation {} }
        MouseArea {
            id: helpMA
            anchors.fill: parent
            onClicked: {helpImage.visible = true; helpButton.visible = false;}
        }

        anchors.horizontalCenter: parent.horizontalCenter
        anchors.bottom: parent.bottom
        anchors.bottomMargin: 0
    }
</db:programlisting>
<db:para>We declare the goAway() private function to disable the mouse area and make the image fully transparent and a comeBack() function to enable the mouse area and make the button fully opaque. We use a <db:link xlink:href="qml-qtquick-behavior.xml">Behavior</db:link> type on the opacity property to apply the default number animation when the value of opacity changes.</db:para>
<db:para>When the players tap the help button, the onClicked signal handler is called to hide the help button by setting the helpButton.visible property to false and to show the help image by setting the helpImage.visible property to false.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquick-demo-maroon-med-6.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:para>We use anchoring to position the help button at the bottom center of the game canvas.</db:para>
<db:para>We use another <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> type to display the help image:</db:para>
<db:programlisting language="cpp">    Image {
        id: helpImage
        z: 1010
        source: &quot;gfx/help.png&quot;
        anchors.fill: parent
        visible: false
        MouseArea {
            anchors.fill: parent
            onClicked: helpImage.visible = false;
        }
    }
</db:programlisting>
<db:para>To hide the help image when the players tap it, the onClicked signal handler within the <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> type is called to set the helpImage.visible property to true.</db:para>
<db:para>To ensure that the images are placed on top when they are visible, we set a high value for their z property.</db:para>
<db:para>The following sections describe how to use timers to add animated objects to the game board and how to create a menu dialog from which the players can add more objects to it.</db:para>
</db:section>
<db:section xml:id="animating-objects-on-the-game-board">
<db:title>Animating Objects on the Game Board</db:title>
<db:para>We use sprite animation to animate objects on the game board. The Qt Quick <db:link xlink:href="qtquick-effects-sprites.xml">sprite engine</db:link> is a stochastic state machine combined with the ability to chop up images containing multiple frames of an animation.</db:para>
<db:section xml:id="spawning-fish">
<db:title>Spawning Fish</db:title>
<db:para>We use a <db:link xlink:href="qtquick-debugging.xml#timer">Timer</db:link> element with the tick() function in GameCanvas.qml to spawn mobs of fish in waves at an increasing rate, starting at 16 milliseconds:</db:para>
<db:programlisting language="cpp">    Timer {
        interval: 16
        running: true
        repeat: true
        onTriggered: Logic.tick()
    }
</db:programlisting>
<db:para>We use the MobBase custom type that is defined in MobBase.qml to animate mobs of fish that swim inside bubbles. We use an <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> type with custom properties and private functions to create the fish and the bubbles and to define the actions that can be applied to them:</db:para>
<db:programlisting language="cpp">Item  {
    id: container
    property string name: &quot;Fish&quot;
    property int col: 0
    property real hp: 3
    property real damage: 1
    property real speed: 0.25
    property int rof: 30 //In ticks
    property int fireCounter: 0
    property bool dying: false
    width: parent ? parent.squareSize : 0
    height: parent ? parent.squareSize : 0
    x: col * width
    z: 1001
    function fire() { }
    ...
</db:programlisting>
<db:para>We use a <db:link xlink:href="qml-qtquick-spritesequence.xml">SpriteSequence</db:link> type to animate the fish:</db:para>
<db:programlisting language="cpp">    SpriteSequence {
        id: fishSprite
        width: 64
        height: 64
        interpolate: false
        goalSprite: &quot;&quot;
</db:programlisting>
<db:para>The <db:link xlink:href="qml-qtquick-spritesequence.xml">SpriteSequence</db:link> type renders and controls a list of animations defined by <db:link xlink:href="qml-qtquick-sprite.xml">Sprite</db:link> types:</db:para>
<db:programlisting language="cpp">        Sprite {
            name: &quot;left&quot;
            source: &quot;../gfx/mob-idle.png&quot;
            frameWidth: 64
            frameHeight: 64
            frameCount: 1
            frameDuration: 800
            frameDurationVariation: 400
            to: { &quot;front&quot; : 1 }
        }

        Sprite {
            name: &quot;front&quot;
            source: &quot;../gfx/mob-idle.png&quot;
            frameCount: 1
            frameX: 64
            frameWidth: 64
            frameHeight: 64
            frameDuration: 800
            frameDurationVariation: 400
            to: { &quot;left&quot; : 1, &quot;right&quot; : 1 }
        }

        Sprite {
            name: &quot;right&quot;
            source: &quot;../gfx/mob-idle.png&quot;
            frameCount: 1
            frameX: 128
            frameWidth: 64
            frameHeight: 64
            frameDuration: 800
            frameDurationVariation: 400
            to: { &quot;front&quot; : 1 }
        }
</db:programlisting>
<db:para>In the fishSprite sprite sequence, each sprite defines one frame within the mob-idle.png file, which shows a fish facing right, front, and left:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/mob-idle.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>We use the frameWidth, frameHeight, and frameX properties to determine that the first 64x64-pixel square of the image is framed in the &quot;left&quot; sprite, the second in the &quot;front&quot; sprite, and the third in the &quot;right&quot; sprite. For each sprite, the frameCount property is set to 1 to specify that the sprite contains one frame.</db:para>
<db:para>We use the frameDuration and frameDurationVariation properties to specify that the duration of an animation can vary from 400 to 1200 milliseconds.</db:para>
<db:para>The to property specifies that the sprites have weighted transitions to other sprites. The &quot;left&quot; and &quot;right&quot; sprites always transfer to the &quot;front&quot; sprite. When the &quot;front&quot; animation finishes, the sprite engine chooses &quot;left&quot; or &quot;right&quot; randomly, but at roughly equal proportions, because they both have the weight 1.</db:para>
<db:para>When the fish are set free, we want them to swim away in the direction they are facing until they get off the screen. If they were facing front, we use the jumpTo method with the JavaScript Math.random() method in the die() private function to randomly jump to the &quot;left&quot; or &quot;right&quot; sprite:</db:para>
<db:programlisting language="cpp">    function die() {
        if (dying)
            return;
        dying = true;
        bubble.jumpTo(&quot;burst&quot;);
        if (fishSprite.currentSprite == &quot;front&quot;)
            fishSprite.jumpTo(Math.random() &amp;gt; 0.5 ? &quot;left&quot; : &quot;right&quot; );
        fishSwim.start();
        Logic.gameState.score += 1;
        killedSound.play();
        bubble.scale = 0.9
        destroy(350);
    }
</db:programlisting>
<db:para>We then use the start() function to run a <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link> that applies a number animation to the x value from its current value to -360 or 360, depending on whether the goingLeft custom property is true, in 300 milliseconds:</db:para>
<db:programlisting language="cpp">        NumberAnimation on x {
            id: fishSwim
            running: false
            property bool goingLeft: fishSprite.currentSprite == &quot;right&quot;
            to: goingLeft ? -360 : 360
            duration: 300
        }
</db:programlisting>
</db:section>
<db:section xml:id="bursting-bubbles">
<db:title>Bursting Bubbles</db:title>
<db:para>We use another <db:link xlink:href="qml-qtquick-spritesequence.xml">SpriteSequence</db:link> to animate the bubbles so that they become smaller and finally burst when they are attacked by a shooter or a melee. For this effect, we set the value of the scale property to decrease by 0.2 each time the custom hp property changes:</db:para>
<db:programlisting language="cpp">    SpriteSequence {
        id: bubble
        width: 64
        height: 64
        scale: 0.4 + (0.2  * hp)
        interpolate: false
        goalSprite: &quot;&quot;
</db:programlisting>
<db:para>We use a <db:link xlink:href="qml-qtquick-behavior.xml">Behavior</db:link> type to apply a <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link> when the value of scale changes. We use the Easing.OutBack easing type for a back (overshooting cubic function: (s+1)*t^3 - s*t^2) easing out curve that decelerates the motion to zero velocity in 150 milliseconds:</db:para>
<db:programlisting language="cpp">        Behavior on scale {
            NumberAnimation { duration: 150; easing.type: Easing.OutBack }
        }
</db:programlisting>
<db:para>The <db:link xlink:href="qml-qtquick-spritesequence.xml">SpriteSequence</db:link> consist of two sprites that display different images. The first sprite, &quot;big&quot;, uses the catch.png image to display an empty bubble:</db:para>
<db:programlisting language="cpp">        Sprite {
            name: &quot;big&quot;
            source: &quot;../gfx/catch.png&quot;
            frameCount: 1
            to: { &quot;burst&quot; : 0 }
        }
</db:programlisting>
<db:para>We set the to property to &quot;burst&quot; with the weight 0 to make the second sprite, &quot;burst&quot;, a valid goal for the jumpTo method that we use in the die() private function to jump directly to the &quot;burst&quot; sprite without playing the first sprite.</db:para>
<db:para>In the &quot;burst&quot; sprite, we set the frameCount property to 3 and the frameX property to 64 to specify that the animation starts at pixel location 64 and loads each frame for the duration of 200 milliseconds.</db:para>
<db:programlisting language="cpp">        Sprite {
            name: &quot;burst&quot;
            source: &quot;../gfx/catch-action.png&quot;
            frameCount: 3
            frameX: 64
            frameDuration: 200
        }
</db:programlisting>
<db:para>Within the <db:link xlink:href="qml-qtquick-spritesequence.xml">SpriteSequence</db:link>, we use <db:link xlink:href="qml-qtquick-sequentialanimation.xml">SequentialAnimation</db:link> with <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link> to animate the transitions between the frames. To create a pulsating effect on the bubbles, we apply a sequential animation on the width property with two number animations to first increase the bubble width from * 1 to * 1.1 over 800 milliseconds and then bring it back over 1 second:</db:para>
<db:programlisting language="cpp">        SequentialAnimation on width {
            loops: Animation.Infinite
            NumberAnimation { from: width * 1; to: width * 1.1; duration: 800; easing.type: Easing.InOutQuad }
            NumberAnimation { from: width * 1.1; to: width * 1; duration: 1000; easing.type: Easing.InOutQuad }
        }
</db:programlisting>
<db:para>Similarly, we increase the bubble height from * 1 to * 1.15 over 1200 milliseconds and then bring it back over 1 second:</db:para>
<db:programlisting language="cpp">        SequentialAnimation on height {
            loops: Animation.Infinite
            NumberAnimation { from: height * 1; to: height * 1.15; duration: 1200; easing.type: Easing.InOutQuad }
            NumberAnimation { from: height * 1.15; to: height * 1; duration: 1000; easing.type: Easing.InOutQuad }
        }
</db:programlisting>
<db:para>We use yet another <db:link xlink:href="qml-qtquick-spritesequence.xml">SpriteSequence</db:link> to display the effect of squid ink on the bubbles. For more examples of using sprite sequences, see the QML files in the towers directory.</db:para>
</db:section>
</db:section>
<db:section xml:id="adding-dialogs">
<db:title>Adding Dialogs</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquick-demo-maroon-med-5.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:para>In GameCanvas.qml, we use an <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> type with some custom properties to create a menu where the players can buy tower objects:</db:para>
<db:programlisting language="cpp">    Image {
        id: towerMenu
        visible: false
        z: 1500
        scale: 0.9
        opacity: 0.7
        property int dragDistance: 16
        property int targetRow: 0
        property int targetCol: 0
        property bool shown: false
        property bool towerExists: false
</db:programlisting>
<db:para>We set the visible property to false to hide the menu by default. The z property is set to 1500 to ensure that the menu is displayed in front of all other items when it is visible.</db:para>
<db:para>We use a <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> type to open or close the menu when players tap on the canvas:</db:para>
<db:programlisting language="cpp">    MouseArea {
        id: ma
        anchors.fill: parent
        onClicked: {
            if (towerMenu.visible)
                towerMenu.finish()
            else
                towerMenu.open(mouse.x, mouse.y)
        }
    }
</db:programlisting>
<db:para>We set the anchors.fill property to parent to allow the players to tap anywhere on the game canvas. We use a condition in the onClicked signal handler to call the finish() function if the menu is visible and the open() function otherwise.</db:para>
<db:para>The finish() function hides the menu by setting the shown custom property to false:</db:para>
<db:programlisting language="cpp">        function finish() {
            shown = false
        }
</db:programlisting>
<db:para>The open() function displays the menu at the x and y position of the mouse pointer:</db:para>
<db:programlisting language="cpp">        function open(xp,yp) {
            if (!grid.gameRunning)
                return
            targetRow = Logic.row(yp)
            targetCol = Logic.col(xp)
            if (targetRow == 0)
                towerMenu.y = (targetRow + 1) * grid.squareSize
            else
                towerMenu.y = (targetRow - 1) * grid.squareSize
            towerExists = (grid.towers[Logic.towerIdx(targetCol, targetRow)] != null)
            shown = true
            helpButton.goAway();
        }
</db:programlisting>
<db:para>If gameRunning is true, we call the JavaScript row() function to calculate the value of the targetRow custom property and the col() function to calculate the value of the targetCol custom property. If the value of targetRow equals 0, the y position is set to one square above the mouse pointer. Otherwise, it is set to one square below the mouse pointer.</db:para>
<db:para>We use the towerIdx() function to set the value of the towerExists custom property.</db:para>
<db:para>We set the shown custom property to true to show the menu and call the helpButton.goAway() function to hide the help button when the menu opens.</db:para>
<db:para>We use states and transitions to display the menu when the shown property is true and the gameOver property is false:</db:para>
<db:programlisting language="cpp">        states: State {
            name: &quot;shown&quot;; when: towerMenu.shown &amp;amp;&amp;amp; !grid.gameOver
            PropertyChanges { target: towerMenu; visible: true; scale: 1; opacity: 1 }
        }

        transitions: Transition {
            PropertyAction { property: &quot;visible&quot; }
            NumberAnimation { properties: &quot;opacity,scale&quot;; duration: 500; easing.type: Easing.OutElastic }
        }
</db:programlisting>
<db:para>To set the visibility of the menu to &quot;visible&quot; without animating the property change, we use a <db:link xlink:href="qml-qtquick-propertyaction.xml">PropertyAction</db:link> type. We do want to animate the changes in opacity and scale, though, so we use number animation to animate the value of the scale property from 0.9 to 1 and the value of opacity property from 0.7 to 1, over 500 milliseconds. We use the Easing.outElastic easing type for an elastic (exponentially decaying sine wave) function easing curve that decelerates from zero velocity.</db:para>
<db:para>To construct the menu, we use a BuildButton custom type that is defined in BuildButton.qml. In GameCanvas.qml, we create one build button for each tower object that the players can buy and position them in a <db:link xlink:href="10-qdoc-commands-tablesandlists.xml#row">Row</db:link> layout in front of the menu background image, dialog.png:</db:para>
<db:programlisting language="cpp">        x: -32
        source: &quot;gfx/dialog.png&quot;
        Row {
            id: buttonRow
            height: 100
            anchors.centerIn: parent
            spacing: 8
            BuildButton {
                row: towerMenu.targetRow; col: towerMenu.targetCol
                anchors.verticalCenter: parent.verticalCenter
                towerType: 1; index: 0
                canBuild: !towerMenu.towerExists
                source: &quot;gfx/dialog-melee.png&quot;
                onClicked: towerMenu.finish()
            }
            BuildButton {
                row: towerMenu.targetRow; col: towerMenu.targetCol
                anchors.verticalCenter: parent.verticalCenter
                towerType: 2; index: 1
                canBuild: !towerMenu.towerExists
                source: &quot;gfx/dialog-shooter.png&quot;
                onClicked: towerMenu.finish()
            }
            BuildButton {
                row: towerMenu.targetRow; col: towerMenu.targetCol
                anchors.verticalCenter: parent.verticalCenter
                towerType: 3; index: 2
                canBuild: !towerMenu.towerExists
                source: &quot;gfx/dialog-bomb.png&quot;
                onClicked: towerMenu.finish()
            }
            BuildButton {
                row: towerMenu.targetRow; col: towerMenu.targetCol
                anchors.verticalCenter: parent.verticalCenter
                towerType: 4; index: 3
                canBuild: !towerMenu.towerExists
                source: &quot;gfx/dialog-factory.png&quot;
                onClicked: towerMenu.finish()
            }
        }
    }
</db:programlisting>
<db:para>For each build button, we set the values of towerType and index custom properties that we define in BuildButton.qml.</db:para>
<db:para>We use the canBuild custom property to prevent players from adding tower objects in locations where tower objects already exist.</db:para>
<db:para>We use the source property to display the image for the tower type.</db:para>
<db:para>The onClicked signal handler is called to execute the finish() function that closes the menu when the players tap an enabled build button.</db:para>
<db:para>Build buttons are enabled when the players have enough coins to buy the tower objects. We use an <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> type in BuildButton.qml to display images on the buttons:</db:para>
<db:programlisting language="cpp">    Image {
        id: img
        opacity: (canBuild &amp;amp;&amp;amp; gameCanvas.coins &amp;gt;= Logic.towerData[towerType-1].cost) ? 1.0 : 0.4
    }
</db:programlisting>
<db:para>We use the opacity property to make the buttons appear enabled. If canBuild is true and the value of the gameCanvas.coins property is larger than or equal to the cost of a tower object, the images are fully opaque, otherwise their opacity is set to 0.4.</db:para>
<db:para>We use a <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> type to display the cost of each tower item, as specified by the towerData variable, depending on towerType:</db:para>
<db:programlisting language="cpp">    Text {
        anchors.right: parent.right
        font.pointSize: 14
        font.bold: true
        color: &quot;#ffffff&quot;
        text: Logic.towerData[towerType - 1].cost
    }
</db:programlisting>
<db:para>To display a pointer on the screen at the position where the tower object will be added, we use the <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> type. We use the visible property to determine whether the dialog-pointer.png image should be positioned below or above the menu. When the value of the col property equals the index and the value or the row property is not 0, we anchor the image to the bottom of its parent, BuildButton.</db:para>
<db:para>When the value or the row property is 0, we anchor the image to the top of BuildButton to position the pointer above the menu and use the rotation property to rotate it by 180 degrees, so that it points upwards:</db:para>
<db:programlisting language="cpp">    Image {
        visible: col == index &amp;amp;&amp;amp; row != 0
        source: &quot;gfx/dialog-pointer.png&quot;
        anchors.top: parent.bottom
        anchors.topMargin: 4
        anchors.horizontalCenter: parent.horizontalCenter
    }
    Image {
        visible: col == index &amp;amp;&amp;amp; row == 0
        source: &quot;gfx/dialog-pointer.png&quot;
        rotation: 180
        anchors.bottom: parent.top
        anchors.bottomMargin: 6
        anchors.horizontalCenter: parent.horizontalCenter
    }
</db:programlisting>
</db:section>
<db:section xml:id="keeping-track-of-game-statistics">
<db:title>Keeping Track of Game Statistics</db:title>
<db:para>To keep track of the game statistics, we use the InfoBar custom type (that is defined in InfoBar.qml) in maroon.qml:</db:para>
<db:programlisting language="cpp">            InfoBar { anchors.bottom: canvas.top; anchors.bottomMargin: 6; width: parent.width }
</db:programlisting>
<db:para>We use the anchors.bottom and anchors.bottomMargin properties to position the info bar at 6 points from the top of the game canvas. We bind the width property of the info bar to that of its parent.</db:para>
<db:para>In InfoBar.qml, we use an <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> type to create the info bar. Within it, we use a <db:link xlink:href="10-qdoc-commands-tablesandlists.xml#row">Row</db:link> layout type to display the number of lives the players have left, the number of fish that have been saved, and the amount of coins that are available for use.</db:para>
<db:para>We use the anchors property to position the rows in relationship to their parent and to each other. In the first <db:link xlink:href="10-qdoc-commands-tablesandlists.xml#row">Row</db:link> object, we use the anchors.left and anchors.leftMargin properties to position the heart icons at 10 points from the left border of the parent item:</db:para>
<db:programlisting language="cpp">Item {
    height: childrenRect.height

    // Display the number of lives
    Row {
        anchors.left: parent.left
        anchors.leftMargin: 10
        spacing: 5
        Repeater {
            id: rep
            model: Math.min(10, canvas.lives)
            delegate: Image { source: &quot;gfx/lifes.png&quot; }
        }
    }
</db:programlisting>
<db:para>We use a <db:link xlink:href="qml-qtquick-repeater.xml">Repeater</db:link> type with a model and a delegate to display as many hearts as the players have lives left. We use the spacing property to leave 5 pixels between the displayed icons.</db:para>
<db:para>In the second <db:link xlink:href="10-qdoc-commands-tablesandlists.xml#row">Row</db:link> object, we use the anchors.right and anchors.rightMargin properties to position the number of fish saved at 20 points left of the third <db:link xlink:href="10-qdoc-commands-tablesandlists.xml#row">Row</db:link> object that displays the number of coins available (and has the id points):</db:para>
<db:programlisting language="cpp">    Row {
        anchors.right: points.left
        anchors.rightMargin: 20
        spacing: 5
        Image { source: &quot;gfx/scores.png&quot; }
        Text {
            text: canvas.score
            font.bold: true
        }
    }

    // Display the number of coins
    Row {
        id: points
        anchors.right: parent.right
        anchors.rightMargin: 10
        spacing: 5
        Image { source: &quot;gfx/points.png&quot; }
        Text {
            id: pointsLabel
            text: canvas.coins
            font.bold: true
        }
    }
}
</db:programlisting>
<db:para>In these objects, we set spacing to 5 pixels to separate the icons from the numbers that we display by using a <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> type.</db:para>
<db:para>In GameCanvas.qml, we define custom properties to hold the game statistics:</db:para>
<db:programlisting language="cpp">    property int score: 0
    property int coins: 100
    property int lives: 3
</db:programlisting>
<db:para>We declare the freshState() function to set the initial game statistics when a new game starts:</db:para>
<db:programlisting language="cpp">    function freshState() {
        lives = 3
        coins = 100
        score = 0
        waveNumber = 0
        waveProgress = 0
        gameOver = false
        gameRunning = false
        towerMenu.shown = false
        helpButton.comeBack();
    }
</db:programlisting>
<db:para>We use the Logic.gameState.score variable in the die() function that we declare in MobBase.qml to increase the score by one when the players set a fish free:</db:para>
<db:programlisting language="cpp">        Logic.gameState.score += 1;
</db:programlisting>
</db:section>
<db:section xml:id="managing-game-states">
<db:title>Managing Game States</db:title>
<db:para>In maroon.qml, we use a <db:link xlink:href="qml-qtqml-statemachine-state.xml">State</db:link> type and JavaScript to switch between screens according to the game state. The logic.js file contains definitions for the functions. To use the functions in a QML file, we import logic.js as the Logic namespace in that file:</db:para>
<db:programlisting language="cpp">import &quot;content/logic.js&quot; as Logic
</db:programlisting>
<db:para>The base state displays the new game screen when the application starts. In addition, we call the Component.onCompleted signal handler to initialize a new game:</db:para>
<db:programlisting language="cpp">    Component.onCompleted: gameState = Logic.newGameState(canvas);
</db:programlisting>
<db:para>In NewGameScreen.qml we use the onClicked signal handler to emit the startButtonClicked() signal when the players tap the New Game button:</db:para>
<db:programlisting language="cpp">    Image {
        source: &quot;gfx/button-play.png&quot;
        anchors.bottom: parent.bottom
        anchors.bottomMargin: 60
        MouseArea {
            anchors.fill: parent
            onClicked: newGameScreen.startButtonClicked()
        }
</db:programlisting>
<db:para>In maroon.qml, we use the onStartButtonClicked signal handler to set the passedSplash property of the root item to true:</db:para>
<db:programlisting language="cpp">        NewGameScreen {
            onStartButtonClicked: root.passedSplash = true
        }
</db:programlisting>
<db:para>We then use the passedSplash property in the when property of the gameOn state to trigger the gameStarter timer:</db:para>
<db:programlisting language="cpp">        State {
            name: &quot;gameOn&quot;; when: gameState.gameOver == false &amp;amp;&amp;amp; passedSplash
            PropertyChanges { target: view; y: -(height - 960) }
            StateChangeScript { script: root.countdown = 0; }
            PropertyChanges { target: gameStarter; running: true }
        },
</db:programlisting>
<db:para>We also switch to the &quot;gameOn&quot; state and move to the y position -(height - 960) to display the game canvas.</db:para>
<db:para>In the gameStarter <db:link xlink:href="qtquick-debugging.xml#timer">Timer</db:link> object we use the onTriggered signal handler to call the startGame() function that starts a new game:</db:para>
<db:programlisting language="cpp">    Timer {
        id: gameStarter
        interval: 4000
        running: false
        repeat: false
        onTriggered: Logic.startGame(canvas);
    }
</db:programlisting>
<db:para>The game continues until gameState.gameOver is set to true and gameState.gameRunning is set to false by calling the endGame() function when the value of the gameState.lives property becomes less than or equal to 0.</db:para>
<db:para>In GameOverScreen.qml, we use a <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> type and an onClicked signal handler within an <db:link xlink:href="09-qdoc-commands-includingimages.xml#image">Image</db:link> type to return to the game canvas when the players tap the New Game button:</db:para>
<db:programlisting language="cpp">    Image {
        source: &quot;gfx/button-play.png&quot;
        anchors.bottom: parent.bottom
        anchors.bottomMargin: 0
        MouseArea {
            anchors.fill: parent
            onClicked: gameCanvas.gameOver = false//This will actually trigger the state change in main.qml
        }
    }
</db:programlisting>
<db:para>The onClicked signal handler triggers a state change in maroon.qml to display the game canvas:</db:para>
<db:programlisting language="cpp">        State {
            name: &quot;gameOver&quot;; when: gameState.gameOver == true
            PropertyChanges { target: view; y: 0 }
        }
</db:programlisting>
</db:section>
<db:section xml:id="playing-sound-effects">
<db:title>Playing Sound Effects</db:title>
<db:para>The app can play sound effects if the <db:link xlink:href="qtmultimedia-index.xml">Qt Multimedia</db:link> module is installed. In the <db:link xlink:href="qml-qtmultimedia-soundeffect.xml">SoundEffect</db:link>.qml file, we proxy a <db:link xlink:href="qml-qtmultimedia-soundeffect.xml">SoundEffect</db:link> type:</db:para>
<db:programlisting language="cpp">Item {
    id: container
    property QtObject effect: Qt.createQmlObject(&quot;import QtMultimedia 5.0; SoundEffect{ source: '&quot; + container.source + &quot;'; muted: Qt.application.state != Qt.ApplicationActive }&quot;, container);
    property url source: &quot;&quot;
    onSourceChanged: if (effect != null) effect.source = source;
    function play() {
        if (effect != null)
            effect.play();
    }
</db:programlisting>
<db:para>We add the qtHaveModule() qmake command to the app .pro file, maroon.pro, to check whether the <db:link xlink:href="qtmultimedia-index.xml">Qt Multimedia</db:link> module is present:</db:para>
<db:programlisting language="cpp">QT += qml quick
qtHaveModule(multimedia): QT += multimedia
</db:programlisting>
<db:para>In each QML file that defines a custom type used on the game canvas, we use a <db:link xlink:href="qml-qtmultimedia-soundeffect.xml">SoundEffect</db:link> type to specify the audio file to play for that type of objects. For example, in Bomb.qml, we specify the sound that a bomb makes when it explodes:</db:para>
<db:programlisting language="cpp">    SoundEffect {
        id: sound
        source: &quot;../audio/bomb-action.wav&quot;
    }
</db:programlisting>
<db:para>To play the sound effect when a bomb explodes, we call the sound.play() function that we declare as a member of the private fire() function within the TowerBase custom type:</db:para>
<db:programlisting language="cpp">    function fire() {
        sound.play()
        sprite.jumpTo(&quot;shoot&quot;)
        animDelay.start()
    }
</db:programlisting>
<db:para>For more examples of playing sound effects, see the QML files in the towers directory and MobBase.qml.</db:para>
</db:section>
<db:section xml:id="adding-keyboard-shortcuts">
<db:title>Adding Keyboard Shortcuts</db:title>
<db:para>This is a touch example, so you should not really need to handle key presses. However, we do not want you to have to spend more time playing the game than you want to while testing it, so we use the Keys.onPressed signal handler to specify keyboard shortcuts. You can press Shift+Up to increment the values of the coins property to add coins, Shift+Left to increment the value of lives, Shift+Down to increment the value of the waveProgress property to spawn mobs of fish faster, and Shift+Right to call the endGame() function to quit the game:</db:para>
<db:programlisting language="cpp">    Keys.onPressed: { // Cheat Codes while Testing
        if (event.key == Qt.Key_Up &amp;amp;&amp;amp; (event.modifiers &amp;amp; Qt.ShiftModifier))
            grid.coins += 10;
        if (event.key == Qt.Key_Left &amp;amp;&amp;amp; (event.modifiers &amp;amp; Qt.ShiftModifier))
            grid.lives += 1;
        if (event.key == Qt.Key_Down &amp;amp;&amp;amp; (event.modifiers &amp;amp; Qt.ShiftModifier))
            Logic.gameState.waveProgress += 1000;
        if (event.key == Qt.Key_Right &amp;amp;&amp;amp; (event.modifiers &amp;amp; Qt.ShiftModifier))
            Logic.endGame();
    }
</db:programlisting>
</db:section>
<db:section xml:id="packaging-resources-for-deployment">
<db:title>Packaging Resources for Deployment</db:title>
<db:para>To be able to run the app on mobile devices, we package all QML, JavaScript, image, and sound files into a Qt resource file (.qrc). For more information, see <db:link xlink:href="resources.xml">The Qt Resource System</db:link>.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/BuildButton.qml">demos/maroon/content/BuildButton.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/GameCanvas.qml">demos/maroon/content/GameCanvas.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/GameOverScreen.qml">demos/maroon/content/GameOverScreen.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/InfoBar.qml">demos/maroon/content/InfoBar.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/NewGameScreen.qml">demos/maroon/content/NewGameScreen.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/SoundEffect.qml">demos/maroon/content/SoundEffect.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/logic.js">demos/maroon/content/logic.js</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/mobs/MobBase.qml">demos/maroon/content/mobs/MobBase.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/towers/Bomb.qml">demos/maroon/content/towers/Bomb.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/towers/Factory.qml">demos/maroon/content/towers/Factory.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/towers/Melee.qml">demos/maroon/content/towers/Melee.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/towers/Ranged.qml">demos/maroon/content/towers/Ranged.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/towers/TowerBase.qml">demos/maroon/content/towers/TowerBase.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/main.cpp">demos/maroon/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/maroon.pro">demos/maroon/maroon.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/maroon.qml">demos/maroon/maroon.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/maroon.qmlproject">demos/maroon/maroon.qmlproject</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/maroon.qrc">demos/maroon/maroon.qrc</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Images:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/background.png">demos/maroon/content/gfx/background.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/bomb-action.png">demos/maroon/content/gfx/bomb-action.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/bomb-idle.png">demos/maroon/content/gfx/bomb-idle.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/bomb.png">demos/maroon/content/gfx/bomb.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/button-help.png">demos/maroon/content/gfx/button-help.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/button-play.png">demos/maroon/content/gfx/button-play.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/catch-action.png">demos/maroon/content/gfx/catch-action.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/catch.png">demos/maroon/content/gfx/catch.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/cloud.png">demos/maroon/content/gfx/cloud.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/currency.png">demos/maroon/content/gfx/currency.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/dialog-bomb.png">demos/maroon/content/gfx/dialog-bomb.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/dialog-factory.png">demos/maroon/content/gfx/dialog-factory.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/dialog-melee.png">demos/maroon/content/gfx/dialog-melee.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/dialog-pointer.png">demos/maroon/content/gfx/dialog-pointer.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/dialog-shooter.png">demos/maroon/content/gfx/dialog-shooter.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/dialog.png">demos/maroon/content/gfx/dialog.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/factory-action.png">demos/maroon/content/gfx/factory-action.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/factory-idle.png">demos/maroon/content/gfx/factory-idle.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/factory.png">demos/maroon/content/gfx/factory.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/grid.png">demos/maroon/content/gfx/grid.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/help.png">demos/maroon/content/gfx/help.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/lifes.png">demos/maroon/content/gfx/lifes.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/logo-bubble.png">demos/maroon/content/gfx/logo-bubble.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/logo-fish.png">demos/maroon/content/gfx/logo-fish.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/logo.png">demos/maroon/content/gfx/logo.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/melee-action.png">demos/maroon/content/gfx/melee-action.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/melee-idle.png">demos/maroon/content/gfx/melee-idle.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/melee.png">demos/maroon/content/gfx/melee.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/mob-idle.png">demos/maroon/content/gfx/mob-idle.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/mob.png">demos/maroon/content/gfx/mob.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/points.png">demos/maroon/content/gfx/points.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/projectile-action.png">demos/maroon/content/gfx/projectile-action.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/projectile.png">demos/maroon/content/gfx/projectile.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/scores.png">demos/maroon/content/gfx/scores.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/shooter-action.png">demos/maroon/content/gfx/shooter-action.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/shooter-idle.png">demos/maroon/content/gfx/shooter-idle.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/shooter.png">demos/maroon/content/gfx/shooter.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/sunlight.png">demos/maroon/content/gfx/sunlight.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/text-1.png">demos/maroon/content/gfx/text-1.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/text-2.png">demos/maroon/content/gfx/text-2.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/text-3.png">demos/maroon/content/gfx/text-3.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/text-blank.png">demos/maroon/content/gfx/text-blank.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/text-gameover.png">demos/maroon/content/gfx/text-gameover.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/text-go.png">demos/maroon/content/gfx/text-go.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="demos/maroon/content/gfx/wave.png">demos/maroon/content/gfx/wave.png</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmlapplications.xml">QML Applications</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section></db:section></db:article>
