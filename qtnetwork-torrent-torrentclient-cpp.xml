<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Torrent Example</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Demonstrates complex TCP/IP operations.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;connectionmanager.h&quot;
#include &quot;filemanager.h&quot;
#include &quot;metainfo.h&quot;
#include &quot;torrentclient.h&quot;
#include &quot;torrentserver.h&quot;
#include &quot;trackerclient.h&quot;
#include &quot;peerwireclient.h&quot;
#include &quot;ratecontroller.h&quot;

#include &lt;QtCore&gt;
#include &lt;QNetworkInterface&gt;

#include &lt;algorithm&gt;

// These constants could also be configurable by the user.
static const int ServerMinPort = 6881;
static const int ServerMaxPort = /* 6889 */ 7000;
static const int BlockSize = 16384;
static const int MaxBlocksInProgress = 5;
static const int MaxBlocksInMultiMode = 2;
static const int MaxConnectionPerPeer = 1;
static const int RateControlWindowLength = 10;
static const int RateControlTimerDelay = 1000;
static const int MinimumTimeBeforeRevisit = 30;
static const int MaxUploads = 4;
static const int UploadScheduleInterval = 10000;

class TorrentPiece {
public:
    int index;
    int length;
    QBitArray completedBlocks;
    QBitArray requestedBlocks;
    bool inProgress;
};

class TorrentClientPrivate
{
public:
    TorrentClientPrivate(TorrentClient *qq);

    // State / error
    void setError(TorrentClient::Error error);
    void setState(TorrentClient::State state);
    TorrentClient::Error error;
    TorrentClient::State state;
    QString errorString;
    QString stateString;

    // Where to save data
    QString destinationFolder;
    MetaInfo metaInfo;

    // Announce tracker and file manager
    QByteArray peerId;
    QByteArray infoHash;
    TrackerClient trackerClient;
    FileManager fileManager;

    // Connections
    QList&lt;PeerWireClient *&gt; connections;
    QList&lt;TorrentPeer *&gt; peers;
    bool schedulerCalled;
    void callScheduler();
    bool connectingToClients;
    void callPeerConnector();
    int uploadScheduleTimer;

    // Pieces
    QMap&lt;int, PeerWireClient *&gt; readIds;
    QMultiMap&lt;PeerWireClient *, TorrentPiece *&gt; payloads;
    QMap&lt;int, TorrentPiece *&gt; pendingPieces;
    QBitArray completedPieces;
    QBitArray incompletePieces;
    int pieceCount;

    // Progress
    int lastProgressValue;
    qint64 downloadedBytes;
    qint64 uploadedBytes;
    int downloadRate[RateControlWindowLength];
    int uploadRate[RateControlWindowLength];
    int transferRateTimer;

    TorrentClient *q;
};

TorrentClientPrivate::TorrentClientPrivate(TorrentClient *qq)
    : trackerClient(qq), q(qq)
{
    error = TorrentClient::UnknownError;
    state = TorrentClient::Idle;
    errorString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Unknown error&quot;);
    stateString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Idle&quot;);
    schedulerCalled = false;
    connectingToClients = false;
    uploadScheduleTimer = 0;
    lastProgressValue = -1;
    pieceCount = 0;
    downloadedBytes = 0;
    uploadedBytes = 0;
    memset(downloadRate, 0, sizeof(downloadRate));
    memset(uploadRate, 0, sizeof(uploadRate));
    transferRateTimer = 0;
}

void TorrentClientPrivate::setError(TorrentClient::Error errorCode)
{
    this-&gt;error = errorCode;
    switch (error) {
    case TorrentClient::UnknownError:
        errorString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Unknown error&quot;);
        break;
    case TorrentClient::TorrentParseError:
        errorString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Invalid torrent data&quot;);
        break;
    case TorrentClient::InvalidTrackerError:
        errorString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Unable to connect to tracker&quot;);
        break;
    case TorrentClient::FileError:
        errorString = QT_TRANSLATE_NOOP(TorrentClient, &quot;File error&quot;);
        break;
    case TorrentClient::ServerError:
        errorString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Unable to initialize server&quot;);
        break;
    }
    emit q-&gt;error(errorCode);
}

void TorrentClientPrivate::setState(TorrentClient::State state)
{
    this-&gt;state = state;
    switch (state) {
    case TorrentClient::Idle:
        stateString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Idle&quot;);
        break;
    case TorrentClient::Paused:
        stateString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Paused&quot;);
        break;
    case TorrentClient::Stopping:
        stateString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Stopping&quot;);
        break;
    case TorrentClient::Preparing:
        stateString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Preparing&quot;);
        break;
    case TorrentClient::Searching:
        stateString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Searching&quot;);
        break;
    case TorrentClient::Connecting:
        stateString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Connecting&quot;);
        break;
    case TorrentClient::WarmingUp:
        stateString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Warming up&quot;);
        break;
    case TorrentClient::Downloading:
        stateString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Downloading&quot;);
        break;
    case TorrentClient::Endgame:
        stateString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Finishing&quot;);
        break;
    case TorrentClient::Seeding:
        stateString = QT_TRANSLATE_NOOP(TorrentClient, &quot;Seeding&quot;);
        break;
    }
    emit q-&gt;stateChanged(state);
}

void TorrentClientPrivate::callScheduler()
{
    if (!schedulerCalled) {
        schedulerCalled = true;
        QMetaObject::invokeMethod(q, &quot;scheduleDownloads&quot;, Qt::QueuedConnection);
    }
}

void TorrentClientPrivate::callPeerConnector()
{
    if (!connectingToClients) {
        connectingToClients = true;
        QTimer::singleShot(10000, q, SLOT(connectToPeers()));
    }
}

TorrentClient::TorrentClient(QObject *parent)
    : QObject(parent), d(new TorrentClientPrivate(this))
{
    // Connect the file manager
    connect(&amp;d-&gt;fileManager, SIGNAL(dataRead(int,int,int,QByteArray)),
            this, SLOT(sendToPeer(int,int,int,QByteArray)));
    connect(&amp;d-&gt;fileManager, SIGNAL(verificationProgress(int)),
            this, SLOT(updateProgress(int)));
    connect(&amp;d-&gt;fileManager, SIGNAL(verificationDone()),
            this, SLOT(fullVerificationDone()));
    connect(&amp;d-&gt;fileManager, SIGNAL(pieceVerified(int,bool)),
            this, SLOT(pieceVerified(int,bool)));
    connect(&amp;d-&gt;fileManager, SIGNAL(error()),
            this, SLOT(handleFileError()));

    // Connect the tracker client
    connect(&amp;d-&gt;trackerClient, SIGNAL(peerListUpdated(QList&lt;TorrentPeer&gt;)),
            this, SLOT(addToPeerList(QList&lt;TorrentPeer&gt;)));
    connect(&amp;d-&gt;trackerClient, SIGNAL(stopped()),
            this, SIGNAL(stopped()));
}

TorrentClient::~TorrentClient()
{
    qDeleteAll(d-&gt;peers);
    qDeleteAll(d-&gt;pendingPieces);
    delete d;
}

bool TorrentClient::setTorrent(const QString &amp;fileName)
{
    QFile file(fileName);
    if (!file.open(QIODevice::ReadOnly) || !setTorrent(file.readAll())) {
        d-&gt;setError(TorrentParseError);
        return false;
    }
    return true;
}

bool TorrentClient::setTorrent(const QByteArray &amp;torrentData)
{
    if (!d-&gt;metaInfo.parse(torrentData)) {
        d-&gt;setError(TorrentParseError);
        return false;
    }

    // Calculate SHA1 hash of the &quot;info&quot; section in the torrent
    QByteArray infoValue = d-&gt;metaInfo.infoValue();
    d-&gt;infoHash = QCryptographicHash::hash(infoValue, QCryptographicHash::Sha1);

    return true;
}

MetaInfo TorrentClient::metaInfo() const
{
    return d-&gt;metaInfo;
}

void TorrentClient::setDestinationFolder(const QString &amp;directory)
{
    d-&gt;destinationFolder = directory;
}

QString TorrentClient::destinationFolder() const
{
    return d-&gt;destinationFolder;
}

void TorrentClient::setDumpedState(const QByteArray &amp;dumpedState)
{
    // Recover partially completed pieces
    QDataStream stream(dumpedState);

    quint16 version = 0;
    stream &gt;&gt; version;
    if (version != 2)
        return;

    stream &gt;&gt; d-&gt;completedPieces;

    while (!stream.atEnd()) {
        int index;
        int length;
        QBitArray completed;
        stream &gt;&gt; index &gt;&gt; length &gt;&gt; completed;
        if (stream.status() != QDataStream::Ok) {
            d-&gt;completedPieces.clear();
            break;
        }

        TorrentPiece *piece = new TorrentPiece;
        piece-&gt;index = index;
        piece-&gt;length = length;
        piece-&gt;completedBlocks = completed;
        piece-&gt;requestedBlocks.resize(completed.size());
        piece-&gt;inProgress = false;
        d-&gt;pendingPieces[index] = piece;
    }
}

QByteArray TorrentClient::dumpedState() const
{
    QByteArray partials;
    QDataStream stream(&amp;partials, QIODevice::WriteOnly);

    stream &lt;&lt; quint16(2);
    stream &lt;&lt; d-&gt;completedPieces;

    // Save the state of all partially downloaded pieces into a format
    // suitable for storing in settings.
    QMap&lt;int, TorrentPiece *&gt;::ConstIterator it = d-&gt;pendingPieces.constBegin();
    while (it != d-&gt;pendingPieces.constEnd()) {
        TorrentPiece *piece = it.value();
        if (blocksLeftForPiece(piece) &gt; 0 &amp;&amp; blocksLeftForPiece(piece) &lt; piece-&gt;completedBlocks.size()) {
            stream &lt;&lt; piece-&gt;index;
            stream &lt;&lt; piece-&gt;length;
            stream &lt;&lt; piece-&gt;completedBlocks;
        }
        ++it;
    }

    return partials;
}

qint64 TorrentClient::progress() const
{
    return d-&gt;lastProgressValue;
}

void TorrentClient::setDownloadedBytes(qint64 bytes)
{
    d-&gt;downloadedBytes = bytes;
}

qint64 TorrentClient::downloadedBytes() const
{
    return d-&gt;downloadedBytes;
}

void TorrentClient::setUploadedBytes(qint64 bytes)
{
    d-&gt;uploadedBytes = bytes;
}

qint64 TorrentClient::uploadedBytes() const
{
    return d-&gt;uploadedBytes;
}

int TorrentClient::connectedPeerCount() const
{
    int tmp = 0;
    foreach (PeerWireClient *client, d-&gt;connections) {
        if (client-&gt;state() == QAbstractSocket::ConnectedState)
            ++tmp;
    }
    return tmp;
}

int TorrentClient::seedCount() const
{
    int tmp = 0;
    foreach (PeerWireClient *client, d-&gt;connections) {
        if (client-&gt;availablePieces().count(true) == d-&gt;pieceCount)
            ++tmp;
    }
    return tmp;
}

TorrentClient::State TorrentClient::state() const
{
    return d-&gt;state;
}

QString TorrentClient::stateString() const
{
    return d-&gt;stateString;
}

TorrentClient::Error TorrentClient::error() const
{
    return d-&gt;error;
}

QString TorrentClient::errorString() const
{
    return d-&gt;errorString;
}

QByteArray TorrentClient::peerId() const
{
    return d-&gt;peerId;
}

QByteArray TorrentClient::infoHash() const
{
    return d-&gt;infoHash;
}

void TorrentClient::start()
{
    if (d-&gt;state != Idle)
        return;

    TorrentServer::instance()-&gt;addClient(this);

    // Initialize the file manager
    d-&gt;setState(Preparing);
    d-&gt;fileManager.setMetaInfo(d-&gt;metaInfo);
    d-&gt;fileManager.setDestinationFolder(d-&gt;destinationFolder);
    d-&gt;fileManager.setCompletedPieces(d-&gt;completedPieces);
    d-&gt;fileManager.start(QThread::LowestPriority);
    d-&gt;fileManager.startDataVerification();
}

void TorrentClient::stop()
{
    if (d-&gt;state == Stopping)
        return;

    TorrentServer::instance()-&gt;removeClient(this);

    // Update the state
    State oldState = d-&gt;state;
    d-&gt;setState(Stopping);

    // Stop the timer
    if (d-&gt;transferRateTimer) {
        killTimer(d-&gt;transferRateTimer);
        d-&gt;transferRateTimer = 0;
    }

    // Abort all existing connections
    foreach (PeerWireClient *client, d-&gt;connections) {
        RateController::instance()-&gt;removeSocket(client);
        ConnectionManager::instance()-&gt;removeConnection(client);
        client-&gt;abort();
    }
    d-&gt;connections.clear();

    // Perhaps stop the tracker
    if (oldState &gt; Preparing) {
        d-&gt;trackerClient.stop();
    } else {
        d-&gt;setState(Idle);
        emit stopped();
    }
}

void TorrentClient::setPaused(bool paused)
{
    if (paused) {
        // Abort all connections, and set the max number of
        // connections to 0. Keep the list of peers, so we can quickly
        // resume later.
        d-&gt;setState(Paused);
        foreach (PeerWireClient *client, d-&gt;connections)
            client-&gt;abort();
        d-&gt;connections.clear();
        TorrentServer::instance()-&gt;removeClient(this);
    } else {
        // Restore the max number of connections, and start the peer
        // connector. We should also quickly start receiving incoming
        // connections.
        d-&gt;setState(d-&gt;completedPieces.count(true) == d-&gt;fileManager.pieceCount()
                    ? Seeding : Searching);
        connectToPeers();
        TorrentServer::instance()-&gt;addClient(this);
    }
}

void TorrentClient::timerEvent(QTimerEvent *event)
{
    if (event-&gt;timerId() == d-&gt;uploadScheduleTimer) {
        // Update the state of who's choked and who's not
        scheduleUploads();
        return;
    }

    if (event-&gt;timerId() != d-&gt;transferRateTimer) {
        QObject::timerEvent(event);
        return;
    }

    // Calculate average upload/download rate
    qint64 uploadBytesPerSecond = 0;
    qint64 downloadBytesPerSecond = 0;
    for (int i = 0; i &lt; RateControlWindowLength; ++i) {
        uploadBytesPerSecond += d-&gt;uploadRate[i];
        downloadBytesPerSecond += d-&gt;downloadRate[i];
    }
    uploadBytesPerSecond /= qint64(RateControlWindowLength);
    downloadBytesPerSecond /= qint64(RateControlWindowLength);
    for (int i = RateControlWindowLength - 2; i &gt;= 0; --i) {
        d-&gt;uploadRate[i + 1] = d-&gt;uploadRate[i];
        d-&gt;downloadRate[i + 1] = d-&gt;downloadRate[i];
    }
    d-&gt;uploadRate[0] = 0;
    d-&gt;downloadRate[0] = 0;
    emit uploadRateUpdated(int(uploadBytesPerSecond));
    emit downloadRateUpdated(int(downloadBytesPerSecond));

    // Stop the timer if there is no activity.
    if (downloadBytesPerSecond == 0 &amp;&amp; uploadBytesPerSecond == 0) {
        killTimer(d-&gt;transferRateTimer);
        d-&gt;transferRateTimer = 0;
    }
}

void TorrentClient::sendToPeer(int readId, int pieceIndex, int begin, const QByteArray &amp;data)
{
    // Send the requested block to the peer if the client connection
    // still exists; otherwise do nothing. This slot is called by the
    // file manager after it has read a block of data.
    PeerWireClient *client = d-&gt;readIds.value(readId);
    if (client) {
        if ((client-&gt;peerWireState() &amp; PeerWireClient::ChokingPeer) == 0)
            client-&gt;sendBlock(pieceIndex, begin, data);
    }
    d-&gt;readIds.remove(readId);
}

void TorrentClient::fullVerificationDone()
{
    // Update our list of completed and incomplete pieces.
    d-&gt;completedPieces = d-&gt;fileManager.completedPieces();
    d-&gt;incompletePieces.resize(d-&gt;completedPieces.size());
    d-&gt;pieceCount = d-&gt;completedPieces.size();
    for (int i = 0; i &lt; d-&gt;fileManager.pieceCount(); ++i) {
        if (!d-&gt;completedPieces.testBit(i))
            d-&gt;incompletePieces.setBit(i);
    }

    updateProgress();

    // If the checksums show that what the dumped state thought was
    // partial was in fact complete, then we trust the checksums.
    QMap&lt;int, TorrentPiece *&gt;::Iterator it = d-&gt;pendingPieces.begin();
    while (it != d-&gt;pendingPieces.end()) {
        if (d-&gt;completedPieces.testBit(it.key()))
            it = d-&gt;pendingPieces.erase(it);
        else
            ++it;
    }

    d-&gt;uploadScheduleTimer = startTimer(UploadScheduleInterval);

    // Start the server
    TorrentServer *server = TorrentServer::instance();
    if (!server-&gt;isListening()) {
        // Set up the peer wire server
        for (int i = ServerMinPort; i &lt;= ServerMaxPort; ++i) {
            if (server-&gt;listen(QHostAddress::Any, i))
                break;
        }
        if (!server-&gt;isListening()) {
            d-&gt;setError(ServerError);
            return;
        }
    }

    d-&gt;setState(d-&gt;completedPieces.count(true) == d-&gt;pieceCount ? Seeding : Searching);

    // Start the tracker client
    d-&gt;trackerClient.start(d-&gt;metaInfo);
}

void TorrentClient::pieceVerified(int pieceIndex, bool ok)
{
    TorrentPiece *piece = d-&gt;pendingPieces.value(pieceIndex);

    // Remove this piece from all payloads
    QMultiMap&lt;PeerWireClient *, TorrentPiece *&gt;::Iterator it = d-&gt;payloads.begin();
    while (it != d-&gt;payloads.end()) {
        if (it.value()-&gt;index == pieceIndex)
            it = d-&gt;payloads.erase(it);
        else
            ++it;
    }

    if (!ok) {
        // If a piece did not pass the SHA1 check, we'll simply clear
        // its state, and the scheduler will re-request it
        piece-&gt;inProgress = false;
        piece-&gt;completedBlocks.fill(false);
        piece-&gt;requestedBlocks.fill(false);
        d-&gt;callScheduler();
        return;
    }

    // Update the peer list so we know who's still interesting.
    foreach (TorrentPeer *peer, d-&gt;peers) {
        if (!peer-&gt;interesting)
            continue;
        bool interesting = false;
        for (int i = 0; i &lt; d-&gt;pieceCount; ++i) {
            if (peer-&gt;pieces.testBit(i) &amp;&amp; d-&gt;incompletePieces.testBit(i)) {
                interesting = true;
                break;
            }
        }
        peer-&gt;interesting = interesting;
    }

    // Delete the piece and update our structures.
    delete piece;
    d-&gt;pendingPieces.remove(pieceIndex);
    d-&gt;completedPieces.setBit(pieceIndex);
    d-&gt;incompletePieces.clearBit(pieceIndex);

    // Notify connected peers.
    foreach (PeerWireClient *client, d-&gt;connections) {
        if (client-&gt;state() == QAbstractSocket::ConnectedState
            &amp;&amp; !client-&gt;availablePieces().testBit(pieceIndex)) {
            client-&gt;sendPieceNotification(pieceIndex);
        }
    }

    // Notify the tracker if we've entered Seeding status; otherwise
    // call the scheduler.
    int completed = d-&gt;completedPieces.count(true);
    if (completed == d-&gt;pieceCount) {
        if (d-&gt;state != Seeding) {
            d-&gt;setState(Seeding);
            d-&gt;trackerClient.startSeeding();
        }
    } else {
        if (completed == 1)
            d-&gt;setState(Downloading);
        else if (d-&gt;incompletePieces.count(true) &lt; 5 &amp;&amp; d-&gt;pendingPieces.size() &gt; d-&gt;incompletePieces.count(true))
            d-&gt;setState(Endgame);
        d-&gt;callScheduler();
    }

    updateProgress();
}

void TorrentClient::handleFileError()
{
    if (d-&gt;state == Paused)
        return;
    setPaused(true);
    emit error(FileError);
}

void TorrentClient::connectToPeers()
{
    d-&gt;connectingToClients = false;

    if (d-&gt;state == Stopping || d-&gt;state == Idle || d-&gt;state == Paused)
        return;

    if (d-&gt;state == Searching)
        d-&gt;setState(Connecting);

    // Find the list of peers we are not currently connected to, where
    // the more interesting peers are listed more than once.
    QList&lt;TorrentPeer *&gt; weighedPeers = weighedFreePeers();

    // Start as many connections as we can
    while (!weighedPeers.isEmpty() &amp;&amp; ConnectionManager::instance()-&gt;canAddConnection()
           &amp;&amp; (qrand() % (ConnectionManager::instance()-&gt;maxConnections() / 2))) {
        PeerWireClient *client = new PeerWireClient(ConnectionManager::instance()-&gt;clientId(), this);
        RateController::instance()-&gt;addSocket(client);
        ConnectionManager::instance()-&gt;addConnection(client);

        initializeConnection(client);
        d-&gt;connections &lt;&lt; client;

        // Pick a random peer from the list of weighed peers.
        TorrentPeer *peer = weighedPeers.takeAt(qrand() % weighedPeers.size());
        weighedPeers.removeAll(peer);
        peer-&gt;connectStart = QDateTime::currentDateTime().toTime_t();
        peer-&gt;lastVisited = peer-&gt;connectStart;

        // Connect to the peer.
        client-&gt;setPeer(peer);
        client-&gt;connectToHost(peer-&gt;address, peer-&gt;port);
    }
}

QList&lt;TorrentPeer *&gt; TorrentClient::weighedFreePeers() const
{
    QList&lt;TorrentPeer *&gt; weighedPeers;

    // Generate a list of peers that we want to connect to.
    uint now = QDateTime::currentDateTime().toTime_t();
    QList&lt;TorrentPeer *&gt; freePeers;
    QMap&lt;QString, int&gt; connectionsPerPeer;
    foreach (TorrentPeer *peer, d-&gt;peers) {
        bool busy = false;
        foreach (PeerWireClient *client, d-&gt;connections) {
            if (client-&gt;state() == PeerWireClient::ConnectedState
                &amp;&amp; client-&gt;peerAddress() == peer-&gt;address
                &amp;&amp; client-&gt;peerPort() == peer-&gt;port) {
                if (++connectionsPerPeer[peer-&gt;address.toString()] &gt;= MaxConnectionPerPeer) {
                    busy = true;
                    break;
                }
            }
        }
        if (!busy &amp;&amp; (now - peer-&gt;lastVisited) &gt; uint(MinimumTimeBeforeRevisit))
            freePeers &lt;&lt; peer;
    }

    // Nothing to connect to
    if (freePeers.isEmpty())
        return weighedPeers;

    // Assign points based on connection speed and pieces available.
    QList&lt;QPair&lt;int, TorrentPeer *&gt; &gt; points;
    foreach (TorrentPeer *peer, freePeers) {
        int tmp = 0;
        if (peer-&gt;interesting) {
            tmp += peer-&gt;numCompletedPieces;
            if (d-&gt;state == Seeding)
                tmp = d-&gt;pieceCount - tmp;
            if (!peer-&gt;connectStart) // An unknown peer is as interesting as a seed
                tmp += d-&gt;pieceCount;

            // 1/5 of the total score for each second below 5 it takes to
            // connect.
            if (peer-&gt;connectTime &lt; 5)
                tmp += (d-&gt;pieceCount / 10) * (5 - peer-&gt;connectTime);
        }
        points &lt;&lt; QPair&lt;int, TorrentPeer *&gt;(tmp, peer);
    }
    std::sort(points.begin(), points.end());

    // Minimize the list so the point difference is never more than 1.
    typedef QPair&lt;int,TorrentPeer*&gt; PointPair;
    QMultiMap&lt;int, TorrentPeer *&gt; pointMap;
    int lowestScore = 0;
    int lastIndex = 0;
    foreach (PointPair point, points) {
        if (point.first &gt; lowestScore) {
            lowestScore = point.first;
            ++lastIndex;
        }
        pointMap.insert(lastIndex, point.second);
    }

    // Now make up a list of peers where the ones with more points are
    // listed many times.
    QMultiMap&lt;int, TorrentPeer *&gt;::ConstIterator it = pointMap.constBegin();
    while (it != pointMap.constEnd()) {
        for (int i = 0; i &lt; it.key() + 1; ++i)
            weighedPeers &lt;&lt; it.value();
        ++it;
    }

    return weighedPeers;
}

void TorrentClient::setupIncomingConnection(PeerWireClient *client)
{
    // Connect signals
    initializeConnection(client);

    // Initialize this client
    RateController::instance()-&gt;addSocket(client);
    d-&gt;connections &lt;&lt; client;

    client-&gt;initialize(d-&gt;infoHash, d-&gt;pieceCount);
    client-&gt;sendPieceList(d-&gt;completedPieces);

    emit peerInfoUpdated();

    if (d-&gt;state == Searching || d-&gt;state == Connecting) {
        int completed = d-&gt;completedPieces.count(true);
        if (completed == 0)
            d-&gt;setState(WarmingUp);
        else if (d-&gt;incompletePieces.count(true) &lt; 5 &amp;&amp; d-&gt;pendingPieces.size() &gt; d-&gt;incompletePieces.count(true))
            d-&gt;setState(Endgame);
    }

    if (d-&gt;connections.isEmpty())
        scheduleUploads();
}

void TorrentClient::setupOutgoingConnection()
{
    PeerWireClient *client = qobject_cast&lt;PeerWireClient *&gt;(sender());

    // Update connection statistics.
    foreach (TorrentPeer *peer, d-&gt;peers) {
        if (peer-&gt;port == client-&gt;peerPort() &amp;&amp; peer-&gt;address == client-&gt;peerAddress()) {
            peer-&gt;connectTime = peer-&gt;lastVisited - peer-&gt;connectStart;
            break;
        }
    }

    // Send handshake and piece list
    client-&gt;initialize(d-&gt;infoHash, d-&gt;pieceCount);
    client-&gt;sendPieceList(d-&gt;completedPieces);

    emit peerInfoUpdated();

    if (d-&gt;state == Searching || d-&gt;state == Connecting) {
        int completed = d-&gt;completedPieces.count(true);
        if (completed == 0)
            d-&gt;setState(WarmingUp);
        else if (d-&gt;incompletePieces.count(true) &lt; 5 &amp;&amp; d-&gt;pendingPieces.size() &gt; d-&gt;incompletePieces.count(true))
            d-&gt;setState(Endgame);
    }
}

void TorrentClient::initializeConnection(PeerWireClient *client)
{
    connect(client, SIGNAL(connected()),
            this, SLOT(setupOutgoingConnection()));
    connect(client, SIGNAL(disconnected()),
            this, SLOT(removeClient()));
    connect(client, SIGNAL(error(QAbstractSocket::SocketError)),
            this, SLOT(removeClient()));
    connect(client, SIGNAL(piecesAvailable(QBitArray)),
            this, SLOT(peerPiecesAvailable(QBitArray)));
    connect(client, SIGNAL(blockRequested(int,int,int)),
            this, SLOT(peerRequestsBlock(int,int,int)));
    connect(client, SIGNAL(blockReceived(int,int,QByteArray)),
            this, SLOT(blockReceived(int,int,QByteArray)));
    connect(client, SIGNAL(choked()),
            this, SLOT(peerChoked()));
    connect(client, SIGNAL(unchoked()),
            this, SLOT(peerUnchoked()));
    connect(client, SIGNAL(bytesWritten(qint64)),
            this, SLOT(peerWireBytesWritten(qint64)));
    connect(client, SIGNAL(bytesReceived(qint64)),
            this, SLOT(peerWireBytesReceived(qint64)));
}

void TorrentClient::removeClient()
{
    PeerWireClient *client = static_cast&lt;PeerWireClient *&gt;(sender());

    // Remove the host from our list of known peers if the connection
    // failed.
    if (client-&gt;peer() &amp;&amp; client-&gt;error() == QAbstractSocket::ConnectionRefusedError)
        d-&gt;peers.removeAll(client-&gt;peer());

    // Remove the client from RateController and all structures.
    RateController::instance()-&gt;removeSocket(client);
    d-&gt;connections.removeAll(client);
    QMultiMap&lt;PeerWireClient *, TorrentPiece *&gt;::Iterator it = d-&gt;payloads.find(client);
    while (it != d-&gt;payloads.end() &amp;&amp; it.key() == client) {
        TorrentPiece *piece = it.value();
        piece-&gt;inProgress = false;
        piece-&gt;requestedBlocks.fill(false);
        it = d-&gt;payloads.erase(it);
    }

    // Remove pending read requests.
    QMapIterator&lt;int, PeerWireClient *&gt; it2(d-&gt;readIds);
    while (it2.findNext(client))
        d-&gt;readIds.remove(it2.key());

    // Delete the client later.
    disconnect(client, SIGNAL(disconnected()), this, SLOT(removeClient()));
    client-&gt;deleteLater();
    ConnectionManager::instance()-&gt;removeConnection(client);

    emit peerInfoUpdated();
    d-&gt;callPeerConnector();
}

void TorrentClient::peerPiecesAvailable(const QBitArray &amp;pieces)
{
    PeerWireClient *client = qobject_cast&lt;PeerWireClient *&gt;(sender());

    // Find the peer in our list of announced peers. If it's there,
    // then we can use the piece list into to gather statistics that
    // help us decide what peers to connect to.
    TorrentPeer *peer = 0;
    QList&lt;TorrentPeer *&gt;::Iterator it = d-&gt;peers.begin();
    while (it != d-&gt;peers.end()) {
        if ((*it)-&gt;address == client-&gt;peerAddress() &amp;&amp; (*it)-&gt;port == client-&gt;peerPort()) {
            peer = *it;
            break;
        }
        ++it;
    }

    // If the peer is a seed, and we are in seeding mode, then the
    // peer is uninteresting.
    if (pieces.count(true) == d-&gt;pieceCount) {
        if (peer)
            peer-&gt;seed = true;
        emit peerInfoUpdated();
        if (d-&gt;state == Seeding) {
            client-&gt;abort();
            return;
        } else {
            if (peer)
                peer-&gt;interesting = true;
            if ((client-&gt;peerWireState() &amp; PeerWireClient::InterestedInPeer) == 0)
                client-&gt;sendInterested();
            d-&gt;callScheduler();
            return;
        }
    }

    // Update our list of available pieces.
    if (peer) {
        peer-&gt;pieces = pieces;
        peer-&gt;numCompletedPieces = pieces.count(true);
    }

    // Check for interesting pieces, and tell the peer whether we are
    // interested or not.
    bool interested = false;
    int piecesSize = pieces.size();
    for (int pieceIndex = 0; pieceIndex &lt; piecesSize; ++pieceIndex) {
        if (!pieces.testBit(pieceIndex))
            continue;
        if (!d-&gt;completedPieces.testBit(pieceIndex)) {
            interested = true;
            if ((client-&gt;peerWireState() &amp; PeerWireClient::InterestedInPeer) == 0) {
                if (peer)
                    peer-&gt;interesting = true;
                client-&gt;sendInterested();
            }

            QMultiMap&lt;PeerWireClient *, TorrentPiece *&gt;::Iterator it = d-&gt;payloads.find(client);
            int inProgress = 0;
            while (it != d-&gt;payloads.end() &amp;&amp; it.key() == client) {
                if (it.value()-&gt;inProgress)
                    inProgress += it.value()-&gt;requestedBlocks.count(true);
                ++it;
            }
            if (!inProgress)
                d-&gt;callScheduler();
            break;
        }
    }
    if (!interested &amp;&amp; (client-&gt;peerWireState() &amp; PeerWireClient::InterestedInPeer)) {
        if (peer)
            peer-&gt;interesting = false;
        client-&gt;sendNotInterested();
    }
}

void TorrentClient::peerRequestsBlock(int pieceIndex, int begin, int length)
{
    PeerWireClient *client = qobject_cast&lt;PeerWireClient *&gt;(sender());

    // Silently ignore requests from choked peers
    if (client-&gt;peerWireState() &amp; PeerWireClient::ChokingPeer)
        return;

    // Silently ignore requests for pieces we don't have.
    if (!d-&gt;completedPieces.testBit(pieceIndex))
        return;

    // Request the block from the file manager
    d-&gt;readIds.insert(d-&gt;fileManager.read(pieceIndex, begin, length),
                      qobject_cast&lt;PeerWireClient *&gt;(sender()));
}

void TorrentClient::blockReceived(int pieceIndex, int begin, const QByteArray &amp;data)
{
    PeerWireClient *client = qobject_cast&lt;PeerWireClient *&gt;(sender());
    if (data.size() == 0) {
        client-&gt;abort();
        return;
    }

    // Ignore it if we already have this block.
    int blockBit = begin / BlockSize;
    TorrentPiece *piece = d-&gt;pendingPieces.value(pieceIndex);
    if (!piece || piece-&gt;completedBlocks.testBit(blockBit)) {
        // Discard blocks that we already have, and fill up the pipeline.
        requestMore(client);
        return;
    }

    // If we are in warmup or endgame mode, cancel all duplicate
    // requests for this block.
    if (d-&gt;state == WarmingUp || d-&gt;state == Endgame) {
        QMultiMap&lt;PeerWireClient *, TorrentPiece *&gt;::Iterator it = d-&gt;payloads.begin();
        while (it != d-&gt;payloads.end()) {
            PeerWireClient *otherClient = it.key();
            if (otherClient != client &amp;&amp; it.value()-&gt;index == pieceIndex) {
                if (otherClient-&gt;incomingBlocks().contains(TorrentBlock(pieceIndex, begin, data.size())))
                    it.key()-&gt;cancelRequest(pieceIndex, begin, data.size());
            }
            ++it;
        }
    }

    if (d-&gt;state != Downloading &amp;&amp; d-&gt;state != Endgame &amp;&amp; d-&gt;completedPieces.count(true) &gt; 0)
        d-&gt;setState(Downloading);

    // Store this block
    d-&gt;fileManager.write(pieceIndex, begin, data);
    piece-&gt;completedBlocks.setBit(blockBit);
    piece-&gt;requestedBlocks.clearBit(blockBit);

    if (blocksLeftForPiece(piece) == 0) {
        // Ask the file manager to verify the newly downloaded piece
        d-&gt;fileManager.verifyPiece(piece-&gt;index);

        // Remove this piece from all payloads
        QMultiMap&lt;PeerWireClient *, TorrentPiece *&gt;::Iterator it = d-&gt;payloads.begin();
        while (it != d-&gt;payloads.end()) {
            if (!it.value() || it.value()-&gt;index == piece-&gt;index)
                it = d-&gt;payloads.erase(it);
            else
                ++it;
        }
    }

    // Fill up the pipeline.
    requestMore(client);
}

void TorrentClient::peerWireBytesWritten(qint64 size)
{
    if (!d-&gt;transferRateTimer)
        d-&gt;transferRateTimer = startTimer(RateControlTimerDelay);

    d-&gt;uploadRate[0] += size;
    d-&gt;uploadedBytes += size;
    emit dataSent(size);
}

void TorrentClient::peerWireBytesReceived(qint64 size)
{
    if (!d-&gt;transferRateTimer)
        d-&gt;transferRateTimer = startTimer(RateControlTimerDelay);

    d-&gt;downloadRate[0] += size;
    d-&gt;downloadedBytes += size;
    emit dataSent(size);
}

int TorrentClient::blocksLeftForPiece(const TorrentPiece *piece) const
{
    int blocksLeft = 0;
    int completedBlocksSize = piece-&gt;completedBlocks.size();
    for (int i = 0; i &lt; completedBlocksSize; ++i) {
        if (!piece-&gt;completedBlocks.testBit(i))
            ++blocksLeft;
    }
    return blocksLeft;
}

void TorrentClient::scheduleUploads()
{
    // Generate a list of clients sorted by their transfer
    // speeds.  When leeching, we sort by download speed, and when
    // seeding, we sort by upload speed. Seeds are left out; there's
    // no use in unchoking them.
    QList&lt;PeerWireClient *&gt; allClients = d-&gt;connections;
    QMultiMap&lt;int, PeerWireClient *&gt; transferSpeeds;
    foreach (PeerWireClient *client, allClients) {
        if (client-&gt;state() == QAbstractSocket::ConnectedState
            &amp;&amp; client-&gt;availablePieces().count(true) != d-&gt;pieceCount) {
            if (d-&gt;state == Seeding) {
                transferSpeeds.insert(client-&gt;uploadSpeed(), client);
            } else {
                transferSpeeds.insert(client-&gt;downloadSpeed(), client);
            }
        }
    }

    // Unchoke the top 'MaxUploads' downloaders (peers that we are
    // uploading to) and choke all others.
    int maxUploaders = MaxUploads;
    QMapIterator&lt;int, PeerWireClient *&gt; it(transferSpeeds);
    it.toBack();
    while (it.hasPrevious()) {
        PeerWireClient *client = it.previous().value();
        bool interested = (client-&gt;peerWireState() &amp; PeerWireClient::PeerIsInterested);

        if (maxUploaders) {
            allClients.removeAll(client);
            if (client-&gt;peerWireState() &amp; PeerWireClient::ChokingPeer)
                client-&gt;unchokePeer();
            --maxUploaders;
            continue;
        }

        if ((client-&gt;peerWireState() &amp; PeerWireClient::ChokingPeer) == 0) {
            if ((qrand() % 10) == 0)
                client-&gt;abort();
            else
                client-&gt;chokePeer();
            allClients.removeAll(client);
        }
        if (!interested)
            allClients.removeAll(client);
    }

    // Only interested peers are left in allClients. Unchoke one
    // random peer to allow it to compete for a position among the
    // downloaders.  (This is known as an &quot;optimistic unchoke&quot;.)
    if (!allClients.isEmpty()) {
        PeerWireClient *client = allClients[qrand() % allClients.size()];
        if (client-&gt;peerWireState() &amp; PeerWireClient::ChokingPeer)
            client-&gt;unchokePeer();
    }
}

void TorrentClient::scheduleDownloads()
{
    d-&gt;schedulerCalled = false;

    if (d-&gt;state == Stopping || d-&gt;state == Paused || d-&gt;state == Idle)
        return;

    // Check what each client is doing, and assign payloads to those
    // who are either idle or done.
    foreach (PeerWireClient *client, d-&gt;connections)
        schedulePieceForClient(client);
}

void TorrentClient::schedulePieceForClient(PeerWireClient *client)
{
    // Only schedule connected clients.
    if (client-&gt;state() != QTcpSocket::ConnectedState)
        return;

    // The peer has choked us; try again later.
    if (client-&gt;peerWireState() &amp; PeerWireClient::ChokedByPeer)
        return;

    // Make a list of all the client's pending pieces, and count how
    // many blocks have been requested.
    QList&lt;int&gt; currentPieces;
    bool somePiecesAreNotInProgress = false;
    TorrentPiece *lastPendingPiece = 0;
    QMultiMap&lt;PeerWireClient *, TorrentPiece *&gt;::Iterator it = d-&gt;payloads.find(client);
    while (it != d-&gt;payloads.end() &amp;&amp; it.key() == client) {
        lastPendingPiece = it.value();
        if (lastPendingPiece-&gt;inProgress) {
            currentPieces &lt;&lt; lastPendingPiece-&gt;index;
        } else {
            somePiecesAreNotInProgress = true;
        }
        ++it;
    }

    // Skip clients that already have too many blocks in progress.
    if (client-&gt;incomingBlocks().size() &gt;= ((d-&gt;state == Endgame || d-&gt;state == WarmingUp)
                                            ? MaxBlocksInMultiMode : MaxBlocksInProgress))
        return;

    // If all pieces are in progress, but we haven't filled up our
    // block requesting quota, then we need to schedule another piece.
    if (!somePiecesAreNotInProgress || client-&gt;incomingBlocks().size() &gt; 0)
        lastPendingPiece = 0;
    TorrentPiece *piece = lastPendingPiece;

    // In warmup state, all clients request blocks from the same pieces.
    if (d-&gt;state == WarmingUp &amp;&amp; d-&gt;pendingPieces.size() &gt;= 4) {
        piece = d-&gt;payloads.value(client);
        if (!piece) {
            QList&lt;TorrentPiece *&gt; values = d-&gt;pendingPieces.values();
            piece = values.value(qrand() % values.size());
            piece-&gt;inProgress = true;
            d-&gt;payloads.insert(client, piece);
        }
        if (piece-&gt;completedBlocks.count(false) == client-&gt;incomingBlocks().size())
            return;
    }

    // If no pieces are currently in progress, schedule a new one.
    if (!piece) {
        // Build up a list of what pieces that we have not completed
        // are available to this client.
        QBitArray incompletePiecesAvailableToClient = d-&gt;incompletePieces;

        // Remove all pieces that are marked as being in progress
        // already (i.e., pieces that this or other clients are
        // already waiting for). A special rule applies to warmup and
        // endgame mode; there, we allow several clients to request
        // the same piece. In endgame mode, this only applies to
        // clients that are currently uploading (more than 1.0KB/s).
        if ((d-&gt;state == Endgame &amp;&amp; client-&gt;uploadSpeed() &lt; 1024) || d-&gt;state != WarmingUp) {
            QMap&lt;int, TorrentPiece *&gt;::ConstIterator it = d-&gt;pendingPieces.constBegin();
            while (it != d-&gt;pendingPieces.constEnd()) {
                if (it.value()-&gt;inProgress)
                    incompletePiecesAvailableToClient.clearBit(it.key());
                ++it;
            }
        }

        // Remove all pieces that the client cannot download.
        incompletePiecesAvailableToClient &amp;= client-&gt;availablePieces();

        // Remove all pieces that this client has already requested.
        foreach (int i, currentPieces)
            incompletePiecesAvailableToClient.clearBit(i);

        // Only continue if more pieces can be scheduled. If no pieces
        // are available and no blocks are in progress, just leave
        // the connection idle; it might become interesting later.
        if (incompletePiecesAvailableToClient.count(true) == 0)
            return;

        // Check if any of the partially completed pieces can be
        // recovered, and if so, pick a random one of them.
        QList&lt;TorrentPiece *&gt; partialPieces;
        QMap&lt;int, TorrentPiece *&gt;::ConstIterator it = d-&gt;pendingPieces.constBegin();
        while (it != d-&gt;pendingPieces.constEnd()) {
            TorrentPiece *tmp = it.value();
            if (incompletePiecesAvailableToClient.testBit(it.key())) {
                if (!tmp-&gt;inProgress || d-&gt;state == WarmingUp || d-&gt;state == Endgame) {
                    partialPieces &lt;&lt; tmp;
                    break;
                }
            }
            ++it;
        }
        if (!partialPieces.isEmpty())
            piece = partialPieces.value(qrand() % partialPieces.size());

        if (!piece) {
            // Pick a random piece 3 out of 4 times; otherwise, pick either
            // one of the most common or the least common pieces available,
            // depending on the state we're in.
            int pieceIndex = 0;
            if (d-&gt;state == WarmingUp || (qrand() &amp; 4) == 0) {
                int *occurrences = new int[d-&gt;pieceCount];
                memset(occurrences, 0, d-&gt;pieceCount * sizeof(int));

                // Count how many of each piece are available.
                foreach (PeerWireClient *peer, d-&gt;connections) {
                    QBitArray peerPieces = peer-&gt;availablePieces();
                    int peerPiecesSize = peerPieces.size();
                    for (int i = 0; i &lt; peerPiecesSize; ++i) {
                        if (peerPieces.testBit(i))
                            ++occurrences[i];
                    }
                }

                // Find the rarest or most common pieces.
                int numOccurrences = d-&gt;state == WarmingUp ? 0 : 99999;
                QList&lt;int&gt; piecesReadyForDownload;
                for (int i = 0; i &lt; d-&gt;pieceCount; ++i) {
                    if (d-&gt;state == WarmingUp) {
                        // Add common pieces
                        if (occurrences[i] &gt;= numOccurrences
                            &amp;&amp; incompletePiecesAvailableToClient.testBit(i)) {
                            if (occurrences[i] &gt; numOccurrences)
                                piecesReadyForDownload.clear();
                            piecesReadyForDownload.append(i);
                            numOccurrences = occurrences[i];
                        }
                    } else {
                        // Add rare pieces
                        if (occurrences[i] &lt;= numOccurrences
                            &amp;&amp; incompletePiecesAvailableToClient.testBit(i)) {
                            if (occurrences[i] &lt; numOccurrences)
                                piecesReadyForDownload.clear();
                            piecesReadyForDownload.append(i);
                            numOccurrences = occurrences[i];
                        }
                    }
                }

                // Select one piece randomly
                pieceIndex = piecesReadyForDownload.at(qrand() % piecesReadyForDownload.size());
                delete [] occurrences;
            } else {
                // Make up a list of available piece indices, and pick
                // a random one.
                QList&lt;int&gt; values;
                int incompletePiecesAvailableToClientSize = incompletePiecesAvailableToClient.size();
                for (int i = 0; i &lt; incompletePiecesAvailableToClientSize; ++i) {
                    if (incompletePiecesAvailableToClient.testBit(i))
                        values &lt;&lt; i;
                }
                pieceIndex = values.at(qrand() % values.size());
            }

            // Create a new TorrentPiece and fill in all initial
            // properties.
            piece = new TorrentPiece;
            piece-&gt;index = pieceIndex;
            piece-&gt;length = d-&gt;fileManager.pieceLengthAt(pieceIndex);
            int numBlocks = piece-&gt;length / BlockSize;
            if (piece-&gt;length % BlockSize)
                ++numBlocks;
            piece-&gt;completedBlocks.resize(numBlocks);
            piece-&gt;requestedBlocks.resize(numBlocks);
            d-&gt;pendingPieces.insert(pieceIndex, piece);
        }

        piece-&gt;inProgress = true;
        d-&gt;payloads.insert(client, piece);
    }

    // Request more blocks from all pending pieces.
    requestMore(client);
}

void TorrentClient::requestMore(PeerWireClient *client)
{
    // Make a list of all pieces this client is currently waiting for,
    // and count the number of blocks in progress.
    QMultiMap&lt;PeerWireClient *, TorrentPiece *&gt;::Iterator it = d-&gt;payloads.find(client);
    int numBlocksInProgress = client-&gt;incomingBlocks().size();
    QList&lt;TorrentPiece *&gt; piecesInProgress;
    while (it != d-&gt;payloads.end() &amp;&amp; it.key() == client) {
        TorrentPiece *piece = it.value();
        if (piece-&gt;inProgress || (d-&gt;state == WarmingUp || d-&gt;state == Endgame))
            piecesInProgress &lt;&lt; piece;
        ++it;
    }

    // If no pieces are in progress, call the scheduler.
    if (piecesInProgress.isEmpty() &amp;&amp; d-&gt;incompletePieces.count(true)) {
        d-&gt;callScheduler();
        return;
    }

    // If too many pieces are in progress, there's nothing to do.
    int maxInProgress = ((d-&gt;state == Endgame || d-&gt;state == WarmingUp)
                         ? MaxBlocksInMultiMode : MaxBlocksInProgress);
    if (numBlocksInProgress == maxInProgress)
        return;

    // Starting with the first piece that we're waiting for, request
    // blocks until the quota is filled up.
    foreach (TorrentPiece *piece, piecesInProgress) {
        numBlocksInProgress += requestBlocks(client, piece, maxInProgress - numBlocksInProgress);
        if (numBlocksInProgress == maxInProgress)
            break;
    }

    // If we still didn't fill up the quota, we need to schedule more
    // pieces.
    if (numBlocksInProgress &lt; maxInProgress &amp;&amp; d-&gt;state != WarmingUp)
        d-&gt;callScheduler();
}

int TorrentClient::requestBlocks(PeerWireClient *client, TorrentPiece *piece, int maxBlocks)
{
    // Generate the list of incomplete blocks for this piece.
    QVector&lt;int&gt; bits;
    int completedBlocksSize = piece-&gt;completedBlocks.size();
    for (int i = 0; i &lt; completedBlocksSize; ++i) {
        if (!piece-&gt;completedBlocks.testBit(i) &amp;&amp; !piece-&gt;requestedBlocks.testBit(i))
            bits &lt;&lt; i;
    }

    // Nothing more to request.
    if (bits.size() == 0) {
        if (d-&gt;state != WarmingUp &amp;&amp; d-&gt;state != Endgame)
            return 0;
        bits.clear();
        for (int i = 0; i &lt; completedBlocksSize; ++i) {
            if (!piece-&gt;completedBlocks.testBit(i))
                bits &lt;&lt; i;
        }
    }

    if (d-&gt;state == WarmingUp || d-&gt;state == Endgame) {
        // By randomizing the list of blocks to request, we
        // significantly speed up the warmup and endgame modes, where
        // the same blocks are requested from multiple peers. The
        // speedup comes from an increased chance of receiving
        // different blocks from the different peers.
        for (int i = 0; i &lt; bits.size(); ++i) {
            int a = qrand() % bits.size();
            int b = qrand() % bits.size();
            int tmp = bits[a];
            bits[a] = bits[b];
            bits[b] = tmp;
        }
    }

    // Request no more blocks than we've been asked to.
    int blocksToRequest = qMin(maxBlocks, bits.size());

    // Calculate the offset and size of each block, and send requests.
    for (int i = 0; i &lt; blocksToRequest; ++i) {
        int blockSize = BlockSize;
        if ((piece-&gt;length % BlockSize) &amp;&amp; bits.at(i) == completedBlocksSize - 1)
            blockSize = piece-&gt;length % BlockSize;
        client-&gt;requestBlock(piece-&gt;index, bits.at(i) * BlockSize, blockSize);
        piece-&gt;requestedBlocks.setBit(bits.at(i));
    }

    return blocksToRequest;
}

void TorrentClient::peerChoked()
{
    PeerWireClient *client = qobject_cast&lt;PeerWireClient *&gt;(sender());
    if (!client)
        return;

    // When the peer chokes us, we immediately forget about all blocks
    // we've requested from it. We also remove the piece from out
    // payload, making it available to other clients.
    QMultiMap&lt;PeerWireClient *, TorrentPiece *&gt;::Iterator it = d-&gt;payloads.find(client);
    while (it != d-&gt;payloads.end() &amp;&amp; it.key() == client) {
        it.value()-&gt;inProgress = false;
        it.value()-&gt;requestedBlocks.fill(false);
        it = d-&gt;payloads.erase(it);
    }
}

void TorrentClient::peerUnchoked()
{
    PeerWireClient *client = qobject_cast&lt;PeerWireClient *&gt;(sender());
    if (!client)
        return;

    // We got unchoked, which means we can request more blocks.
    if (d-&gt;state != Seeding)
        d-&gt;callScheduler();
}

void TorrentClient::addToPeerList(const QList&lt;TorrentPeer&gt; &amp;peerList)
{
    // Add peers we don't already know of to our list of peers.
    QList&lt;QHostAddress&gt; addresses =  QNetworkInterface::allAddresses();
    foreach (TorrentPeer peer, peerList) {
        if (addresses.contains(peer.address)
            &amp;&amp; peer.port == TorrentServer::instance()-&gt;serverPort()) {
            // Skip our own server.
            continue;
        }

        bool known = false;
        foreach (TorrentPeer *knownPeer, d-&gt;peers) {
            if (knownPeer-&gt;port == peer.port
                &amp;&amp; knownPeer-&gt;address == peer.address) {
                known = true;
                break;
            }
        }
        if (!known) {
            TorrentPeer *newPeer = new TorrentPeer;
            *newPeer = peer;
            newPeer-&gt;interesting = true;
            newPeer-&gt;seed = false;
            newPeer-&gt;lastVisited = 0;
            newPeer-&gt;connectStart = 0;
            newPeer-&gt;connectTime = 999999;
            newPeer-&gt;pieces.resize(d-&gt;pieceCount);
            newPeer-&gt;numCompletedPieces = 0;
            d-&gt;peers &lt;&lt; newPeer;
        }
    }

    // If we've got more peers than we can connect to, we remove some
    // of the peers that have no (or low) activity.
    int maxPeers = ConnectionManager::instance()-&gt;maxConnections() * 3;
    if (d-&gt;peers.size() &gt; maxPeers) {
        // Find what peers are currently connected &amp; active
        QSet&lt;TorrentPeer *&gt; activePeers;
        foreach (TorrentPeer *peer, d-&gt;peers) {
            foreach (PeerWireClient *client, d-&gt;connections) {
                if (client-&gt;peer() == peer &amp;&amp; (client-&gt;downloadSpeed() + client-&gt;uploadSpeed()) &gt; 1024)
                    activePeers &lt;&lt; peer;
            }
        }

        // Remove inactive peers from the peer list until we're below
        // the max connections count.
        QList&lt;int&gt; toRemove;
        for (int i = 0; i &lt; d-&gt;peers.size() &amp;&amp; (d-&gt;peers.size() - toRemove.size()) &gt; maxPeers; ++i) {
            if (!activePeers.contains(d-&gt;peers.at(i)))
                toRemove &lt;&lt; i;
        }
        QListIterator&lt;int&gt; toRemoveIterator(toRemove);
        toRemoveIterator.toBack();
        while (toRemoveIterator.hasPrevious())
            d-&gt;peers.removeAt(toRemoveIterator.previous());

        // If we still have too many peers, remove the oldest ones.
        while (d-&gt;peers.size() &gt; maxPeers)
            d-&gt;peers.takeFirst();
    }

    if (d-&gt;state != Paused &amp;&amp; d-&gt;state != Stopping &amp;&amp; d-&gt;state != Idle) {
        if (d-&gt;state == Searching || d-&gt;state == WarmingUp)
            connectToPeers();
        else
            d-&gt;callPeerConnector();
    }
}

void TorrentClient::trackerStopped()
{
    d-&gt;setState(Idle);
    emit stopped();
}

void TorrentClient::updateProgress(int progress)
{
    if (progress == -1 &amp;&amp; d-&gt;pieceCount &gt; 0) {
        int newProgress = (d-&gt;completedPieces.count(true) * 100) / d-&gt;pieceCount;
        if (d-&gt;lastProgressValue != newProgress) {
            d-&gt;lastProgressValue = newProgress;
            emit progressUpdated(newProgress);
        }
    } else if (d-&gt;lastProgressValue != progress) {
        d-&gt;lastProgressValue = progress;
        emit progressUpdated(progress);
    }
}

</db:programlisting>
</db:article>
