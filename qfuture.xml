<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QFuture Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QFuture</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qfuture.xml">QFuture</db:link> class represents the result of an asynchronous computation.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">thread-safe</db:link> with the following exceptions:</db:para>
<db:para>These functions are only <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qfuture-const-iterator.xml">const_iterator</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QFuture</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QFuture is part of <db:simplelist><db:member>thread</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> allows threads to be synchronized against one or more results which will be ready at a later point in time. The result can be of any type that has default, copy and possibly move constructors. If a result is not available at the time of calling the <db:link xlink:href="qfuture.xml#result">result</db:link>(), <db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>(), <db:link xlink:href="qfuture.xml#results">results</db:link>() and <db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>() functions, <db:link xlink:href="qfuture.xml">QFuture</db:link> will wait until the result becomes available. You can use the <db:link xlink:href="qfuture.xml#isResultReadyAt">isResultReadyAt</db:link>() function to determine if a result is ready or not. For <db:link xlink:href="qfuture.xml">QFuture</db:link> objects that report more than one result, the <db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>() function returns the number of continuous results. This means that it is always safe to iterate through the results from 0 to <db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>(). <db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>() invalidates a future, and any subsequent attempt to access result or results from the future leads to undefined behavior. <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() tells you if results can be accessed.</db:para>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> provides a <db:link xlink:href="java-style-iterators.xml#java-style-iterators">Java-style iterator</db:link> (<db:link xlink:href="qfutureiterator.xml">QFutureIterator</db:link>) and an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> (<db:link xlink:href="qfuture-const-iterator.xml">QFuture::const_iterator</db:link>). Using these iterators is another way to access results in the future.</db:para>
<db:para>If the result of one asynchronous computation needs to be passed to another, <db:link xlink:href="qfuture.xml">QFuture</db:link> provides a convenient way of chaining multiple sequential computations using <db:link xlink:href="qfuture.xml#then">then</db:link>(). <db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>() can be used for adding a handler to be called if the <db:link xlink:href="qfuture.xml">QFuture</db:link> is canceled. Additionally, <db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>() can be used to handle any failures that occurred in the chain. Note that <db:link xlink:href="qfuture.xml">QFuture</db:link> relies on exceptions for the error handling. If using exceptions is not an option, you can still indicate the error state of <db:link xlink:href="qfuture.xml">QFuture</db:link>, by making the error type part of the <db:link xlink:href="qfuture.xml">QFuture</db:link> type. For example, you can use std::variant, std::any or similar for keeping the result or failure or make your custom type.</db:para>
<db:para>The example below demonstrates how the error handling can be done without using exceptions. Let's say we want to send a network request to obtain a large file from a network location. Then we want to write it to the file system and return its location in case of a success. Both of these operations may fail with different errors. So, we use std::variant to keep the result or error:</db:para>
<db:programlisting language="cpp">using NetworkReply = std::variant&amp;lt;QByteArray, QNetworkReply::NetworkError&amp;gt;;

enum class IOError { FailedToRead, FailedToWrite };
using IOResult = std::variant&amp;lt;QString, IOError&amp;gt;;
</db:programlisting>
<db:para>And we combine the two operations using <db:link xlink:href="qfuture.xml#then">then</db:link>():</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;IOResult&amp;gt; future = QtConcurrent::run([url] {
        ...
        return NetworkReply(QNetworkReply::TimeoutError);
}).then([](NetworkReply reply) {
    if (auto error = std::get_if&amp;lt;QNetworkReply::NetworkError&amp;gt;(&amp;amp;reply))
        return IOResult(IOError::FailedToRead);

    auto data = std::get_if&amp;lt;QByteArray&amp;gt;(&amp;amp;reply);
    // try to write *data and return IOError::FailedToWrite on failure
    ...
});

auto result = future.result();
if (auto filePath = std::get_if&amp;lt;QString&amp;gt;(&amp;amp;result)) {
    // do something with *filePath
else
    // process the error
</db:programlisting>
<db:para>It's possible to chain multiple continuations and handlers in any order. For example:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; testFuture = ...;
auto resultFuture = testFuture.then([](int res) {
    // Block 1
}).onCanceled([] {
    // Block 2
}).onFailed([] {
    // Block 3
}).then([] {
    // Block 4
}).onFailed([] {
    // Block 5
}).onCanceled([] {
    // Block 6
});
</db:programlisting>
<db:para>Depending on the state of testFuture (canceled, has exception or has a result), the next <db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>(), <db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>() or <db:link xlink:href="qfuture.xml#then">then</db:link>() will be called. So if testFuture is successfully fulfilled, Block 1 will be called. If it succeeds as well, the next <db:link xlink:href="qfuture.xml#then">then</db:link>() (Block 4) is called. If testFuture gets canceled or fails with an exception, either Block 2 or Block 3 will be called respectively. The next <db:link xlink:href="qfuture.xml#then">then</db:link>() will be called afterwards, and the story repeats.</db:para>
<db:note>
<db:para>If Block 2 is invoked and throws an exception, the following <db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>() (Block 3) will handle it. If the order of <db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>() and <db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>() were reversed, the exception state would propagate to the next continuations and eventually would be caught in Block 5.</db:para>
</db:note>
<db:para>In the next example the first <db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>() (Block 2) is removed:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; testFuture = ...;
auto resultFuture = testFuture.then([](int res) {
    // Block 1
}).onFailed([] {
    // Block 3
}).then([] {
    // Block 4
}).onFailed([] {
    // Block 5
}).onCanceled([] {
    // Block 6
});
</db:programlisting>
<db:para>If testFuture gets canceled, its state is propagated to the next <db:link xlink:href="qfuture.xml#then">then</db:link>(), which will be also canceled. So in this case Block 6 will be called.</db:para>
<db:para>The future can have only one continuation. Consider the following example:</db:para>
<db:programlisting language="cpp">QPromise&amp;lt;int&amp;gt; p;

QFuture&amp;lt;int&amp;gt; f1 = p.future();
f1.then([](int) { qDebug(&quot;first&quot;); });

QFuture&amp;lt;int&amp;gt; f2 = p.future();
f2.then([](int) { qDebug(&quot;second&quot;); });

p.start();
p.addResult(42);
p.finish();
</db:programlisting>
<db:para>In this case f1 and f2 are effectively the same <db:link xlink:href="qfuture.xml">QFuture</db:link> object, as they share the same internal state. As a result, calling <db:link xlink:href="qfuture.xml#then">then</db:link> on f2 will overwrite the continuation specified for f1. So, only &quot;second&quot; will be printed when this code is executed.</db:para>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> also offers ways to interact with a running computation. For instance, the computation can be canceled with the <db:link xlink:href="qfuture.xml#cancel">cancel</db:link>() function. To suspend or resume the computation, use the <db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>() function or one of the <db:link xlink:href="qfuture.xml#suspend">suspend</db:link>(), <db:link xlink:href="qfuture.xml#resume">resume</db:link>(), or <db:link xlink:href="qfuture.xml#toggleSuspended">toggleSuspended</db:link>() convenience functions. Be aware that not all running asynchronous computations can be canceled or suspended. For example, the future returned by QtConcurrent::run() cannot be canceled; but the future returned by QtConcurrent::mappedReduced() can.</db:para>
<db:para>Progress information is provided by the <db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>(), <db:link xlink:href="qfuture.xml#progressMinimum">progressMinimum</db:link>(), <db:link xlink:href="qfuture.xml#progressMaximum">progressMaximum</db:link>(), and <db:link xlink:href="qfuture.xml#progressText">progressText</db:link>() functions. The <db:link xlink:href="qfuture.xml#waitForFinished">waitForFinished</db:link>() function causes the calling thread to block and wait for the computation to finish, ensuring that all results are available.</db:para>
<db:para>The state of the computation represented by a <db:link xlink:href="qfuture.xml">QFuture</db:link> can be queried using the <db:link xlink:href="qfuture.xml#isCanceled">isCanceled</db:link>(), <db:link xlink:href="qfuture.xml#isStarted">isStarted</db:link>(), <db:link xlink:href="qfuture.xml#isFinished">isFinished</db:link>(), <db:link xlink:href="qfuture.xml#isRunning">isRunning</db:link>(), <db:link xlink:href="qfuture.xml#isSuspending">isSuspending</db:link>() or <db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>() functions.</db:para>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;void&gt; is specialized to not contain any of the result fetching functions. Any <db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;T&gt; can be assigned or copied into a <db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;void&gt; as well. This is useful if only status or progress information is needed - not the actual result data.</db:para>
<db:para>To interact with running tasks using signals and slots, use <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link>.</db:para>
<db:para>You can also use <db:link xlink:href="qtfuture.xml#connect">QtFuture::connect</db:link>() to connect signals to a <db:link xlink:href="qfuture.xml">QFuture</db:link> object which will be resolved when a signal is emitted. This allows working with signals like with <db:link xlink:href="qfuture.xml">QFuture</db:link> objects. For example, if you combine it with <db:link xlink:href="qfuture.xml#then">then</db:link>(), you can attach multiple continuations to a signal, which are invoked in the same thread or a new thread.</db:para>
<db:para>The <db:link xlink:href="qtfuture.xml#whenAll">QtFuture::whenAll</db:link>() and <db:link xlink:href="qtfuture.xml#whenAny">QtFuture::whenAny</db:link>() functions can be used to combine several futures and track when the last or first of them completes.</db:para>
<db:para>A ready <db:link xlink:href="qfuture.xml">QFuture</db:link> object with a value or a <db:link xlink:href="qfuture.xml">QFuture</db:link> object holding exception can be created using convenience functions <db:link xlink:href="qtfuture.xml#makeReadyVoidFuture">QtFuture::makeReadyVoidFuture</db:link>(), <db:link xlink:href="qtfuture.xml#makeReadyValueFuture">QtFuture::makeReadyValueFuture</db:link>(), <db:link xlink:href="qtfuture.xml#makeReadyRangeFuture">QtFuture::makeReadyRangeFuture</db:link>(), and <db:link xlink:href="qtfuture.xml#makeExceptionalFuture">QtFuture::makeExceptionalFuture</db:link>().</db:para>
<db:note>
<db:para>Some APIs (see <db:link xlink:href="qfuture.xml#then">QFuture::then</db:link>() or various <db:link xlink:href="qtconcurrent-module.xml">QtConcurrent</db:link> method overloads) allow scheduling the computation to a specific thread pool. However, <db:link xlink:href="qfuture.xml">QFuture</db:link> implements a work-stealing algorithm to prevent deadlocks and optimize thread usage. As a result, computations can be executed directly in the thread which requests the <db:link xlink:href="qfuture.xml">QFuture</db:link>'s result.</db:para>
</db:note>
<db:note>
<db:para>To start a computation and store results in a <db:link xlink:href="qfuture.xml">QFuture</db:link>, use <db:link xlink:href="qpromise.xml">QPromise</db:link> or one of the APIs in the <db:link xlink:href="qtconcurrent-index.xml">Qt Concurrent</db:link> framework.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qpromise.xml">QPromise</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#connect">QtFuture::connect</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyVoidFuture">QtFuture::makeReadyVoidFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyValueFuture">QtFuture::makeReadyValueFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyRangeFuture">QtFuture::makeReadyRangeFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeExceptionalFuture">QtFuture::makeExceptionalFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link></db:member>
<db:member><db:link xlink:href="qtconcurrent-index.xml">Qt Concurrent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QFuture::ConstIterator</db:title>
<db:typedefsynopsis>
<db:typedefname>ConstIterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qfuture-const-iterator.xml">QFuture::const_iterator</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QFuture">
<db:title>QFuture::QFuture()</db:title>
<db:constructorsynopsis>
<db:methodname>QFuture</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty, canceled future.</db:para>
</db:section>
<db:section xml:id="QFuture-4">
<db:title>QFuture::QFuture(const QFuture&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QFuture</db:methodname>
<db:methodparam>
<db:type>const QFuture&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture(const QFuture&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#operator-eq-1">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QFuture">
<db:title>QFuture::~QFuture()</db:title>
<db:destructorsynopsis>
<db:methodname>~QFuture</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QFuture()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the future.</db:para>
<db:para>Note that this neither waits nor cancels the asynchronous computation. Use <db:link xlink:href="qfuture.xml#waitForFinished">waitForFinished</db:link>() or <db:link xlink:href="qfuturesynchronizer.xml">QFutureSynchronizer</db:link> when you need to ensure that the computation is completed before the future is destroyed.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QFuture::const_iterator QFuture::begin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture::const_iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture::const_iterator begin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first result in the future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cancel">
<db:title>void QFuture::cancel()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>cancel</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void cancel()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Cancels the asynchronous computation represented by this future. Note that the cancellation is asynchronous. Use <db:link xlink:href="qfuture.xml#waitForFinished">waitForFinished</db:link>() after calling cancel() when you need synchronous cancellation.</db:para>
<db:para>Results currently available may still be accessed on a canceled future, but new results will <db:emphasis>not</db:emphasis> become available after calling this function. Any <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> object that is watching this future will not deliver progress and result ready signals on a canceled future.</db:para>
<db:para>Be aware that not all running asynchronous computations can be canceled. For example, the future returned by QtConcurrent::run() cannot be canceled; but the future returned by QtConcurrent::mappedReduced() can.</db:para>
</db:section>
<db:section xml:id="constBegin">
<db:title>QFuture::const_iterator QFuture::constBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture::const_iterator</db:type>
<db:methodname>constBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture::const_iterator constBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first result in the future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QFuture::const_iterator QFuture::constEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture::const_iterator</db:type>
<db:methodname>constEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture::const_iterator constEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary result after the last result in the future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end">
<db:title>QFuture::const_iterator QFuture::end() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture::const_iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture::const_iterator end() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary result after the last result in the future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isCanceled">
<db:title>bool QFuture::isCanceled() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isCanceled</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isCanceled() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation has been canceled with the <db:link xlink:href="qfuture.xml#cancel">cancel</db:link>() function; otherwise returns false.</db:para>
<db:para>Be aware that the computation may still be running even though this function returns true. See <db:link xlink:href="qfuture.xml#cancel">cancel</db:link>() for more details.</db:para>
</db:section>
<db:section xml:id="isFinished">
<db:title>bool QFuture::isFinished() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFinished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFinished() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation represented by this future has finished; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="isResultReadyAt">
<db:title>bool QFuture::isResultReadyAt(int <db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isResultReadyAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isResultReadyAt(int index) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the result at <db:code role="parameter">index</db:code> is immediately available; otherwise returns false.</db:para>
<db:note>
<db:para>Calling isResultReadyAt() leads to undefined behavior if <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() returns false for this <db:link xlink:href="qfuture.xml">QFuture</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isRunning">
<db:title>bool QFuture::isRunning() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isRunning</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isRunning() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation represented by this future is currently running; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="isStarted">
<db:title>bool QFuture::isStarted() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isStarted</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isStarted() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation represented by this future has been started; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="isSuspended">
<db:title>[since 6.0] bool QFuture::isSuspended() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSuspended</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSuspended() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if a suspension of the asynchronous computation has been requested, and it is in effect, meaning that no more results or progress changes are expected.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#toggleSuspended">toggleSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isSuspending">isSuspending</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSuspending">
<db:title>[since 6.0] bool QFuture::isSuspending() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSuspending</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSuspending() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation has been suspended with the <db:link xlink:href="qfuture.xml#suspend">suspend</db:link>() function, but the work is not yet suspended, and computation is still running. Returns false otherwise.</db:para>
<db:para>To check if suspension is actually in effect, use <db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>() instead.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#toggleSuspended">toggleSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>[since 6.0] bool QFuture::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if a result or results can be accessed or taken from this <db:link xlink:href="qfuture.xml">QFuture</db:link> object. Returns false after the result was taken from the future.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="onCanceled">
<db:title>[since 6.0] QFuture&lt;T&gt; QFuture::onCanceled(Function &amp;&amp;<db:emphasis>handler</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>onCanceled</db:methodname>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>handler</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; onCanceled(Function &amp;&amp;handler)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attaches a cancellation <db:code role="parameter">handler</db:code> to this future. The returned future behaves exactly as this future (has the same state and result) unless this future is cancelled. The <db:code role="parameter">handler</db:code> is a callable which takes no arguments and returns a value of the type packaged by this future. After cancellation, the returned future packages the value returned by <db:code role="parameter">handler</db:code>.</db:para>
<db:para>If attached before the cancellation, <db:code role="parameter">handler</db:code> will be invoked in the same thread that reports the future as finished after the cancellation. If the handler is attached after this future has already been canceled, it will be invoked immediately in the thread that executes onCanceled(). Therefore, the handler cannot always make assumptions about which thread it will be run on. Use the overload that takes a context object if you want to control which thread the handler is invoked on.</db:para>
<db:para>The example below demonstrates how to attach a cancellation handler:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; testFuture = ...;
auto resultFuture = testFuture.then([](int res) {
    // Block 1
    ...
    return 1;
}).then([](int res) {
    // Block 2
    ...
    return 2;
}).onCanceled([] {
    // Block 3
    ...
    return -1;
});
</db:programlisting>
<db:para>If testFuture is canceled, Block 3 will be called and the resultFuture will have -1 as its result. Unlike testFuture, it won't be in a Canceled state. This means that you can get its result, attach countinuations to it, and so on.</db:para>
<db:para>Also note that you can cancel the chain of continuations while they are executing via the future that started the chain. Let's say testFuture.cancel() was called while Block 1 is already executing. The next continuation will detect that cancellation was requested, so Block 2 will be skipped, and the cancellation handler (Block 3) will be called.</db:para>
<db:note>
<db:para>This method returns a new QFuture representing the result of the continuation chain. Canceling the resulting QFuture itself won't invoke the cancellation handler in the chain that lead to it. This means that if you call resultFuture.cancel(), Block 3 won't be called: because resultFuture is the future that results from attaching the cancellation handler to testFuture, no cancellation handlers have been attached to resultFuture itself. Only cancellation of testFuture or the futures returned by continuations attached before the onCancelled() call can trigger Block 3.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#then">then</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="onCanceled-1">
<db:title>[since 6.1] QFuture&lt;T&gt; QFuture::onCanceled(QObject *<db:emphasis>context</db:emphasis>, Function &amp;&amp;<db:emphasis>handler</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>onCanceled</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>context</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>handler</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; onCanceled(QObject *context, Function &amp;&amp;handler)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Attaches a cancellation <db:code role="parameter">handler</db:code> to this future, to be called when the future is canceled. The <db:code role="parameter">handler</db:code> is a callable which doesn't take any arguments. It will be invoked in the thread of the <db:code role="parameter">context</db:code> object. This can be useful if the cancellation needs to be handled in a specific thread.</db:para>
<db:para>If the <db:code role="parameter">context</db:code> is destroyed before the chain has finished, the future is canceled. See <db:link xlink:href="qfuture.xml#context-lifetime">then</db:link>() for details.</db:para>
<db:note>
<db:para>When calling this method, it should be guaranteed that the <db:code role="parameter">context</db:code> stays alive during setup of the chain.</db:para>
</db:note>
<db:para>See the documentation of the other overload for more details about <db:code role="parameter">handler</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#then">then</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="onFailed">
<db:title>[since 6.0] QFuture&lt;T&gt; QFuture::onFailed(Function &amp;&amp;<db:emphasis>handler</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>onFailed</db:methodname>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>handler</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; onFailed(Function &amp;&amp;handler)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attaches a failure handler to this future, to handle any exceptions. The returned future behaves exactly as this future (has the same state and result) unless this future fails with an exception.</db:para>
<db:para>The <db:code role="parameter">handler</db:code> is a callable which takes either no argument or one argument, to filter by specific error types, similar to the <db:link xlink:href="https://en.cppreference.com/w/cpp/language/try_catch">catch</db:link> statement. It returns a value of the type packaged by this future. After the failure, the returned future packages the value returned by <db:code role="parameter">handler</db:code>.</db:para>
<db:para>The handler will only be invoked if an exception is raised. If the exception is raised after this handler is attached, the handler is executed in the thread that reports the future as finished as a result of the exception. If the handler is attached after this future has already failed, it will be invoked immediately, in the thread that executes onFailed(). Therefore, the handler cannot always make assumptions about which thread it will be run on. Use the overload that takes a context object if you want to control which thread the handler is invoked on.</db:para>
<db:para>The example below demonstrates how to attach a failure handler:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
auto resultFuture = future.then([](int res) {
    ...
    throw Error();
    ...
}).onFailed([](const Error &amp;amp;e) {
    // Handle exceptions of type Error
    ...
    return -1;
}).onFailed([] {
    // Handle all other types of errors
    ...
    return -1;
});

auto result = resultFuture.result(); // result is -1
</db:programlisting>
<db:para>If there are multiple handlers attached, the first handler that matches with the thrown exception type will be invoked. For example:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
future.then([](int res) {
    ...
    throw std::runtime_error(&quot;message&quot;);
    ...
}).onFailed([](const std::exception &amp;amp;e) {
    // This handler will be invoked
}).onFailed([](const std::runtime_error &amp;amp;e) {
    // This handler won't be invoked, because of the handler above.
});
</db:programlisting>
<db:para>If none of the handlers matches with the thrown exception type, the exception will be propagated to the resulted future:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
auto resultFuture = future.then([](int res) {
    ...
    throw Error(&quot;message&quot;);
    ...
}).onFailed([](const std::exception &amp;amp;e) {
    // Won't be invoked
}).onFailed([](const QException &amp;amp;e) {
    // Won't be invoked
});

try {
    auto result = resultFuture.result();
} catch(...) {
    // Handle the exception
}
</db:programlisting>
<db:note>
<db:para>You can always attach a handler taking no argument, to handle all exception types and avoid writing the try-catch block.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#then">then</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="onFailed-1">
<db:title>[since 6.1] QFuture&lt;T&gt; QFuture::onFailed(QObject *<db:emphasis>context</db:emphasis>, Function &amp;&amp;<db:emphasis>handler</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>onFailed</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>context</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>handler</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; onFailed(QObject *context, Function &amp;&amp;handler)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Attaches a failure handler to this future, to handle any exceptions that the future raises, or that it has already raised. Returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> of the same type as this future. The handler will be invoked only in case of an exception, in the thread of the <db:code role="parameter">context</db:code> object. This can be useful if the failure needs to be handled in a specific thread. For example:</db:para>
<db:programlisting language="cpp">// somewhere in the main thread
auto future = QtConcurrent::run([] {
    // This will run in a separate thread
    ...
    throw std::exception();
}).onFailed(this, [] {
   // Update UI elements
});
</db:programlisting>
<db:para>The failure handler attached into <db:link xlink:href="qtconcurrent.xml#run">QtConcurrent::run</db:link> updates the UI elements and cannot be invoked from a non-gui thread. So this is provided as a context to .onFailed(), to make sure that it will be invoked in the main thread.</db:para>
<db:para>If the <db:code role="parameter">context</db:code> is destroyed before the chain has finished, the future is canceled. See <db:link xlink:href="qfuture.xml#context-lifetime">then</db:link>() for details.</db:para>
<db:note>
<db:para>When calling this method, it should be guaranteed that the <db:code role="parameter">context</db:code> stays alive during setup of the chain.</db:para>
</db:note>
<db:para>See the documentation of the other overload for more details about <db:code role="parameter">handler</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#then">then</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressMaximum">
<db:title>int QFuture::progressMaximum() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressMaximum</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressMaximum() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum <db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#progressMinimum">progressMinimum</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressMinimum">
<db:title>int QFuture::progressMinimum() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressMinimum</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressMinimum() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the minimum <db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#progressMaximum">progressMaximum</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressText">
<db:title>QString QFuture::progressText() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>progressText</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString progressText() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the (optional) textual representation of the progress as reported by the asynchronous computation.</db:para>
<db:para>Be aware that not all computations provide a textual representation of the progress, and as such, this function may return an empty string.</db:para>
</db:section>
<db:section xml:id="progressValue">
<db:title>int QFuture::progressValue() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressValue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressValue() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current progress value, which is between the <db:link xlink:href="qfuture.xml#progressMinimum">progressMinimum</db:link>() and <db:link xlink:href="qfuture.xml#progressMaximum">progressMaximum</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#progressMinimum">progressMinimum</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#progressMaximum">progressMaximum</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="result">
<db:title>T QFuture::result() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>result</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T result() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the first result in the future. If the result is not immediately available, this function will block and wait for the result to become available. This is a convenience method for calling <db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>(0). Note that result() returns a copy of the internally stored result. If T is a move-only type, or you don't want to copy the result, use <db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>() instead.</db:para>
<db:note>
<db:para>Calling result() leads to undefined behavior if <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() returns false for this <db:link xlink:href="qfuture.xml">QFuture</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resultAt">
<db:title>T QFuture::resultAt(int <db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>resultAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T resultAt(int index) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the result at <db:code role="parameter">index</db:code> in the future. If the result is not immediately available, this function will block and wait for the result to become available.</db:para>
<db:note>
<db:para>Calling resultAt() leads to undefined behavior if <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() returns false for this <db:link xlink:href="qfuture.xml">QFuture</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resultCount">
<db:title>int QFuture::resultCount() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>resultCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int resultCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of continuous results available in this future. The real number of results stored might be different from this value, due to gaps in the result set. It is always safe to iterate through the results from 0 to resultCount().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="results">
<db:title>QList&lt;T&gt; QFuture::results() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>results</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; results() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns all results from the future. If the results are not immediately available, this function will block and wait for them to become available. Note that results() returns a copy of the internally stored results. Getting all results of a move-only type T is not supported at the moment. However you can still iterate through the list of move-only results by using <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> or read-only <db:link xlink:href="java-style-iterators.xml#java-style-iterators">Java-style iterators</db:link>.</db:para>
<db:note>
<db:para>Calling results() leads to undefined behavior if <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() returns false for this <db:link xlink:href="qfuture.xml">QFuture</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resume">
<db:title>void QFuture::resume()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resume</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resume()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Resumes the asynchronous computation represented by the future(). This is a convenience method that simply calls <db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>(false).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#suspend">suspend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSuspended">
<db:title>[since 6.0] void QFuture::setSuspended(bool <db:emphasis>suspend</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSuspended</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>suspend</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSuspended(bool suspend)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">suspend</db:code> is true, this function suspends the asynchronous computation represented by the future(). If the computation is already suspended, this function does nothing. <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> will not immediately stop delivering progress and result ready signals when the future is suspended. At the moment of suspending there may still be computations that are in progress and cannot be stopped. Signals for such computations will still be delivered.</db:para>
<db:para>If <db:code role="parameter">suspend</db:code> is false, this function resumes the asynchronous computation. If the computation was not previously suspended, this function does nothing.</db:para>
<db:para>Be aware that not all computations can be suspended. For example, the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned by QtConcurrent::run() cannot be suspended; but the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned by QtConcurrent::mappedReduced() can.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#suspend">suspend</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#toggleSuspended">toggleSuspended</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="suspend">
<db:title>[since 6.0] void QFuture::suspend()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>suspend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void suspend()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Suspends the asynchronous computation represented by this future. This is a convenience method that simply calls <db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>(true).</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="takeResult">
<db:title>[since 6.0] T QFuture::takeResult()</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>takeResult</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T takeResult()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Call this function only if <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() returns true, otherwise the behavior is undefined. This function takes (moves) the first result from the <db:link xlink:href="qfuture.xml">QFuture</db:link> object, when only one result is expected. If there are any other results, they are discarded after taking the first one. If the result is not immediately available, this function will block and wait for the result to become available. The <db:link xlink:href="qfuture.xml">QFuture</db:link> will try to use move semantics if possible, and will fall back to copy construction if the type is not movable. After the result was taken, <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() will evaluate as false.</db:para>
<db:note>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> in general allows sharing the results between different <db:link xlink:href="qfuture.xml">QFuture</db:link> objects (and potentially between different threads). takeResult() was introduced to make <db:link xlink:href="qfuture.xml">QFuture</db:link> also work with move-only types (like std::unique_ptr), so it assumes that only one thread can move the results out of the future, and do it only once. Also note that taking the list of all results is not supported at the moment. However you can still iterate through the list of move-only results by using <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> or read-only <db:link xlink:href="java-style-iterators.xml#java-style-iterators">Java-style iterators</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="then">
<db:title>[since 6.0] QFuture&lt;ResultType&lt;Function&gt;&gt; QFuture::then(Function &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&lt;Function&gt;&gt;</db:type>
<db:methodname>then</db:methodname>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&lt;Function&gt;&gt; then(Function &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Attaches a continuation to this future, allowing to chain multiple asynchronous computations if desired, using the <db:link xlink:href="qtfuture.xml#Launch-enum">Sync</db:link> policy. <db:code role="parameter">function</db:code> is a callable that takes an argument of the type packaged by this future if this has a result (is not a <db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;void&gt;). Otherwise it takes no arguments. This method returns a new <db:link xlink:href="qfuture.xml">QFuture</db:link> that packages a value of the type returned by <db:code role="parameter">function</db:code>. The returned future will be in an uninitialized state until the attached continuation is invoked, or until this future fails or is canceled.</db:para>
<db:note>
<db:para>Use other overloads of this method if you need to launch the continuation in a separate thread.</db:para>
</db:note>
<db:para>You can chain multiple operations like this:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
future.then([](int res1){ ... }).then([](int res2){ ... })...
</db:programlisting>
<db:para>Or:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;void&amp;gt; future = ...;
future.then([](){ ... }).then([](){ ... })...
</db:programlisting>
<db:para>The continuation can also take a <db:link xlink:href="qfuture.xml">QFuture</db:link> argument (instead of its value), representing the previous future. This can be useful if, for example, <db:link xlink:href="qfuture.xml">QFuture</db:link> has multiple results, and the user wants to access them inside the continuation. Or the user needs to handle the exception of the previous future inside the continuation, to not interrupt the chain of multiple continuations. For example:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
    future.then([](QFuture&amp;lt;int&amp;gt; f) {
        try {
            ...
            auto result = f.result();
            ...
        } catch (QException &amp;amp;e) {
            // handle the exception
        }
    }).then(...);
</db:programlisting>
<db:para>If the previous future throws an exception and it is not handled inside the continuation, the exception will be propagated to the continuation future, to allow the caller to handle it:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
auto continuation = future.then([](int res1){ ... }).then([](int res2){ ... })...
...
// future throws an exception
try {
    auto result = continuation.result();
} catch (QException &amp;amp;e) {
    // handle the exception
}
</db:programlisting>
<db:para>In this case the whole chain of continuations will be interrupted.</db:para>
<db:note>
<db:para>If this future gets canceled, the continuations attached to it will also be canceled.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="then-1">
<db:title>[since 6.0] QFuture&lt;ResultType&lt;Function&gt;&gt; QFuture::then(QtFuture::Launch <db:emphasis>policy</db:emphasis>, Function &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&lt;Function&gt;&gt;</db:type>
<db:methodname>then</db:methodname>
<db:methodparam>
<db:type>QtFuture::Launch</db:type>
<db:parameter>policy</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&lt;Function&gt;&gt; then(QtFuture::Launch policy, Function &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Attaches a continuation to this future, allowing to chain multiple asynchronous computations. When the asynchronous computation represented by this future finishes, <db:code role="parameter">function</db:code> will be invoked according to the given launch <db:code role="parameter">policy</db:code>. A new <db:link xlink:href="qfuture.xml">QFuture</db:link> representing the result of the continuation is returned.</db:para>
<db:para>Depending on the <db:code role="parameter">policy</db:code>, continuation will be invoked in the same thread as this future, in a new thread, or will inherit the launch policy and thread pool of this future. If no launch policy is specified (see the overload taking only a callable), the Sync policy will be used.</db:para>
<db:para>In the following example both continuations will be invoked in a new thread (but in the same one).</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
future.then(QtFuture::Launch::Async, [](int res){ ... }).then([](int res2){ ... });
</db:programlisting>
<db:para>In the following example both continuations will be invoked in new threads using the same thread pool.</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
future.then(QtFuture::Launch::Async, [](int res){ ... })
      .then(QtFuture::Launch::Inherit, [](int res2){ ... });
</db:programlisting>
<db:para>See the documentation of the other overload for more details about <db:code role="parameter">function</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="then-2">
<db:title>[since 6.0] QFuture&lt;ResultType&lt;Function&gt;&gt; QFuture::then(QThreadPool *<db:emphasis>pool</db:emphasis>, Function &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&lt;Function&gt;&gt;</db:type>
<db:methodname>then</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&lt;Function&gt;&gt; then(QThreadPool *pool, Function &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Attaches a continuation to this future, allowing to chain multiple asynchronous computations if desired. When the asynchronous computation represented by this future finishes, <db:code role="parameter">function</db:code> will be scheduled on <db:code role="parameter">pool</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="then-3">
<db:title>[since 6.1] QFuture&lt;ResultType&lt;Function&gt;&gt; QFuture::then(QObject *<db:emphasis>context</db:emphasis>, Function &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&lt;Function&gt;&gt;</db:type>
<db:methodname>then</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>context</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&lt;Function&gt;&gt; then(QObject *context, Function &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Attaches a continuation to this future, allowing to chain multiple asynchronous computations if desired. When the asynchronous computation represented by this future finishes, <db:code role="parameter">function</db:code> will be invoked in the thread of the <db:code role="parameter">context</db:code> object. This can be useful if the continuation needs to be invoked in a specific thread. For example:</db:para>
<db:programlisting language="cpp">// somewhere in the main thread
auto future = QtConcurrent::run([] {
    // This will run in a separate thread
    ...
}).then(this, [] {
   // Update UI elements
});
</db:programlisting>
<db:para>The continuation attached into <db:link xlink:href="qtconcurrent.xml#run">QtConcurrent::run</db:link> updates the UI elements and cannot be invoked from a non-gui thread. So this is provided as a context to .then(), to make sure that it will be invoked in the main thread.</db:para>
<db:para>The following continuations will be also invoked from the same context, unless a different context or launch policy is specified:</db:para>
<db:programlisting language="cpp">auto future = QtConcurrent::run([] {
    ...
}).then(this, [] {
   // Update UI elements
}).then([] {
    // This will also run in the main thread
});
</db:programlisting>
<db:para>This is because by default .then() is invoked from the same thread as the previous one.</db:para>
<db:para>But note that if the continuation is attached after this future has already finished, it will be invoked immediately, in the thread that executes then():</db:para>
<db:programlisting language="cpp">QObject *context = ...;
auto future = cachedResultsReady ? QtFuture::makeReadyValueFuture(result)
                                 : QtConcurrent::run([] { /* compute result */});
auto continuation = future.then(context, [] (Result result) {
    // Runs in the context's thread
}).then([] {
    // May or may not run in the context's thread
});
</db:programlisting>
<db:para>In the above example if cachedResultsReady is true, and a ready future is returned, it is possible that the first .then() finishes before the second one is attached. In this case it will be resolved in the current thread. Therefore, when in doubt, pass the context explicitly.</db:para>
<db:anchor xml:id="context-lifetime"/>
<db:para>If the <db:code role="parameter">context</db:code> is destroyed before the chain has finished, the future is canceled. This implies that a cancellation handler might be invoked when the <db:code role="parameter">context</db:code> is not valid anymore. To guard against this, capture the <db:code role="parameter">context</db:code> as a <db:link xlink:href="qpointer.xml">QPointer</db:link>:</db:para>
<db:programlisting language="cpp">QObject *context = ...;
auto future = ...;
auto continuation = future.then(context, [context](Result result) {
                               // ...
                           }).onCanceled([context = QPointer(context)] {
                               if (!context)
                                   return;  // context was destroyed already
                               // handle cancellation
                           });
</db:programlisting>
<db:para>When the context object is destroyed, cancellation happens immediately. Previous futures in the chain are <db:emphasis>not</db:emphasis> cancelled and keep running until they are finished.</db:para>
<db:note>
<db:para>When calling this method, it should be guaranteed that the <db:code role="parameter">context</db:code> stays alive during setup of the chain.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toggleSuspended">
<db:title>[since 6.0] void QFuture::toggleSuspended()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>toggleSuspended</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void toggleSuspended()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Toggles the suspended state of the asynchronous computation. In other words, if the computation is currently suspending or suspended, calling this function resumes it; if the computation is running, it is suspended. This is a convenience method for calling <db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>(!(<db:link xlink:href="qfuture.xml#isSuspending">isSuspending</db:link>() || <db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>())).</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#suspend">suspend</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unwrap">
<db:title>[since 6.4] QFuture&lt;U&gt; QFuture::unwrap()</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;U&gt;</db:type>
<db:methodname>unwrap</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;U&gt; unwrap()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Unwraps the inner future from this QFuture&lt;T&gt;, where T is a future of type QFuture&lt;U&gt;, i.e. this future has type of QFuture&lt;QFuture&lt;U&gt;&gt;. For example:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;QFuture&amp;lt;int&amp;gt;&amp;gt; outerFuture = ...;
QFuture&amp;lt;int&amp;gt; unwrappedFuture = outerFuture.unwrap();
</db:programlisting>
<db:para>unwrappedFuture will be fulfilled as soon as the inner future nested inside the outerFuture is fulfilled, with the same result or exception and in the same thread that reports the inner future as finished. If the inner future is canceled, unwrappedFuture will also be canceled.</db:para>
<db:para>This is especially useful when chaining multiple computations, and one of them returns a QFuture as its result type. For example, let's say we want to download multiple images from an URL, scale the images, and reduce them to a single image using QtConcurrent::mappedReduced(). We could write something like:</db:para>
<db:programlisting language="cpp">auto downloadImages = [] (const QUrl &amp;amp;url) {
    QList&amp;lt;QImage&amp;gt; images;
    ...
    return images;
};

auto processImages = [](const QList&amp;lt;QImage&amp;gt; &amp;amp;images) {
   return QtConcurrent::mappedReduced(images, scale, reduceImages);
}

auto show = [](const QImage &amp;amp;image) { ... };

auto future = QtConcurrent::run(downloadImages, url)
               .then(processImages)
               .unwrap()
               .then(show);
</db:programlisting>
<db:para>Here QtConcurrent::mappedReduced() returns a QFuture&lt;QImage&gt;, so .then(processImages) returns a QFuture&lt;QFuture&lt;QImage&gt;&gt;. Since show() takes a QImage as argument, the result of .then(processImages) can't be passed to it directly. We need to call .unwrap(), that will get the result of the inner future when it's ready and pass it to the next continuation.</db:para>
<db:para>In case of multiple nesting, .unwrap() goes down to the innermost level:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;QFuture&amp;lt;QFuture&amp;lt;int&amp;gt;&amp;gt;&amp;gt;&amp;gt; outerFuture;
QFuture&amp;lt;int&amp;gt; unwrappedFuture = outerFuture.unwrap();

</db:programlisting>
<db:para>This function was introduced in Qt 6.4.</db:para>
</db:section>
<db:section xml:id="waitForFinished">
<db:title>void QFuture::waitForFinished()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>waitForFinished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void waitForFinished()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Waits for the asynchronous computation to finish (including <db:link xlink:href="qfuture.xml#cancel">cancel</db:link>()ed computations), i.e. until <db:link xlink:href="qfuture.xml#isFinished">isFinished</db:link>() returns true.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QFuture&lt;T&gt; &amp;QFuture::operator=(const QFuture&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QFuture&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; &amp; operator=(const QFuture&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">other</db:code> to this future and returns a reference to this future.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QFuture</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qfuture.xml">QFuture</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="isPaused">
<db:title>bool QFuture::isPaused() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isPaused</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isPaused() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuture.xml#isSuspending">isSuspending</db:link>() or <db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>() instead.</db:para>
<db:para>Returns true if the asynchronous computation has been paused with the <db:link xlink:href="qfuture.xml#pause">pause</db:link>() function; otherwise returns false.</db:para>
<db:para>Be aware that the computation may still be running even though this function returns true. See <db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>() for more details. To check if pause actually took effect, use <db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#toggleSuspended">toggleSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pause">
<db:title>void QFuture::pause()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pause</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pause()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuture.xml#suspend">suspend</db:link>() instead.</db:para>
<db:para>Pauses the asynchronous computation represented by this future. This is a convenience method that simply calls <db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>(true).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPaused">
<db:title>void QFuture::setPaused(bool <db:emphasis>paused</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPaused</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>paused</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPaused(bool paused)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>() instead.</db:para>
<db:para>If <db:code role="parameter">paused</db:code> is true, this function pauses the asynchronous computation represented by the future. If the computation is already paused, this function does nothing. Any <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> object that is watching this future will stop delivering progress and result ready signals while the future is paused. Signal delivery will continue once the future is resumed.</db:para>
<db:para>If <db:code role="parameter">paused</db:code> is false, this function resumes the asynchronous computation. If the computation was not previously paused, this function does nothing.</db:para>
<db:para>Be aware that not all computations can be paused. For example, the future returned by QtConcurrent::run() cannot be paused; but the future returned by QtConcurrent::mappedReduced() can.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#isPaused">isPaused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#suspend">suspend</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#toggleSuspended">toggleSuspended</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="togglePaused">
<db:title>void QFuture::togglePaused()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>togglePaused</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void togglePaused()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.0. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuture.xml#toggleSuspended">toggleSuspended</db:link>() instead.</db:para>
<db:para>Toggles the paused state of the asynchronous computation. In other words, if the computation is currently paused, calling this function resumes it; if the computation is running, it is paused. This is a convenience method for calling <db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>(!<db:link xlink:href="qfuture.xml#isPaused">isPaused</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#suspend">suspend</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
