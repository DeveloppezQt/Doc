<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QFuture Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QFuture</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.0.4 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qfuture.xml">QFuture</db:link> class represents the result of an asynchronous computation.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">thread-safe</db:link> with the following exceptions:</db:para>
<db:para>These functions are only <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qfuture-const-iterator.xml">const_iterator</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QFuture</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QFuture is part of <db:simplelist><db:member>thread</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> allows threads to be synchronized against one or more results which will be ready at a later point in time. The result can be of any type that has default, copy and possibly move constructors. If a result is not available at the time of calling the <db:link xlink:href="qfuture.xml#result">result</db:link>(), <db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>(), <db:link xlink:href="qfuture.xml#results">results</db:link>() and <db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>() functions, <db:link xlink:href="qfuture.xml">QFuture</db:link> will wait until the result becomes available. You can use the <db:link xlink:href="qfuture.xml#isResultReadyAt">isResultReadyAt</db:link>() function to determine if a result is ready or not. For <db:link xlink:href="qfuture.xml">QFuture</db:link> objects that report more than one result, the <db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>() function returns the number of continuous results. This means that it is always safe to iterate through the results from 0 to <db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>(). <db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>() invalidates a future, and any subsequent attempt to access result or results from the future leads to undefined behavior. <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() tells you if results can be accessed.</db:para>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> provides a <db:link xlink:href="java-style-iterators.xml#java-style-iterators">Java-style iterator</db:link> (<db:link xlink:href="qfutureiterator.xml">QFutureIterator</db:link>) and an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> (<db:link xlink:href="qfuture-const-iterator.xml">QFuture::const_iterator</db:link>). Using these iterators is another way to access results in the future.</db:para>
<db:para>If the result of one asynchronous computation needs to be passed to another, <db:link xlink:href="qfuture.xml">QFuture</db:link> provides a convenient way of chaining multiple sequential computations using <db:link xlink:href="qfuture.xml#then">then</db:link>(). <db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>() can be used for adding a handler to be called if the <db:link xlink:href="qfuture.xml">QFuture</db:link> is canceled. Additionally, <db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>() can be used to handle any failures that occurred in the chain. Note that <db:link xlink:href="qfuture.xml">QFuture</db:link> relies on exceptions for the error handling. If using exceptions is not an option, you can still indicate the error state of <db:link xlink:href="qfuture.xml">QFuture</db:link>, by making the error type part of the <db:link xlink:href="qfuture.xml">QFuture</db:link> type. For example, you can use std::variant, std::any or similar for keeping the result or failure or make your custom type.</db:para>
<db:para>The example below demonstrates how the error handling can be done without using exceptions. Let's say we want to send a network request to obtain a large file from a network location. Then we want to write it to the file system and return its location in case of a success. Both of these operations may fail with different errors. So, we use std::variant to keep the result or error:</db:para>
<db:programlisting language="cpp">using NetworkReply = std::variant&amp;lt;QByteArray, QNetworkReply::NetworkError&amp;gt;;

enum class IOError { FailedToRead, FailedToWrite };
using IOResult = std::variant&amp;lt;QString, IOError&amp;gt;;
</db:programlisting>
<db:para>And we combine the two operations using <db:link xlink:href="qfuture.xml#then">then</db:link>():</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;IOResult&amp;gt; future = QtConcurrent::run([url] {
        ...
        return NetworkReply(QNetworkReply::TimeoutError);
}).then([](NetworkReply reply) {
    if (auto error = std::get_if&amp;lt;QNetworkReply::NetworkError&amp;gt;(&amp;amp;reply))
        return IOResult(IOError::FailedToRead);

    auto data = std::get_if&amp;lt;QByteArray&amp;gt;(&amp;amp;reply);
    // try to write *data and return IOError::FailedToWrite on failure
    ...
});

auto result = future.result();
if (auto filePath = std::get_if&amp;lt;QString&amp;gt;(&amp;amp;result)) {
    // do something with *filePath
else
    // process the error
</db:programlisting>
<db:para>It's possible to chain multiple continuations and handlers in any order. The first handler that can handle the state of its parent is invoked first. If there's no proper handler, the state is propagated to the next continuation or handler. For example:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; testFuture = ...;
auto resultFuture = testFuture.then([](int res) {
    // Block 1
}).onCanceled([] {
    // Block 2
}).onFailed([] {
    // Block 3
}).then([] {
    // Block 4
}).onFailed([] {
    // Block 5
}).onCanceled([] {
    // Block 6
});
</db:programlisting>
<db:para>If testFuture is successfully fulfilled Block 1 will be called. If it succeeds as well, the next <db:link xlink:href="qfuture.xml#then">then</db:link>() (Block 4) is called. If testFuture gets canceled or fails with an exception, either Block 2 or Block 3 will be called respectively. The next <db:link xlink:href="qfuture.xml#then">then</db:link>() will be called afterwards, and the story repeats.</db:para>
<db:note>
<db:para>If Block 2 is invoked and throws an exception, the following <db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>() (Block 3) will handle it. If the order of <db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>() and <db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>() were reversed, the exception state would propagate to the next continuations and eventually would be caught in Block 5.</db:para>
</db:note>
<db:para>In the next example the first <db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>() (Block 2) is removed:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; testFuture = ...;
auto resultFuture = testFuture.then([](int res) {
    // Block 1
}).onFailed([] {
    // Block 3
}).then([] {
    // Block 4
}).onFailed([] {
    // Block 5
}).onCanceled([] {
    // Block 6
});
</db:programlisting>
<db:para>If testFuture gets canceled, its state is propagated to the next <db:link xlink:href="qfuture.xml#then">then</db:link>(), which will be also canceled. So in this case Block 6 will be called.</db:para>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> also offers ways to interact with a runnning computation. For instance, the computation can be canceled with the <db:link xlink:href="qfuture.xml#cancel">cancel</db:link>() function. To suspend or resume the computation, use the <db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>() function or one of the <db:link xlink:href="qfuture.xml#suspend">suspend</db:link>(), <db:link xlink:href="qfuture.xml#resume">resume</db:link>(), or <db:link xlink:href="qfuture.xml#toggleSuspended">toggleSuspended</db:link>() convenience functions. Be aware that not all running asynchronous computations can be canceled or suspended. For example, the future returned by QtConcurrent::run() cannot be canceled; but the future returned by QtConcurrent::mappedReduced() can.</db:para>
<db:para>Progress information is provided by the <db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>(), <db:link xlink:href="qfuture.xml#progressMinimum">progressMinimum</db:link>(), <db:link xlink:href="qfuture.xml#progressMaximum">progressMaximum</db:link>(), and <db:link xlink:href="qfuture.xml#progressText">progressText</db:link>() functions. The <db:link xlink:href="qfuture.xml#waitForFinished">waitForFinished</db:link>() function causes the calling thread to block and wait for the computation to finish, ensuring that all results are available.</db:para>
<db:para>The state of the computation represented by a <db:link xlink:href="qfuture.xml">QFuture</db:link> can be queried using the <db:link xlink:href="qfuture.xml#isCanceled">isCanceled</db:link>(), <db:link xlink:href="qfuture.xml#isStarted">isStarted</db:link>(), <db:link xlink:href="qfuture.xml#isFinished">isFinished</db:link>(), <db:link xlink:href="qfuture.xml#isRunning">isRunning</db:link>(), <db:link xlink:href="qfuture.xml#isSuspending">isSuspending</db:link>() or <db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>() functions.</db:para>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> is a lightweight reference counted class that can be passed by value.</db:para>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;void&gt; is specialized to not contain any of the result fetching functions. Any <db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;T&gt; can be assigned or copied into a <db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;void&gt; as well. This is useful if only status or progress information is needed - not the actual result data.</db:para>
<db:para>To interact with running tasks using signals and slots, use <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link>.</db:para>
<db:para>You can also use <db:link xlink:href="qtfuture.xml#connect">QtFuture::connect</db:link> to connect signals to a <db:link xlink:href="qfuture.xml">QFuture</db:link> object which will be resolved when a signal is emitted. This allows working with signals like with <db:link xlink:href="qfuture.xml">QFuture</db:link> objects. For example, if you combine it with <db:link xlink:href="qfuture.xml#then">then</db:link>(), you can attach multiple continuations to a signal, which are invoked in the same thread or a new thread.</db:para>
<db:note>
<db:para>To start a computation and store results in a <db:link xlink:href="qfuture.xml">QFuture</db:link>, use <db:link xlink:href="qpromise.xml">QPromise</db:link> or one of the APIs in the <db:link xlink:href="qtconcurrent-index.xml">Qt Concurrent</db:link> framework.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qpromise.xml">QPromise</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#connect">QtFuture::connect</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link></db:member>
<db:member><db:link xlink:href="qtconcurrent-index.xml">Qt Concurrent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QFuture::ConstIterator</db:title>
<db:typedefsynopsis>
<db:typedefname>ConstIterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qfuture-const-iterator.xml">QFuture::const_iterator</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QFuture">
<db:title>QFuture::QFuture()</db:title>
<db:constructorsynopsis>
<db:methodname>QFuture</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty, canceled future.</db:para>
</db:section>
<db:section xml:id="QFuture-4">
<db:title>QFuture::QFuture(const QFuture&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QFuture</db:methodname>
<db:methodparam>
<db:type>const QFuture&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture(const QFuture&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#operator-eq-1">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QFuture">
<db:title>QFuture::~QFuture()</db:title>
<db:destructorsynopsis>
<db:methodname>~QFuture</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QFuture()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the future.</db:para>
<db:para>Note that this neither waits nor cancels the asynchronous computation. Use <db:link xlink:href="qfuture.xml#waitForFinished">waitForFinished</db:link>() or <db:link xlink:href="qfuturesynchronizer.xml">QFutureSynchronizer</db:link> when you need to ensure that the computation is completed before the future is destroyed.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QFuture::const_iterator QFuture::begin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture::const_iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture::const_iterator begin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first result in the future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cancel">
<db:title>void QFuture::cancel()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>cancel</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void cancel()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Cancels the asynchronous computation represented by this future. Note that the cancelation is asynchronous. Use <db:link xlink:href="qfuture.xml#waitForFinished">waitForFinished</db:link>() after calling cancel() when you need synchronous cancelation.</db:para>
<db:para>Results currently available may still be accessed on a canceled future, but new results will <db:emphasis>not</db:emphasis> become available after calling this function. Any <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> object that is watching this future will not deliver progress and result ready signals on a canceled future.</db:para>
<db:para>Be aware that not all running asynchronous computations can be canceled. For example, the future returned by QtConcurrent::run() cannot be canceled; but the future returned by QtConcurrent::mappedReduced() can.</db:para>
</db:section>
<db:section xml:id="constBegin">
<db:title>QFuture::const_iterator QFuture::constBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture::const_iterator</db:type>
<db:methodname>constBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture::const_iterator constBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first result in the future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QFuture::const_iterator QFuture::constEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture::const_iterator</db:type>
<db:methodname>constEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture::const_iterator constEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary result after the last result in the future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end">
<db:title>QFuture::const_iterator QFuture::end() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture::const_iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture::const_iterator end() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary result after the last result in the future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isCanceled">
<db:title>bool QFuture::isCanceled() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isCanceled</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isCanceled() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation has been canceled with the <db:link xlink:href="qfuture.xml#cancel">cancel</db:link>() function; otherwise returns false.</db:para>
<db:para>Be aware that the computation may still be running even though this function returns true. See <db:link xlink:href="qfuture.xml#cancel">cancel</db:link>() for more details.</db:para>
</db:section>
<db:section xml:id="isFinished">
<db:title>bool QFuture::isFinished() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFinished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFinished() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation represented by this future has finished; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="isResultReadyAt">
<db:title>bool QFuture::isResultReadyAt(int <db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isResultReadyAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isResultReadyAt(int index) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the result at <db:code role="parameter">index</db:code> is immediately available; otherwise returns false.</db:para>
<db:note>
<db:para>Calling isResultReadyAt() leads to undefined behavior if <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() returns false for this <db:link xlink:href="qfuture.xml">QFuture</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isRunning">
<db:title>bool QFuture::isRunning() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isRunning</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isRunning() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation represented by this future is currently running; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="isStarted">
<db:title>bool QFuture::isStarted() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isStarted</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isStarted() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation represented by this future has been started; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="isSuspended">
<db:title>[since 6.0] bool QFuture::isSuspended() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSuspended</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSuspended() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if a suspension of the asynchronous computation has been requested, and it is in effect, meaning that no more results or progress changes are expected.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#toggleSuspended">toggleSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isSuspending">isSuspending</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSuspending">
<db:title>[since 6.0] bool QFuture::isSuspending() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSuspending</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSuspending() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation has been suspended with the <db:link xlink:href="qfuture.xml#suspend">suspend</db:link>() function, but the work is not yet suspended, and computation is still running. Returns false otherwise.</db:para>
<db:para>To check if suspension is actually in effect, use <db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>() instead.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#toggleSuspended">toggleSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>[since 6.0] bool QFuture::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if a result or results can be accessed or taken from this <db:link xlink:href="qfuture.xml">QFuture</db:link> object. Returns false after the result was taken from the future.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="onCanceled">
<db:title>[since 6.0] QFuture&lt;T&gt; QFuture::onCanceled(Function &amp;&amp;<db:emphasis>handler</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>onCanceled</db:methodname>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>handler</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; onCanceled(Function &amp;&amp;handler)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attaches a cancellation <db:code role="parameter">handler</db:code> to this future, to be called when the future is canceled. The <db:code role="parameter">handler</db:code> is a callable which doesn't take any arguments. It will be invoked in the same thread in which this future has been running. If the continuation is attached after the parent has already finished, it will be invoked in the thread where the parent lives.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#then">then</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="onFailed">
<db:title>[since 6.0] QFuture&lt;T&gt; QFuture::onFailed(Function &amp;&amp;<db:emphasis>handler</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>onFailed</db:methodname>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>handler</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; onFailed(Function &amp;&amp;handler)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attaches a failure handler to this future, to handle any exceptions that may have been generated. Returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> of the parent type. The handler will be invoked only in case of an exception, in the same thread as the parent future has been running. If the continuation is attached after the parent has already finished, it will be invoked in the thread where the parent lives. <db:code role="parameter">handler</db:code> is a callable which takes either no argument or one argument, to filter by specific error types similar to <db:link xlink:href="https://en.cppreference.com/w/cpp/language/try_catch">catch</db:link> statement.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
auto resultFuture = future.then([](int res) {
    ...
    throw Error();
    ...
}).onFailed([](const Error &amp;amp;e) {
    // Handle exceptions of type Error
    ...
    return -1;
}).onFailed([] {
    // Handle all other types of errors
    ...
    return -1;
});

auto result = resultFuture.result(); // result is -1
</db:programlisting>
<db:para>If there are multiple handlers attached, the first handler that matches with the thrown exception type will be invoked. For example:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
future.then([](int res) {
    ...
    throw std::runtime_error(&quot;message&quot;);
    ...
}).onFailed([](const std::exception &amp;amp;e) {
    // This handler will be invoked
}).onFailed([](const std::runtime_error &amp;amp;e) {
    // This handler won't be invoked, because of the handler above.
});
</db:programlisting>
<db:para>If none of the handlers matches with the thrown exception type, the exception will be propagated to the resulted future:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
auto resultFuture = future.then([](int res) {
    ...
    throw Error(&quot;message&quot;);
    ...
}).onFailed([](const std::exception &amp;amp;e) {
    // Won't be invoked
}).onFailed([](const QException &amp;amp;e) {
    // Won't be invoked
});

try {
    auto result = resultFuture.result();
} catch(...) {
    // Handle the exception
}
</db:programlisting>
<db:note>
<db:para>You can always attach a handler taking no argument, to handle all exception types and avoid writing the try-catch block.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#then">then</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressMaximum">
<db:title>int QFuture::progressMaximum() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressMaximum</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressMaximum() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum <db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#progressMinimum">progressMinimum</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressMinimum">
<db:title>int QFuture::progressMinimum() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressMinimum</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressMinimum() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the minimum <db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#progressMaximum">progressMaximum</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressText">
<db:title>QString QFuture::progressText() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>progressText</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString progressText() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the (optional) textual representation of the progress as reported by the asynchronous computation.</db:para>
<db:para>Be aware that not all computations provide a textual representation of the progress, and as such, this function may return an empty string.</db:para>
</db:section>
<db:section xml:id="progressValue">
<db:title>int QFuture::progressValue() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressValue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressValue() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current progress value, which is between the <db:link xlink:href="qfuture.xml#progressMinimum">progressMinimum</db:link>() and <db:link xlink:href="qfuture.xml#progressMaximum">progressMaximum</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#progressMinimum">progressMinimum</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#progressMaximum">progressMaximum</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="result">
<db:title>T QFuture::result() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>result</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T result() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the first result in the future. If the result is not immediately available, this function will block and wait for the result to become available. This is a convenience method for calling <db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>(0). Note that result() returns a copy of the internally stored result. If T is a move-only type, or you don't want to copy the result, use <db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>() instead.</db:para>
<db:note>
<db:para>Calling result() leads to undefined behavior if <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() returns false for this <db:link xlink:href="qfuture.xml">QFuture</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resultAt">
<db:title>T QFuture::resultAt(int <db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>resultAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T resultAt(int index) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the result at <db:code role="parameter">index</db:code> in the future. If the result is not immediately available, this function will block and wait for the result to become available.</db:para>
<db:note>
<db:para>Calling resultAt() leads to undefined behavior if <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() returns false for this <db:link xlink:href="qfuture.xml">QFuture</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resultCount">
<db:title>int QFuture::resultCount() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>resultCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int resultCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of continuous results available in this future. The real number of results stored might be different from this value, due to gaps in the result set. It is always safe to iterate through the results from 0 to resultCount().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="results">
<db:title>QList&lt;T&gt; QFuture::results() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>results</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; results() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns all results from the future. If the results are not immediately available, this function will block and wait for them to become available. Note that results() returns a copy of the internally stored results. Getting all results of a move-only type T is not supported at the moment. However you can still iterate through the list of move-only results by using <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> or read-only <db:link xlink:href="java-style-iterators.xml#java-style-iterators">Java-style iterators</db:link>.</db:para>
<db:note>
<db:para>Calling results() leads to undefined behavior if <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() returns false for this <db:link xlink:href="qfuture.xml">QFuture</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#takeResult">takeResult</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resume">
<db:title>void QFuture::resume()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resume</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resume()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Resumes the asynchronous computation represented by the future(). This is a convenience method that simply calls <db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>(false).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#suspend">suspend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSuspended">
<db:title>[since 6.0] void QFuture::setSuspended(bool <db:emphasis>suspend</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSuspended</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>suspend</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSuspended(bool suspend)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">suspend</db:code> is true, this function suspends the asynchronous computation represented by the future(). If the computation is already suspended, this function does nothing. <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> will not immediately stop delivering progress and result ready signals when the future is suspended. At the moment of suspending there may still be computations that are in progress and cannot be stopped. Signals for such computations will still be delivered.</db:para>
<db:para>If <db:code role="parameter">suspend</db:code> is false, this function resumes the asynchronous computation. If the computation was not previously suspended, this function does nothing.</db:para>
<db:para>Be aware that not all computations can be suspended. For example, the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned by QtConcurrent::run() cannot be suspended; but the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned by QtConcurrent::mappedReduced() can.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#suspend">suspend</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#toggleSuspended">toggleSuspended</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="suspend">
<db:title>[since 6.0] void QFuture::suspend()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>suspend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void suspend()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Suspends the asynchronous computation represented by this future. This is a convenience method that simply calls <db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>(true).</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="takeResult">
<db:title>[since 6.0] T QFuture::takeResult()</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>takeResult</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T takeResult()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Call this function only if <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() returns true, otherwise the behavior is undefined. This function takes (moves) the first result from the <db:link xlink:href="qfuture.xml">QFuture</db:link> object, when only one result is expected. If there are any other results, they are discarded after taking the first one. If the result is not immediately available, this function will block and wait for the result to become available. The <db:link xlink:href="qfuture.xml">QFuture</db:link> will try to use move semantics if possible, and will fall back to copy construction if the type is not movable. After the result was taken, <db:link xlink:href="qfuture.xml#isValid">isValid</db:link>() will evaluate as false.</db:para>
<db:note>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> in general allows sharing the results between different <db:link xlink:href="qfuture.xml">QFuture</db:link> objects (and potentially between different threads). takeResult() was introduced to make <db:link xlink:href="qfuture.xml">QFuture</db:link> also work with move-only types (like std::unique_ptr), so it assumes that only one thread can move the results out of the future, and do it only once. Also note that taking the list of all results is not supported at the moment. However you can still iterate through the list of move-only results by using <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> or read-only <db:link xlink:href="java-style-iterators.xml#java-style-iterators">Java-style iterators</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="then">
<db:title>[since 6.0] QFuture&lt;ResultType&lt;Function&gt;&gt; QFuture::then(Function &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&lt;Function&gt;&gt;</db:type>
<db:methodname>then</db:methodname>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&lt;Function&gt;&gt; then(Function &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Attaches a continuation to this future, allowing to chain multiple asynchronous computations if desired. When the asynchronous computation represented by this future finishes, <db:code role="parameter">function</db:code> will be invoked in the same thread in which this future has been running. If the continuation is attached after the parent has already finished, it will be invoked in the thread where the parent lives. This method returns a new <db:link xlink:href="qfuture.xml">QFuture</db:link> representing the result of the continuation.</db:para>
<db:note>
<db:para>Use other overloads of this method if you need to launch the continuation in a separate thread.</db:para>
</db:note>
<db:para>If this future has a result (is not a <db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;void&gt;), <db:code role="parameter">function</db:code> takes the result of this future as its argument.</db:para>
<db:para>You can chain multiple operations like this:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
future.then([](int res1){ ... }).then([](int res2){ ... })...
</db:programlisting>
<db:para>Or:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;void&amp;gt; future = ...;
future.then([](){ ... }).then([](){ ... })...
</db:programlisting>
<db:para>The continuation can also take a <db:link xlink:href="qfuture.xml">QFuture</db:link> argument (instead of its value), representing the previous future. This can be useful if, for example, <db:link xlink:href="qfuture.xml">QFuture</db:link> has multiple results, and the user wants to access them inside the continuation. Or the user needs to handle the exception of the previous future inside the continuation, to not interrupt the chain of multiple continuations. For example:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
    future.then([](QFuture&amp;lt;int&amp;gt; f) {
        try {
            ...
            auto result = f.result();
            ...
        } catch (QException &amp;amp;e) {
            // handle the exception
        }
    }).then(...);
</db:programlisting>
<db:para>If the previous future throws an exception and it is not handled inside the continuation, the exception will be propagated to the continuation future, to allow the caller to handle it:</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; parentFuture = ...;
auto continuation = parentFuture.then([](int res1){ ... }).then([](int res2){ ... })...
...
// parentFuture throws an exception
try {
    auto result = continuation.result();
} catch (QException &amp;amp;e) {
    // handle the exception
}
</db:programlisting>
<db:para>In this case the whole chain of continuations will be interrupted.</db:para>
<db:note>
<db:para>If the parent future gets canceled, its continuations will also be canceled.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="then-1">
<db:title>[since 6.0] QFuture&lt;ResultType&lt;Function&gt;&gt; QFuture::then(QtFuture::Launch <db:emphasis>policy</db:emphasis>, Function &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&lt;Function&gt;&gt;</db:type>
<db:methodname>then</db:methodname>
<db:methodparam>
<db:type>QtFuture::Launch</db:type>
<db:parameter>policy</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&lt;Function&gt;&gt; then(QtFuture::Launch policy, Function &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Attaches a continuation to this future, allowing to chain multiple asynchronous computations. When the asynchronous computation represented by this future finishes, <db:code role="parameter">function</db:code> will be invoked according to the given launch <db:code role="parameter">policy</db:code>. A new <db:link xlink:href="qfuture.xml">QFuture</db:link> representing the result of the continuation is returned.</db:para>
<db:para>Depending on the <db:code role="parameter">policy</db:code>, continuation will run in the same thread as the parent, run in a new thread, or inherit the launch policy and thread pool of the parent.</db:para>
<db:para>In the following example both continuations will run in a new thread (but in the same one).</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
future.then(QtFuture::Launch::Async, [](int res){ ... }).then([](int res2){ ... });
</db:programlisting>
<db:para>In the following example both continuations will run in new threads using the same thread pool.</db:para>
<db:programlisting language="cpp">QFuture&amp;lt;int&amp;gt; future = ...;
future.then(QtFuture::Launch::Async, [](int res){ ... })
      .then(QtFuture::Launch::Inherit, [](int res2){ ... });
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="then-2">
<db:title>[since 6.0] QFuture&lt;ResultType&lt;Function&gt;&gt; QFuture::then(QThreadPool *<db:emphasis>pool</db:emphasis>, Function &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&lt;Function&gt;&gt;</db:type>
<db:methodname>then</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Function &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&lt;Function&gt;&gt; then(QThreadPool *pool, Function &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Attaches a continuation to this future, allowing to chain multiple asynchronous computations if desired. When the asynchronous computation represented by this future finishes, <db:code role="parameter">function</db:code> will be invoked in a separate thread taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#onFailed">onFailed</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#onCanceled">onCanceled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toggleSuspended">
<db:title>[since 6.0] void QFuture::toggleSuspended()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>toggleSuspended</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void toggleSuspended()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Toggles the suspended state of the asynchronous computation. In other words, if the computation is currently suspending or suspended, calling this function resumes it; if the computation is running, it is suspended. This is a convenience method for calling <db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>(!(<db:link xlink:href="qfuture.xml#isSuspending">isSuspending</db:link>() || <db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>())).</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#suspend">suspend</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForFinished">
<db:title>void QFuture::waitForFinished()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>waitForFinished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void waitForFinished()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Waits for the asynchronous computation to finish (including <db:link xlink:href="qfuture.xml#cancel">cancel</db:link>()ed computations), i.e. until <db:link xlink:href="qfuture.xml#isFinished">isFinished</db:link>() returns true.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QFuture&lt;T&gt; &amp;QFuture::operator=(const QFuture&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QFuture&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; &amp; operator=(const QFuture&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">other</db:code> to this future and returns a reference to this future.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QFuture</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qfuture.xml">QFuture</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="isPaused">
<db:title>bool QFuture::isPaused() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isPaused</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isPaused() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuture.xml#isSuspending">isSuspending</db:link>() or <db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>() instead.</db:para>
<db:para>Returns true if the asynchronous computation has been paused with the <db:link xlink:href="qfuture.xml#pause">pause</db:link>() function; otherwise returns false.</db:para>
<db:para>Be aware that the computation may still be running even though this function returns true. See <db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>() for more details. To check if pause actually took effect, use <db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#togglePaused">togglePaused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isSuspended">isSuspended</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pause">
<db:title>void QFuture::pause()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pause</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pause()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuture.xml#suspend">suspend</db:link>() instead.</db:para>
<db:para>Pauses the asynchronous computation represented by this future. This is a convenience method that simply calls <db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>(true).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPaused">
<db:title>void QFuture::setPaused(bool <db:emphasis>paused</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPaused</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>paused</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPaused(bool paused)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuture.xml#setSuspended">setSuspended</db:link>() instead.</db:para>
<db:para>If <db:code role="parameter">paused</db:code> is true, this function pauses the asynchronous computation represented by the future. If the computation is already paused, this function does nothing. Any <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> object that is watching this future will stop delivering progress and result ready signals while the future is paused. Signal delivery will continue once the future is resumed.</db:para>
<db:para>If <db:code role="parameter">paused</db:code> is false, this function resumes the asynchronous computation. If the computation was not previously paused, this function does nothing.</db:para>
<db:para>Be aware that not all computations can be paused. For example, the future returned by QtConcurrent::run() cannot be paused; but the future returned by QtConcurrent::mappedReduced() can.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#isPaused">isPaused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#pause">pause</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#togglePaused">togglePaused</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="togglePaused">
<db:title>void QFuture::togglePaused()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>togglePaused</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void togglePaused()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuture.xml#toggleSuspended">toggleSuspended</db:link>() instead.</db:para>
<db:para>Toggles the paused state of the asynchronous computation. In other words, if the computation is currently paused, calling this function resumes it; if the computation is running, it is paused. This is a convenience method for calling <db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>(!<db:link xlink:href="qfuture.xml#isPaused">isPaused</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#pause">pause</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
