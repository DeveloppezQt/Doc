<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QFuture Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QFuture</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.13.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qfuture.xml">QFuture</db:link> class represents the result of an asynchronous computation.</db:para>
<db:para>This class was introduced in Qt 4.4.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">thread-safe</db:link> with the following exceptions:</db:para>
<db:para>These functions are only <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qfuture-const-iterator.xml">const_iterator</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QFuture</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.4</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QFuture is part of <db:simplelist><db:member>thread</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>To start a computation, use one of the APIs in the <db:link xlink:href="qtconcurrent-index.xml">Qt Concurrent</db:link> framework.</db:para>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> allows threads to be synchronized against one or more results which will be ready at a later point in time. The result can be of any type that has a default constructor and a copy constructor. If a result is not available at the time of calling the <db:link xlink:href="qfuture.xml#result">result</db:link>(), <db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>(), or <db:link xlink:href="qfuture.xml#results">results</db:link>() functions, <db:link xlink:href="qfuture.xml">QFuture</db:link> will wait until the result becomes available. You can use the <db:link xlink:href="qfuture.xml#isResultReadyAt">isResultReadyAt</db:link>() function to determine if a result is ready or not. For <db:link xlink:href="qfuture.xml">QFuture</db:link> objects that report more than one result, the <db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>() function returns the number of continuous results. This means that it is always safe to iterate through the results from 0 to <db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>().</db:para>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> provides a <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterator</db:link> (QFutureIterator) and an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> (<db:link xlink:href="qfuture-const-iterator.xml">QFuture::const_iterator</db:link>). Using these iterators is another way to access results in the future.</db:para>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> also offers ways to interact with a runnning computation. For instance, the computation can be canceled with the <db:link xlink:href="qfuture.xml#cancel">cancel</db:link>() function. To pause the computation, use the <db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>() function or one of the <db:link xlink:href="qfuture.xml#pause">pause</db:link>(), <db:link xlink:href="qfuture.xml#resume">resume</db:link>(), or <db:link xlink:href="qfuture.xml#togglePaused">togglePaused</db:link>() convenience functions. Be aware that not all running asynchronous computations can be canceled or paused. For example, the future returned by QtConcurrent::run() cannot be canceled; but the future returned by QtConcurrent::mappedReduced() can.</db:para>
<db:para>Progress information is provided by the <db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>(), <db:link xlink:href="qfuture.xml#progressMinimum">progressMinimum</db:link>(), <db:link xlink:href="qfuture.xml#progressMaximum">progressMaximum</db:link>(), and <db:link xlink:href="qfuture.xml#progressText">progressText</db:link>() functions. The <db:link xlink:href="qfuture.xml#waitForFinished">waitForFinished</db:link>() function causes the calling thread to block and wait for the computation to finish, ensuring that all results are available.</db:para>
<db:para>The state of the computation represented by a <db:link xlink:href="qfuture.xml">QFuture</db:link> can be queried using the <db:link xlink:href="qfuture.xml#isCanceled">isCanceled</db:link>(), <db:link xlink:href="qfuture.xml#isStarted">isStarted</db:link>(), <db:link xlink:href="qfuture.xml#isFinished">isFinished</db:link>(), <db:link xlink:href="qfuture.xml#isRunning">isRunning</db:link>(), or <db:link xlink:href="qfuture.xml#isPaused">isPaused</db:link>() functions.</db:para>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link> is a lightweight reference counted class that can be passed by value.</db:para>
<db:para><db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;void&gt; is specialized to not contain any of the result fetching functions. Any <db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;T&gt; can be assigned or copied into a <db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;void&gt; as well. This is useful if only status or progress information is needed - not the actual result data.</db:para>
<db:para>To interact with running tasks using signals and slots, use <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link></db:member>
<db:member><db:link xlink:href="qtconcurrent-index.xml">Qt Concurrent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QFuture::ConstIterator</db:title>
<db:typedefsynopsis>
<db:typedefname>ConstIterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qfuture-const-iterator.xml">QFuture::const_iterator</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QFuture">
<db:title>QFuture::QFuture()</db:title>
<db:constructorsynopsis>
<db:methodname>QFuture</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty, canceled future.</db:para>
</db:section>
<db:section xml:id="QFuture-2">
<db:title>QFuture::QFuture(const QFuture&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QFuture</db:methodname>
<db:methodparam>
<db:type>const QFuture&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture(const QFuture&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QFuture">
<db:title>QFuture::~QFuture()</db:title>
<db:destructorsynopsis>
<db:methodname>~QFuture</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QFuture()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the future.</db:para>
<db:para>Note that this neither waits nor cancels the asynchronous computation. Use <db:link xlink:href="qfuture.xml#waitForFinished">waitForFinished</db:link>() or <db:link xlink:href="qfuturesynchronizer.xml">QFutureSynchronizer</db:link> when you need to ensure that the computation is completed before the future is destroyed.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QFuture::const_iterator QFuture::begin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture::const_iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture::const_iterator begin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first result in the future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cancel">
<db:title>void QFuture::cancel()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>cancel</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void cancel()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Cancels the asynchronous computation represented by this future. Note that the cancelation is asynchronous. Use <db:link xlink:href="qfuture.xml#waitForFinished">waitForFinished</db:link>() after calling cancel() when you need synchronous cancelation.</db:para>
<db:para>Results currently available may still be accessed on a canceled future, but new results will <db:emphasis>not</db:emphasis> become available after calling this function. Any <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> object that is watching this future will not deliver progress and result ready signals on a canceled future.</db:para>
<db:para>Be aware that not all running asynchronous computations can be canceled. For example, the future returned by QtConcurrent::run() cannot be canceled; but the future returned by QtConcurrent::mappedReduced() can.</db:para>
</db:section>
<db:section xml:id="constBegin">
<db:title>QFuture::const_iterator QFuture::constBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture::const_iterator</db:type>
<db:methodname>constBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture::const_iterator constBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first result in the future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QFuture::const_iterator QFuture::constEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture::const_iterator</db:type>
<db:methodname>constEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture::const_iterator constEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary result after the last result in the future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end">
<db:title>QFuture::const_iterator QFuture::end() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture::const_iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture::const_iterator end() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary result after the last result in the future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isCanceled">
<db:title>bool QFuture::isCanceled() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isCanceled</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isCanceled() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the asynchronous computation has been canceled with the <db:link xlink:href="qfuture.xml#cancel">cancel</db:link>() function; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Be aware that the computation may still be running even though this function returns <db:code>true</db:code>. See <db:link xlink:href="qfuture.xml#cancel">cancel</db:link>() for more details.</db:para>
</db:section>
<db:section xml:id="isFinished">
<db:title>bool QFuture::isFinished() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFinished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFinished() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the asynchronous computation represented by this future has finished; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="isPaused">
<db:title>bool QFuture::isPaused() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isPaused</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isPaused() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the asynchronous computation has been paused with the <db:link xlink:href="qfuture.xml#pause">pause</db:link>() function; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Be aware that the computation may still be running even though this function returns <db:code>true</db:code>. See <db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>() for more details.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#togglePaused">togglePaused</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isResultReadyAt">
<db:title>bool QFuture::isResultReadyAt(int <db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isResultReadyAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isResultReadyAt(int index) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the result at <db:code role="parameter">index</db:code> is immediately available; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isRunning">
<db:title>bool QFuture::isRunning() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isRunning</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isRunning() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the asynchronous computation represented by this future is currently running; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="isStarted">
<db:title>bool QFuture::isStarted() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isStarted</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isStarted() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the asynchronous computation represented by this future has been started; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="pause">
<db:title>void QFuture::pause()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pause</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pause()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Pauses the asynchronous computation represented by this future. This is a convenience method that simply calls <db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>(true).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressMaximum">
<db:title>int QFuture::progressMaximum() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressMaximum</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressMaximum() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum <db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#progressMinimum">progressMinimum</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressMinimum">
<db:title>int QFuture::progressMinimum() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressMinimum</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressMinimum() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the minimum <db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#progressValue">progressValue</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#progressMaximum">progressMaximum</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressText">
<db:title>int QFuture::progressText() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressText</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressText() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the (optional) textual representation of the progress as reported by the asynchronous computation.</db:para>
<db:para>Be aware that not all computations provide a textual representation of the progress, and as such, this function may return an empty string.</db:para>
</db:section>
<db:section xml:id="progressValue">
<db:title>int QFuture::progressValue() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressValue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressValue() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current progress value, which is between the <db:link xlink:href="qfuture.xml#progressMinimum">progressMinimum</db:link>() and <db:link xlink:href="qfuture.xml#progressMaximum">progressMaximum</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#progressMinimum">progressMinimum</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#progressMaximum">progressMaximum</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="result">
<db:title>T QFuture::result() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>result</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T result() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the first result in the future. If the result is not immediately available, this function will block and wait for the result to become available. This is a convenience method for calling <db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>(0).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resultAt">
<db:title>T QFuture::resultAt(int <db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>resultAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T resultAt(int index) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the result at <db:code role="parameter">index</db:code> in the future. If the result is not immediately available, this function will block and wait for the result to become available.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resultCount">
<db:title>int QFuture::resultCount() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>resultCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int resultCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of continuous results available in this future. The real number of results stored might be different from this value, due to gaps in the result set. It is always safe to iterate through the results from 0 to resultCount().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="results">
<db:title>QList&lt;T&gt; QFuture::results() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>results</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; results() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns all results from the future. If the results are not immediately available, this function will block and wait for them to become available.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultCount">resultCount</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resume">
<db:title>void QFuture::resume()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resume</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resume()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Resumes the asynchronous computation represented by this future. This is a convenience method that simply calls <db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>(false).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#pause">pause</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPaused">
<db:title>void QFuture::setPaused(bool <db:emphasis>paused</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPaused</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>paused</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPaused(bool paused)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">paused</db:code> is true, this function pauses the asynchronous computation represented by the future. If the computation is already paused, this function does nothing. Any <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> object that is watching this future will stop delivering progress and result ready signals while the future is paused. Signal delivery will continue once the future is resumed.</db:para>
<db:para>If <db:code role="parameter">paused</db:code> is false, this function resumes the asynchronous computation. If the computation was not previously paused, this function does nothing.</db:para>
<db:para>Be aware that not all computations can be paused. For example, the future returned by QtConcurrent::run() cannot be paused; but the future returned by QtConcurrent::mappedReduced() can.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#isPaused">isPaused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#pause">pause</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#togglePaused">togglePaused</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="togglePaused">
<db:title>void QFuture::togglePaused()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>togglePaused</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void togglePaused()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Toggles the paused state of the asynchronous computation. In other words, if the computation is currently paused, calling this function resumes it; if the computation is running, it is paused. This is a convenience method for calling <db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>(!<db:link xlink:href="qfuture.xml#isPaused">isPaused</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#setPaused">setPaused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#pause">pause</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForFinished">
<db:title>void QFuture::waitForFinished()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>waitForFinished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void waitForFinished()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Waits for the asynchronous computation to finish (including <db:link xlink:href="qfuture.xml#cancel">cancel</db:link>()ed computations).</db:para>
</db:section>
<db:section xml:id="operator-T">
<db:title>T QFuture::operator T() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>operator T</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T operator T() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the first result in the future. If the result is not immediately available, this function will block and wait for the result to become available. This is a convenience method for calling <db:link xlink:href="qfuture.xml#result">result</db:link>() or <db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>(0).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#result">result</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#resultAt">resultAt</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#results">results</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QFuture::operator!=(const QFuture&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QFuture&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QFuture&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">other</db:code> is <db:emphasis>not</db:emphasis> a copy of this future; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QFuture&lt;T&gt; &amp;QFuture::operator=(const QFuture&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QFuture&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; &amp; operator=(const QFuture&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">other</db:code> to this future and returns a reference to this future.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QFuture::operator==(const QFuture&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QFuture&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QFuture&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">other</db:code> is a copy of this future; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
</db:section>
</db:article>
