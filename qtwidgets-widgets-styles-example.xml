<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Styles Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.14.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Styles example illustrates how to create custom widget drawing styles using Qt, and demonstrates Qt's predefined styles.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:figure>
<db:title>Screenshot of the Styles example</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/styles-enabledwood.png"/>
</db:imageobject>
</db:mediaobject>
</db:figure>
<db:para>A style in Qt is a subclass of QStyle or of one of its subclasses. Styles perform drawing on behalf of widgets. Qt provides a whole range of predefined styles, either built into the Qt Widgets module or found in plugins. Styles are usually customized by subclassing QProxyStyle and reimplementing a few virtual functions. While QProxyStyle provides a transparent way to customize either a specific style or the appropriate platform's default style, Qt also provides QCommonStyle as a convenient base for full custom style implementations.</db:para>
<db:para>In this example, the custom style is called <db:code>NorwegianWoodStyle</db:code> and derives from QProxyStyle. Its main features are the wooden textures used for filling most of the widgets and its round buttons and comboboxes.</db:para>
<db:para>To implement the style, we use some advanced features provided by QPainter, such as antialiasing (to obtain smoother button edges), <db:link xlink:href="">alpha blending</db:link> (to make the buttons appeared raised or sunken), and <db:link xlink:href="">painter paths</db:link> (to fill the buttons and draw the outline). We also use many features of QBrush and QPalette.</db:para>
<db:para>The example consists of the following classes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>NorwegianWoodStyle</db:code> inherits from QProxyStyle and implements the Norwegian Wood style.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>WidgetGallery</db:code> is a <db:code>QDialog</db:code> subclass that shows the most common widgets and allows the user to switch style dynamically.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="norwegianwoodstyle-class-definition">
<db:title>NorwegianWoodStyle Class Definition</db:title>
<db:para>Here's the definition of the <db:code>NorwegianWoodStyle</db:code> class:</db:para>
<db:programlisting language="cpp">class NorwegianWoodStyle : public QProxyStyle
{
    Q_OBJECT

public:
    NorwegianWoodStyle();

    QPalette standardPalette() const override;

    void polish(QWidget *widget) override;
    void unpolish(QWidget *widget) override;
    int pixelMetric(PixelMetric metric, const QStyleOption *option,
                    const QWidget *widget) const override;
    int styleHint(StyleHint hint, const QStyleOption *option,
                  const QWidget *widget, QStyleHintReturn *returnData) const override;
    void drawPrimitive(PrimitiveElement element, const QStyleOption *option,
                       QPainter *painter, const QWidget *widget) const override;
    void drawControl(ControlElement control, const QStyleOption *option,
                     QPainter *painter, const QWidget *widget) const override;

private:
    static void setTexture(QPalette &amp;amp;palette, QPalette::ColorRole role,
                           const QImage &amp;amp;image);
    static QPainterPath roundRectPath(const QRect &amp;amp;rect);
    mutable QPalette m_standardPalette;
};
</db:programlisting>
<db:para>The public functions are all declared in QStyle (QProxyStyle's grandparent class) and reimplemented here to override the Windows look and feel. The private functions are helper functions.</db:para>
</db:section>
<db:section xml:id="norwegianwoodstyle-class-implementation">
<db:title>NorwegianWoodStyle Class Implementation</db:title>
<db:para>We will now review the implementation of the <db:code>NorwegianWoodStyle</db:code> class.</db:para>
<db:programlisting language="cpp">QPalette NorwegianWoodStyle::standardPalette() const
{
    if (!m_standardPalette.isBrushSet(QPalette::Disabled, QPalette::Mid)) {
        QColor brown(212, 140, 95);
        QColor beige(236, 182, 120);
        QColor slightlyOpaqueBlack(0, 0, 0, 63);

        QImage backgroundImage(&quot;:/images/woodbackground.png&quot;);
        QImage buttonImage(&quot;:/images/woodbutton.png&quot;);
        QImage midImage = buttonImage.convertToFormat(QImage::Format_RGB32);

        QPainter painter;
        painter.begin(&amp;amp;midImage);
        painter.setPen(Qt::NoPen);
        painter.fillRect(midImage.rect(), slightlyOpaqueBlack);
        painter.end();
</db:programlisting>
<db:para>The <db:code>standardPalette()</db:code> function is reimplemented from QStyle. It returns a QPalette with the style's preferred colors and textures. Most styles don't need to reimplement that function. The Norwegian Wood style reimplements it to set a &quot;wooden&quot; palette.</db:para>
<db:para>We start by defining a few <db:link xlink:href="qcolor-proxy.xml">QColor</db:link>s that we'll need. Then we load two PNG images. The <db:code>:</db:code> prefix in the file path indicates that the PNG files are <db:link xlink:href="resources.xml">embedded resources</db:link>.</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/woodbackground.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">woodbackground.png</db:emphasis></db:para>
<db:para>This texture is used as the background of most widgets. The wood pattern is horizontal.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/woodbutton.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">woodbutton.png</db:emphasis></db:para>
<db:para>This texture is used for filling push buttons and comboboxes. The wood pattern is vertical and more reddish than the texture used for the background.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>midImage</db:code> variable is initialized to be the same as <db:code>buttonImage</db:code>, but then we use a QPainter and fill it with a 25% opaque black color (a black with an <db:link xlink:href="">alpha channel</db:link> of 63). The result is a somewhat darker image than <db:code>buttonImage</db:code>. This image will be used for filling buttons that the user is holding down.</db:para>
<db:programlisting language="cpp">    QPalette palette(brown);

    palette.setBrush(QPalette::BrightText, Qt::white);
    palette.setBrush(QPalette::Base, beige);
    palette.setBrush(QPalette::Highlight, Qt::darkGreen);
    setTexture(palette, QPalette::Button, buttonImage);
    setTexture(palette, QPalette::Mid, midImage);
    setTexture(palette, QPalette::Window, backgroundImage);

    QBrush brush = palette.window();
    brush.setColor(brush.color().darker());

    palette.setBrush(QPalette::Disabled, QPalette::WindowText, brush);
    palette.setBrush(QPalette::Disabled, QPalette::Text, brush);
    palette.setBrush(QPalette::Disabled, QPalette::ButtonText, brush);
    palette.setBrush(QPalette::Disabled, QPalette::Base, brush);
    palette.setBrush(QPalette::Disabled, QPalette::Button, brush);
    palette.setBrush(QPalette::Disabled, QPalette::Mid, brush);

    m_standardPalette = palette;
}

return m_standardPalette;
}
</db:programlisting>
<db:para>We initialize the palette. Palettes have various <db:link xlink:href="">color roles</db:link>, such as QPalette::Base (used for filling text editors, item views, etc.), QPalette::Text (used for foreground text), and QPalette::Background (used for the background of most widgets). Each role has its own QBrush, which usually is a plain color but can also be a brush pattern or even a texture (a QPixmap).</db:para>
<db:para>In addition to the roles, palettes have several <db:link xlink:href="">color groups</db:link>: active, disabled, and inactive. The active color group is used for painting widgets in the active window. The disabled group is used for disabled widgets. The inactive group is used for all other widgets. Most palettes have identical active and inactive groups, while the disabled group uses darker shades.</db:para>
<db:para>We initialize the QPalette object with a brown color. Qt automatically derivates all color roles for all color groups from that single color. We then override some of the default values. For example, we use Qt::darkGreen instead of the default (Qt::darkBlue) for the QPalette::Highlight role. The QPalette::setBrush() overload that we use here sets the same color or brush for all three color groups.</db:para>
<db:para>The <db:code>setTexture()</db:code> function is a private function that sets the texture for a certain color role, while preserving the existing color in the QBrush. A QBrush can hold both a solid color and a texture at the same time. The solid color is used for drawing text and other graphical elements where textures don't look good.</db:para>
<db:para>At the end, we set the brush for the disabled color group of the palette. We use <db:code>woodbackground.png</db:code> as the texture for all disabled widgets, including buttons, and use a darker color to accompany the texture.</db:para>
<db:mediaobject>
<db:alt>The Norwegian Wood style with disabled widgets</db:alt>
<db:imageobject>
<db:imagedata fileref="images/styles-disabledwood.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Let's move on to the other functions reimplemented from QProxyStyle:</db:para>
<db:programlisting language="cpp">void NorwegianWoodStyle::polish(QWidget *widget)
{
    if (qobject_cast&amp;lt;QPushButton *&amp;gt;(widget)
            || qobject_cast&amp;lt;QComboBox *&amp;gt;(widget))
        widget-&amp;gt;setAttribute(Qt::WA_Hover, true);
}
</db:programlisting>
<db:para>This QStyle::polish() overload is called once on every widget drawn using the style. We reimplement it to set the Qt::WA_Hover attribute on QPushButtons and QComboBoxes. When this attribute is set, Qt generates paint events when the mouse pointer enters or leaves the widget. This makes it possible to render push buttons and comboboxes differently when the mouse pointer is over them.</db:para>
<db:programlisting language="cpp">void NorwegianWoodStyle::unpolish(QWidget *widget)
{
    if (qobject_cast&amp;lt;QPushButton *&amp;gt;(widget)
            || qobject_cast&amp;lt;QComboBox *&amp;gt;(widget))
        widget-&amp;gt;setAttribute(Qt::WA_Hover, false);
}
</db:programlisting>
<db:para>This QStyle::unpolish() overload is called to undo any modification done to the widget in <db:code>polish()</db:code>. For simplicity, we assume that the flag wasn't set before <db:code>polish()</db:code> was called. In an ideal world, we would remember the original state for each widgets (e.g., using a <db:link xlink:href="qmap.xml">QMap</db:link>&lt;QWidget *, bool&gt;) and restore it in <db:code>unpolish()</db:code>.</db:para>
<db:programlisting language="cpp">int NorwegianWoodStyle::pixelMetric(PixelMetric metric,
                                    const QStyleOption *option,
                                    const QWidget *widget) const
{
    switch (metric) {
    case PM_ComboBoxFrameWidth:
        return 8;
    case PM_ScrollBarExtent:
        return QProxyStyle::pixelMetric(metric, option, widget) + 4;
    default:
        return QProxyStyle::pixelMetric(metric, option, widget);
    }
}
</db:programlisting>
<db:para>The <db:link xlink:href="">pixelMetric()</db:link> function returns the size in pixels for a certain user interface element. By reimplementing this function, we can affect the way certain widgets are drawn and their size hint. Here, we return 8 as the width around a shown in a QComboBox, ensuring that there is enough place around the text and the arrow for the Norwegian Wood round corners. The default value for this setting in the Windows style is 2.</db:para>
<db:para>We also change the extent of QScrollBars, i.e., the height for a horizontal scroll bar and the width for a vertical scroll bar, to be 4 pixels more than in the Windows style. This makes the style a bit more distinctive.</db:para>
<db:para>For all other QStyle::PixelMetric elements, we use the Windows settings.</db:para>
<db:programlisting language="cpp">int NorwegianWoodStyle::styleHint(StyleHint hint, const QStyleOption *option,
                                  const QWidget *widget,
                                  QStyleHintReturn *returnData) const
{
    switch (hint) {
    case SH_DitherDisabledText:
        return int(false);
    case SH_EtchDisabledText:
        return int(true);
    default:
        return QProxyStyle::styleHint(hint, option, widget, returnData);
    }
}
</db:programlisting>
<db:para>The <db:link xlink:href="">styleHint()</db:link> function returns some hints to widgets or to the base style (in our case QProxyStyle) about how to draw the widgets. The Windows style returns <db:code>true</db:code> for the QStyle::SH_DitherDisabledText hint, resulting in a most unpleasing visual effect. We override this behavior and return <db:code>false</db:code> instead. We also return <db:code>true</db:code> for the QStyle::SH_EtchDisabledText hint, meaning that disabled text is rendered with an embossed look.</db:para>
<db:programlisting language="cpp">void NorwegianWoodStyle::drawPrimitive(PrimitiveElement element,
                                       const QStyleOption *option,
                                       QPainter *painter,
                                       const QWidget *widget) const
{
    switch (element) {
    case PE_PanelButtonCommand:
        {
            int delta = (option-&amp;gt;state &amp;amp; State_MouseOver) ? 64 : 0;
            QColor slightlyOpaqueBlack(0, 0, 0, 63);
            QColor semiTransparentWhite(255, 255, 255, 127 + delta);
            QColor semiTransparentBlack(0, 0, 0, 127 - delta);

            int x, y, width, height;
            option-&amp;gt;rect.getRect(&amp;amp;x, &amp;amp;y, &amp;amp;width, &amp;amp;height);
</db:programlisting>
<db:para>The <db:link xlink:href="">drawPrimitive()</db:link> function is called by Qt widgets to draw various fundamental graphical elements. Here we reimplement it to draw QPushButton and QComboBox with round corners. The button part of these widgets is drawn using the QStyle::PE_PanelButtonCommand primitive element.</db:para>
<db:para>The <db:code>option</db:code> parameter, of type QStyleOption, contains everything we need to know about the widget we want to draw on. In particular, <db:code>option-&gt;rect</db:code> gives the rectangle within which to draw the primitive element. The <db:code>painter</db:code> parameter is a QPainter object that we can use to draw on the widget.</db:para>
<db:para>The <db:code>widget</db:code> parameter is the widget itself. Normally, all the information we need is available in <db:code>option</db:code> and <db:code>painter</db:code>, so we don't need <db:code>widget</db:code>. We can use it to perform special effects; for example, QMacStyle uses it to animate default buttons. If you use it, be aware that the caller is allowed to pass a null pointer.</db:para>
<db:para>We start by defining three <db:link xlink:href="qcolor-proxy.xml">QColor</db:link>s that we'll need later on. We also put the x, y, width, and height components of the widget's rectangle in local variables. The value used for the <db:code>semiTransparentWhite</db:code> and for the <db:code>semiTransparentBlack</db:code> color's alpha channel depends on whether the mouse cursor is over the widget or not. Since we set the Qt::WA_Hover attribute on QPushButtons and QComboBoxes, we can rely on the QStyle::State_MouseOver flag to be set when the mouse is over the widget.</db:para>
<db:programlisting language="cpp">            QPainterPath roundRect = roundRectPath(option-&amp;gt;rect);
            int radius = qMin(width, height) / 2;
</db:programlisting>
<db:para>The <db:code>roundRect</db:code> variable is a QPainterPath. A QPainterPath is is a vectorial specification of a shape. Any shape (rectangle, ellipse, spline, etc.) or combination of shapes can be expressed as a path. We will use <db:code>roundRect</db:code> both for filling the button background with a wooden texture and for drawing the outline. The <db:code>roundRectPath()</db:code> function is a private function; we will come back to it later.</db:para>
<db:programlisting language="cpp">            QBrush brush;
            bool darker;

            const QStyleOptionButton *buttonOption =
                    qstyleoption_cast&amp;lt;const QStyleOptionButton *&amp;gt;(option);
            if (buttonOption
                    &amp;amp;&amp;amp; (buttonOption-&amp;gt;features &amp;amp; QStyleOptionButton::Flat)) {
                brush = option-&amp;gt;palette.window();
                darker = (option-&amp;gt;state &amp;amp; (State_Sunken | State_On));
            } else {
                if (option-&amp;gt;state &amp;amp; (State_Sunken | State_On)) {
                    brush = option-&amp;gt;palette.mid();
                    darker = !(option-&amp;gt;state &amp;amp; State_Sunken);
                } else {
                    brush = option-&amp;gt;palette.button();
                    darker = false;
                }
            }
</db:programlisting>
<db:para>We define two variables, <db:code>brush</db:code> and <db:code>darker</db:code>, and initialize them based on the state of the button:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If the button is a <db:link xlink:href="">flat button</db:link>, we use the Background brush. We set <db:code>darker</db:code> to <db:code>true</db:code> if the button is down or checked.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the button is currently held down by the user or in the checked state, we use the Mid component of the palette. We set <db:code>darker</db:code> to <db:code>true</db:code> if the button is checked.</db:para>
</db:listitem>
<db:listitem>
<db:para>Otherwise, we use the Button component of the palette.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The screenshot below illustrates how QPushButtons are rendered based on their state:</db:para>
<db:mediaobject>
<db:alt>Norwegian Wood buttons in different states</db:alt>
<db:imageobject>
<db:imagedata fileref="images/styles-woodbuttons.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>To discover whether the button is flat or not, we need to cast the <db:code>option</db:code> parameter to QStyleOptionButton and check if the features member specifies the QStyleOptionButton::Flat flag. The qstyleoption_cast() function performs a dynamic cast; if <db:code>option</db:code> is not a QStyleOptionButton, qstyleoption_cast() returns a null pointer.</db:para>
<db:programlisting language="cpp">            painter-&amp;gt;save();
            painter-&amp;gt;setRenderHint(QPainter::Antialiasing, true);
            painter-&amp;gt;fillPath(roundRect, brush);
            if (darker)
                painter-&amp;gt;fillPath(roundRect, slightlyOpaqueBlack);
</db:programlisting>
<db:para>We turn on antialiasing on QPainter. Antialiasing is a technique that reduces the visual distortion that occurs when the edges of a shape are converted into pixels. For the Norwegian Wood style, we use it to obtain smoother edges for the round buttons.</db:para>
<db:mediaobject>
<db:alt>Norwegian wood buttons with and without antialiasing</db:alt>
<db:imageobject>
<db:imagedata fileref="images/styles-aliasing.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The first call to QPainter::fillPath() draws the background of the button with a wooden texture. The second call to <db:link xlink:href="">fillPath()</db:link> paints the same area with a semi-transparent black color (a black color with an alpha channel of 63) to make the area darker if <db:code>darker</db:code> is true.</db:para>
<db:programlisting language="cpp">            int penWidth;
            if (radius &amp;lt; 10)
                penWidth = 3;
            else if (radius &amp;lt; 20)
                penWidth = 5;
            else
                penWidth = 7;

            QPen topPen(semiTransparentWhite, penWidth);
            QPen bottomPen(semiTransparentBlack, penWidth);

            if (option-&amp;gt;state &amp;amp; (State_Sunken | State_On))
                qSwap(topPen, bottomPen);
</db:programlisting>
<db:para>Next, we draw the outline. The top-left half of the outline and the bottom-right half of the outline are drawn using different QPens to produce a 3D effect. Normally, the top-left half of the outline is drawn lighter whereas the bottom-right half is drawn darker, but if the button is down or checked, we invert the two QPens to give a sunken look to the button.</db:para>
<db:programlisting language="cpp">            int x1 = x;
            int x2 = x + radius;
            int x3 = x + width - radius;
            int x4 = x + width;

            if (option-&amp;gt;direction == Qt::RightToLeft) {
                qSwap(x1, x4);
                qSwap(x2, x3);
            }

            QPolygon topHalf;
            topHalf &amp;lt;&amp;lt; QPoint(x1, y)
                    &amp;lt;&amp;lt; QPoint(x4, y)
                    &amp;lt;&amp;lt; QPoint(x3, y + radius)
                    &amp;lt;&amp;lt; QPoint(x2, y + height - radius)
                    &amp;lt;&amp;lt; QPoint(x1, y + height);

            painter-&amp;gt;setClipPath(roundRect);
            painter-&amp;gt;setClipRegion(topHalf, Qt::IntersectClip);
            painter-&amp;gt;setPen(topPen);
            painter-&amp;gt;drawPath(roundRect);
</db:programlisting>
<db:para>We draw the top-left part of the outline by calling QPainter::drawPath() with an appropriate <db:link xlink:href="">clip region</db:link>. If the <db:link xlink:href="">layout direction</db:link> is right-to-left instead of left-to-right, we swap the <db:code>x1</db:code>, <db:code>x2</db:code>, <db:code>x3</db:code>, and <db:code>x4</db:code> variables to obtain correct results. On right-to-left desktop, the &quot;light&quot; comes from the top-right corner of the screen instead of the top-left corner; raised and sunken widgets must be drawn accordingly.</db:para>
<db:para>The diagram below illustrates how 3D effects are drawn according to the layout direction. The area in red on the diagram corresponds to the <db:code>topHalf</db:code> polygon:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/styles-3d.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>An easy way to test how a style looks in right-to-left mode is to pass the <db:code>-reverse</db:code> command-line option to the application. This option is recognized by the QApplication constructor.</db:para>
<db:programlisting language="cpp">            QPolygon bottomHalf = topHalf;
            bottomHalf[0] = QPoint(x4, y + height);

            painter-&amp;gt;setClipPath(roundRect);
            painter-&amp;gt;setClipRegion(bottomHalf, Qt::IntersectClip);
            painter-&amp;gt;setPen(bottomPen);
            painter-&amp;gt;drawPath(roundRect);

            painter-&amp;gt;setPen(option-&amp;gt;palette.windowText().color());
            painter-&amp;gt;setClipping(false);
            painter-&amp;gt;drawPath(roundRect);

            painter-&amp;gt;restore();
        }
        break;
    default:
        QProxyStyle::drawPrimitive(element, option, painter, widget);
    }
}
</db:programlisting>
<db:para>The bottom-right part of the outline is drawn in a similar fashion. Then we draw a one-pixel wide outline around the entire button, using the Foreground component of the QPalette.</db:para>
<db:para>This completes the QStyle::PE_PanelButtonCommand case of the <db:code>switch</db:code> statement. Other primitive elements are handled by the base style. Let's now turn to the other <db:code>NorwegianWoodStyle</db:code> member functions:</db:para>
<db:programlisting language="cpp">void NorwegianWoodStyle::drawControl(ControlElement element,
                                     const QStyleOption *option,
                                     QPainter *painter,
                                     const QWidget *widget) const
{
    switch (element) {
    case CE_PushButtonLabel:
        {
            QStyleOptionButton myButtonOption;
            const QStyleOptionButton *buttonOption =
                    qstyleoption_cast&amp;lt;const QStyleOptionButton *&amp;gt;(option);
            if (buttonOption) {
                myButtonOption = *buttonOption;
                if (myButtonOption.palette.currentColorGroup()
                        != QPalette::Disabled) {
                    if (myButtonOption.state &amp;amp; (State_Sunken | State_On)) {
                        myButtonOption.palette.setBrush(QPalette::ButtonText,
                                myButtonOption.palette.brightText());
                    }
                }
            }
            QProxyStyle::drawControl(element, &amp;amp;myButtonOption, painter, widget);
        }
        break;
    default:
        QProxyStyle::drawControl(element, option, painter, widget);
    }
}
</db:programlisting>
<db:para>We reimplement QStyle::drawControl() to draw the text on a QPushButton in a bright color when the button is down or checked.</db:para>
<db:para>If the <db:code>option</db:code> parameter points to a QStyleOptionButton object (it normally should), we take a copy of the object and modify its palette member to make the QPalette::ButtonText be the same as the QPalette::BrightText component (unless the widget is disabled).</db:para>
<db:programlisting language="cpp">void NorwegianWoodStyle::setTexture(QPalette &amp;amp;palette, QPalette::ColorRole role,
                                    const QImage &amp;amp;image)
{
    for (int i = 0; i &amp;lt; QPalette::NColorGroups; ++i) {
        QBrush brush(image);
        brush.setColor(palette.brush(QPalette::ColorGroup(i), role).color());
        palette.setBrush(QPalette::ColorGroup(i), role, brush);
    }
}
</db:programlisting>
<db:para>The <db:code>setTexture()</db:code> function is a private function that sets the texture component of the QBrushes for a certain <db:link xlink:href="">color role</db:link>, for all three <db:link xlink:href="">color groups</db:link> (active, disabled, inactive). We used it to initialize the Norwegian Wood palette in <db:code>standardPalette</db:code>.</db:para>
<db:programlisting language="cpp">QPainterPath NorwegianWoodStyle::roundRectPath(const QRect &amp;amp;rect)
{
    int radius = qMin(rect.width(), rect.height()) / 2;
    int diam = 2 * radius;

    int x1, y1, x2, y2;
    rect.getCoords(&amp;amp;x1, &amp;amp;y1, &amp;amp;x2, &amp;amp;y2);

    QPainterPath path;
    path.moveTo(x2, y1 + radius);
    path.arcTo(QRect(x2 - diam, y1, diam, diam), 0.0, +90.0);
    path.lineTo(x1 + radius, y1);
    path.arcTo(QRect(x1, y1, diam, diam), 90.0, +90.0);
    path.lineTo(x1, y2 - radius);
    path.arcTo(QRect(x1, y2 - diam, diam, diam), 180.0, +90.0);
    path.lineTo(x1 + radius, y2);
    path.arcTo(QRect(x2 - diam, y2 - diam, diam, diam), 270.0, +90.0);
    path.closeSubpath();
    return path;
}
</db:programlisting>
<db:para>The <db:code>roundRectPath()</db:code> function is a private function that constructs a QPainterPath object for round buttons. The path consists of eight segments: four arc segments for the corners and four lines for the sides.</db:para>
<db:para>With around 250 lines of code, we have a fully functional custom style based on one of the predefined styles. Custom styles can be used to provide a distinct look to an application or family of applications.</db:para>
</db:section>
<db:section xml:id="widgetgallery-class">
<db:title>WidgetGallery Class</db:title>
<db:para>For completeness, we will quickly review the <db:code>WidgetGallery</db:code> class, which contains the most common Qt widgets and allows the user to change style dynamically. Here's the class definition:</db:para>
<db:programlisting language="cpp">class WidgetGallery : public QDialog
{
    Q_OBJECT

public:
    WidgetGallery(QWidget *parent = nullptr);

protected:
    void changeEvent(QEvent *) override;

private slots:
    void changeStyle(const QString &amp;amp;styleName);
    void styleChanged();
    void changePalette();
    void advanceProgressBar();

private:
    void createTopLeftGroupBox();
    void createTopRightGroupBox();
    void createBottomLeftTabWidget();
    void createBottomRightGroupBox();
    void createProgressBar();

    QPalette originalPalette;

    QLabel *styleLabel;
    QComboBox *styleComboBox;
    QCheckBox *useStylePaletteCheckBox;
    QCheckBox *disableWidgetsCheckBox;
    ...
};
</db:programlisting>
<db:para>Here's the <db:code>WidgetGallery</db:code> constructor:</db:para>
<db:programlisting language="cpp">WidgetGallery::WidgetGallery(QWidget *parent)
    : QDialog(parent)
{
    originalPalette = QApplication::palette();

    styleComboBox = new QComboBox;
    const QString defaultStyleName = QApplication::style()-&amp;gt;objectName();
    QStringList styleNames = QStyleFactory::keys();
    styleNames.append(&quot;NorwegianWood&quot;);
    for (int i = 1, size = styleNames.size(); i &amp;lt; size; ++i) {
        if (defaultStyleName.compare(styleNames.at(i), Qt::CaseInsensitive) == 0) {
            styleNames.swapItemsAt(0, i);
            break;
        }
    }
    styleComboBox-&amp;gt;addItems(styleNames);

    styleLabel = new QLabel(tr(&quot;&amp;amp;Style:&quot;));
    styleLabel-&amp;gt;setBuddy(styleComboBox);

    useStylePaletteCheckBox = new QCheckBox(tr(&quot;&amp;amp;Use style's standard palette&quot;));
    useStylePaletteCheckBox-&amp;gt;setChecked(true);

    disableWidgetsCheckBox = new QCheckBox(tr(&quot;&amp;amp;Disable widgets&quot;));

    createTopLeftGroupBox();
    createTopRightGroupBox();
    createBottomLeftTabWidget();
    createBottomRightGroupBox();
    createProgressBar();
</db:programlisting>
<db:para>We start by creating child widgets. The <db:guilabel>Style</db:guilabel> combobox is initialized with all the styles known to QStyleFactory, in addition to <db:code>NorwegianWood</db:code>. The <db:code>create...()</db:code> functions are private functions that set up the various parts of the <db:code>WidgetGallery</db:code>.</db:para>
<db:programlisting language="cpp">    connect(styleComboBox, &amp;amp;QComboBox::textActivated,
            this, &amp;amp;WidgetGallery::changeStyle);
    connect(useStylePaletteCheckBox, &amp;amp;QCheckBox::toggled,
            this, &amp;amp;WidgetGallery::changePalette);
    connect(disableWidgetsCheckBox, &amp;amp;QCheckBox::toggled,
            topLeftGroupBox, &amp;amp;QGroupBox::setDisabled);
    connect(disableWidgetsCheckBox, &amp;amp;QCheckBox::toggled,
            topRightGroupBox, &amp;amp;QGroupBox::setDisabled);
    connect(disableWidgetsCheckBox, &amp;amp;QCheckBox::toggled,
            bottomLeftTabWidget, &amp;amp;QGroupBox::setDisabled);
    connect(disableWidgetsCheckBox, &amp;amp;QCheckBox::toggled,
            bottomRightGroupBox, &amp;amp;QGroupBox::setDisabled);
</db:programlisting>
<db:para>We connect the <db:guilabel>Style</db:guilabel> combobox to the <db:code>changeStyle()</db:code> private slot, the <db:guilabel>Use style's standard palette</db:guilabel> check box to the <db:code>changePalette()</db:code> slot, and the <db:guilabel>Disable widgets</db:guilabel> check box to the child widgets' <db:link xlink:href="">setDisabled()</db:link> slot.</db:para>
<db:programlisting language="cpp">    QHBoxLayout *topLayout = new QHBoxLayout;
    topLayout-&amp;gt;addWidget(styleLabel);
    topLayout-&amp;gt;addWidget(styleComboBox);
    topLayout-&amp;gt;addStretch(1);
    topLayout-&amp;gt;addWidget(useStylePaletteCheckBox);
    topLayout-&amp;gt;addWidget(disableWidgetsCheckBox);

    QGridLayout *mainLayout = new QGridLayout;
    mainLayout-&amp;gt;addLayout(topLayout, 0, 0, 1, 2);
    mainLayout-&amp;gt;addWidget(topLeftGroupBox, 1, 0);
    mainLayout-&amp;gt;addWidget(topRightGroupBox, 1, 1);
    mainLayout-&amp;gt;addWidget(bottomLeftTabWidget, 2, 0);
    mainLayout-&amp;gt;addWidget(bottomRightGroupBox, 2, 1);
    mainLayout-&amp;gt;addWidget(progressBar, 3, 0, 1, 2);
    mainLayout-&amp;gt;setRowStretch(1, 1);
    mainLayout-&amp;gt;setRowStretch(2, 1);
    mainLayout-&amp;gt;setColumnStretch(0, 1);
    mainLayout-&amp;gt;setColumnStretch(1, 1);
    setLayout(mainLayout);

    setWindowTitle(tr(&quot;Styles&quot;));
    styleChanged();
}
</db:programlisting>
<db:para>Finally, we put the child widgets in layouts.</db:para>
<db:programlisting language="cpp">void WidgetGallery::changeStyle(const QString &amp;amp;styleName)
{
    if (styleName == &quot;NorwegianWood&quot;)
        QApplication::setStyle(new NorwegianWoodStyle);
    else
        QApplication::setStyle(QStyleFactory::create(styleName));
}
</db:programlisting>
<db:para>When the user changes the style in the combobox, we call QApplication::setStyle() to dynamically change the style of the application.</db:para>
<db:programlisting language="cpp">void WidgetGallery::changePalette()
{
    if (useStylePaletteCheckBox-&amp;gt;isChecked())
        QApplication::setPalette(QApplication::style()-&amp;gt;standardPalette());
    else
        QApplication::setPalette(originalPalette);
}
</db:programlisting>
<db:para>If the user turns the <db:guilabel>Use style's standard palette</db:guilabel> on, the current style's <db:link xlink:href="">standard palette</db:link> is used; otherwise, the system's default palette is honored.</db:para>
<db:programlisting language="cpp">void WidgetGallery::advanceProgressBar()
{
    int curVal = progressBar-&amp;gt;value();
    int maxVal = progressBar-&amp;gt;maximum();
    progressBar-&amp;gt;setValue(curVal + (maxVal - curVal) / 100);
}
</db:programlisting>
<db:para>The <db:code>advanceProgressBar()</db:code> slot is called at regular intervals to advance the progress bar. Since we don't know how long the user will keep the Styles application running, we use a logarithmic formula: The closer the progress bar gets to 100%, the slower it advances.</db:para>
<db:para>We will review <db:code>createProgressBar()</db:code> in a moment.</db:para>
<db:programlisting language="cpp">void WidgetGallery::createTopLeftGroupBox()
{
    topLeftGroupBox = new QGroupBox(tr(&quot;Group 1&quot;));

    radioButton1 = new QRadioButton(tr(&quot;Radio button 1&quot;));
    radioButton2 = new QRadioButton(tr(&quot;Radio button 2&quot;));
    radioButton3 = new QRadioButton(tr(&quot;Radio button 3&quot;));
    radioButton1-&amp;gt;setChecked(true);

    checkBox = new QCheckBox(tr(&quot;Tri-state check box&quot;));
    checkBox-&amp;gt;setTristate(true);
    checkBox-&amp;gt;setCheckState(Qt::PartiallyChecked);

    QVBoxLayout *layout = new QVBoxLayout;
    layout-&amp;gt;addWidget(radioButton1);
    layout-&amp;gt;addWidget(radioButton2);
    layout-&amp;gt;addWidget(radioButton3);
    layout-&amp;gt;addWidget(checkBox);
    layout-&amp;gt;addStretch(1);
    topLeftGroupBox-&amp;gt;setLayout(layout);
}
</db:programlisting>
<db:para>The <db:code>createTopLeftGroupBox()</db:code> function creates the QGroupBox that occupies the top-left corner of the <db:code>WidgetGallery</db:code>. We skip the <db:code>createTopRightGroupBox()</db:code>, <db:code>createBottomLeftTabWidget()</db:code>, and <db:code>createBottomRightGroupBox()</db:code> functions, which are very similar.</db:para>
<db:programlisting language="cpp">void WidgetGallery::createProgressBar()
{
    progressBar = new QProgressBar;
    progressBar-&amp;gt;setRange(0, 10000);
    progressBar-&amp;gt;setValue(0);

    QTimer *timer = new QTimer(this);
    connect(timer, &amp;amp;QTimer::timeout, this, &amp;amp;WidgetGallery::advanceProgressBar);
    timer-&amp;gt;start(1000);
}
</db:programlisting>
<db:para>In <db:code>createProgressBar()</db:code>, we create a QProgressBar at the bottom of the <db:code>WidgetGallery</db:code> and connect its <db:link xlink:href="">timeout()</db:link> signal to the <db:code>advanceProgressBar()</db:code> slot.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/widgets/styles?h=5.14">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
