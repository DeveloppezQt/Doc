<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Styles Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 6.0.4 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Styles example illustrates how to create custom widget drawing styles using Qt, and demonstrates Qt's predefined styles.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:figure>
<db:title>Screenshot of the Styles example</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/styles-enabledwood.png"/>
</db:imageobject>
</db:mediaobject>
</db:figure>
<db:para>A style in Qt is a subclass of <db:link xlink:href="qstyle.xml">QStyle</db:link> or of one of its subclasses. Styles perform drawing on behalf of widgets. Qt provides a whole range of predefined styles, either built into the Qt Widgets module or found in plugins. Styles are usually customized by subclassing <db:link xlink:href="qproxystyle.xml">QProxyStyle</db:link> and reimplementing a few virtual functions. While <db:link xlink:href="qproxystyle.xml">QProxyStyle</db:link> provides a transparent way to customize either a specific style or the appropriate platform's default style, Qt also provides <db:link xlink:href="qcommonstyle.xml">QCommonStyle</db:link> as a convenient base for full custom style implementations.</db:para>
<db:para>In this example, the custom style is called NorwegianWoodStyle and derives from <db:link xlink:href="qproxystyle.xml">QProxyStyle</db:link>. Its main features are the wooden textures used for filling most of the widgets and its round buttons and comboboxes.</db:para>
<db:para>To implement the style, we use some advanced features provided by <db:link xlink:href="qpainter.xml">QPainter</db:link>, such as <db:link xlink:href="qpainter.xml#RenderHint-enum">antialiasing</db:link> (to obtain smoother button edges), <db:link xlink:href="qcolor.xml#alpha">alpha blending</db:link> (to make the buttons appeared raised or sunken), and <db:link xlink:href="qpainterpath.xml">painter paths</db:link> (to fill the buttons and draw the outline). We also use many features of <db:link xlink:href="qbrush.xml">QBrush</db:link> and <db:link xlink:href="qpalette.xml">QPalette</db:link>.</db:para>
<db:para>The example consists of the following classes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>NorwegianWoodStyle inherits from <db:link xlink:href="qproxystyle.xml">QProxyStyle</db:link> and implements the Norwegian Wood style.</db:para>
</db:listitem>
<db:listitem>
<db:para>WidgetGallery is a QDialog subclass that shows the most common widgets and allows the user to switch style dynamically.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="norwegianwoodstyle-class-definition">
<db:title>NorwegianWoodStyle Class Definition</db:title>
<db:para>Here's the definition of the NorwegianWoodStyle class:</db:para>
<db:programlisting language="cpp">class NorwegianWoodStyle : public QProxyStyle
{
    Q_OBJECT

public:
    NorwegianWoodStyle();

    QPalette standardPalette() const override;

    void polish(QWidget *widget) override;
    void unpolish(QWidget *widget) override;
    int pixelMetric(PixelMetric metric, const QStyleOption *option,
                    const QWidget *widget) const override;
    int styleHint(StyleHint hint, const QStyleOption *option,
                  const QWidget *widget, QStyleHintReturn *returnData) const override;
    void drawPrimitive(PrimitiveElement element, const QStyleOption *option,
                       QPainter *painter, const QWidget *widget) const override;
    void drawControl(ControlElement control, const QStyleOption *option,
                     QPainter *painter, const QWidget *widget) const override;

private:
    static void setTexture(QPalette &amp;amp;palette, QPalette::ColorRole role,
                           const QImage &amp;amp;image);
    static QPainterPath roundRectPath(const QRect &amp;amp;rect);
    mutable QPalette m_standardPalette;
};
</db:programlisting>
<db:para>The public functions are all declared in <db:link xlink:href="qstyle.xml">QStyle</db:link> (<db:link xlink:href="qproxystyle.xml">QProxyStyle</db:link>'s grandparent class) and reimplemented here to override the Windows look and feel. The private functions are helper functions.</db:para>
</db:section>
<db:section xml:id="norwegianwoodstyle-class-implementation">
<db:title>NorwegianWoodStyle Class Implementation</db:title>
<db:para>We will now review the implementation of the NorwegianWoodStyle class.</db:para>
<db:programlisting language="cpp">QPalette NorwegianWoodStyle::standardPalette() const
{
    if (!m_standardPalette.isBrushSet(QPalette::Disabled, QPalette::Mid)) {
        QColor brown(212, 140, 95);
        QColor beige(236, 182, 120);
        QColor slightlyOpaqueBlack(0, 0, 0, 63);

        QImage backgroundImage(&quot;:/images/woodbackground.png&quot;);
        QImage buttonImage(&quot;:/images/woodbutton.png&quot;);
        QImage midImage = buttonImage.convertToFormat(QImage::Format_RGB32);

        QPainter painter;
        painter.begin(&amp;amp;midImage);
        painter.setPen(Qt::NoPen);
        painter.fillRect(midImage.rect(), slightlyOpaqueBlack);
        painter.end();
</db:programlisting>
<db:para>The standardPalette() function is reimplemented from <db:link xlink:href="qstyle.xml">QStyle</db:link>. It returns a <db:link xlink:href="qpalette.xml">QPalette</db:link> with the style's preferred colors and textures. Most styles don't need to reimplement that function. The Norwegian Wood style reimplements it to set a &quot;wooden&quot; palette.</db:para>
<db:para>We start by defining a few <db:link xlink:href="qcolor.xml">QColor</db:link>s that we'll need. Then we load two PNG images. The : prefix in the file path indicates that the PNG files are <db:link xlink:href="resources.xml">embedded resources</db:link>.</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/woodbackground.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">woodbackground.png</db:emphasis></db:para>
<db:para>This texture is used as the background of most widgets. The wood pattern is horizontal.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/woodbutton.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:emphasis role="bold">woodbutton.png</db:emphasis></db:para>
<db:para>This texture is used for filling push buttons and comboboxes. The wood pattern is vertical and more reddish than the texture used for the background.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The midImage variable is initialized to be the same as buttonImage, but then we use a <db:link xlink:href="qpainter.xml">QPainter</db:link> and fill it with a 25% opaque black color (a black with an <db:link xlink:href="qcolor.xml#alpha">alpha channel</db:link> of 63). The result is a somewhat darker image than buttonImage. This image will be used for filling buttons that the user is holding down.</db:para>
<db:programlisting language="cpp">    QPalette palette(brown);

    palette.setBrush(QPalette::BrightText, Qt::white);
    palette.setBrush(QPalette::Base, beige);
    palette.setBrush(QPalette::Highlight, Qt::darkGreen);
    setTexture(palette, QPalette::Button, buttonImage);
    setTexture(palette, QPalette::Mid, midImage);
    setTexture(palette, QPalette::Window, backgroundImage);

    QBrush brush = palette.window();
    brush.setColor(brush.color().darker());

    palette.setBrush(QPalette::Disabled, QPalette::WindowText, brush);
    palette.setBrush(QPalette::Disabled, QPalette::Text, brush);
    palette.setBrush(QPalette::Disabled, QPalette::ButtonText, brush);
    palette.setBrush(QPalette::Disabled, QPalette::Base, brush);
    palette.setBrush(QPalette::Disabled, QPalette::Button, brush);
    palette.setBrush(QPalette::Disabled, QPalette::Mid, brush);

    m_standardPalette = palette;
}

return m_standardPalette;
}
</db:programlisting>
<db:para>We initialize the palette. Palettes have various <db:link xlink:href="qpalette.xml#ColorRole-enum">color roles</db:link>, such as <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::Base</db:link> (used for filling text editors, item views, etc.), <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::Text</db:link> (used for foreground text), and <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::Window</db:link> (used for the background of most widgets). Each role has its own <db:link xlink:href="qbrush.xml">QBrush</db:link>, which usually is a plain color but can also be a brush pattern or even a texture (a <db:link xlink:href="qpixmap.xml">QPixmap</db:link>).</db:para>
<db:para>In addition to the roles, palettes have several <db:link xlink:href="qpalette.xml#ColorGroup-enum">color groups</db:link>: active, disabled, and inactive. The active color group is used for painting widgets in the active window. The disabled group is used for disabled widgets. The inactive group is used for all other widgets. Most palettes have identical active and inactive groups, while the disabled group uses darker shades.</db:para>
<db:para>We initialize the <db:link xlink:href="qpalette.xml">QPalette</db:link> object with a brown color. Qt automatically derivates all color roles for all color groups from that single color. We then override some of the default values. For example, we use <db:link xlink:href="qt.xml#GlobalColor-enum">Qt::darkGreen</db:link> instead of the default (<db:link xlink:href="qt.xml#GlobalColor-enum">Qt::darkBlue</db:link>) for the <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::Highlight</db:link> role. The <db:link xlink:href="qpalette.xml#setBrush">QPalette::setBrush</db:link>() overload that we use here sets the same color or brush for all three color groups.</db:para>
<db:para>The setTexture() function is a private function that sets the texture for a certain color role, while preserving the existing color in the <db:link xlink:href="qbrush.xml">QBrush</db:link>. A <db:link xlink:href="qbrush.xml">QBrush</db:link> can hold both a solid color and a texture at the same time. The solid color is used for drawing text and other graphical elements where textures don't look good.</db:para>
<db:para>At the end, we set the brush for the disabled color group of the palette. We use woodbackground.png as the texture for all disabled widgets, including buttons, and use a darker color to accompany the texture.</db:para>
<db:mediaobject>
<db:alt>The Norwegian Wood style with disabled widgets</db:alt>
<db:imageobject>
<db:imagedata fileref="images/styles-disabledwood.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Let's move on to the other functions reimplemented from <db:link xlink:href="qproxystyle.xml">QProxyStyle</db:link>:</db:para>
<db:programlisting language="cpp">void NorwegianWoodStyle::polish(QWidget *widget)
{
    if (qobject_cast&amp;lt;QPushButton *&amp;gt;(widget)
            || qobject_cast&amp;lt;QComboBox *&amp;gt;(widget))
        widget-&amp;gt;setAttribute(Qt::WA_Hover, true);
}
</db:programlisting>
<db:para>This <db:link xlink:href="qstyle.xml#polish">QStyle::polish</db:link>() overload is called once on every widget drawn using the style. We reimplement it to set the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_Hover</db:link> attribute on <db:link xlink:href="qpushbutton.xml">QPushButton</db:link>s and <db:link xlink:href="qcombobox.xml">QComboBox</db:link>es. When this attribute is set, Qt generates paint events when the mouse pointer enters or leaves the widget. This makes it possible to render push buttons and comboboxes differently when the mouse pointer is over them.</db:para>
<db:programlisting language="cpp">void NorwegianWoodStyle::unpolish(QWidget *widget)
{
    if (qobject_cast&amp;lt;QPushButton *&amp;gt;(widget)
            || qobject_cast&amp;lt;QComboBox *&amp;gt;(widget))
        widget-&amp;gt;setAttribute(Qt::WA_Hover, false);
}
</db:programlisting>
<db:para>This <db:link xlink:href="qstyle.xml#unpolish">QStyle::unpolish</db:link>() overload is called to undo any modification done to the widget in polish(). For simplicity, we assume that the flag wasn't set before polish() was called. In an ideal world, we would remember the original state for each widgets (e.g., using a <db:link xlink:href="qmap.xml">QMap</db:link>&lt;<db:link xlink:href="qwidget.xml">QWidget</db:link> *, bool&gt;) and restore it in unpolish().</db:para>
<db:programlisting language="cpp">int NorwegianWoodStyle::pixelMetric(PixelMetric metric,
                                    const QStyleOption *option,
                                    const QWidget *widget) const
{
    switch (metric) {
    case PM_ComboBoxFrameWidth:
        return 8;
    case PM_ScrollBarExtent:
        return QProxyStyle::pixelMetric(metric, option, widget) + 4;
    default:
        return QProxyStyle::pixelMetric(metric, option, widget);
    }
}
</db:programlisting>
<db:para>The <db:link xlink:href="qstyle.xml#pixelMetric">pixelMetric</db:link>() function returns the size in pixels for a certain user interface element. By reimplementing this function, we can affect the way certain widgets are drawn and their size hint. Here, we return 8 as the width around a shown in a <db:link xlink:href="qcombobox.xml">QComboBox</db:link>, ensuring that there is enough place around the text and the arrow for the Norwegian Wood round corners. The default value for this setting in the Windows style is 2.</db:para>
<db:para>We also change the extent of <db:link xlink:href="qscrollbar.xml">QScrollBar</db:link>s, i.e., the height for a horizontal scroll bar and the width for a vertical scroll bar, to be 4 pixels more than in the Windows style. This makes the style a bit more distinctive.</db:para>
<db:para>For all other <db:link xlink:href="qstyle.xml#PixelMetric-enum">QStyle::PixelMetric</db:link> elements, we use the Windows settings.</db:para>
<db:programlisting language="cpp">int NorwegianWoodStyle::styleHint(StyleHint hint, const QStyleOption *option,
                                  const QWidget *widget,
                                  QStyleHintReturn *returnData) const
{
    switch (hint) {
    case SH_DitherDisabledText:
        return int(false);
    case SH_EtchDisabledText:
        return int(true);
    default:
        return QProxyStyle::styleHint(hint, option, widget, returnData);
    }
}
</db:programlisting>
<db:para>The <db:link xlink:href="qstyle.xml#styleHint">styleHint</db:link>() function returns some hints to widgets or to the base style (in our case <db:link xlink:href="qproxystyle.xml">QProxyStyle</db:link>) about how to draw the widgets. The Windows style returns true for the <db:link xlink:href="qstyle.xml#StyleHint-enum">QStyle::SH_DitherDisabledText</db:link> hint, resulting in a most unpleasing visual effect. We override this behavior and return false instead. We also return true for the <db:link xlink:href="qstyle.xml#StyleHint-enum">QStyle::SH_EtchDisabledText</db:link> hint, meaning that disabled text is rendered with an embossed look.</db:para>
<db:programlisting language="cpp">void NorwegianWoodStyle::drawPrimitive(PrimitiveElement element,
                                       const QStyleOption *option,
                                       QPainter *painter,
                                       const QWidget *widget) const
{
    switch (element) {
    case PE_PanelButtonCommand:
        {
            int delta = (option-&amp;gt;state &amp;amp; State_MouseOver) ? 64 : 0;
            QColor slightlyOpaqueBlack(0, 0, 0, 63);
            QColor semiTransparentWhite(255, 255, 255, 127 + delta);
            QColor semiTransparentBlack(0, 0, 0, 127 - delta);

            int x, y, width, height;
            option-&amp;gt;rect.getRect(&amp;amp;x, &amp;amp;y, &amp;amp;width, &amp;amp;height);
</db:programlisting>
<db:para>The <db:link xlink:href="qstyle.xml#drawPrimitive">drawPrimitive</db:link>() function is called by Qt widgets to draw various fundamental graphical elements. Here we reimplement it to draw <db:link xlink:href="qpushbutton.xml">QPushButton</db:link> and <db:link xlink:href="qcombobox.xml">QComboBox</db:link> with round corners. The button part of these widgets is drawn using the <db:link xlink:href="qstyle.xml#PrimitiveElement-enum">QStyle::PE_PanelButtonCommand</db:link> primitive element.</db:para>
<db:para>The option parameter, of type <db:link xlink:href="qstyleoption.xml">QStyleOption</db:link>, contains everything we need to know about the widget we want to draw on. In particular, option-&gt;rect gives the rectangle within which to draw the primitive element. The painter parameter is a <db:link xlink:href="qpainter.xml">QPainter</db:link> object that we can use to draw on the widget.</db:para>
<db:para>The widget parameter is the widget itself. Normally, all the information we need is available in option and painter, so we don't need widget. We can use it to perform special effects; for example, QMacStyle uses it to animate default buttons. If you use it, be aware that the caller is allowed to pass a null pointer.</db:para>
<db:para>We start by defining three <db:link xlink:href="qcolor.xml">QColor</db:link>s that we'll need later on. We also put the x, y, width, and height components of the widget's rectangle in local variables. The value used for the semiTransparentWhite and for the semiTransparentBlack color's alpha channel depends on whether the mouse cursor is over the widget or not. Since we set the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_Hover</db:link> attribute on <db:link xlink:href="qpushbutton.xml">QPushButton</db:link>s and <db:link xlink:href="qcombobox.xml">QComboBox</db:link>es, we can rely on the <db:link xlink:href="qstyle.xml#StateFlag-enum">QStyle::State_MouseOver</db:link> flag to be set when the mouse is over the widget.</db:para>
<db:programlisting language="cpp">            QPainterPath roundRect = roundRectPath(option-&amp;gt;rect);
            int radius = qMin(width, height) / 2;
</db:programlisting>
<db:para>The roundRect variable is a <db:link xlink:href="qpainterpath.xml">QPainterPath</db:link>. A <db:link xlink:href="qpainterpath.xml">QPainterPath</db:link> is is a vectorial specification of a shape. Any shape (rectangle, ellipse, spline, etc.) or combination of shapes can be expressed as a path. We will use roundRect both for filling the button background with a wooden texture and for drawing the outline. The roundRectPath() function is a private function; we will come back to it later.</db:para>
<db:programlisting language="cpp">            QBrush brush;
            bool darker;

            const QStyleOptionButton *buttonOption =
                    qstyleoption_cast&amp;lt;const QStyleOptionButton *&amp;gt;(option);
            if (buttonOption
                    &amp;amp;&amp;amp; (buttonOption-&amp;gt;features &amp;amp; QStyleOptionButton::Flat)) {
                brush = option-&amp;gt;palette.window();
                darker = (option-&amp;gt;state &amp;amp; (State_Sunken | State_On));
            } else {
                if (option-&amp;gt;state &amp;amp; (State_Sunken | State_On)) {
                    brush = option-&amp;gt;palette.mid();
                    darker = !(option-&amp;gt;state &amp;amp; State_Sunken);
                } else {
                    brush = option-&amp;gt;palette.button();
                    darker = false;
                }
            }
</db:programlisting>
<db:para>We define two variables, brush and darker, and initialize them based on the state of the button:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If the button is a <db:link xlink:href="qpushbutton.xml#flat-prop">flat button</db:link>, we use the <db:link xlink:href="qpalette.xml#ColorRole-enum">Window</db:link> brush. We set darker to true if the button is <db:link xlink:href="qabstractbutton.xml#down-prop">down</db:link> or <db:link xlink:href="qabstractbutton.xml#checked-prop">checked</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the button is currently held down by the user or in the <db:link xlink:href="qabstractbutton.xml#checked-prop">checked</db:link> state, we use the <db:link xlink:href="qpalette.xml#ColorRole-enum">Mid</db:link> component of the palette. We set darker to true if the button is <db:link xlink:href="qabstractbutton.xml#checked-prop">checked</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Otherwise, we use the <db:link xlink:href="qpalette.xml#ColorRole-enum">Button</db:link> component of the palette.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The screenshot below illustrates how <db:link xlink:href="qpushbutton.xml">QPushButton</db:link>s are rendered based on their state:</db:para>
<db:mediaobject>
<db:alt>Norwegian Wood buttons in different states</db:alt>
<db:imageobject>
<db:imagedata fileref="images/styles-woodbuttons.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>To discover whether the button is flat or not, we need to cast the option parameter to <db:link xlink:href="qstyleoptionbutton.xml">QStyleOptionButton</db:link> and check if the <db:link xlink:href="qstyleoptionbutton.xml#features-var">features</db:link> member specifies the <db:link xlink:href="qstyleoptionbutton.xml#ButtonFeature-enum">QStyleOptionButton::Flat</db:link> flag. The <db:link xlink:href="qstylehintreturn.xml#qstyleoption_cast-1">qstyleoption_cast</db:link>() function performs a dynamic cast; if option is not a <db:link xlink:href="qstyleoptionbutton.xml">QStyleOptionButton</db:link>, <db:link xlink:href="qstylehintreturn.xml#qstyleoption_cast-1">qstyleoption_cast</db:link>() returns a null pointer.</db:para>
<db:programlisting language="cpp">            painter-&amp;gt;save();
            painter-&amp;gt;setRenderHint(QPainter::Antialiasing, true);
            painter-&amp;gt;fillPath(roundRect, brush);
            if (darker)
                painter-&amp;gt;fillPath(roundRect, slightlyOpaqueBlack);
</db:programlisting>
<db:para>We turn on antialiasing on <db:link xlink:href="qpainter.xml">QPainter</db:link>. Antialiasing is a technique that reduces the visual distortion that occurs when the edges of a shape are converted into pixels. For the Norwegian Wood style, we use it to obtain smoother edges for the round buttons.</db:para>
<db:mediaobject>
<db:alt>Norwegian wood buttons with and without antialiasing</db:alt>
<db:imageobject>
<db:imagedata fileref="images/styles-aliasing.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The first call to <db:link xlink:href="qpainter.xml#fillPath">QPainter::fillPath</db:link>() draws the background of the button with a wooden texture. The second call to <db:link xlink:href="qpainter.xml#fillPath">fillPath</db:link>() paints the same area with a semi-transparent black color (a black color with an alpha channel of 63) to make the area darker if darker is true.</db:para>
<db:programlisting language="cpp">            int penWidth;
            if (radius &amp;lt; 10)
                penWidth = 3;
            else if (radius &amp;lt; 20)
                penWidth = 5;
            else
                penWidth = 7;

            QPen topPen(semiTransparentWhite, penWidth);
            QPen bottomPen(semiTransparentBlack, penWidth);

            if (option-&amp;gt;state &amp;amp; (State_Sunken | State_On))
                qSwap(topPen, bottomPen);
</db:programlisting>
<db:para>Next, we draw the outline. The top-left half of the outline and the bottom-right half of the outline are drawn using different <db:link xlink:href="qpen.xml">QPen</db:link>s to produce a 3D effect. Normally, the top-left half of the outline is drawn lighter whereas the bottom-right half is drawn darker, but if the button is <db:link xlink:href="qabstractbutton.xml#down-prop">down</db:link> or <db:link xlink:href="qabstractbutton.xml#checked-prop">checked</db:link>, we invert the two <db:link xlink:href="qpen.xml">QPen</db:link>s to give a sunken look to the button.</db:para>
<db:programlisting language="cpp">            int x1 = x;
            int x2 = x + radius;
            int x3 = x + width - radius;
            int x4 = x + width;

            if (option-&amp;gt;direction == Qt::RightToLeft) {
                qSwap(x1, x4);
                qSwap(x2, x3);
            }

            QPolygon topHalf;
            topHalf &amp;lt;&amp;lt; QPoint(x1, y)
                    &amp;lt;&amp;lt; QPoint(x4, y)
                    &amp;lt;&amp;lt; QPoint(x3, y + radius)
                    &amp;lt;&amp;lt; QPoint(x2, y + height - radius)
                    &amp;lt;&amp;lt; QPoint(x1, y + height);

            painter-&amp;gt;setClipPath(roundRect);
            painter-&amp;gt;setClipRegion(topHalf, Qt::IntersectClip);
            painter-&amp;gt;setPen(topPen);
            painter-&amp;gt;drawPath(roundRect);
</db:programlisting>
<db:para>We draw the top-left part of the outline by calling <db:link xlink:href="qpainter.xml#drawPath">QPainter::drawPath</db:link>() with an appropriate <db:link xlink:href="qpainter.xml#setClipRegion">clip region</db:link>. If the <db:link xlink:href="qstyleoption.xml#direction-var">layout direction</db:link> is right-to-left instead of left-to-right, we swap the x1, x2, x3, and x4 variables to obtain correct results. On right-to-left desktop, the &quot;light&quot; comes from the top-right corner of the screen instead of the top-left corner; raised and sunken widgets must be drawn accordingly.</db:para>
<db:para>The diagram below illustrates how 3D effects are drawn according to the layout direction. The area in red on the diagram corresponds to the topHalf polygon:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/styles-3d.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>An easy way to test how a style looks in right-to-left mode is to pass the -reverse command-line option to the application. This option is recognized by the <db:link xlink:href="qapplication.xml">QApplication</db:link> constructor.</db:para>
<db:programlisting language="cpp">            QPolygon bottomHalf = topHalf;
            bottomHalf[0] = QPoint(x4, y + height);

            painter-&amp;gt;setClipPath(roundRect);
            painter-&amp;gt;setClipRegion(bottomHalf, Qt::IntersectClip);
            painter-&amp;gt;setPen(bottomPen);
            painter-&amp;gt;drawPath(roundRect);

            painter-&amp;gt;setPen(option-&amp;gt;palette.windowText().color());
            painter-&amp;gt;setClipping(false);
            painter-&amp;gt;drawPath(roundRect);

            painter-&amp;gt;restore();
        }
        break;
    default:
        QProxyStyle::drawPrimitive(element, option, painter, widget);
    }
}
</db:programlisting>
<db:para>The bottom-right part of the outline is drawn in a similar fashion. Then we draw a one-pixel wide outline around the entire button, using the <db:link xlink:href="qpalette.xml#ColorRole-enum">WindowText</db:link> component of the <db:link xlink:href="qpalette.xml">QPalette</db:link>.</db:para>
<db:para>This completes the <db:link xlink:href="qstyle.xml#PrimitiveElement-enum">QStyle::PE_PanelButtonCommand</db:link> case of the switch statement. Other primitive elements are handled by the base style. Let's now turn to the other NorwegianWoodStyle member functions:</db:para>
<db:programlisting language="cpp">void NorwegianWoodStyle::drawControl(ControlElement element,
                                     const QStyleOption *option,
                                     QPainter *painter,
                                     const QWidget *widget) const
{
    switch (element) {
    case CE_PushButtonLabel:
        {
            QStyleOptionButton myButtonOption;
            const QStyleOptionButton *buttonOption =
                    qstyleoption_cast&amp;lt;const QStyleOptionButton *&amp;gt;(option);
            if (buttonOption) {
                myButtonOption = *buttonOption;
                if (myButtonOption.palette.currentColorGroup()
                        != QPalette::Disabled) {
                    if (myButtonOption.state &amp;amp; (State_Sunken | State_On)) {
                        myButtonOption.palette.setBrush(QPalette::ButtonText,
                                myButtonOption.palette.brightText());
                    }
                }
            }
            QProxyStyle::drawControl(element, &amp;amp;myButtonOption, painter, widget);
        }
        break;
    default:
        QProxyStyle::drawControl(element, option, painter, widget);
    }
}
</db:programlisting>
<db:para>We reimplement <db:link xlink:href="qstyle.xml#drawControl">QStyle::drawControl</db:link>() to draw the text on a <db:link xlink:href="qpushbutton.xml">QPushButton</db:link> in a bright color when the button is <db:link xlink:href="qabstractbutton.xml#down-prop">down</db:link> or <db:link xlink:href="qabstractbutton.xml#checked-prop">checked</db:link>.</db:para>
<db:para>If the option parameter points to a <db:link xlink:href="qstyleoptionbutton.xml">QStyleOptionButton</db:link> object (it normally should), we take a copy of the object and modify its <db:link xlink:href="qstyleoption.xml#palette-var">palette</db:link> member to make the <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::ButtonText</db:link> be the same as the <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::BrightText</db:link> component (unless the widget is disabled).</db:para>
<db:programlisting language="cpp">void NorwegianWoodStyle::setTexture(QPalette &amp;amp;palette, QPalette::ColorRole role,
                                    const QImage &amp;amp;image)
{
    for (int i = 0; i &amp;lt; QPalette::NColorGroups; ++i) {
        QBrush brush(image);
        brush.setColor(palette.brush(QPalette::ColorGroup(i), role).color());
        palette.setBrush(QPalette::ColorGroup(i), role, brush);
    }
}
</db:programlisting>
<db:para>The setTexture() function is a private function that sets the <db:link xlink:href="qbrush.xml#texture">texture</db:link> component of the <db:link xlink:href="qbrush.xml">QBrush</db:link>es for a certain <db:link xlink:href="qpalette.xml#ColorRole-enum">color role</db:link>, for all three <db:link xlink:href="qpalette.xml#ColorGroup-enum">color groups</db:link> (active, disabled, inactive). We used it to initialize the Norwegian Wood palette in standardPalette.</db:para>
<db:programlisting language="cpp">QPainterPath NorwegianWoodStyle::roundRectPath(const QRect &amp;amp;rect)
{
    int radius = qMin(rect.width(), rect.height()) / 2;
    int diam = 2 * radius;

    int x1, y1, x2, y2;
    rect.getCoords(&amp;amp;x1, &amp;amp;y1, &amp;amp;x2, &amp;amp;y2);

    QPainterPath path;
    path.moveTo(x2, y1 + radius);
    path.arcTo(QRect(x2 - diam, y1, diam, diam), 0.0, +90.0);
    path.lineTo(x1 + radius, y1);
    path.arcTo(QRect(x1, y1, diam, diam), 90.0, +90.0);
    path.lineTo(x1, y2 - radius);
    path.arcTo(QRect(x1, y2 - diam, diam, diam), 180.0, +90.0);
    path.lineTo(x1 + radius, y2);
    path.arcTo(QRect(x2 - diam, y2 - diam, diam, diam), 270.0, +90.0);
    path.closeSubpath();
    return path;
}
</db:programlisting>
<db:para>The roundRectPath() function is a private function that constructs a <db:link xlink:href="qpainterpath.xml">QPainterPath</db:link> object for round buttons. The path consists of eight segments: four arc segments for the corners and four lines for the sides.</db:para>
<db:para>With around 250 lines of code, we have a fully functional custom style based on one of the predefined styles. Custom styles can be used to provide a distinct look to an application or family of applications.</db:para>
</db:section>
<db:section xml:id="widgetgallery-class">
<db:title>WidgetGallery Class</db:title>
<db:para>For completeness, we will quickly review the WidgetGallery class, which contains the most common Qt widgets and allows the user to change style dynamically. Here's the class definition:</db:para>
<db:programlisting language="cpp">class WidgetGallery : public QDialog
{
    Q_OBJECT

public:
    WidgetGallery(QWidget *parent = nullptr);

protected:
    void changeEvent(QEvent *) override;

private slots:
    void changeStyle(const QString &amp;amp;styleName);
    void styleChanged();
    void changePalette();
    void advanceProgressBar();

private:
    void createTopLeftGroupBox();
    void createTopRightGroupBox();
    void createBottomLeftTabWidget();
    void createBottomRightGroupBox();
    void createProgressBar();

    QLabel *styleLabel;
    QComboBox *styleComboBox;
    QCheckBox *useStylePaletteCheckBox;
    QCheckBox *disableWidgetsCheckBox;
    ...
};
</db:programlisting>
<db:para>Here's the WidgetGallery constructor:</db:para>
<db:programlisting language="cpp">WidgetGallery::WidgetGallery(QWidget *parent)
    : QDialog(parent)
{
    styleComboBox = new QComboBox;
    const QString defaultStyleName = QApplication::style()-&amp;gt;objectName();
    QStringList styleNames = QStyleFactory::keys();
    styleNames.append(&quot;NorwegianWood&quot;);
    for (int i = 1, size = styleNames.size(); i &amp;lt; size; ++i) {
        if (defaultStyleName.compare(styleNames.at(i), Qt::CaseInsensitive) == 0) {
            styleNames.swapItemsAt(0, i);
            break;
        }
    }
    styleComboBox-&amp;gt;addItems(styleNames);

    styleLabel = new QLabel(tr(&quot;&amp;amp;Style:&quot;));
    styleLabel-&amp;gt;setBuddy(styleComboBox);

    useStylePaletteCheckBox = new QCheckBox(tr(&quot;&amp;amp;Use style's standard palette&quot;));
    useStylePaletteCheckBox-&amp;gt;setChecked(true);

    disableWidgetsCheckBox = new QCheckBox(tr(&quot;&amp;amp;Disable widgets&quot;));

    createTopLeftGroupBox();
    createTopRightGroupBox();
    createBottomLeftTabWidget();
    createBottomRightGroupBox();
    createProgressBar();
</db:programlisting>
<db:para>We start by creating child widgets. The <db:guilabel>Style</db:guilabel> combobox is initialized with all the styles known to <db:link xlink:href="qstylefactory.xml">QStyleFactory</db:link>, in addition to NorwegianWood. The create...() functions are private functions that set up the various parts of the WidgetGallery.</db:para>
<db:programlisting language="cpp">    connect(styleComboBox, &amp;amp;QComboBox::textActivated,
            this, &amp;amp;WidgetGallery::changeStyle);
    connect(useStylePaletteCheckBox, &amp;amp;QCheckBox::toggled,
            this, &amp;amp;WidgetGallery::changePalette);
    connect(disableWidgetsCheckBox, &amp;amp;QCheckBox::toggled,
            topLeftGroupBox, &amp;amp;QGroupBox::setDisabled);
    connect(disableWidgetsCheckBox, &amp;amp;QCheckBox::toggled,
            topRightGroupBox, &amp;amp;QGroupBox::setDisabled);
    connect(disableWidgetsCheckBox, &amp;amp;QCheckBox::toggled,
            bottomLeftTabWidget, &amp;amp;QGroupBox::setDisabled);
    connect(disableWidgetsCheckBox, &amp;amp;QCheckBox::toggled,
            bottomRightGroupBox, &amp;amp;QGroupBox::setDisabled);
</db:programlisting>
<db:para>We connect the <db:guilabel>Style</db:guilabel> combobox to the changeStyle() private slot, the <db:guilabel>Use style's standard palette</db:guilabel> check box to the changePalette() slot, and the <db:guilabel>Disable widgets</db:guilabel> check box to the child widgets' <db:link xlink:href="qwidget.xml#setDisabled">setDisabled</db:link>() slot.</db:para>
<db:programlisting language="cpp">    QHBoxLayout *topLayout = new QHBoxLayout;
    topLayout-&amp;gt;addWidget(styleLabel);
    topLayout-&amp;gt;addWidget(styleComboBox);
    topLayout-&amp;gt;addStretch(1);
    topLayout-&amp;gt;addWidget(useStylePaletteCheckBox);
    topLayout-&amp;gt;addWidget(disableWidgetsCheckBox);

    QGridLayout *mainLayout = new QGridLayout;
    mainLayout-&amp;gt;addLayout(topLayout, 0, 0, 1, 2);
    mainLayout-&amp;gt;addWidget(topLeftGroupBox, 1, 0);
    mainLayout-&amp;gt;addWidget(topRightGroupBox, 1, 1);
    mainLayout-&amp;gt;addWidget(bottomLeftTabWidget, 2, 0);
    mainLayout-&amp;gt;addWidget(bottomRightGroupBox, 2, 1);
    mainLayout-&amp;gt;addWidget(progressBar, 3, 0, 1, 2);
    mainLayout-&amp;gt;setRowStretch(1, 1);
    mainLayout-&amp;gt;setRowStretch(2, 1);
    mainLayout-&amp;gt;setColumnStretch(0, 1);
    mainLayout-&amp;gt;setColumnStretch(1, 1);
    setLayout(mainLayout);

    setWindowTitle(tr(&quot;Styles&quot;));
    styleChanged();
}
</db:programlisting>
<db:para>Finally, we put the child widgets in layouts.</db:para>
<db:programlisting language="cpp">void WidgetGallery::changeStyle(const QString &amp;amp;styleName)
{
    if (styleName == &quot;NorwegianWood&quot;)
        QApplication::setStyle(new NorwegianWoodStyle);
    else
        QApplication::setStyle(QStyleFactory::create(styleName));
}
</db:programlisting>
<db:para>When the user changes the style in the combobox, we call <db:link xlink:href="qapplication.xml#setStyle">QApplication::setStyle</db:link>() to dynamically change the style of the application.</db:para>
<db:programlisting language="cpp">void WidgetGallery::changePalette()
{
    QApplication::setPalette(useStylePaletteCheckBox-&amp;gt;isChecked() ?
        QApplication::style()-&amp;gt;standardPalette() : QPalette());
}
</db:programlisting>
<db:para>If the user turns the <db:guilabel>Use style's standard palette</db:guilabel> on, the current style's <db:link xlink:href="qstyle.xml#standardPalette">standard palette</db:link> is used; otherwise, the system's default palette is honored.</db:para>
<db:programlisting language="cpp">void WidgetGallery::advanceProgressBar()
{
    int curVal = progressBar-&amp;gt;value();
    int maxVal = progressBar-&amp;gt;maximum();
    progressBar-&amp;gt;setValue(curVal + (maxVal - curVal) / 100);
}
</db:programlisting>
<db:para>The advanceProgressBar() slot is called at regular intervals to advance the progress bar. Since we don't know how long the user will keep the Styles application running, we use a logarithmic formula: The closer the progress bar gets to 100%, the slower it advances.</db:para>
<db:para>We will review createProgressBar() in a moment.</db:para>
<db:programlisting language="cpp">void WidgetGallery::createTopLeftGroupBox()
{
    topLeftGroupBox = new QGroupBox(tr(&quot;Group 1&quot;));

    radioButton1 = new QRadioButton(tr(&quot;Radio button 1&quot;));
    radioButton2 = new QRadioButton(tr(&quot;Radio button 2&quot;));
    radioButton3 = new QRadioButton(tr(&quot;Radio button 3&quot;));
    radioButton1-&amp;gt;setChecked(true);

    checkBox = new QCheckBox(tr(&quot;Tri-state check box&quot;));
    checkBox-&amp;gt;setTristate(true);
    checkBox-&amp;gt;setCheckState(Qt::PartiallyChecked);

    QVBoxLayout *layout = new QVBoxLayout;
    layout-&amp;gt;addWidget(radioButton1);
    layout-&amp;gt;addWidget(radioButton2);
    layout-&amp;gt;addWidget(radioButton3);
    layout-&amp;gt;addWidget(checkBox);
    layout-&amp;gt;addStretch(1);
    topLeftGroupBox-&amp;gt;setLayout(layout);
}
</db:programlisting>
<db:para>The createTopLeftGroupBox() function creates the <db:link xlink:href="qgroupbox.xml">QGroupBox</db:link> that occupies the top-left corner of the WidgetGallery. We skip the createTopRightGroupBox(), createBottomLeftTabWidget(), and createBottomRightGroupBox() functions, which are very similar.</db:para>
<db:programlisting language="cpp">void WidgetGallery::createProgressBar()
{
    progressBar = new QProgressBar;
    progressBar-&amp;gt;setRange(0, 10000);
    progressBar-&amp;gt;setValue(0);

    QTimer *timer = new QTimer(this);
    connect(timer, &amp;amp;QTimer::timeout, this, &amp;amp;WidgetGallery::advanceProgressBar);
    timer-&amp;gt;start(1000);
}
</db:programlisting>
<db:para>In createProgressBar(), we create a <db:link xlink:href="qprogressbar.xml">QProgressBar</db:link> at the bottom of the WidgetGallery and connect its <db:link xlink:href="qtimer.xml#timeout">timeout</db:link>() signal to the advanceProgressBar() slot.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/widgets/styles?h=6.0">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
