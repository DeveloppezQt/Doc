<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QAudioBuffer Class</db:title>
<db:productname>QtMultimedia</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Multimedia Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qaudiobuffer.xml">QAudioBuffer</db:link> class represents a collection of audio samples with a specific format and sample rate.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QAudioBuffer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += multimedia</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QAudioBuffer is part of <db:simplelist><db:member>multimedia</db:member><db:member>multimedia_audio</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QAudioBuffer">
<db:title>QAudioBuffer::QAudioBuffer()</db:title>
<db:para>Create a new, empty, invalid buffer.</db:para>
</db:section>
<db:section xml:id="QAudioBuffer-2">
<db:title>QAudioBuffer::QAudioBuffer(const QByteArray &amp;<db:emphasis>data</db:emphasis>, const QAudioFormat &amp;<db:emphasis>format</db:emphasis>, qint64 <db:emphasis>startTime</db:emphasis> = -1)</db:title>
<db:para>Creates a new audio buffer from the supplied <db:code role="parameter">data</db:code>, in the given <db:code role="parameter">format</db:code>. The format will determine how the number and sizes of the samples are interpreted from the <db:code role="parameter">data</db:code>.</db:para>
<db:para>If the supplied <db:code role="parameter">data</db:code> is not an integer multiple of the calculated frame size, the excess data will not be used.</db:para>
<db:para>This audio buffer will copy the contents of <db:code role="parameter">data</db:code>.</db:para>
<db:para><db:code role="parameter">startTime</db:code> (in microseconds) indicates when this buffer starts in the stream. If this buffer is not part of a stream, set it to -1.</db:para>
</db:section>
<db:section xml:id="QAudioBuffer-3">
<db:title>QAudioBuffer::QAudioBuffer(int <db:emphasis>numFrames</db:emphasis>, const QAudioFormat &amp;<db:emphasis>format</db:emphasis>, qint64 <db:emphasis>startTime</db:emphasis> = -1)</db:title>
<db:para>Creates a new audio buffer with space for <db:code role="parameter">numFrames</db:code> frames of the given <db:code role="parameter">format</db:code>. The individual samples will be initialized to the default for the format.</db:para>
<db:para><db:code role="parameter">startTime</db:code> (in microseconds) indicates when this buffer starts in the stream. If this buffer is not part of a stream, set it to -1.</db:para>
</db:section>
<db:section xml:id="QAudioBuffer-1">
<db:title>QAudioBuffer::QAudioBuffer(const QAudioBuffer &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Creates a new audio buffer from <db:code role="parameter">other</db:code>. Generally this will have copy-on-write semantics - a copy will only be made when it has to be.</db:para>
</db:section>
<db:section xml:id="dtor.QAudioBuffer">
<db:title>[noexcept] QAudioBuffer::~QAudioBuffer()</db:title>
<db:para>Destroys this audio buffer.</db:para>
</db:section>
<db:section xml:id="byteCount">
<db:title>int QAudioBuffer::byteCount() const</db:title>
<db:para>Returns the size of this buffer, in bytes.</db:para>
</db:section>
<db:section xml:id="constData">
<db:title>const void *QAudioBuffer::constData() const</db:title>
<db:para>Returns a pointer to this buffer's data. You can only read it.</db:para>
<db:para>This method is preferred over the const version of <db:link xlink:href="qaudiobuffer.xml#data">data</db:link>() to prevent unnecessary copying.</db:para>
<db:para>There is also a templatized version of this constData() function that allows you to retrieve a specific type of read-only pointer to the data. Note that there is no checking done on the format of the audio buffer - this is simply a convenience function.</db:para>
<db:programlisting language="cpp">// With a 16bit sample buffer:
const quint16 *data = buffer-&gt;constData&lt;quint16&gt;();
</db:programlisting>
</db:section>
<db:section xml:id="data">
<db:title>void *QAudioBuffer::data()</db:title>
<db:para>Returns a pointer to this buffer's data. You can modify the data through the returned pointer.</db:para>
<db:para>Since QAudioBuffers can share the actual sample data, calling this function will result in a deep copy being made if there are any other buffers using the sample. You should avoid calling this unless you really need to modify the data.</db:para>
<db:para>This pointer will remain valid until the underlying storage is detached. In particular, if you obtain a pointer, and then copy this audio buffer, changing data through this pointer may change both buffer instances. Calling data() on either instance will again cause a deep copy to be made, which may invalidate the pointers returned from this function previously.</db:para>
<db:para>There is also a templatized version of data() allows you to retrieve a specific type of pointer to the data. Note that there is no checking done on the format of the audio buffer - this is simply a convenience function.</db:para>
<db:programlisting language="cpp">// With a 16bit sample buffer:
quint16 *data = buffer-&gt;data&lt;quint16&gt;(); // May cause deep copy
</db:programlisting>
</db:section>
<db:section xml:id="data-1">
<db:title>const void *QAudioBuffer::data() const</db:title>
<db:para>Returns a pointer to this buffer's data. You can only read it.</db:para>
<db:para>You should use the <db:link xlink:href="qaudiobuffer.xml#constData">constData</db:link>() function rather than this to prevent accidental deep copying.</db:para>
<db:para>There is also a templatized version of this <db:link xlink:href="qaudiobuffer.xml#data">data</db:link>() function that allows you to retrieve a specific type of read-only pointer to the data. Note that there is no checking done on the format of the audio buffer - this is simply a convenience function.</db:para>
<db:programlisting language="cpp">// With a 16bit sample const buffer:
const quint16 *data = buffer-&gt;data&lt;quint16&gt;();
</db:programlisting>
</db:section>
<db:section xml:id="duration">
<db:title>qint64 QAudioBuffer::duration() const</db:title>
<db:para>Returns the duration of audio in this buffer, in microseconds.</db:para>
<db:para>This depends on the /l <db:link xlink:href="qaudiobuffer.xml#format">format</db:link>(), and the <db:link xlink:href="qaudiobuffer.xml#frameCount">frameCount</db:link>().</db:para>
</db:section>
<db:section xml:id="format">
<db:title>QAudioFormat QAudioBuffer::format() const</db:title>
<db:para>Returns the <db:link xlink:href="qaudioformat.xml">format</db:link> of this buffer.</db:para>
<db:para>Several properties of this format influence how the <db:link xlink:href="qaudiobuffer.xml#duration">duration</db:link>() or <db:link xlink:href="qaudiobuffer.xml#byteCount">byteCount</db:link>() are calculated from the <db:link xlink:href="qaudiobuffer.xml#frameCount">frameCount</db:link>().</db:para>
</db:section>
<db:section xml:id="frameCount">
<db:title>int QAudioBuffer::frameCount() const</db:title>
<db:para>Returns the number of complete audio frames in this buffer.</db:para>
<db:para>An audio frame is an interleaved set of one sample per channel for the same instant in time.</db:para>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QAudioBuffer::isValid() const</db:title>
<db:para>Returns true if this is a valid buffer. A valid buffer has more than zero frames in it and a valid format.</db:para>
</db:section>
<db:section xml:id="sampleCount">
<db:title>int QAudioBuffer::sampleCount() const</db:title>
<db:para>Returns the number of samples in this buffer.</db:para>
<db:para>If the format of this buffer has multiple channels, then this count includes all channels. This means that a stereo buffer with 1000 samples in total will have 500 left samples and 500 right samples (interleaved), and this function will return 1000.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaudiobuffer.xml#frameCount">frameCount</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startTime">
<db:title>qint64 QAudioBuffer::startTime() const</db:title>
<db:para>Returns the time in a stream that this buffer starts at (in microseconds).</db:para>
<db:para>If this buffer is not part of a stream, this will return -1.</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QAudioBuffer &amp;QAudioBuffer::operator=(const QAudioBuffer &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Assigns the <db:code role="parameter">other</db:code> buffer to this.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="S16S-typedef">
<db:title>S16S</db:title>
<db:para>This is a predefined specialization for a signed stereo 16 bit sample. Each channel is a <db:emphasis>signed short</db:emphasis>.</db:para>
</db:section>
<db:section xml:id="S16U-typedef">
<db:title>S16U</db:title>
<db:para>This is a predefined specialization for an unsigned stereo 16 bit sample. Each channel is an <db:emphasis>unsigned short</db:emphasis>.</db:para>
</db:section>
<db:section xml:id="S32F-typedef">
<db:title>S32F</db:title>
<db:para>This is a predefined specialization for an 32 bit float sample. Each channel is a <db:emphasis>float</db:emphasis>.</db:para>
</db:section>
<db:section xml:id="S8S-typedef">
<db:title>S8S</db:title>
<db:para>This is a predefined specialization for a signed stereo 8 bit sample. Each channel is a <db:emphasis>signed char</db:emphasis>.</db:para>
</db:section>
<db:section xml:id="S8U-typedef">
<db:title>S8U</db:title>
<db:para>This is a predefined specialization for an unsigned stereo 8 bit sample. Each channel is an <db:emphasis>unsigned char</db:emphasis>.</db:para>
</db:section>
</db:section>
</db:article>
