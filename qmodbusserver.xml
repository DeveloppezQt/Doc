<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QModbusServer Class</db:title>
<db:productname>QtSerialBus</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Serial Bus Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qmodbusserver.xml">QModbusServer</db:link> class is the interface to receive and process Modbus requests.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QModbusServer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS SerialBus)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::SerialBus)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += serialbus</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qmodbusdevice.xml" xlink:role="class">QModbusDevice</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qmodbusrtuserialserver.xml" xlink:role="class">QModbusRtuSerialServer</db:link> and <db:link xlink:href="qmodbustcpserver.xml" xlink:role="class">QModbusTcpServer</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Modbus networks can have multiple Modbus servers. Modbus Servers are read/written by a Modbus client represented by <db:link xlink:href="qmodbusclient.xml">QModbusClient</db:link>. <db:link xlink:href="qmodbusserver.xml">QModbusServer</db:link> communicates with a Modbus backend, providing users with a convenient API.</db:para>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Option-enum">
<db:title>enum QModbusServer::Option</db:title>
<db:enumsynopsis>
<db:enumname>Option</db:enumname>
<db:enumitem>
<db:enumidentifier>DiagnosticRegister</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExceptionStatusOffset</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DeviceBusy</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AsciiInputDelimiter</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ListenOnlyMode</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ServerIdentifier</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RunIndicatorStatus</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AdditionalData</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DeviceIdentification</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UserOption</db:enumidentifier>
<db:enumvalue>0x100</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Each Modbus server has a set of values associated with it, each with its own option.</db:para>
<db:para>The general purpose options (and the associated types) are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmodbusserver.xml">QModbusServer</db:link></db:emphasis>::DiagnosticRegister</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The diagnostic register of the server. <db:code>quint16</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmodbusserver.xml">QModbusServer</db:link></db:emphasis>::ExceptionStatusOffset</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The exception status byte offset of the server. <db:code>quint16</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmodbusserver.xml">QModbusServer</db:link></db:emphasis>::DeviceBusy</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Flag to signal the server is engaged in processing a long-duration program command. <db:code>quint16</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmodbusserver.xml">QModbusServer</db:link></db:emphasis>::AsciiInputDelimiter</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The Modbus ASCII end of message delimiter. <db:code>char</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmodbusserver.xml">QModbusServer</db:link></db:emphasis>::ListenOnlyMode</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>Flag to set listen only mode of the server. This function is typically supported only by Modbus serial devices. <db:code>bool</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmodbusserver.xml">QModbusServer</db:link></db:emphasis>::ServerIdentifier</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The identifier of the server, <db:emphasis role="bold">not</db:emphasis> the server address. <db:code>quint8</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmodbusserver.xml">QModbusServer</db:link></db:emphasis>::RunIndicatorStatus</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The run indicator of the server. <db:code>quint8</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmodbusserver.xml">QModbusServer</db:link></db:emphasis>::AdditionalData</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>The additional data of the server. <db:code>QByteArray</db:code></db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmodbusserver.xml">QModbusServer</db:link></db:emphasis>::DeviceIdentification</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>The physical and functional description of the server. <db:code>QModbusDeviceIdentification</db:code></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>User options:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmodbusserver.xml">QModbusServer</db:link></db:emphasis>::UserOption</db:code></db:para>
</db:td>
<db:td><db:code>0x100</db:code></db:td>
<db:td>
<db:para>The first option that can be used for user-specific purposes.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>For user options, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QModbusServer">
<db:title>[explicit] QModbusServer::QModbusServer(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QModbusServer</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QModbusServer(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a Modbus server with the specified <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="data">
<db:title>bool QModbusServer::data(QModbusDataUnit *<db:emphasis>newData</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>data</db:methodname>
<db:methodparam>
<db:type>QModbusDataUnit *</db:type>
<db:parameter>newData</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool data(QModbusDataUnit *newData) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the values in the register range given by <db:code role="parameter">newData</db:code>.</db:para>
<db:para><db:code role="parameter">newData</db:code> must provide a valid register type, start address and valueCount. The returned <db:code role="parameter">newData</db:code> will contain the register values associated with the given range.</db:para>
<db:para>If <db:code role="parameter">newData</db:code> contains a valid register type but a negative start address the entire register map is returned and <db:code role="parameter">newData</db:code> appropriately sized.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmodbusserver.xml#setData">setData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data-1">
<db:title>bool QModbusServer::data(QModbusDataUnit::RegisterType <db:emphasis>table</db:emphasis>, quint16 <db:emphasis>address</db:emphasis>, quint16 *<db:emphasis>data</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>data</db:methodname>
<db:methodparam>
<db:type>QModbusDataUnit::RegisterType</db:type>
<db:parameter>table</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint16 *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool data(QModbusDataUnit::RegisterType table, quint16 address, quint16 *data) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads data stored in the Modbus server. A Modbus server has four tables (<db:code role="parameter">table</db:code>) and each have a unique <db:code role="parameter">address</db:code> field, which is used to read <db:code role="parameter">data</db:code> from the desired field. See <db:link xlink:href="qmodbusdataunit.xml#RegisterType-enum">QModbusDataUnit::RegisterType</db:link> for more information about the different tables. Returns <db:code>false</db:code> if address is outside of the map range or the register type is not even defined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmodbusdataunit.xml#RegisterType-enum">QModbusDataUnit::RegisterType</db:link></db:member>
<db:member><db:link xlink:href="qmodbusserver.xml#setData">setData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dataWritten">
<db:title>void QModbusServer::dataWritten(QModbusDataUnit::RegisterType <db:emphasis>table</db:emphasis>, int <db:emphasis>address</db:emphasis>, int <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>dataWritten</db:methodname>
<db:methodparam>
<db:type>QModbusDataUnit::RegisterType</db:type>
<db:parameter>table</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void dataWritten(QModbusDataUnit::RegisterType table, int address, int size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when a Modbus client has written one or more fields of data to the Modbus server. The signal contains information about the fields that were written:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Register type (<db:code role="parameter">table</db:code>) that was written,</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code role="parameter">address</db:code> of the first field that was written,</db:para>
</db:listitem>
<db:listitem>
<db:para>and <db:code role="parameter">size</db:code> of consecutive fields that were written starting from <db:code role="parameter">address</db:code>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The signal is not emitted when the to-be-written fields have not changed due to no change in value.</db:para>
</db:section>
<db:section xml:id="processPrivateRequest">
<db:title>[virtual protected] QModbusResponse QModbusServer::processPrivateRequest(const QModbusPdu &amp;<db:emphasis>request</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QModbusResponse</db:type>
<db:methodname>processPrivateRequest</db:methodname>
<db:methodparam>
<db:type>const QModbusPdu &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QModbusResponse processPrivateRequest(const QModbusPdu &amp;request)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function should be implemented by custom Modbus servers. It is called by <db:link xlink:href="qmodbusserver.xml#processRequest">processRequest</db:link>() if the given <db:code role="parameter">request</db:code> is not a standard Modbus request.</db:para>
<db:para>Overwriting this function allows handling of additional function codes and subfunction-codes not specified in the Modbus Application Protocol Specification 1.1b. Reimplementations should call this function again to ensure an exception response is returned for all unknown function codes the custom Modbus implementation does not handle.</db:para>
<db:para>This default implementation returns a <db:code>QModbusExceptionResponse</db:code> with the <db:code role="parameter">request</db:code> function code and error code set to illegal function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmodbusserver.xml#processRequest">processRequest</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="processRequest">
<db:title>[virtual protected] QModbusResponse QModbusServer::processRequest(const QModbusPdu &amp;<db:emphasis>request</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QModbusResponse</db:type>
<db:methodname>processRequest</db:methodname>
<db:methodparam>
<db:type>const QModbusPdu &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QModbusResponse processRequest(const QModbusPdu &amp;request)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Processes a Modbus client <db:code role="parameter">request</db:code> and returns a Modbus response. This function returns a <db:link xlink:href="qmodbusresponse.xml">QModbusResponse</db:link> or <db:link xlink:href="qmodbusexceptionresponse.xml">QModbusExceptionResponse</db:link> depending on the nature of the request.</db:para>
<db:para>The default implementation of this function handles all standard Modbus function codes as defined by the Modbus Application Protocol Specification 1.1b. All other Modbus function codes not included in the specification are forwarded to <db:link xlink:href="qmodbusserver.xml#processPrivateRequest">processPrivateRequest</db:link>().</db:para>
<db:para>The default handling of the standard Modbus function code requests can be overwritten by reimplementing this function. The override must handle the request type in question and return the appropriate <db:link xlink:href="qmodbusresponse.xml">QModbusResponse</db:link>. A common reason might be to filter out function code requests for data values to limit read/write access and function codes not desired in particular implementations such as serial line diagnostics on ethernet or Modbus Plus transport layers. Every other request type should be forwarded to this default implementation.</db:para>
<db:note>
<db:para>This function should not be overridden to provide a custom implementation for non-standard Modbus request types.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmodbusserver.xml#processPrivateRequest">processPrivateRequest</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="processesBroadcast">
<db:title>[virtual] bool QModbusServer::processesBroadcast() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>processesBroadcast</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool processesBroadcast() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Subclasses should implement this function if the transport layer shall handle broadcasts. The implementation then should return <db:code>true</db:code> if the currently processed request is a broadcast request; otherwise <db:code>false</db:code>. The default implementation returns always <db:code>false</db:code>.</db:para>
<db:note>
<db:para>The return value of this function only makes sense from within <db:link xlink:href="qmodbusserver.xml#processRequest">processRequest</db:link>() or <db:link xlink:href="qmodbusserver.xml#processPrivateRequest">processPrivateRequest</db:link>(), otherwise it can only tell that the last request processed was a broadcast request.</db:para>
</db:note>
</db:section>
<db:section xml:id="readData">
<db:title>[virtual protected] bool QModbusServer::readData(QModbusDataUnit *<db:emphasis>newData</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>readData</db:methodname>
<db:methodparam>
<db:type>QModbusDataUnit *</db:type>
<db:parameter>newData</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool readData(QModbusDataUnit *newData) const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads the values in the register range given by <db:code role="parameter">newData</db:code> and writes the data back to <db:code role="parameter">newData</db:code>. Returns <db:code>true</db:code> on success or <db:code>false</db:code> if <db:code role="parameter">newData</db:code> is <db:code>0</db:code>, the <db:code role="parameter">newData</db:code> range is outside of the map range or the registerType() does not exist.</db:para>
<db:note>
<db:para>Sub-classes that implement reading from a different backing store then default one, also need to implement <db:link xlink:href="qmodbusserver.xml#setMap">setMap</db:link>() and <db:link xlink:href="qmodbusserver.xml#writeData">writeData</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmodbusserver.xml#setMap">setMap</db:link>()</db:member>
<db:member><db:link xlink:href="qmodbusserver.xml#writeData">writeData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="serverAddress">
<db:title>int QModbusServer::serverAddress() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>serverAddress</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int serverAddress() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the address of this Modbus server instance.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmodbusserver.xml#setServerAddress">setServerAddress</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setData">
<db:title>bool QModbusServer::setData(const QModbusDataUnit &amp;<db:emphasis>newData</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>setData</db:methodname>
<db:methodparam>
<db:type>const QModbusDataUnit &amp;</db:type>
<db:parameter>newData</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setData(const QModbusDataUnit &amp;newData)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes <db:code role="parameter">newData</db:code> to the Modbus server map. Returns <db:code>false</db:code> if the <db:code role="parameter">newData</db:code> range is outside of the map range.</db:para>
<db:para>If the call was successful the <db:link xlink:href="qmodbusserver.xml#dataWritten">dataWritten</db:link>() signal is emitted. Note that the signal is not emitted when the addressed register has not changed. This may happen when <db:code role="parameter">newData</db:code> contains exactly the same values as the register already. Nevertheless this function returns <db:code>true</db:code> in such cases.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmodbusserver.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setData-1">
<db:title>bool QModbusServer::setData(QModbusDataUnit::RegisterType <db:emphasis>table</db:emphasis>, quint16 <db:emphasis>address</db:emphasis>, quint16 <db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>setData</db:methodname>
<db:methodparam>
<db:type>QModbusDataUnit::RegisterType</db:type>
<db:parameter>table</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setData(QModbusDataUnit::RegisterType table, quint16 address, quint16 data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes data to the Modbus server. A Modbus server has four tables (<db:code role="parameter">table</db:code>) and each have a unique <db:code role="parameter">address</db:code> field, which is used to write <db:code role="parameter">data</db:code> to the desired field. Returns <db:code>false</db:code> if address outside of the map range.</db:para>
<db:para>If the call was successful the <db:link xlink:href="qmodbusserver.xml#dataWritten">dataWritten</db:link>() signal is emitted. Note that the signal is not emitted when <db:code role="parameter">data</db:code> has not changed. Nevertheless this function returns <db:code>true</db:code> in such cases.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmodbusdataunit.xml#RegisterType-enum">QModbusDataUnit::RegisterType</db:link></db:member>
<db:member><db:link xlink:href="qmodbusserver.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qmodbusserver.xml#dataWritten">dataWritten</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMap">
<db:title>[virtual] bool QModbusServer::setMap(const QModbusDataUnitMap &amp;<db:emphasis>map</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>setMap</db:methodname>
<db:methodparam>
<db:type>const QModbusDataUnitMap &amp;</db:type>
<db:parameter>map</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setMap(const QModbusDataUnitMap &amp;map)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the registered map structure for requests from other ModBus clients to <db:code role="parameter">map</db:code>. The register values are initialized with zero. Returns <db:code>true</db:code> on success; otherwise <db:code>false</db:code>.</db:para>
<db:para>If this function is not called before connecting, a default register with zero entries is setup.</db:para>
<db:note>
<db:para>Calling this function discards any register value that was previously set.</db:para>
</db:note>
</db:section>
<db:section xml:id="setServerAddress">
<db:title>void QModbusServer::setServerAddress(int <db:emphasis>serverAddress</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setServerAddress</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>serverAddress</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setServerAddress(int serverAddress)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the address for this Modbus server instance to <db:code role="parameter">serverAddress</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmodbusserver.xml#serverAddress">serverAddress</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setValue">
<db:title>[virtual] bool QModbusServer::setValue(int <db:emphasis>option</db:emphasis>, const QVariant &amp;<db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>setValue</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setValue(int option, const QVariant &amp;newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the <db:code role="parameter">newValue</db:code> for <db:code role="parameter">option</db:code> and returns <db:code>true</db:code> on success; <db:code>false</db:code> otherwise.</db:para>
<db:note>
<db:para>If the option's associated type is <db:code>quint8</db:code> or <db:code>quint16</db:code> and the type of <db:code role="parameter">newValue</db:code> is larger, the data will be truncated or conversation will fail.</db:para>
</db:note>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Key</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::DiagnosticRegister</db:link></db:para>
</db:td>
<db:td>
<db:para>Sets the diagnostic register of the server in a device specific encoding to <db:code role="parameter">newValue</db:code>. The default value preset is <db:code>0x0000</db:code>. The bit values of the register need device specific documentation.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::ExceptionStatusOffset</db:link></db:para>
</db:td>
<db:td>
<db:para>Sets the exception status byte offset of the server to <db:code role="parameter">newValue</db:code> which is the absolute offset address in the coils (0x register). Modbus register table starting with <db:code>0x0000h</db:code>. The default value preset is <db:code>0x0000</db:code>, using the exception status coils similar to Modicon 984 CPUs (coils 1-8).</db:para>
<db:para>The function returns <db:code>true</db:code> if the coils register contains the 8 bits required for storing and retrieving the status coils, otherwise <db:code>false</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::DeviceBusy</db:link></db:para>
</db:td>
<db:td>
<db:para>Sets a flag that signals that the server is engaged in processing a long-duration program command. Valid values are <db:code>0x0000</db:code> (not busy) and <db:code>0xffff</db:code> (busy). The default value preset is <db:code>0x0000</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::AsciiInputDelimiter</db:link></db:para>
</db:td>
<db:td>
<db:para>The <db:code role="parameter">newValue</db:code> becomes the end of message delimiter for future Modbus ASCII messages. The default value preset is <db:code>\n</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::ListenOnlyMode</db:link></db:para>
</db:td>
<db:td>
<db:para>Ss the server's listen only state to <db:code role="parameter">newValue</db:code>. If listen only mode is set to <db:code>true</db:code>, messages are monitored but no response will be sent. The default value preset is <db:code>false</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::ServerIdentifier</db:link></db:para>
</db:td>
<db:td>
<db:para>Sets the server's manufacturer identifier to <db:code role="parameter">newValue</db:code>. Possible values are in the range of <db:code>0x00</db:code> to 0xff. The default value preset is <db:code>0x0a</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::RunIndicatorStatus</db:link></db:para>
</db:td>
<db:td>
<db:para>Sets the servers' run indicator status to <db:code role="parameter">newValue</db:code>. This data is used as addendum by the <db:link xlink:href="qmodbuspdu.xml#FunctionCode-enum">QModbusPdu::ReportServerId</db:link> function code. Valid values are <db:code>0x00</db:code> (OFF) and <db:code>0xff</db:code> (ON). The default value preset is <db:code>0xff</db:code> (ON).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::AdditionalData</db:link></db:para>
</db:td>
<db:td>
<db:para>Sets the server's additional data to <db:code role="parameter">newValue</db:code>. This data is used as addendum by the <db:link xlink:href="qmodbuspdu.xml#FunctionCode-enum">QModbusPdu::ReportServerId</db:link> function code. The maximum data size cannot exceed 249 bytes to match response message size restrictions. The default value preset is <db:code>Qt Modbus Server</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::DeviceIdentification</db:link></db:para>
</db:td>
<db:td>
<db:para>Sets the server's physical and functional description. By default there is no additional device identification data set.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::UserOption</db:link></db:para>
</db:td>
<db:td>
<db:para>Sets the value of a user option to <db:code role="parameter">newValue</db:code>.</db:para>
<db:note>
<db:para>For user options, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting values.</db:para>
</db:note>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmodbusserver.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value">
<db:title>[virtual] QVariant QModbusServer::value(int <db:emphasis>option</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant value(int option) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the value for <db:code role="parameter">option</db:code> or an invalid <db:code>QVariant</db:code> if the option is not set.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Option</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::DiagnosticRegister</db:link></db:para>
</db:td>
<db:td>
<db:para>Returns the diagnostic register value of the server. The diagnostic register contains device specific contents where each bit has a specific meaning.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::ExceptionStatusOffset</db:link></db:para>
</db:td>
<db:td>
<db:para>Returns the offset address of the exception status byte location in the coils register.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::DeviceBusy</db:link></db:para>
</db:td>
<db:td>
<db:para>Returns a flag that signals if the server is engaged in processing a long-duration program command.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::AsciiInputDelimiter</db:link></db:para>
</db:td>
<db:td>
<db:para>Returns a end of message delimiter of Modbus ASCII messages.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::ListenOnlyMode</db:link></db:para>
</db:td>
<db:td>
<db:para>Returns the server's listen only state. Messages are monitored but no response will be sent.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::ServerIdentifier</db:link></db:para>
</db:td>
<db:td>
<db:para>Returns the server manufacturer's identifier code. This can be an arbitrary value in the range of <db:code>0x00</db:code> to 0xff.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::RunIndicatorStatus</db:link></db:para>
</db:td>
<db:td>
<db:para>Returns the server's run indicator status. This data is used as addendum by the <db:link xlink:href="qmodbuspdu.xml#FunctionCode-enum">QModbusPdu::ReportServerId</db:link> function code.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::AdditionalData</db:link></db:para>
</db:td>
<db:td>
<db:para>Returns the server's additional data. This data is used as addendum by the <db:link xlink:href="qmodbuspdu.xml#FunctionCode-enum">QModbusPdu::ReportServerId</db:link> function code.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::DeviceIdentification</db:link></db:para>
</db:td>
<db:td>
<db:para>Returns the server's physical and functional description.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmodbusserver.xml#Option-enum">QModbusServer::UserOption</db:link></db:para>
</db:td>
<db:td>
<db:para>Returns the value of a user option.</db:para>
<db:note>
<db:para>For user options, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting values.</db:para>
</db:note>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmodbusserver.xml#setValue">setValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="writeData">
<db:title>[virtual protected] bool QModbusServer::writeData(const QModbusDataUnit &amp;<db:emphasis>newData</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>writeData</db:methodname>
<db:methodparam>
<db:type>const QModbusDataUnit &amp;</db:type>
<db:parameter>newData</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool writeData(const QModbusDataUnit &amp;newData)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes <db:code role="parameter">newData</db:code> to the Modbus server map. Returns <db:code>true</db:code> on success, or <db:code>false</db:code> if the <db:code role="parameter">newData</db:code> range is outside of the map range or the registerType() does not exist.</db:para>
<db:note>
<db:para>Sub-classes that implement writing to a different backing store then default one, also need to implement <db:link xlink:href="qmodbusserver.xml#setMap">setMap</db:link>() and <db:link xlink:href="qmodbusserver.xml#readData">readData</db:link>(). The <db:link xlink:href="qmodbusserver.xml#dataWritten">dataWritten</db:link>() signal needs to be emitted from within the functions implementation as well.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmodbusserver.xml#setMap">setMap</db:link>()</db:member>
<db:member><db:link xlink:href="qmodbusserver.xml#readData">readData</db:link>()</db:member>
<db:member><db:link xlink:href="qmodbusserver.xml#dataWritten">dataWritten</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
