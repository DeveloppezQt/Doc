<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QImage Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.4.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qimage.xml">QImage</db:link> class provides a hardware-independent image representation that allows direct access to the pixel data, and can be used as a paint device.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QImage</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Gui)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qpaintdevice.xml" xlink:role="class">QPaintDevice</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QImage is part of <db:simplelist><db:member><db:link xlink:href="painting.xml">Painting Classes</db:link></db:member><db:member>shared</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Qt provides four classes for handling image data: <db:link xlink:href="qimage.xml">QImage</db:link>, <db:link xlink:href="qpixmap.xml">QPixmap</db:link>, <db:link xlink:href="qbitmap.xml">QBitmap</db:link> and <db:link xlink:href="qpicture.xml">QPicture</db:link>. <db:link xlink:href="qimage.xml">QImage</db:link> is designed and optimized for I/O, and for direct pixel access and manipulation, while <db:link xlink:href="qpixmap.xml">QPixmap</db:link> is designed and optimized for showing images on screen. <db:link xlink:href="qbitmap.xml">QBitmap</db:link> is only a convenience class that inherits <db:link xlink:href="qpixmap.xml">QPixmap</db:link>, ensuring a depth of 1. Finally, the <db:link xlink:href="qpicture.xml">QPicture</db:link> class is a paint device that records and replays <db:link xlink:href="qpainter.xml">QPainter</db:link> commands.</db:para>
<db:para>Because <db:link xlink:href="qimage.xml">QImage</db:link> is a <db:link xlink:href="qpaintdevice.xml">QPaintDevice</db:link> subclass, <db:link xlink:href="qpainter.xml">QPainter</db:link> can be used to draw directly onto images. When using <db:link xlink:href="qpainter.xml">QPainter</db:link> on a <db:link xlink:href="qimage.xml">QImage</db:link>, the painting can be performed in another thread than the current GUI thread.</db:para>
<db:para>The <db:link xlink:href="qimage.xml">QImage</db:link> class supports several image formats described by the <db:link xlink:href="qimage.xml#Format-enum">Format</db:link> enum. These include monochrome, 8-bit, 32-bit and alpha-blended images which are available in all versions of Qt 4.x.</db:para>
<db:para><db:link xlink:href="qimage.xml">QImage</db:link> provides a collection of functions that can be used to obtain a variety of information about the image. There are also several functions that enables transformation of the image.</db:para>
<db:para><db:link xlink:href="qimage.xml">QImage</db:link> objects can be passed around by value since the <db:link xlink:href="qimage.xml">QImage</db:link> class uses <db:link xlink:href="implicit-sharing.xml">implicit data sharing</db:link>. <db:link xlink:href="qimage.xml">QImage</db:link> objects can also be streamed and compared.</db:para>
<db:note>
<db:para>If you would like to load <db:link xlink:href="qimage.xml">QImage</db:link> objects in a static build of Qt, refer to the <db:link xlink:href="plugins-howto.xml">Plugin HowTo</db:link>.</db:para>
</db:note>
<db:warning>
<db:para>Painting on a <db:link xlink:href="qimage.xml">QImage</db:link> with the format <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_Indexed8</db:link> is not supported.</db:para>
</db:warning>
<db:section xml:id="reading-and-writing-image-files">
<db:title>Reading and Writing Image Files</db:title>
<db:para><db:link xlink:href="qimage.xml">QImage</db:link> provides several ways of loading an image file: The file can be loaded when constructing the <db:link xlink:href="qimage.xml">QImage</db:link> object, or by using the <db:link xlink:href="qimage.xml#load">load</db:link>() or <db:link xlink:href="qimage.xml#loadFromData">loadFromData</db:link>() functions later on. <db:link xlink:href="qimage.xml">QImage</db:link> also provides the static <db:link xlink:href="qimage.xml#fromData">fromData</db:link>() function, constructing a <db:link xlink:href="qimage.xml">QImage</db:link> from the given data. When loading an image, the file name can either refer to an actual file on disk or to one of the application's embedded resources. See <db:link xlink:href="resources.xml">The Qt Resource System</db:link> overview for details on how to embed images and other resource files in the application's executable.</db:para>
<db:para>Simply call the <db:link xlink:href="qimage.xml#save">save</db:link>() function to save a <db:link xlink:href="qimage.xml">QImage</db:link> object.</db:para>
<db:para>The complete list of supported file formats are available through the <db:link xlink:href="qimagereader.xml#supportedImageFormats">QImageReader::supportedImageFormats</db:link>() and <db:link xlink:href="qimagewriter.xml#supportedImageFormats">QImageWriter::supportedImageFormats</db:link>() functions. New file formats can be added as plugins. By default, Qt supports the following formats:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Format</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
<db:th>
<db:para>Qt's support</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>BMP</db:para>
</db:td>
<db:td>
<db:para>Windows Bitmap</db:para>
</db:td>
<db:td>
<db:para>Read/write</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>GIF</db:para>
</db:td>
<db:td>
<db:para>Graphic Interchange Format (optional)</db:para>
</db:td>
<db:td>
<db:para>Read</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>JPG</db:para>
</db:td>
<db:td>
<db:para>Joint Photographic Experts Group</db:para>
</db:td>
<db:td>
<db:para>Read/write</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>JPEG</db:para>
</db:td>
<db:td>
<db:para>Joint Photographic Experts Group</db:para>
</db:td>
<db:td>
<db:para>Read/write</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>PNG</db:para>
</db:td>
<db:td>
<db:para>Portable Network Graphics</db:para>
</db:td>
<db:td>
<db:para>Read/write</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>PBM</db:para>
</db:td>
<db:td>
<db:para>Portable Bitmap</db:para>
</db:td>
<db:td>
<db:para>Read</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>PGM</db:para>
</db:td>
<db:td>
<db:para>Portable Graymap</db:para>
</db:td>
<db:td>
<db:para>Read</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>PPM</db:para>
</db:td>
<db:td>
<db:para>Portable Pixmap</db:para>
</db:td>
<db:td>
<db:para>Read/write</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>XBM</db:para>
</db:td>
<db:td>
<db:para>X11 Bitmap</db:para>
</db:td>
<db:td>
<db:para>Read/write</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>XPM</db:para>
</db:td>
<db:td>
<db:para>X11 Pixmap</db:para>
</db:td>
<db:td>
<db:para>Read/write</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="image-information">
<db:title>Image Information</db:title>
<db:para><db:link xlink:href="qimage.xml">QImage</db:link> provides a collection of functions that can be used to obtain a variety of information about the image:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
</db:th>
<db:th>
<db:para>Available Functions</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Geometry</db:para>
</db:td>
<db:td>
<db:para>The <db:link xlink:href="qimage.xml#size">size</db:link>(), <db:link xlink:href="qimage.xml#width">width</db:link>(), <db:link xlink:href="qimage.xml#height">height</db:link>(), <db:link xlink:href="qimage.xml#dotsPerMeterX">dotsPerMeterX</db:link>(), and <db:link xlink:href="qimage.xml#dotsPerMeterY">dotsPerMeterY</db:link>() functions provide information about the image size and aspect ratio.</db:para>
<db:para>The <db:link xlink:href="qimage.xml#rect">rect</db:link>() function returns the image's enclosing rectangle. The <db:link xlink:href="qimage.xml#valid">valid</db:link>() function tells if a given pair of coordinates is within this rectangle. The <db:link xlink:href="qimage.xml#offset">offset</db:link>() function returns the number of pixels by which the image is intended to be offset by when positioned relative to other images, which also can be manipulated using the <db:link xlink:href="qimage.xml#setOffset">setOffset</db:link>() function.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Colors</db:para>
</db:td>
<db:td>
<db:para>The color of a pixel can be retrieved by passing its coordinates to the <db:link xlink:href="qimage.xml#pixel">pixel</db:link>() function. The <db:link xlink:href="qimage.xml#pixel">pixel</db:link>() function returns the color as a <db:link xlink:href="qcolor.xml#QRgb-typedef">QRgb</db:link> value independent of the image's format.</db:para>
<db:para>In case of monochrome and 8-bit images, the <db:link xlink:href="qimage.xml#colorCount">colorCount</db:link>() and <db:link xlink:href="qimage.xml#colorTable">colorTable</db:link>() functions provide information about the color components used to store the image data: The <db:link xlink:href="qimage.xml#colorTable">colorTable</db:link>() function returns the image's entire color table. To obtain a single entry, use the <db:link xlink:href="qimage.xml#pixelIndex">pixelIndex</db:link>() function to retrieve the pixel index for a given pair of coordinates, then use the <db:link xlink:href="qimage.xml#color">color</db:link>() function to retrieve the color. Note that if you create an 8-bit image manually, you have to set a valid color table on the image as well.</db:para>
<db:para>The <db:link xlink:href="qimage.xml#hasAlphaChannel">hasAlphaChannel</db:link>() function tells if the image's format respects the alpha channel, or not. The <db:link xlink:href="qimage.xml#allGray">allGray</db:link>() and <db:link xlink:href="qimage.xml#isGrayscale">isGrayscale</db:link>() functions tell whether an image's colors are all shades of gray.</db:para>
<db:para>See also the <db:link xlink:href="qimage.xml#pixel-manipulation">Pixel Manipulation</db:link> and <db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link> sections.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Text</db:para>
</db:td>
<db:td>
<db:para>The <db:link xlink:href="qimage.xml#text">text</db:link>() function returns the image text associated with the given text key. An image's text keys can be retrieved using the <db:link xlink:href="qimage.xml#textKeys">textKeys</db:link>() function. Use the <db:link xlink:href="qimage.xml#setText">setText</db:link>() function to alter an image's text.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Low-level information</db:para>
</db:td>
<db:td>
<db:para>The <db:link xlink:href="qimage.xml#depth">depth</db:link>() function returns the depth of the image. The supported depths are 1 (monochrome), 8, 16, 24 and 32 bits. The <db:link xlink:href="qimage.xml#bitPlaneCount">bitPlaneCount</db:link>() function tells how many of those bits that are used. For more information see the <db:link xlink:href="qimage.xml#image-formats">Image Formats</db:link> section.</db:para>
<db:para>The <db:link xlink:href="qimage.xml#format">format</db:link>(), <db:link xlink:href="qimage.xml#bytesPerLine">bytesPerLine</db:link>(), and <db:link xlink:href="qimage.xml#sizeInBytes">sizeInBytes</db:link>() functions provide low-level information about the data stored in the image.</db:para>
<db:para>The <db:link xlink:href="qimage.xml#cacheKey">cacheKey</db:link>() function returns a number that uniquely identifies the contents of this <db:link xlink:href="qimage.xml">QImage</db:link> object.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="pixel-manipulation">
<db:title>Pixel Manipulation</db:title>
<db:para>The functions used to manipulate an image's pixels depend on the image format. The reason is that monochrome and 8-bit images are index-based and use a color lookup table, while 32-bit images store ARGB values directly. For more information on image formats, see the <db:link xlink:href="qimage.xml#image-formats">Image Formats</db:link> section.</db:para>
<db:para>In case of a 32-bit image, the <db:link xlink:href="qimage.xml#setPixel">setPixel</db:link>() function can be used to alter the color of the pixel at the given coordinates to any other color specified as an ARGB quadruplet. To make a suitable <db:link xlink:href="qcolor.xml#QRgb-typedef">QRgb</db:link> value, use the <db:link xlink:href="qcolor.xml#qRgb">qRgb</db:link>() (adding a default alpha component to the given RGB values, i.e. creating an opaque color) or <db:link xlink:href="qcolor.xml#qRgba">qRgba</db:link>() function. For example:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th colspan="2">
<db:para>32-bit</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/qimage-32bit_scaled.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:programlisting language="cpp">QImage image(3, 3, QImage::Format_RGB32);
QRgb value;

value = qRgb(189, 149, 39); // 0xffbd9527
image.setPixel(1, 1, value);

value = qRgb(122, 163, 39); // 0xff7aa327
image.setPixel(0, 1, value);
image.setPixel(1, 0, value);

value = qRgb(237, 187, 51); // 0xffedba31
image.setPixel(2, 1, value);
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>In case of a 8-bit and monchrome images, the pixel value is only an index from the image's color table. So the <db:link xlink:href="qimage.xml#setPixel">setPixel</db:link>() function can only be used to alter the color of the pixel at the given coordinates to a predefined color from the image's color table, i.e. it can only change the pixel's index value. To alter or add a color to an image's color table, use the <db:link xlink:href="qimage.xml#setColor">setColor</db:link>() function.</db:para>
<db:para>An entry in the color table is an ARGB quadruplet encoded as an <db:link xlink:href="qcolor.xml#QRgb-typedef">QRgb</db:link> value. Use the <db:link xlink:href="qcolor.xml#qRgb">qRgb</db:link>() and <db:link xlink:href="qcolor.xml#qRgba">qRgba</db:link>() functions to make a suitable <db:link xlink:href="qcolor.xml#QRgb-typedef">QRgb</db:link> value for use with the <db:link xlink:href="qimage.xml#setColor">setColor</db:link>() function. For example:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th colspan="2">
<db:para>8-bit</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/qimage-8bit_scaled.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:programlisting language="cpp">QImage image(3, 3, QImage::Format_Indexed8);
QRgb value;

value = qRgb(122, 163, 39); // 0xff7aa327
image.setColor(0, value);

value = qRgb(237, 187, 51); // 0xffedba31
image.setColor(1, value);

value = qRgb(189, 149, 39); // 0xffbd9527
image.setColor(2, value);

image.setPixel(0, 1, 0);
image.setPixel(1, 0, 0);
image.setPixel(1, 1, 2);
image.setPixel(2, 1, 1);
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>For images with more than 8-bit per color-channel. The methods <db:link xlink:href="qimage.xml#setPixelColor">setPixelColor</db:link>() and <db:link xlink:href="qimage.xml#pixelColor">pixelColor</db:link>() can be used to set and get with <db:link xlink:href="qcolor.xml">QColor</db:link> values.</db:para>
<db:para><db:link xlink:href="qimage.xml">QImage</db:link> also provide the <db:link xlink:href="qimage.xml#scanLine">scanLine</db:link>() function which returns a pointer to the pixel data at the scanline with the given index, and the <db:link xlink:href="qimage.xml#bits">bits</db:link>() function which returns a pointer to the first pixel data (this is equivalent to <db:code>scanLine(0)</db:code>).</db:para>
</db:section>
<db:section xml:id="image-formats">
<db:title>Image Formats</db:title>
<db:para>Each pixel stored in a <db:link xlink:href="qimage.xml">QImage</db:link> is represented by an integer. The size of the integer varies depending on the format. <db:link xlink:href="qimage.xml">QImage</db:link> supports several image formats described by the <db:link xlink:href="qimage.xml#Format-enum">Format</db:link> enum.</db:para>
<db:para>Monochrome images are stored using 1-bit indexes into a color table with at most two colors. There are two different types of monochrome images: big endian (MSB first) or little endian (LSB first) bit order.</db:para>
<db:para>8-bit images are stored using 8-bit indexes into a color table, i.e. they have a single byte per pixel. The color table is a <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qcolor.xml#QRgb-typedef">QRgb</db:link>&gt;, and the <db:link xlink:href="qcolor.xml#QRgb-typedef">QRgb</db:link> typedef is equivalent to an unsigned int containing an ARGB quadruplet on the format 0xAARRGGBB.</db:para>
<db:para>32-bit images have no color table; instead, each pixel contains an <db:link xlink:href="qcolor.xml#QRgb-typedef">QRgb</db:link> value. There are three different types of 32-bit images storing RGB (i.e. 0xffRRGGBB), ARGB and premultiplied ARGB values respectively. In the premultiplied format the red, green, and blue channels are multiplied by the alpha component divided by 255.</db:para>
<db:para>An image's format can be retrieved using the <db:link xlink:href="qimage.xml#format">format</db:link>() function. Use the <db:link xlink:href="qimage.xml#convertToFormat">convertToFormat</db:link>() functions to convert an image into another format. The <db:link xlink:href="qimage.xml#allGray">allGray</db:link>() and <db:link xlink:href="qimage.xml#isGrayscale">isGrayscale</db:link>() functions tell whether a color image can safely be converted to a grayscale image.</db:para>
</db:section>
<db:section xml:id="image-transformations">
<db:title>Image Transformations</db:title>
<db:para><db:link xlink:href="qimage.xml">QImage</db:link> supports a number of functions for creating a new image that is a transformed version of the original: The <db:link xlink:href="qimage.xml#createAlphaMask">createAlphaMask</db:link>() function builds and returns a 1-bpp mask from the alpha buffer in this image, and the <db:link xlink:href="qimage.xml#createHeuristicMask">createHeuristicMask</db:link>() function creates and returns a 1-bpp heuristic mask for this image. The latter function works by selecting a color from one of the corners, then chipping away pixels of that color starting at all the edges.</db:para>
<db:para>The <db:link xlink:href="qimage.xml#mirrored">mirrored</db:link>() function returns a mirror of the image in the desired direction, the <db:link xlink:href="qimage.xml#scaled">scaled</db:link>() returns a copy of the image scaled to a rectangle of the desired measures, and the <db:link xlink:href="qimage.xml#rgbSwapped">rgbSwapped</db:link>() function constructs a BGR image from a RGB image.</db:para>
<db:para>The <db:link xlink:href="qimage.xml#scaledToWidth">scaledToWidth</db:link>() and <db:link xlink:href="qimage.xml#scaledToHeight">scaledToHeight</db:link>() functions return scaled copies of the image.</db:para>
<db:para>The <db:link xlink:href="qimage.xml#transformed">transformed</db:link>() function returns a copy of the image that is transformed with the given transformation matrix and transformation mode: Internally, the transformation matrix is adjusted to compensate for unwanted translation, i.e. <db:link xlink:href="qimage.xml#transformed">transformed</db:link>() returns the smallest image containing all transformed points of the original image. The static <db:link xlink:href="qimage.xml#trueMatrix">trueMatrix</db:link>() function returns the actual matrix used for transforming the image.</db:para>
<db:para>There are also functions for changing attributes of an image in-place:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Function</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qimage.xml#setDotsPerMeterX">setDotsPerMeterX</db:link>()</db:para>
</db:td>
<db:td>
<db:para>Defines the aspect ratio by setting the number of pixels that fit horizontally in a physical meter.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qimage.xml#setDotsPerMeterY">setDotsPerMeterY</db:link>()</db:para>
</db:td>
<db:td>
<db:para>Defines the aspect ratio by setting the number of pixels that fit vertically in a physical meter.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qimage.xml#fill">fill</db:link>()</db:para>
</db:td>
<db:td>
<db:para>Fills the entire image with the given pixel value.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qimage.xml#invertPixels">invertPixels</db:link>()</db:para>
</db:td>
<db:td>
<db:para>Inverts all pixel values in the image using the given <db:link xlink:href="qimage.xml#InvertMode-enum">InvertMode</db:link> value.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qimage.xml#setColorTable">setColorTable</db:link>()</db:para>
</db:td>
<db:td>
<db:para>Sets the color table used to translate color indexes. Only monochrome and 8-bit formats.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qimage.xml#setColorCount">setColorCount</db:link>()</db:para>
</db:td>
<db:td>
<db:para>Resizes the color table. Only monochrome and 8-bit formats.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimagereader.xml">QImageReader</db:link></db:member>
<db:member><db:link xlink:href="qimagewriter.xml">QImageWriter</db:link></db:member>
<db:member><db:link xlink:href="qpixmap.xml">QPixmap</db:link></db:member>
<db:member><db:link xlink:href="qsvgrenderer.xml">QSvgRenderer</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-painting-imagecomposition-example.xml">Image Composition Example</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-imageviewer-example.xml">Image Viewer Example</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-scribble-example.xml">Scribble Example</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-itemviews-pixelator-example.xml">Pixelator Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Format-enum">
<db:title>enum QImage::Format</db:title>
<db:enumsynopsis>
<db:enumname>Format</db:enumname>
<db:enumitem>
<db:enumidentifier>Format_Invalid</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_Mono</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_MonoLSB</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_Indexed8</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGB32</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_ARGB32</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_ARGB32_Premultiplied</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGB16</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_ARGB8565_Premultiplied</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGB666</db:enumidentifier>
<db:enumvalue>9</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_ARGB6666_Premultiplied</db:enumidentifier>
<db:enumvalue>10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGB555</db:enumidentifier>
<db:enumvalue>11</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_ARGB8555_Premultiplied</db:enumidentifier>
<db:enumvalue>12</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGB888</db:enumidentifier>
<db:enumvalue>13</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGB444</db:enumidentifier>
<db:enumvalue>14</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_ARGB4444_Premultiplied</db:enumidentifier>
<db:enumvalue>15</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGBX8888</db:enumidentifier>
<db:enumvalue>16</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGBA8888</db:enumidentifier>
<db:enumvalue>17</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGBA8888_Premultiplied</db:enumidentifier>
<db:enumvalue>18</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_BGR30</db:enumidentifier>
<db:enumvalue>19</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_A2BGR30_Premultiplied</db:enumidentifier>
<db:enumvalue>20</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGB30</db:enumidentifier>
<db:enumvalue>21</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_A2RGB30_Premultiplied</db:enumidentifier>
<db:enumvalue>22</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_Alpha8</db:enumidentifier>
<db:enumvalue>23</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_Grayscale8</db:enumidentifier>
<db:enumvalue>24</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGBX64</db:enumidentifier>
<db:enumvalue>25</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGBA64</db:enumidentifier>
<db:enumvalue>26</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGBA64_Premultiplied</db:enumidentifier>
<db:enumvalue>27</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_Grayscale16</db:enumidentifier>
<db:enumvalue>28</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_BGR888</db:enumidentifier>
<db:enumvalue>29</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGBX16FPx4</db:enumidentifier>
<db:enumvalue>30</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGBA16FPx4</db:enumidentifier>
<db:enumvalue>31</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGBA16FPx4_Premultiplied</db:enumidentifier>
<db:enumvalue>32</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGBX32FPx4</db:enumidentifier>
<db:enumvalue>33</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGBA32FPx4</db:enumidentifier>
<db:enumvalue>34</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Format_RGBA32FPx4_Premultiplied</db:enumidentifier>
<db:enumvalue>35</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>The following image formats are available in Qt. See the notes after the table.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_Invalid</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The image is invalid.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_Mono</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The image is stored using 1-bit per pixel. Bytes are packed with the most significant bit (MSB) first.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_MonoLSB</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The image is stored using 1-bit per pixel. Bytes are packed with the less significant bit (LSB) first.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_Indexed8</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The image is stored using 8-bit indexes into a colormap.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGB32</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The image is stored using a 32-bit RGB format (0xffRRGGBB).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_ARGB32</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The image is stored using a 32-bit ARGB format (0xAARRGGBB).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_ARGB32_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The image is stored using a premultiplied 32-bit ARGB format (0xAARRGGBB), i.e. the red, green, and blue channels are multiplied by the alpha component divided by 255. (If RR, GG, or BB has a higher value than the alpha channel, the results are undefined.) Certain operations (such as image composition using alpha blending) are faster using premultiplied ARGB32 than with plain ARGB32.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGB16</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>The image is stored using a 16-bit RGB format (5-6-5).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_ARGB8565_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>The image is stored using a premultiplied 24-bit ARGB format (8-5-6-5).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGB666</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>The image is stored using a 24-bit RGB format (6-6-6). The unused most significant bits is always zero.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_ARGB6666_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>The image is stored using a premultiplied 24-bit ARGB format (6-6-6-6).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGB555</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>The image is stored using a 16-bit RGB format (5-5-5). The unused most significant bit is always zero.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_ARGB8555_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>The image is stored using a premultiplied 24-bit ARGB format (8-5-5-5).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGB888</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>The image is stored using a 24-bit RGB format (8-8-8).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGB444</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>The image is stored using a 16-bit RGB format (4-4-4). The unused bits are always zero.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_ARGB4444_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>15</db:code></db:td>
<db:td>
<db:para>The image is stored using a premultiplied 16-bit ARGB format (4-4-4-4).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGBX8888</db:code></db:para>
</db:td>
<db:td><db:code>16</db:code></db:td>
<db:td>
<db:para>The image is stored using a 32-bit byte-ordered RGB(x) format (8-8-8-8). This is the same as the Format_RGBA8888 except alpha must always be 255. (added in Qt 5.2)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGBA8888</db:code></db:para>
</db:td>
<db:td><db:code>17</db:code></db:td>
<db:td>
<db:para>The image is stored using a 32-bit byte-ordered RGBA format (8-8-8-8). Unlike ARGB32 this is a byte-ordered format, which means the 32bit encoding differs between big endian and little endian architectures, being respectively (0xRRGGBBAA) and (0xAABBGGRR). The order of the colors is the same on any architecture if read as bytes 0xRR,0xGG,0xBB,0xAA. (added in Qt 5.2)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGBA8888_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>18</db:code></db:td>
<db:td>
<db:para>The image is stored using a premultiplied 32-bit byte-ordered RGBA format (8-8-8-8). (added in Qt 5.2)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_BGR30</db:code></db:para>
</db:td>
<db:td><db:code>19</db:code></db:td>
<db:td>
<db:para>The image is stored using a 32-bit BGR format (x-10-10-10). (added in Qt 5.4)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_A2BGR30_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>20</db:code></db:td>
<db:td>
<db:para>The image is stored using a 32-bit premultiplied ABGR format (2-10-10-10). (added in Qt 5.4)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGB30</db:code></db:para>
</db:td>
<db:td><db:code>21</db:code></db:td>
<db:td>
<db:para>The image is stored using a 32-bit RGB format (x-10-10-10). (added in Qt 5.4)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_A2RGB30_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>22</db:code></db:td>
<db:td>
<db:para>The image is stored using a 32-bit premultiplied ARGB format (2-10-10-10). (added in Qt 5.4)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_Alpha8</db:code></db:para>
</db:td>
<db:td><db:code>23</db:code></db:td>
<db:td>
<db:para>The image is stored using an 8-bit alpha only format. (added in Qt 5.5)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_Grayscale8</db:code></db:para>
</db:td>
<db:td><db:code>24</db:code></db:td>
<db:td>
<db:para>The image is stored using an 8-bit grayscale format. (added in Qt 5.5)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_Grayscale16</db:code></db:para>
</db:td>
<db:td><db:code>28</db:code></db:td>
<db:td>
<db:para>The image is stored using an 16-bit grayscale format. (added in Qt 5.13)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGBX64</db:code></db:para>
</db:td>
<db:td><db:code>25</db:code></db:td>
<db:td>
<db:para>The image is stored using a 64-bit halfword-ordered RGB(x) format (16-16-16-16). This is the same as the Format_RGBA64 except alpha must always be 65535. (added in Qt 5.12)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGBA64</db:code></db:para>
</db:td>
<db:td><db:code>26</db:code></db:td>
<db:td>
<db:para>The image is stored using a 64-bit halfword-ordered RGBA format (16-16-16-16). (added in Qt 5.12)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGBA64_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>27</db:code></db:td>
<db:td>
<db:para>The image is stored using a premultiplied 64-bit halfword-ordered RGBA format (16-16-16-16). (added in Qt 5.12)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_BGR888</db:code></db:para>
</db:td>
<db:td><db:code>29</db:code></db:td>
<db:td>
<db:para>The image is stored using a 24-bit BGR format. (added in Qt 5.14)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGBX16FPx4</db:code></db:para>
</db:td>
<db:td><db:code>30</db:code></db:td>
<db:td>
<db:para>The image is stored using a 4 16-bit halfword floating point RGBx format (16FP-16FP-16FP-16FP). This is the same as the Format_RGBA16FPx4 except alpha must always be 1.0. (added in Qt 6.2)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGBA16FPx4</db:code></db:para>
</db:td>
<db:td><db:code>31</db:code></db:td>
<db:td>
<db:para>The image is stored using a 4 16-bit halfword floating point RGBA format (16FP-16FP-16FP-16FP). (added in Qt 6.2)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGBA16FPx4_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>32</db:code></db:td>
<db:td>
<db:para>The image is stored using a premultiplied 4 16-bit halfword floating point RGBA format (16FP-16FP-16FP-16FP). (added in Qt 6.2)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGBX32FPx4</db:code></db:para>
</db:td>
<db:td><db:code>33</db:code></db:td>
<db:td>
<db:para>The image is stored using a 4 32-bit floating point RGBx format (32FP-32FP-32FP-32FP). This is the same as the Format_RGBA32FPx4 except alpha must always be 1.0. (added in Qt 6.2)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGBA32FPx4</db:code></db:para>
</db:td>
<db:td><db:code>34</db:code></db:td>
<db:td>
<db:para>The image is stored using a 4 32-bit floating point RGBA format (32FP-32FP-32FP-32FP). (added in Qt 6.2)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::Format_RGBA32FPx4_Premultiplied</db:code></db:para>
</db:td>
<db:td><db:code>35</db:code></db:td>
<db:td>
<db:para>The image is stored using a premultiplied 4 32-bit floating point RGBA format (32FP-32FP-32FP-32FP). (added in Qt 6.2)</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:note>
<db:para>Drawing into a <db:link xlink:href="qimage.xml">QImage</db:link> with QImage::Format_Indexed8 is not supported.</db:para>
</db:note>
<db:note>
<db:para>Avoid most rendering directly to most of these formats using <db:link xlink:href="qpainter.xml">QPainter</db:link>. Rendering is best optimized to the <db:code>Format_RGB32</db:code> and <db:code>Format_ARGB32_Premultiplied</db:code> formats, and secondarily for rendering to the <db:code>Format_RGB16</db:code>, <db:code>Format_RGBX8888</db:code>, <db:code>Format_RGBA8888_Premultiplied</db:code>, <db:code>Format_RGBX64</db:code> and <db:code>Format_RGBA64_Premultiplied</db:code> formats</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#format">format</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#convertToFormat">convertToFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="InvertMode-enum">
<db:title>enum QImage::InvertMode</db:title>
<db:enumsynopsis>
<db:enumname>InvertMode</db:enumname>
<db:enumitem>
<db:enumidentifier>InvertRgb</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>InvertRgba</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum type is used to describe how pixel values should be inverted in the <db:link xlink:href="qimage.xml#invertPixels">invertPixels</db:link>() function.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::InvertRgb</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Invert only the RGB values and leave the alpha channel unchanged.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qimage.xml">QImage</db:link></db:emphasis>::InvertRgba</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Invert all channels, including the alpha channel.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#invertPixels">invertPixels</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="convertToFormat-1">
<db:title>QImage QImage::convertToFormat(QImage::Format <db:emphasis>format</db:emphasis>, Qt::ImageConversionFlags <db:emphasis>flags</db:emphasis> = Qt::AutoColor) &amp;&amp;</db:title>
<db:bridgehead renderas="sect2" xml:id="convertToFormat">QImage QImage::convertToFormat(QImage::Format <db:emphasis>format</db:emphasis>, Qt::ImageConversionFlags <db:emphasis>flags</db:emphasis> = Qt::AutoColor) const &amp;</db:bridgehead>
<db:para>Returns a copy of the image in the given <db:code role="parameter">format</db:code>.</db:para>
<db:para>The specified image conversion <db:code role="parameter">flags</db:code> control how the image data is handled during the conversion process.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#convertTo">convertTo</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-formats">Image Formats</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="convertedTo-1">
<db:title>[since 6.0] QImage QImage::convertedTo(QImage::Format <db:emphasis>format</db:emphasis>, Qt::ImageConversionFlags <db:emphasis>flags</db:emphasis> = Qt::AutoColor) &amp;&amp;</db:title>
<db:bridgehead renderas="sect2" xml:id="convertedTo">[since 6.0] QImage QImage::convertedTo(QImage::Format <db:emphasis>format</db:emphasis>, Qt::ImageConversionFlags <db:emphasis>flags</db:emphasis> = Qt::AutoColor) const &amp;</db:bridgehead>
<db:para>Returns a copy of the image in the given <db:code role="parameter">format</db:code>.</db:para>
<db:para>The specified image conversion <db:code role="parameter">flags</db:code> control how the image data is handled during the conversion process.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#convertTo">convertTo</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-formats">Image Formats</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mirrored-1">
<db:title>QImage QImage::mirrored(bool <db:emphasis>horizontal</db:emphasis> = false, bool <db:emphasis>vertical</db:emphasis> = true) &amp;&amp;</db:title>
<db:bridgehead renderas="sect2" xml:id="mirrored">QImage QImage::mirrored(bool <db:emphasis>horizontal</db:emphasis> = false, bool <db:emphasis>vertical</db:emphasis> = true) const &amp;</db:bridgehead>
<db:para>Returns a mirror of the image, mirrored in the horizontal and/or the vertical direction depending on whether <db:code role="parameter">horizontal</db:code> and <db:code role="parameter">vertical</db:code> are set to true or false.</db:para>
<db:para>Note that the original image is not changed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#mirror">mirror</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rgbSwapped-1">
<db:title>QImage QImage::rgbSwapped() &amp;&amp;</db:title>
<db:bridgehead renderas="sect2" xml:id="rgbSwapped">QImage QImage::rgbSwapped() const &amp;</db:bridgehead>
<db:para>Returns a <db:link xlink:href="qimage.xml">QImage</db:link> in which the values of the red and blue components of all pixels have been swapped, effectively converting an RGB image to an BGR image.</db:para>
<db:para>The original <db:link xlink:href="qimage.xml">QImage</db:link> is not changed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#rgbSwap">rgbSwap</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QImage">
<db:title>QImage::QImage()</db:title>
<db:constructorsynopsis>
<db:methodname>QImage</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a null image.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#isNull">isNull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QImage-1">
<db:title>QImage::QImage(const QSize &amp;<db:emphasis>size</db:emphasis>, QImage::Format <db:emphasis>format</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QImage</db:methodname>
<db:methodparam>
<db:type>const QSize &amp;</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImage::Format</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage(const QSize &amp;size, QImage::Format format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an image with the given <db:code role="parameter">size</db:code> and <db:code role="parameter">format</db:code>.</db:para>
<db:para>A <db:link xlink:href="qimage.xml#isNull">null</db:link> image is returned if memory cannot be allocated.</db:para>
<db:warning>
<db:para>This will create a <db:link xlink:href="qimage.xml">QImage</db:link> with uninitialized data. Call <db:link xlink:href="qimage.xml#fill">fill</db:link>() to fill the image with an appropriate pixel value before drawing onto it with <db:link xlink:href="qpainter.xml">QPainter</db:link>.</db:para>
</db:warning>
</db:section>
<db:section xml:id="QImage-2">
<db:title>QImage::QImage(int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, QImage::Format <db:emphasis>format</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QImage</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>width</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>height</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImage::Format</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage(int width, int height, QImage::Format format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an image with the given <db:code role="parameter">width</db:code>, <db:code role="parameter">height</db:code> and <db:code role="parameter">format</db:code>.</db:para>
<db:para>A <db:link xlink:href="qimage.xml#isNull">null</db:link> image will be returned if memory cannot be allocated.</db:para>
<db:warning>
<db:para>This will create a <db:link xlink:href="qimage.xml">QImage</db:link> with uninitialized data. Call <db:link xlink:href="qimage.xml#fill">fill</db:link>() to fill the image with an appropriate pixel value before drawing onto it with <db:link xlink:href="qpainter.xml">QPainter</db:link>.</db:para>
</db:warning>
</db:section>
<db:section xml:id="QImage-3">
<db:title>QImage::QImage(uchar *<db:emphasis>data</db:emphasis>, int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, QImage::Format <db:emphasis>format</db:emphasis>, QImageCleanupFunction <db:emphasis>cleanupFunction</db:emphasis> = nullptr, void *<db:emphasis>cleanupInfo</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QImage</db:methodname>
<db:methodparam>
<db:type>uchar *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>width</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>height</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImage::Format</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImageCleanupFunction</db:type>
<db:parameter>cleanupFunction</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>cleanupInfo</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage(uchar *data, int width, int height, QImage::Format format, QImageCleanupFunction cleanupFunction, void *cleanupInfo)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an image with the given <db:code role="parameter">width</db:code>, <db:code role="parameter">height</db:code> and <db:code role="parameter">format</db:code>, that uses an existing memory buffer, <db:code role="parameter">data</db:code>. The <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code> must be specified in pixels, <db:code role="parameter">data</db:code> must be 32-bit aligned, and each scanline of data in the image must also be 32-bit aligned.</db:para>
<db:para>The buffer must remain valid throughout the life of the <db:link xlink:href="qimage.xml">QImage</db:link> and all copies that have not been modified or otherwise detached from the original buffer. The image does not delete the buffer at destruction. You can provide a function pointer <db:code role="parameter">cleanupFunction</db:code> along with an extra pointer <db:code role="parameter">cleanupInfo</db:code> that will be called when the last copy is destroyed.</db:para>
<db:para>If <db:code role="parameter">format</db:code> is an indexed color format, the image color table is initially empty and must be sufficiently expanded with <db:link xlink:href="qimage.xml#setColorCount">setColorCount</db:link>() or <db:link xlink:href="qimage.xml#setColorTable">setColorTable</db:link>() before the image is used.</db:para>
</db:section>
<db:section xml:id="QImage-4">
<db:title>QImage::QImage(const uchar *<db:emphasis>data</db:emphasis>, int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, QImage::Format <db:emphasis>format</db:emphasis>, QImageCleanupFunction <db:emphasis>cleanupFunction</db:emphasis> = nullptr, void *<db:emphasis>cleanupInfo</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QImage</db:methodname>
<db:methodparam>
<db:type>const uchar *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>width</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>height</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImage::Format</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImageCleanupFunction</db:type>
<db:parameter>cleanupFunction</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>cleanupInfo</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage(const uchar *data, int width, int height, QImage::Format format, QImageCleanupFunction cleanupFunction, void *cleanupInfo)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an image with the given <db:code role="parameter">width</db:code>, <db:code role="parameter">height</db:code> and <db:code role="parameter">format</db:code>, that uses an existing read-only memory buffer, <db:code role="parameter">data</db:code>. The <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code> must be specified in pixels, <db:code role="parameter">data</db:code> must be 32-bit aligned, and each scanline of data in the image must also be 32-bit aligned.</db:para>
<db:para>The buffer must remain valid throughout the life of the <db:link xlink:href="qimage.xml">QImage</db:link> and all copies that have not been modified or otherwise detached from the original buffer. The image does not delete the buffer at destruction. You can provide a function pointer <db:code role="parameter">cleanupFunction</db:code> along with an extra pointer <db:code role="parameter">cleanupInfo</db:code> that will be called when the last copy is destroyed.</db:para>
<db:para>If <db:code role="parameter">format</db:code> is an indexed color format, the image color table is initially empty and must be sufficiently expanded with <db:link xlink:href="qimage.xml#setColorCount">setColorCount</db:link>() or <db:link xlink:href="qimage.xml#setColorTable">setColorTable</db:link>() before the image is used.</db:para>
<db:para>Unlike the similar <db:link xlink:href="qimage.xml">QImage</db:link> constructor that takes a non-const data buffer, this version will never alter the contents of the buffer. For example, calling <db:link xlink:href="qimage.xml#bits">QImage::bits</db:link>() will return a deep copy of the image, rather than the buffer passed to the constructor. This allows for the efficiency of constructing a <db:link xlink:href="qimage.xml">QImage</db:link> from raw data, without the possibility of the raw data being changed.</db:para>
</db:section>
<db:section xml:id="QImage-5">
<db:title>QImage::QImage(uchar *<db:emphasis>data</db:emphasis>, int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, qsizetype <db:emphasis>bytesPerLine</db:emphasis>, QImage::Format <db:emphasis>format</db:emphasis>, QImageCleanupFunction <db:emphasis>cleanupFunction</db:emphasis> = nullptr, void *<db:emphasis>cleanupInfo</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QImage</db:methodname>
<db:methodparam>
<db:type>uchar *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>width</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>height</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>bytesPerLine</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImage::Format</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImageCleanupFunction</db:type>
<db:parameter>cleanupFunction</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>cleanupInfo</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage(uchar *data, int width, int height, qsizetype bytesPerLine, QImage::Format format, QImageCleanupFunction cleanupFunction, void *cleanupInfo)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an image with the given <db:code role="parameter">width</db:code>, <db:code role="parameter">height</db:code> and <db:code role="parameter">format</db:code>, that uses an existing memory buffer, <db:code role="parameter">data</db:code>. The <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code> must be specified in pixels. <db:code role="parameter">bytesPerLine</db:code> specifies the number of bytes per line (stride).</db:para>
<db:para>The buffer must remain valid throughout the life of the <db:link xlink:href="qimage.xml">QImage</db:link> and all copies that have not been modified or otherwise detached from the original buffer. The image does not delete the buffer at destruction. You can provide a function pointer <db:code role="parameter">cleanupFunction</db:code> along with an extra pointer <db:code role="parameter">cleanupInfo</db:code> that will be called when the last copy is destroyed.</db:para>
<db:para>If <db:code role="parameter">format</db:code> is an indexed color format, the image color table is initially empty and must be sufficiently expanded with <db:link xlink:href="qimage.xml#setColorCount">setColorCount</db:link>() or <db:link xlink:href="qimage.xml#setColorTable">setColorTable</db:link>() before the image is used.</db:para>
</db:section>
<db:section xml:id="QImage-6">
<db:title>QImage::QImage(const uchar *<db:emphasis>data</db:emphasis>, int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, qsizetype <db:emphasis>bytesPerLine</db:emphasis>, QImage::Format <db:emphasis>format</db:emphasis>, QImageCleanupFunction <db:emphasis>cleanupFunction</db:emphasis> = nullptr, void *<db:emphasis>cleanupInfo</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QImage</db:methodname>
<db:methodparam>
<db:type>const uchar *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>width</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>height</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>bytesPerLine</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImage::Format</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImageCleanupFunction</db:type>
<db:parameter>cleanupFunction</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>cleanupInfo</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage(const uchar *data, int width, int height, qsizetype bytesPerLine, QImage::Format format, QImageCleanupFunction cleanupFunction, void *cleanupInfo)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an image with the given <db:code role="parameter">width</db:code>, <db:code role="parameter">height</db:code> and <db:code role="parameter">format</db:code>, that uses an existing memory buffer, <db:code role="parameter">data</db:code>. The <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code> must be specified in pixels. <db:code role="parameter">bytesPerLine</db:code> specifies the number of bytes per line (stride).</db:para>
<db:para>The buffer must remain valid throughout the life of the <db:link xlink:href="qimage.xml">QImage</db:link> and all copies that have not been modified or otherwise detached from the original buffer. The image does not delete the buffer at destruction. You can provide a function pointer <db:code role="parameter">cleanupFunction</db:code> along with an extra pointer <db:code role="parameter">cleanupInfo</db:code> that will be called when the last copy is destroyed.</db:para>
<db:para>If <db:code role="parameter">format</db:code> is an indexed color format, the image color table is initially empty and must be sufficiently expanded with <db:link xlink:href="qimage.xml#setColorCount">setColorCount</db:link>() or <db:link xlink:href="qimage.xml#setColorTable">setColorTable</db:link>() before the image is used.</db:para>
<db:para>Unlike the similar <db:link xlink:href="qimage.xml">QImage</db:link> constructor that takes a non-const data buffer, this version will never alter the contents of the buffer. For example, calling <db:link xlink:href="qimage.xml#bits">QImage::bits</db:link>() will return a deep copy of the image, rather than the buffer passed to the constructor. This allows for the efficiency of constructing a <db:link xlink:href="qimage.xml">QImage</db:link> from raw data, without the possibility of the raw data being changed.</db:para>
</db:section>
<db:section xml:id="QImage-7">
<db:title>[explicit] QImage::QImage(const char *const[] <db:emphasis>xpm</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QImage</db:methodname>
<db:methodparam>
<db:type>const char *const[]</db:type>
<db:parameter>xpm</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage(const char *const[] xpm)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an image from the given <db:code role="parameter">xpm</db:code> image.</db:para>
<db:para>Make sure that the image is a valid XPM image. Errors are silently ignored.</db:para>
<db:para>Note that it's possible to squeeze the XPM variable a little bit by using an unusual declaration:</db:para>
<db:programlisting language="cpp">static const char * const start_xpm[] = {
    &quot;16 15 8 1&quot;,
    &quot;a c #cec6bd&quot;,
    // etc.
};
</db:programlisting>
<db:para>The extra <db:code>const</db:code> makes the entire definition read-only, which is slightly more efficient (e.g., when the code is in a shared library) and able to be stored in ROM with the application.</db:para>
</db:section>
<db:section xml:id="QImage-8">
<db:title>[explicit] QImage::QImage(const QString &amp;<db:emphasis>fileName</db:emphasis>, const char *<db:emphasis>format</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QImage</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>fileName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>format</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">8</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage(const QString &amp;fileName, const char *format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an image and tries to load the image from the file with the given <db:code role="parameter">fileName</db:code>.</db:para>
<db:para>The loader attempts to read the image using the specified <db:code role="parameter">format</db:code>. If the <db:code role="parameter">format</db:code> is not specified (which is the default), it is auto-detected based on the file's suffix and header. For details, see {<db:link xlink:href="qimagereader.xml#setAutoDetectImageFormat">QImageReader::setAutoDetectImageFormat</db:link>()}{<db:link xlink:href="qimagereader.xml">QImageReader</db:link>}.</db:para>
<db:para>If the loading of the image failed, this object is a null image.</db:para>
<db:para>The file name can either refer to an actual file on disk or to one of the application's embedded resources. See the <db:link xlink:href="resources.xml">Resource System</db:link> overview for details on how to embed images and other resource files in the application's executable.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#reading-and-writing-image-files">Reading and Writing Image Files</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QImage-9">
<db:title>QImage::QImage(const QImage &amp;<db:emphasis>image</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QImage</db:methodname>
<db:methodparam>
<db:type>const QImage &amp;</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">9</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage(const QImage &amp;image)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a shallow copy of the given <db:code role="parameter">image</db:code>.</db:para>
<db:para>For more information about shallow copies, see the <db:link xlink:href="implicit-sharing.xml">Implicit Data Sharing</db:link> documentation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#copy">copy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QImage-10">
<db:title>[since 5.2] QImage::QImage(QImage &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QImage</db:methodname>
<db:methodparam>
<db:type>QImage &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">10</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage(QImage &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Move-constructs a <db:link xlink:href="qimage.xml">QImage</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="dtor.QImage">
<db:title>[virtual] QImage::~QImage()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QImage</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QImage()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the image and cleans up.</db:para>
</db:section>
<db:section xml:id="allGray">
<db:title>bool QImage::allGray() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>allGray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool allGray() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if all the colors in the image are shades of gray (i.e. their red, green and blue components are equal); otherwise false.</db:para>
<db:para>Note that this function is slow for images without color table.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#isGrayscale">isGrayscale</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="applyColorTransform">
<db:title>[since 5.14] void QImage::applyColorTransform(const QColorTransform &amp;<db:emphasis>transform</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>applyColorTransform</db:methodname>
<db:methodparam>
<db:type>const QColorTransform &amp;</db:type>
<db:parameter>transform</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void applyColorTransform(const QColorTransform &amp;transform)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Applies the color transformation <db:code role="parameter">transform</db:code> to all pixels in the image.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
</db:section>
<db:section xml:id="bitPlaneCount">
<db:title>int QImage::bitPlaneCount() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>bitPlaneCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int bitPlaneCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of bit planes in the image.</db:para>
<db:para>The number of bit planes is the number of bits of color and transparency information for each pixel. This is different from (i.e. smaller than) the depth when the image format contains unused bits.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#depth">depth</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#format">format</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-formats">Image Formats</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bits">
<db:title>uchar *QImage::bits()</db:title>
<db:methodsynopsis>
<db:type>uchar *</db:type>
<db:methodname>bits</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uchar * bits()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the first pixel data. This is equivalent to <db:link xlink:href="qimage.xml#scanLine">scanLine</db:link>(0).</db:para>
<db:para>Note that <db:link xlink:href="qimage.xml">QImage</db:link> uses <db:link xlink:href="implicit-sharing.xml">implicit data sharing</db:link>. This function performs a deep copy of the shared pixel data, thus ensuring that this <db:link xlink:href="qimage.xml">QImage</db:link> is the only one using the current return value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#scanLine">scanLine</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#sizeInBytes">sizeInBytes</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#constBits">constBits</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bits-1">
<db:title>const uchar *QImage::bits() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const uchar *</db:type>
<db:methodname>bits</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const uchar * bits() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Note that <db:link xlink:href="qimage.xml">QImage</db:link> uses <db:link xlink:href="implicit-sharing.xml">implicit data sharing</db:link>, but this function does <db:emphasis>not</db:emphasis> perform a deep copy of the shared pixel data, because the returned data is const.</db:para>
</db:section>
<db:section xml:id="bytesPerLine">
<db:title>qsizetype QImage::bytesPerLine() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>bytesPerLine</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype bytesPerLine() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of bytes per image scanline.</db:para>
<db:para>This is equivalent to <db:link xlink:href="qimage.xml#sizeInBytes">sizeInBytes</db:link>() / <db:link xlink:href="qimage.xml#height">height</db:link>() if <db:link xlink:href="qimage.xml#height">height</db:link>() is non-zero.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#scanLine">scanLine</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cacheKey">
<db:title>qint64 QImage::cacheKey() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>cacheKey</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 cacheKey() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a number that identifies the contents of this <db:link xlink:href="qimage.xml">QImage</db:link> object. Distinct <db:link xlink:href="qimage.xml">QImage</db:link> objects can only have the same key if they refer to the same contents.</db:para>
<db:para>The key will change when the image is altered.</db:para>
</db:section>
<db:section xml:id="color">
<db:title>QRgb QImage::color(int <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRgb</db:type>
<db:methodname>color</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRgb color(int i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the color in the color table at index <db:code role="parameter">i</db:code>. The first color is at index 0.</db:para>
<db:para>The colors in an image's color table are specified as ARGB quadruplets (<db:link xlink:href="qcolor.xml#QRgb-typedef">QRgb</db:link>). Use the qAlpha(), qRed(), qGreen(), and qBlue() functions to get the color value components.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#setColor">setColor</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#pixelIndex">pixelIndex</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#pixel-manipulation">Pixel Manipulation</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="colorCount">
<db:title>int QImage::colorCount() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>colorCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int colorCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size of the color table for the image.</db:para>
<db:para>Notice that colorCount() returns 0 for 32-bpp images because these images do not use color tables, but instead encode pixel values as ARGB quadruplets.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#setColorCount">setColorCount</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="colorSpace">
<db:title>[since 5.14] QColorSpace QImage::colorSpace() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QColorSpace</db:type>
<db:methodname>colorSpace</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QColorSpace colorSpace() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the color space of the image if a color space is defined.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#setColorSpace">setColorSpace</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="colorTable">
<db:title>QList&lt;QRgb&gt; QImage::colorTable() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QRgb&gt;</db:type>
<db:methodname>colorTable</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QRgb&gt; colorTable() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list of the colors contained in the image's color table, or an empty list if the image does not have a color table</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#setColorTable">setColorTable</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#colorCount">colorCount</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#color">color</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="colorTransformed">
<db:title>[since 6.4] QImage QImage::colorTransformed(const QColorTransform &amp;<db:emphasis>transform</db:emphasis>) const &amp;</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>colorTransformed</db:methodname>
<db:methodparam>
<db:type>const QColorTransform &amp;</db:type>
<db:parameter>transform</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="refness">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage colorTransformed(const QColorTransform &amp;transform) const &amp;</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the image color transformed using <db:code role="parameter">transform</db:code> on all pixels in the image.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#applyColorTransform">applyColorTransform</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="colorTransformed-1">
<db:title>[since 6.4] QImage QImage::colorTransformed(const QColorTransform &amp;<db:emphasis>transform</db:emphasis>) &amp;&amp;</db:title>
<db:methodsynopsis>
<db:type>QImage</db:type>
<db:methodname>colorTransformed</db:methodname>
<db:methodparam>
<db:type>const QColorTransform &amp;</db:type>
<db:parameter>transform</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="refness">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage colorTransformed(const QColorTransform &amp;transform) &amp;&amp;</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the image color transformed using <db:code role="parameter">transform</db:code> on all pixels in the image.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#applyColorTransform">applyColorTransform</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBits">
<db:title>const uchar *QImage::constBits() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const uchar *</db:type>
<db:methodname>constBits</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const uchar * constBits() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the first pixel data.</db:para>
<db:para>Note that <db:link xlink:href="qimage.xml">QImage</db:link> uses <db:link xlink:href="implicit-sharing.xml">implicit data sharing</db:link>, but this function does <db:emphasis>not</db:emphasis> perform a deep copy of the shared pixel data, because the returned data is const.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#bits">bits</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#constScanLine">constScanLine</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constScanLine">
<db:title>const uchar *QImage::constScanLine(int <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const uchar *</db:type>
<db:methodname>constScanLine</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const uchar * constScanLine(int i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the pixel data at the scanline with index <db:code role="parameter">i</db:code>. The first scanline is at index 0.</db:para>
<db:para>The scanline data is as minimum 32-bit aligned. For 64-bit formats it follows the native alignment of 64-bit integers (64-bit for most platforms, but notably 32-bit on i386).</db:para>
<db:para>Note that <db:link xlink:href="qimage.xml">QImage</db:link> uses <db:link xlink:href="implicit-sharing.xml">implicit data sharing</db:link>, but this function does <db:emphasis>not</db:emphasis> perform a deep copy of the shared pixel data, because the returned data is const.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#scanLine">scanLine</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#constBits">constBits</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="convertTo">
<db:title>[since 5.13] void QImage::convertTo(QImage::Format <db:emphasis>format</db:emphasis>, Qt::ImageConversionFlags <db:emphasis>flags</db:emphasis> = Qt::AutoColor)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>convertTo</db:methodname>
<db:methodparam>
<db:type>QImage::Format</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ImageConversionFlags</db:type>
<db:parameter>flags</db:parameter>
<db:initializer>Qt::AutoColor</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void convertTo(QImage::Format format, Qt::ImageConversionFlags flags)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the image to the given <db:code role="parameter">format</db:code> in place, detaching if necessary.</db:para>
<db:para>The specified image conversion <db:code role="parameter">flags</db:code> control how the image data is handled during the conversion process.</db:para>
<db:para>This function was introduced in Qt 5.13.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#convertedTo">convertedTo</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="convertToColorSpace">
<db:title>[since 5.14] void QImage::convertToColorSpace(const QColorSpace &amp;<db:emphasis>colorSpace</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>convertToColorSpace</db:methodname>
<db:methodparam>
<db:type>const QColorSpace &amp;</db:type>
<db:parameter>colorSpace</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void convertToColorSpace(const QColorSpace &amp;colorSpace)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the image to <db:code role="parameter">colorSpace</db:code>.</db:para>
<db:para>If the image has no valid color space, the method does nothing.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#convertedToColorSpace">convertedToColorSpace</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#setColorSpace">setColorSpace</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="convertToFormat-2">
<db:title>QImage QImage::convertToFormat(QImage::Format <db:emphasis>format</db:emphasis>, const QList&lt;QRgb&gt; &amp;<db:emphasis>colorTable</db:emphasis>, Qt::ImageConversionFlags <db:emphasis>flags</db:emphasis> = Qt::AutoColor) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>convertToFormat</db:methodname>
<db:methodparam>
<db:type>QImage::Format</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QList&lt;QRgb&gt; &amp;</db:type>
<db:parameter>colorTable</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ImageConversionFlags</db:type>
<db:parameter>flags</db:parameter>
<db:initializer>Qt::AutoColor</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage convertToFormat(QImage::Format format, const QList&lt;QRgb&gt; &amp;colorTable, Qt::ImageConversionFlags flags) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a copy of the image converted to the given <db:code role="parameter">format</db:code>, using the specified <db:code role="parameter">colorTable</db:code>.</db:para>
<db:para>Conversion from RGB formats to indexed formats is a slow operation and will use a straightforward nearest color approach, with no dithering.</db:para>
</db:section>
<db:section xml:id="convertedToColorSpace">
<db:title>[since 5.14] QImage QImage::convertedToColorSpace(const QColorSpace &amp;<db:emphasis>colorSpace</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>convertedToColorSpace</db:methodname>
<db:methodparam>
<db:type>const QColorSpace &amp;</db:type>
<db:parameter>colorSpace</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage convertedToColorSpace(const QColorSpace &amp;colorSpace) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the image converted to <db:code role="parameter">colorSpace</db:code>.</db:para>
<db:para>If the image has no valid color space, a null <db:link xlink:href="qimage.xml">QImage</db:link> is returned.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#convertToColorSpace">convertToColorSpace</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="copy">
<db:title>QImage QImage::copy(const QRect &amp;<db:emphasis>rectangle</db:emphasis> = QRect()) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>copy</db:methodname>
<db:methodparam>
<db:type>const QRect &amp;</db:type>
<db:parameter>rectangle</db:parameter>
<db:initializer>QRect()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage copy(const QRect &amp;rectangle) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a sub-area of the image as a new image.</db:para>
<db:para>The returned image is copied from the position (<db:code role="parameter">rectangle</db:code>.x(), <db:code role="parameter">rectangle</db:code>.y()) in this image, and will always have the size of the given <db:code role="parameter">rectangle</db:code>.</db:para>
<db:para>In areas beyond this image, pixels are set to 0. For 32-bit RGB images, this means black; for 32-bit ARGB images, this means transparent black; for 8-bit images, this means the color with index 0 in the color table which can be anything; for 1-bit images, this means <db:link xlink:href="qt.xml#GlobalColor-enum">Qt::color0</db:link>.</db:para>
<db:para>If the given <db:code role="parameter">rectangle</db:code> is a null rectangle the entire image is copied.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#QImage">QImage</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="copy-1">
<db:title>QImage QImage::copy(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>, int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>copy</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>width</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>height</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage copy(int x, int y, int width, int height) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>The returned image is copied from the position (<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>) in this image, and will always have the given <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code>. In areas beyond this image, pixels are set to 0.</db:para>
</db:section>
<db:section xml:id="createAlphaMask">
<db:title>QImage QImage::createAlphaMask(Qt::ImageConversionFlags <db:emphasis>flags</db:emphasis> = Qt::AutoColor) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>createAlphaMask</db:methodname>
<db:methodparam>
<db:type>Qt::ImageConversionFlags</db:type>
<db:parameter>flags</db:parameter>
<db:initializer>Qt::AutoColor</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage createAlphaMask(Qt::ImageConversionFlags flags) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Builds and returns a 1-bpp mask from the alpha buffer in this image. Returns a null image if the image's format is <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_RGB32</db:link>.</db:para>
<db:para>The <db:code role="parameter">flags</db:code> argument is a bitwise-OR of the <db:link xlink:href="qt.xml#ImageConversionFlag-enum">Qt::ImageConversionFlags</db:link>, and controls the conversion process. Passing 0 for flags sets all the default options.</db:para>
<db:para>The returned image has little-endian bit order (i.e. the image's format is <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_MonoLSB</db:link>), which you can convert to big-endian (<db:link xlink:href="qimage.xml#Format-enum">QImage::Format_Mono</db:link>) using the <db:link xlink:href="qimage.xml#convertToFormat">convertToFormat</db:link>() function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#createHeuristicMask">createHeuristicMask</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createHeuristicMask">
<db:title>QImage QImage::createHeuristicMask(bool <db:emphasis>clipTight</db:emphasis> = true) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>createHeuristicMask</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>clipTight</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage createHeuristicMask(bool clipTight) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates and returns a 1-bpp heuristic mask for this image.</db:para>
<db:para>The function works by selecting a color from one of the corners, then chipping away pixels of that color starting at all the edges. The four corners vote for which color is to be masked away. In case of a draw (this generally means that this function is not applicable to the image), the result is arbitrary.</db:para>
<db:para>The returned image has little-endian bit order (i.e. the image's format is <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_MonoLSB</db:link>), which you can convert to big-endian (<db:link xlink:href="qimage.xml#Format-enum">QImage::Format_Mono</db:link>) using the <db:link xlink:href="qimage.xml#convertToFormat">convertToFormat</db:link>() function.</db:para>
<db:para>If <db:code role="parameter">clipTight</db:code> is true (the default) the mask is just large enough to cover the pixels; otherwise, the mask is larger than the data pixels.</db:para>
<db:para>Note that this function disregards the alpha buffer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#createAlphaMask">createAlphaMask</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createMaskFromColor">
<db:title>QImage QImage::createMaskFromColor(QRgb <db:emphasis>color</db:emphasis>, Qt::MaskMode <db:emphasis>mode</db:emphasis> = Qt::MaskInColor) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>createMaskFromColor</db:methodname>
<db:methodparam>
<db:type>QRgb</db:type>
<db:parameter>color</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::MaskMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>Qt::MaskInColor</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage createMaskFromColor(QRgb color, Qt::MaskMode mode) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates and returns a mask for this image based on the given <db:code role="parameter">color</db:code> value. If the <db:code role="parameter">mode</db:code> is MaskInColor (the default value), all pixels matching <db:code role="parameter">color</db:code> will be opaque pixels in the mask. If <db:code role="parameter">mode</db:code> is MaskOutColor, all pixels matching the given color will be transparent.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#createAlphaMask">createAlphaMask</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#createHeuristicMask">createHeuristicMask</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="depth">
<db:title>int QImage::depth() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>depth</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int depth() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the depth of the image.</db:para>
<db:para>The image depth is the number of bits used to store a single pixel, also called bits per pixel (bpp).</db:para>
<db:para>The supported depths are 1, 8, 16, 24, 32 and 64.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#bitPlaneCount">bitPlaneCount</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#convertToFormat">convertToFormat</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-formats">Image Formats</db:link></db:member>
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="deviceIndependentSize">
<db:title>[since 6.2] QSizeF QImage::deviceIndependentSize() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSizeF</db:type>
<db:methodname>deviceIndependentSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSizeF deviceIndependentSize() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size of the image in device independent pixels.</db:para>
<db:para>This value should be used when using the image size in user interface size calculations.</db:para>
<db:para>The return value is equivalent to image.<db:link xlink:href="qimage.xml#size">size</db:link>() / image.<db:link xlink:href="qimage.xml#devicePixelRatio">devicePixelRatio</db:link>().</db:para>
<db:para>This function was introduced in Qt 6.2.</db:para>
</db:section>
<db:section xml:id="devicePixelRatio">
<db:title>qreal QImage::devicePixelRatio() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qreal</db:type>
<db:methodname>devicePixelRatio</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qreal devicePixelRatio() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the device pixel ratio for the image. This is the ratio between <db:emphasis>device pixels</db:emphasis> and <db:emphasis>device independent pixels</db:emphasis>.</db:para>
<db:para>Use this function when calculating layout geometry based on the image size: <db:link xlink:href="qsize.xml">QSize</db:link> layoutSize = image.<db:link xlink:href="qimage.xml#size">size</db:link>() / image.devicePixelRatio()</db:para>
<db:para>The default value is 1.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#setDevicePixelRatio">setDevicePixelRatio</db:link>()</db:member>
<db:member><db:link xlink:href="qimagereader.xml">QImageReader</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dotsPerMeterX">
<db:title>int QImage::dotsPerMeterX() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>dotsPerMeterX</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int dotsPerMeterX() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of pixels that fit horizontally in a physical meter. Together with <db:link xlink:href="qimage.xml#dotsPerMeterY">dotsPerMeterY</db:link>(), this number defines the intended scale and aspect ratio of the image.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#setDotsPerMeterX">setDotsPerMeterX</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dotsPerMeterY">
<db:title>int QImage::dotsPerMeterY() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>dotsPerMeterY</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int dotsPerMeterY() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of pixels that fit vertically in a physical meter. Together with <db:link xlink:href="qimage.xml#dotsPerMeterX">dotsPerMeterX</db:link>(), this number defines the intended scale and aspect ratio of the image.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#setDotsPerMeterY">setDotsPerMeterY</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fill">
<db:title>void QImage::fill(uint <db:emphasis>pixelValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>fill</db:methodname>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>pixelValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void fill(uint pixelValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Fills the entire image with the given <db:code role="parameter">pixelValue</db:code>.</db:para>
<db:para>If the depth of this image is 1, only the lowest bit is used. If you say fill(0), fill(2), etc., the image is filled with 0s. If you say fill(1), fill(3), etc., the image is filled with 1s. If the depth is 8, the lowest 8 bits are used and if the depth is 16 the lowest 16 bits are used.</db:para>
<db:para>If the image depth is higher than 32bit the result is undefined.</db:para>
<db:note>
<db:para>There are no corresponding value getter, though <db:link xlink:href="qimage.xml#pixelIndex">QImage::pixelIndex</db:link>() will return the same value for indexed formats, and <db:link xlink:href="qimage.xml#pixel">QImage::pixel</db:link>() for RGB32, ARGB32, and ARGB32PM formats.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#depth">depth</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fill-1">
<db:title>void QImage::fill(const QColor &amp;<db:emphasis>color</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>fill</db:methodname>
<db:methodparam>
<db:type>const QColor &amp;</db:type>
<db:parameter>color</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void fill(const QColor &amp;color)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Fills the entire image with the given <db:code role="parameter">color</db:code>.</db:para>
<db:para>If the depth of the image is 1, the image will be filled with 1 if <db:code role="parameter">color</db:code> equals <db:link xlink:href="qt.xml#GlobalColor-enum">Qt::color1</db:link>; it will otherwise be filled with 0.</db:para>
<db:para>If the depth of the image is 8, the image will be filled with the index corresponding the <db:code role="parameter">color</db:code> in the color table if present; it will otherwise be filled with 0.</db:para>
</db:section>
<db:section xml:id="fill-2">
<db:title>void QImage::fill(Qt::GlobalColor <db:emphasis>color</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>fill</db:methodname>
<db:methodparam>
<db:type>Qt::GlobalColor</db:type>
<db:parameter>color</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void fill(Qt::GlobalColor color)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Fills the image with the given <db:code role="parameter">color</db:code>, described as a standard global color.</db:para>
</db:section>
<db:section xml:id="format">
<db:title>QImage::Format QImage::format() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage::Format</db:type>
<db:methodname>format</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage::Format format() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the format of the image.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#image-formats">Image Formats</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromData">
<db:title>[static, since 6.2] QImage QImage::fromData(QByteArrayView <db:emphasis>data</db:emphasis>, const char *<db:emphasis>format</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QImage</db:type>
<db:methodname>fromData</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>format</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage fromData(QByteArrayView data, const char *format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs an image from the given <db:link xlink:href="qbytearrayview.xml">QByteArrayView</db:link> <db:code role="parameter">data</db:code>. The loader attempts to read the image using the specified <db:code role="parameter">format</db:code>. If <db:code role="parameter">format</db:code> is not specified (which is the default), the loader probes the data for a header to guess the file format.</db:para>
<db:para>If <db:code role="parameter">format</db:code> is specified, it must be one of the values returned by <db:link xlink:href="qimagereader.xml#supportedImageFormats">QImageReader::supportedImageFormats</db:link>().</db:para>
<db:para>If the loading of the image fails, the image returned will be a null image.</db:para>
<db:para>This function was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#load">load</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#save">save</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#reading-and-writing-image-files">Reading and Writing Image Files</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromData-1">
<db:title>[static] QImage QImage::fromData(const uchar *<db:emphasis>data</db:emphasis>, int <db:emphasis>size</db:emphasis>, const char *<db:emphasis>format</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QImage</db:type>
<db:methodname>fromData</db:methodname>
<db:methodparam>
<db:type>const uchar *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>format</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage fromData(const uchar *data, int size, const char *format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs a <db:link xlink:href="qimage.xml">QImage</db:link> from the first <db:code role="parameter">size</db:code> bytes of the given binary <db:code role="parameter">data</db:code>.</db:para>
</db:section>
<db:section xml:id="fromData-2">
<db:title>[static] QImage QImage::fromData(const QByteArray &amp;<db:emphasis>data</db:emphasis>, const char *<db:emphasis>format</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QImage</db:type>
<db:methodname>fromData</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>format</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage fromData(const QByteArray &amp;data, const char *format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs a <db:link xlink:href="qimage.xml">QImage</db:link> from the given <db:link xlink:href="qbytearray.xml">QByteArray</db:link> <db:code role="parameter">data</db:code>.</db:para>
</db:section>
<db:section xml:id="fromHBITMAP">
<db:title>[static, since 6.0] QImage QImage::fromHBITMAP(HBITMAP <db:emphasis>hbitmap</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QImage</db:type>
<db:methodname>fromHBITMAP</db:methodname>
<db:methodparam>
<db:type>HBITMAP</db:type>
<db:parameter>hbitmap</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage fromHBITMAP(HBITMAP hbitmap)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qimage.xml">QImage</db:link> that is equivalent to the given <db:code role="parameter">hbitmap</db:code>.</db:para>
<db:para>HBITMAP does not store information about the alpha channel.</db:para>
<db:para>In the standard case, the alpha channel is ignored and a fully opaque image is created (typically of format <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_RGB32</db:link>).</db:para>
<db:para>There are cases where the alpha channel is used, though, for example for application icon or systray icons. In that case, <db:code>reinterpretAsFormat(QImage::Format_ARGB32)</db:code> should be called on the returned image to ensure the format is correct.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#toHBITMAP">toHBITMAP</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#reinterpretAsFormat">reinterpretAsFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromHICON">
<db:title>[static, since 6.0] QImage QImage::fromHICON(HICON <db:emphasis>icon</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QImage</db:type>
<db:methodname>fromHICON</db:methodname>
<db:methodparam>
<db:type>HICON</db:type>
<db:parameter>icon</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage fromHICON(HICON icon)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qimage.xml">QImage</db:link> that is equivalent to the given <db:code role="parameter">icon</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#toHICON">toHICON</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasAlphaChannel">
<db:title>bool QImage::hasAlphaChannel() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasAlphaChannel</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasAlphaChannel() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the image has a format that respects the alpha channel, otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="height">
<db:title>int QImage::height() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>height</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int height() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the height of the image.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="invertPixels">
<db:title>void QImage::invertPixels(QImage::InvertMode <db:emphasis>mode</db:emphasis> = InvertRgb)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>invertPixels</db:methodname>
<db:methodparam>
<db:type>QImage::InvertMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>InvertRgb</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void invertPixels(QImage::InvertMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inverts all pixel values in the image.</db:para>
<db:para>The given invert <db:code role="parameter">mode</db:code> only have a meaning when the image's depth is 32. The default <db:code role="parameter">mode</db:code> is <db:link xlink:href="qimage.xml#InvertMode-enum">InvertRgb</db:link>, which leaves the alpha channel unchanged. If the <db:code role="parameter">mode</db:code> is <db:link xlink:href="qimage.xml#InvertMode-enum">InvertRgba</db:link>, the alpha bits are also inverted.</db:para>
<db:para>Inverting an 8-bit image means to replace all pixels using color index <db:emphasis>i</db:emphasis> with a pixel using color index 255 minus <db:emphasis>i</db:emphasis>. The same is the case for a 1-bit image. Note that the color table is <db:emphasis>not</db:emphasis> changed.</db:para>
<db:para>If the image has a premultiplied alpha channel, the image is first converted to an unpremultiplied image format to be inverted and then converted back.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isGrayscale">
<db:title>bool QImage::isGrayscale() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isGrayscale</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isGrayscale() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>For 32-bit images, this function is equivalent to <db:link xlink:href="qimage.xml#allGray">allGray</db:link>().</db:para>
<db:para>For color indexed images, this function returns <db:code>true</db:code> if color(i) is <db:link xlink:href="qcolor.xml#QRgb-typedef">QRgb</db:link>(i, i, i) for all indexes of the color table; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#allGray">allGray</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-formats">Image Formats</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QImage::isNull() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isNull</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isNull() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if it is a null image, otherwise returns <db:code>false</db:code>.</db:para>
<db:para>A null image has all parameters set to zero and no allocated data.</db:para>
</db:section>
<db:section xml:id="load">
<db:title>bool QImage::load(const QString &amp;<db:emphasis>fileName</db:emphasis>, const char *<db:emphasis>format</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>load</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>fileName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>format</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool load(const QString &amp;fileName, const char *format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Loads an image from the file with the given <db:code role="parameter">fileName</db:code>. Returns <db:code>true</db:code> if the image was successfully loaded; otherwise invalidates the image and returns <db:code>false</db:code>.</db:para>
<db:para>The loader attempts to read the image using the specified <db:code role="parameter">format</db:code>, e.g., PNG or JPG. If <db:code role="parameter">format</db:code> is not specified (which is the default), it is auto-detected based on the file's suffix and header. For details, see <db:link xlink:href="qimagereader.xml#setAutoDetectImageFormat">QImageReader::setAutoDetectImageFormat</db:link>().</db:para>
<db:para>The file name can either refer to an actual file on disk or to one of the application's embedded resources. See the <db:link xlink:href="resources.xml">Resource System</db:link> overview for details on how to embed images and other resource files in the application's executable.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#reading-and-writing-image-files">Reading and Writing Image Files</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="load-1">
<db:title>bool QImage::load(QIODevice *<db:emphasis>device</db:emphasis>, const char *<db:emphasis>format</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>load</db:methodname>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool load(QIODevice *device, const char *format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function reads a <db:link xlink:href="qimage.xml">QImage</db:link> from the given <db:code role="parameter">device</db:code>. This can, for example, be used to load an image directly into a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
</db:section>
<db:section xml:id="loadFromData">
<db:title>[since 6.2] bool QImage::loadFromData(QByteArrayView <db:emphasis>data</db:emphasis>, const char *<db:emphasis>format</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>loadFromData</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>format</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool loadFromData(QByteArrayView data, const char *format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Loads an image from the given <db:link xlink:href="qbytearrayview.xml">QByteArrayView</db:link> <db:code role="parameter">data</db:code>. Returns <db:code>true</db:code> if the image was successfully loaded; otherwise invalidates the image and returns <db:code>false</db:code>.</db:para>
<db:para>The loader attempts to read the image using the specified <db:code role="parameter">format</db:code>, e.g., PNG or JPG. If <db:code role="parameter">format</db:code> is not specified (which is the default), the loader probes the file for a header to guess the file format.</db:para>
<db:para>This function was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#reading-and-writing-image-files">Reading and Writing Image Files</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="loadFromData-1">
<db:title>bool QImage::loadFromData(const uchar *<db:emphasis>data</db:emphasis>, int <db:emphasis>len</db:emphasis>, const char *<db:emphasis>format</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>loadFromData</db:methodname>
<db:methodparam>
<db:type>const uchar *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>format</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool loadFromData(const uchar *data, int len, const char *format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Loads an image from the first <db:code role="parameter">len</db:code> bytes of the given binary <db:code role="parameter">data</db:code>.</db:para>
</db:section>
<db:section xml:id="loadFromData-2">
<db:title>bool QImage::loadFromData(const QByteArray &amp;<db:emphasis>data</db:emphasis>, const char *<db:emphasis>format</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>loadFromData</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>format</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool loadFromData(const QByteArray &amp;data, const char *format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Loads an image from the given <db:link xlink:href="qbytearray.xml">QByteArray</db:link> <db:code role="parameter">data</db:code>.</db:para>
</db:section>
<db:section xml:id="mirror">
<db:title>[since 6.0] void QImage::mirror(bool <db:emphasis>horizontal</db:emphasis> = false, bool <db:emphasis>vertical</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>mirror</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>horizontal</db:parameter>
<db:initializer>false</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>vertical</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mirror(bool horizontal, bool vertical)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Mirrors of the image in the horizontal and/or the vertical direction depending on whether <db:code role="parameter">horizontal</db:code> and <db:code role="parameter">vertical</db:code> are set to true or false.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#mirrored">mirrored</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="offset">
<db:title>QPoint QImage::offset() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPoint</db:type>
<db:methodname>offset</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPoint offset() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of pixels by which the image is intended to be offset by when positioning relative to other images.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#setOffset">setOffset</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pixel">
<db:title>QRgb QImage::pixel(const QPoint &amp;<db:emphasis>position</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRgb</db:type>
<db:methodname>pixel</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>position</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRgb pixel(const QPoint &amp;position) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the color of the pixel at the given <db:code role="parameter">position</db:code>.</db:para>
<db:para>If the <db:code role="parameter">position</db:code> is not valid, the results are undefined.</db:para>
<db:warning>
<db:para>This function is expensive when used for massive pixel manipulations. Use <db:link xlink:href="qimage.xml#constBits">constBits</db:link>() or <db:link xlink:href="qimage.xml#constScanLine">constScanLine</db:link>() when many pixels needs to be read.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#setPixel">setPixel</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#valid">valid</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#constBits">constBits</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#constScanLine">constScanLine</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#pixel-manipulation">Pixel Manipulation</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pixel-1">
<db:title>QRgb QImage::pixel(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRgb</db:type>
<db:methodname>pixel</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QRgb pixel(int x, int y) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the color of the pixel at coordinates (<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>).</db:para>
</db:section>
<db:section xml:id="pixelColor">
<db:title>[since 5.6] QColor QImage::pixelColor(const QPoint &amp;<db:emphasis>position</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QColor</db:type>
<db:methodname>pixelColor</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>position</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QColor pixelColor(const QPoint &amp;position) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the color of the pixel at the given <db:code role="parameter">position</db:code> as a <db:link xlink:href="qcolor.xml">QColor</db:link>.</db:para>
<db:para>If the <db:code role="parameter">position</db:code> is not valid, an invalid <db:link xlink:href="qcolor.xml">QColor</db:link> is returned.</db:para>
<db:warning>
<db:para>This function is expensive when used for massive pixel manipulations. Use <db:link xlink:href="qimage.xml#constBits">constBits</db:link>() or <db:link xlink:href="qimage.xml#constScanLine">constScanLine</db:link>() when many pixels needs to be read.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#setPixelColor">setPixelColor</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#setPixel">setPixel</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#valid">valid</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#constBits">constBits</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#constScanLine">constScanLine</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#pixel-manipulation">Pixel Manipulation</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pixelColor-1">
<db:title>[since 5.6] QColor QImage::pixelColor(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QColor</db:type>
<db:methodname>pixelColor</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QColor pixelColor(int x, int y) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the color of the pixel at coordinates (<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>) as a <db:link xlink:href="qcolor.xml">QColor</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="pixelFormat">
<db:title>QPixelFormat QImage::pixelFormat() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPixelFormat</db:type>
<db:methodname>pixelFormat</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPixelFormat pixelFormat() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qimage.xml#Format-enum">QImage::Format</db:link> as a <db:link xlink:href="qpixelformat.xml">QPixelFormat</db:link></db:para>
</db:section>
<db:section xml:id="pixelIndex">
<db:title>int QImage::pixelIndex(const QPoint &amp;<db:emphasis>position</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>pixelIndex</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>position</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int pixelIndex(const QPoint &amp;position) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the pixel index at the given <db:code role="parameter">position</db:code>.</db:para>
<db:para>If <db:code role="parameter">position</db:code> is not valid, or if the image is not a paletted image (<db:link xlink:href="qimage.xml#depth">depth</db:link>() &gt; 8), the results are undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#valid">valid</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#depth">depth</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#pixel-manipulation">Pixel Manipulation</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pixelIndex-1">
<db:title>int QImage::pixelIndex(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>pixelIndex</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int pixelIndex(int x, int y) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the pixel index at (<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>).</db:para>
</db:section>
<db:section xml:id="rect">
<db:title>QRect QImage::rect() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRect</db:type>
<db:methodname>rect</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRect rect() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the enclosing rectangle (0, 0, <db:link xlink:href="qimage.xml#width">width</db:link>(), <db:link xlink:href="qimage.xml#height">height</db:link>()) of the image.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reinterpretAsFormat">
<db:title>[since 5.9] bool QImage::reinterpretAsFormat(QImage::Format <db:emphasis>format</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>reinterpretAsFormat</db:methodname>
<db:methodparam>
<db:type>QImage::Format</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool reinterpretAsFormat(QImage::Format format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Changes the format of the image to <db:code role="parameter">format</db:code> without changing the data. Only works between formats of the same depth.</db:para>
<db:para>Returns <db:code>true</db:code> if successful.</db:para>
<db:para>This function can be used to change images with alpha-channels to their corresponding opaque formats if the data is known to be opaque-only, or to change the format of a given image buffer before overwriting it with new data.</db:para>
<db:warning>
<db:para>The function does not check if the image data is valid in the new format and will still return <db:code>true</db:code> if the depths are compatible. Operations on an image with invalid data are undefined.</db:para>
</db:warning>
<db:warning>
<db:para>If the image is not detached, this will cause the data to be copied.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#hasAlphaChannel">hasAlphaChannel</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#convertToFormat">convertToFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rgbSwap">
<db:title>[since 6.0] void QImage::rgbSwap()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>rgbSwap</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void rgbSwap()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps the values of the red and blue components of all pixels, effectively converting an RGB image to an BGR image.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#rgbSwapped">rgbSwapped</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="save">
<db:title>bool QImage::save(const QString &amp;<db:emphasis>fileName</db:emphasis>, const char *<db:emphasis>format</db:emphasis> = nullptr, int <db:emphasis>quality</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>save</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>fileName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>format</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>quality</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool save(const QString &amp;fileName, const char *format, int quality) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Saves the image to the file with the given <db:code role="parameter">fileName</db:code>, using the given image file <db:code role="parameter">format</db:code> and <db:code role="parameter">quality</db:code> factor. If <db:code role="parameter">format</db:code> is <db:code>nullptr</db:code>, <db:link xlink:href="qimage.xml">QImage</db:link> will attempt to guess the format by looking at <db:code role="parameter">fileName</db:code>'s suffix.</db:para>
<db:para>The <db:code role="parameter">quality</db:code> factor must be in the range 0 to 100 or -1. Specify 0 to obtain small compressed files, 100 for large uncompressed files, and -1 (the default) to use the default settings.</db:para>
<db:para>Returns <db:code>true</db:code> if the image was successfully saved; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#reading-and-writing-image-files">Reading and Writing Image Files</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="save-1">
<db:title>bool QImage::save(QIODevice *<db:emphasis>device</db:emphasis>, const char *<db:emphasis>format</db:emphasis> = nullptr, int <db:emphasis>quality</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>save</db:methodname>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>format</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>quality</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool save(QIODevice *device, const char *format, int quality) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function writes a <db:link xlink:href="qimage.xml">QImage</db:link> to the given <db:code role="parameter">device</db:code>.</db:para>
<db:para>This can, for example, be used to save an image directly into a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>:</db:para>
<db:programlisting language="cpp">QImage image;
QByteArray ba;
QBuffer buffer(&amp;amp;ba);
buffer.open(QIODevice::WriteOnly);
image.save(&amp;amp;buffer, &quot;PNG&quot;); // writes image into ba in PNG format
</db:programlisting>
</db:section>
<db:section xml:id="scaled">
<db:title>QImage QImage::scaled(const QSize &amp;<db:emphasis>size</db:emphasis>, Qt::AspectRatioMode <db:emphasis>aspectRatioMode</db:emphasis> = Qt::IgnoreAspectRatio, Qt::TransformationMode <db:emphasis>transformMode</db:emphasis> = Qt::FastTransformation) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>scaled</db:methodname>
<db:methodparam>
<db:type>const QSize &amp;</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::AspectRatioMode</db:type>
<db:parameter>aspectRatioMode</db:parameter>
<db:initializer>Qt::IgnoreAspectRatio</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>Qt::TransformationMode</db:type>
<db:parameter>transformMode</db:parameter>
<db:initializer>Qt::FastTransformation</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage scaled(const QSize &amp;size, Qt::AspectRatioMode aspectRatioMode, Qt::TransformationMode transformMode) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a copy of the image scaled to a rectangle defined by the given <db:code role="parameter">size</db:code> according to the given <db:code role="parameter">aspectRatioMode</db:code> and <db:code role="parameter">transformMode</db:code>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qimage-scaling.png"/>
</db:imageobject>
</db:mediaobject>
<db:itemizedlist>
<db:listitem>
<db:para>If <db:code role="parameter">aspectRatioMode</db:code> is <db:link xlink:href="qt.xml#AspectRatioMode-enum">Qt::IgnoreAspectRatio</db:link>, the image is scaled to <db:code role="parameter">size</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>If <db:code role="parameter">aspectRatioMode</db:code> is <db:link xlink:href="qt.xml#AspectRatioMode-enum">Qt::KeepAspectRatio</db:link>, the image is scaled to a rectangle as large as possible inside <db:code role="parameter">size</db:code>, preserving the aspect ratio.</db:para>
</db:listitem>
<db:listitem>
<db:para>If <db:code role="parameter">aspectRatioMode</db:code> is <db:link xlink:href="qt.xml#AspectRatioMode-enum">Qt::KeepAspectRatioByExpanding</db:link>, the image is scaled to a rectangle as small as possible outside <db:code role="parameter">size</db:code>, preserving the aspect ratio.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>If the given <db:code role="parameter">size</db:code> is empty, this function returns a null image.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="scaled-1">
<db:title>QImage QImage::scaled(int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, Qt::AspectRatioMode <db:emphasis>aspectRatioMode</db:emphasis> = Qt::IgnoreAspectRatio, Qt::TransformationMode <db:emphasis>transformMode</db:emphasis> = Qt::FastTransformation) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>scaled</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>width</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>height</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::AspectRatioMode</db:type>
<db:parameter>aspectRatioMode</db:parameter>
<db:initializer>Qt::IgnoreAspectRatio</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>Qt::TransformationMode</db:type>
<db:parameter>transformMode</db:parameter>
<db:initializer>Qt::FastTransformation</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage scaled(int width, int height, Qt::AspectRatioMode aspectRatioMode, Qt::TransformationMode transformMode) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a copy of the image scaled to a rectangle with the given <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code> according to the given <db:code role="parameter">aspectRatioMode</db:code> and <db:code role="parameter">transformMode</db:code>.</db:para>
<db:para>If either the <db:code role="parameter">width</db:code> or the <db:code role="parameter">height</db:code> is zero or negative, this function returns a null image.</db:para>
</db:section>
<db:section xml:id="scaledToHeight">
<db:title>QImage QImage::scaledToHeight(int <db:emphasis>height</db:emphasis>, Qt::TransformationMode <db:emphasis>mode</db:emphasis> = Qt::FastTransformation) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>scaledToHeight</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>height</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::TransformationMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>Qt::FastTransformation</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage scaledToHeight(int height, Qt::TransformationMode mode) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a scaled copy of the image. The returned image is scaled to the given <db:code role="parameter">height</db:code> using the specified transformation <db:code role="parameter">mode</db:code>.</db:para>
<db:para>This function automatically calculates the width of the image so that the ratio of the image is preserved.</db:para>
<db:para>If the given <db:code role="parameter">height</db:code> is 0 or negative, a null image is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="scaledToWidth">
<db:title>QImage QImage::scaledToWidth(int <db:emphasis>width</db:emphasis>, Qt::TransformationMode <db:emphasis>mode</db:emphasis> = Qt::FastTransformation) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>scaledToWidth</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>width</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::TransformationMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>Qt::FastTransformation</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage scaledToWidth(int width, Qt::TransformationMode mode) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a scaled copy of the image. The returned image is scaled to the given <db:code role="parameter">width</db:code> using the specified transformation <db:code role="parameter">mode</db:code>.</db:para>
<db:para>This function automatically calculates the height of the image so that its aspect ratio is preserved.</db:para>
<db:para>If the given <db:code role="parameter">width</db:code> is 0 or negative, a null image is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="scanLine">
<db:title>uchar *QImage::scanLine(int <db:emphasis>i</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>uchar *</db:type>
<db:methodname>scanLine</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uchar * scanLine(int i)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the pixel data at the scanline with index <db:code role="parameter">i</db:code>. The first scanline is at index 0.</db:para>
<db:para>The scanline data is as minimum 32-bit aligned. For 64-bit formats it follows the native alignment of 64-bit integers (64-bit for most platforms, but notably 32-bit on i386).</db:para>
<db:para>For example, to remove the green component of each pixel in an image:</db:para>
<db:programlisting language="cpp">for (int y = 0; y &amp;lt; image.height(); ++y) {
    QRgb *line = reinterpret_cast&amp;lt;QRgb*&amp;gt;(image.scanLine(y));
    for (int x = 0; x &amp;lt; image.width(); ++x) {
        QRgb &amp;amp;rgb = line[x];
        rgb = qRgba(qRed(rgb), qGreen(0), qBlue(rgb), qAlpha(rgb));
    }
}
</db:programlisting>
<db:warning>
<db:para>If you are accessing 32-bpp image data, cast the returned pointer to <db:code>QRgb*</db:code> (<db:link xlink:href="qcolor.xml#QRgb-typedef">QRgb</db:link> has a 32-bit size) and use it to read/write the pixel value. You cannot use the <db:code>uchar*</db:code> pointer directly, because the pixel format depends on the byte order on the underlying platform. Use qRed(), qGreen(), qBlue(), and qAlpha() to access the pixels.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#bytesPerLine">bytesPerLine</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#bits">bits</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#pixel-manipulation">Pixel Manipulation</db:link></db:member>
<db:member><db:link xlink:href="qimage.xml#constScanLine">constScanLine</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="scanLine-1">
<db:title>const uchar *QImage::scanLine(int <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const uchar *</db:type>
<db:methodname>scanLine</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const uchar * scanLine(int i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="setAlphaChannel">
<db:title>void QImage::setAlphaChannel(const QImage &amp;<db:emphasis>alphaChannel</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setAlphaChannel</db:methodname>
<db:methodparam>
<db:type>const QImage &amp;</db:type>
<db:parameter>alphaChannel</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setAlphaChannel(const QImage &amp;alphaChannel)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the alpha channel of this image to the given <db:code role="parameter">alphaChannel</db:code>.</db:para>
<db:para>If <db:code role="parameter">alphaChannel</db:code> is an 8 bit alpha image, the alpha values are used directly. Otherwise, <db:code role="parameter">alphaChannel</db:code> is converted to 8 bit grayscale and the intensity of the pixel values is used.</db:para>
<db:para>If the image already has an alpha channel, the existing alpha channel is multiplied with the new one. If the image doesn't have an alpha channel it will be converted to a format that does.</db:para>
<db:para>The operation is similar to painting <db:code role="parameter">alphaChannel</db:code> as an alpha image over this image using <db:code>QPainter::CompositionMode_DestinationIn</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#hasAlphaChannel">hasAlphaChannel</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
<db:member><db:link xlink:href="qimage.xml#image-formats">Image Formats</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setColor">
<db:title>void QImage::setColor(int <db:emphasis>index</db:emphasis>, QRgb <db:emphasis>colorValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setColor</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QRgb</db:type>
<db:parameter>colorValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setColor(int index, QRgb colorValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the color at the given <db:code role="parameter">index</db:code> in the color table, to the given to <db:code role="parameter">colorValue</db:code>. The color value is an ARGB quadruplet.</db:para>
<db:para>If <db:code role="parameter">index</db:code> is outside the current size of the color table, it is expanded with <db:link xlink:href="qimage.xml#setColorCount">setColorCount</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#color">color</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#colorCount">colorCount</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#setColorTable">setColorTable</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#pixel-manipulation">Pixel Manipulation</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setColorCount">
<db:title>void QImage::setColorCount(int <db:emphasis>colorCount</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setColorCount</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>colorCount</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setColorCount(int colorCount)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Resizes the color table to contain <db:code role="parameter">colorCount</db:code> entries.</db:para>
<db:para>If the color table is expanded, all the extra colors will be set to transparent (i.e <db:link xlink:href="qcolor.xml#qRgba">qRgba</db:link>(0, 0, 0, 0)).</db:para>
<db:para>When the image is used, the color table must be large enough to have entries for all the pixel/index values present in the image, otherwise the results are undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#colorCount">colorCount</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#colorTable">colorTable</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#setColor">setColor</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setColorSpace">
<db:title>[since 5.14] void QImage::setColorSpace(const QColorSpace &amp;<db:emphasis>colorSpace</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setColorSpace</db:methodname>
<db:methodparam>
<db:type>const QColorSpace &amp;</db:type>
<db:parameter>colorSpace</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setColorSpace(const QColorSpace &amp;colorSpace)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the image color space to <db:code role="parameter">colorSpace</db:code> without performing any conversions on image data.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#colorSpace">colorSpace</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setColorTable">
<db:title>void QImage::setColorTable(const QList&lt;QRgb&gt; &amp;<db:emphasis>colors</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setColorTable</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QRgb&gt; &amp;</db:type>
<db:parameter>colors</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setColorTable(const QList&lt;QRgb&gt; &amp;colors)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the color table used to translate color indexes to <db:link xlink:href="qcolor.xml#QRgb-typedef">QRgb</db:link> values, to the specified <db:code role="parameter">colors</db:code>.</db:para>
<db:para>When the image is used, the color table must be large enough to have entries for all the pixel/index values present in the image, otherwise the results are undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#colorTable">colorTable</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#setColor">setColor</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDevicePixelRatio">
<db:title>void QImage::setDevicePixelRatio(qreal <db:emphasis>scaleFactor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDevicePixelRatio</db:methodname>
<db:methodparam>
<db:type>qreal</db:type>
<db:parameter>scaleFactor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDevicePixelRatio(qreal scaleFactor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the device pixel ratio for the image. This is the ratio between image pixels and device-independent pixels.</db:para>
<db:para>The default <db:code role="parameter">scaleFactor</db:code> is 1.0. Setting it to something else has two effects:</db:para>
<db:para>QPainters that are opened on the image will be scaled. For example, painting on a 200x200 image if with a ratio of 2.0 will result in effective (device-independent) painting bounds of 100x100.</db:para>
<db:para>Code paths in Qt that calculate layout geometry based on the image size will take the ratio into account: <db:link xlink:href="qsize.xml">QSize</db:link> layoutSize = image.<db:link xlink:href="qimage.xml#size">size</db:link>() / image.<db:link xlink:href="qimage.xml#devicePixelRatio">devicePixelRatio</db:link>() The net effect of this is that the image is displayed as high-DPI image rather than a large image (see <db:link xlink:href="qpainter.xml#drawing-high-resolution-versions-of-pixmaps-and-images">Drawing High Resolution Versions of Pixmaps and Images</db:link>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#devicePixelRatio">devicePixelRatio</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#deviceIndependentSize">deviceIndependentSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDotsPerMeterX">
<db:title>void QImage::setDotsPerMeterX(int <db:emphasis>x</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDotsPerMeterX</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDotsPerMeterX(int x)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the number of pixels that fit horizontally in a physical meter, to <db:code role="parameter">x</db:code>.</db:para>
<db:para>Together with <db:link xlink:href="qimage.xml#dotsPerMeterY">dotsPerMeterY</db:link>(), this number defines the intended scale and aspect ratio of the image, and determines the scale at which <db:link xlink:href="qpainter.xml">QPainter</db:link> will draw graphics on the image. It does not change the scale or aspect ratio of the image when it is rendered on other paint devices.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#dotsPerMeterX">dotsPerMeterX</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDotsPerMeterY">
<db:title>void QImage::setDotsPerMeterY(int <db:emphasis>y</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDotsPerMeterY</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDotsPerMeterY(int y)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the number of pixels that fit vertically in a physical meter, to <db:code role="parameter">y</db:code>.</db:para>
<db:para>Together with <db:link xlink:href="qimage.xml#dotsPerMeterX">dotsPerMeterX</db:link>(), this number defines the intended scale and aspect ratio of the image, and determines the scale at which <db:link xlink:href="qpainter.xml">QPainter</db:link> will draw graphics on the image. It does not change the scale or aspect ratio of the image when it is rendered on other paint devices.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#dotsPerMeterY">dotsPerMeterY</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setOffset">
<db:title>void QImage::setOffset(const QPoint &amp;<db:emphasis>offset</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setOffset</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>offset</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setOffset(const QPoint &amp;offset)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the number of pixels by which the image is intended to be offset by when positioning relative to other images, to <db:code role="parameter">offset</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#offset">offset</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPixel">
<db:title>void QImage::setPixel(const QPoint &amp;<db:emphasis>position</db:emphasis>, uint <db:emphasis>index_or_rgb</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPixel</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>position</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>index_or_rgb</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPixel(const QPoint &amp;position, uint index_or_rgb)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the pixel index or color at the given <db:code role="parameter">position</db:code> to <db:code role="parameter">index_or_rgb</db:code>.</db:para>
<db:para>If the image's format is either monochrome or paletted, the given <db:code role="parameter">index_or_rgb</db:code> value must be an index in the image's color table, otherwise the parameter must be a <db:link xlink:href="qcolor.xml#QRgb-typedef">QRgb</db:link> value.</db:para>
<db:para>If <db:code role="parameter">position</db:code> is not a valid coordinate pair in the image, or if <db:code role="parameter">index_or_rgb</db:code> &gt;= <db:link xlink:href="qimage.xml#colorCount">colorCount</db:link>() in the case of monochrome and paletted images, the result is undefined.</db:para>
<db:warning>
<db:para>This function is expensive due to the call of the internal <db:code>detach()</db:code> function called within; if performance is a concern, we recommend the use of <db:link xlink:href="qimage.xml#scanLine">scanLine</db:link>() or <db:link xlink:href="qimage.xml#bits">bits</db:link>() to access pixel data directly.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#pixel">pixel</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#pixel-manipulation">Pixel Manipulation</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPixel-1">
<db:title>void QImage::setPixel(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>, uint <db:emphasis>index_or_rgb</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPixel</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>index_or_rgb</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPixel(int x, int y, uint index_or_rgb)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the pixel index or color at (<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>) to <db:code role="parameter">index_or_rgb</db:code>.</db:para>
</db:section>
<db:section xml:id="setPixelColor">
<db:title>[since 5.6] void QImage::setPixelColor(const QPoint &amp;<db:emphasis>position</db:emphasis>, const QColor &amp;<db:emphasis>color</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPixelColor</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>position</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QColor &amp;</db:type>
<db:parameter>color</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPixelColor(const QPoint &amp;position, const QColor &amp;color)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the color at the given <db:code role="parameter">position</db:code> to <db:code role="parameter">color</db:code>.</db:para>
<db:para>If <db:code role="parameter">position</db:code> is not a valid coordinate pair in the image, or the image's format is either monochrome or paletted, the result is undefined.</db:para>
<db:warning>
<db:para>This function is expensive due to the call of the internal <db:code>detach()</db:code> function called within; if performance is a concern, we recommend the use of <db:link xlink:href="qimage.xml#scanLine">scanLine</db:link>() or <db:link xlink:href="qimage.xml#bits">bits</db:link>() to access pixel data directly.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#pixelColor">pixelColor</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#pixel">pixel</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#bits">bits</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#scanLine">scanLine</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#pixel-manipulation">Pixel Manipulation</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPixelColor-1">
<db:title>[since 5.6] void QImage::setPixelColor(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>, const QColor &amp;<db:emphasis>color</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPixelColor</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QColor &amp;</db:type>
<db:parameter>color</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPixelColor(int x, int y, const QColor &amp;color)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the pixel color at (<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>) to <db:code role="parameter">color</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="setText">
<db:title>void QImage::setText(const QString &amp;<db:emphasis>key</db:emphasis>, const QString &amp;<db:emphasis>text</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setText</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>text</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setText(const QString &amp;key, const QString &amp;text)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the image text to the given <db:code role="parameter">text</db:code> and associate it with the given <db:code role="parameter">key</db:code>.</db:para>
<db:para>If you just want to store a single text block (i.e., a &quot;comment&quot; or just a description), you can either pass an empty key, or use a generic key like &quot;Description&quot;.</db:para>
<db:para>The image text is embedded into the image data when you call <db:link xlink:href="qimage.xml#save">save</db:link>() or <db:link xlink:href="qimagewriter.xml#write">QImageWriter::write</db:link>().</db:para>
<db:para>Not all image formats support embedded text. You can find out if a specific image or format supports embedding text by using <db:link xlink:href="qimagewriter.xml#supportsOption">QImageWriter::supportsOption</db:link>(). We give an example:</db:para>
<db:programlisting language="cpp">    QImageWriter writer;
    writer.setFormat(&quot;png&quot;);
    if (writer.supportsOption(QImageIOHandler::Description))
        qDebug() &amp;lt;&amp;lt; &quot;Png supports embedded text&quot;;
</db:programlisting>
<db:para>You can use <db:link xlink:href="qimagewriter.xml#supportedImageFormats">QImageWriter::supportedImageFormats</db:link>() to find out which image formats are available to you.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#text">text</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#textKeys">textKeys</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>QSize QImage::size() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSize</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSize size() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size of the image, i.e. its <db:link xlink:href="qimage.xml#width">width</db:link>() and <db:link xlink:href="qimage.xml#height">height</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
<db:member><db:link xlink:href="qimage.xml#deviceIndependentSize">deviceIndependentSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sizeInBytes">
<db:title>[since 5.10] qsizetype QImage::sizeInBytes() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>sizeInBytes</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype sizeInBytes() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the image data size in bytes.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#bytesPerLine">bytesPerLine</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#bits">bits</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QImage::swap(QImage &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QImage &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QImage &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps image <db:code role="parameter">other</db:code> with this image. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="text">
<db:title>QString QImage::text(const QString &amp;<db:emphasis>key</db:emphasis> = QString()) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>text</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString text(const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the image text associated with the given <db:code role="parameter">key</db:code>. If the specified <db:code role="parameter">key</db:code> is an empty string, the whole image text is returned, with each key-text pair separated by a newline.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#setText">setText</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#textKeys">textKeys</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="textKeys">
<db:title>QStringList QImage::textKeys() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>textKeys</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList textKeys() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the text keys for this image.</db:para>
<db:para>You can use these keys with <db:link xlink:href="qimage.xml#text">text</db:link>() to list the image text for a certain key.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#text">text</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toCGImage">
<db:title>CGImageRef QImage::toCGImage() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>CGImageRef</db:type>
<db:methodname>toCGImage</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">CGImageRef toCGImage() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a <db:code>CGImage</db:code> equivalent to this <db:link xlink:href="qimage.xml">QImage</db:link>.</db:para>
<db:para>Returns a <db:code>CGImageRef</db:code> handle.</db:para>
<db:para>The returned CGImageRef partakes in the <db:link xlink:href="qimage.xml">QImage</db:link> implicit sharing, and holds a reference to the <db:link xlink:href="qimage.xml">QImage</db:link> data. CGImage is immutable and will never detach the <db:link xlink:href="qimage.xml">QImage</db:link>. Writing to the <db:link xlink:href="qimage.xml">QImage</db:link> will detach as usual.</db:para>
<db:para>This function is fast, and does not copy or convert image data.</db:para>
<db:para>The following image formats are supported, and will be mapped to a corresponding native image type:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Qt</db:para>
</db:th>
<db:th>
<db:para>CoreGraphics</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qimage.xml#Format-enum">Format_ARGB32</db:link></db:para>
</db:td>
<db:td>
<db:para>kCGImageAlphaFirst | kCGBitmapByteOrder32Host</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qimage.xml#Format-enum">Format_RGB32</db:link></db:para>
</db:td>
<db:td>
<db:para>kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qimage.xml#Format-enum">Format_RGBA8888_Premultiplied</db:link></db:para>
</db:td>
<db:td>
<db:para>kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qimage.xml#Format-enum">Format_RGBA8888</db:link></db:para>
</db:td>
<db:td>
<db:para>kCGImageAlphaLast | kCGBitmapByteOrder32Big</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qimage.xml#Format-enum">Format_RGBX8888</db:link></db:para>
</db:td>
<db:td>
<db:para>kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qimage.xml#Format-enum">Format_ARGB32_Premultiplied</db:link></db:para>
</db:td>
<db:td>
<db:para>kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Other formats are not supported; this function returns a null CGImageRef for those cases. Users of this function may then convert the <db:link xlink:href="qimage.xml">QImage</db:link> to a supported format first, for example <db:link xlink:href="qimage.xml#Format-enum">Format_ARGB32_Premultiplied</db:link>.</db:para>
<db:para>The CGImageRef color space is set to the sRGB color space.</db:para>
</db:section>
<db:section xml:id="toHBITMAP">
<db:title>[since 6.0] HBITMAP QImage::toHBITMAP() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>HBITMAP</db:type>
<db:methodname>toHBITMAP</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">HBITMAP toHBITMAP() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a <db:code>HBITMAP</db:code> equivalent of the <db:link xlink:href="qimage.xml">QImage</db:link>.</db:para>
<db:para>Returns the <db:code>HBITMAP</db:code> handle.</db:para>
<db:para>It is the caller's responsibility to free the <db:code>HBITMAP</db:code> data after use.</db:para>
<db:para>For usage with with standard GDI calls, such as <db:code>BitBlt()</db:code>, the image should have the format <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_RGB32</db:link>.</db:para>
<db:para>When using the resulting HBITMAP for the <db:code>AlphaBlend()</db:code> GDI function, the image should have the format <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_ARGB32_Premultiplied</db:link> (use <db:link xlink:href="qimage.xml#convertToFormat">convertToFormat</db:link>()).</db:para>
<db:para>When using the resulting HBITMAP as application icon or a systray icon, the image should have the format <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_ARGB32</db:link>.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#fromHBITMAP">fromHBITMAP</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#convertToFormat">convertToFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toHICON">
<db:title>[since 6.0] HICON QImage::toHICON(const QImage &amp;<db:emphasis>mask</db:emphasis> = {}) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>HICON</db:type>
<db:methodname>toHICON</db:methodname>
<db:methodparam>
<db:type>const QImage &amp;</db:type>
<db:parameter>mask</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">HICON toHICON(const QImage &amp;mask) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a <db:code>HICON</db:code> equivalent of the <db:link xlink:href="qpixmap.xml">QPixmap</db:link>, applying the mask <db:code role="parameter">mask</db:code>.</db:para>
<db:para>If <db:code role="parameter">mask</db:code> is not null, it needs to be of format <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_Mono</db:link>. Returns the <db:code>HICON</db:code> handle.</db:para>
<db:para>It is the caller's responsibility to free the <db:code>HICON</db:code> data after use.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#fromHICON">fromHICON</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toImageFormat">
<db:title>[static] QImage::Format QImage::toImageFormat(QPixelFormat <db:emphasis>format</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QImage::Format</db:type>
<db:methodname>toImageFormat</db:methodname>
<db:methodparam>
<db:type>QPixelFormat</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage::Format toImageFormat(QPixelFormat format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts <db:code role="parameter">format</db:code> into a <db:link xlink:href="qimage.xml#Format-enum">QImage::Format</db:link></db:para>
</db:section>
<db:section xml:id="toPixelFormat">
<db:title>[static] QPixelFormat QImage::toPixelFormat(QImage::Format <db:emphasis>format</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QPixelFormat</db:type>
<db:methodname>toPixelFormat</db:methodname>
<db:methodparam>
<db:type>QImage::Format</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPixelFormat toPixelFormat(QImage::Format format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts <db:code role="parameter">format</db:code> into a <db:link xlink:href="qpixelformat.xml">QPixelFormat</db:link></db:para>
</db:section>
<db:section xml:id="transformed">
<db:title>QImage QImage::transformed(const QTransform &amp;<db:emphasis>matrix</db:emphasis>, Qt::TransformationMode <db:emphasis>mode</db:emphasis> = Qt::FastTransformation) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QImage</db:type>
<db:methodname>transformed</db:methodname>
<db:methodparam>
<db:type>const QTransform &amp;</db:type>
<db:parameter>matrix</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::TransformationMode</db:type>
<db:parameter>mode</db:parameter>
<db:initializer>Qt::FastTransformation</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage transformed(const QTransform &amp;matrix, Qt::TransformationMode mode) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a copy of the image that is transformed using the given transformation <db:code role="parameter">matrix</db:code> and transformation <db:code role="parameter">mode</db:code>.</db:para>
<db:para>The returned image will normally have the same {Image Formats}{format} as the original image. However, a complex transformation may result in an image where not all pixels are covered by the transformed pixels of the original image. In such cases, those background pixels will be assigned a transparent color value, and the transformed image will be given a format with an alpha channel, even if the original image did not have that.</db:para>
<db:para>The transformation <db:code role="parameter">matrix</db:code> is internally adjusted to compensate for unwanted translation; i.e. the image produced is the smallest image that contains all the transformed points of the original image. Use the <db:link xlink:href="qimage.xml#trueMatrix">trueMatrix</db:link>() function to retrieve the actual matrix used for transforming an image.</db:para>
<db:para>Unlike the other overload, this function can be used to perform perspective transformations on images.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#trueMatrix">trueMatrix</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="trueMatrix">
<db:title>[static] QTransform QImage::trueMatrix(const QTransform &amp;<db:emphasis>matrix</db:emphasis>, int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QTransform</db:type>
<db:methodname>trueMatrix</db:methodname>
<db:methodparam>
<db:type>const QTransform &amp;</db:type>
<db:parameter>matrix</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>width</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>height</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QTransform trueMatrix(const QTransform &amp;matrix, int width, int height)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the actual matrix used for transforming an image with the given <db:code role="parameter">width</db:code>, <db:code role="parameter">height</db:code> and <db:code role="parameter">matrix</db:code>.</db:para>
<db:para>When transforming an image using the <db:link xlink:href="qimage.xml#transformed">transformed</db:link>() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. <db:link xlink:href="qimage.xml#transformed">transformed</db:link>() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.</db:para>
<db:para>Unlike the other overload, this function creates transformation matrices that can be used to perform perspective transformations on images.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#transformed">transformed</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#image-transformations">Image Transformations</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="valid">
<db:title>bool QImage::valid(const QPoint &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>valid</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool valid(const QPoint &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">pos</db:code> is a valid coordinate pair within the image; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#rect">rect</db:link>()</db:member>
<db:member><db:link xlink:href="qrect.xml#contains">QRect::contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="valid-1">
<db:title>bool QImage::valid(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>valid</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool valid(int x, int y) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if <db:link xlink:href="qpoint.xml">QPoint</db:link>(<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>) is a valid coordinate pair within the image; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="width">
<db:title>int QImage::width() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>width</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int width() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the width of the image.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#image-information">Image Information</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-QVariant">
<db:title>QVariant QImage::operator QVariant() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>operator QVariant</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant operator QVariant() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the image as a <db:link xlink:href="qvariant.xml">QVariant</db:link>.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QImage::operator!=(const QImage &amp;<db:emphasis>image</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QImage &amp;</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QImage &amp;image) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this image and the given <db:code role="parameter">image</db:code> have different contents; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison can be slow, unless there is some obvious difference, such as different widths, in which case the function will return quickly.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QImage &amp;QImage::operator=(const QImage &amp;<db:emphasis>image</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QImage &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QImage &amp;</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage &amp; operator=(const QImage &amp;image)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns a shallow copy of the given <db:code role="parameter">image</db:code> to this image and returns a reference to this image.</db:para>
<db:para>For more information about shallow copies, see the <db:link xlink:href="implicit-sharing.xml">Implicit Data Sharing</db:link> documentation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#copy">copy</db:link>()</db:member>
<db:member><db:link xlink:href="qimage.xml#QImage">QImage</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[since 5.2] QImage &amp;QImage::operator=(QImage &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QImage &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QImage &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage &amp; operator=(QImage &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qimage.xml">QImage</db:link> instance.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QImage::operator==(const QImage &amp;<db:emphasis>image</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QImage &amp;</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QImage &amp;image) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this image and the given <db:code role="parameter">image</db:code> have the same contents; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison can be slow, unless there is some obvious difference (e.g. different size or format), in which case the function will return quickly.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="QImageCleanupFunction-typedef">
<db:title>[since 5.0] QImageCleanupFunction</db:title>
<db:typedefsynopsis>
<db:typedefname>QImageCleanupFunction</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>A function with the following signature that can be used to implement basic image memory management:</db:para>
<db:programlisting language="cpp">void myImageCleanupHandler(void *info);
</db:programlisting>
<db:para>This typedef was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>stream</db:emphasis>, const QImage &amp;<db:emphasis>image</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>stream</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QImage &amp;</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&lt;&lt;(QDataStream &amp;stream, const QImage &amp;image)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the given <db:code role="parameter">image</db:code> to the given <db:code role="parameter">stream</db:code> as a PNG image, or as a BMP image if the stream's version is 1. Note that writing the stream to a file will not produce a valid image file.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#save">QImage::save</db:link>()</db:member>
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>stream</db:emphasis>, QImage &amp;<db:emphasis>image</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>stream</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QImage &amp;</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&gt;&gt;(QDataStream &amp;stream, QImage &amp;image)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads an image from the given <db:code role="parameter">stream</db:code> and stores it in the given <db:code role="parameter">image</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qimage.xml#load">QImage::load</db:link>()</db:member>
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
