<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSqlQuery Class</db:title>
<db:productname>QtSql</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt SQL Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> class provides a means of executing and manipulating SQL statements.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSqlQuery</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Sql)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Sql)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += sql</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QSqlQuery is part of <db:simplelist><db:member><db:link xlink:href="database.xml">Database Classes</db:link></db:member><db:member>shared</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> encapsulates the functionality involved in creating, navigating and retrieving data from SQL queries which are executed on a <db:link xlink:href="qsqldatabase.xml">QSqlDatabase</db:link>. It can be used to execute DML (data manipulation language) statements, such as <db:code>SELECT</db:code>, <db:code>INSERT</db:code>, <db:code>UPDATE</db:code> and <db:code>DELETE</db:code>, as well as DDL (data definition language) statements, such as <db:code>CREATE</db:code> <db:code>TABLE</db:code>. It can also be used to execute database-specific commands which are not standard SQL (e.g. <db:code>SET DATESTYLE=ISO</db:code> for PostgreSQL).</db:para>
<db:para>Successfully executed SQL statements set the query's state to active so that <db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>() returns <db:code>true</db:code>. Otherwise the query's state is set to inactive. In either case, when executing a new SQL statement, the query is positioned on an invalid record. An active query must be navigated to a valid record (so that <db:link xlink:href="qsqlquery.xml#isValid">isValid</db:link>() returns <db:code>true</db:code>) before values can be retrieved.</db:para>
<db:para>For some databases, if an active query that is a <db:code>SELECT</db:code> statement exists when you call <db:link xlink:href="qsqldatabase.xml#commit">commit</db:link>() or <db:link xlink:href="qsqldatabase.xml#rollback">rollback</db:link>(), the commit or rollback will fail. See <db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>() for details.</db:para>
<db:anchor xml:id="qsqlquery-examples"/>
<db:para>Navigating records is performed with the following functions:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qsqlquery.xml#next">next</db:link>()</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qsqlquery.xml#previous">previous</db:link>()</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qsqlquery.xml#first">first</db:link>()</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qsqlquery.xml#last">last</db:link>()</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qsqlquery.xml#seek">seek</db:link>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>These functions allow the programmer to move forward, backward or arbitrarily through the records returned by the query. If you only need to move forward through the results (e.g., by using <db:link xlink:href="qsqlquery.xml#next">next</db:link>()), you can use <db:link xlink:href="qsqlquery.xml#setForwardOnly">setForwardOnly</db:link>(), which will save a significant amount of memory overhead and improve performance on some databases. Once an active query is positioned on a valid record, data can be retrieved using <db:link xlink:href="qsqlquery.xml#value">value</db:link>(). All data is transferred from the SQL backend using QVariants.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">    QSqlQuery query(&quot;SELECT country FROM artist&quot;);
    while (query.next()) {
        QString country = query.value(0).toString();
        doSomething(country);
    }
</db:programlisting>
<db:para>To access the data returned by a query, use value(int). Each field in the data returned by a <db:code>SELECT</db:code> statement is accessed by passing the field's position in the statement, starting from 0. This makes using <db:code>SELECT *</db:code> queries inadvisable because the order of the fields returned is indeterminate.</db:para>
<db:para>For the sake of efficiency, there are no functions to access a field by name (unless you use prepared queries with names, as explained below). To convert a field name into an index, use <db:link xlink:href="qsqlquery.xml#record">record</db:link>().<db:link xlink:href="qsqlrecord.xml#indexOf">indexOf</db:link>(), for example:</db:para>
<db:programlisting language="cpp">    QSqlQuery query(&quot;SELECT * FROM artist&quot;);
    int fieldNo = query.record().indexOf(&quot;country&quot;);
    while (query.next()) {
        QString country = query.value(fieldNo).toString();
        doSomething(country);
    }
</db:programlisting>
<db:para><db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> supports prepared query execution and the binding of parameter values to placeholders. Some databases don't support these features, so for those, Qt emulates the required functionality. For example, the Oracle and ODBC drivers have proper prepared query support, and Qt makes use of it; but for databases that don't have this support, Qt implements the feature itself, e.g. by replacing placeholders with actual values when a query is executed. Use <db:link xlink:href="qsqlquery.xml#numRowsAffected">numRowsAffected</db:link>() to find out how many rows were affected by a non-<db:code>SELECT</db:code> query, and <db:link xlink:href="qsqlquery.xml#size">size</db:link>() to find how many were retrieved by a <db:code>SELECT</db:code>.</db:para>
<db:para>Oracle databases identify placeholders by using a colon-name syntax, e.g <db:code>:name</db:code>. ODBC simply uses <db:code>?</db:code> characters. Qt supports both syntaxes, with the restriction that you can't mix them in the same query.</db:para>
<db:para>You can retrieve the values of all the fields in a single variable using <db:link xlink:href="qsqlquery.xml#boundValues">boundValues</db:link>().</db:para>
<db:note>
<db:para>Not all SQL operations support binding values. Refer to your database system's documentation to check their availability.</db:para>
</db:note>
<db:section xml:id="approaches-to-binding-values">
<db:title>Approaches to Binding Values</db:title>
<db:para>Below we present the same example using each of the four different binding approaches, as well as one example of binding values to a stored procedure.</db:para>
<db:para><db:emphasis role="bold">Named binding using named placeholders:</db:emphasis></db:para>
<db:programlisting language="cpp">    QSqlQuery query;
    query.prepare(&quot;INSERT INTO person (id, forename, surname) &quot;
                  &quot;VALUES (:id, :forename, :surname)&quot;);
    query.bindValue(&quot;:id&quot;, 1001);
    query.bindValue(&quot;:forename&quot;, &quot;Bart&quot;);
    query.bindValue(&quot;:surname&quot;, &quot;Simpson&quot;);
    query.exec();
</db:programlisting>
<db:para><db:emphasis role="bold">Positional binding using named placeholders:</db:emphasis></db:para>
<db:programlisting language="cpp">    QSqlQuery query;
    query.prepare(&quot;INSERT INTO person (id, forename, surname) &quot;
                  &quot;VALUES (:id, :forename, :surname)&quot;);
    query.bindValue(0, 1001);
    query.bindValue(1, &quot;Bart&quot;);
    query.bindValue(2, &quot;Simpson&quot;);
    query.exec();
</db:programlisting>
<db:para><db:emphasis role="bold">Binding values using positional placeholders (version 1):</db:emphasis></db:para>
<db:programlisting language="cpp">    QSqlQuery query;
    query.prepare(&quot;INSERT INTO person (id, forename, surname) &quot;
                  &quot;VALUES (?, ?, ?)&quot;);
    query.bindValue(0, 1001);
    query.bindValue(1, &quot;Bart&quot;);
    query.bindValue(2, &quot;Simpson&quot;);
    query.exec();
</db:programlisting>
<db:para><db:emphasis role="bold">Binding values using positional placeholders (version 2):</db:emphasis></db:para>
<db:programlisting language="cpp">    QSqlQuery query;
    query.prepare(&quot;INSERT INTO person (id, forename, surname) &quot;
                  &quot;VALUES (?, ?, ?)&quot;);
    query.addBindValue(1001);
    query.addBindValue(&quot;Bart&quot;);
    query.addBindValue(&quot;Simpson&quot;);
    query.exec();
</db:programlisting>
<db:para><db:emphasis role="bold">Binding values to a stored procedure:</db:emphasis></db:para>
<db:para>This code calls a stored procedure called <db:code>AsciiToInt()</db:code>, passing it a character through its in parameter, and taking its result in the out parameter.</db:para>
<db:programlisting language="cpp">    QSqlQuery query;
    query.prepare(&quot;CALL AsciiToInt(?, ?)&quot;);
    query.bindValue(0, &quot;A&quot;);
    query.bindValue(1, 0, QSql::Out);
    query.exec();
    int i = query.boundValue(1).toInt(); // i is 65
</db:programlisting>
<db:para>Note that unbound parameters will retain their values.</db:para>
<db:para>Stored procedures that uses the return statement to return values, or return multiple result sets, are not fully supported. For specific details see <db:link xlink:href="sql-driver.xml">SQL Database Drivers</db:link>.</db:para>
<db:warning>
<db:para>You must load the SQL driver and open the connection before a <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> is created. Also, the connection must remain open while the query exists; otherwise, the behavior of <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> is undefined.</db:para>
</db:warning>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqldatabase.xml">QSqlDatabase</db:link></db:member>
<db:member><db:link xlink:href="qsqlquerymodel.xml">QSqlQueryModel</db:link></db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link></db:member>
<db:member><db:link xlink:href="qvariant.xml">QVariant</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="BatchExecutionMode-enum">
<db:title>enum QSqlQuery::BatchExecutionMode</db:title>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link></db:emphasis>::ValuesAsRows</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>- Updates multiple rows. Treats every entry in a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> as a value for updating the next row.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link></db:emphasis>::ValuesAsColumns</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>- Updates a single row. Treats every entry in a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> as a single value of an array type.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="forwardOnly-prop">
<db:title>[since 6.8] forwardOnly : bool</db:title>
<db:para>This property holds the forward only mode. If <db:code role="parameter">forward</db:code> is true, only <db:link xlink:href="qsqlquery.xml#next">next</db:link>() and <db:link xlink:href="qsqlquery.xml#seek">seek</db:link>() with positive values, are allowed for navigating the results.</db:para>
<db:para>Forward only mode can be (depending on the driver) more memory efficient since results do not need to be cached. It will also improve performance on some databases. For this to be true, you must call <db:code>setForwardOnly()</db:code> before the query is prepared or executed. Note that the constructor that takes a query and a database may execute the query.</db:para>
<db:para>Forward only mode is off by default.</db:para>
<db:para>Setting forward only to false is a suggestion to the database engine, which has the final say on whether a result set is forward only or scrollable. <db:link xlink:href="qsqlquery.xml#isForwardOnly">isForwardOnly</db:link>() will always return the correct status of the result set.</db:para>
<db:note>
<db:para>Calling <db:link xlink:href="qsqlquery.xml#setForwardOnly">setForwardOnly</db:link> after execution of the query will result in unexpected results at best, and crashes at worst.</db:para>
</db:note>
<db:note>
<db:para>To make sure the forward-only query completed successfully, the application should check <db:link xlink:href="qsqlquery.xml#lastError">lastError</db:link>() for an error not only after executing the query, but also after navigating the query results.</db:para>
</db:note>
<db:warning>
<db:para>PostgreSQL: While navigating the query results in forward-only mode, do not execute any other SQL command on the same database connection. This will cause the query results to be lost.</db:para>
</db:warning>
<db:para>This property was introduced in Qt 6.8.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold"><db:link xlink:href="qsqlquery.xml#isForwardOnly">isForwardOnly</db:link></db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qsqlquery.xml#setForwardOnly">setForwardOnly</db:link></db:emphasis>(<db:type>bool</db:type> <db:emphasis>forward</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#next">next</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#seek">seek</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="numericalPrecisionPolicy-prop">
<db:title>[since 6.8] numericalPrecisionPolicy : QSql::NumericalPrecisionPolicy</db:title>
<db:para>Instruct the database driver to return numerical values with a precision specified by <db:code role="parameter">precisionPolicy</db:code>.</db:para>
<db:para>The Oracle driver, for example, can retrieve numerical values as strings to prevent the loss of precision. If high precision doesn't matter, use this method to increase execution speed by bypassing string conversions.</db:para>
<db:para>Note: Drivers that don't support fetching numerical values with low precision will ignore the precision policy. You can use <db:link xlink:href="qsqldriver.xml#hasFeature">QSqlDriver::hasFeature</db:link>() to find out whether a driver supports this feature.</db:para>
<db:para>Note: Setting the precision policy doesn't affect the currently active query. Call <db:link xlink:href="qsqlquery.xml#exec">exec</db:link>(QString) or <db:link xlink:href="qsqlquery.xml#prepare">prepare</db:link>() in order to activate the policy.</db:para>
<db:para>This property was introduced in Qt 6.8.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsql.xml#NumericalPrecisionPolicy-enum">QSql::NumericalPrecisionPolicy</db:link></db:type> <db:emphasis role="bold"><db:link xlink:href="qsqlquery.xml#numericalPrecisionPolicy">numericalPrecisionPolicy</db:link></db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qsqlquery.xml#setNumericalPrecisionPolicy">setNumericalPrecisionPolicy</db:link></db:emphasis>(<db:type><db:link xlink:href="qsql.xml#NumericalPrecisionPolicy-enum">QSql::NumericalPrecisionPolicy</db:link></db:type> <db:emphasis>precisionPolicy</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsql.xml#NumericalPrecisionPolicy-enum">QSql::NumericalPrecisionPolicy</db:link></db:member>
<db:member><db:link xlink:href="qsqldriver.xml#numericalPrecisionPolicy">QSqlDriver::numericalPrecisionPolicy</db:link></db:member>
<db:member><db:link xlink:href="qsqldatabase.xml#numericalPrecisionPolicy">QSqlDatabase::numericalPrecisionPolicy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="positionalBindingEnabled-prop">
<db:title>[since 6.8] positionalBindingEnabled : bool</db:title>
<db:para>This property enables or disables the positional <db:link xlink:href="qsqlquery.xml#approaches-to-binding-values">binding</db:link> for this query, depending on <db:code role="parameter">enable</db:code> (default is <db:code>true</db:code>). Disabling positional bindings is useful if the query itself contains a '?' which must not be handled as a positional binding parameter but, for example, as a JSON operator for a PostgreSQL database.</db:para>
<db:para>This property will have no effect when the database has native support for positional bindings with question marks (see also <db:link xlink:href="qsqldriver.xml#DriverFeature-enum">QSqlDriver::PositionalPlaceholders</db:link>).</db:para>
<db:para>This property was introduced in Qt 6.8.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold"><db:link xlink:href="qsqlquery.xml#isPositionalBindingEnabled">isPositionalBindingEnabled</db:link></db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qsqlquery.xml#setPositionalBindingEnabled">setPositionalBindingEnabled</db:link></db:emphasis>(<db:type>bool</db:type> <db:emphasis>enable</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QSqlQuery-1">
<db:title>[explicit] QSqlQuery::QSqlQuery(QSqlResult *<db:emphasis>result</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> object which uses the <db:link xlink:href="qsqlresult.xml">QSqlResult</db:link> <db:code role="parameter">result</db:code> to communicate with a database.</db:para>
</db:section>
<db:section xml:id="QSqlQuery-2">
<db:title>[explicit] QSqlQuery::QSqlQuery(const QSqlDatabase &amp;<db:emphasis>db</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> object using the database <db:code role="parameter">db</db:code>. If <db:code role="parameter">db</db:code> is invalid, the application's default database will be used.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqldatabase.xml">QSqlDatabase</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QSqlQuery-4">
<db:title>[explicit] QSqlQuery::QSqlQuery(const QString &amp;<db:emphasis>query</db:emphasis> = QString(), const QSqlDatabase &amp;<db:emphasis>db</db:emphasis> = QSqlDatabase())</db:title>
<db:para>Constructs a <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> object using the SQL <db:code role="parameter">query</db:code> and the database <db:code role="parameter">db</db:code>. If <db:code role="parameter">db</db:code> is not specified, or is invalid, the application's default database is used. If <db:code role="parameter">query</db:code> is not an empty string, it will be executed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqldatabase.xml">QSqlDatabase</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QSqlQuery">
<db:title>[noexcept, since 6.2] QSqlQuery::QSqlQuery(QSqlQuery &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-constructs a <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> from <db:code role="parameter">other</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.2.</db:para>
</db:section>
<db:section xml:id="dtor.QSqlQuery">
<db:title>[noexcept] QSqlQuery::~QSqlQuery()</db:title>
<db:para>Destroys the object and frees any allocated resources.</db:para>
</db:section>
<db:section xml:id="addBindValue">
<db:title>void QSqlQuery::addBindValue(const QVariant &amp;<db:emphasis>val</db:emphasis>, QSql::ParamType <db:emphasis>paramType</db:emphasis> = QSql::In)</db:title>
<db:para>Adds the value <db:code role="parameter">val</db:code> to the list of values when using positional value binding. The order of the addBindValue() calls determines which placeholder a value will be bound to in the prepared query. If <db:code role="parameter">paramType</db:code> is <db:link xlink:href="qsql.xml#ParamTypeFlag-enum">QSql::Out</db:link> or <db:link xlink:href="qsql.xml#ParamTypeFlag-enum">QSql::InOut</db:link>, the placeholder will be overwritten with data from the database after the <db:link xlink:href="qsqlquery.xml#exec">exec</db:link>() call.</db:para>
<db:para>To bind a NULL value, use a null <db:link xlink:href="qvariant.xml">QVariant</db:link>; for example, use <db:code>QVariant(QMetaType::fromType&lt;QString&gt;())</db:code> if you are binding a string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#bindValue">bindValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#prepare">prepare</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#exec">exec</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#boundValue">boundValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#boundValues">boundValues</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="at">
<db:title>int QSqlQuery::at() const</db:title>
<db:para>Returns the current internal position of the query. The first record is at position zero. If the position is invalid, the function returns <db:link xlink:href="qsql.xml#Location-enum">QSql::BeforeFirstRow</db:link> or <db:link xlink:href="qsql.xml#Location-enum">QSql::AfterLastRow</db:link>, which are special negative values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#previous">previous</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#next">next</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#seek">seek</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindValue">
<db:title>void QSqlQuery::bindValue(const QString &amp;<db:emphasis>placeholder</db:emphasis>, const QVariant &amp;<db:emphasis>val</db:emphasis>, QSql::ParamType <db:emphasis>paramType</db:emphasis> = QSql::In)</db:title>
<db:para>Set the placeholder <db:code role="parameter">placeholder</db:code> to be bound to value <db:code role="parameter">val</db:code> in the prepared statement. Note that the placeholder mark (e.g <db:code>:</db:code>) must be included when specifying the placeholder name. If <db:code role="parameter">paramType</db:code> is <db:link xlink:href="qsql.xml#ParamTypeFlag-enum">QSql::Out</db:link> or <db:link xlink:href="qsql.xml#ParamTypeFlag-enum">QSql::InOut</db:link>, the placeholder will be overwritten with data from the database after the <db:link xlink:href="qsqlquery.xml#exec">exec</db:link>() call. In this case, sufficient space must be pre-allocated to store the result into.</db:para>
<db:para>To bind a NULL value, use a null <db:link xlink:href="qvariant.xml">QVariant</db:link>; for example, use <db:code>QVariant(QMetaType::fromType&lt;QString&gt;())</db:code> if you are binding a string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#addBindValue">addBindValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#prepare">prepare</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#exec">exec</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#boundValue">boundValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#boundValues">boundValues</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindValue-1">
<db:title>void QSqlQuery::bindValue(int <db:emphasis>pos</db:emphasis>, const QVariant &amp;<db:emphasis>val</db:emphasis>, QSql::ParamType <db:emphasis>paramType</db:emphasis> = QSql::In)</db:title>
<db:para>Set the placeholder in position <db:code role="parameter">pos</db:code> to be bound to value <db:code role="parameter">val</db:code> in the prepared statement. Field numbering starts at 0. If <db:code role="parameter">paramType</db:code> is <db:link xlink:href="qsql.xml#ParamTypeFlag-enum">QSql::Out</db:link> or <db:link xlink:href="qsql.xml#ParamTypeFlag-enum">QSql::InOut</db:link>, the placeholder will be overwritten with data from the database after the <db:link xlink:href="qsqlquery.xml#exec">exec</db:link>() call.</db:para>
</db:section>
<db:section xml:id="boundValue">
<db:title>QVariant QSqlQuery::boundValue(const QString &amp;<db:emphasis>placeholder</db:emphasis>) const</db:title>
<db:para>Returns the value for the <db:code role="parameter">placeholder</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#boundValues">boundValues</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#bindValue">bindValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#addBindValue">addBindValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="boundValue-1">
<db:title>QVariant QSqlQuery::boundValue(int <db:emphasis>pos</db:emphasis>) const</db:title>
<db:para>Returns the value for the placeholder at position <db:code role="parameter">pos</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#boundValues">boundValues</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="boundValueName">
<db:title>[since 6.6] QString QSqlQuery::boundValueName(int <db:emphasis>pos</db:emphasis>) const</db:title>
<db:para>Returns the bound value name at position <db:code role="parameter">pos</db:code>.</db:para>
<db:para>The order of the list is in binding order, irrespective of whether named or positional binding is used.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#boundValueNames">boundValueNames</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="boundValueNames">
<db:title>[since 6.6] QStringList QSqlQuery::boundValueNames() const</db:title>
<db:para>Returns the names of all bound values.</db:para>
<db:para>The order of the list is in binding order, irrespective of whether named or positional binding is used.</db:para>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#boundValues">boundValues</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#boundValueName">boundValueName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="boundValues">
<db:title>[since 6.0] QVariantList QSqlQuery::boundValues() const</db:title>
<db:para>Returns a list of bound values.</db:para>
<db:para>The order of the list is in binding order, irrespective of whether named or positional binding is used.</db:para>
<db:para>The bound values can be examined in the following way:</db:para>
<db:programlisting language="cpp">    const QVariantList list = query.boundValues();
    for (qsizetype i = 0; i &lt; list.size(); ++i)
        qDebug() &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; list.at(i).toString();
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#boundValue">boundValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#bindValue">bindValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#addBindValue">addBindValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#boundValueNames">boundValueNames</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QSqlQuery::clear()</db:title>
<db:para>Clears the result set and releases any resources held by the query. Sets the query state to inactive. You should rarely if ever need to call this function.</db:para>
</db:section>
<db:section xml:id="driver">
<db:title>const QSqlDriver *QSqlQuery::driver() const</db:title>
<db:para>Returns the database driver associated with the query.</db:para>
</db:section>
<db:section xml:id="exec">
<db:title>bool QSqlQuery::exec()</db:title>
<db:para>Executes a previously prepared SQL query. Returns <db:code>true</db:code> if the query executed successfully; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Note that the last error for this query is reset when exec() is called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#prepare">prepare</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#bindValue">bindValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#addBindValue">addBindValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#boundValue">boundValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#boundValues">boundValues</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="exec-1">
<db:title>bool QSqlQuery::exec(const QString &amp;<db:emphasis>query</db:emphasis>)</db:title>
<db:para>Executes the SQL in <db:code role="parameter">query</db:code>. Returns <db:code>true</db:code> and sets the query state to <db:link xlink:href="qsqlquery.xml#isActive">active</db:link> if the query was successful; otherwise returns <db:code>false</db:code>. The <db:code role="parameter">query</db:code> string must use syntax appropriate for the SQL database being queried (for example, standard SQL).</db:para>
<db:para>After the query is executed, the query is positioned on an <db:emphasis>invalid</db:emphasis> record and must be navigated to a valid record before data values can be retrieved (for example, using <db:link xlink:href="qsqlquery.xml#next">next</db:link>()).</db:para>
<db:para>Note that the last error for this query is reset when <db:link xlink:href="qsqlquery.xml#exec">exec</db:link>() is called.</db:para>
<db:para>For SQLite, the query string can contain only one statement at a time. If more than one statement is given, the function returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">    QSqlQuery query;
    query.exec(&quot;INSERT INTO employee (id, name, salary) &quot;
               &quot;VALUES (1001, 'Thad Beaumont', 65000)&quot;);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#next">next</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#previous">previous</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#seek">seek</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="execBatch">
<db:title>bool QSqlQuery::execBatch(QSqlQuery::BatchExecutionMode <db:emphasis>mode</db:emphasis> = ValuesAsRows)</db:title>
<db:para>Executes a previously prepared SQL query in a batch. All the bound parameters have to be lists of variants. If the database doesn't support batch executions, the driver will simulate it using conventional <db:link xlink:href="qsqlquery.xml#exec">exec</db:link>() calls.</db:para>
<db:para>Returns <db:code>true</db:code> if the query is executed successfully; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QSqlQuery q;
q.prepare(&quot;insert into myTable values (?, ?)&quot;);

QVariantList ints;
ints &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4;
q.addBindValue(ints);

QVariantList names;
names &lt;&lt; &quot;Harald&quot; &lt;&lt; &quot;Boris&quot; &lt;&lt; &quot;Trond&quot; &lt;&lt; QVariant(QMetaType::fromType&lt;QString&gt;());
q.addBindValue(names);

if (!q.execBatch())
    qDebug() &lt;&lt; q.lastError();
</db:programlisting>
<db:para>The example above inserts four new rows into <db:code>myTable</db:code>:</db:para>
<db:programlisting language="cpp">1  Harald
2  Boris
3  Trond
4  NULL
</db:programlisting>
<db:para>To bind NULL values, a null <db:link xlink:href="qvariant.xml">QVariant</db:link> of the relevant type has to be added to the bound <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>; for example, <db:code>QVariant(QMetaType::fromType&lt;QString&gt;())</db:code> should be used if you are using strings.</db:para>
<db:note>
<db:para>Every bound <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> must contain the same amount of variants.</db:para>
</db:note>
<db:note>
<db:para>The type of the QVariants in a list must not change. For example, you cannot mix integer and string variants within a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link>.</db:para>
</db:note>
<db:para>The <db:code role="parameter">mode</db:code> parameter indicates how the bound <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> will be interpreted. If <db:code role="parameter">mode</db:code> is <db:code>ValuesAsRows</db:code>, every variant within the <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> will be interpreted as a value for a new row. <db:code>ValuesAsColumns</db:code> is a special case for the Oracle driver. In this mode, every entry within a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> will be interpreted as array-value for an IN or OUT value within a stored procedure. Note that this will only work if the IN or OUT value is a table-type consisting of only one column of a basic type, for example <db:code>TYPE myType IS TABLE OF VARCHAR(64) INDEX BY BINARY_INTEGER;</db:code></db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#prepare">prepare</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#bindValue">bindValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#addBindValue">addBindValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="executedQuery">
<db:title>QString QSqlQuery::executedQuery() const</db:title>
<db:para>Returns the last query that was successfully executed.</db:para>
<db:para>In most cases this function returns the same string as <db:link xlink:href="qsqlquery.xml#lastQuery">lastQuery</db:link>(). If a prepared query with placeholders is executed on a DBMS that does not support it, the preparation of this query is emulated. The placeholders in the original query are replaced with their bound values to form a new query. This function returns the modified query. It is mostly useful for debugging purposes.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#lastQuery">lastQuery</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="finish">
<db:title>void QSqlQuery::finish()</db:title>
<db:para>Instruct the database driver that no more data will be fetched from this query until it is re-executed. There is normally no need to call this function, but it may be helpful in order to free resources such as locks or cursors if you intend to re-use the query at a later time.</db:para>
<db:para>Sets the query to inactive. Bound values retain their values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#prepare">prepare</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#exec">exec</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first">
<db:title>bool QSqlQuery::first()</db:title>
<db:para>Retrieves the first record in the result, if available, and positions the query on the retrieved record. Note that the result must be in the <db:link xlink:href="qsqlquery.xml#isActive">active</db:link> state and <db:link xlink:href="qsqlquery.xml#isSelect">isSelect</db:link>() must return true before calling this function or it will do nothing and return false. Returns <db:code>true</db:code> if successful. If unsuccessful the query position is set to an invalid position and false is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#next">next</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#previous">previous</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#seek">seek</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isActive">
<db:title>bool QSqlQuery::isActive() const</db:title>
<db:para>Returns <db:code>true</db:code> if the query is <db:emphasis>active</db:emphasis>. An active <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> is one that has been <db:link xlink:href="qsqlquery.xml#exec">exec</db:link>()'d successfully but not yet finished with. When you are finished with an active query, you can make the query inactive by calling <db:link xlink:href="qsqlquery.xml#finish">finish</db:link>() or <db:link xlink:href="qsqlquery.xml#clear">clear</db:link>(), or you can delete the <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> instance.</db:para>
<db:note>
<db:para>Of particular interest is an active query that is a <db:code>SELECT</db:code> statement. For some databases that support transactions, an active query that is a <db:code>SELECT</db:code> statement can cause a <db:link xlink:href="qsqldatabase.xml#commit">commit</db:link>() or a <db:link xlink:href="qsqldatabase.xml#rollback">rollback</db:link>() to fail, so before committing or rolling back, you should make your active <db:code>SELECT</db:code> statement query inactive using one of the ways listed above.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#isSelect">isSelect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isForwardOnly">
<db:title>bool QSqlQuery::isForwardOnly() const</db:title>
<db:para>Returns <db:link xlink:href="qsqlquery.xml#forwardOnly-prop">forwardOnly</db:link>.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qsqlquery.xml#forwardOnly-prop">forwardOnly</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#forwardOnly-prop">forwardOnly</db:link></db:member>
<db:member><db:link xlink:href="qsqlquery.xml#next">next</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#seek">seek</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QSqlQuery::isNull(int <db:emphasis>field</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if the query is not <db:link xlink:href="qsqlquery.xml#isActive">active</db:link>, the query is not positioned on a valid record, there is no such <db:code role="parameter">field</db:code>, or the <db:code role="parameter">field</db:code> is null; otherwise <db:code>false</db:code>. Note that for some drivers, isNull() will not return accurate information until after an attempt is made to retrieve data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isNull-1">
<db:title>bool QSqlQuery::isNull(QAnyStringView <db:emphasis>name</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if there is no field with this <db:code role="parameter">name</db:code>; otherwise returns <db:link xlink:href="qsqlquery.xml#isNull">isNull</db:link>(int index) for the corresponding field index.</db:para>
<db:para>This overload is less efficient than <db:link xlink:href="qsqlquery.xml#isNull">isNull</db:link>()</db:para>
<db:note>
<db:para>In Qt versions prior to 6.8, this function took <db:link xlink:href="qstring.xml">QString</db:link>, not <db:link xlink:href="qanystringview.xml">QAnyStringView</db:link>.</db:para>
</db:note>
</db:section>
<db:section xml:id="isPositionalBindingEnabled">
<db:title>[since 6.7] bool QSqlQuery::isPositionalBindingEnabled() const</db:title>
<db:para>Returns <db:link xlink:href="qsqlquery.xml#positionalBindingEnabled-prop">positionalBindingEnabled</db:link>.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qsqlquery.xml#positionalBindingEnabled-prop">positionalBindingEnabled</db:link>. </db:para>
</db:note>
<db:para>This function was introduced in Qt 6.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#positionalBindingEnabled-prop">positionalBindingEnabled</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSelect">
<db:title>bool QSqlQuery::isSelect() const</db:title>
<db:para>Returns <db:code>true</db:code> if the current query is a <db:code>SELECT</db:code> statement; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QSqlQuery::isValid() const</db:title>
<db:para>Returns <db:code>true</db:code> if the query is currently positioned on a valid record; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="last">
<db:title>bool QSqlQuery::last()</db:title>
<db:para>Retrieves the last record in the result, if available, and positions the query on the retrieved record. Note that the result must be in the <db:link xlink:href="qsqlquery.xml#isActive">active</db:link> state and <db:link xlink:href="qsqlquery.xml#isSelect">isSelect</db:link>() must return true before calling this function or it will do nothing and return false. Returns <db:code>true</db:code> if successful. If unsuccessful the query position is set to an invalid position and false is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#next">next</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#previous">previous</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#seek">seek</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastError">
<db:title>QSqlError QSqlQuery::lastError() const</db:title>
<db:para>Returns error information about the last error (if any) that occurred with this query.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlerror.xml">QSqlError</db:link></db:member>
<db:member><db:link xlink:href="qsqldatabase.xml#lastError">QSqlDatabase::lastError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastInsertId">
<db:title>QVariant QSqlQuery::lastInsertId() const</db:title>
<db:para>Returns the object ID of the most recent inserted row if the database supports it. An invalid <db:link xlink:href="qvariant.xml">QVariant</db:link> will be returned if the query did not insert any value or if the database does not report the id back. If more than one row was touched by the insert, the behavior is undefined.</db:para>
<db:para>For MySQL databases the row's auto-increment field will be returned.</db:para>
<db:note>
<db:para>For this function to work in PSQL, the table must contain OIDs, which may not have been created by default. Check the <db:code>default_with_oids</db:code> configuration variable to be sure.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqldriver.xml#hasFeature">QSqlDriver::hasFeature</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastQuery">
<db:title>QString QSqlQuery::lastQuery() const</db:title>
<db:para>Returns the text of the current query being used, or an empty string if there is no current query text.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#executedQuery">executedQuery</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="next">
<db:title>bool QSqlQuery::next()</db:title>
<db:para>Retrieves the next record in the result, if available, and positions the query on the retrieved record. Note that the result must be in the <db:link xlink:href="qsqlquery.xml#isActive">active</db:link> state and <db:link xlink:href="qsqlquery.xml#isSelect">isSelect</db:link>() must return true before calling this function or it will do nothing and return false.</db:para>
<db:para>The following rules apply:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If the result is currently located before the first record, e.g. immediately after a query is executed, an attempt is made to retrieve the first record.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the result is currently located after the last record, there is no change and false is returned.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the result is located somewhere in the middle, an attempt is made to retrieve the next record.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>If the record could not be retrieved, the result is positioned after the last record and false is returned. If the record is successfully retrieved, true is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#previous">previous</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#seek">seek</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nextResult">
<db:title>bool QSqlQuery::nextResult()</db:title>
<db:para>Discards the current result set and navigates to the next if available.</db:para>
<db:para>Some databases are capable of returning multiple result sets for stored procedures or SQL batches (a query strings that contains multiple statements). If multiple result sets are available after executing a query this function can be used to navigate to the next result set(s).</db:para>
<db:para>If a new result set is available this function will return true. The query will be repositioned on an <db:emphasis>invalid</db:emphasis> record in the new result set and must be navigated to a valid record before data values can be retrieved. If a new result set isn't available the function returns <db:code>false</db:code> and the query is set to inactive. In any case the old result set will be discarded.</db:para>
<db:para>When one of the statements is a non-select statement a count of affected rows may be available instead of a result set.</db:para>
<db:para>Note that some databases, i.e. Microsoft SQL Server, requires non-scrollable cursors when working with multiple result sets. Some databases may execute all statements at once while others may delay the execution until the result set is actually accessed, and some databases may have restrictions on which statements are allowed to be used in a SQL batch.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqldriver.xml#hasFeature">QSqlDriver::hasFeature</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#forwardOnly-prop">forwardOnly</db:link></db:member>
<db:member><db:link xlink:href="qsqlquery.xml#next">next</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isSelect">isSelect</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#numRowsAffected">numRowsAffected</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#lastError">lastError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="numRowsAffected">
<db:title>int QSqlQuery::numRowsAffected() const</db:title>
<db:para>Returns the number of rows affected by the result's SQL statement, or -1 if it cannot be determined. Note that for <db:code>SELECT</db:code> statements, the value is undefined; use <db:link xlink:href="qsqlquery.xml#size">size</db:link>() instead. If the query is not <db:link xlink:href="qsqlquery.xml#isActive">active</db:link>, -1 is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qsqldriver.xml#hasFeature">QSqlDriver::hasFeature</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="numericalPrecisionPolicy">
<db:title>QSql::NumericalPrecisionPolicy QSqlQuery::numericalPrecisionPolicy() const</db:title>
<db:para>Returns the numericalPrecisionPolicy.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qsqlquery.xml#numericalPrecisionPolicy-prop">numericalPrecisionPolicy</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#setNumericalPrecisionPolicy">setNumericalPrecisionPolicy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="prepare">
<db:title>bool QSqlQuery::prepare(const QString &amp;<db:emphasis>query</db:emphasis>)</db:title>
<db:para>Prepares the SQL query <db:code role="parameter">query</db:code> for execution. Returns <db:code>true</db:code> if the query is prepared successfully; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The query may contain placeholders for binding values. Both Oracle style colon-name (e.g., <db:code>:surname</db:code>), and ODBC style (<db:code>?</db:code>) placeholders are supported; but they cannot be mixed in the same query. See the <db:link xlink:href="qsqlquery.xml#qsqlquery-examples">Detailed Description</db:link> for examples.</db:para>
<db:para>Portability notes: Some databases choose to delay preparing a query until it is executed the first time. In this case, preparing a syntactically wrong query succeeds, but every consecutive <db:link xlink:href="qsqlquery.xml#exec">exec</db:link>() will fail. When the database does not support named placeholders directly, the placeholder can only contain characters in the range [a-zA-Z0-9_].</db:para>
<db:para>For SQLite, the query string can contain only one statement at a time. If more than one statement is given, the function returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">    QSqlQuery query;
    query.prepare(&quot;INSERT INTO person (id, forename, surname) &quot;
                  &quot;VALUES (:id, :forename, :surname)&quot;);
    query.bindValue(&quot;:id&quot;, 1001);
    query.bindValue(&quot;:forename&quot;, &quot;Bart&quot;);
    query.bindValue(&quot;:surname&quot;, &quot;Simpson&quot;);
    query.exec();
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#exec">exec</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#bindValue">bindValue</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#addBindValue">addBindValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="previous">
<db:title>bool QSqlQuery::previous()</db:title>
<db:para>Retrieves the previous record in the result, if available, and positions the query on the retrieved record. Note that the result must be in the <db:link xlink:href="qsqlquery.xml#isActive">active</db:link> state and <db:link xlink:href="qsqlquery.xml#isSelect">isSelect</db:link>() must return true before calling this function or it will do nothing and return false.</db:para>
<db:para>The following rules apply:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If the result is currently located before the first record, there is no change and false is returned.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the result is currently located after the last record, an attempt is made to retrieve the last record.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the result is somewhere in the middle, an attempt is made to retrieve the previous record.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>If the record could not be retrieved, the result is positioned before the first record and false is returned. If the record is successfully retrieved, true is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#next">next</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#seek">seek</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="record">
<db:title>QSqlRecord QSqlQuery::record() const</db:title>
<db:para>Returns a <db:link xlink:href="qsqlrecord.xml">QSqlRecord</db:link> containing the field information for the current query. If the query points to a valid row (<db:link xlink:href="qsqlquery.xml#isValid">isValid</db:link>() returns true), the record is populated with the row's values. An empty record is returned when there is no active query (<db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>() returns false).</db:para>
<db:para>To retrieve values from a query, <db:link xlink:href="qsqlquery.xml#value">value</db:link>() should be used since its index-based lookup is faster.</db:para>
<db:para>In the following example, a <db:code>SELECT * FROM</db:code> query is executed. Since the order of the columns is not defined, <db:link xlink:href="qsqlrecord.xml#indexOf">QSqlRecord::indexOf</db:link>() is used to obtain the index of a column.</db:para>
<db:programlisting language="cpp">QSqlQuery q(&quot;select * from employees&quot;);
QSqlRecord rec = q.record();

qDebug() &lt;&lt; &quot;Number of columns: &quot; &lt;&lt; rec.count();

int nameCol = rec.indexOf(&quot;name&quot;); // index of the field &quot;name&quot;
while (q.next())
    qDebug() &lt;&lt; q.value(nameCol).toString(); // output all names
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="result">
<db:title>const QSqlResult *QSqlQuery::result() const</db:title>
<db:para>Returns the result associated with the query.</db:para>
</db:section>
<db:section xml:id="seek">
<db:title>bool QSqlQuery::seek(int <db:emphasis>index</db:emphasis>, bool <db:emphasis>relative</db:emphasis> = false)</db:title>
<db:para>Retrieves the record at position <db:code role="parameter">index</db:code>, if available, and positions the query on the retrieved record. The first record is at position 0. Note that the query must be in an <db:link xlink:href="qsqlquery.xml#isActive">active</db:link> state and <db:link xlink:href="qsqlquery.xml#isSelect">isSelect</db:link>() must return true before calling this function.</db:para>
<db:para>If <db:code role="parameter">relative</db:code> is false (the default), the following rules apply:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If <db:code role="parameter">index</db:code> is negative, the result is positioned before the first record and false is returned.</db:para>
</db:listitem>
<db:listitem>
<db:para>Otherwise, an attempt is made to move to the record at position <db:code role="parameter">index</db:code>. If the record at position <db:code role="parameter">index</db:code> could not be retrieved, the result is positioned after the last record and false is returned. If the record is successfully retrieved, true is returned.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>If <db:code role="parameter">relative</db:code> is true, the following rules apply:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If the result is currently positioned before the first record and:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code role="parameter">index</db:code> is negative or zero, there is no change, and false is returned.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code role="parameter">index</db:code> is positive, an attempt is made to position the result at absolute position <db:code role="parameter">index</db:code> - 1, following the sames rule for non relative seek, above.</db:para>
</db:listitem>
</db:itemizedlist>
</db:listitem>
<db:listitem>
<db:para>If the result is currently positioned after the last record and:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code role="parameter">index</db:code> is positive or zero, there is no change, and false is returned.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code role="parameter">index</db:code> is negative, an attempt is made to position the result at <db:code role="parameter">index</db:code> + 1 relative position from last record, following the rule below.</db:para>
</db:listitem>
</db:itemizedlist>
</db:listitem>
<db:listitem>
<db:para>If the result is currently located somewhere in the middle, and the relative offset <db:code role="parameter">index</db:code> moves the result below zero, the result is positioned before the first record and false is returned.</db:para>
</db:listitem>
<db:listitem>
<db:para>Otherwise, an attempt is made to move to the record <db:code role="parameter">index</db:code> records ahead of the current record (or <db:code role="parameter">index</db:code> records behind the current record if <db:code role="parameter">index</db:code> is negative). If the record at offset <db:code role="parameter">index</db:code> could not be retrieved, the result is positioned after the last record if <db:code role="parameter">index</db:code> &gt;= 0, (or before the first record if <db:code role="parameter">index</db:code> is negative), and false is returned. If the record is successfully retrieved, true is returned.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#next">next</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#previous">previous</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setForwardOnly">
<db:title>void QSqlQuery::setForwardOnly(bool <db:emphasis>forward</db:emphasis>)</db:title>
<db:para>Sets <db:link xlink:href="qsqlquery.xml#forwardOnly-prop">forwardOnly</db:link> to <db:code role="parameter">forward</db:code>.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qsqlquery.xml#forwardOnly-prop">forwardOnly</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#isForwardOnly">isForwardOnly</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#forwardOnly-prop">forwardOnly</db:link></db:member>
<db:member><db:link xlink:href="qsqlquery.xml#next">next</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#seek">seek</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNumericalPrecisionPolicy">
<db:title>void QSqlQuery::setNumericalPrecisionPolicy(QSql::NumericalPrecisionPolicy <db:emphasis>precisionPolicy</db:emphasis>)</db:title>
<db:para>Sets <db:link xlink:href="qsqlquery.xml#numericalPrecisionPolicy">numericalPrecisionPolicy</db:link> to <db:code role="parameter">precisionPolicy</db:code>.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qsqlquery.xml#numericalPrecisionPolicy-prop">numericalPrecisionPolicy</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#numericalPrecisionPolicy">numericalPrecisionPolicy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPositionalBindingEnabled">
<db:title>[since 6.7] void QSqlQuery::setPositionalBindingEnabled(bool <db:emphasis>enable</db:emphasis>)</db:title>
<db:para>Sets <db:link xlink:href="qsqlquery.xml#positionalBindingEnabled-prop">positionalBindingEnabled</db:link> to <db:code role="parameter">enable</db:code>.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qsqlquery.xml#positionalBindingEnabled-prop">positionalBindingEnabled</db:link>. </db:para>
</db:note>
<db:para>This function was introduced in Qt 6.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#isPositionalBindingEnabled">isPositionalBindingEnabled</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#positionalBindingEnabled-prop">positionalBindingEnabled</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>int QSqlQuery::size() const</db:title>
<db:para>Returns the size of the result (number of rows returned), or -1 if the size cannot be determined or if the database does not support reporting information about query sizes. Note that for non-<db:code>SELECT</db:code> statements (<db:link xlink:href="qsqlquery.xml#isSelect">isSelect</db:link>() returns <db:code>false</db:code>), size() will return -1. If the query is not active (<db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>() returns <db:code>false</db:code>), -1 is returned.</db:para>
<db:para>To determine the number of rows affected by a non-<db:code>SELECT</db:code> statement, use <db:link xlink:href="qsqlquery.xml#numRowsAffected">numRowsAffected</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#numRowsAffected">numRowsAffected</db:link>()</db:member>
<db:member><db:link xlink:href="qsqldriver.xml#hasFeature">QSqlDriver::hasFeature</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>[noexcept, since 6.2] void QSqlQuery::swap(QSqlQuery &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps this query with <db:code role="parameter">other</db:code>. This operation is very fast and never fails.</db:para>
<db:para>This function was introduced in Qt 6.2.</db:para>
</db:section>
<db:section xml:id="value">
<db:title>QVariant QSqlQuery::value(int <db:emphasis>index</db:emphasis>) const</db:title>
<db:para>Returns the value of field <db:code role="parameter">index</db:code> in the current record.</db:para>
<db:para>The fields are numbered from left to right using the text of the <db:code>SELECT</db:code> statement, e.g. in</db:para>
<db:programlisting language="cpp">SELECT forename, surname FROM people;
</db:programlisting>
<db:para>field 0 is <db:code>forename</db:code> and field 1 is <db:code>surname</db:code>. Using <db:code>SELECT *</db:code> is not recommended because the order of the fields in the query is undefined.</db:para>
<db:para>An invalid <db:link xlink:href="qvariant.xml">QVariant</db:link> is returned if field <db:code role="parameter">index</db:code> does not exist, if the query is inactive, or if the query is positioned on an invalid record.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquery.xml#previous">previous</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#next">next</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#seek">seek</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isActive">isActive</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquery.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value-1">
<db:title>QVariant QSqlQuery::value(QAnyStringView <db:emphasis>name</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the value of the field called <db:code role="parameter">name</db:code> in the current record. If field <db:code role="parameter">name</db:code> does not exist an invalid variant is returned.</db:para>
<db:para>This overload is less efficient than <db:link xlink:href="qsqlquery.xml#value">value</db:link>()</db:para>
<db:note>
<db:para>In Qt versions prior to 6.8, this function took <db:link xlink:href="qstring.xml">QString</db:link>, not <db:link xlink:href="qanystringview.xml">QAnyStringView</db:link>.</db:para>
</db:note>
</db:section>
<db:section xml:id="operator-eq">
<db:title>[noexcept, since 6.2] QSqlQuery &amp;QSqlQuery::operator=(QSqlQuery &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this object.</db:para>
<db:para>This function was introduced in Qt 6.2.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QSqlQuery</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="QSqlQuery-3">
<db:title>[deprecated] QSqlQuery::QSqlQuery(const QSqlQuery &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:para><db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> cannot be meaningfully copied. Prepared statements, bound values and so on will not work correctly, depending on your database driver (for instance, changing the copy will affect the original). Treat <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> as a move-only type instead.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[deprecated] QSqlQuery &amp;QSqlQuery::operator=(const QSqlQuery &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Assigns <db:code role="parameter">other</db:code> to this object.</db:para>
<db:para><db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> cannot be meaningfully copied. Prepared statements, bound values and so on will not work correctly, depending on your database driver (for instance, changing the copy will affect the original). Treat <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> as a move-only type instead.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
