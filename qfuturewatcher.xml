<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QFutureWatcher Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QFutureWatcher</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.0.4 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> class allows monitoring a <db:link xlink:href="qfuture.xml">QFuture</db:link> using signals and slots.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QFutureWatcher</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QFutureWatcher is part of <db:simplelist><db:member>thread</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> provides information and notifications about a <db:link xlink:href="qfuture.xml">QFuture</db:link>. Use the <db:link xlink:href="qfuturewatcher.xml#setFuture">setFuture</db:link>() function to start watching a particular <db:link xlink:href="qfuture.xml">QFuture</db:link>. The <db:link xlink:href="qfuturewatcher.xml#future">future</db:link>() function returns the future set with <db:link xlink:href="qfuturewatcher.xml#setFuture">setFuture</db:link>().</db:para>
<db:para>For convenience, several of <db:link xlink:href="qfuture.xml">QFuture</db:link>'s functions are also available in <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link>: <db:link xlink:href="qfuturewatcher.xml#progressValue">progressValue</db:link>(), <db:link xlink:href="qfuturewatcher.xml#progressMinimum">progressMinimum</db:link>(), <db:link xlink:href="qfuturewatcher.xml#progressMaximum">progressMaximum</db:link>(), <db:link xlink:href="qfuturewatcher.xml#progressText">progressText</db:link>(), <db:link xlink:href="qfuturewatcher.xml#isStarted">isStarted</db:link>(), <db:link xlink:href="qfuturewatcher.xml#isFinished">isFinished</db:link>(), <db:link xlink:href="qfuturewatcher.xml#isRunning">isRunning</db:link>(), <db:link xlink:href="qfuturewatcher.xml#isCanceled">isCanceled</db:link>(), <db:link xlink:href="qfuturewatcher.xml#isSuspending">isSuspending</db:link>(), <db:link xlink:href="qfuturewatcher.xml#isSuspended">isSuspended</db:link>(), <db:link xlink:href="qfuturewatcher.xml#waitForFinished">waitForFinished</db:link>(), <db:link xlink:href="qfuturewatcher.xml#result">result</db:link>(), and <db:link xlink:href="qfuturewatcher.xml#resultAt">resultAt</db:link>(). The <db:link xlink:href="qfuturewatcher.xml#cancel">cancel</db:link>(), <db:link xlink:href="qfuturewatcher.xml#setSuspended">setSuspended</db:link>(), <db:link xlink:href="qfuturewatcher.xml#suspend">suspend</db:link>(), <db:link xlink:href="qfuturewatcher.xml#resume">resume</db:link>(), and <db:link xlink:href="qfuturewatcher.xml#toggleSuspended">toggleSuspended</db:link>() functions are slots in <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link>.</db:para>
<db:para>Status changes are reported via the <db:link xlink:href="qfuturewatcher.xml#started">started</db:link>(), <db:link xlink:href="qfuturewatcher.xml#finished">finished</db:link>(), <db:link xlink:href="qfuturewatcher.xml#canceled">canceled</db:link>(), <db:link xlink:href="qfuturewatcher.xml#suspending">suspending</db:link>(), <db:link xlink:href="qfuturewatcher.xml#suspended">suspended</db:link>(), <db:link xlink:href="qfuturewatcher.xml#resumed">resumed</db:link>(), <db:link xlink:href="qfuturewatcher.xml#resultReadyAt">resultReadyAt</db:link>(), and <db:link xlink:href="qfuturewatcher.xml#resultsReadyAt">resultsReadyAt</db:link>() signals. Progress information is provided from the <db:link xlink:href="qfuturewatcher.xml#progressRangeChanged">progressRangeChanged</db:link>(), void <db:link xlink:href="qfuturewatcher.xml#progressValueChanged">progressValueChanged</db:link>(), and <db:link xlink:href="qfuturewatcher.xml#progressTextChanged">progressTextChanged</db:link>() signals.</db:para>
<db:para>Throttling control is provided by the <db:link xlink:href="qfuturewatcher.xml#setPendingResultsLimit">setPendingResultsLimit</db:link>() function. When the number of pending <db:link xlink:href="qfuturewatcher.xml#resultReadyAt">resultReadyAt</db:link>() or <db:link xlink:href="qfuturewatcher.xml#resultsReadyAt">resultsReadyAt</db:link>() signals exceeds the limit, the computation represented by the future will be throttled automatically. The computation will resume once the number of pending signals drops below the limit.</db:para>
<db:para>Example: Starting a computation and getting a slot callback when it's finished:</db:para>
<db:programlisting language="cpp">// Instantiate the objects and connect to the finished signal.
MyClass myObject;
QFutureWatcher&amp;lt;int&amp;gt; watcher;
connect(&amp;amp;watcher, &amp;amp;QFutureWatcher&amp;lt;int&amp;gt;::finished, &amp;amp;myObject, &amp;amp;MyClass::handleFinished);

// Start the computation.
QFuture&amp;lt;int&amp;gt; future = QtConcurrent::run(...);
watcher.setFuture(future);
</db:programlisting>
<db:para>Be aware that not all running asynchronous computations can be canceled or suspended. For example, the future returned by QtConcurrent::run() cannot be canceled; but the future returned by QtConcurrent::mappedReduced() can.</db:para>
<db:para><db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link>&lt;void&gt; is specialized to not contain any of the result fetching functions. Any <db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;T&gt; can be watched by a <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link>&lt;void&gt; as well. This is useful if only status or progress information is needed; not the actual result data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qtconcurrent-index.xml">Qt Concurrent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QFutureWatcher">
<db:title>[explicit] QFutureWatcher::QFutureWatcher(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QFutureWatcher</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QFutureWatcher(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> with the given <db:code role="parameter">parent</db:code>. Until a future is set with <db:link xlink:href="qfuturewatcher.xml#setFuture">setFuture</db:link>(), the functions <db:link xlink:href="qfuturewatcher.xml#isStarted">isStarted</db:link>(), <db:link xlink:href="qfuturewatcher.xml#isCanceled">isCanceled</db:link>(), and <db:link xlink:href="qfuturewatcher.xml#isFinished">isFinished</db:link>() return true.</db:para>
</db:section>
<db:section xml:id="dtor.QFutureWatcher">
<db:title>[virtual] QFutureWatcher::~QFutureWatcher()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QFutureWatcher</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QFutureWatcher()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link>.</db:para>
</db:section>
<db:section xml:id="cancel">
<db:title>void QFutureWatcher::cancel()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>cancel</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void cancel()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Cancels the asynchronous computation represented by the <db:link xlink:href="qfuturewatcher.xml#future">future</db:link>(). Note that the cancelation is asynchronous. Use <db:link xlink:href="qfuturewatcher.xml#waitForFinished">waitForFinished</db:link>() after calling cancel() when you need synchronous cancelation.</db:para>
<db:para>Currently available results may still be accessed on a canceled <db:link xlink:href="qfuture.xml">QFuture</db:link>, but new results will <db:emphasis>not</db:emphasis> become available after calling this function. Also, this <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> will not deliver progress and result ready signals once canceled. This includes the <db:link xlink:href="qfuturewatcher.xml#progressValueChanged">progressValueChanged</db:link>(), <db:link xlink:href="qfuturewatcher.xml#progressRangeChanged">progressRangeChanged</db:link>(), <db:link xlink:href="qfuturewatcher.xml#progressTextChanged">progressTextChanged</db:link>(), <db:link xlink:href="qfuturewatcher.xml#resultReadyAt">resultReadyAt</db:link>(), and <db:link xlink:href="qfuturewatcher.xml#resultsReadyAt">resultsReadyAt</db:link>() signals.</db:para>
<db:para>Be aware that not all running asynchronous computations can be canceled. For example, the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned by QtConcurrent::run() cannot be canceled; but the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned by QtConcurrent::mappedReduced() can.</db:para>
</db:section>
<db:section xml:id="canceled">
<db:title>void QFutureWatcher::canceled()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>canceled</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void canceled()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted if the watched future is canceled.</db:para>
</db:section>
<db:section xml:id="finished">
<db:title>void QFutureWatcher::finished()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>finished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void finished()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the watched future finishes.</db:para>
</db:section>
<db:section xml:id="future">
<db:title>QFuture&lt;T&gt; QFutureWatcher::future() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>future</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; future() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the watched future.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#setFuture">setFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isCanceled">
<db:title>bool QFutureWatcher::isCanceled() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isCanceled</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isCanceled() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation has been canceled with the <db:link xlink:href="qfuturewatcher.xml#cancel">cancel</db:link>() function, or if no future has been set; otherwise returns false.</db:para>
<db:para>Be aware that the computation may still be running even though this function returns true. See <db:link xlink:href="qfuturewatcher.xml#cancel">cancel</db:link>() for more details.</db:para>
</db:section>
<db:section xml:id="isFinished">
<db:title>bool QFutureWatcher::isFinished() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFinished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFinished() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation represented by the <db:link xlink:href="qfuturewatcher.xml#future">future</db:link>() has finished, or if no future has been set; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="isRunning">
<db:title>bool QFutureWatcher::isRunning() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isRunning</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isRunning() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation represented by the <db:link xlink:href="qfuturewatcher.xml#future">future</db:link>() is currently running; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="isStarted">
<db:title>bool QFutureWatcher::isStarted() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isStarted</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isStarted() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation represented by the <db:link xlink:href="qfuturewatcher.xml#future">future</db:link>() has been started, or if no future has been set; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="isSuspended">
<db:title>[since 6.0] bool QFutureWatcher::isSuspended() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSuspended</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSuspended() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if a suspension of the asynchronous computation has been requested, and it is in effect, meaning that no more results or progress changes are expected.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#suspended">suspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#setSuspended">setSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#isSuspending">isSuspending</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSuspending">
<db:title>[since 6.0] bool QFutureWatcher::isSuspending() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSuspending</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSuspending() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the asynchronous computation has been suspended with the <db:link xlink:href="qfuturewatcher.xml#suspend">suspend</db:link>() function, but the work is not yet suspended, and computation is still running. Returns false otherwise.</db:para>
<db:para>To check if suspension is actually in effect, use <db:link xlink:href="qfuturewatcher.xml#isSuspended">isSuspended</db:link>() instead.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#setSuspended">setSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#toggleSuspended">toggleSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#isSuspended">isSuspended</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressMaximum">
<db:title>int QFutureWatcher::progressMaximum() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressMaximum</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressMaximum() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum <db:link xlink:href="qfuturewatcher.xml#progressValue">progressValue</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#progressValue">progressValue</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#progressMinimum">progressMinimum</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressMinimum">
<db:title>int QFutureWatcher::progressMinimum() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressMinimum</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressMinimum() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the minimum <db:link xlink:href="qfuturewatcher.xml#progressValue">progressValue</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#progressValue">progressValue</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#progressMaximum">progressMaximum</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressRangeChanged">
<db:title>void QFutureWatcher::progressRangeChanged(int <db:emphasis>minimum</db:emphasis>, int <db:emphasis>maximum</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>progressRangeChanged</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>minimum</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>maximum</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void progressRangeChanged(int minimum, int maximum)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The progress range for the watched future has changed to <db:code role="parameter">minimum</db:code> and <db:code role="parameter">maximum</db:code></db:para>
</db:section>
<db:section xml:id="progressText">
<db:title>QString QFutureWatcher::progressText() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>progressText</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString progressText() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the (optional) textual representation of the progress as reported by the asynchronous computation.</db:para>
<db:para>Be aware that not all computations provide a textual representation of the progress, and as such, this function may return an empty string.</db:para>
</db:section>
<db:section xml:id="progressTextChanged">
<db:title>void QFutureWatcher::progressTextChanged(const QString &amp;<db:emphasis>progressText</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>progressTextChanged</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>progressText</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void progressTextChanged(const QString &amp;progressText)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the watched future reports textual progress information, <db:code role="parameter">progressText</db:code>.</db:para>
</db:section>
<db:section xml:id="progressValue">
<db:title>int QFutureWatcher::progressValue() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>progressValue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int progressValue() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current progress value, which is between the <db:link xlink:href="qfuturewatcher.xml#progressMinimum">progressMinimum</db:link>() and <db:link xlink:href="qfuturewatcher.xml#progressMaximum">progressMaximum</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#progressMinimum">progressMinimum</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#progressMaximum">progressMaximum</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="progressValueChanged">
<db:title>void QFutureWatcher::progressValueChanged(int <db:emphasis>progressValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>progressValueChanged</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>progressValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void progressValueChanged(int progressValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the watched future reports progress, <db:code role="parameter">progressValue</db:code> gives the current progress. In order to avoid overloading the GUI event loop, <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> limits the progress signal emission rate. This means that listeners connected to this slot might not get all progress reports the future makes. The last progress update (where <db:code role="parameter">progressValue</db:code> equals the maximum value) will always be delivered.</db:para>
</db:section>
<db:section xml:id="result">
<db:title>T QFutureWatcher::result() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>result</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T result() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the first result in the <db:link xlink:href="qfuturewatcher.xml#future">future</db:link>(). If the result is not immediately available, this function will block and wait for the result to become available. This is a convenience method for calling <db:link xlink:href="qfuturewatcher.xml#resultAt">resultAt</db:link>(0).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#resultAt">resultAt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resultAt">
<db:title>T QFutureWatcher::resultAt(int <db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>resultAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T resultAt(int index) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the result at <db:code role="parameter">index</db:code> in the <db:link xlink:href="qfuturewatcher.xml#future">future</db:link>(). If the result is not immediately available, this function will block and wait for the result to become available.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#result">result</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resultReadyAt">
<db:title>void QFutureWatcher::resultReadyAt(int <db:emphasis>index</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resultReadyAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resultReadyAt(int index)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the watched future reports a ready result at <db:code role="parameter">index</db:code>. If the future reports multiple results, the index will indicate which one it is. Results can be reported out-of-order. To get the result, call <db:link xlink:href="qfuturewatcher.xml#resultAt">resultAt</db:link>(index);</db:para>
</db:section>
<db:section xml:id="resultsReadyAt">
<db:title>void QFutureWatcher::resultsReadyAt(int <db:emphasis>beginIndex</db:emphasis>, int <db:emphasis>endIndex</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resultsReadyAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>beginIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>endIndex</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resultsReadyAt(int beginIndex, int endIndex)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the watched future reports ready results. The results are indexed from <db:code role="parameter">beginIndex</db:code> to <db:code role="parameter">endIndex</db:code>.</db:para>
</db:section>
<db:section xml:id="resume">
<db:title>void QFutureWatcher::resume()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resume</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resume()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Resumes the asynchronous computation represented by the <db:link xlink:href="qfuturewatcher.xml#future">future</db:link>(). This is a convenience method that simply calls <db:link xlink:href="qfuturewatcher.xml#setSuspended">setSuspended</db:link>(false).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#suspend">suspend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resumed">
<db:title>void QFutureWatcher::resumed()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resumed</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resumed()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the watched future is resumed.</db:para>
</db:section>
<db:section xml:id="setFuture">
<db:title>void QFutureWatcher::setFuture(const QFuture&lt;T&gt; &amp;<db:emphasis>future</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFuture</db:methodname>
<db:methodparam>
<db:type>const QFuture&lt;T&gt; &amp;</db:type>
<db:parameter>future</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFuture(const QFuture&lt;T&gt; &amp;future)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Starts watching the given <db:code role="parameter">future</db:code>.</db:para>
<db:para>One of the signals might be emitted for the current state of the <db:code role="parameter">future</db:code>. For example, if the future is already stopped, the finished signal will be emitted.</db:para>
<db:para>To avoid a race condition, it is important to call this function <db:emphasis>after</db:emphasis> doing the connections.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#future">future</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPendingResultsLimit">
<db:title>void QFutureWatcher::setPendingResultsLimit(int <db:emphasis>limit</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPendingResultsLimit</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>limit</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPendingResultsLimit(int limit)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The setPendingResultsLimit() provides throttling control. When the number of pending <db:link xlink:href="qfuturewatcher.xml#resultReadyAt">resultReadyAt</db:link>() or <db:link xlink:href="qfuturewatcher.xml#resultsReadyAt">resultsReadyAt</db:link>() signals exceeds the <db:code role="parameter">limit</db:code>, the computation represented by the future will be throttled automatically. The computation will resume once the number of pending signals drops below the <db:code role="parameter">limit</db:code>.</db:para>
</db:section>
<db:section xml:id="setSuspended">
<db:title>[since 6.0] void QFutureWatcher::setSuspended(bool <db:emphasis>suspend</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSuspended</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>suspend</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSuspended(bool suspend)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">suspend</db:code> is true, this function suspends the asynchronous computation represented by the <db:link xlink:href="qfuturewatcher.xml#future">future</db:link>(). If the computation is already suspended, this function does nothing. <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> will not immediately stop delivering progress and result ready signals when the future is suspended. At the moment of suspending there may still be computations that are in progress and cannot be stopped. Signals for such computations will still be delivered.</db:para>
<db:para>If <db:code role="parameter">suspend</db:code> is false, this function resumes the asynchronous computation. If the computation was not previously suspended, this function does nothing.</db:para>
<db:para>Be aware that not all computations can be suspended. For example, the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned by QtConcurrent::run() cannot be suspended; but the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned by QtConcurrent::mappedReduced() can.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#suspended">suspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#suspend">suspend</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#resume">resume</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#toggleSuspended">toggleSuspended</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="started">
<db:title>void QFutureWatcher::started()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>started</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void started()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when this <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> starts watching the future set with <db:link xlink:href="qfuturewatcher.xml#setFuture">setFuture</db:link>().</db:para>
</db:section>
<db:section xml:id="suspend">
<db:title>[since 6.0] void QFutureWatcher::suspend()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>suspend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void suspend()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Suspends the asynchronous computation represented by this future. This is a convenience method that simply calls <db:link xlink:href="qfuturewatcher.xml#setSuspended">setSuspended</db:link>(true).</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="suspended">
<db:title>[since 6.0] void QFutureWatcher::suspended()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>suspended</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void suspended()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when <db:link xlink:href="qfuturewatcher.xml#suspend">suspend</db:link>() took effect, meaning that there are no more running computations. After receiving this signal no more result ready or progress reporting signals are expected.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#setSuspended">setSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#suspend">suspend</db:link>()</db:member>
<db:member>suspended()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="suspending">
<db:title>[since 6.0] void QFutureWatcher::suspending()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>suspending</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void suspending()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the state of the watched future is set to suspended.</db:para>
<db:note>
<db:para>This signal only informs that suspension has been requested. It doesn't indicate that all background operations are stopped. Signals for computations that were in progress at the moment of suspending will still be delivered. To be informed when suspension actually took effect, use the <db:link xlink:href="qfuturewatcher.xml#suspended">suspended</db:link>() signal.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#setSuspended">setSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#suspend">suspend</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#suspended">suspended</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toggleSuspended">
<db:title>[since 6.0] void QFutureWatcher::toggleSuspended()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>toggleSuspended</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void toggleSuspended()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Toggles the suspended state of the asynchronous computation. In other words, if the computation is currently suspending or suspended, calling this function resumes it; if the computation is running, it is suspended. This is a convenience method for calling <db:link xlink:href="qfuturewatcher.xml#setSuspended">setSuspended</db:link>(!(<db:link xlink:href="qfuturewatcher.xml#isSuspending">isSuspending</db:link>() || <db:link xlink:href="qfuturewatcher.xml#isSuspended">isSuspended</db:link>())).</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#setSuspended">setSuspended</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#suspend">suspend</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForFinished">
<db:title>void QFutureWatcher::waitForFinished()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>waitForFinished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void waitForFinished()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Waits for the asynchronous computation to finish (including <db:link xlink:href="qfuturewatcher.xml#cancel">cancel</db:link>()ed computations), i.e. until <db:link xlink:href="qfuturewatcher.xml#isFinished">isFinished</db:link>() returns true.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QFutureWatcher</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="isPaused">
<db:title>bool QFutureWatcher::isPaused() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isPaused</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isPaused() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuturewatcher.xml#isSuspending">isSuspending</db:link>() or <db:link xlink:href="qfuturewatcher.xml#isSuspended">isSuspended</db:link>() instead.</db:para>
<db:para>Returns true if the asynchronous computation has been paused with the <db:link xlink:href="qfuturewatcher.xml#pause">pause</db:link>() function; otherwise returns false.</db:para>
<db:para>Be aware that the computation may still be running even though this function returns true. See <db:link xlink:href="qfuturewatcher.xml#setPaused">setPaused</db:link>() for more details. To check if pause actually took effect, use <db:link xlink:href="qfuturewatcher.xml#isSuspended">isSuspended</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#setPaused">setPaused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#togglePaused">togglePaused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#isSuspended">isSuspended</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pause">
<db:title>void QFutureWatcher::pause()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pause</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pause()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuturewatcher.xml#suspend">suspend</db:link>() instead.</db:para>
<db:para>Pauses the asynchronous computation represented by the <db:link xlink:href="qfuturewatcher.xml#future">future</db:link>(). This is a convenience method that simply calls <db:link xlink:href="qfuturewatcher.xml#setPaused">setPaused</db:link>(true).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="paused">
<db:title>void QFutureWatcher::paused()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>paused</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void paused()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuturewatcher.xml#suspending">suspending</db:link>() instead.</db:para>
<db:para>This signal is emitted when the state of the watched future is set to paused.</db:para>
<db:note>
<db:para>This signal only informs that pause has been requested. It doesn't indicate that all background operations are stopped. Signals for computations that were in progress at the moment of pausing will still be delivered. To to be informed when <db:link xlink:href="qfuturewatcher.xml#pause">pause</db:link>() actually took effect, use the <db:link xlink:href="qfuturewatcher.xml#suspended">suspended</db:link>() signal.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#setPaused">setPaused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#pause">pause</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#suspended">suspended</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPaused">
<db:title>void QFutureWatcher::setPaused(bool <db:emphasis>paused</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPaused</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>paused</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPaused(bool paused)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuturewatcher.xml#setSuspended">setSuspended</db:link>() instead.</db:para>
<db:para>If <db:code role="parameter">paused</db:code> is true, this function pauses the asynchronous computation represented by the <db:link xlink:href="qfuturewatcher.xml#future">future</db:link>(). If the computation is already paused, this function does nothing. <db:link xlink:href="qfuturewatcher.xml">QFutureWatcher</db:link> will not immediately stop delivering progress and result ready signals when the future is paused. At the moment of pausing there may still be computations that are in progress and cannot be stopped. Signals for such computations will still be delivered after pause.</db:para>
<db:para>If <db:code role="parameter">paused</db:code> is false, this function resumes the asynchronous computation. If the computation was not previously paused, this function does nothing.</db:para>
<db:para>Be aware that not all computations can be paused. For example, the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned by QtConcurrent::run() cannot be paused; but the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned by QtConcurrent::mappedReduced() can.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#paused">paused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#pause">pause</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#resume">resume</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#togglePaused">togglePaused</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="togglePaused">
<db:title>void QFutureWatcher::togglePaused()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>togglePaused</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void togglePaused()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qfuturewatcher.xml#toggleSuspended">toggleSuspended</db:link>() instead.</db:para>
<db:para>Toggles the paused state of the asynchronous computation. In other words, if the computation is currently paused, calling this function resumes it; if the computation is running, it is paused. This is a convenience method for calling <db:link xlink:href="qfuturewatcher.xml#setPaused">setPaused</db:link>(!<db:link xlink:href="qfuturewatcher.xml#isPaused">isPaused</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuturewatcher.xml#setPaused">setPaused</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#pause">pause</db:link>()</db:member>
<db:member><db:link xlink:href="qfuturewatcher.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
