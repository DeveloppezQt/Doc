<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Vector Deformation</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Demonstrates how to manipulate the elements of a <db:link xlink:href="qpainterpath.xml">QPainterPath</db:link>.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the demonstration applications of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;pathdeform.h&quot;

#include &amp;lt;QGuiApplication&amp;gt;
#include &amp;lt;QScreen&amp;gt;
#include &amp;lt;QtDebug&amp;gt;
#include &amp;lt;QMouseEvent&amp;gt;
#include &amp;lt;QTimerEvent&amp;gt;
#include &amp;lt;QLayout&amp;gt;
#include &amp;lt;QLineEdit&amp;gt;
#include &amp;lt;QPainter&amp;gt;
#include &amp;lt;QSlider&amp;gt;
#include &amp;lt;QLabel&amp;gt;
#include &amp;lt;QDesktopWidget&amp;gt;
#include &amp;lt;qmath.h&amp;gt;

PathDeformControls::PathDeformControls(QWidget *parent,
                                       PathDeformRenderer* renderer, bool smallScreen)
      : QWidget(parent)
{
    m_renderer = renderer;

    if (smallScreen)
        layoutForSmallScreen();
    else
        layoutForDesktop();
}

void PathDeformControls::layoutForDesktop()
{
    QGroupBox* mainGroup = new QGroupBox(this);
    mainGroup-&amp;gt;setTitle(tr(&quot;Controls&quot;));

    QGroupBox *radiusGroup = new QGroupBox(mainGroup);
    radiusGroup-&amp;gt;setTitle(tr(&quot;Lens Radius&quot;));
    QSlider *radiusSlider = new QSlider(Qt::Horizontal, radiusGroup);
    radiusSlider-&amp;gt;setRange(15, 150);
    radiusSlider-&amp;gt;setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);

    QGroupBox *deformGroup = new QGroupBox(mainGroup);
    deformGroup-&amp;gt;setTitle(tr(&quot;Deformation&quot;));
    QSlider *deformSlider = new QSlider(Qt::Horizontal, deformGroup);
    deformSlider-&amp;gt;setRange(-100, 100);
    deformSlider-&amp;gt;setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);

    QGroupBox *fontSizeGroup = new QGroupBox(mainGroup);
    fontSizeGroup-&amp;gt;setTitle(tr(&quot;Font Size&quot;));
    QSlider *fontSizeSlider = new QSlider(Qt::Horizontal, fontSizeGroup);
    fontSizeSlider-&amp;gt;setRange(16, 200);
    fontSizeSlider-&amp;gt;setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);

    QGroupBox *textGroup = new QGroupBox(mainGroup);
    textGroup-&amp;gt;setTitle(tr(&quot;Text&quot;));
    QLineEdit *textInput = new QLineEdit(textGroup);

    QPushButton *animateButton = new QPushButton(mainGroup);
    animateButton-&amp;gt;setText(tr(&quot;Animated&quot;));
    animateButton-&amp;gt;setCheckable(true);

    QPushButton *showSourceButton = new QPushButton(mainGroup);
    showSourceButton-&amp;gt;setText(tr(&quot;Show Source&quot;));

#if QT_CONFIG(opengl)
    QPushButton *enableOpenGLButton = new QPushButton(mainGroup);
    enableOpenGLButton-&amp;gt;setText(tr(&quot;Use OpenGL&quot;));
    enableOpenGLButton-&amp;gt;setCheckable(true);
    enableOpenGLButton-&amp;gt;setChecked(m_renderer-&amp;gt;usesOpenGL());
#endif

    QPushButton *whatsThisButton = new QPushButton(mainGroup);
    whatsThisButton-&amp;gt;setText(tr(&quot;What's This?&quot;));
    whatsThisButton-&amp;gt;setCheckable(true);

    mainGroup-&amp;gt;setFixedWidth(180);

    QVBoxLayout *mainGroupLayout = new QVBoxLayout(mainGroup);
    mainGroupLayout-&amp;gt;addWidget(radiusGroup);
    mainGroupLayout-&amp;gt;addWidget(deformGroup);
    mainGroupLayout-&amp;gt;addWidget(fontSizeGroup);
    mainGroupLayout-&amp;gt;addWidget(textGroup);
    mainGroupLayout-&amp;gt;addWidget(animateButton);
    mainGroupLayout-&amp;gt;addStretch(1);
#if QT_CONFIG(opengl)
    mainGroupLayout-&amp;gt;addWidget(enableOpenGLButton);
#endif
    mainGroupLayout-&amp;gt;addWidget(showSourceButton);
    mainGroupLayout-&amp;gt;addWidget(whatsThisButton);

    QVBoxLayout *radiusGroupLayout = new QVBoxLayout(radiusGroup);
    radiusGroupLayout-&amp;gt;addWidget(radiusSlider);

    QVBoxLayout *deformGroupLayout = new QVBoxLayout(deformGroup);
    deformGroupLayout-&amp;gt;addWidget(deformSlider);

    QVBoxLayout *fontSizeGroupLayout = new QVBoxLayout(fontSizeGroup);
    fontSizeGroupLayout-&amp;gt;addWidget(fontSizeSlider);

    QVBoxLayout *textGroupLayout = new QVBoxLayout(textGroup);
    textGroupLayout-&amp;gt;addWidget(textInput);

    QVBoxLayout * mainLayout = new QVBoxLayout(this);
    mainLayout-&amp;gt;addWidget(mainGroup);
    mainLayout-&amp;gt;setMargin(0);

    connect(radiusSlider, SIGNAL(valueChanged(int)), m_renderer, SLOT(setRadius(int)));
    connect(deformSlider, SIGNAL(valueChanged(int)), m_renderer, SLOT(setIntensity(int)));
    connect(fontSizeSlider, SIGNAL(valueChanged(int)), m_renderer, SLOT(setFontSize(int)));
    connect(animateButton, SIGNAL(clicked(bool)), m_renderer, SLOT(setAnimated(bool)));
#if QT_CONFIG(opengl)
    connect(enableOpenGLButton, SIGNAL(clicked(bool)), m_renderer, SLOT(enableOpenGL(bool)));
#endif

    connect(textInput, SIGNAL(textChanged(QString)), m_renderer, SLOT(setText(QString)));
    connect(m_renderer, SIGNAL(descriptionEnabledChanged(bool)),
            whatsThisButton, SLOT(setChecked(bool)));
    connect(whatsThisButton, SIGNAL(clicked(bool)), m_renderer, SLOT(setDescriptionEnabled(bool)));
    connect(showSourceButton, SIGNAL(clicked()), m_renderer, SLOT(showSource()));

    animateButton-&amp;gt;animateClick();
    deformSlider-&amp;gt;setValue(80);
    fontSizeSlider-&amp;gt;setValue(120);
    radiusSlider-&amp;gt;setValue(100);
    textInput-&amp;gt;setText(tr(&quot;Qt&quot;));
}

void PathDeformControls::layoutForSmallScreen()
{
    QGroupBox* mainGroup = new QGroupBox(this);
    mainGroup-&amp;gt;setTitle(tr(&quot;Controls&quot;));

    QLabel *radiusLabel = new QLabel(mainGroup);
    radiusLabel-&amp;gt;setText(tr(&quot;Lens Radius:&quot;));
    QSlider *radiusSlider = new QSlider(Qt::Horizontal, mainGroup);
    radiusSlider-&amp;gt;setRange(15, 150);
    radiusSlider-&amp;gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);

    QLabel *deformLabel = new QLabel(mainGroup);
    deformLabel-&amp;gt;setText(tr(&quot;Deformation:&quot;));
    QSlider *deformSlider = new QSlider(Qt::Horizontal, mainGroup);
    deformSlider-&amp;gt;setRange(-100, 100);
    deformSlider-&amp;gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);

    QLabel *fontSizeLabel = new QLabel(mainGroup);
    fontSizeLabel-&amp;gt;setText(tr(&quot;Font Size:&quot;));
    QSlider *fontSizeSlider = new QSlider(Qt::Horizontal, mainGroup);
    fontSizeSlider-&amp;gt;setRange(16, 200);
    fontSizeSlider-&amp;gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);

    QPushButton *animateButton = new QPushButton(tr(&quot;Animated&quot;), mainGroup);
    animateButton-&amp;gt;setCheckable(true);

#if QT_CONFIG(opengl)
    QPushButton *enableOpenGLButton = new QPushButton(mainGroup);
    enableOpenGLButton-&amp;gt;setText(tr(&quot;Use OpenGL&quot;));
    enableOpenGLButton-&amp;gt;setCheckable(mainGroup);
    enableOpenGLButton-&amp;gt;setChecked(m_renderer-&amp;gt;usesOpenGL());
#endif

    QPushButton *quitButton = new QPushButton(tr(&quot;Quit&quot;), mainGroup);
    QPushButton *okButton = new QPushButton(tr(&quot;OK&quot;), mainGroup);

    QGridLayout *mainGroupLayout = new QGridLayout(mainGroup);
    mainGroupLayout-&amp;gt;setMargin(0);
    mainGroupLayout-&amp;gt;addWidget(radiusLabel, 0, 0, Qt::AlignRight);
    mainGroupLayout-&amp;gt;addWidget(radiusSlider, 0, 1);
    mainGroupLayout-&amp;gt;addWidget(deformLabel, 1, 0, Qt::AlignRight);
    mainGroupLayout-&amp;gt;addWidget(deformSlider, 1, 1);
    mainGroupLayout-&amp;gt;addWidget(fontSizeLabel, 2, 0, Qt::AlignRight);
    mainGroupLayout-&amp;gt;addWidget(fontSizeSlider, 2, 1);
    mainGroupLayout-&amp;gt;addWidget(animateButton, 3,0, 1,2);
#if QT_CONFIG(opengl)
    mainGroupLayout-&amp;gt;addWidget(enableOpenGLButton, 4,0, 1,2);
#endif

    QVBoxLayout *mainLayout = new QVBoxLayout(this);
    mainLayout-&amp;gt;addWidget(mainGroup);
    mainLayout-&amp;gt;addStretch(1);
    mainLayout-&amp;gt;addWidget(okButton);
    mainLayout-&amp;gt;addWidget(quitButton);

    connect(quitButton, SIGNAL(clicked()), this, SIGNAL(quitPressed()));
    connect(okButton, SIGNAL(clicked()), this, SIGNAL(okPressed()));
    connect(radiusSlider, SIGNAL(valueChanged(int)), m_renderer, SLOT(setRadius(int)));
    connect(deformSlider, SIGNAL(valueChanged(int)), m_renderer, SLOT(setIntensity(int)));
    connect(fontSizeSlider, SIGNAL(valueChanged(int)), m_renderer, SLOT(setFontSize(int)));
    connect(animateButton, SIGNAL(clicked(bool)), m_renderer, SLOT(setAnimated(bool)));
#if QT_CONFIG(opengl)
    connect(enableOpenGLButton, SIGNAL(clicked(bool)), m_renderer, SLOT(enableOpenGL(bool)));
#endif

    animateButton-&amp;gt;animateClick();
    deformSlider-&amp;gt;setValue(80);
    fontSizeSlider-&amp;gt;setValue(120);

    QRect screen_size = QGuiApplication::primaryScreen()-&amp;gt;geometry();
    radiusSlider-&amp;gt;setValue(qMin(screen_size.width(), screen_size.height())/5);

    m_renderer-&amp;gt;setText(tr(&quot;Qt&quot;));
}

PathDeformWidget::PathDeformWidget(QWidget *parent, bool smallScreen)
    : QWidget(parent)
{
    setWindowTitle(tr(&quot;Vector Deformation&quot;));

    m_renderer = new PathDeformRenderer(this, smallScreen);
    m_renderer-&amp;gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);

    // Layouts
    QHBoxLayout *mainLayout = new QHBoxLayout(this);
    mainLayout-&amp;gt;addWidget(m_renderer);

    m_controls = new PathDeformControls(0, m_renderer, smallScreen);
    m_controls-&amp;gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Minimum);

    if (!smallScreen)
        mainLayout-&amp;gt;addWidget(m_controls);

    m_renderer-&amp;gt;loadSourceFile(&quot;:res/deform/pathdeform.cpp&quot;);
    m_renderer-&amp;gt;loadDescription(&quot;:res/deform/pathdeform.html&quot;);
    m_renderer-&amp;gt;setDescriptionEnabled(false);

    connect(m_renderer, SIGNAL(clicked()), this, SLOT(showControls()));
    connect(m_controls, SIGNAL(okPressed()), this, SLOT(hideControls()));
    connect(m_controls, SIGNAL(quitPressed()), QCoreApplication::instance(), SLOT(quit()));
}

void PathDeformWidget::showControls()
{
    m_controls-&amp;gt;showFullScreen();
}

void PathDeformWidget::hideControls()
{
    m_controls-&amp;gt;hide();
}

void PathDeformWidget::setStyle( QStyle * style )
{
    QWidget::setStyle(style);
    if (m_controls == 0)
        return;

    m_controls-&amp;gt;setStyle(style);

    QList&amp;lt;QWidget *&amp;gt; widgets = m_controls-&amp;gt;findChildren&amp;lt;QWidget *&amp;gt;();
    foreach (QWidget *w, widgets)
        w-&amp;gt;setStyle(style);
}

static inline QRect circle_bounds(const QPointF &amp;amp;center, qreal radius, qreal compensation)
{
    return QRect(qRound(center.x() - radius - compensation),
                 qRound(center.y() - radius - compensation),
                 qRound((radius + compensation) * 2),
                 qRound((radius + compensation) * 2));

}

const int LENS_EXTENT = 10;

PathDeformRenderer::PathDeformRenderer(QWidget *widget, bool smallScreen)
    : ArthurFrame(widget)
{
    m_radius = 100;
    m_pos = QPointF(m_radius, m_radius);
    m_direction = QPointF(1, 1);
    m_fontSize = 24;
    m_animated = true;
    m_repaintTimer.start(25, this);
    m_repaintTracker.start();
    m_intensity = 100;
    m_smallScreen = smallScreen;

//     m_fpsTimer.start(1000, this);
//     m_fpsCounter = 0;

    generateLensPixmap();
}

void PathDeformRenderer::setText(const QString &amp;amp;text)
{
    m_text = text;

    QFont f(&quot;times new roman,utopia&quot;);
    f.setStyleStrategy(QFont::ForceOutline);
    f.setPointSize(m_fontSize);
    f.setStyleHint(QFont::Times);

    QFontMetrics fm(f);

    m_paths.clear();
    m_pathBounds = QRect();

    QPointF advance(0, 0);

    bool do_quick = true;
    for (int i=0; i&amp;lt;text.size(); ++i) {
        if (text.at(i).unicode() &amp;gt;= 0x4ff &amp;amp;&amp;amp; text.at(i).unicode() &amp;lt;= 0x1e00) {
            do_quick = false;
            break;
        }
    }

    if (do_quick) {
        for (int i=0; i&amp;lt;text.size(); ++i) {
            QPainterPath path;
            path.addText(advance, f, text.mid(i, 1));
            m_pathBounds |= path.boundingRect();
            m_paths &amp;lt;&amp;lt; path;
            advance += QPointF(fm.horizontalAdvance(text.mid(i, 1)), 0);
        }
    } else {
        QPainterPath path;
        path.addText(advance, f, text);
        m_pathBounds |= path.boundingRect();
        m_paths &amp;lt;&amp;lt; path;
    }

    for (int i=0; i&amp;lt;m_paths.size(); ++i)
        m_paths[i] = m_paths[i] * QMatrix(1, 0, 0, 1, -m_pathBounds.x(), -m_pathBounds.y());

    update();
}

void PathDeformRenderer::generateLensPixmap()
{
    qreal rad = m_radius + LENS_EXTENT;

    QRect bounds = circle_bounds(QPointF(), rad, 0);

    QPainter painter;

    if (preferImage()) {
        m_lens_image = QImage(bounds.size(), QImage::Format_ARGB32_Premultiplied);
        m_lens_image.fill(0);
        painter.begin(&amp;amp;m_lens_image);
    } else {
        m_lens_pixmap = QPixmap(bounds.size());
        m_lens_pixmap.fill(Qt::transparent);
        painter.begin(&amp;amp;m_lens_pixmap);
    }

    QRadialGradient gr(rad, rad, rad, 3 * rad / 5, 3 * rad / 5);
    gr.setColorAt(0.0, QColor(255, 255, 255, 191));
    gr.setColorAt(0.2, QColor(255, 255, 127, 191));
    gr.setColorAt(0.9, QColor(150, 150, 200, 63));
    gr.setColorAt(0.95, QColor(0, 0, 0, 127));
    gr.setColorAt(1, QColor(0, 0, 0, 0));
    painter.setRenderHint(QPainter::Antialiasing);
    painter.setBrush(gr);
    painter.setPen(Qt::NoPen);
    painter.drawEllipse(0, 0, bounds.width(), bounds.height());
}

void PathDeformRenderer::setAnimated(bool animated)
{
    m_animated = animated;

    if (m_animated) {
//         m_fpsTimer.start(1000, this);
//         m_fpsCounter = 0;
        m_repaintTimer.start(25, this);
        m_repaintTracker.start();
    } else {
//         m_fpsTimer.stop();
        m_repaintTimer.stop();
    }
}

void PathDeformRenderer::timerEvent(QTimerEvent *e)
{

    if (e-&amp;gt;timerId() == m_repaintTimer.timerId()) {

        if (QLineF(QPointF(0,0), m_direction).length() &amp;gt; 1)
            m_direction *= 0.995;
        qreal time = m_repaintTracker.restart();

        QRect rectBefore = circle_bounds(m_pos, m_radius, m_fontSize);

        qreal dx = m_direction.x();
        qreal dy = m_direction.y();
        if (time &amp;gt; 0) {
            dx = dx * time * .1;
            dy = dy * time * .1;
        }

        m_pos += QPointF(dx, dy);

        if (m_pos.x() - m_radius &amp;lt; 0) {
            m_direction.setX(-m_direction.x());
            m_pos.setX(m_radius);
        } else if (m_pos.x() + m_radius &amp;gt; width()) {
            m_direction.setX(-m_direction.x());
            m_pos.setX(width() - m_radius);
        }

        if (m_pos.y() - m_radius &amp;lt; 0) {
            m_direction.setY(-m_direction.y());
            m_pos.setY(m_radius);
        } else if (m_pos.y() + m_radius &amp;gt; height()) {
            m_direction.setY(-m_direction.y());
            m_pos.setY(height() - m_radius);
        }

#if QT_CONFIG(opengl)
        if (usesOpenGL()) {
            update();
        } else
#endif
        {
            QRect rectAfter = circle_bounds(m_pos, m_radius, m_fontSize);
            update(rectAfter | rectBefore);
        }
    }
//     else if (e-&amp;gt;timerId() == m_fpsTimer.timerId()) {
//         printf(&quot;fps: %d\n&quot;, m_fpsCounter);
//         emit frameRate(m_fpsCounter);
//         m_fpsCounter = 0;

//     }
}

void PathDeformRenderer::mousePressEvent(QMouseEvent *e)
{
    if (m_show_doc) {
        setDescriptionEnabled(false);
        return;
    }
    setDescriptionEnabled(false);

    m_repaintTimer.stop();
    m_offset = QPointF();
    if (QLineF(m_pos, e-&amp;gt;pos()).length() &amp;lt;= m_radius)
        m_offset = m_pos - e-&amp;gt;pos();

    m_mousePress = e-&amp;gt;pos();

    // If we're not running in small screen mode, always assume we're dragging
    m_mouseDrag = !m_smallScreen;

    mouseMoveEvent(e);
}

void PathDeformRenderer::mouseReleaseEvent(QMouseEvent *e)
{
    if (e-&amp;gt;buttons() == Qt::NoButton &amp;amp;&amp;amp; m_animated) {
        m_repaintTimer.start(10, this);
        m_repaintTracker.start();
    }

    if (!m_mouseDrag &amp;amp;&amp;amp; m_smallScreen)
        emit clicked();
}

void PathDeformRenderer::mouseMoveEvent(QMouseEvent *e)
{
    if (!m_mouseDrag &amp;amp;&amp;amp; (QLineF(m_mousePress, e-&amp;gt;pos()).length() &amp;gt; 25.0) )
        m_mouseDrag = true;

    if (m_mouseDrag) {
        QRect rectBefore = circle_bounds(m_pos, m_radius, m_fontSize);
        if (e-&amp;gt;type() == QEvent::MouseMove) {
            QLineF line(m_pos, e-&amp;gt;pos() + m_offset);
            line.setLength(line.length() * .1);
            QPointF dir(line.dx(), line.dy());
            m_direction = (m_direction + dir) / 2;
        }
        m_pos = e-&amp;gt;pos() + m_offset;
#if QT_CONFIG(opengl)
        if (usesOpenGL()) {
            update();
        } else
#endif
        {
            QRect rectAfter = circle_bounds(m_pos, m_radius, m_fontSize);
            update(rectBefore | rectAfter);
        }
    }
}

QPainterPath PathDeformRenderer::lensDeform(const QPainterPath &amp;amp;source, const QPointF &amp;amp;offset)
{
    QPainterPath path;
    path.addPath(source);

    qreal flip = m_intensity / qreal(100);

    for (int i=0; i&amp;lt;path.elementCount(); ++i) {
        const QPainterPath::Element &amp;amp;e = path.elementAt(i);

        qreal x = e.x + offset.x();
        qreal y = e.y + offset.y();

        qreal dx = x - m_pos.x();
        qreal dy = y - m_pos.y();
        qreal len = m_radius - qSqrt(dx * dx + dy * dy);

        if (len &amp;gt; 0) {
            path.setElementPositionAt(i,
                                      x + flip * dx * len / m_radius,
                                      y + flip * dy * len / m_radius);
        } else {
            path.setElementPositionAt(i, x, y);
        }

    }

    return path;
}

void PathDeformRenderer::paint(QPainter *painter)
{
    int pad_x = 5;
    int pad_y = 5;

    int skip_x = qRound(m_pathBounds.width() + pad_x + m_fontSize/2);
    int skip_y = qRound(m_pathBounds.height() + pad_y);

    painter-&amp;gt;setPen(Qt::NoPen);
    painter-&amp;gt;setBrush(Qt::black);

    QRectF clip(painter-&amp;gt;clipPath().boundingRect());

    int overlap = pad_x / 2;

    for (int start_y=0; start_y &amp;lt; height(); start_y += skip_y) {

        if (start_y &amp;gt; clip.bottom())
            break;

        int start_x = -overlap;
        for (; start_x &amp;lt; width(); start_x += skip_x) {

            if (start_y + skip_y &amp;gt;= clip.top() &amp;amp;&amp;amp;
                start_x + skip_x &amp;gt;= clip.left() &amp;amp;&amp;amp;
                start_x &amp;lt;= clip.right()) {
                for (int i=0; i&amp;lt;m_paths.size(); ++i) {
                    QPainterPath path = lensDeform(m_paths[i], QPointF(start_x, start_y));
                    painter-&amp;gt;drawPath(path);
                }
            }
        }
        overlap = skip_x - (start_x - width());

    }

    if (preferImage()) {
        painter-&amp;gt;drawImage(m_pos - QPointF(m_radius + LENS_EXTENT, m_radius + LENS_EXTENT),
                           m_lens_image);
    } else {
        painter-&amp;gt;drawPixmap(m_pos - QPointF(m_radius + LENS_EXTENT, m_radius + LENS_EXTENT),
                            m_lens_pixmap);
    }
}

void PathDeformRenderer::setRadius(int radius)
{
    qreal max = qMax(m_radius, (qreal)radius);
    m_radius = radius;
    generateLensPixmap();
    if (!m_animated || m_radius &amp;lt; max) {
#if QT_CONFIG(opengl)
        if (usesOpenGL()){
            update();
            return;
        }
#endif
        update(circle_bounds(m_pos, max, m_fontSize));
    }
}

void PathDeformRenderer::setIntensity(int intensity)
{
    m_intensity = intensity;
    if (!m_animated) {
#if QT_CONFIG(opengl)
        if (usesOpenGL()) {
            update();
            return;
        }
#endif
        update(circle_bounds(m_pos, m_radius, m_fontSize));
    }
}

</db:programlisting>
</db:article>
