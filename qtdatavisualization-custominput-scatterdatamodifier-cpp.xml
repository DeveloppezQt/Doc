<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Custom Input Example</db:title>
<db:productname>QtDataVisualization</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Implementing custom input handler in a widget application.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the Qt Data Visualization module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:GPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3 or (at your option) any later version
** approved by the KDE Free Qt Foundation. The licenses are as published by
** the Free Software Foundation and appearing in the file LICENSE.GPL3
** included in the packaging of this file. Please review the following
** information to ensure the GNU General Public License requirements will
** be met: https://www.gnu.org/licenses/gpl-3.0.html.
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;scatterdatamodifier.h&quot;

#include &lt;QtDataVisualization/QScatterDataProxy&gt;
#include &lt;QtDataVisualization/QValue3DAxis&gt;
#include &lt;QtDataVisualization/Q3DScene&gt;
#include &lt;QtDataVisualization/Q3DCamera&gt;
#include &lt;QtDataVisualization/QScatter3DSeries&gt;
#include &lt;QtDataVisualization/Q3DTheme&gt;
#include &lt;QtCore/qmath.h&gt;
#include &lt;QtCore/QTextStream&gt;
#include &lt;QtCore/QDebug&gt;

using namespace QtDataVisualization;

ScatterDataModifier::ScatterDataModifier(Q3DScatter *scatter)
    : m_graph(scatter),
      m_inputHandler(new CustomInputHandler())
{
    m_graph-&gt;activeTheme()-&gt;setType(Q3DTheme::ThemeDigia);
    m_graph-&gt;setShadowQuality(QAbstract3DGraph::ShadowQualityMedium);
    m_graph-&gt;scene()-&gt;activeCamera()-&gt;setCameraPreset(Q3DCamera::CameraPresetFront);

    m_graph-&gt;setAxisX(new QValue3DAxis);
    m_graph-&gt;setAxisY(new QValue3DAxis);
    m_graph-&gt;setAxisZ(new QValue3DAxis);

    m_graph-&gt;axisX()-&gt;setRange(-10.0f, 10.0f);
    m_graph-&gt;axisY()-&gt;setRange(-5.0f, 5.0f);
    m_graph-&gt;axisZ()-&gt;setRange(-5.0f, 5.0f);

    QScatter3DSeries *series = new QScatter3DSeries;
    series-&gt;setItemLabelFormat(QStringLiteral(&quot;@xLabel, @yLabel, @zLabel&quot;));
    series-&gt;setMesh(QAbstract3DSeries::MeshCube);
    series-&gt;setItemSize(0.15f);
    m_graph-&gt;addSeries(series);

    m_animationCameraX = new QPropertyAnimation(m_graph-&gt;scene()-&gt;activeCamera(), &quot;xRotation&quot;);
    m_animationCameraX-&gt;setDuration(20000);
    m_animationCameraX-&gt;setStartValue(QVariant::fromValue(0.0f));
    m_animationCameraX-&gt;setEndValue(QVariant::fromValue(360.0f));
    m_animationCameraX-&gt;setLoopCount(-1);

    QPropertyAnimation *upAnimation = new QPropertyAnimation(m_graph-&gt;scene()-&gt;activeCamera(), &quot;yRotation&quot;);
    upAnimation-&gt;setDuration(9000);
    upAnimation-&gt;setStartValue(QVariant::fromValue(5.0f));
    upAnimation-&gt;setEndValue(QVariant::fromValue(45.0f));

    QPropertyAnimation *downAnimation = new QPropertyAnimation(m_graph-&gt;scene()-&gt;activeCamera(), &quot;yRotation&quot;);
    downAnimation-&gt;setDuration(9000);
    downAnimation-&gt;setStartValue(QVariant::fromValue(45.0f));
    downAnimation-&gt;setEndValue(QVariant::fromValue(5.0f));

    m_animationCameraY = new QSequentialAnimationGroup();
    m_animationCameraY-&gt;setLoopCount(-1);
    m_animationCameraY-&gt;addAnimation(upAnimation);
    m_animationCameraY-&gt;addAnimation(downAnimation);

    m_animationCameraX-&gt;start();
    m_animationCameraY-&gt;start();

    // Give ownership of the handler to the graph and make it the active handler
    m_graph-&gt;setActiveInputHandler(m_inputHandler);

    m_selectionTimer = new QTimer(this);
    m_selectionTimer-&gt;setInterval(10);
    m_selectionTimer-&gt;setSingleShot(false);
    QObject::connect(m_selectionTimer, &amp;QTimer::timeout, this,
                     &amp;ScatterDataModifier::triggerSelection);
    m_selectionTimer-&gt;start();
}

ScatterDataModifier::~ScatterDataModifier()
{
    delete m_graph;
}

void ScatterDataModifier::start()
{
    addData();
}

void ScatterDataModifier::addData()
{
    QVector&lt;QVector3D&gt; itemList;

    // Read data items from the file to QVector
    QTextStream stream;
    QFile dataFile(&quot;:/data/data.txt&quot;);
    if (dataFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
        stream.setDevice(&amp;dataFile);
        while (!stream.atEnd()) {
            QString line = stream.readLine();
            if (line.startsWith(&quot;#&quot;)) // Ignore comments
                continue;
            QStringList strList = line.split(&quot;,&quot;, QString::SkipEmptyParts);
            // Each line has three data items: xPos, yPos and zPos value
            if (strList.size() &lt; 3) {
                qWarning() &lt;&lt; &quot;Invalid row read from data:&quot; &lt;&lt; line;
                continue;
            }
            itemList.append(QVector3D(
                                 strList.at(0).trimmed().toFloat(),
                                 strList.at(1).trimmed().toFloat(),
                                 strList.at(2).trimmed().toFloat()));
        }
    } else {
        qWarning() &lt;&lt; &quot;Unable to open data file:&quot; &lt;&lt; dataFile.fileName();
    }

    // Add data from the QVector to datamodel
    QScatterDataArray *dataArray = new QScatterDataArray;
    dataArray-&gt;resize(itemList.count());
    QScatterDataItem *ptrToDataArray = &amp;dataArray-&gt;first();
    for (int i = 0; i &lt; itemList.count(); i++) {
        ptrToDataArray-&gt;setPosition(itemList.at(i));
        ptrToDataArray++;
    }

    m_graph-&gt;seriesList().at(0)-&gt;dataProxy()-&gt;resetArray(dataArray);
}

void ScatterDataModifier::toggleCameraAnimation()
{
    if (m_animationCameraX-&gt;state() != QAbstractAnimation::Paused) {
        m_animationCameraX-&gt;pause();
        m_animationCameraY-&gt;pause();
    } else {
        m_animationCameraX-&gt;resume();
        m_animationCameraY-&gt;resume();
    }
}

void ScatterDataModifier::triggerSelection()
{
    m_graph-&gt;scene()-&gt;setSelectionQueryPosition(m_inputHandler-&gt;inputPosition());
}

void ScatterDataModifier::shadowQualityUpdatedByVisual(QAbstract3DGraph::ShadowQuality sq)
{
    int quality = int(sq);
    emit shadowQualityChanged(quality); // connected to a checkbox in main.cpp
}

void ScatterDataModifier::changeShadowQuality(int quality)
{
    QAbstract3DGraph::ShadowQuality sq = QAbstract3DGraph::ShadowQuality(quality);
    m_graph-&gt;setShadowQuality(sq);
}

</db:programlisting>
</db:article>
