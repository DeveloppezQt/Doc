<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QJsonObject Class</db:title>
<db:productname>QtCore</db:productname>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link> class encapsulates a JSON object.</db:para>
<db:para>This class was introduced in Qt 5.0.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QJsonObject</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QJsonObject is part of <db:simplelist><db:member><db:link xlink:href="json.xml">JSON Support in Qt</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A JSON object is a list of key value pairs, where the keys are unique strings and the values are represented by a <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>.</db:para>
<db:para>A <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link> can be converted to and from a <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link>. You can query the number of (key, value) pairs with <db:link xlink:href="qjsonobject.xml#size">size</db:link>(), <db:link xlink:href="qjsonobject.xml#insert">insert</db:link>(), and <db:link xlink:href="qjsonobject.xml#remove">remove</db:link>() entries from it and iterate over its content using the standard C++ iterator pattern.</db:para>
<db:para><db:link xlink:href="qjsonobject.xml">QJsonObject</db:link> is an implicitly shared class, and shares the data with the document it has been created from as long as it is not being modified.</db:para>
<db:para>You can convert the array to and from text based JSON through <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link>.</db:para>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QJsonObject::ConstIterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qjsonobject-const-iterator.xml">QJsonObject::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>QJsonObject::Iterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qjsonobject-iterator.xml">QJsonObject::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="key_type-typedef">
<db:title>QJsonObject::key_type</db:title>
<db:para>Typedef for <db:link xlink:href="qstring.xml">QString</db:link>. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="mapped_type-typedef">
<db:title>QJsonObject::mapped_type</db:title>
<db:para>Typedef for <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>QJsonObject::size_type</db:title>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QJsonObject">
<db:title>QJsonObject::QJsonObject()</db:title>
<db:para>Constructs an empty JSON object</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QJsonObject-1">
<db:title>QJsonObject::QJsonObject(const QJsonObject &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Creates a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:para>Since <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link> is implicitly shared, the copy is shallow as long as the object does not get modified.</db:para>
</db:section>
<db:section xml:id="dtor.QJsonObject">
<db:title>[noexcept] QJsonObject::~QJsonObject()</db:title>
<db:para>Destroys the object.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QJsonObject::iterator QJsonObject::begin()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonobject.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>QJsonObject::const_iterator QJsonObject::begin() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="constBegin">
<db:title>QJsonObject::const_iterator QJsonObject::constBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonobject.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QJsonObject::const_iterator QJsonObject::constEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonobject.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind">
<db:title>QJsonObject::const_iterator QJsonObject::constFind(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns an const iterator pointing to the item with key <db:code role="parameter">key</db:code> in the map.</db:para>
<db:para>If the map contains no item with key <db:code role="parameter">key</db:code>, the function returns <db:link xlink:href="qjsonobject.xml#constEnd">constEnd</db:link>().</db:para>
</db:section>
<db:section xml:id="contains">
<db:title>bool QJsonObject::contains(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns true if the object contains key <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonobject.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonobject.xml#take">take</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>int QJsonObject::count() const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qjsonobject.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="empty">
<db:title>bool QJsonObject::empty() const</db:title>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qjsonobject.xml#isEmpty">isEmpty</db:link>(), returning true if the object is empty; otherwise returning false.</db:para>
</db:section>
<db:section xml:id="end">
<db:title>QJsonObject::iterator QJsonObject::end()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonobject.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>QJsonObject::const_iterator QJsonObject::end() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="erase">
<db:title>QJsonObject::iterator QJsonObject::erase(QJsonObject::iterator <db:emphasis>it</db:emphasis>)</db:title>
<db:para>Removes the (key, value) pair pointed to by the iterator <db:code role="parameter">it</db:code> from the map, and returns an iterator to the next item in the map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find">
<db:title>QJsonObject::iterator QJsonObject::find(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Returns an iterator pointing to the item with key <db:code role="parameter">key</db:code> in the map.</db:para>
<db:para>If the map contains no item with key <db:code role="parameter">key</db:code>, the function returns <db:link xlink:href="qjsonobject.xml#end">end</db:link>().</db:para>
</db:section>
<db:section xml:id="find-1">
<db:title>QJsonObject::const_iterator QJsonObject::find(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="fromVariantMap">
<db:title>[static] QJsonObject QJsonObject::fromVariantMap(const QVariantMap &amp;<db:emphasis>map</db:emphasis>)</db:title>
<db:para>Converts the variant map <db:code role="parameter">map</db:code> to a <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link>.</db:para>
<db:para>The keys in <db:code role="parameter">map</db:code> will be used as the keys in the JSON object, and the <db:link xlink:href="qvariant.xml">QVariant</db:link> values will be converted to JSON values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#toVariantMap">toVariantMap</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonvalue.xml#fromVariant">QJsonValue::fromVariant</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert">
<db:title>QJsonObject::iterator QJsonObject::insert(const QString &amp;<db:emphasis>key</db:emphasis>, const QJsonValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Inserts a new item with the key <db:code role="parameter">key</db:code> and a value of <db:code role="parameter">value</db:code>.</db:para>
<db:para>If there is already an item with the key <db:code role="parameter">key</db:code> then that item's value is replaced with <db:code role="parameter">value</db:code>.</db:para>
<db:para>Returns an iterator pointing to the inserted item.</db:para>
<db:para>If the value is <db:link xlink:href="qjsonvalue.xml#Type-enum">QJsonValue::Undefined</db:link>, it will cause the key to get removed from the object. The returned iterator will then point to <db:link xlink:href="qjsonobject.xml#end">end</db:link>()</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonobject.xml#take">take</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonobject-iterator.xml">QJsonObject::iterator</db:link></db:member>
<db:member><db:link xlink:href="qjsonobject.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QJsonObject::isEmpty() const</db:title>
<db:para>Returns true if the object is empty. This is the same as <db:link xlink:href="qjsonobject.xml#size">size</db:link>() == 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keys">
<db:title>QStringList QJsonObject::keys() const</db:title>
<db:para>Returns a list of all keys in this object.</db:para>
</db:section>
<db:section xml:id="length">
<db:title>int QJsonObject::length() const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qjsonobject.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="remove">
<db:title>void QJsonObject::remove(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes <db:code role="parameter">key</db:code> from the object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonobject.xml#take">take</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>int QJsonObject::size() const</db:title>
<db:para>Returns the number of (key, value) pairs stored in the object.</db:para>
</db:section>
<db:section xml:id="take">
<db:title>QJsonValue QJsonObject::take(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes <db:code role="parameter">key</db:code> from the object.</db:para>
<db:para>Returns a <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link> containing the value referenced by <db:code role="parameter">key</db:code>. If <db:code role="parameter">key</db:code> was not contained in the object, the returned <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link> is Undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonobject.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toVariantMap">
<db:title>QVariantMap QJsonObject::toVariantMap() const</db:title>
<db:para>Converts this object to a <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link>.</db:para>
<db:para>Returns the created map.</db:para>
</db:section>
<db:section xml:id="value">
<db:title>QJsonValue QJsonObject::value(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns a <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link> representing the value for the key <db:code role="parameter">key</db:code>.</db:para>
<db:para>The returned <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link> is Undefined, if the key does not exist.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link></db:member>
<db:member><db:link xlink:href="qjsonvalue.xml#isUndefined">QJsonValue::isUndefined</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QJsonObject::operator!=(const QJsonObject &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns true if <db:code role="parameter">other</db:code> is not equal to this object</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QJsonObject &amp;QJsonObject::operator=(const QJsonObject &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Assigns <db:code role="parameter">other</db:code> to this object.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QJsonObject::operator==(const QJsonObject &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns true if <db:code role="parameter">other</db:code> is equal to this object</db:para>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>QJsonValueRef QJsonObject::operator[](const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Returns a reference to the value for <db:code role="parameter">key</db:code>.</db:para>
<db:para>The return value is of type QJsonValueRef, a helper class for <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link> and <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link>. When you get an object of type QJsonValueRef, you can use it as if it were a reference to a <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>. If you assign to it, the assignment will apply to the character in the <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link> of <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link> from which you got the reference.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>QJsonValue QJsonObject::operator[](const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns a <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link> representing the value for the key <db:code role="parameter">key</db:code>.</db:para>
<db:para>This does the same as <db:link xlink:href="qjsonobject.xml#value">value</db:link>().</db:para>
<db:para>The returned <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link> is Undefined, if the key does not exist.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsonobject.xml#value">value</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link></db:member>
<db:member><db:link xlink:href="qjsonvalue.xml#isUndefined">QJsonValue::isUndefined</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
