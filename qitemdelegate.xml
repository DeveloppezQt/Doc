<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QItemDelegate Class</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> class provides display and editing facilities for data items from a model.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QItemDelegate</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Widgets)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Widgets)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += widgets</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qabstractitemdelegate.xml" xlink:role="class">QAbstractItemDelegate</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QItemDelegate is part of <db:simplelist><db:member>model-view</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> can be used to provide custom display features and editor widgets for item views based on <db:link xlink:href="qabstractitemview.xml">QAbstractItemView</db:link> subclasses. Using a delegate for this purpose allows the display and editing mechanisms to be customized and developed independently from the model and view.</db:para>
<db:para>The <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> class is one of the <db:link xlink:href="model-view-programming.xml#model-view-classes">Model/View Classes</db:link> and is part of Qt's <db:link xlink:href="model-view-programming.xml">model/view framework</db:link>. Note that <db:link xlink:href="qstyleditemdelegate.xml">QStyledItemDelegate</db:link> has taken over the job of drawing Qt's item views. We recommend the use of <db:link xlink:href="qstyleditemdelegate.xml">QStyledItemDelegate</db:link> when creating new delegates.</db:para>
<db:para>When displaying items from a custom model in a standard view, it is often sufficient to simply ensure that the model returns appropriate data for each of the <db:link xlink:href="qt.xml#ItemDataRole-enum">roles</db:link> that determine the appearance of items in views. The default delegate used by Qt's standard views uses this role information to display items in most of the common forms expected by users. However, it is sometimes necessary to have even more control over the appearance of items than the default delegate can provide.</db:para>
<db:para>This class provides default implementations of the functions for painting item data in a view and editing data from item models. Default implementations of the <db:link xlink:href="qitemdelegate.xml#paint">paint</db:link>() and <db:link xlink:href="qitemdelegate.xml#sizeHint">sizeHint</db:link>() virtual functions, defined in <db:link xlink:href="qabstractitemdelegate.xml">QAbstractItemDelegate</db:link>, are provided to ensure that the delegate implements the correct basic behavior expected by views. You can reimplement these functions in subclasses to customize the appearance of items.</db:para>
<db:para>When editing data in an item view, <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> provides an editor widget, which is a widget that is placed on top of the view while editing takes place. Editors are created with a <db:link xlink:href="qitemeditorfactory.xml">QItemEditorFactory</db:link>; a default static instance provided by <db:link xlink:href="qitemeditorfactory.xml">QItemEditorFactory</db:link> is installed on all item delegates. You can set a custom factory using <db:link xlink:href="qitemdelegate.xml#setItemEditorFactory">setItemEditorFactory</db:link>() or set a new default factory with <db:link xlink:href="qitemeditorfactory.xml#setDefaultFactory">QItemEditorFactory::setDefaultFactory</db:link>(). It is the data stored in the item model with the <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::EditRole</db:link> that is edited.</db:para>
<db:para>Only the standard editing functions for widget-based delegates are reimplemented here:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qitemdelegate.xml#createEditor">createEditor</db:link>() returns the widget used to change data from the model and can be reimplemented to customize editing behavior.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qitemdelegate.xml#setEditorData">setEditorData</db:link>() provides the widget with data to manipulate.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qitemdelegate.xml#updateEditorGeometry">updateEditorGeometry</db:link>() ensures that the editor is displayed correctly with respect to the item view.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qitemdelegate.xml#setModelData">setModelData</db:link>() returns updated data to the model.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The <db:link xlink:href="qabstractitemdelegate.xml#closeEditor">closeEditor</db:link>() signal indicates that the user has completed editing the data, and that the editor widget can be destroyed.</db:para>
<db:section xml:id="standard-roles-and-data-types">
<db:title>Standard Roles and Data Types</db:title>
<db:para>The default delegate used by the standard views supplied with Qt associates each standard role (defined by <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::ItemDataRole</db:link>) with certain data types. Models that return data in these types can influence the appearance of the delegate as described in the following table.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Role</db:para>
</db:th>
<db:th>
<db:para>Accepted Types</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::BackgroundRole</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qbrush.xml">QBrush</db:link> (</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::CheckStateRole</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qt.xml#CheckState-enum">Qt::CheckState</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::DecorationRole</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qicon.xml">QIcon</db:link>, <db:link xlink:href="qpixmap.xml">QPixmap</db:link> and <db:link xlink:href="qcolor.xml">QColor</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::DisplayRole</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qstring.xml">QString</db:link> and types with a string representation</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::EditRole</db:link></db:para>
</db:td>
<db:td>
<db:para>See <db:link xlink:href="qitemeditorfactory.xml">QItemEditorFactory</db:link> for details</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::FontRole</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qfont.xml">QFont</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::SizeHintRole</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qsize.xml">QSize</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::TextAlignmentRole</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qt.xml#AlignmentFlag-enum">Qt::Alignment</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::ForegroundRole</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qbrush.xml">QBrush</db:link> (</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>If the default delegate does not allow the level of customization that you need, either for display purposes or for editing data, it is possible to subclass <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> to implement the desired behavior.</db:para>
</db:section>
<db:section xml:id="subclassing">
<db:title>Subclassing</db:title>
<db:para>When subclassing <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the <db:link xlink:href="qitemdelegate.xml#paint">paint</db:link>() function contains some hints to show how this can be achieved.</db:para>
<db:para>You can provide custom editors by using a <db:link xlink:href="qitemeditorfactory.xml">QItemEditorFactory</db:link>. The <db:link xlink:href="qtwidgets-itemviews-coloreditorfactory-example.xml">Color Editor Factory Example</db:link> shows how a custom editor can be made available to delegates with the default item editor factory. This way, there is no need to subclass <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link>. An alternative is to reimplement <db:link xlink:href="qitemdelegate.xml#createEditor">createEditor</db:link>(), <db:link xlink:href="qitemdelegate.xml#setEditorData">setEditorData</db:link>(), <db:link xlink:href="qitemdelegate.xml#setModelData">setModelData</db:link>(), and <db:link xlink:href="qitemdelegate.xml#updateEditorGeometry">updateEditorGeometry</db:link>(). This process is described in the <db:link xlink:href="qtwidgets-itemviews-spinboxdelegate-example.xml">Spin Box Delegate Example</db:link>.</db:para>
</db:section>
<db:section xml:id="qstyleditemdelegate-vs-qitemdelegate">
<db:title>QStyledItemDelegate vs. QItemDelegate</db:title>
<db:para>Since Qt 4.4, there are two delegate classes: <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> and <db:link xlink:href="qstyleditemdelegate.xml">QStyledItemDelegate</db:link>. However, the default delegate is <db:link xlink:href="qstyleditemdelegate.xml">QStyledItemDelegate</db:link>. These two classes are independent alternatives to painting and providing editors for items in views. The difference between them is that <db:link xlink:href="qstyleditemdelegate.xml">QStyledItemDelegate</db:link> uses the current style to paint its items. We therefore recommend using <db:link xlink:href="qstyleditemdelegate.xml">QStyledItemDelegate</db:link> as the base class when implementing custom delegates or when working with Qt style sheets. The code required for either class should be equal unless the custom delegate needs to use the style for drawing.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="model-view-programming.xml#delegate-classes">Delegate Classes</db:link></db:member>
<db:member><db:link xlink:href="qstyleditemdelegate.xml">QStyledItemDelegate</db:link></db:member>
<db:member><db:link xlink:href="qabstractitemdelegate.xml">QAbstractItemDelegate</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-itemviews-spinboxdelegate-example.xml">Spin Box Delegate Example</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-tools-settingseditor-example.xml">Settings Editor Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="clipping-prop">
<db:title>clipping : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>clipping</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">hasClipping</db:synopsisinfo>
<db:synopsisinfo role="setter">setClipping</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>if the delegate should clip the paint events</db:para>
<db:para>This property will set the paint clip to the size of the item. The default value is on. It is useful for cases such as when images are larger than the size of the item.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">hasClipping</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setClipping</db:emphasis>(<db:type>bool</db:type> <db:emphasis>clip</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QItemDelegate">
<db:title>[explicit] QItemDelegate::QItemDelegate(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QItemDelegate</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QItemDelegate(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an item delegate with the given <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QItemDelegate">
<db:title>[virtual] QItemDelegate::~QItemDelegate()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QItemDelegate</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QItemDelegate()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the item delegate.</db:para>
</db:section>
<db:section xml:id="createEditor">
<db:title>[override virtual] QWidget *QItemDelegate::createEditor(QWidget *<db:emphasis>parent</db:emphasis>, const QStyleOptionViewItem &amp;<db:emphasis>option</db:emphasis>, const QModelIndex &amp;<db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>createEditor</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>parent</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStyleOptionViewItem &amp;</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * createEditor(QWidget *parent, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemdelegate.xml#createEditor" role="function">QAbstractItemDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const</db:link>.</db:para>
<db:para>Returns the widget used to edit the item specified by <db:code role="parameter">index</db:code> for editing. The <db:code role="parameter">parent</db:code> widget and style <db:code role="parameter">option</db:code> are used to control how the editor widget appears.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractitemdelegate.xml#createEditor">QAbstractItemDelegate::createEditor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="drawBackground">
<db:title>[protected] void QItemDelegate::drawBackground(QPainter *<db:emphasis>painter</db:emphasis>, const QStyleOptionViewItem &amp;<db:emphasis>option</db:emphasis>, const QModelIndex &amp;<db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>drawBackground</db:methodname>
<db:methodparam>
<db:type>QPainter *</db:type>
<db:parameter>painter</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStyleOptionViewItem &amp;</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void drawBackground(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Renders the item background for the given <db:code role="parameter">index</db:code>, using the given <db:code role="parameter">painter</db:code> and style <db:code role="parameter">option</db:code>.</db:para>
</db:section>
<db:section xml:id="drawCheck">
<db:title>[virtual protected] void QItemDelegate::drawCheck(QPainter *<db:emphasis>painter</db:emphasis>, const QStyleOptionViewItem &amp;<db:emphasis>option</db:emphasis>, const QRect &amp;<db:emphasis>rect</db:emphasis>, Qt::CheckState <db:emphasis>state</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>drawCheck</db:methodname>
<db:methodparam>
<db:type>QPainter *</db:type>
<db:parameter>painter</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStyleOptionViewItem &amp;</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRect &amp;</db:type>
<db:parameter>rect</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::CheckState</db:type>
<db:parameter>state</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void drawCheck(QPainter *painter, const QStyleOptionViewItem &amp;option, const QRect &amp;rect, Qt::CheckState state) const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Renders a check indicator within the rectangle specified by <db:code role="parameter">rect</db:code>, using the given <db:code role="parameter">painter</db:code> and style <db:code role="parameter">option</db:code>, using the given <db:code role="parameter">state</db:code>.</db:para>
</db:section>
<db:section xml:id="drawDecoration">
<db:title>[virtual protected] void QItemDelegate::drawDecoration(QPainter *<db:emphasis>painter</db:emphasis>, const QStyleOptionViewItem &amp;<db:emphasis>option</db:emphasis>, const QRect &amp;<db:emphasis>rect</db:emphasis>, const QPixmap &amp;<db:emphasis>pixmap</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>drawDecoration</db:methodname>
<db:methodparam>
<db:type>QPainter *</db:type>
<db:parameter>painter</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStyleOptionViewItem &amp;</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRect &amp;</db:type>
<db:parameter>rect</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QPixmap &amp;</db:type>
<db:parameter>pixmap</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void drawDecoration(QPainter *painter, const QStyleOptionViewItem &amp;option, const QRect &amp;rect, const QPixmap &amp;pixmap) const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Renders the decoration <db:code role="parameter">pixmap</db:code> within the rectangle specified by <db:code role="parameter">rect</db:code> using the given <db:code role="parameter">painter</db:code> and style <db:code role="parameter">option</db:code>.</db:para>
</db:section>
<db:section xml:id="drawDisplay">
<db:title>[virtual protected] void QItemDelegate::drawDisplay(QPainter *<db:emphasis>painter</db:emphasis>, const QStyleOptionViewItem &amp;<db:emphasis>option</db:emphasis>, const QRect &amp;<db:emphasis>rect</db:emphasis>, const QString &amp;<db:emphasis>text</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>drawDisplay</db:methodname>
<db:methodparam>
<db:type>QPainter *</db:type>
<db:parameter>painter</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStyleOptionViewItem &amp;</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRect &amp;</db:type>
<db:parameter>rect</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>text</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void drawDisplay(QPainter *painter, const QStyleOptionViewItem &amp;option, const QRect &amp;rect, const QString &amp;text) const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Renders the item view <db:code role="parameter">text</db:code> within the rectangle specified by <db:code role="parameter">rect</db:code> using the given <db:code role="parameter">painter</db:code> and style <db:code role="parameter">option</db:code>.</db:para>
</db:section>
<db:section xml:id="drawFocus">
<db:title>[virtual protected] void QItemDelegate::drawFocus(QPainter *<db:emphasis>painter</db:emphasis>, const QStyleOptionViewItem &amp;<db:emphasis>option</db:emphasis>, const QRect &amp;<db:emphasis>rect</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>drawFocus</db:methodname>
<db:methodparam>
<db:type>QPainter *</db:type>
<db:parameter>painter</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStyleOptionViewItem &amp;</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRect &amp;</db:type>
<db:parameter>rect</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void drawFocus(QPainter *painter, const QStyleOptionViewItem &amp;option, const QRect &amp;rect) const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Renders the region within the rectangle specified by <db:code role="parameter">rect</db:code>, indicating that it has the focus, using the given <db:code role="parameter">painter</db:code> and style <db:code role="parameter">option</db:code>.</db:para>
</db:section>
<db:section xml:id="editorEvent">
<db:title>[override virtual protected] bool QItemDelegate::editorEvent(QEvent *<db:emphasis>event</db:emphasis>, QAbstractItemModel *<db:emphasis>model</db:emphasis>, const QStyleOptionViewItem &amp;<db:emphasis>option</db:emphasis>, const QModelIndex &amp;<db:emphasis>index</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>editorEvent</db:methodname>
<db:methodparam>
<db:type>QEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QAbstractItemModel *</db:type>
<db:parameter>model</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStyleOptionViewItem &amp;</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool editorEvent(QEvent *event, QAbstractItemModel *model, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemdelegate.xml#editorEvent" role="function">QAbstractItemDelegate::editorEvent(QEvent *event, QAbstractItemModel *model, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index)</db:link>.</db:para>
</db:section>
<db:section xml:id="eventFilter">
<db:title>[override virtual protected] bool QItemDelegate::eventFilter(QObject *<db:emphasis>editor</db:emphasis>, QEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>eventFilter</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>editor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool eventFilter(QObject *editor, QEvent *event) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qobject.xml#eventFilter" role="function">QObject::eventFilter(QObject *watched, QEvent *event)</db:link>.</db:para>
<db:para>Returns true if the given <db:code role="parameter">editor</db:code> is a valid <db:link xlink:href="qwidget.xml">QWidget</db:link> and the given <db:code role="parameter">event</db:code> is handled; otherwise returns false. The following key press events are handled by default:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:guilabel>Tab</db:guilabel></db:para>
</db:listitem>
<db:listitem>
<db:para><db:guilabel>Backtab</db:guilabel></db:para>
</db:listitem>
<db:listitem>
<db:para><db:guilabel>Enter</db:guilabel></db:para>
</db:listitem>
<db:listitem>
<db:para><db:guilabel>Return</db:guilabel></db:para>
</db:listitem>
<db:listitem>
<db:para><db:guilabel>Esc</db:guilabel></db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In the case of <db:guilabel>Tab</db:guilabel>, <db:guilabel>Backtab</db:guilabel>, <db:guilabel>Enter</db:guilabel> and <db:guilabel>Return</db:guilabel> key press events, the <db:code role="parameter">editor</db:code>'s data is committed to the model and the editor is closed. If the <db:code role="parameter">event</db:code> is a <db:guilabel>Tab</db:guilabel> key press the view will open an editor on the next item in the view. Likewise, if the <db:code role="parameter">event</db:code> is a <db:guilabel>Backtab</db:guilabel> key press the view will open an editor on the <db:emphasis>previous</db:emphasis> item in the view.</db:para>
<db:para>If the event is a <db:guilabel>Esc</db:guilabel> key press event, the <db:code role="parameter">editor</db:code> is closed <db:emphasis>without</db:emphasis> committing its data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractitemdelegate.xml#commitData">commitData</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractitemdelegate.xml#closeEditor">closeEditor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="itemEditorFactory">
<db:title>QItemEditorFactory *QItemDelegate::itemEditorFactory() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QItemEditorFactory *</db:type>
<db:methodname>itemEditorFactory</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QItemEditorFactory * itemEditorFactory() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the editor factory used by the item delegate. If no editor factory is set, the function will return null.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qitemdelegate.xml#setItemEditorFactory">setItemEditorFactory</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="paint">
<db:title>[override virtual] void QItemDelegate::paint(QPainter *<db:emphasis>painter</db:emphasis>, const QStyleOptionViewItem &amp;<db:emphasis>option</db:emphasis>, const QModelIndex &amp;<db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>paint</db:methodname>
<db:methodparam>
<db:type>QPainter *</db:type>
<db:parameter>painter</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStyleOptionViewItem &amp;</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemdelegate.xml#paint" role="function">QAbstractItemDelegate::paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const</db:link>.</db:para>
<db:para>Renders the delegate using the given <db:code role="parameter">painter</db:code> and style <db:code role="parameter">option</db:code> for the item specified by <db:code role="parameter">index</db:code>.</db:para>
<db:para>When reimplementing this function in a subclass, you should update the area held by the option's <db:link xlink:href="qstyleoption.xml#rect-var">rect</db:link> variable, using the option's <db:link xlink:href="qstyleoption.xml#state-var">state</db:link> variable to determine the state of the item to be displayed, and adjust the way it is painted accordingly.</db:para>
<db:para>For example, a selected item may need to be displayed differently to unselected items, as shown in the following code:</db:para>
<db:programlisting language="cpp">if (option.state &amp;amp; QStyle::State_Selected)
    painter-&amp;gt;fillRect(option.rect, option.palette.highlight());
</db:programlisting>
<db:para>After painting, you should ensure that the painter is returned to its the state it was supplied in when this function was called. For example, it may be useful to call <db:link xlink:href="qpainter.xml#save">QPainter::save</db:link>() before painting and <db:link xlink:href="qpainter.xml#restore">QPainter::restore</db:link>() afterwards.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstyle.xml#StateFlag-enum">QStyle::State</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setEditorData">
<db:title>[override virtual] void QItemDelegate::setEditorData(QWidget *<db:emphasis>editor</db:emphasis>, const QModelIndex &amp;<db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>setEditorData</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>editor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setEditorData(QWidget *editor, const QModelIndex &amp;index) const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemdelegate.xml#setEditorData" role="function">QAbstractItemDelegate::setEditorData(QWidget *editor, const QModelIndex &amp;index) const</db:link>.</db:para>
<db:para>Sets the data to be displayed and edited by the <db:code role="parameter">editor</db:code> from the data model item specified by the model <db:code role="parameter">index</db:code>.</db:para>
<db:para>The default implementation stores the data in the <db:code role="parameter">editor</db:code> widget's <db:link xlink:href="properties.xml">user property</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetaproperty.xml#isUser">QMetaProperty::isUser</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setItemEditorFactory">
<db:title>void QItemDelegate::setItemEditorFactory(QItemEditorFactory *<db:emphasis>factory</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setItemEditorFactory</db:methodname>
<db:methodparam>
<db:type>QItemEditorFactory *</db:type>
<db:parameter>factory</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setItemEditorFactory(QItemEditorFactory *factory)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the editor factory to be used by the item delegate to be the <db:code role="parameter">factory</db:code> specified. If no editor factory is set, the item delegate will use the default editor factory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qitemdelegate.xml#itemEditorFactory">itemEditorFactory</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setModelData">
<db:title>[override virtual] void QItemDelegate::setModelData(QWidget *<db:emphasis>editor</db:emphasis>, QAbstractItemModel *<db:emphasis>model</db:emphasis>, const QModelIndex &amp;<db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>setModelData</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>editor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QAbstractItemModel *</db:type>
<db:parameter>model</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &amp;index) const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemdelegate.xml#setModelData" role="function">QAbstractItemDelegate::setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &amp;index) const</db:link>.</db:para>
<db:para>Gets data from the <db:code role="parameter">editor</db:code> widget and stores it in the specified <db:code role="parameter">model</db:code> at the item <db:code role="parameter">index</db:code>.</db:para>
<db:para>The default implementation gets the value to be stored in the data model from the <db:code role="parameter">editor</db:code> widget's <db:link xlink:href="properties.xml">user property</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmetaproperty.xml#isUser">QMetaProperty::isUser</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sizeHint">
<db:title>[override virtual] QSize QItemDelegate::sizeHint(const QStyleOptionViewItem &amp;<db:emphasis>option</db:emphasis>, const QModelIndex &amp;<db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QSize</db:type>
<db:methodname>sizeHint</db:methodname>
<db:methodparam>
<db:type>const QStyleOptionViewItem &amp;</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSize sizeHint(const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemdelegate.xml#sizeHint" role="function">QAbstractItemDelegate::sizeHint(const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const</db:link>.</db:para>
<db:para>Returns the size needed by the delegate to display the item specified by <db:code role="parameter">index</db:code>, taking into account the style information provided by <db:code role="parameter">option</db:code>.</db:para>
<db:para>When reimplementing this function, note that in case of text items, <db:link xlink:href="qitemdelegate.xml">QItemDelegate</db:link> adds a margin (i.e. 2 * <db:link xlink:href="qstyle.xml#PixelMetric-enum">QStyle::PM_FocusFrameHMargin</db:link>) to the length of the text.</db:para>
</db:section>
<db:section xml:id="updateEditorGeometry">
<db:title>[override virtual] void QItemDelegate::updateEditorGeometry(QWidget *<db:emphasis>editor</db:emphasis>, const QStyleOptionViewItem &amp;<db:emphasis>option</db:emphasis>, const QModelIndex &amp;<db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>updateEditorGeometry</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>editor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStyleOptionViewItem &amp;</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemdelegate.xml#updateEditorGeometry" role="function">QAbstractItemDelegate::updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const</db:link>.</db:para>
<db:para>Updates the <db:code role="parameter">editor</db:code> for the item specified by <db:code role="parameter">index</db:code> according to the style <db:code role="parameter">option</db:code> given.</db:para>
</db:section>
</db:section>
</db:article>
