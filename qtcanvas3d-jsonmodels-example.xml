<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>JSON Models Example</db:title>
<db:productname>QtCanvas3D</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Canvas 3D Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Load and display several JSON models.</db:para>
<db:para>This documentation was introduced in QtCanvas3D 1.0.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The JSON Models Example demonstrates loading and displaying more than one JSON model and more than one texture. It also implements simple mouse input handling to allow rotating the scene and zooming into it.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/jsonmodels-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="json-model-loader">
<db:title>JSON Model Loader</db:title>
<db:para>First we include a JSON model parser, which handles parsing the JSON models into our internal models:</db:para>
<db:programlisting language="cpp">Qt.include(&quot;ThreeJSLoader.js&quot;)
</db:programlisting>
<db:para>The <db:code>ThreeJSLoader.js</db:code> includes a reimplementation of the JSON parser in <db:code>three.js</db:code>, but we will not go into its implementation details.</db:para>
</db:section>
<db:section xml:id="loading-the-models">
<db:title>Loading the Models</db:title>
<db:para>First we need to initialize all array buffers for the models:</db:para>
<db:programlisting language="cpp">function initBuffers() {
    modelOne.verticesVBO = gl.createBuffer();
    modelOne.verticesVBO.name = &quot;modelOne.verticesVBO&quot;;
    modelOne.normalsVBO  = gl.createBuffer();
    modelOne.normalsVBO.name = &quot;modelOne.normalsVBO&quot;;
    modelOne.texCoordVBO = gl.createBuffer();
    modelOne.texCoordVBO.name = &quot;modelOne.texCoordVBO&quot;;
    modelOne.indexVBO    = gl.createBuffer();
    modelOne.indexVBO.name = &quot;modelOne.indexVBO&quot;;

    modelTwo.verticesVBO = gl.createBuffer();
    modelTwo.verticesVBO.name = &quot;modelTwo.verticesVBO&quot;;
    modelTwo.normalsVBO  = gl.createBuffer();
    modelTwo.normalsVBO.name = &quot;modelTwo.normalsVBO&quot;;
    modelTwo.texCoordVBO = gl.createBuffer();
    modelTwo.texCoordVBO.name = &quot;modelTwo.texCoordVBO&quot;;
    modelTwo.indexVBO    = gl.createBuffer();
    modelTwo.indexVBO.name = &quot;modelTwo.indexVBO&quot;;
    ...
</db:programlisting>
<db:para>Then we request the models to be loaded:</db:para>
<db:programlisting language="cpp">function loadJSONModels() {
    // Load the first model
    var request = new XMLHttpRequest();
    request.open(&quot;GET&quot;, &quot;gold.json&quot;);
    request.onreadystatechange = function () {
        if (request.readyState === XMLHttpRequest.DONE) {
            handleLoadedModel(JSON.parse(request.responseText));
        }
    }
    request.send();
    log(&quot;   XMLHttpRequest sent for model one&quot;)

    // Load the second model
    var request2 = new XMLHttpRequest();
    request2.open(&quot;GET&quot;, &quot;woodbox.json&quot;);
    request2.onreadystatechange = function () {
        if (request2.readyState === XMLHttpRequest.DONE) {
            handleLoadedModel(JSON.parse(request2.responseText));
        }
    }
    request2.send();
    log(&quot;   XMLHttpRequest sent for model two&quot;)
    ...
</db:programlisting>
<db:para>Then, when the load requests return, we handle the models:</db:para>
<db:programlisting language="cpp">function handleLoadedModel(jsonObj) {
    log(&quot;handleLoadedModel...&quot;);
    var modelData = parseJSON3DModel(jsonObj, &quot;&quot;);

    if (modelOne.count === 0)
        fillModel(modelData, modelOne);
    else if (modelTwo.count === 0)
        fillModel(modelData, modelTwo);
    ...
</db:programlisting>
<db:para>Each buffer is bound and filled with the data parsed from the json models:</db:para>
<db:programlisting language="cpp">function fillModel(modelData, model) {
    log(&quot;   fillModel...&quot;);
    log(&quot;   &quot;+model.verticesVBO.name);
    gl.bindBuffer(gl.ARRAY_BUFFER, model.verticesVBO);
    gl.bufferData(gl.ARRAY_BUFFER,
                  new Float32Array(modelData.vertices),
                  gl.STATIC_DRAW);
    log(&quot;   &quot;+model.normalsVBO.name);
    if (isLogEnabled &amp;amp;&amp;amp; stateDumpExt)
        log(&quot;GL STATE DUMP:\n&quot;+stateDumpExt.getGLStateDump(stateDumpExt.DUMP_VERTEX_ATTRIB_ARRAYS_BIT || stateDumpExt.DUMP_VERTEX_ATTRIB_ARRAYS_CONTENTS_BIT));

    gl.bindBuffer(gl.ARRAY_BUFFER, model.normalsVBO);
    gl.bufferData(gl.ARRAY_BUFFER,
                  new Float32Array(modelData.normals),
                  gl.STATIC_DRAW);

    log(&quot;   &quot;+model.texCoordVBO.name);
    gl.bindBuffer(gl.ARRAY_BUFFER, model.texCoordVBO);
    gl.bufferData(gl.ARRAY_BUFFER,
                  new Float32Array(modelData.texCoords[0]),
                  gl.STATIC_DRAW);

    log(&quot;   &quot;+model.indexVBO.name);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexVBO);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                  new Uint16Array(modelData.indices),
                  gl.STATIC_DRAW);

    model.count = modelData.indices.length;
    log(&quot;   ...fillModel&quot;);
}
</db:programlisting>
</db:section>
<db:section xml:id="loading-the-textures">
<db:title>Loading the Textures</db:title>
<db:para>First we create the TextureImage objects for each of the images we are going to load and register handlers for the <db:code>imageLoaded</db:code> and <db:code>imageLoadingFailed</db:code> signals. In the <db:code>imageLoaded</db:code> signal handlers we create the OpenGL textures:</db:para>
<db:programlisting language="cpp">function loadTextures() {
    // Load the first texture
    var goldImage = TextureImageFactory.newTexImage();
    goldImage.name = &quot;goldImage&quot;;
    goldImage.imageLoaded.connect(function() {
        log(&quot;    creating model one texture&quot;);
        modelOneTexture = gl.createTexture();
        modelOneTexture.name = &quot;modelOneTexture&quot;;
        gl.bindTexture(gl.TEXTURE_2D, modelOneTexture);
        gl.texImage2D(gl.TEXTURE_2D,    // target
                      0,                // level
                      gl.RGBA,          // internalformat
                      gl.RGBA,          // format
                      gl.UNSIGNED_BYTE, // type
                      goldImage);       // pixels
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);
    });
    goldImage.imageLoadingFailed.connect(function() {
        console.log(&quot;Texture load FAILED, &quot;+goldImage.errorString);
    });
    goldImage.src = &quot;qrc:///gold.jpg&quot;;
    log(&quot;   texture one source set&quot;)

    // Load the second texture
    var woodBoxImage = TextureImageFactory.newTexImage();
    woodBoxImage.name = &quot;woodBoxImage&quot;;
    woodBoxImage.imageLoaded.connect(function() {
        log(&quot;    creating model two texture&quot;);
        modelTwoTexture = gl.createTexture();
        modelTwoTexture.name = &quot;modelTwoTexture&quot;;
        gl.bindTexture(gl.TEXTURE_2D, modelTwoTexture);
        gl.texImage2D(gl.TEXTURE_2D,    // target
                      0,                // level
                      gl.RGBA,          // internalformat
                      gl.RGBA,          // format
                      gl.UNSIGNED_BYTE, // type
                      woodBoxImage);    // pixels
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);
    });
    woodBoxImage.imageLoadingFailed.connect(function() {
        console.log(&quot;Texture load FAILED, &quot;+woodBoxImage.errorString);
    });
    woodBoxImage.src = &quot;qrc:///woodbox.jpg&quot;;
    log(&quot;   texture two source set&quot;)
    ...
</db:programlisting>
</db:section>
<db:section xml:id="input-handling">
<db:title>Input Handling</db:title>
<db:para>First we add a <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> to fill the Canvas3D:</db:para>
<db:programlisting language="qml">MouseArea {
    anchors.fill: parent
    ...
</db:programlisting>
<db:para>Before adding some functionality on it, we need to add properties to the canvas with initial values set:</db:para>
<db:programlisting language="qml">property double xRot: 0.0
property double yRot: 45.0
property double distance: 2.0
</db:programlisting>
<db:para>After that, we add rotation on mouse movement when the left mouse button is pressed:</db:para>
<db:programlisting language="qml">onMouseXChanged: {
    // Do not rotate if we don't have previous value
    if (previousY !== 0)
        canvas3d.yRot += mouseY - previousY
    previousY = mouseY
    // Limit the rotation to -90...90 degrees
    if (canvas3d.yRot &amp;gt; 90)
        canvas3d.yRot = 90
    if (canvas3d.yRot &amp;lt; -90)
        canvas3d.yRot = -90
}
onMouseYChanged: {
    // Do not rotate if we don't have previous value
    if (previousX !== 0)
        canvas3d.xRot += mouseX - previousX
    previousX = mouseX
    // Wrap the rotation around
    if (canvas3d.xRot &amp;gt; 180)
        canvas3d.xRot -= 360
    if (canvas3d.xRot &amp;lt; -180)
        canvas3d.xRot += 360
}
onReleased: {
    // Reset previous mouse positions to avoid rotation jumping
    previousX = 0
    previousY = 0
}
</db:programlisting>
<db:para>We need to keep the previous x and y values to avoid rotation jumping when the mouse button is released and pressed again. We store them in these properties:</db:para>
<db:programlisting language="qml">property int previousY: 0
property int previousX: 0
</db:programlisting>
<db:para>Then we add zooming by mouse wheel:</db:para>
<db:programlisting language="qml">onWheel: {
    canvas3d.distance -= wheel.angleDelta.y / 1000.0
    // Limit the distance to 0.5...10
    if (canvas3d.distance &amp;lt; 0.5)
        canvas3d.distance = 0.5
    if (canvas3d.distance &amp;gt; 10)
        canvas3d.distance = 10
}
</db:programlisting>
<db:para>These properties are then used in the JavaScript side when calculating eye/camera movement:</db:para>
<db:programlisting language="cpp">// Get the view matrix
mat4.identity(vMatrix);
eye = moveEye(canvas.xRot, canvas.yRot, canvas.distance);
mat4.lookAt(vMatrix, eye, [0, 0, 0], [0, 1, 0]);
</db:programlisting>
<db:para>Converting the rotation values into movement is done as follows:</db:para>
<db:programlisting language="cpp">function moveEye(xRot, yRot, distance) {
    var xAngle = degToRad(xRot);
    var yAngle = degToRad(yRot);

    var zPos = distance * Math.cos(xAngle) * Math.cos(yAngle);
    var xPos = distance * Math.sin(xAngle) * Math.cos(yAngle);
    var yPos = distance * Math.sin(yAngle);

    return [-xPos, yPos, zPos];
}
</db:programlisting>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="jsonmodels/jsonmodels.pro">jsonmodels/jsonmodels.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="jsonmodels/main.cpp">jsonmodels/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="jsonmodels/qml.qrc">jsonmodels/qml.qrc</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="jsonmodels/qml/jsonmodels/jsonmodels.js">jsonmodels/qml/jsonmodels/jsonmodels.js</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="jsonmodels/qml/jsonmodels/jsonmodels.qml">jsonmodels/qml/jsonmodels/jsonmodels.qml</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Images:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="jsonmodels/qml/jsonmodels/bush.png">jsonmodels/qml/jsonmodels/bush.png</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="jsonmodels/qml/jsonmodels/gold.jpg">jsonmodels/qml/jsonmodels/gold.jpg</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="jsonmodels/qml/jsonmodels/pallet.jpg">jsonmodels/qml/jsonmodels/pallet.jpg</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="jsonmodels/qml/jsonmodels/rock.jpg">jsonmodels/qml/jsonmodels/rock.jpg</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="jsonmodels/qml/jsonmodels/woodbox.jpg">jsonmodels/qml/jsonmodels/woodbox.jpg</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:section></db:article>
