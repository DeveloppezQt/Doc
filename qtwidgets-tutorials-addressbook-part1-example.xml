<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Part 1 - Designing the User Interface</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Widgets Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>This first part covers the design of the basic graphical user interface (GUI) for our address book application.</db:para>
<db:para>The first step in creating a GUI program is to design the user interface. Here the our goal is to set up the labels and input fields to implement a basic address book. The figure below is a screenshot of the expected output.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part1-screenshot.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>We require two <db:link xlink:href="qlabel.xml">QLabel</db:link> objects, nameLabel and addressLabel, as well as two input fields, a <db:link xlink:href="qlineedit.xml">QLineEdit</db:link> object, nameLine, and a <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> object, addressText, to enable the user to enter a contact's name and address. The widgets used and their positions are shown in the figure below.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part1-labeled-screenshot.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>There are three files used to implement this address book:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>addressbook.h - the definition file for the AddressBook class,</db:para>
</db:listitem>
<db:listitem>
<db:para>addressbook.cpp - the implementation file for the AddressBook class, and</db:para>
</db:listitem>
<db:listitem>
<db:para>main.cpp - the file containing a main() function, with an instance of AddressBook.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="qt-programming-subclassing">
<db:title>Qt Programming - Subclassing</db:title>
<db:para>When writing Qt programs, we usually subclass Qt objects to add functionality. This is one of the essential concepts behind creating custom widgets or collections of standard widgets. Subclassing to extend or change the behavior of a widget has the following advantages:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>We can write implementations of virtual or pure virtual functions to obtain exactly what we need, falling back on the base class's implementation when necessary.</db:para>
</db:listitem>
<db:listitem>
<db:para>It allows us to encapsulate parts of the user interface within a class, so that the other parts of the application don't need to know about the individual widgets in the user interface.</db:para>
</db:listitem>
<db:listitem>
<db:para>The subclass can be used to create multiple custom widgets in the same application or library, and the code for the subclass can be reused in other projects.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Since Qt does not provide a specific address book widget, we subclass a standard Qt widget class and add features to it. The AddressBook class we create in this tutorial can be reused in situations where a basic address book widget is needed.</db:para>
</db:section>
<db:section xml:id="defining-the-addressbook-class">
<db:title>Defining the AddressBook Class</db:title>
<db:para>The <db:link xlink:href="">addressbook.h</db:link> file is used to define the AddressBook class.</db:para>
<db:para>We start by defining AddressBook as a <db:link xlink:href="qwidget.xml">QWidget</db:link> subclass and declaring a constructor. We also use the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro to indicate that the class uses internationalization and Qt's signals and slots features, even if we do not use all of these features at this stage.</db:para>
<db:programlisting language="cpp">class AddressBook : public QWidget
{
    Q_OBJECT

public:
    AddressBook(QWidget *parent = 0);

private:
    QLineEdit *nameLine;
    QTextEdit *addressText;
};
</db:programlisting>
<db:para>The class holds declarations of nameLine and addressText, the private instances of <db:link xlink:href="qlineedit.xml">QLineEdit</db:link> and <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> mentioned earlier. The data stored in nameLine and addressText will be needed for many of the address book functions.</db:para>
<db:para>We don't include declarations of the <db:link xlink:href="qlabel.xml">QLabel</db:link> objects we will use because we will not need to reference them once they have been created. The way Qt tracks the ownership of objects is explained in the next section.</db:para>
<db:para>The <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro itself implements some of the more advanced features of Qt. For now, it is useful to think of the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro as a shortcut which allows us to use the <db:link xlink:href="qobject.xml#tr">tr</db:link>() and <db:link xlink:href="qobject.xml#connect">connect</db:link>() functions.</db:para>
<db:para>We have now completed the addressbook.h file and we move on to implement the corresponding addressbook.cpp file.</db:para>
</db:section>
<db:section xml:id="implementing-the-addressbook-class">
<db:title>Implementing the AddressBook Class</db:title>
<db:para>The constructor of AddressBook accepts a <db:link xlink:href="qwidget.xml">QWidget</db:link> parameter, <db:code role="parameter">parent</db:code>. By convention, we pass this parameter to the base class's constructor. This concept of ownership, where a parent can have one or more children, is useful for grouping widgets in Qt. For example, if you delete a parent, all of its children will be deleted as well.</db:para>
<db:programlisting language="cpp">AddressBook::AddressBook(QWidget *parent)
    : QWidget(parent)
{
    QLabel *nameLabel = new QLabel(tr(&quot;Name:&quot;));
    nameLine = new QLineEdit;

    QLabel *addressLabel = new QLabel(tr(&quot;Address:&quot;));
    addressText = new QTextEdit;
</db:programlisting>
<db:para>In this constructor, the <db:link xlink:href="qlabel.xml">QLabel</db:link> objects nameLabel and addressLabel are instantiated, as well as nameLine and addressText. The <db:link xlink:href="qobject.xml#tr">tr</db:link>() function returns a translated version of the string, if there is one available. Otherwise it returns the string itself. This function marks its <db:link xlink:href="qstring.xml">QString</db:link> parameter as one that should be translated into other languages. It should be used wherever a translatable string appears.</db:para>
<db:para>When programming with Qt, it is useful to know how layouts work. Qt provides three main layout classes: <db:link xlink:href="qhboxlayout.xml">QHBoxLayout</db:link>, <db:link xlink:href="qvboxlayout.xml">QVBoxLayout</db:link> and <db:link xlink:href="qgridlayout.xml">QGridLayout</db:link> to handle the positioning of widgets.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part1-labeled-layout.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>We use a <db:link xlink:href="qgridlayout.xml">QGridLayout</db:link> to position our labels and input fields in a structured manner. <db:link xlink:href="qgridlayout.xml">QGridLayout</db:link> divides the available space into a grid and places widgets in the cells we specify with row and column numbers. The diagram above shows the layout cells and the position of our widgets, and we specify this arrangement using the following code:</db:para>
<db:programlisting language="cpp">    QGridLayout *mainLayout = new QGridLayout;
    mainLayout-&gt;addWidget(nameLabel, 0, 0);
    mainLayout-&gt;addWidget(nameLine, 0, 1);
    mainLayout-&gt;addWidget(addressLabel, 1, 0, Qt::AlignTop);
    mainLayout-&gt;addWidget(addressText, 1, 1);
</db:programlisting>
<db:para>Notice that addressLabel is positioned using <db:link xlink:href="qt.xml#AlignmentFlag-enum">Qt::AlignTop</db:link> as an additional argument. This is to make sure it is not vertically centered in cell (1,0). For a basic overview on Qt Layouts, refer to the <db:link xlink:href="layout.xml">Layout Management</db:link> documentation.</db:para>
<db:para>In order to install the layout object onto the widget, we have to invoke the widget's <db:link xlink:href="qwidget.xml#setLayout">setLayout</db:link>() function:</db:para>
<db:programlisting language="cpp">    setLayout(mainLayout);
    setWindowTitle(tr(&quot;Simple Address Book&quot;));
}
</db:programlisting>
<db:para>Lastly, we set the widget's title to &quot;Simple Address Book&quot;.</db:para>
</db:section>
<db:section xml:id="running-the-application">
<db:title>Running the Application</db:title>
<db:para>A separate file, main.cpp, is used for the main() function. Within this function, we instantiate a <db:link xlink:href="qapplication.xml">QApplication</db:link> object, app. <db:link xlink:href="qapplication.xml">QApplication</db:link> is responsible for various application-wide resources, such as the default font and cursor, and for running an event loop. Hence, there is always one <db:link xlink:href="qapplication.xml">QApplication</db:link> object in every GUI application using Qt.</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    AddressBook addressBook;
    addressBook.show();

    return app.exec();
}
</db:programlisting>
<db:para>We construct a new AddressBook widget on the stack and invoke its <db:link xlink:href="qwidget.xml#show">show</db:link>() function to display it. However, the widget will not be shown until the application's event loop is started. We start the event loop by calling the application's <db:link xlink:href="qapplication.xml#exec">exec</db:link>() function; the result returned by this function is used as the return value from the main() function. At this point, it becomes apparent why we instanciated AddressBook on the stack: It will now go out of scope. Therefore, AddressBook and all its child widgets will be deleted, thus preventing memory leaks.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part1/addressbook.cpp">tutorials/addressbook/part1/addressbook.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part1/addressbook.h">tutorials/addressbook/part1/addressbook.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part1/main.cpp">tutorials/addressbook/part1/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part1/part1.pro">tutorials/addressbook/part1/part1.pro</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
