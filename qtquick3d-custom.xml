<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Programmable Materials, Effects, Geometry, and Texture data</db:title>
<db:productname>QtQuick3D</db:productname>
<db:edition>Qt Quick 3D | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Quick 3D Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Custom materials, effects, geometry and texture data providers in Qt Quick 3D.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>While the built-in materials of Qt Quick 3D, <db:link xlink:href="qml-qtquick3d-defaultmaterial.xml">DefaultMaterial</db:link> and <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link>, allow a wide degree of customization via their properties, they do not provide programmability on the vertex and fragment shader level. To allow that, the <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> type is provided.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>A model with <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link></db:para>
</db:th>
<db:th>
<db:para>With a <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> transforming the vertices</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-mat1.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-mat2.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Post-processing effects, where one or more passes of processing on the color buffer are performed, optionally taking the depth buffer into account, before the <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link>'s output is passed on to Qt Quick, also exist in two varieties:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>built-in post-processing steps that can be configured via <db:link xlink:href="qml-qtquick3d-helpers-extendedsceneenvironment.xml">ExtendedSceneEnvironment</db:link>, such as glow/bloom, depth of field, vignette, lens flare,</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>custom</db:code> effects implemented by the application in form of fragment shader code and a specification of the processing passes in an <db:link xlink:href="qml-qtquick3d-effect.xml">Effect</db:link> object.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In practice there is a third category of post-processing effects: 2D effects implemented via Qt Quick, operating on the output of the <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> item without any involvement from the 3D renderer. For example, to apply a blur to a <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> item, the simplest approach is to use Qt Quick's existing facilities, such as <db:link xlink:href="qml-qtquick-effects-multieffect.xml">MultiEffect</db:link>. The 3D post-processing system becomes beneficial for complex effects that involve 3D scene concepts such as the depth buffer or the screen texture, or need to deal with HDR tonemapping or need multiple passes with intermediate buffers, etc. Simple 2D effects that do not require any insight into the 3D scene and renderer can always be implemented with <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link> or <db:link xlink:href="qml-qtquick-effects-multieffect.xml">MultiEffect</db:link> instead.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Scene without effect</db:para>
</db:th>
<db:th>
<db:para>The same scene with a custom post-processing effect applied</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-effect1.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-effect2.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>In addition to programmable materials and post-processing, there are two types of data that is normally provided in form of files (<db:code>.mesh</db:code> files or images such as <db:code>.png</db:code>):</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vertex data, including the geometry for the mesh to be rendered, texture coordinates, normals, colors, and other data,</db:para>
</db:listitem>
<db:listitem>
<db:para>the content for textures that are then used as texture maps for the rendered objects, or used with skybox or image based lighting.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>If they so wish, applications can provide such data from C++ in form of a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. Such data can also be changed over time, allowing to procedurally generate and later alter the data for a <db:link xlink:href="qml-qtquick3d-model.xml">Model</db:link> or <db:link xlink:href="qml-qtquick3d-texture.xml">Texture</db:link>.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>A grid, rendered by specifying vertex data dynamically from C++</db:para>
</db:th>
<db:th>
<db:para>A cube textured with image data generated from C++</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-geom.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-tex.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>These four approaches to customizing and making materials, effects, geometry, and textures dynamic enable the programmability of shading and procedural generation of the data the shaders get as their input. The following sections provide an overview of these features. The full reference is available in the documentation pages for the respective types:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Feature</db:para>
</db:th>
<db:th>
<db:para>Reference Documentation</db:para>
</db:th>
<db:th>
<db:para>Relevant Examples</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Custom materials</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtquick3d-customshaders-example.xml">Qt Quick 3D - Custom Shaders Example</db:link>, <db:link xlink:href="qtquick3d-custommaterial-example.xml">Qt Quick 3D - Custom Materials Example</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Custom post-processing effects</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-qtquick3d-effect.xml">Effect</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtquick3d-customeffect-example.xml">Qt Quick 3D - Custom Effect Example</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Custom geometry</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qquick3dgeometry.xml">QQuick3DGeometry</db:link>, <db:link xlink:href="qml-qtquick3d-model.xml#geometry-prop">Model::geometry</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtquick3d-customgeometry-example.xml">Qt Quick 3D - Custom Geometry Example</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Custom texture data</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qquick3dtexturedata.xml">QQuick3DTextureData</db:link>, <db:link xlink:href="qml-qtquick3d-texture.xml#textureData-prop">Texture::textureData</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtquick3d-proceduraltexture-example.xml">Qt Quick 3D - Procedural Texture Example</db:link></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section xml:id="programmability-for-materials">
<db:title>Programmability for Materials</db:title>
<db:para>Let's have a scene with a cube, and start with a default <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> and <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link>:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para><db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link></db:para>
</db:th>
<db:th>
<db:para><db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link></db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">import QtQuick
import QtQuick3D
Item {
    View3D {
        anchors.fill: parent
        environment: SceneEnvironment {
            backgroundMode: SceneEnvironment.Color
            clearColor: &quot;black&quot;
        }
        PerspectiveCamera { z: 600 }
        DirectionalLight { }
        Model {
            source: &quot;#Cube&quot;
            scale: Qt.vector3d(2, 2, 2)
            eulerRotation.x: 30
            materials: PrincipledMaterial { }
         }
    }
}
</db:programlisting>
</db:td>
<db:td>
<db:programlisting language="qml">import QtQuick
import QtQuick3D
Item {
    View3D {
        anchors.fill: parent
        environment: SceneEnvironment {
            backgroundMode: SceneEnvironment.Color
            clearColor: &quot;black&quot;
        }
        PerspectiveCamera { z: 600 }
        DirectionalLight { }
        Model {
            source: &quot;#Cube&quot;
            scale: Qt.vector3d(2, 2, 2)
            eulerRotation.x: 30
            materials: CustomMaterial { }
         }
    }
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>These both lead to the exact same result, because a <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> is effectively a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link>, when no vertex or fragment shader code is added to it.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-cube1.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:note>
<db:para>Properties, such as, <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#baseColor-prop">baseColor</db:link>, <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#metalness-prop">metalness</db:link>, <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#baseColorMap-prop">baseColorMap</db:link>, and many others, have no equivalent properties in the <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> QML type. This is by design: customizing the material is done via shader code, not by merely providing a few fixed values.</db:para>
</db:note>
<db:section xml:id="our-first-vertex-shader">
<db:title>Our first vertex shader</db:title>
<db:para>Let's add a custom vertex shader snippet. This is done by referencing a file in the <db:link xlink:href="qml-qtquick3d-custommaterial.xml#vertexShader-prop">vertexShader</db:link> property. The approach will be the same for fragment shaders. These references work like <db:link xlink:href="qml-qtquick-image.xml#source-prop">Image.source</db:link> or <db:link xlink:href="qml-qtquick-shadereffect.xml#vertexShader-prop">ShaderEffect.vertexShader</db:link>: they are local or <db:code>qrc</db:code> URLs, and a relative path is treated relative to the <db:code>.qml</db:code> file's location. The common approach is therefore to place the <db:code>.vert</db:code> and <db:code>.frag</db:code> files into the Qt resource system (<db:code>qt_add_resources</db:code> when using CMake) and reference them using a relative path.</db:para>
<db:para>In Qt 6.0 inline shader strings are no longer supported, neither in Qt Quick nor in Qt Quick 3D. (make note of the fact that these properties are URLs, not strings) However, due to their intrinsically dynamic nature, custom materials and post-processing effects in Qt Quick 3D still provide shader snippets in source form in the referenced files. This is a difference to <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link> where the shaders are complete on their own, with no further amending by the engine, and so are expected to be provided as pre-conditioned <db:code>.qsb</db:code> shader packs.</db:para>
<db:note>
<db:para>In Qt Quick 3D URLs can only refer to local resources. Schemes for remote content are not supported.</db:para>
</db:note>
<db:note>
<db:para>The shading language used is Vulkan-compatible GLSL. The <db:code>.vert</db:code> and <db:code>.frag</db:code> files are not complete shaders on their own, hence being often called <db:code>snippets</db:code>. That is why there are no uniform blocks, input and output variables, or sampler uniforms provided directly by these snippets. Rather, the Qt Quick 3D engine will amend them as appropriate.</db:para>
</db:note>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml, material.vert</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">materials: CustomMaterial {
    vertexShader: &quot;material.vert&quot;
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-cube1-small.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>A custom vertex or fragment shader snippet is expected to provide one or more functions with pre-defined names, such as <db:code>MAIN</db:code>, <db:code>DIRECTIONAL_LIGHT</db:code>, <db:code>POINT_LIGHT</db:code>, <db:code>SPOT_LIGHT</db:code>, <db:code>AMBIENT_LIGHT</db:code>, <db:code>SPECULAR_LIGHT</db:code>. For now let's focus on <db:code>MAIN</db:code>.</db:para>
<db:para>As shown here, the end result with an empty MAIN() is exactly the same as before.</db:para>
<db:para>Before making it more interesting, let's look at an overview of the most commonly used special keywords in custom vertex shader snippets. This is not the full list. For a full reference, check the <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> page.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Keyword</db:para>
</db:th>
<db:th>
<db:para>Type</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>MAIN</db:para>
</db:td>
<db:td>
</db:td>
<db:td>
<db:para>void MAIN() is the entry point. This function must always be present in a custom vertex shader snippet, there is no point in providing one otherwise.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>VERTEX</db:para>
</db:td>
<db:td>
<db:para>vec3</db:para>
</db:td>
<db:td>
<db:para>The vertex position the shader receives as input. A common use case for vertex shaders in custom materials is to change (displace) the x, y, or z values of this vector, by simply assigning a value to the whole vector, or some of its components.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>NORMAL</db:para>
</db:td>
<db:td>
<db:para>vec3</db:para>
</db:td>
<db:td>
<db:para>The vertex normal from the input mesh data, or all zeroes if there were no normals provided. As with VERTEX, the shader is free to alter the value as it sees fit. The altered value is then used by the rest of the pipeline, including the lighting calculations in the fragment stage.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>UV0</db:para>
</db:td>
<db:td>
<db:para>vec2</db:para>
</db:td>
<db:td>
<db:para>The first set of texture coordinates from the input mesh data, or all zeroes if there were no UV values provided. As with VERTEX and NORMAL, the value can altered.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>MODELVIEWPROJECTION_MATRIX</db:para>
</db:td>
<db:td>
<db:para>mat4</db:para>
</db:td>
<db:td>
<db:para>The model-view-projection matrix. To unify the behavior regardless of which graphics API rendering happens with, all vertex data and transformation matrices follow OpenGL conventions on this level. (Y axis pointing up, OpenGL-compatible projection matrix) Read only.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>MODEL_MATRIX</db:para>
</db:td>
<db:td>
<db:para>mat4</db:para>
</db:td>
<db:td>
<db:para>The model (world) matrix. Read only.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>NORMAL_MATRIX</db:para>
</db:td>
<db:td>
<db:para>mat3</db:para>
</db:td>
<db:td>
<db:para>The transposed inverse of the top-left 3x3 slice of the model matrix. Read only.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>CAMERA_POSITION</db:para>
</db:td>
<db:td>
<db:para>vec3</db:para>
</db:td>
<db:td>
<db:para>The camera position in world space. In the examples on this page this is <db:code>(0, 0, 600)</db:code>. Read only.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>CAMERA_DIRECTION</db:para>
</db:td>
<db:td>
<db:para>vec3</db:para>
</db:td>
<db:td>
<db:para>The camera direction vector. In the examples on this page this is <db:code>(0, 0, -1)</db:code>. Read only.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>CAMERA_PROPERTIES</db:para>
</db:td>
<db:td>
<db:para>vec2</db:para>
</db:td>
<db:td>
<db:para>The near and far clip values of the camera. In the examples on this page this is <db:code>(10, 10000)</db:code>. Read only.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>POINT_SIZE</db:para>
</db:td>
<db:td>
<db:para>float</db:para>
</db:td>
<db:td>
<db:para>Relevant only when rendering with a topology of points, for example because the <db:link xlink:href="qquick3dgeometry.xml">custom geometry</db:link> provides such a geometry for the mesh. Writing to this value is equivalent to setting <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#pointSize-prop">pointSize on a PrincipledMaterial</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>POSITION</db:para>
</db:td>
<db:td>
<db:para>vec4</db:para>
</db:td>
<db:td>
<db:para>Like <db:code>gl_Position</db:code>. When not present, a default assignment statement is generated automatically using <db:code>MODELVIEWPROJECTION_MATRIX</db:code> and <db:code>VERTEX</db:code>. This is why an empty MAIN() is functional, and in most cases there will be no need to assign a custom value to it.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Let's make a custom material that displaces the vertices according to some pattern. To make it more interesting, have some animated QML properties, the values of which end up being exposed as uniforms in the shader code. (to be precise, most properties are going to be mapped to members in a uniform block, backed by a uniform buffer at run time, but Qt Quick 3D conveniently makes such details transparent to the custom material author)</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml, material.vert</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">materials: CustomMaterial {
   vertexShader: &quot;material.vert&quot;
   property real uAmplitude: 0
   NumberAnimation on uAmplitude {
       from: 0; to: 100; duration: 5000; loops: -1
   }
   property real uTime: 0
   NumberAnimation on uTime {
       from: 0; to: 100; duration: 10000; loops: -1
   }
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    VERTEX.x += sin(uTime + VERTEX.y) * uAmplitude;
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-cube2-anim.gif"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="uniforms-from-qml-properties">
<db:title>Uniforms from QML properties</db:title>
<db:para>Custom properties in the <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> object get mapped to uniforms. In the above example this includes <db:code>uAmplitude</db:code> and <db:code>uTime</db:code>. Any time the values change, the updated value will become visible in the shader. This concept may already be familiar from <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link>.</db:para>
<db:para>The name of the QML property and the GLSL variable must match. There is no separate declaration in the shader code for the individual uniforms. Rather, the QML property name can be used as-is. This is why the example above can just reference <db:code>uTime</db:code> and <db:code>uAmplitude</db:code> in the vertex shader snippet without any previous declaration for them.</db:para>
<db:para>The following table lists how the types are mapped:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>QML Type</db:para>
</db:th>
<db:th>
<db:para>Shader Type</db:para>
</db:th>
<db:th>
<db:para>Notes</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>real, int, bool</db:para>
</db:td>
<db:td>
<db:para>float, int, bool</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>color</db:para>
</db:td>
<db:td>
<db:para>vec4</db:para>
</db:td>
<db:td>
<db:para>sRGB to linear conversion is performed implicitly</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>vector2d</db:para>
</db:td>
<db:td>
<db:para>vec2</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>vector3d</db:para>
</db:td>
<db:td>
<db:para>vec3</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>vector4d</db:para>
</db:td>
<db:td>
<db:para>vec4</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>matrix4x4</db:para>
</db:td>
<db:td>
<db:para>mat4</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>quaternion</db:para>
</db:td>
<db:td>
<db:para>vec4</db:para>
</db:td>
<db:td>
<db:para>scalar value is <db:code>w</db:code></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>rect</db:para>
</db:td>
<db:td>
<db:para>vec4</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>point, size</db:para>
</db:td>
<db:td>
<db:para>vec2</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qml-qtquick3d-textureinput.xml">TextureInput</db:link></db:para>
</db:td>
<db:td>
<db:para>sampler2D</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="improving-the-example">
<db:title>Improving the example</db:title>
<db:para>Before moving further, let's make the example somewhat better looking. By adding a rotated rectangle mesh and making the <db:link xlink:href="qml-qtquick3d-directionallight.xml">DirectionalLight</db:link> cast shadows, we can verify that the alteration to the cube's vertices is correctly reflected in all rendering passes, including shadow maps. To get a visible shadow, the light is now placed a bit higher on the Y axis, and a rotation is applied to have it pointing partly downwards. (this being a <db:code>directional</db:code> light, the rotation matters)</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>main.qml, material.vert</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">import QtQuick
import QtQuick3D
Item {
    View3D {
        anchors.fill: parent
        environment: SceneEnvironment { backgroundMode: SceneEnvironment.Color; clearColor: &quot;black&quot; }
        PerspectiveCamera { z: 600 }
        DirectionalLight {
            y: 200
            eulerRotation.x: -45
            castsShadow: true
        }
        Model {
            source: &quot;#Rectangle&quot;
            y: -250
            scale: Qt.vector3d(5, 5, 5)
            eulerRotation.x: -45
            materials: PrincipledMaterial { baseColor: &quot;lightBlue&quot; }
        }
        Model {
            source: &quot;#Cube&quot;
            scale: Qt.vector3d(2, 2, 2)
            eulerRotation.x: 30
            materials: CustomMaterial {
                vertexShader: &quot;material.vert&quot;
                property real uAmplitude: 0
                NumberAnimation on uAmplitude {
                    from: 0; to: 100; duration: 5000; loops: -1
                }
                property real uTime: 0
                NumberAnimation on uTime {
                    from: 0; to: 100; duration: 10000; loops: -1
                }
            }
        }
    }
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    VERTEX.x += sin(uTime + VERTEX.y) * uAmplitude;
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-cube3-anim.gif"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="adding-a-fragment-shader">
<db:title>Adding a fragment shader</db:title>
<db:para>Many custom materials will want to have a fragment shader as well. In fact, many will want only a fragment shader. If there is no extra data to be passed from the vertex to fragment stage, and the default vertex transformation is sufficient, setting the <db:code>vertexShader</db:code> property can be left out from the <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link>.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml, material.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">materials: CustomMaterial {
    fragmentShader: &quot;material.frag&quot;
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-cube4.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Our first fragment shader contains an empty MAIN() function. This is no different than not specifying a fragment shader snippet at all: what we get looks like what we get with a default <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link>.</db:para>
<db:para>Let's look at some of the commonly used keywords in fragment shaders. This is not the full list, refer to the <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> documentation for a complete reference. Many of these are read-write, meaning they have a default value, but the shader can, and often will want to, assign a different value to them.</db:para>
<db:para>As the names suggest, many of these map to similarly named <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> properties, with the same meaning and semantics, following the <db:link xlink:href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material">metallic-roughness material model</db:link>. It is up the custom material implementation to decide how these values are calculated: for example, a value for <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#base-color">BASE_COLOR</db:link> can be hard coded in the shader, can be based on sampling a texture, or can be calculated based on QML properties exposed as uniforms or on interpolated data passed along from the vertex shader.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Keyword</db:para>
</db:th>
<db:th>
<db:para>Type</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qml-qtquick3d-principledmaterial.xml#base-color">BASE_COLOR</db:link></db:para>
</db:td>
<db:td>
<db:para>vec4</db:para>
</db:td>
<db:td>
<db:para>The base color and alpha value. Corresponds to <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#baseColor-prop">PrincipledMaterial::baseColor</db:link>. The final alpha value of the fragment is the model opacity multiplied by the base color alpha. The default value is <db:code>(1.0, 1.0, 1.0, 1.0)</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>EMISSIVE_COLOR</db:para>
</db:td>
<db:td>
<db:para>vec3</db:para>
</db:td>
<db:td>
<db:para>The color of self-illumination. Corresponds to <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#emissiveFactor-prop">PrincipledMaterial::emissiveFactor</db:link>. The default value is <db:code>(0.0, 0.0, 0.0)</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>METALNESS</db:para>
</db:td>
<db:td>
<db:para>float</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-qtquick3d-principledmaterial.xml#metalness-prop">Metalness</db:link> value in range 0-1. Default to 0, which means the material is dielectric (non-metallic).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>ROUGHNESS</db:para>
</db:td>
<db:td>
<db:para>float</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-qtquick3d-principledmaterial.xml#roughness-prop">Roughness</db:link> value in range 0-1. The default value is 0. Larger values soften specular highlights and blur reflections.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>SPECULAR_AMOUNT</db:para>
</db:td>
<db:td>
<db:para>float</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qml-qtquick3d-principledmaterial.xml#specularAmount-prop">The strength of specularity</db:link> in range 0-1. The default value is <db:code>0.5</db:code>. For metallic objects with <db:code>metalness</db:code> set to <db:code>1</db:code> this value will have no effect. When both <db:code>SPECULAR_AMOUNT</db:code> and <db:code>METALNESS</db:code> have values larger than 0 but smaller than 1, the result is a blend between the two material models.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>NORMAL</db:para>
</db:td>
<db:td>
<db:para>vec3</db:para>
</db:td>
<db:td>
<db:para>The interpolated normal in world space, adjusted for double-sidedness when face culling is disabled. Read only.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>UV0</db:para>
</db:td>
<db:td>
<db:para>vec2</db:para>
</db:td>
<db:td>
<db:para>The interpolated texture coordinates. Read only.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>VAR_WORLD_POSITION</db:para>
</db:td>
<db:td>
<db:para>vec3</db:para>
</db:td>
<db:td>
<db:para>Interpolated vertex position in world space. Read only.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Let's make the cube's base color red:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml, material.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">materials: CustomMaterial {
    fragmentShader: &quot;material.frag&quot;
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    BASE_COLOR = vec4(1.0, 0.0, 0.0, 1.0);
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-cube5.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Now strengthen the level of self-illumination a bit:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml, material.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">materials: CustomMaterial {
    fragmentShader: &quot;material.frag&quot;
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    BASE_COLOR = vec4(1.0, 0.0, 0.0, 1.0);
    EMISSIVE_COLOR = vec3(0.4);
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-cube6.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Instead of having values hardcoded in the shader, we could also use QML properties exposed as uniforms, even animated ones:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml, material.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">materials: CustomMaterial {
    fragmentShader: &quot;material.frag&quot;
    property color baseColor: &quot;black&quot;
    ColorAnimation on baseColor {
        from: &quot;black&quot;; to: &quot;purple&quot;; duration: 5000; loops: -1
    }
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    BASE_COLOR = vec4(baseColor.rgb, 1.0);
    EMISSIVE_COLOR = vec3(0.4);
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-cube7-anim.gif"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Let's do something less trivial, something that is not implementable with a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> and its standard, built-in properties. The following material visualizes the texture UV coordinates of the cube mesh. U runs 0 to 1, so from black to red, while V is also 0 to 1, black to green.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml, material.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">materials: CustomMaterial {
    fragmentShader: &quot;material.frag&quot;
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    BASE_COLOR = vec4(UV0, 0.0, 1.0);
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-cube8.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>While we are at it, why not visualize normals as well, this time on a sphere. Like with UVs, if a custom vertex shader snippet were to alter the value of NORMAL, the interpolated per-fragment value in the fragment shader, also exposed under the name NORMAL, would reflect those adjustments.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml, material.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">Model {
    source: &quot;#Sphere&quot;
    scale: Qt.vector3d(2, 2, 2)
    materials: CustomMaterial {
        fragmentShader: &quot;material.frag&quot;
    }
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    BASE_COLOR = vec4(NORMAL, 1.0);
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-cube9.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="colors">
<db:title>Colors</db:title>
<db:para>Let's switch over to a teapot model for a moment, make the material a blend of metallic and dielectric, and try to set a green base color for it. The <db:code>green</db:code> <db:link xlink:href="qcolor.xml">QColor</db:link> value maps to <db:code>(0, 128, 0)</db:code>, based on which our first attempt could be:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>main.qml, material.frag</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">import QtQuick
import QtQuick3D
Item {
    View3D {
        anchors.fill: parent
        environment: SceneEnvironment { backgroundMode: SceneEnvironment.Color; clearColor: &quot;black&quot; }
        PerspectiveCamera { z: 600 }
        DirectionalLight { }
        Model {
            source: &quot;teapot.mesh&quot;
            scale: Qt.vector3d(60, 60, 60)
            eulerRotation.x: 30
            materials: CustomMaterial {
                fragmentShader: &quot;material.frag&quot;
            }
        }
    }
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    BASE_COLOR = vec4(0.0, 0.5, 0.0, 1.0);
    METALNESS = 0.6;
    SPECULAR_AMOUNT = 0.4;
    ROUGHNESS = 0.4;
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-color1.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:para>This does not look entirely right. Compare with the second approach:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml, material.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">materials: CustomMaterial {
    fragmentShader: &quot;material.frag&quot;
    property color uColor: &quot;green&quot;
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    BASE_COLOR = vec4(uColor.rgb, 1.0);
    METALNESS = 0.6;
    SPECULAR_AMOUNT = 0.4;
    ROUGHNESS = 0.4;
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-color2.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Switching to a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link>, we can confirm that setting the <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#baseColor-prop">PrincipledMaterial::baseColor</db:link> to &quot;green&quot; and following the metalness and other properties, the result is identical to our second approach:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">materials: PrincipledMaterial {
    baseColor: &quot;green&quot;
    metalness: 0.6
    specularAmount: 0.4
    roughness: 0.4
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-color3.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>If the type of the <db:code>uColor</db:code> property was changed to <db:code>vector4d</db:code>, or any type other than <db:code>color</db:code>, the results would suddenly change and become identical to our first approach.</db:para>
<db:para>Why is this?</db:para>
<db:para>The answer lies in the sRGB to linear conversion that is performed implicitly for color properties of <db:link xlink:href="qml-qtquick3d-defaultmaterial.xml">DefaultMaterial</db:link>, <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link>, and also for custom properties with a <db:code>color</db:code> type in a <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link>. Such conversion is not performed for any other value, so if the shader hardcodes a color value, or bases it on a QML property with a type different from <db:code>color</db:code>, it will be up to the shader to perform linearization in case the source value was in sRGB color space. Converting to linear is important since Qt Quick 3D performs <db:link xlink:href="qml-qtquick3d-sceneenvironment.xml#tonemapMode-prop">tonemapping</db:link> on the results of fragment shading, and that process assumes values in the sRGB space as its input.</db:para>
<db:para>The built-in <db:link xlink:href="qcolor.xml">QColor</db:link> constants, such as, <db:code>&quot;green&quot;</db:code>, are all given in sRGB space. Therefore, just assigning <db:code>vec4(0.0, 0.5, 0.0, 1.0)</db:code> to <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#base-color">BASE_COLOR</db:link> in the first attempt is insufficient if we wanted a result that matches an RGB value <db:code>(0, 128, 0)</db:code> in the sRGB space. See the <db:code>BASE_COLOR</db:code> documentation in <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> for a formula for linearizing such color values. The same applies to color values retrieved by sampling textures: if the source image data is not in the sRGB color space, a conversion is needed (unless <db:link xlink:href="qml-qtquick3d-sceneenvironment.xml#tonemapMode-prop">tonemapping</db:link> is disabled).</db:para>
</db:section>
<db:section xml:id="blending">
<db:title>Blending</db:title>
<db:para>Just writing a value less than <db:code>1.0</db:code> to <db:code>BASE_COLOR.a</db:code> is not sufficient if the expectation is to get alpha blending. Such materials will very often change the values of <db:link xlink:href="qml-qtquick3d-custommaterial.xml#sourceBlend-prop">sourceBlend</db:link> and <db:link xlink:href="qml-qtquick3d-custommaterial.xml#destinationBlend-prop">destinationBlend</db:link> properties to get the desired results.</db:para>
<db:para>Also keep in mind that the combined alpha value is the <db:link xlink:href="qml-qtquick3d-node.xml#opacity-prop">Node opacity</db:link> multiplied by the material alpha.</db:para>
<db:para>To visualize, let's use a shader that assigns red with alpha <db:code>0.5</db:code> to <db:code>BASE_COLOR</db:code>:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>main.qml, material.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">import QtQuick
import QtQuick3D
Item {
    View3D {
        anchors.fill: parent
        environment: SceneEnvironment {
            backgroundMode: SceneEnvironment.Color
            clearColor: &quot;white&quot;
        }
        PerspectiveCamera {
            id: camera
            z: 600
        }
        DirectionalLight { }
        Model {
            source: &quot;#Cube&quot;
            x: -150
            eulerRotation.x: 60
            eulerRotation.y: 20
            materials: CustomMaterial {
                fragmentShader: &quot;material.frag&quot;
            }
        }
        Model {
            source: &quot;#Cube&quot;
            eulerRotation.x: 60
            eulerRotation.y: 20
            materials: CustomMaterial {
                sourceBlend: CustomMaterial.SrcAlpha
                destinationBlend: CustomMaterial.OneMinusSrcAlpha
                fragmentShader: &quot;material.frag&quot;
            }
        }
        Model {
            source: &quot;#Cube&quot;
            x: 150
            eulerRotation.x: 60
            eulerRotation.y: 20
            materials: CustomMaterial {
                sourceBlend: CustomMaterial.SrcAlpha
                destinationBlend: CustomMaterial.OneMinusSrcAlpha
                fragmentShader: &quot;material.frag&quot;
            }
            opacity: 0.5
        }
    }
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    BASE_COLOR = vec4(1.0, 0.0, 0.0, 0.5);
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-blend.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The first cube is writing 0.5 to the alpha value of the color but it does not bring visible results since alpha blending is not enabled. The second cube enables simple alpha blending via the <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> properties. The third one also assigns an opacity of 0.5 to the Model, which means that the effective opacity is 0.25.</db:para>
</db:section>
<db:section xml:id="passing-data-between-the-vertex-and-fragment-shader">
<db:title>Passing data between the vertex and fragment shader</db:title>
<db:para>Calculating a value per vertex (for example, assuming a single triangle, for the 3 corners of the triangle), and then passing it on to the fragment stage, where for each fragment (for example, every fragment covered by the rasterized triangle) an interpolated value is made accessible. In custom material shader snippets this is made possible by the <db:code>VARYING</db:code> keyword. This provides a syntax similar to GLSL 120 and GLSL ES 100, but will work regardless of the graphics API used at run time. The engine will take care of rewriting the varying declaration as appropriate.</db:para>
<db:para>Let's see how the classic texture sampling with UV coordinates would look like. Textures are going to be covered in an upcoming section, for now let's focus on how we get the UV coordinates that can be passed to the <db:code>texture()</db:code> function in the shader.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>main.qml, material.vert, material.frag</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">import QtQuick
import QtQuick3D
Item {
    View3D {
        anchors.fill: parent
        environment: SceneEnvironment { backgroundMode: SceneEnvironment.Color; clearColor: &quot;black&quot; }
        PerspectiveCamera { z: 600 }
        DirectionalLight { }
        Model {
            source: &quot;#Sphere&quot;
            scale: Qt.vector3d(4, 4, 4)
            eulerRotation.x: 30
            materials: CustomMaterial {
                vertexShader: &quot;material.vert&quot;
                fragmentShader: &quot;material.frag&quot;
                property TextureInput someTextureMap: TextureInput {
                    texture: Texture {
                        source: &quot;qt_logo_rect.png&quot;
                    }
                }
            }
        }
    }
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">VARYING vec2 uv;
void MAIN()
{
    uv = UV0;
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">VARYING vec2 uv;
void MAIN()
{
    BASE_COLOR = texture(someTextureMap, uv);
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>qt_logo_rect.png</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-varying-map.png"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-varying1.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Note that <db:code>VARYING</db:code> declarations. The name and type must match, <db:code>uv</db:code> in the fragment shader will expose the interpolated UV coordinate for the current fragment.</db:para>
<db:para>Any other type of data can be passed on to the fragment stage in a similar manner. It is worth noting that in many cases setting up the material's own varyings is not necessary because there are builtins provided that cover many of typical needs. This includes making the (interpolated) normals, UVs, world position (<db:code>VAR_WORLD_POSITION</db:code>), or the vector pointing towards the camera (<db:code>VIEW_VECTOR</db:code>).</db:para>
<db:para>The above example can in fact be simplified to the following as <db:code>UV0</db:code> is automatically available in the fragment stage as well:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml, material.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">materials: CustomMaterial {
    fragmentShader: &quot;material.frag&quot;
    property TextureInput someTextureMap: TextureInput {
        texture: Texture {
        source: &quot;qt_logo_rect.png&quot;
    }
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    BASE_COLOR = texture(someTextureMap, UV0);
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-varying1.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="textures">
<db:title>Textures</db:title>
<db:para>A <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> has no built-in texture maps, meaning there is no equivalent of, for example, <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#baseColorMap-prop">PrincipledMaterial::baseColorMap</db:link>. This is because implementing the same is often trivial, while giving a lot more flexibility than what <db:link xlink:href="qml-qtquick3d-defaultmaterial.xml">DefaultMaterial</db:link> and <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> has built in. Besides simply sampling a texture, custom fragment shader snippets are free to combine and blend data from various sources when calculating the values they assign to <db:code>BASE_COLOR</db:code>, <db:code>EMISSIVE_COLOR</db:code>, <db:code>ROUGHNESS</db:code>, etc. They can base these calculations on data provided via QML properties, interpolated data sent on from the vertex stage, values retrieved from sampling textures, and on hardcoded values.</db:para>
<db:para>As the previous example shows, exposing a texture to the vertex, fragment, or both shaders is very similar to scalar and vector uniform values: a QML property with the type <db:link xlink:href="qml-qtquick3d-textureinput.xml">TextureInput</db:link> will automatically get associated with a <db:code>sampler2D</db:code> in the shader code. As always, there is no need to declare this sampler in the shader code.</db:para>
<db:para>A <db:link xlink:href="qml-qtquick3d-textureinput.xml">TextureInput</db:link> references a <db:link xlink:href="qml-qtquick3d-texture.xml">Texture</db:link>, with an additional <db:link xlink:href="qml-qtquick3d-textureinput.xml#enabled-prop">enabled</db:link> property. A <db:link xlink:href="qml-qtquick3d-texture.xml">Texture</db:link> can source its data in three ways: <db:link xlink:href="qml-qtquick3d-texture.xml#source-prop">from an image file</db:link>, <db:link xlink:href="qml-qtquick3d-texture.xml#sourceItem-prop">from a texture with live Qt Quick content</db:link>, or <db:link xlink:href="qml-qtquick3d-texture.xml#textureData-prop">can be provided from C++</db:link> via <db:link xlink:href="qquick3dtexturedata.xml">QQuick3DTextureData</db:link>.</db:para>
<db:note>
<db:para>When it comes to <db:link xlink:href="qml-qtquick3d-texture.xml">Texture</db:link> properties, the source, tiling, and filtering related ones are the only ones that are taken into account implicitly with custom materials, as the rest (such as, UV transformations) is up to the custom shaders to implement as they see fit.</db:para>
</db:note>
<db:para>Let's see an example where a model, a sphere in this case, is textured using live Qt Quick content:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>main.qml, material.frag</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">import QtQuick
import QtQuick3D
Item {
    View3D {
        anchors.fill: parent
        environment: SceneEnvironment { backgroundMode: SceneEnvironment.Color; clearColor: &quot;black&quot; }
        PerspectiveCamera { z: 600 }
        DirectionalLight { }
        Model {
            source: &quot;#Sphere&quot;
            scale: Qt.vector3d(4, 4, 4)
            eulerRotation.x: 30
            materials: CustomMaterial {
                fragmentShader: &quot;material.frag&quot;
                property TextureInput someTextureMap: TextureInput {
                    texture: Texture {
                        sourceItem: Rectangle {
                            width: 512; height: 512
                            color: &quot;red&quot;
                            Rectangle {
                                width: 32; height: 32
                                anchors.horizontalCenter: parent.horizontalCenter
                                y: 150
                                color: &quot;gray&quot;;
                                NumberAnimation on rotation { from: 0; to: 360; duration: 3000; loops: -1 }
                            }
                            Text {
                                anchors.centerIn: parent
                                text: &quot;Texture Map&quot;
                                font.pointSize: 16
                            }
                        }
                    }
                }
            }
        }
    }
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    vec2 uv = vec2(UV0.x, 1.0 - UV0.y);
    vec4 c = texture(someTextureMap, uv);
    BASE_COLOR = c;
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custmat-tex1-anim.gif"/>
</db:imageobject>
</db:mediaobject>
<db:para>Here the 2D subtree (Rectangle with two children: another Rectangle and the Text) is rendered in to an 512x512 2D texture every time this mini-scene changes. The texture is then exposed to the custom material under the name of <db:code>someTextureMap</db:code>.</db:para>
<db:para>Note the flipping of the V coordinate in the shader. As noted above, custom materials, where there is full programmability on shader level, do not offer the &quot;fixed&quot; features of <db:link xlink:href="qml-qtquick3d-texture.xml">Texture</db:link> and <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link>. This means that any transformations to the UV coordinates will need to be applied by the shader. Here we know that the texture is generated via <db:link xlink:href="qml-qtquick3d-texture.xml#sourceItem-prop">Texture::sourceItem</db:link> and so V needs to be flipped to get something that matches the UV set of the mesh we are using.</db:para>
<db:para>What this example shows is possible to do with a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> too. Let's make it more interesting by doing a simple emboss effect in addition:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>material.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    vec2 uv = vec2(UV0.x, 1.0 - UV0.y);
    vec2 size = vec2(textureSize(someTextureMap, 0));
    vec2 d = vec2(1.0 / size.x, 1.0 / size.y);
    vec4 diff = texture(someTextureMap, uv + d) - texture(someTextureMap, uv - d);
    float c = (diff.x + diff.y + diff.z) + 0.5;
    BASE_COLOR = vec4(c, c, c, 1.0);
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custmat-tex2-anim.gif"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>With the features covered so far a wide range of possibilities are open for creating materials that shade the meshes in visually impressive ways. To finish the basic tour, let's look at an example that applies height and normal maps to a plane mesh. (a dedicated <db:code>.mesh</db:code> file is used here because the builtin <db:code>#Rectangle</db:code> does not have enough subdivisions) For better lighting results, we will use image based lighting with a 360 degree HDR image. The image is also set as the skybox to make it more clear what is happening.</db:para>
<db:para>First let's start with an empty <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link>:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>main.qml</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">import QtQuick
import QtQuick3D
Item {
    View3D {
        anchors.fill: parent
        environment: SceneEnvironment {
            backgroundMode: SceneEnvironment.SkyBox
            lightProbe: Texture {
                source: &quot;00489_OpenfootageNET_snowfield_low.hdr&quot;
            }
        }
        PerspectiveCamera {
            z: 600
        }
        Model {
            source: &quot;plane.mesh&quot;
            scale: Qt.vector3d(400, 400, 400)
            z: 400
            y: -50
            eulerRotation.x: -90
            materials: CustomMaterial { }
        }
    }
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-tex3.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Now let's make some shaders that apply a height and normal map to the mesh:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Height map</db:para>
</db:th>
<db:th>
<db:para>Normap map</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-heightmap.png"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-normalmap.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>material.vert, material.frag</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="cpp" role="bad">float getHeight(vec2 pos)
{
    return texture(heightMap, pos).r;
}

void MAIN()
{
    const float offset = 0.004;
    VERTEX.y += getHeight(UV0);
    TANGENT = normalize(vec3(0.0, getHeight(UV0 + vec2(0.0, offset)) - getHeight(UV0 + vec2(0.0, -offset)), offset * 2.0));
    BINORMAL = normalize(vec3(offset * 2.0, getHeight(UV0 + vec2(offset, 0.0)) - getHeight(UV0 + vec2(-offset, 0.0)), 0.0));
    NORMAL = cross(TANGENT, BINORMAL);
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    vec3 normalValue = texture(normalMap, UV0).rgb;
    normalValue.xy = normalValue.xy * 2.0 - 1.0;
    normalValue.z = sqrt(max(0.0, 1.0 - dot(normalValue.xy, normalValue.xy)));
    NORMAL = normalize(mix(NORMAL, TANGENT * normalValue.x + BINORMAL * normalValue.y + NORMAL * normalValue.z, 1.0));
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">materials: CustomMaterial {
    vertexShader: &quot;material.vert&quot;
    fragmentShader: &quot;material.frag&quot;
    property TextureInput normalMap: TextureInput {
        texture: Texture { source: &quot;normalmap.jpg&quot; }
    }
    property TextureInput heightMap: TextureInput {
        texture: Texture { source: &quot;heightmap.png&quot; }
    }
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-tex4.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:note>
<db:para>The <db:link xlink:href="qml-qtquick3d-helpers-wasdcontroller.xml">WasdController</db:link> object can be immensely helpful during development and troubleshooting as it allows navigating and looking around in the scene with the keyboard and mouse in a familiar manner. Having a camera controlled by the <db:link xlink:href="qml-qtquick3d-helpers-wasdcontroller.xml">WasdController</db:link> is as simple as:</db:para>
</db:note>
<db:programlisting language="qml">import QtQuick3D.Helpers
View3D {
    PerspectiveCamera {
        id: camera
    }
    // ...
}
WasdController {
    controlledObject: camera
}
</db:programlisting>
</db:section>
<db:section xml:id="depth-and-screen-textures">
<db:title>Depth and screen textures</db:title>
<db:para>When a custom shader snippet uses the <db:code>DEPTH_TEXTURE</db:code> or <db:code>SCREEN_TEXTURE</db:code> keywords, it opts in to generating the corresponding textures in a separate render pass, which is not necessarily a cheap operation, but allows implementing a variety of techniques, such as refraction for glass-like materials.</db:para>
<db:para><db:code>DEPTH_TEXTURE</db:code> is a <db:code>sampler2D</db:code> that allows sampling a texture with the contents of the depth buffer with all the <db:code>opaque</db:code> objects in the scene rendered. Similarly, <db:code>SCREEN_TEXTURE</db:code> is a <db:code>sampler2D</db:code> that allows sampling a texture containing the contents of the scene excluding any transparent materials or any materials also using the SCREEN_TEXTURE. The texture can be used for materials that require the contents of the framebuffer they are being rendered to. The SCREEN_TEXTURE texture uses the same clear mode as the <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link>. The size of these textures matches the size of the <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> in pixels.</db:para>
<db:para>Let's have a simple demonstration by visualizing the depth buffer contents via <db:code>DEPTH_TEXTURE</db:code>. The camera's <db:link xlink:href="qml-qtquick3d-perspectivecamera.xml#clipFar-prop">far clip value</db:link> is reduced here from the default 10000 to 2000, in order to have a smaller range, and so have the visualized depth value differences more obvious. The result is a rectangle that happens to visualize the depth buffer for the scene over its surface.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>main.qml, material.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">import QtQuick
import QtQuick3D
import QtQuick3D.Helpers
Rectangle {
    width: 400
    height: 400
    color: &quot;black&quot;
    View3D {
        anchors.fill: parent
        PerspectiveCamera {
            id: camera
            z: 600
            clipNear: 1
            clipFar: 2000
        }
        DirectionalLight { }
        Model {
            source: &quot;#Cube&quot;
            scale: Qt.vector3d(2, 2, 2)
            position: Qt.vector3d(150, 200, -1000)
            eulerRotation.x: 60
            eulerRotation.y: 20
            materials: PrincipledMaterial { }
        }
        Model {
            source: &quot;#Cylinder&quot;
            scale: Qt.vector3d(2, 2, 2)
            position: Qt.vector3d(400, 200, -1000)
            materials: PrincipledMaterial { }
            opacity: 0.3
        }
        Model {
            source: &quot;#Sphere&quot;
            scale: Qt.vector3d(2, 2, 2)
            position: Qt.vector3d(-150, 200, -600)
            materials: PrincipledMaterial { }
        }
        Model {
            source: &quot;#Cone&quot;
            scale: Qt.vector3d(2, 2, 2)
            position: Qt.vector3d(0, 400, -1200)
            materials: PrincipledMaterial { }
        }
        Model {
            source: &quot;#Rectangle&quot;
            scale: Qt.vector3d(3, 3, 3)
            y: -150
            materials: CustomMaterial {
                fragmentShader: &quot;material.frag&quot;
            }
        }
    }
    WasdController {
        controlledObject: camera
    }
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    float zNear = CAMERA_PROPERTIES.x;
    float zFar = CAMERA_PROPERTIES.y;
    float zRange = zFar - zNear;
    vec4 depthSample = texture(DEPTH_TEXTURE, vec2(UV0.x, 1.0 - UV0.y));
    float zn = 2.0 * depthSample.r - 1.0;
    float d = 2.0 * zNear * zFar / (zFar + zNear - zn * zRange);
    d /= zFar;
    BASE_COLOR = vec4(d, d, d, 1.0);
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-depth-anim.gif"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Note how the cylinder is not present in <db:code>DEPTH_TEXTURE</db:code> due to its reliance on semi-transparency, which puts it into a different category than the other objects that are all opaque. These objects do not write into the depth buffer, although they do test against the depth values written by opaque objects, and rely on being rendered in back to front order. Hence they are not present in <db:code>DEPTH_TEXTURE</db:code> either.</db:para>
<db:para>What happens if we switch the shader to sample <db:code>SCREEN_TEXTURE</db:code> instead?</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>material.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    vec4 c = texture(SCREEN_TEXTURE, vec2(UV0.x, 1.0 - UV0.y));
    if (c.a == 0.0)
        c.rgb = vec3(0.2, 0.1, 0.3);
    BASE_COLOR = c;
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-screen.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Here the rectangle is textured with <db:code>SCREEN_TEXTURE</db:code>, while replacing transparent pixels with purple.</db:para>
</db:section>
<db:section xml:id="light-processor-functions">
<db:title>Light processor functions</db:title>
<db:para>An advanced feature of <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> is the ability to define functions in the fragment shader that reimplement the lighting equations that are used to calculate the fragment color. A light processor function, when present, is called once per each light in the scene, for each fragment. There is a dedicated function for different light types, as well as the ambient and specular contribution. When no corresponding light processor function is present, the standard calculations are used, just like a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> would do. When a light processor is present, but the function body is empty, it means there will be no contribution from a given type of lights in the scene.</db:para>
<db:para>Refer to the <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> documentation for details on functions such as <db:code>DIRECTIONAL_LIGHT</db:code>, <db:code>POINT_LIGHT</db:code>, <db:code>SPOT_LIGHT</db:code>, <db:code>AMBIENT_LIGHT</db:code>, and <db:code>SPECULAR_LIGHT</db:code>.</db:para>
</db:section>
<db:section xml:id="unshaded-custom-materials">
<db:title>Unshaded custom materials</db:title>
<db:para>There is another type of <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link>: <db:code>unshaded</db:code> custom materials. All the example so far used <db:code>shaded</db:code> custom materials, with the <db:link xlink:href="qml-qtquick3d-custommaterial.xml#shadingMode-prop">shadingMode</db:link> property left at its default <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link>.Shaded value.</db:para>
<db:para>What happens if we switch this property to <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link>.Unshaded?</db:para>
<db:para>First of all, keywords like <db:code>BASE_COLOR</db:code>, <db:code>EMISSIVE_COLOR</db:code>, <db:code>METALNESS</db:code>, etc. no longer have the desired effect. This is because an unshaded material, as the name suggests, does not automatically get amended with much of the standard shading code, thus ignoring lights, image based lighting, shadows, and ambient occlusion in the scene. Rather, an unshaded material gives full control to the shader via the <db:code>FRAGCOLOR</db:code> keyword. This is similar to gl_FragColor: the color assigned to <db:code>FRAGCOLOR</db:code> is the result and the final color of the fragment, without any further adjustments by Qt Quick 3D.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>main.qml, material.frag, material2.frag</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">import QtQuick
import QtQuick3D
Item {
    View3D {
        anchors.fill: parent
        environment: SceneEnvironment {
            backgroundMode: SceneEnvironment.Color
            clearColor: &quot;black&quot;
        }
        PerspectiveCamera { z: 600 }
        DirectionalLight { }
        Model {
            source: &quot;#Cylinder&quot;
            x: -100
            eulerRotation.x: 30
            materials: CustomMaterial {
                fragmentShader: &quot;material.frag&quot;
            }
        }
        Model {
            source: &quot;#Cylinder&quot;
            x: 100
            eulerRotation.x: 30
            materials: CustomMaterial {
                shadingMode: CustomMaterial.Unshaded
                fragmentShader: &quot;material2.frag&quot;
            }
        }
    }
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    BASE_COLOR = vec4(1.0);
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    FRAGCOLOR = vec4(1.0);
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-unshaded1.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Notice how the right cylinder ignores the <db:link xlink:href="qml-qtquick3d-directionallight.xml">DirectionalLight</db:link> in the scene. Its shading knows nothing about scene lighting, the final fragment color is all white.</db:para>
<db:para>The vertex shader in an unshaded material still has the typical inputs available: <db:code>VERTEX</db:code>, <db:code>NORMAL</db:code>, <db:code>MODELVIEWPROJECTION_MATRIX</db:code>, etc. and can write to <db:code>POSITION</db:code>. The fragment shader no longer has the similar conveniences available, however: <db:code>NORMAL</db:code>, <db:code>UV0</db:code>, or <db:code>VAR_WORLD_POSITION</db:code> are not available in an unshaded material's fragment shader. Rather, it is now up to the shader code to calculate and pass on using <db:code>VARYING</db:code> everything it needs to determine the final fragment color.</db:para>
<db:para>Let's look at an example that has both a vertex and fragment shader. The altered vertex position is passed on to the fragment shader, with an interpolated value made available to every fragment.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>main.qml, material.vert, material.frag</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">import QtQuick
import QtQuick3D
Item {
    View3D {
        anchors.fill: parent
        environment: SceneEnvironment {
            backgroundMode: SceneEnvironment.Color
            clearColor: &quot;black&quot;
        }
        PerspectiveCamera { z: 600 }
        Model {
            source: &quot;#Sphere&quot;
            scale: Qt.vector3d(3, 3, 3)
            materials: CustomMaterial {
                property real time: 0.0
                NumberAnimation on time { from: 0; to: 100; duration: 20000; loops: -1 }
                property real amplitude: 10.0
                shadingMode: CustomMaterial.Unshaded
                vertexShader: &quot;material.vert&quot;
                fragmentShader: &quot;material.frag&quot;
            }
        }
    }
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">VARYING vec3 pos;
void MAIN()
{
    pos = VERTEX;
    pos.x += sin(time * 4.0 + pos.y) * amplitude;
    POSITION = MODELVIEWPROJECTION_MATRIX * vec4(pos, 1.0);
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">VARYING vec3 pos;
void MAIN()
{
    FRAGCOLOR = vec4(vec3(pos.x * 0.02, pos.y * 0.02, pos.z * 0.02), 1.0);
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-unshaded-anim.gif"/>
</db:imageobject>
</db:mediaobject>
<db:para>Unshaded materials are useful when interacting with scene lighting is not necessary or desired, and the material needs full control on the final fragment color. Notice how the example above has neither a <db:link xlink:href="qml-qtquick3d-directionallight.xml">DirectionalLight</db:link> nor any other lights, but the sphere with the custom material shows up as expected.</db:para>
<db:note>
<db:para>An unshaded material that only has a vertex shader snippet, but does not specify the fragmentShader property, will still be functional but the results are as if the shadingMode was set to Shaded. Therefore it makes little sense to switch shadingMode for materials that only have a vertex shader.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="programmability-for-effects">
<db:title>Programmability for Effects</db:title>
<db:para>Post-processing effects apply one or more fragment shaders to the result of a <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link>. The output from these fragment shaders is then displayed instead of the original rendering results. This is conceptually very similar to Qt Quick's <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link> and <db:link xlink:href="qml-qtquick-shadereffectsource.xml">ShaderEffectSource</db:link>.</db:para>
<db:note>
<db:para>Post-processing effects are only available when the <db:link xlink:href="qml-qtquick3d-view3d.xml#renderMode-prop">renderMode</db:link> for the <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> is set to <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link>.Offscreen.</db:para>
</db:note>
<db:para>Custom vertex shader snippets can also be specified for an effect, but they have limited usefulness and therefore are expected to be used relatively rarely. The vertex input for a post-processing effect is a quad (either two triangles or a triangle strip), transforming or displacing the vertices of that is often not helpful. It can however make sense to have a vertex shader in order to calculate and pass on data to the fragment shader using the <db:code>VARYING</db:code> keyword. As usual, the fragment shader will then receive an interpolated value based on the current fragment coordinate.</db:para>
<db:para>The syntax of the shader snippets associated with a <db:link xlink:href="qml-qtquick3d-effect.xml">Effect</db:link> is identical to the shaders for an unshaded <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link>. When it comes to the built-in special keywords, <db:code>VARYING</db:code>, <db:code>MAIN</db:code>, <db:code>FRAGCOLOR</db:code> (fragment shader only), <db:code>POSITION</db:code> (vertex shader only), <db:code>VERTEX</db:code> (vertex shader only), and <db:code>MODELVIEWPROJECTION_MATRIX</db:code> work identically to <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link>.</db:para>
<db:para>The most important special keywords for <db:link xlink:href="qml-qtquick3d-effect.xml">Effect</db:link> fragment shaders are the following:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Name</db:para>
</db:th>
<db:th>
<db:para>Type</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>INPUT</db:para>
</db:td>
<db:td>
<db:para>sampler2D</db:para>
</db:td>
<db:td>
<db:para>The sampler for the input texture. An effect will typically sample this using <db:code>INPUT_UV</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>INPUT_UV</db:para>
</db:td>
<db:td>
<db:para>vec2</db:para>
</db:td>
<db:td>
<db:para>UV coordinates for sampling <db:code>INPUT</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>INPUT_SIZE</db:para>
</db:td>
<db:td>
<db:para>vec2</db:para>
</db:td>
<db:td>
<db:para>The size of the <db:code>INPUT</db:code> texture, in pixels. This is a convenient alternative to calling textureSize().</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>OUTPUT_SIZE</db:para>
</db:td>
<db:td>
<db:para>vec2</db:para>
</db:td>
<db:td>
<db:para>The size of the output texture, in pixels. Equal to <db:code>INPUT_SIZE</db:code> in many cases, but a multi-pass effect may have passes that output to intermediate textures with different sizes.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>DEPTH_TEXTURE</db:para>
</db:td>
<db:td>
<db:para>sampler2D</db:para>
</db:td>
<db:td>
<db:para>Depth texture with the depth buffer contents with the opaque objects in the scene. Like with <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link>, the presence of this keyword in the shader triggers generating the depth texture automatically.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section xml:id="a-post-processing-effect">
<db:title>A post-processing effect</db:title>
<db:para>Let's start with a simple scene, this time using a few more objects, including a textured rectangle that uses a checkerboard texture as its base color map.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>main.qml</db:para>
</db:th>
<db:th>
<db:para>Result</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">import QtQuick
import QtQuick3D
Item {
    View3D {
        anchors.fill: parent
        environment: SceneEnvironment {
            backgroundMode: SceneEnvironment.Color
            clearColor: &quot;black&quot;
        }

        PerspectiveCamera { z: 400 }

        DirectionalLight { }

        Texture {
            id: checkerboard
            source: &quot;checkerboard.png&quot;
            scaleU: 20
            scaleV: 20
            tilingModeHorizontal: Texture.Repeat
            tilingModeVertical: Texture.Repeat
        }

        Model {
            source: &quot;#Rectangle&quot;
            scale: Qt.vector3d(10, 10, 1)
            eulerRotation.x: -45
            materials: PrincipledMaterial {
                baseColorMap: checkerboard
            }
        }

        Model {
            source: &quot;#Cone&quot;
            position: Qt.vector3d(100, -50, 100)
            materials: PrincipledMaterial { }
        }

        Model {
            source: &quot;#Cube&quot;
            position.y: 100
            eulerRotation.y: 20
            materials: PrincipledMaterial { }
        }

        Model {
            source: &quot;#Sphere&quot;
            position: Qt.vector3d(-150, 200, -100)
            materials: PrincipledMaterial { }
        }
    }
}
</db:programlisting>
</db:td>
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-effect-section-scene.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Now let's apply an affect to the entire scene. More precisely, to the <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link>. When there are multiple <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> items in the scene, each has its own <db:link xlink:href="qml-qtquick3d-sceneenvironment.xml">SceneEnvironment</db:link> and therefore have their own post-processing effect chain. In the example there is one single <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> covering the entire window.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml</db:para>
</db:th>
<db:th>
<db:para>effect.frag</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">environment: SceneEnvironment {
    backgroundMode: SceneEnvironment.Color
    clearColor: &quot;black&quot;
    effects: redEffect
}

Effect {
    id: redEffect
    property real uRed: 1.0
    NumberAnimation on uRed { from: 1; to: 0; duration: 5000; loops: -1 }
    passes: Pass {
        shaders: Shader {
            stage: Shader.Fragment
            shader: &quot;effect.frag&quot;
        }
    }
}
</db:programlisting>
</db:td>
<db:td>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    vec4 c = texture(INPUT, INPUT_UV);
    c.r = uRed;
    FRAGCOLOR = c;
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This simple effect alters the red color channel value. Exposing QML properties as uniforms works the same way with effects as with custom materials. The shader starts with a line that is going to be very common when writing fragment shaders fro effects: sampling <db:code>INPUT</db:code> at the UV coordinates <db:code>INPUT_UV</db:code>. It then performs its desired calculations, and assigns the final fragment color to <db:code>FRAGCOLOR</db:code>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-first-effect-anim.gif"/>
</db:imageobject>
</db:mediaobject>
<db:para>Many properties set in the example are in plural (effects, passes, shaders). While the list <db:code>[ ]</db:code> syntax can be omitted when having a single element only, all these properties are lists, and can hold more than one element. Why is this?</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick3d-sceneenvironment.xml#effects-prop">effects</db:link> is a list, because <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> allows chaining multiple effects together. The effects are applied in the order in which they are added to the list. This allows easily applying two or more effects together to the <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link>, and is similar to what one can achieve in Qt Quick by nesting <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link> items. The <db:code>INPUT</db:code> texture of the next effect is always a texture that contains the previous effect's output. The output of the last effect in what gets used as the final output of the <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick3d-effect.xml#passes-prop">passes</db:link> is a list, because unlike <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link>, Effect has built-in support for multiple passes. A multi-pass effect is more powerful than chaining together multiple, independent effects in <db:link xlink:href="qml-qtquick3d-sceneenvironment.xml#effects-prop">effects</db:link>: a pass can output to a temporary, intermediate texture, which can then be used as input to subsequent passes, in addition to the original input texture of the effect. This allows creating complex effects that calculate, render, and blend together multiple textures in order to get to the final fragment color. This advanced use case is not going to be covered here. Refer to the <db:link xlink:href="qml-qtquick3d-effect.xml">Effect</db:link> documentation page for details.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick3d-pass.xml#shaders-prop">shaders</db:link> is a list, because an effect may have both a vertex and a fragment shader associated.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="chaining-multiple-effects">
<db:title>Chaining multiple effects</db:title>
<db:para>Let's look at an example where the effect from the previous example gets complemented by another effect similar to the built-in <db:link xlink:href="qml-qtquick3d-effects-distortionspiral.xml" role="deprecated">DistortionSpiral</db:link> effect.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Change in main.qml</db:para>
</db:th>
<db:th>
<db:para>effect2.frag</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">environment: SceneEnvironment {
    backgroundMode: SceneEnvironment.Color
    clearColor: &quot;black&quot;
    effects: [redEffect, distortEffect]
}

Effect {
    id: redEffect
    property real uRed: 1.0
    NumberAnimation on uRed { from: 1; to: 0; duration: 5000; loops: -1 }
    passes: Pass {
        shaders: Shader {
            stage: Shader.Fragment
            shader: &quot;effect.frag&quot;
        }
    }
}

Effect {
    id: distortEffect
    property real uRadius: 0.1
    NumberAnimation on uRadius { from: 0.1; to: 1.0; duration: 5000; loops: -1 }
    passes: Pass {
        shaders: Shader {
            stage: Shader.Fragment
            shader: &quot;effect2.frag&quot;
        }
    }
}
</db:programlisting>
</db:td>
<db:td>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    vec2 center_vec = INPUT_UV - vec2(0.5, 0.5);
    center_vec.y *= INPUT_SIZE.y / INPUT_SIZE.x;
    float dist_to_center = length(center_vec) / uRadius;
    vec2 texcoord = INPUT_UV;
    if (dist_to_center &amp;lt;= 1.0) {
        float rotation_amount = (1.0 - dist_to_center) * (1.0 - dist_to_center);
        float r = radians(360.0) * rotation_amount / 4.0;
        float cos_r = cos(r);
        float sin_r = sin(r);
        mat2 rotation = mat2(cos_r, sin_r, -sin_r, cos_r);
        texcoord = vec2(0.5, 0.5) + rotation * (INPUT_UV - vec2(0.5, 0.5));
    }
    vec4 c = texture(INPUT, texcoord);
    FRAGCOLOR = c;
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-chained-effect-anim.gif"/>
</db:imageobject>
</db:mediaobject>
<db:para>Now the perhaps surprising question: why is this a bad example?</db:para>
<db:para>More precisely, it is not bad, but rather shows a pattern that can often be beneficial to avoid.</db:para>
<db:para>Chaining effects this way can be useful, but it is important to keep in mind the performance implications: doing two render passes (one to generate a texture with the adjusted red color channel, and then another one two calculate the distortion) is quite wasteful when one would be enough. If the fragment shader snippets were combined, the same result could have been achieved with one single effect.</db:para>
</db:section>
</db:section>
<db:section xml:id="defining-mesh-and-texture-data-from-c">
<db:title>Defining Mesh and Texture Data from C++</db:title>
<db:para>Procedurally generating mesh and texture image data both follow similar steps:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Subclass <db:link xlink:href="qquick3dgeometry.xml">QQuick3DGeometry</db:link> or <db:link xlink:href="qquick3dtexturedata.xml">QQuick3DTextureData</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Set the desired vertex or image data upon construction by calling the protected member functions from the base class</db:para>
</db:listitem>
<db:listitem>
<db:para>If dynamic changes are needed afterwards at some point, set the new data and call update()</db:para>
</db:listitem>
<db:listitem>
<db:para>Once the implementation is done, the class needs to be registered to make it visible in QML</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick3d-model.xml">Model</db:link> and <db:link xlink:href="qml-qtquick3d-texture.xml">Texture</db:link> objects in QML can now use the custom vertex or image data provider by setting the <db:link xlink:href="qml-qtquick3d-model.xml#geometry-prop">Model::geometry</db:link> or <db:link xlink:href="qml-qtquick3d-texture.xml#textureData-prop">Texture::textureData</db:link> property</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="custom-vertex-data">
<db:title>Custom vertex data</db:title>
<db:para>Vertex data refers to the sequence of (typically <db:code>float</db:code>) values that make up a mesh. Instead of loading <db:code>.mesh</db:code> files, a custom geometry provider is responsible for providing the same data. The vertex data consist of <db:code>attributes</db:code>, such as position, texture (UV) coordinates, or normals. The specification of attributes describes what kind of attributes are present, the component type (for example, a 3 component float vector for vertex position consisting of x, y, z values), which offset they start at in the provided data, and what the stride (the increment that needs to be added to the offset to point to the next element for the same attribute) is.</db:para>
<db:para>This may seem familiar if one has worked with graphics APIs, such as OpenGL or Vulkan directly, because the way vertex input is specified with those APIs maps loosely to what a <db:code>.mesh</db:code> file or a <db:link xlink:href="qquick3dgeometry.xml">QQuick3DGeometry</db:link> instance defines.</db:para>
<db:para>In addition, the mesh topology (primitive type) must be specified too. For indexed drawing, the data for an index buffer must be provided as well.</db:para>
<db:para>There is one built-in custom geometry implementation: the <db:link xlink:href="qtquick3d-qmlmodule.xml">QtQuick3D</db:link>.Helpers module includes a <db:link xlink:href="qml-qtquick3d-helpers-gridgeometry.xml">GridGeometry</db:link> type. This allows rendering a grid in the scene with line primitives, without having to implement a custom <db:link xlink:href="qquick3dgeometry.xml">QQuick3DGeometry</db:link> subclass.</db:para>
<db:para>One other common use cases is rendering points. This is fairly simple to do since the attribute specification is going to be minimal: we provide three floats (x, y, z) for each vertex, nothing else. A <db:link xlink:href="qquick3dgeometry.xml">QQuick3DGeometry</db:link> subclass could implement a geometry consisting of 2000 points similarly to the following:</db:para>
<db:programlisting language="cpp" role="bad">clear();
const int N = 2000;
const int stride = 3 * sizeof(float);
QByteArray v;
v.resize(N * stride);
float *p = reinterpret_cast&amp;lt;float *&amp;gt;(v.data());
QRandomGenerator *rg = QRandomGenerator::global();
for (int i = 0; i &amp;lt; N; ++i) {
    const float x = float(rg-&amp;gt;bounded(200.0f) - 100.0f) / 20.0f;
    const float y = float(rg-&amp;gt;bounded(200.0f) - 100.0f) / 20.0f;
    *p++ = x;
    *p++ = y;
    *p++ = 0.0f;
}
setVertexData(v);
setStride(stride);
setPrimitiveType(QQuick3DGeometry::PrimitiveType::Points);
addAttribute(QQuick3DGeometry::Attribute::PositionSemantic, 0, QQuick3DGeometry::Attribute::F32Type);
</db:programlisting>
<db:para>Combined with a material of</db:para>
<db:programlisting language="qml">DefaultMaterial {
    lighting: DefaultMaterial.NoLighting
    cullMode: DefaultMaterial.NoCulling
    diffuseColor: &quot;yellow&quot;
    pointSize: 4
}
</db:programlisting>
<db:para>the end result is similar to this (here viewed from an altered camera angle, with the help of <db:link xlink:href="qml-qtquick3d-helpers-wasdcontroller.xml">WasdController</db:link>):</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quick3d-custom-points.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:note>
<db:para>Be aware that point sizes and line widths other than 1 may not be supported at run time, depending on the underlying graphics API. This is not something Qt has control over. Therefore, it can become necessary to implement alternative techniques instead of relying on point and line drawing.</db:para>
</db:note>
</db:section>
<db:section xml:id="custom-texture-data">
<db:title>Custom texture data</db:title>
<db:para>With textures, the data that needs to be provided is a lot simpler structurally: it is the raw pixel data, with a varying number of bytes per pixel, depending on the texture format. For example, an <db:code>RGBA</db:code> texture expects four bytes per pixel, whereas <db:code>RGBA16F</db:code> is four half-floats per pixel. This is similar to what a <db:link xlink:href="qimage.xml">QImage</db:link> stores internally. However, Qt Quick 3D textures can have formats the data for which cannot be represented by a <db:link xlink:href="qimage.xml">QImage</db:link>. For example, floating point HDR textures, or compressed textures. Therefore the data for <db:link xlink:href="qquick3dtexturedata.xml">QQuick3DTextureData</db:link> is always provided as a raw sequence of bytes. This may seem familiar if one has worked with graphics APIs, such as OpenGL or Vulkan directly.</db:para>
<db:para>For details, refer to the <db:link xlink:href="qquick3dgeometry.xml">QQuick3DGeometry</db:link> and <db:link xlink:href="qquick3dtexturedata.xml">QQuick3DTextureData</db:link> documentation pages.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick3d-effect.xml">Effect</db:link></db:member>
<db:member><db:link xlink:href="qquick3dgeometry.xml">QQuick3DGeometry</db:link></db:member>
<db:member><db:link xlink:href="qquick3dtexturedata.xml">QQuick3DTextureData</db:link></db:member>
<db:member><db:link xlink:href="qtquick3d-customeffect-example.xml">Qt Quick 3D - Custom Effect Example</db:link></db:member>
<db:member><db:link xlink:href="qtquick3d-customshaders-example.xml">Qt Quick 3D - Custom Shaders Example</db:link></db:member>
<db:member><db:link xlink:href="qtquick3d-custommaterial-example.xml">Qt Quick 3D - Custom Materials Example</db:link></db:member>
<db:member><db:link xlink:href="qtquick3d-customgeometry-example.xml">Qt Quick 3D - Custom Geometry Example</db:link></db:member>
<db:member><db:link xlink:href="qtquick3d-proceduraltexture-example.xml">Qt Quick 3D - Procedural Texture Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
