<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QMutex Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.3.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qmutex.xml">QMutex</db:link> class provides access serialization between threads.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="">thread-safe</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QMutex</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QMutex is part of <db:simplelist><db:member>thread</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The purpose of a <db:link xlink:href="qmutex.xml">QMutex</db:link> is to protect an object, data structure or section of code so that only one thread can access it at a time (this is similar to the Java <db:code>synchronized</db:code> keyword). It is usually best to use a mutex with a <db:link xlink:href="qmutexlocker.xml">QMutexLocker</db:link> since this makes it easy to ensure that locking and unlocking are performed consistently.</db:para>
<db:para>For example, say there is a method that prints a message to the user on two lines:</db:para>
<db:programlisting language="cpp">int number = 6;

void method1()
{
    number *= 5;
    number /= 4;
}

void method2()
{
    number *= 3;
    number /= 2;
}
</db:programlisting>
<db:para>If these two methods are called in succession, the following happens:</db:para>
<db:programlisting language="cpp">// method1()
number *= 5;        // number is now 30
number /= 4;        // number is now 7

// method2()
number *= 3;        // number is now 21
number /= 2;        // number is now 10
</db:programlisting>
<db:para>If these two methods are called simultaneously from two threads then the following sequence could result:</db:para>
<db:programlisting language="cpp">// Thread 1 calls method1()
number *= 5;        // number is now 30

// Thread 2 calls method2().
//
// Most likely Thread 1 has been put to sleep by the operating
// system to allow Thread 2 to run.
number *= 3;        // number is now 90
number /= 2;        // number is now 45

// Thread 1 finishes executing.
number /= 4;        // number is now 11, instead of 10
</db:programlisting>
<db:para>If we add a mutex, we should get the result we want:</db:para>
<db:programlisting language="cpp">QMutex mutex;
int number = 6;

void method1()
{
    mutex.lock();
    number *= 5;
    number /= 4;
    mutex.unlock();
}

void method2()
{
    mutex.lock();
    number *= 3;
    number /= 2;
    mutex.unlock();
}
</db:programlisting>
<db:para>Then only one thread can modify <db:code>number</db:code> at any given time and the result is correct. This is a trivial example, of course, but applies to any other case where things need to happen in a particular sequence.</db:para>
<db:para>When you call <db:link xlink:href="qmutex.xml#lock">lock</db:link>() in a thread, other threads that try to call <db:link xlink:href="qmutex.xml#lock">lock</db:link>() in the same place will block until the thread that got the lock calls <db:link xlink:href="qmutex.xml#unlock">unlock</db:link>(). A non-blocking alternative to <db:link xlink:href="qmutex.xml#lock">lock</db:link>() is <db:link xlink:href="qmutex.xml#tryLock">tryLock</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmutexlocker.xml">QMutexLocker</db:link></db:member>
<db:member><db:link xlink:href="qreadwritelock.xml">QReadWriteLock</db:link></db:member>
<db:member><db:link xlink:href="qsemaphore.xml">QSemaphore</db:link></db:member>
<db:member><db:link xlink:href="qwaitcondition.xml">QWaitCondition</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="RecursionMode-enum">
<db:title>enum QMutex::RecursionMode</db:title>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmutex.xml">QMutex</db:link></db:emphasis>::Recursive</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>In this mode, a thread can lock the same mutex multiple times and the mutex won't be unlocked until a corresponding number of <db:link xlink:href="qmutex.xml#unlock">unlock</db:link>() calls have been made.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qmutex.xml">QMutex</db:link></db:emphasis>::NonRecursive</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>In this mode, a thread may only lock a mutex once.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmutex.xml#QMutex">QMutex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QMutex">
<db:title>[explicit] QMutex::QMutex(QMutex::RecursionMode <db:emphasis>mode</db:emphasis> = NonRecursive)</db:title>
<db:para>Constructs a new mutex. The mutex is created in an unlocked state.</db:para>
<db:para>If <db:code role="parameter">mode</db:code> is <db:link xlink:href="qmutex.xml#RecursionMode-enum">QMutex::Recursive</db:link>, a thread can lock the same mutex multiple times and the mutex won't be unlocked until a corresponding number of <db:link xlink:href="qmutex.xml#unlock">unlock</db:link>() calls have been made. Otherwise a thread may only lock a mutex once. The default is <db:link xlink:href="qmutex.xml#RecursionMode-enum">QMutex::NonRecursive</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmutex.xml#lock">lock</db:link>()</db:member>
<db:member><db:link xlink:href="qmutex.xml#unlock">unlock</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isRecursive">
<db:title>[since 5.0] bool QMutex::isRecursive()</db:title>
<db:para>Returns <db:code>true</db:code> if the mutex is recursive</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="lock">
<db:title>void QMutex::lock()</db:title>
<db:para>Locks the mutex. If another thread has locked the mutex then this call will block until that thread has unlocked it.</db:para>
<db:para>Calling this function multiple times on the same mutex from the same thread is allowed if this mutex is a <db:link xlink:href="qmutex.xml#RecursionMode-enum">recursive mutex</db:link>. If this mutex is a <db:link xlink:href="qmutex.xml#RecursionMode-enum">non-recursive mutex</db:link>, this function will <db:emphasis>dead-lock</db:emphasis> when the mutex is locked recursively.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmutex.xml#unlock">unlock</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="tryLock">
<db:title>bool QMutex::tryLock(int <db:emphasis>timeout</db:emphasis> = 0)</db:title>
<db:para>Attempts to lock the mutex. This function returns <db:code>true</db:code> if the lock was obtained; otherwise it returns <db:code>false</db:code>. If another thread has locked the mutex, this function will wait for at most <db:code role="parameter">timeout</db:code> milliseconds for the mutex to become available.</db:para>
<db:para>Note: Passing a negative number as the <db:code role="parameter">timeout</db:code> is equivalent to calling <db:link xlink:href="qmutex.xml#lock">lock</db:link>(), i.e. this function will wait forever until mutex can be locked if <db:code role="parameter">timeout</db:code> is negative.</db:para>
<db:para>If the lock was obtained, the mutex must be unlocked with <db:link xlink:href="qmutex.xml#unlock">unlock</db:link>() before another thread can successfully lock it.</db:para>
<db:para>Calling this function multiple times on the same mutex from the same thread is allowed if this mutex is a <db:link xlink:href="qmutex.xml#RecursionMode-enum">recursive mutex</db:link>. If this mutex is a <db:link xlink:href="qmutex.xml#RecursionMode-enum">non-recursive mutex</db:link>, this function will <db:emphasis>always</db:emphasis> return false when attempting to lock the mutex recursively.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmutex.xml#lock">lock</db:link>()</db:member>
<db:member><db:link xlink:href="qmutex.xml#unlock">unlock</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unlock">
<db:title>void QMutex::unlock()</db:title>
<db:para>Unlocks the mutex. Attempting to unlock a mutex in a different thread to the one that locked it results in an error. Unlocking a mutex that is not locked results in undefined behavior.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmutex.xml#lock">lock</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
