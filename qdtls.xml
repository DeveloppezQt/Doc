<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QDtls Class</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 6.0.4 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>This class provides encryption for UDP sockets.</db:para>
<db:para>This class was introduced in Qt 5.12.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QDtls</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.12</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Network)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Network)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += network</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QDtls is part of <db:simplelist><db:member><db:link xlink:href="network.xml">Network Programming API</db:link></db:member><db:member>ssl</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qdtls.xml">QDtls</db:link> class can be used to establish a secure connection with a network peer using User Datagram Protocol (UDP). DTLS connection over essentially connectionless UDP means that two peers first have to successfully complete a TLS handshake by calling <db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>(). After the handshake has completed, encrypted datagrams can be sent to the peer using <db:link xlink:href="qdtls.xml#writeDatagramEncrypted">writeDatagramEncrypted</db:link>(). Encrypted datagrams coming from the peer can be decrypted by <db:link xlink:href="qdtls.xml#decryptDatagram">decryptDatagram</db:link>().</db:para>
<db:para><db:link xlink:href="qdtls.xml">QDtls</db:link> is designed to work with <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link>. Since <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> can receive datagrams coming from different peers, an application must implement demultiplexing, forwarding datagrams coming from different peers to their corresponding instances of <db:link xlink:href="qdtls.xml">QDtls</db:link>. An association between a network peer and its <db:link xlink:href="qdtls.xml">QDtls</db:link> object can be established using the peer's address and port number. Before starting a handshake, the application must set the peer's address and port number using <db:link xlink:href="qdtls.xml#setPeer">setPeer</db:link>().</db:para>
<db:para><db:link xlink:href="qdtls.xml">QDtls</db:link> does not read datagrams from <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link>, this is expected to be done by the application, for example, in a slot attached to the <db:link xlink:href="qiodevice.xml#readyRead">QUdpSocket::readyRead</db:link>() signal. Then, these datagrams must be processed by <db:link xlink:href="qdtls.xml">QDtls</db:link>.</db:para>
<db:note>
<db:para><db:link xlink:href="qdtls.xml">QDtls</db:link> does <db:emphasis>not</db:emphasis> take ownership of the <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> object.</db:para>
</db:note>
<db:para>Normally, several datagrams are to be received and sent by both peers during the handshake phase. Upon reading datagrams, server and client must pass these datagrams to <db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>() until some error is found or <db:link xlink:href="qdtls.xml#handshakeState">handshakeState</db:link>() returns <db:link xlink:href="qdtls.xml#HandshakeState-enum">HandshakeComplete</db:link>:</db:para>
<db:programlisting language="cpp">// A client initiates a handshake:
QUdpSocket clientSocket;
QDtls clientDtls;
clientDtls.setPeer(address, port, peerName);
clientDtls.doHandshake(&amp;amp;clientSocket);

// A server accepting an incoming connection; address, port, clientHello are
// read by QUdpSocket::readDatagram():
QByteArray clientHello(serverSocket.pendingDatagramSize(), Qt::Uninitialized);
QHostAddress address;
quin16 port = {};
serverSocket.readDatagram(clientHello.data(), clientHello.size(), &amp;amp;address, &amp;amp;port);

QDtls serverDtls;
serverDtls.setPeer(address, port);
serverDtls.doHandshake(&amp;amp;serverSocket, clientHello);

// Handshake completion, both for server and client:
void DtlsConnection::continueHandshake(const QByteArray &amp;amp;datagram)
{
    if (dtls.doHandshake(&amp;amp;udpSocket, datagram)) {
        // Check handshake status:
        if (dtls.handshakeStatus() == QDlts::HandshakeComplete) {
            // Secure DTLS connection is now established.
        }
    } else {
        // Error handling.
    }
}
</db:programlisting>
<db:para>For a server, the first call to <db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>() requires a non-empty datagram containing a ClientHello message. If the server also deploys <db:link xlink:href="qdtlsclientverifier.xml">QDtlsClientVerifier</db:link>, the first ClientHello message is expected to be the one verified by <db:link xlink:href="qdtlsclientverifier.xml">QDtlsClientVerifier</db:link>.</db:para>
<db:para>In case the peer's identity cannot be validated during the handshake, the application must inspect errors returned by <db:link xlink:href="qdtls.xml#peerVerificationErrors">peerVerificationErrors</db:link>() and then either ignore errors by calling <db:link xlink:href="qdtls.xml#ignoreVerificationErrors">ignoreVerificationErrors</db:link>() or abort the handshake by calling <db:link xlink:href="qdtls.xml#abortHandshake">abortHandshake</db:link>(). If errors were ignored, the handshake can be resumed by calling <db:link xlink:href="qdtls.xml#resumeHandshake">resumeHandshake</db:link>().</db:para>
<db:para>After the handshake has been completed, datagrams can be sent to and received from the network peer securely:</db:para>
<db:programlisting language="cpp">// Sending an encrypted datagram:
dtlsConnection.writeDatagramEncrypted(&amp;amp;clientSocket, &quot;Hello DTLS server!&quot;);

// Decryption:
QByteArray encryptedMessage(dgramSize);
socket.readDatagram(encryptedMessage.data(), dgramSize);
const QByteArray plainText = dtlsConnection.decryptDatagram(&amp;amp;socket, encryptedMessage);
</db:programlisting>
<db:para>A DTLS connection may be closed using <db:link xlink:href="qdtls.xml#shutdown">shutdown</db:link>().</db:para>
<db:programlisting language="cpp">DtlsClient::~DtlsClient()
{
    clientDtls.shutdown(&amp;amp;clientSocket);
}
</db:programlisting>
<db:warning>
<db:para>It's recommended to call <db:link xlink:href="qdtls.xml#shutdown">shutdown</db:link>() before destroying the client's <db:link xlink:href="qdtls.xml">QDtls</db:link> object if you are planning to re-use the same port number to connect to the server later. Otherwise, the server may drop incoming ClientHello messages, see <db:link xlink:href="https://tools.ietf.org/html/rfc6347#page-25">RFC 6347, section 4.2.8</db:link> for more details and implementation hints.</db:para>
</db:warning>
<db:para>If the server does not use <db:link xlink:href="qdtlsclientverifier.xml">QDtlsClientVerifier</db:link>, it <db:emphasis>must</db:emphasis> configure its <db:link xlink:href="qdtls.xml">QDtls</db:link> objects to disable the cookie verification procedure:</db:para>
<db:programlisting language="cpp">auto config = QSslConfiguration::defaultDtlsConfiguration();
config.setDtlsCookieVerificationEnabled(false);
// Some other customization ...
dtlsConnection.setDtlsConfiguration(config);
</db:programlisting>
<db:para>A server that uses cookie verification with non-default generator parameters <db:emphasis>must</db:emphasis> set the same parameters for its <db:link xlink:href="qdtls.xml">QDtls</db:link> object before starting the handshake.</db:para>
<db:note>
<db:para>The DTLS protocol leaves Path Maximum Transmission Unit (PMTU) discovery to the application. The application may provide <db:link xlink:href="qdtls.xml">QDtls</db:link> with the MTU using <db:link xlink:href="qdtls.xml#setMtuHint">setMtuHint</db:link>(). This hint affects only the handshake phase, since only handshake messages can be fragmented and reassembled by the DTLS. All other messages sent by the application must fit into a single datagram.</db:para>
</db:note>
<db:note>
<db:para>DTLS-specific headers add some overhead to application data further reducing the possible message size.</db:para>
</db:note>
<db:warning>
<db:para>A server configured to reply with HelloVerifyRequest will drop all fragmented ClientHello messages, never starting a handshake.</db:para>
</db:warning>
<db:para>The <db:link xlink:href="qtnetwork-secureudpserver-example.xml">DTLS server</db:link> and <db:link xlink:href="qtnetwork-secureudpclient-example.xml">DTLS client</db:link> examples illustrate how to use <db:link xlink:href="qdtls.xml">QDtls</db:link> in applications.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link></db:member>
<db:member><db:link xlink:href="qdtlsclientverifier.xml">QDtlsClientVerifier</db:link></db:member>
<db:member><db:link xlink:href="qdtls.xml#HandshakeState-enum">HandshakeState</db:link></db:member>
<db:member><db:link xlink:href="qdtls.xml#QDtlsError-enum">QDtlsError</db:link></db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="GeneratorParameters-typedef">
<db:title>[alias] QDtls::GeneratorParameters</db:title>
<db:typedefsynopsis>
<db:typedefname>GeneratorParameters</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
</db:section>
<db:section xml:id="HandshakeState-enum">
<db:title>[since 5.12] enum QDtls::HandshakeState</db:title>
<db:enumsynopsis>
<db:enumname>HandshakeState</db:enumname>
<db:enumitem>
<db:enumidentifier>HandshakeNotStarted</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>HandshakeInProgress</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PeerVerificationFailed</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>HandshakeComplete</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="module">QtNetwork</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Describes the current state of DTLS handshake.</db:para>
<db:para>This enum describes the current state of DTLS handshake for a <db:link xlink:href="qdtls.xml">QDtls</db:link> connection.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::HandshakeNotStarted</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Nothing done yet.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::HandshakeInProgress</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Handshake was initiated and no errors were found so far.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::PeerVerificationFailed</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The identity of the peer can't be established.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::HandshakeComplete</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>Handshake completed successfully and encrypted connection was established.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#doHandshake">QDtls::doHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#handshakeState">QDtls::handshakeState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QDtls">
<db:title>[explicit] QDtls::QDtls(QSslSocket::SslMode <db:emphasis>mode</db:emphasis>, QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QDtls</db:methodname>
<db:methodparam>
<db:type>QSslSocket::SslMode</db:type>
<db:parameter>mode</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QDtls(QSslSocket::SslMode mode, QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qdtls.xml">QDtls</db:link> object, <db:code role="parameter">parent</db:code> is passed to the <db:link xlink:href="qobject.xml">QObject</db:link> constructor. <db:code role="parameter">mode</db:code> is <db:link xlink:href="qsslsocket.xml#SslMode-enum">QSslSocket::SslServerMode</db:link> for a server-side DTLS connection or <db:link xlink:href="qsslsocket.xml#SslMode-enum">QSslSocket::SslClientMode</db:link> for a client.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#sslMode">sslMode</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#SslMode-enum">QSslSocket::SslMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QDtls">
<db:title>[virtual] QDtls::~QDtls()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QDtls</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QDtls()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qdtls.xml">QDtls</db:link> object.</db:para>
</db:section>
<db:section xml:id="abortHandshake">
<db:title>bool QDtls::abortHandshake(QUdpSocket *<db:emphasis>socket</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>abortHandshake</db:methodname>
<db:methodparam>
<db:type>QUdpSocket *</db:type>
<db:parameter>socket</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool abortHandshake(QUdpSocket *socket)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Aborts the ongoing handshake. Returns true if one was on-going on <db:code role="parameter">socket</db:code>; otherwise, sets a suitable error and returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#resumeHandshake">resumeHandshake</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cookieGeneratorParameters">
<db:title>QDtls::GeneratorParameters QDtls::cookieGeneratorParameters() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDtls::GeneratorParameters</db:type>
<db:methodname>cookieGeneratorParameters</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDtls::GeneratorParameters cookieGeneratorParameters() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current hash algorithm and secret, either default ones or previously set by a call to <db:link xlink:href="qdtls.xml#setCookieGeneratorParameters">setCookieGeneratorParameters</db:link>().</db:para>
<db:para>The default hash algorithm is <db:link xlink:href="qcryptographichash.xml#Algorithm-enum">QCryptographicHash::Sha256</db:link> if Qt was configured to support it, <db:link xlink:href="qcryptographichash.xml#Algorithm-enum">QCryptographicHash::Sha1</db:link> otherwise. The default secret is obtained from the backend-specific cryptographically strong pseudorandom number generator.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#setCookieGeneratorParameters">setCookieGeneratorParameters</db:link>()</db:member>
<db:member><db:link xlink:href="qdtlsclientverifier.xml">QDtlsClientVerifier</db:link></db:member>
<db:member>cookieGeneratorParameters()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="decryptDatagram">
<db:title>QByteArray QDtls::decryptDatagram(QUdpSocket *<db:emphasis>socket</db:emphasis>, const QByteArray &amp;<db:emphasis>dgram</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray</db:type>
<db:methodname>decryptDatagram</db:methodname>
<db:methodparam>
<db:type>QUdpSocket *</db:type>
<db:parameter>socket</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>dgram</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray decryptDatagram(QUdpSocket *socket, const QByteArray &amp;dgram)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Decrypts <db:code role="parameter">dgram</db:code> and returns its contents as plain text. The handshake must be completed before datagrams can be decrypted. Depending on the type of the TLS message the connection may write into <db:code role="parameter">socket</db:code>, which must be a valid pointer.</db:para>
</db:section>
<db:section xml:id="doHandshake">
<db:title>bool QDtls::doHandshake(QUdpSocket *<db:emphasis>socket</db:emphasis>, const QByteArray &amp;<db:emphasis>dgram</db:emphasis> = {})</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>doHandshake</db:methodname>
<db:methodparam>
<db:type>QUdpSocket *</db:type>
<db:parameter>socket</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>dgram</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool doHandshake(QUdpSocket *socket, const QByteArray &amp;dgram)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Starts or continues a DTLS handshake. <db:code role="parameter">socket</db:code> must be a valid pointer. When starting a server-side DTLS handshake, <db:code role="parameter">dgram</db:code> must contain the initial ClientHello message read from <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link>. This function returns true if no error was found. Handshake state can be tested using <db:link xlink:href="qdtls.xml#handshakeState">handshakeState</db:link>(). false return means some error occurred, use <db:link xlink:href="qdtls.xml#dtlsError">dtlsError</db:link>() for more detailed information.</db:para>
<db:note>
<db:para>If the identity of the peer can't be established, the error is set to <db:link xlink:href="qdtls.xml#QDtlsError-enum">QDtlsError::PeerVerificationError</db:link>. If you want to ignore verification errors and continue connecting, you must call <db:link xlink:href="qdtls.xml#ignoreVerificationErrors">ignoreVerificationErrors</db:link>() and then <db:link xlink:href="qdtls.xml#resumeHandshake">resumeHandshake</db:link>(). If the errors cannot be ignored, you must call <db:link xlink:href="qdtls.xml#abortHandshake">abortHandshake</db:link>().</db:para>
</db:note>
<db:programlisting language="cpp">if (!dtls.doHandshake(&amp;amp;socket, dgram)) {
    if (dtls.dtlsError() == QDtlsError::PeerVerificationError)
        dtls.abortAfterError(&amp;amp;socket);
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#handshakeState">handshakeState</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#dtlsError">dtlsError</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#ignoreVerificationErrors">ignoreVerificationErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#resumeHandshake">resumeHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#abortHandshake">abortHandshake</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtlsConfiguration">
<db:title>QSslConfiguration QDtls::dtlsConfiguration() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslConfiguration</db:type>
<db:methodname>dtlsConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslConfiguration dtlsConfiguration() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns either the default DTLS configuration or the configuration set by an earlier call to <db:link xlink:href="qdtls.xml#setDtlsConfiguration">setDtlsConfiguration</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#setDtlsConfiguration">setDtlsConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#defaultDtlsConfiguration">QSslConfiguration::defaultDtlsConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtlsError">
<db:title>QDtlsError QDtls::dtlsError() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDtlsError</db:type>
<db:methodname>dtlsError</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDtlsError dtlsError() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the last error encountered by the connection or <db:link xlink:href="qdtls.xml#QDtlsError-enum">QDtlsError::NoError</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#dtlsErrorString">dtlsErrorString</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#QDtlsError-enum">QDtlsError</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtlsErrorString">
<db:title>QString QDtls::dtlsErrorString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>dtlsErrorString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString dtlsErrorString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a textual description for the last error encountered by the connection or empty string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#dtlsError">dtlsError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="handleTimeout">
<db:title>bool QDtls::handleTimeout(QUdpSocket *<db:emphasis>socket</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>handleTimeout</db:methodname>
<db:methodparam>
<db:type>QUdpSocket *</db:type>
<db:parameter>socket</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool handleTimeout(QUdpSocket *socket)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If a timeout occures during the handshake, the <db:link xlink:href="qdtls.xml#handshakeTimeout">handshakeTimeout</db:link>() signal is emitted. The application must call handleTimeout() to retransmit handshake messages; handleTimeout() returns true if a timeout has occurred, false otherwise. <db:code role="parameter">socket</db:code> must be a valid pointer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#handshakeTimeout">handshakeTimeout</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="handshakeState">
<db:title>QDtls::HandshakeState QDtls::handshakeState() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDtls::HandshakeState</db:type>
<db:methodname>handshakeState</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDtls::HandshakeState handshakeState() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current handshake state for this <db:link xlink:href="qdtls.xml">QDtls</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#HandshakeState-enum">QDtls::HandshakeState</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="handshakeTimeout">
<db:title>void QDtls::handshakeTimeout()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>handshakeTimeout</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void handshakeTimeout()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Packet loss can result in timeouts during the handshake phase. In this case <db:link xlink:href="qdtls.xml">QDtls</db:link> emits a handshakeTimeout() signal. Call <db:link xlink:href="qdtls.xml#handleTimeout">handleTimeout</db:link>() to retransmit the handshake messages:</db:para>
<db:programlisting language="cpp">DtlsClient::DtlsClient()
{
    // Some initialization code here ...
    connect(&amp;amp;clientDtls, &amp;amp;QDtls::handshakeTimeout, this, &amp;amp;DtlsClient::handleTimeout);
}

void DtlsClient::handleTimeout()
{
    clientDtls.handleTimeout(&amp;amp;clientSocket);
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#handleTimeout">handleTimeout</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ignoreVerificationErrors">
<db:title>void QDtls::ignoreVerificationErrors(const QList&lt;QSslError&gt; &amp;<db:emphasis>errorsToIgnore</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>ignoreVerificationErrors</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QSslError&gt; &amp;</db:type>
<db:parameter>errorsToIgnore</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void ignoreVerificationErrors(const QList&lt;QSslError&gt; &amp;errorsToIgnore)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This method tells <db:link xlink:href="qdtls.xml">QDtls</db:link> to ignore only the errors given in <db:code role="parameter">errorsToIgnore</db:code>.</db:para>
<db:para>If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QSslCertificate&amp;gt; cert = QSslCertificate::fromPath(QLatin1String(&quot;server-certificate.pem&quot;));
QSslError error(QSslError::SelfSignedCertificate, cert.at(0));
QList&amp;lt;QSslError&amp;gt; expectedSslErrors;
expectedSslErrors.append(error);

QDtls dtls;
dtls.ignoreVerificationErrors(expectedSslErrors);
dtls.doHandshake(udpSocket);
</db:programlisting>
<db:para>You can also call this function after <db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>() encountered the <db:link xlink:href="qdtls.xml#QDtlsError-enum">QDtlsError::PeerVerificationError</db:link> error, and then resume the handshake by calling <db:link xlink:href="qdtls.xml#resumeHandshake">resumeHandshake</db:link>().</db:para>
<db:para>Later calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#resumeHandshake">resumeHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qsslerror.xml">QSslError</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isConnectionEncrypted">
<db:title>bool QDtls::isConnectionEncrypted() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isConnectionEncrypted</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isConnectionEncrypted() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if DTLS handshake completed successfully.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#handshakeState">handshakeState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mtuHint">
<db:title>quint16 QDtls::mtuHint() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint16</db:type>
<db:methodname>mtuHint</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint16 mtuHint() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the value previously set by <db:link xlink:href="qdtls.xml#setMtuHint">setMtuHint</db:link>(). The default value is 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#setMtuHint">setMtuHint</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerAddress">
<db:title>QHostAddress QDtls::peerAddress() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHostAddress</db:type>
<db:methodname>peerAddress</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHostAddress peerAddress() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the peer's address, set by <db:link xlink:href="qdtls.xml#setPeer">setPeer</db:link>(), or <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::Null</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#setPeer">setPeer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerPort">
<db:title>quint16 QDtls::peerPort() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint16</db:type>
<db:methodname>peerPort</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint16 peerPort() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the peer's port number, set by <db:link xlink:href="qdtls.xml#setPeer">setPeer</db:link>(), or 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#setPeer">setPeer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerVerificationErrors">
<db:title>QList&lt;QSslError&gt; QDtls::peerVerificationErrors() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QSslError&gt;</db:type>
<db:methodname>peerVerificationErrors</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QSslError&gt; peerVerificationErrors() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns errors found while establishing the identity of the peer.</db:para>
<db:para>If you want to continue connecting despite the errors that have occurred, you must call <db:link xlink:href="qdtls.xml#ignoreVerificationErrors">ignoreVerificationErrors</db:link>().</db:para>
</db:section>
<db:section xml:id="peerVerificationName">
<db:title>QString QDtls::peerVerificationName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>peerVerificationName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString peerVerificationName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the host name set by <db:link xlink:href="qdtls.xml#setPeer">setPeer</db:link>() or <db:link xlink:href="qdtls.xml#setPeerVerificationName">setPeerVerificationName</db:link>(). The default value is an empty string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#setPeerVerificationName">setPeerVerificationName</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#setPeer">setPeer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pskRequired">
<db:title>void QDtls::pskRequired(QSslPreSharedKeyAuthenticator *<db:emphasis>authenticator</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pskRequired</db:methodname>
<db:methodparam>
<db:type>QSslPreSharedKeyAuthenticator *</db:type>
<db:parameter>authenticator</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pskRequired(QSslPreSharedKeyAuthenticator *authenticator)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:link xlink:href="qdtls.xml">QDtls</db:link> emits this signal when it negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</db:para>
<db:para>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the TLS handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <db:code role="parameter">authenticator</db:code> object according to their needs.</db:para>
<db:note>
<db:para>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</db:para>
</db:note>
<db:note>
<db:para>The <db:code role="parameter">authenticator</db:code> object is owned by <db:link xlink:href="qdtls.xml">QDtls</db:link> and must not be deleted by the application.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslpresharedkeyauthenticator.xml">QSslPreSharedKeyAuthenticator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resumeHandshake">
<db:title>bool QDtls::resumeHandshake(QUdpSocket *<db:emphasis>socket</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>resumeHandshake</db:methodname>
<db:methodparam>
<db:type>QUdpSocket *</db:type>
<db:parameter>socket</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool resumeHandshake(QUdpSocket *socket)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If peer verification errors were ignored during the handshake, resumeHandshake() resumes and completes the handshake and returns true. <db:code role="parameter">socket</db:code> must be a valid pointer. Returns false if the handshake could not be resumed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#abortHandshake">abortHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#peerVerificationErrors">peerVerificationErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#ignoreVerificationErrors">ignoreVerificationErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sessionCipher">
<db:title>QSslCipher QDtls::sessionCipher() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslCipher</db:type>
<db:methodname>sessionCipher</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslCipher sessionCipher() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the cryptographic <db:link xlink:href="qsslcipher.xml">cipher</db:link> used by this connection, or a null cipher if the connection isn't encrypted. The cipher for the session is selected during the handshake phase. The cipher is used to encrypt and decrypt data.</db:para>
<db:para><db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> provides functions for setting the ordered list of ciphers from which the handshake phase will eventually select the session cipher. This ordered list must be in place before the handshake phase begins.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link></db:member>
<db:member><db:link xlink:href="qdtls.xml#setDtlsConfiguration">setDtlsConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#dtlsConfiguration">dtlsConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sessionProtocol">
<db:title>QSsl::SslProtocol QDtls::sessionProtocol() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSsl::SslProtocol</db:type>
<db:methodname>sessionProtocol</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSsl::SslProtocol sessionProtocol() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the DTLS protocol version used by this connection, or UnknownProtocol if the connection isn't encrypted yet. The protocol for the connection is selected during the handshake phase.</db:para>
<db:para><db:link xlink:href="qdtls.xml#setDtlsConfiguration">setDtlsConfiguration</db:link>() can set the preferred version before the handshake starts.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#setDtlsConfiguration">setDtlsConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link></db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#defaultDtlsConfiguration">QSslConfiguration::defaultDtlsConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setProtocol">QSslConfiguration::setProtocol</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCookieGeneratorParameters">
<db:title>bool QDtls::setCookieGeneratorParameters(const QDtls::GeneratorParameters &amp;<db:emphasis>params</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>setCookieGeneratorParameters</db:methodname>
<db:methodparam>
<db:type>const QDtls::GeneratorParameters &amp;</db:type>
<db:parameter>params</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setCookieGeneratorParameters(const QDtls::GeneratorParameters &amp;params)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the cryptographic hash algorithm and the secret from <db:code role="parameter">params</db:code>. This function is only needed for a server-side <db:link xlink:href="qdtls.xml">QDtls</db:link> connection. Returns true if successful.</db:para>
<db:note>
<db:para>This function must be called before the handshake starts.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#cookieGeneratorParameters">cookieGeneratorParameters</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qdtlsclientverifier.xml">QDtlsClientVerifier</db:link></db:member>
<db:member><db:link xlink:href="qdtlsclientverifier.xml#cookieGeneratorParameters">QDtlsClientVerifier::cookieGeneratorParameters</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDtlsConfiguration">
<db:title>bool QDtls::setDtlsConfiguration(const QSslConfiguration &amp;<db:emphasis>configuration</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>setDtlsConfiguration</db:methodname>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>configuration</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setDtlsConfiguration(const QSslConfiguration &amp;configuration)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the connection's TLS configuration from <db:code role="parameter">configuration</db:code> and returns true if successful.</db:para>
<db:note>
<db:para>This function must be called before the handshake starts.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#dtlsConfiguration">dtlsConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMtuHint">
<db:title>void QDtls::setMtuHint(quint16 <db:emphasis>mtuHint</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setMtuHint</db:methodname>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>mtuHint</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setMtuHint(quint16 mtuHint)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:code role="parameter">mtuHint</db:code> is the maximum transmission unit (MTU), either discovered or guessed by the application. The application is not required to set this value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#mtuHint">mtuHint</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#SocketOption-enum">QAbstractSocket::PathMtuSocketOption</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPeer">
<db:title>bool QDtls::setPeer(const QHostAddress &amp;<db:emphasis>address</db:emphasis>, quint16 <db:emphasis>port</db:emphasis>, const QString &amp;<db:emphasis>verificationName</db:emphasis> = {})</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>setPeer</db:methodname>
<db:methodparam>
<db:type>const QHostAddress &amp;</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>verificationName</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setPeer(const QHostAddress &amp;address, quint16 port, const QString &amp;verificationName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the peer's address, <db:code role="parameter">port</db:code>, and host name and returns true if successful. <db:code role="parameter">address</db:code> must not be null, multicast, or broadcast. <db:code role="parameter">verificationName</db:code> is the host name used for the certificate validation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#peerAddress">peerAddress</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#peerPort">peerPort</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#peerVerificationName">peerVerificationName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPeerVerificationName">
<db:title>bool QDtls::setPeerVerificationName(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>setPeerVerificationName</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setPeerVerificationName(const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the host <db:code role="parameter">name</db:code> that will be used for the certificate validation and returns true if successful.</db:para>
<db:note>
<db:para>This function must be called before the handshake starts.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#peerVerificationName">peerVerificationName</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#setPeer">setPeer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="shutdown">
<db:title>bool QDtls::shutdown(QUdpSocket *<db:emphasis>socket</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>shutdown</db:methodname>
<db:methodparam>
<db:type>QUdpSocket *</db:type>
<db:parameter>socket</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool shutdown(QUdpSocket *socket)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sends an encrypted shutdown alert message and closes the DTLS connection. Handshake state changes to <db:link xlink:href="qdtls.xml#HandshakeState-enum">QDtls::HandshakeNotStarted</db:link>. <db:code role="parameter">socket</db:code> must be a valid pointer. This function returns true on success.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslMode">
<db:title>QSslSocket::SslMode QDtls::sslMode() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslSocket::SslMode</db:type>
<db:methodname>sslMode</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslSocket::SslMode sslMode() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:link xlink:href="qsslsocket.xml#SslMode-enum">QSslSocket::SslServerMode</db:link> for a server-side connection and <db:link xlink:href="qsslsocket.xml#SslMode-enum">QSslSocket::SslClientMode</db:link> for a client.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#QDtls">QDtls</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#SslMode-enum">QSslSocket::SslMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="writeDatagramEncrypted">
<db:title>qint64 QDtls::writeDatagramEncrypted(QUdpSocket *<db:emphasis>socket</db:emphasis>, const QByteArray &amp;<db:emphasis>dgram</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qint64</db:type>
<db:methodname>writeDatagramEncrypted</db:methodname>
<db:methodparam>
<db:type>QUdpSocket *</db:type>
<db:parameter>socket</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>dgram</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 writeDatagramEncrypted(QUdpSocket *socket, const QByteArray &amp;dgram)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Encrypts <db:code role="parameter">dgram</db:code> and writes the encrypted data into <db:code role="parameter">socket</db:code>. Returns the number of bytes written, or -1 in case of error. The handshake must be completed before writing encrypted data. <db:code role="parameter">socket</db:code> must be a valid pointer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdtls.xml#doHandshake">doHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#handshakeState">handshakeState</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#isConnectionEncrypted">isConnectionEncrypted</db:link>()</db:member>
<db:member><db:link xlink:href="qdtls.xml#dtlsError">dtlsError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="QDtlsError-enum">
<db:title>[since 5.12] enum QDtlsError</db:title>
<db:enumsynopsis>
<db:enumname>QDtlsError</db:enumname>
<db:enumitem>
<db:enumidentifier>NoError</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>InvalidInputParameters</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>InvalidOperation</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnderlyingSocketError</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemoteClosedConnectionError</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PeerVerificationError</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TlsInitializationError</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TlsFatalError</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TlsNonFatalError</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="module">QtNetwork</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Describes errors that can be found by <db:link xlink:href="qdtls.xml">QDtls</db:link> and <db:link xlink:href="qdtlsclientverifier.xml">QDtlsClientVerifier</db:link>.</db:para>
<db:para>This enum describes general and TLS-specific errors that can be encountered by objects of the classes <db:link xlink:href="qdtlsclientverifier.xml">QDtlsClientVerifier</db:link> and <db:link xlink:href="qdtls.xml">QDtls</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::<db:emphasis role="bold">QDtlsError</db:emphasis>::NoError</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>No error occurred, the last operation was successful.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::<db:emphasis role="bold">QDtlsError</db:emphasis>::InvalidInputParameters</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Input parameters provided by a caller were invalid.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::<db:emphasis role="bold">QDtlsError</db:emphasis>::InvalidOperation</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>An operation was attempted in a state that did not permit it.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::<db:emphasis role="bold">QDtlsError</db:emphasis>::UnderlyingSocketError</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qudpsocket.xml#writeDatagram">QUdpSocket::writeDatagram</db:link>() failed, <db:link xlink:href="qabstractsocket.xml#error">QUdpSocket::error</db:link>() and <db:link xlink:href="qiodevice.xml#errorString">QUdpSocket::errorString</db:link>() can provide more specific information.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::<db:emphasis role="bold">QDtlsError</db:emphasis>::RemoteClosedConnectionError</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>TLS shutdown alert message was received.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::<db:emphasis role="bold">QDtlsError</db:emphasis>::PeerVerificationError</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>Peer's identity could not be verified during the TLS handshake.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::<db:emphasis role="bold">QDtlsError</db:emphasis>::TlsInitializationError</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>An error occurred while initializing an underlying TLS backend.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::<db:emphasis role="bold">QDtlsError</db:emphasis>::TlsFatalError</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>A fatal error occurred during TLS handshake, other than peer verification error or TLS initialization error.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdtls.xml">QDtls</db:link></db:emphasis>::<db:emphasis role="bold">QDtlsError</db:emphasis>::TlsNonFatalError</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>A failure to encrypt or decrypt a datagram, non-fatal, meaning <db:link xlink:href="qdtls.xml">QDtls</db:link> can continue working after this error.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 5.12.</db:para>
</db:section>
</db:section>
</db:article>
