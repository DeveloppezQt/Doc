<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Comparison types overview</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Core Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:note>
<db:para>Qt's comparison types provide functionality equivalent to their C++20 standard counterparts. The only reason why they exist is to make the functionality available in C++17 builds, too. In a C++20 build, they implicitly convert to and from the std types, making them fully interchangeable. We therefore recommended that you prefer to use the C++ standard types in your code, if you can use C++20 in your projects already. The Qt comparison types will be removed in Qt 7.</db:para>
</db:note>
<db:para>Qt provides several comparison types for a <db:link xlink:href="https://en.cppreference.com/w/cpp/language/operator_comparison#Three-way_comparison">three-way comparison</db:link>, which are comparable against a <db:emphasis>zero literal</db:emphasis>. To use these comparison types, you need to include the &lt;QtCompare&gt; header. These comparison types are categorized based on their <db:emphasis>order</db:emphasis>, which is a mathematical concept used to describe the arrangement or ranking of elements. The following categories are provided:</db:para>
<db:informaltable style="generic" width="100%">
<db:thead>
<db:tr>
<db:th>
<db:para>C++ type</db:para>
</db:th>
<db:th>
<db:para>Qt type</db:para>
</db:th>
<db:th>
<db:para>strict</db:para>
</db:th>
<db:th>
<db:para>total</db:para>
</db:th>
<db:th>
<db:para>Example</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="https://en.cppreference.com/w/cpp/utility/compare/strong_ordering">std::strong_ordering</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qt-strong-ordering.xml">Qt::strong_ordering</db:link></db:para>
</db:td>
<db:td>
<db:para>yes</db:para>
</db:td>
<db:td>
<db:para>yes</db:para>
</db:td>
<db:td>
<db:para>integral types, case-sensitive strings, <db:link xlink:href="qdate.xml">QDate</db:link>, <db:link xlink:href="qtime.xml">QTime</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="https://en.cppreference.com/w/cpp/utility/compare/weak_ordering">std::weak_ordering</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qt-weak-ordering.xml">Qt::weak_ordering</db:link></db:para>
</db:td>
<db:td>
<db:para>no</db:para>
</db:td>
<db:td>
<db:para>yes</db:para>
</db:td>
<db:td>
<db:para>case-insensitive strings, unordered associative containers, <db:link xlink:href="qdatetime.xml">QDateTime</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="https://en.cppreference.com/w/cpp/utility/compare/partial_ordering">std::partial_ordering</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qt-partial-ordering.xml">Qt::partial_ordering</db:link></db:para>
</db:td>
<db:td>
<db:para>no</db:para>
</db:td>
<db:td>
<db:para>no</db:para>
</db:td>
<db:td>
<db:para>floating-point types, <db:link xlink:href="qoperatingsystemversion.xml">QOperatingSystemVersion</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The strongest comparison type, <db:link xlink:href="qt-strong-ordering.xml">Qt::strong_ordering</db:link>, represents a strict total order. It requires that any two elements be comparable in a way where equality implies substitutability. In other words, equivalent values cannot be distinguished from each other. A practical example would be the case-sensitive comparison of two strings. For instance, when comparing the values &quot;Qt&quot; and &quot;Qt&quot; the result would be <db:link xlink:href="qt-strong-ordering.xml#equal-var">Qt::strong_ordering::equal</db:link>. Both values are indistinguishable and all deterministic operations performed on these values would yield identical results.</db:para>
<db:para><db:link xlink:href="qt-weak-ordering.xml">Qt::weak_ordering</db:link> represents a total order. While any two values still need to be comparable, equivalent values may be distinguishable. The canonical example here would be the case-insensitive comparison of two strings. For instance, when comparing the values &quot;Qt&quot; and &quot;qt&quot; both hold the same letters but with different representations. This comparison would result in <db:link xlink:href="qt-weak-ordering.xml#equivalent-var">Qt::weak_ordering::equivalent</db:link>, but not actually Equal. Another example would be <db:link xlink:href="qdatetime.xml">QDateTime</db:link>, which can represent a given instant in time in terms of local time or any other time-zone, including UTC. The different representations are equivalent, even though their time() and sometimes date() may differ.</db:para>
<db:para><db:link xlink:href="qt-partial-ordering.xml">Qt::partial_ordering</db:link> represents, as the name implies, a partial ordering. It allows for the possibility that two values may not be comparable, resulting in an <db:link xlink:href="qt-partial-ordering.xml#unordered-var">unordered</db:link> state. Additionally, equivalent values may still be distinguishable. A practical example would be the comparison of two floating-point values, comparing with NaN (Not-a-Number) would yield an unordered result. Another example is the comparison of two <db:link xlink:href="qoperatingsystemversion.xml">QOperatingSystemVersion</db:link> objects. Comparing versions of two different operating systems, such as Android and Windows, would produce an unordered result.</db:para>
<db:para>Utilizing these comparison types enhances the expressiveness of defining relations. Furthermore, they serve as a fundamental component for implementing three-way comparison with C++17.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qt-strong-ordering.xml">Qt::strong_ordering</db:link></db:member>
<db:member><db:link xlink:href="qt-weak-ordering.xml">Qt::weak_ordering</db:link></db:member>
<db:member><db:link xlink:href="qt-partial-ordering.xml">Qt::partial_ordering</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
