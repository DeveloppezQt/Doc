<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>&lt;QtEndian&gt; - Endian Conversion Functions</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.4.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The &lt;QtEndian&gt; header provides functions to convert between little and big endian representations of numbers.</db:para>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QtEndian</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>&lt;QtEndian&gt; is part of <db:simplelist><db:member>funclists</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
</db:section>
<db:section xml:id="type-documentation">
<db:title>Type Documentation</db:title>
<db:section xml:id="qint16_be-typedef">
<db:title>[since 5.10] qint16_be</db:title>
<db:typedefsynopsis>
<db:typedefname>qint16_be</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for <db:link xlink:href="qbeinteger.xml">QBEInteger</db:link>&lt;qint16&gt;. This type is guaranteed to be stored in memory as a 16-bit big-endian signed integer on all platforms supported by Qt.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>qint16</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qint16_le-typedef">
<db:title>[since 5.10] qint16_le</db:title>
<db:typedefsynopsis>
<db:typedefname>qint16_le</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for <db:link xlink:href="qleinteger.xml">QLEInteger</db:link>&lt;qint16&gt;. This type is guaranteed to be stored in memory as a 16-bit little-endian signed integer on all platforms supported by Qt.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>qint16</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qint32_be-typedef">
<db:title>[since 5.10] qint32_be</db:title>
<db:typedefsynopsis>
<db:typedefname>qint32_be</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for <db:link xlink:href="qbeinteger.xml">QBEInteger</db:link>&lt;qint32&gt;. This type is guaranteed to be stored in memory as a 32-bit big-endian signed integer on all platforms supported by Qt.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>qint32</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qint32_le-typedef">
<db:title>[since 5.10] qint32_le</db:title>
<db:typedefsynopsis>
<db:typedefname>qint32_le</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for <db:link xlink:href="qleinteger.xml">QLEInteger</db:link>&lt;qint32&gt;. This type is guaranteed to be stored in memory as a 32-bit little-endian signed integer on all platforms supported by Qt.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>qint32</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qint64_be-typedef">
<db:title>[since 5.10] qint64_be</db:title>
<db:typedefsynopsis>
<db:typedefname>qint64_be</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for <db:link xlink:href="qbeinteger.xml">QBEInteger</db:link>&lt;qint64&gt;. This type is guaranteed to be stored in memory as a 64-bit big-endian signed integer on all platforms supported by Qt.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>qint64</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qint64_le-typedef">
<db:title>[since 5.10] qint64_le</db:title>
<db:typedefsynopsis>
<db:typedefname>qint64_le</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for <db:link xlink:href="qleinteger.xml">QLEInteger</db:link>&lt;qint64&gt;. This type is guaranteed to be stored in memory as a 64-bit little-endian signed integer on all platforms supported by Qt.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>qint64</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quint16_be-typedef">
<db:title>[since 5.10] quint16_be</db:title>
<db:typedefsynopsis>
<db:typedefname>quint16_be</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for <db:link xlink:href="qbeinteger.xml">QBEInteger</db:link>&lt;quint16&gt;. This type is guaranteed to be stored in memory as a 16-bit big-endian unsigned integer on all platforms supported by Qt.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>quint16</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quint16_le-typedef">
<db:title>[since 5.10] quint16_le</db:title>
<db:typedefsynopsis>
<db:typedefname>quint16_le</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for <db:link xlink:href="qleinteger.xml">QLEInteger</db:link>&lt;quint16&gt;. This type is guaranteed to be stored in memory as a 16-bit little-endian unsigned integer on all platforms supported by Qt.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>quint16</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quint32_be-typedef">
<db:title>[since 5.10] quint32_be</db:title>
<db:typedefsynopsis>
<db:typedefname>quint32_be</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for <db:link xlink:href="qbeinteger.xml">QBEInteger</db:link>&lt;quint32&gt;. This type is guaranteed to be stored in memory as a 32-bit big-endian unsigned integer on all platforms supported by Qt.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>quint32</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quint32_le-typedef">
<db:title>[since 5.10] quint32_le</db:title>
<db:typedefsynopsis>
<db:typedefname>quint32_le</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for <db:link xlink:href="qleinteger.xml">QLEInteger</db:link>&lt;quint32&gt;. This type is guaranteed to be stored in memory as a 32-bit little-endian unsigned integer on all platforms supported by Qt.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>quint32</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quint64_be-typedef">
<db:title>[since 5.10] quint64_be</db:title>
<db:typedefsynopsis>
<db:typedefname>quint64_be</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for <db:link xlink:href="qbeinteger.xml">QBEInteger</db:link>&lt;quint64&gt;. This type is guaranteed to be stored in memory as a 64-bit big-endian unsigned integer on all platforms supported by Qt.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>quint64</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quint64_le-typedef">
<db:title>[since 5.10] quint64_le</db:title>
<db:typedefsynopsis>
<db:typedefname>quint64_le</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for <db:link xlink:href="qleinteger.xml">QLEInteger</db:link>&lt;quint64&gt;. This type is guaranteed to be stored in memory as a 64-bit little-endian unsigned integer on all platforms supported by Qt.</db:para>
<db:para>This typedef was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>quint64</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="function-documentation">
<db:title>Function Documentation</db:title>
<db:section xml:id="qFromBigEndian">
<db:title>T qFromBigEndian(const void *<db:emphasis>src</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>qFromBigEndian</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T qFromBigEndian(const void *src)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a big-endian number from memory location <db:code role="parameter">src</db:code> and returns the number in the host byte order representation. On CPU architectures where the host byte order is little-endian (such as x86) this will swap the byte order; otherwise it will just read from <db:code role="parameter">src</db:code>.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:note>
<db:para>Since Qt 5.7, the type of the <db:code role="parameter">src</db:code> parameter is a void pointer.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">src</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromLittleEndian">qFromLittleEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qFromBigEndian-1">
<db:title>[constexpr] T qFromBigEndian(T <db:emphasis>src</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>qFromBigEndian</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T qFromBigEndian(T src)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Converts <db:code role="parameter">src</db:code> from big-endian byte order and returns the number in host byte order representation of that number. On CPU architectures where the host byte order is little-endian (such as x86) this will return <db:code role="parameter">src</db:code> with the byte order swapped; otherwise it will return <db:code role="parameter">src</db:code> unmodified.</db:para>
</db:section>
<db:section xml:id="qFromBigEndian-2">
<db:title>[since 5.12] void qFromBigEndian(const void *<db:emphasis>src</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, void *<db:emphasis>dest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qFromBigEndian</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>dest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void qFromBigEndian(const void *src, qsizetype count, void *dest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads <db:code role="parameter">count</db:code> big-endian numbers from memory location <db:code role="parameter">src</db:code> and stores them in the host byte order representation at <db:code role="parameter">dest</db:code>. On CPU architectures where the host byte order is little-endian (such as x86) this will swap the byte order; otherwise it will just perform a memcpy from <db:code role="parameter">src</db:code> to <db:code role="parameter">dest</db:code>.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">src</db:code>. However, <db:code role="parameter">dest</db:code> is expected to be naturally aligned for type T.</db:para>
<db:para>If <db:code role="parameter">src</db:code> and <db:code role="parameter">dest</db:code> can be the same pointer, this function will perform an in-place swap (if necessary). If they are not the same, the memory regions must not overlap.</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromLittleEndian">qFromLittleEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qFromLittleEndian">
<db:title>T qFromLittleEndian(const void *<db:emphasis>src</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>qFromLittleEndian</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T qFromLittleEndian(const void *src)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a little-endian number from memory location <db:code role="parameter">src</db:code> and returns the number in the host byte order representation. On CPU architectures where the host byte order is big-endian (such as PowerPC) this will swap the byte order; otherwise it will just read from <db:code role="parameter">src</db:code>.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:note>
<db:para>Since Qt 5.7, the type of the <db:code role="parameter">src</db:code> parameter is a void pointer.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">src</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromBigEndian">qFromBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qFromLittleEndian-1">
<db:title>[constexpr] T qFromLittleEndian(T <db:emphasis>src</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>qFromLittleEndian</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T qFromLittleEndian(T src)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Converts <db:code role="parameter">src</db:code> from little-endian byte order and returns the number in host byte order representation of that number. On CPU architectures where the host byte order is big-endian (such as PowerPC) this will return <db:code role="parameter">src</db:code> with the byte order swapped; otherwise it will return <db:code role="parameter">src</db:code> unmodified.</db:para>
</db:section>
<db:section xml:id="qFromLittleEndian-2">
<db:title>[since 5.12] void qFromLittleEndian(const void *<db:emphasis>src</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, void *<db:emphasis>dest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qFromLittleEndian</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>dest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void qFromLittleEndian(const void *src, qsizetype count, void *dest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads <db:code role="parameter">count</db:code> little-endian numbers from memory location <db:code role="parameter">src</db:code> and stores them in the host byte order representation at <db:code role="parameter">dest</db:code>. On CPU architectures where the host byte order is big-endian (such as PowerPC) this will swap the byte order; otherwise it will just perform a memcpy from <db:code role="parameter">src</db:code> to <db:code role="parameter">dest</db:code>.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">src</db:code>. However, <db:code role="parameter">dest</db:code> is expected to be naturally aligned for type T.</db:para>
<db:para>If <db:code role="parameter">src</db:code> and <db:code role="parameter">dest</db:code> can be the same pointer, this function will perform an in-place swap (if necessary). If they are not the same, the memory regions must not overlap.</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qToBigEndian">
<db:title>void qToBigEndian(T <db:emphasis>src</db:emphasis>, void *<db:emphasis>dest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qToBigEndian</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>dest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qToBigEndian(T src, void *dest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the number <db:code role="parameter">src</db:code> with template type T to the memory location at <db:code role="parameter">dest</db:code> in big-endian byte order.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">dest</db:code>.</db:para>
<db:note>
<db:para>Since Qt 5.7, the type of the <db:code role="parameter">dest</db:code> parameter is a void pointer.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromBigEndian">qFromBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qFromLittleEndian">qFromLittleEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qToBigEndian-1">
<db:title>[constexpr] T qToBigEndian(T <db:emphasis>src</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>qToBigEndian</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T qToBigEndian(T src)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Converts <db:code role="parameter">src</db:code> from host byte order and returns the number in big-endian byte order representation of that number. On CPU architectures where the host byte order is little-endian (such as x86) this will return <db:code role="parameter">src</db:code> with the byte order swapped; otherwise it will return <db:code role="parameter">src</db:code> unmodified.</db:para>
</db:section>
<db:section xml:id="qToBigEndian-2">
<db:title>[since 5.12] void qToBigEndian(const void *<db:emphasis>src</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, void *<db:emphasis>dest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qToBigEndian</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>dest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void qToBigEndian(const void *src, qsizetype count, void *dest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads <db:code role="parameter">count</db:code> numbers from memory location <db:code role="parameter">src</db:code> in the host byte order and stores them in big-endian representation at <db:code role="parameter">dest</db:code>. On CPU architectures where the host byte order is little-endian (such as x86) this will swap the byte order; otherwise it will just perform a memcpy from <db:code role="parameter">src</db:code> to <db:code role="parameter">dest</db:code>.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">dest</db:code>. However, <db:code role="parameter">src</db:code> is expected to be naturally aligned for type T.</db:para>
<db:para>If <db:code role="parameter">src</db:code> and <db:code role="parameter">dest</db:code> can be the same pointer, this function will perform an in-place swap (if necessary). If they are not the same, the memory regions must not overlap.</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromLittleEndian">qFromLittleEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qToLittleEndian">
<db:title>void qToLittleEndian(T <db:emphasis>src</db:emphasis>, void *<db:emphasis>dest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qToLittleEndian</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>dest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qToLittleEndian(T src, void *dest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the number <db:code role="parameter">src</db:code> with template type T to the memory location at <db:code role="parameter">dest</db:code> in little-endian byte order.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">dest</db:code>.</db:para>
<db:note>
<db:para>Since Qt 5.7, the type of the <db:code role="parameter">dest</db:code> parameter is a void pointer.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromBigEndian">qFromBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qFromLittleEndian">qFromLittleEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qToLittleEndian-1">
<db:title>[constexpr] T qToLittleEndian(T <db:emphasis>src</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>qToLittleEndian</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T qToLittleEndian(T src)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Converts <db:code role="parameter">src</db:code> from host byte order and returns the number in little-endian byte order representation of that number. On CPU architectures where the host byte order is big-endian (such as PowerPC) this will return <db:code role="parameter">src</db:code> with the byte order swapped; otherwise it will return <db:code role="parameter">src</db:code> unmodified.</db:para>
</db:section>
<db:section xml:id="qToLittleEndian-2">
<db:title>[since 5.12] void qToLittleEndian(const void *<db:emphasis>src</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, void *<db:emphasis>dest</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qToLittleEndian</db:methodname>
<db:methodparam>
<db:type>const void *</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>dest</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void qToLittleEndian(const void *src, qsizetype count, void *dest)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads <db:code role="parameter">count</db:code> numbers from memory location <db:code role="parameter">src</db:code> in the host byte order and stores them in little-endian representation at <db:code role="parameter">dest</db:code>. On CPU architectures where the host byte order is big-endian (such as PowerPC) this will swap the byte order; otherwise it will just perform a memcpy from <db:code role="parameter">src</db:code> to <db:code role="parameter">dest</db:code>.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">dest</db:code>. However, <db:code role="parameter">src</db:code> is expected to be naturally aligned for type T.</db:para>
<db:para>If <db:code role="parameter">src</db:code> and <db:code role="parameter">dest</db:code> can be the same pointer, this function will perform an in-place swap (if necessary). If they are not the same, the memory regions must not overlap.</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromLittleEndian">qFromLittleEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
