<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>&lt;QtEndian&gt; - Endian Conversion Functions</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The &lt;QtEndian&gt; header provides functions to convert between little and big endian representations of numbers.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QtEndian</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>&lt;QtEndian&gt; is part of <db:simplelist><db:member>funclists</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
</db:section>
<db:section xml:id="type-documentation">
<db:title>Type Documentation</db:title>
<db:section xml:id="qint16_be-typedef">
<db:title>qint16_be</db:title>
<db:para>Typedef for <db:link xlink:href="qbeinteger.xml">QBEInteger</db:link>&lt;qint16&gt;. This type is guaranteed to be stored in memory as a 16-bit big-endian signed integer on all platforms supported by Qt.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qttypes.xml#qint16-typedef">qint16</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qint16_le-typedef">
<db:title>qint16_le</db:title>
<db:para>Typedef for <db:link xlink:href="qleinteger.xml">QLEInteger</db:link>&lt;qint16&gt;. This type is guaranteed to be stored in memory as a 16-bit little-endian signed integer on all platforms supported by Qt.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qttypes.xml#qint16-typedef">qint16</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qint32_be-typedef">
<db:title>qint32_be</db:title>
<db:para>Typedef for <db:link xlink:href="qbeinteger.xml">QBEInteger</db:link>&lt;qint32&gt;. This type is guaranteed to be stored in memory as a 32-bit big-endian signed integer on all platforms supported by Qt.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qttypes.xml#qint32-typedef">qint32</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qint32_le-typedef">
<db:title>qint32_le</db:title>
<db:para>Typedef for <db:link xlink:href="qleinteger.xml">QLEInteger</db:link>&lt;qint32&gt;. This type is guaranteed to be stored in memory as a 32-bit little-endian signed integer on all platforms supported by Qt.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qttypes.xml#qint32-typedef">qint32</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qint64_be-typedef">
<db:title>qint64_be</db:title>
<db:para>Typedef for <db:link xlink:href="qbeinteger.xml">QBEInteger</db:link>&lt;qint64&gt;. This type is guaranteed to be stored in memory as a 64-bit big-endian signed integer on all platforms supported by Qt.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qttypes.xml#qint64-typedef">qint64</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qint64_le-typedef">
<db:title>qint64_le</db:title>
<db:para>Typedef for <db:link xlink:href="qleinteger.xml">QLEInteger</db:link>&lt;qint64&gt;. This type is guaranteed to be stored in memory as a 64-bit little-endian signed integer on all platforms supported by Qt.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qttypes.xml#qint64-typedef">qint64</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quint16_be-typedef">
<db:title>quint16_be</db:title>
<db:para>Typedef for <db:link xlink:href="qbeinteger.xml">QBEInteger</db:link>&lt;quint16&gt;. This type is guaranteed to be stored in memory as a 16-bit big-endian unsigned integer on all platforms supported by Qt.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qttypes.xml#quint16-typedef">quint16</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quint16_le-typedef">
<db:title>quint16_le</db:title>
<db:para>Typedef for <db:link xlink:href="qleinteger.xml">QLEInteger</db:link>&lt;quint16&gt;. This type is guaranteed to be stored in memory as a 16-bit little-endian unsigned integer on all platforms supported by Qt.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qttypes.xml#quint16-typedef">quint16</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quint32_be-typedef">
<db:title>quint32_be</db:title>
<db:para>Typedef for <db:link xlink:href="qbeinteger.xml">QBEInteger</db:link>&lt;quint32&gt;. This type is guaranteed to be stored in memory as a 32-bit big-endian unsigned integer on all platforms supported by Qt.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qttypes.xml#quint32-typedef">quint32</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quint32_le-typedef">
<db:title>quint32_le</db:title>
<db:para>Typedef for <db:link xlink:href="qleinteger.xml">QLEInteger</db:link>&lt;quint32&gt;. This type is guaranteed to be stored in memory as a 32-bit little-endian unsigned integer on all platforms supported by Qt.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qttypes.xml#quint32-typedef">quint32</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quint64_be-typedef">
<db:title>quint64_be</db:title>
<db:para>Typedef for <db:link xlink:href="qbeinteger.xml">QBEInteger</db:link>&lt;quint64&gt;. This type is guaranteed to be stored in memory as a 64-bit big-endian unsigned integer on all platforms supported by Qt.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qttypes.xml#quint64-typedef">quint64</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quint64_le-typedef">
<db:title>quint64_le</db:title>
<db:para>Typedef for <db:link xlink:href="qleinteger.xml">QLEInteger</db:link>&lt;quint64&gt;. This type is guaranteed to be stored in memory as a 64-bit little-endian unsigned integer on all platforms supported by Qt.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qttypes.xml#quint64-typedef">quint64</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="function-documentation">
<db:title>Function Documentation</db:title>
<db:section xml:id="qFromBigEndian">
<db:title>T qFromBigEndian(const void *<db:emphasis>src</db:emphasis>)</db:title>
<db:para>Reads a big-endian number from memory location <db:code role="parameter">src</db:code> and returns the number in the host byte order representation. On CPU architectures where the host byte order is little-endian (such as x86) this will swap the byte order; otherwise it will just read from <db:code role="parameter">src</db:code>.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:note>
<db:para>Since Qt 5.7, the type of the <db:code role="parameter">src</db:code> parameter is a void pointer.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">src</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromLittleEndian">qFromLittleEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qFromBigEndian-1">
<db:title>[constexpr] T qFromBigEndian(T <db:emphasis>src</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Converts <db:code role="parameter">src</db:code> from big-endian byte order and returns the number in host byte order representation of that number. On CPU architectures where the host byte order is little-endian (such as x86) this will return <db:code role="parameter">src</db:code> with the byte order swapped; otherwise it will return <db:code role="parameter">src</db:code> unmodified.</db:para>
</db:section>
<db:section xml:id="qFromBigEndian-2">
<db:title>void qFromBigEndian(const void *<db:emphasis>src</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, void *<db:emphasis>dest</db:emphasis>)</db:title>
<db:para>Reads <db:code role="parameter">count</db:code> big-endian numbers from memory location <db:code role="parameter">src</db:code> and stores them in the host byte order representation at <db:code role="parameter">dest</db:code>. On CPU architectures where the host byte order is little-endian (such as x86) this will swap the byte order; otherwise it will just perform a memcpy from <db:code role="parameter">src</db:code> to <db:code role="parameter">dest</db:code>.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">src</db:code>. However, <db:code role="parameter">dest</db:code> is expected to be naturally aligned for type T.</db:para>
<db:para>If <db:code role="parameter">src</db:code> and <db:code role="parameter">dest</db:code> can be the same pointer, this function will perform an in-place swap (if necessary). If they are not the same, the memory regions must not overlap.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromLittleEndian">qFromLittleEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qFromLittleEndian">
<db:title>T qFromLittleEndian(const void *<db:emphasis>src</db:emphasis>)</db:title>
<db:para>Reads a little-endian number from memory location <db:code role="parameter">src</db:code> and returns the number in the host byte order representation. On CPU architectures where the host byte order is big-endian (such as PowerPC) this will swap the byte order; otherwise it will just read from <db:code role="parameter">src</db:code>.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:note>
<db:para>Since Qt 5.7, the type of the <db:code role="parameter">src</db:code> parameter is a void pointer.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">src</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromBigEndian">qFromBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qFromLittleEndian-1">
<db:title>[constexpr] T qFromLittleEndian(T <db:emphasis>src</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Converts <db:code role="parameter">src</db:code> from little-endian byte order and returns the number in host byte order representation of that number. On CPU architectures where the host byte order is big-endian (such as PowerPC) this will return <db:code role="parameter">src</db:code> with the byte order swapped; otherwise it will return <db:code role="parameter">src</db:code> unmodified.</db:para>
</db:section>
<db:section xml:id="qFromLittleEndian-2">
<db:title>void qFromLittleEndian(const void *<db:emphasis>src</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, void *<db:emphasis>dest</db:emphasis>)</db:title>
<db:para>Reads <db:code role="parameter">count</db:code> little-endian numbers from memory location <db:code role="parameter">src</db:code> and stores them in the host byte order representation at <db:code role="parameter">dest</db:code>. On CPU architectures where the host byte order is big-endian (such as PowerPC) this will swap the byte order; otherwise it will just perform a memcpy from <db:code role="parameter">src</db:code> to <db:code role="parameter">dest</db:code>.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">src</db:code>. However, <db:code role="parameter">dest</db:code> is expected to be naturally aligned for type T.</db:para>
<db:para>If <db:code role="parameter">src</db:code> and <db:code role="parameter">dest</db:code> can be the same pointer, this function will perform an in-place swap (if necessary). If they are not the same, the memory regions must not overlap.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qToBigEndian">
<db:title>void qToBigEndian(T <db:emphasis>src</db:emphasis>, void *<db:emphasis>dest</db:emphasis>)</db:title>
<db:para>Writes the number <db:code role="parameter">src</db:code> with template type T to the memory location at <db:code role="parameter">dest</db:code> in big-endian byte order.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">dest</db:code>.</db:para>
<db:note>
<db:para>Since Qt 5.7, the type of the <db:code role="parameter">dest</db:code> parameter is a void pointer.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromBigEndian">qFromBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qFromLittleEndian">qFromLittleEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qToBigEndian-1">
<db:title>[constexpr] T qToBigEndian(T <db:emphasis>src</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Converts <db:code role="parameter">src</db:code> from host byte order and returns the number in big-endian byte order representation of that number. On CPU architectures where the host byte order is little-endian (such as x86) this will return <db:code role="parameter">src</db:code> with the byte order swapped; otherwise it will return <db:code role="parameter">src</db:code> unmodified.</db:para>
</db:section>
<db:section xml:id="qToBigEndian-2">
<db:title>void qToBigEndian(const void *<db:emphasis>src</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, void *<db:emphasis>dest</db:emphasis>)</db:title>
<db:para>Reads <db:code role="parameter">count</db:code> numbers from memory location <db:code role="parameter">src</db:code> in the host byte order and stores them in big-endian representation at <db:code role="parameter">dest</db:code>. On CPU architectures where the host byte order is little-endian (such as x86) this will swap the byte order; otherwise it will just perform a memcpy from <db:code role="parameter">src</db:code> to <db:code role="parameter">dest</db:code>.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">dest</db:code>. However, <db:code role="parameter">src</db:code> is expected to be naturally aligned for type T.</db:para>
<db:para>If <db:code role="parameter">src</db:code> and <db:code role="parameter">dest</db:code> can be the same pointer, this function will perform an in-place swap (if necessary). If they are not the same, the memory regions must not overlap.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromLittleEndian">qFromLittleEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qToLittleEndian">
<db:title>void qToLittleEndian(T <db:emphasis>src</db:emphasis>, void *<db:emphasis>dest</db:emphasis>)</db:title>
<db:para>Writes the number <db:code role="parameter">src</db:code> with template type T to the memory location at <db:code role="parameter">dest</db:code> in little-endian byte order.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">dest</db:code>.</db:para>
<db:note>
<db:para>Since Qt 5.7, the type of the <db:code role="parameter">dest</db:code> parameter is a void pointer.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromBigEndian">qFromBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qFromLittleEndian">qFromLittleEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qToLittleEndian-1">
<db:title>[constexpr] T qToLittleEndian(T <db:emphasis>src</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Converts <db:code role="parameter">src</db:code> from host byte order and returns the number in little-endian byte order representation of that number. On CPU architectures where the host byte order is big-endian (such as PowerPC) this will return <db:code role="parameter">src</db:code> with the byte order swapped; otherwise it will return <db:code role="parameter">src</db:code> unmodified.</db:para>
</db:section>
<db:section xml:id="qToLittleEndian-2">
<db:title>void qToLittleEndian(const void *<db:emphasis>src</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, void *<db:emphasis>dest</db:emphasis>)</db:title>
<db:para>Reads <db:code role="parameter">count</db:code> numbers from memory location <db:code role="parameter">src</db:code> in the host byte order and stores them in little-endian representation at <db:code role="parameter">dest</db:code>. On CPU architectures where the host byte order is big-endian (such as PowerPC) this will swap the byte order; otherwise it will just perform a memcpy from <db:code role="parameter">src</db:code> to <db:code role="parameter">dest</db:code>.</db:para>
<db:note>
<db:para>Template type T can either be a quint16, qint16, quint32, qint32, quint64, or qint64. Other types of integers, e.g., qlong, are not applicable.</db:para>
</db:note>
<db:para>There are no data alignment constraints for <db:code role="parameter">dest</db:code>. However, <db:code role="parameter">src</db:code> is expected to be naturally aligned for type T.</db:para>
<db:para>If <db:code role="parameter">src</db:code> and <db:code role="parameter">dest</db:code> can be the same pointer, this function will perform an in-place swap (if necessary). If they are not the same, the memory regions must not overlap.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtendian.xml#qFromLittleEndian">qFromLittleEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToBigEndian">qToBigEndian</db:link>()</db:member>
<db:member><db:link xlink:href="qtendian.xml#qToLittleEndian">qToLittleEndian</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
