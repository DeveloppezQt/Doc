<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt SCXML Pinball Example</db:title>
<db:productname>QtScxml</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Scxml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Encapsulates the internal logic of an application in an SCXML file.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para><db:emphasis>Pinball</db:emphasis> demonstrates a clear separation between the user interface, which may be easily replaced, and the internal logic encapsulated in an SCXML file, which could also be used with another user interface.</db:para>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="http://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:emphasis role="bold">Welcome</db:emphasis> mode and select the example from <db:emphasis role="bold">Examples</db:emphasis>. For more information, visit <db:link xlink:href="http://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="pinball-features">
<db:title>Pinball Features</db:title>
<db:mediaobject>
<db:alt>Screenshot of the Pinball example</db:alt>
<db:imageobject>
<db:imagedata fileref="images/pinball.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The Pinball example mimics a pinball game. The targets on the pinball table are substituted by GUI controls, mainly by push buttons. Display elements, including current score, highscore, and targets' lights, are substituted by labels. Usually, the state of the targets' lights changes very often during a game: the lights get turned on or off permanently or they blink at varying speed indicating a game (or a certain target) entered a temporary state. The state of each target light is presented as an enabled or a disabled label. There is no real ball, but clicking a target's button represents hitting a real pinball target with a ball.</db:para>
<db:para>Our pinball contains the following features:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Initially and when the game ends, the pinball table enters <db:code>offState</db:code>. In that state, all lights on the table blink slowly (at intervals of 1 second).</db:para>
</db:listitem>
<db:listitem>
<db:para>After clicking the <db:guilabel>START</db:guilabel> button, the pinball table enters <db:code>onState</db:code>. All lights are turned off and the pinball table is ready to be played.</db:para>
</db:listitem>
<db:listitem>
<db:para>When the table is in <db:code>onState</db:code> and the players click the <db:guilabel>BALL OUT</db:guilabel> button, the game ends and enters <db:code>offState</db:code>. If the players' score is higher than the current highscore, the highscore is updated.</db:para>
</db:listitem>
<db:listitem>
<db:para>The goal is to collect the <db:guilabel>JACKPOT</db:guilabel>. In order to do that, the players must hit all five <db:guilabel>CRAZY</db:guilabel> letters twice. They have unlimited time for hitting them for the first time. However, after they have collected all the letters for the first time, they enter the <db:code>hurryState</db:code> and must collect them again within 5 seconds. If the time has passed and the letters were not collected again, the players must start collecting the letters from scratch.</db:para>
</db:listitem>
<db:listitem>
<db:para>Scores:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>1.000 per letter hit when not in <db:code>hurryState</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>10.000 per letter hit when in <db:code>hurryState</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>100.000 bonus for all 5 letters when not in <db:code>hurryState</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>1.000.000 bonus for all 5 letters when in <db:code>hurryState</db:code> (<db:guilabel>JACKPOT</db:guilabel>).</db:para>
</db:listitem>
</db:itemizedlist>
</db:listitem>
<db:listitem>
<db:para>When not in <db:code>hurryState</db:code>, the letters already hit should blink at intermediate speed (500ms). Letters not hit yet should stay off.</db:para>
</db:listitem>
<db:listitem>
<db:para>When in <db:code>hurryState</db:code>, the letters already hit should stay on. Letters not hit yet should blink fast (200ms). In addition, the <db:guilabel>HURRY</db:guilabel> light should blink at the same speed.</db:para>
</db:listitem>
<db:listitem>
<db:para>When the jackpot gets collected, the <db:guilabel>JACKPOT</db:guilabel> light should stay on.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="scxml-part-internal-logic-description">
<db:title>SCXML Part: Internal Logic Description</db:title>
<db:para>The <db:emphasis>pinball.scxml</db:emphasis> file describes the internal logic implemented for the pinball game. In this example, we have chosen the ECMAScript data model:</db:para>
<db:programlisting language="cpp">&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot;
       name=&quot;Pinball&quot; datamodel=&quot;ecmascript&quot;&gt;
</db:programlisting>
<db:para>The ECMAScript data model enables declaring variables with initial values that can be modified later. We declare the <db:code>&quot;highscore&quot;</db:code> and <db:code>&quot;score&quot;</db:code> variables with the initial values of 0:</db:para>
<db:programlisting language="cpp">    &lt;datamodel&gt;
        &lt;data id=&quot;highScore&quot; expr=&quot;0&quot;/&gt;
        &lt;data id=&quot;score&quot; expr=&quot;0&quot;/&gt;
    &lt;/datamodel&gt;
</db:programlisting>
<db:para>We define a root parallel state <db:code>&quot;global&quot;</db:code>, with two child states, <db:code>guiControl</db:code> and <db:code>internalState</db:code>, which are also parallel. Because the top <db:code>global</db:code> state is parallel, all of its direct children are active when it is active. In this example, the role of <db:code>global</db:code> is to collect the child states and make them both active at a time.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/pinball-statechart-global.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="maintaining-light-state">
<db:title>Maintaining Light State</db:title>
<db:para>The <db:code>guiControl</db:code> element is responsible for maintaining the current state of each light control that is visible on the pinball table. Each light has a corresponding state.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/pinball-statechart-guicontrol.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>For example, the light of the letter <db:guilabel>C</db:guilabel> corresponds to the <db:code>cLight</db:code> state. Each light state has two child states indicating whether the light is on or off:</db:para>
<db:programlisting language="cpp">    &lt;parallel id=&quot;global&quot;&gt;
        &lt;parallel id=&quot;guiControl&quot;&gt;
            &lt;state id=&quot;cLight&quot;&gt;
                &lt;state id=&quot;cLightOn&quot;&gt;
                    &lt;transition event=&quot;turnOffC&quot; target=&quot;cLightOff&quot;/&gt;
                &lt;/state&gt;
                &lt;state id=&quot;cLightOff&quot;&gt;
                    &lt;transition event=&quot;turnOnC&quot; target=&quot;cLightOn&quot;/&gt;
                &lt;/state&gt;
            &lt;/state&gt;
</db:programlisting>
<db:para>As mentioned before, the <db:code>guiControl</db:code> state is always active, and since it is of parallel type, all its direct children are always active too. Therefore, the <db:code>cLight</db:code> state is always active. However, only one of its children, <db:code>cLightOn</db:code> or <db:code>cLightOff</db:code>, is active at a time. The same applies to the other children of the <db:code>guiControl</db:code> state. In addition, we define transitions between on and off substates. For example, whenever the active state is <db:code>cLightOn</db:code> and a <db:code>turnOffC</db:code> event is received, we change the active substate of <db:code>cLight</db:code> to <db:code>cLightOff</db:code>. Whenever the active state is <db:code>cLightOff</db:code> and we receive a <db:code>turnOnC</db:code> event, we change the active substate of <db:code>cLight</db:code> to <db:code>cLightOn</db:code>.</db:para>
<db:para>In our application, we use instances of <db:link xlink:href="qlabel.xml">QLabel</db:link> class in C++ to represent real lights on the table. When the light transitions into the <db:emphasis>on</db:emphasis> or <db:emphasis>off</db:emphasis> state, we enable or disable the particular label accordingly. The connection between the state machine and the GUI part of the application will be shown in the <db:link xlink:href="qtscxml-pinball-example.xml#c-part-glue-gui-with-scxml">C++ code</db:link> later on. For now, it is enough to realize that changes to active states inside the state machine will serve as the external interface of the state machine that the other parts of the application (such as the GUI part) can listen to.</db:para>
<db:para>All of the mentioned events that switch the state of a light will be generated by this state machine inside the <db:code>internalState</db:code> in reaction to running timers or external triggers.</db:para>
</db:section>
<db:section xml:id="maintaining-game-state">
<db:title>Maintaining Game State</db:title>
<db:para>The <db:code>internalState</db:code> state consists of two main parts: <db:code>logicalState</db:code> and <db:code>workflow</db:code>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/pinball-statechart-internalstate.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The <db:code>logicalState</db:code> state holds the definitions for the modes that the game is able to go into and for the logical states of collected targets. The <db:code>workflow</db:code> state implements a generator for light blinking and calculates most of the new states the machine should go into depending on incoming events and on currently active states. As mentioned already, <db:code>internalState</db:code> is always active, and since it is of a parallel type, <db:code>logicalState</db:code> and <db:code>workflow</db:code> are always active too.</db:para>
</db:section>
<db:section xml:id="maintaining-logical-state-of-buttons">
<db:title>Maintaining Logical State of Buttons</db:title>
<db:para>The <db:code>logicalState</db:code> state consist of two parts: <db:code>letterState</db:code> and <db:code>modeState</db:code>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/pinball-statechart-logicalstate.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>As previously mentioned, <db:code>logicalState</db:code> is always active, and since it is of parallel type, the <db:code>letterState</db:code> and <db:code>modeState</db:code> children are always active too. Now let us look at the first part, the <db:code>letterState</db:code>, which contains one parallel <db:code>lettersState</db:code>:</db:para>
<db:programlisting language="cpp">                &lt;state id=&quot;letterState&quot;&gt;
                    &lt;parallel id=&quot;lettersState&quot;&gt;
                        &lt;state id=&quot;letter.C&quot;&gt;
                            &lt;state id=&quot;cLetterOff&quot;&gt;
                                &lt;transition event=&quot;cLetterTriggered&quot; cond=&quot;In('onState')&quot; target=&quot;cLetterOn&quot;/&gt;
                            &lt;/state&gt;
                            &lt;final id=&quot;cLetterOn&quot;/&gt;
                        &lt;/state&gt;
                        &lt;state id=&quot;letter.R&quot;&gt;
                            ...
                        &lt;/state&gt;
                        &lt;state id=&quot;letter.A&quot;&gt;
                            ...
                        &lt;/state&gt;
                        &lt;state id=&quot;letter.Z&quot;&gt;
                            ...
                        &lt;/state&gt;
                        &lt;state id=&quot;letter.Y&quot;&gt;
                            ...
                        &lt;/state&gt;
                        &lt;transition event=&quot;resetLetters&quot; target=&quot;lettersState&quot;/&gt;
                    &lt;/parallel&gt;
                &lt;/state&gt;
</db:programlisting>
<db:para>The <db:code>lettersState</db:code> state maintains the logical state of the buttons pretending to be targets that were clicked by the players. The letter state for the letter <db:guilabel>C</db:guilabel> holds whether the target for the letter <db:guilabel>C</db:guilabel> was hit, while the light state for the letter <db:guilabel>C</db:guilabel> holds whether the light for the target for the letter <db:guilabel>C</db:guilabel> should be currently on or off. In a real pinball game, these states are usually orthogonal, which means that if you have not hit a target yet, the target is blinking, indicating that it is currently worth hitting. This blinking means that the light state switches between on and off at short intervals, while the target state is continouosly off, because it has not been hit yet. The author of a pinball table can decide that after a target is hit (that is, after the target state switches to on) the target's light is continuously turned off or on or the intervals between lights blinking become shorter or longer.</db:para>
<db:para>As mentioned before, <db:code>letterState</db:code> is always active, which means that its only child <db:code>lettersState</db:code> should always be active too. However, there is one exception: for a short while the <db:code>lettersState</db:code> may end up being <db:emphasis>not active</db:emphasis>. This happens when the transition for <db:code>lettersState</db:code> is being performed. This transition is triggered when the <db:code>resetLetters</db:code> event occurs, and it instructs the state machine to exit <db:code>lettersState</db:code> and all its descendant states and reenter <db:code>lettersState</db:code> and set up all its descendant states with their initial states. In short, the <db:code>resetLetters</db:code> event resets the <db:code>lettersState</db:code> and all its descendant states to the default configuration.</db:para>
<db:para>The <db:code>lettersState</db:code> contains five direct substates that correspond to five different letters. The content for other letters' states than C is not shown here, but it is analogous to the content for C's state.</db:para>
<db:para>The <db:code>letter.C</db:code> state contains two substates reflecting its off and on states: <db:code>cLetterOff</db:code> and <db:code>cLetterOn</db:code>. The <db:code>letter.C</db:code> state inside its parallel parent <db:code>lettersState</db:code> is always active (under the condition that <db:code>lettersState</db:code> is active, as described before). However, only one of its child states is active at a time: <db:code>cLetterOff</db:code> or <db:code>cLetterOn</db:code>. The initial substate of the <db:code>letter.C</db:code> state is <db:code>cLetterOff</db:code> meaning that whenever the <db:code>letter.C</db:code> state is being activated (which happens initially and after the <db:code>resetLetters</db:code> event) its active substate will be set to <db:code>cLetterOff</db:code>.</db:para>
<db:para>The <db:code>cLetterOff</db:code> state defines a transition, which will be triggered by the <db:code>cLetterTriggered</db:code> event. This transition activates <db:code>cLetterOn</db:code>, the other child of <db:code>letter.C</db:code>, only when the machine is in <db:code>onState</db:code> (that is, when the pinball game is running). The <db:code>cLetterTriggered</db:code> event is expected to be an event posted into the state machine from outside of the state machine. This event should be generated when the ball hits the letter <db:guilabel>C</db:guilabel> target. In our example we mimic it by the clicking the letter <db:guilabel>C</db:guilabel> button.</db:para>
<db:para>The <db:code>cLetterOn</db:code> state is defined as a final state, which means that whenever this state is activated the <db:code>done.state.letter.C</db:code> event will be automatically posted by the state machine. This event will be used later for updating the current score.</db:para>
<db:para>Moreover, when all <db:code>lettersState</db:code> children reach their final state, the state machine will automatically post the <db:code>done.state.lettersState</db:code> event. This event will be used later, too, for updating the current score and for turning on or off the hurry state.</db:para>
</db:section>
<db:section xml:id="maintaining-game-modes">
<db:title>Maintaining Game Modes</db:title>
<db:para>The <db:code>modeState</db:code> state consists of two substates, <db:code>offState</db:code> and <db:code>onState</db:code>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/pinball-statechart-modestate.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The <db:code>offState</db:code> state describes what should happen before the pinball game is started and when it is over, while <db:code>onState</db:code> represents the logic appropriate for the active game.</db:para>
<db:programlisting language="cpp">                    &lt;state id=&quot;offState&quot;&gt;
                        &lt;onentry&gt;
                            &lt;if cond=&quot;highScore &amp;lt; score&quot;&gt;
                                &lt;assign location=&quot;highScore&quot; expr=&quot;score&quot;/&gt;
                            &lt;/if&gt;
                            &lt;raise event=&quot;resetLetters&quot;/&gt;
                            &lt;raise event=&quot;update&quot;/&gt;
                        &lt;/onentry&gt;
                        &lt;transition event=&quot;startTriggered&quot; target=&quot;onState&quot;/&gt;
                    &lt;/state&gt;
</db:programlisting>
<db:para>When the pinball application starts or a game ends, the machine goes into <db:code>offState</db:code>. Entering that state invokes some actions, which are enclosed inside an <db:code>&lt;onentry&gt;</db:code> element. First, we update the <db:code>highScore</db:code> variable in case the current <db:code>highScore</db:code> value is less than current <db:code>score</db:code> value. This is being checked inside the <db:code>&quot;cond&quot;</db:code> attribute of the <db:code>&lt;if&gt;</db:code> element (note that we need to escape the &quot;&lt;&quot; character with &quot;&amp;lt;&quot;). Even in the <db:code>off</db:code> state, we want to show the last reached score, so we do not clear it here; we will do that when we enter the <db:code>on</db:code> state. Next, we raise two events: <db:code>resetLetters</db:code> to logically reset all letters that might have been hit during the last game and <db:code>update</db:code> to immediately activate the blinking and updating of all lights. When the machine is in <db:code>offState</db:code>, it is ready to transition into the <db:code>onState</db:code> if only the <db:code>startTriggered</db:code> event occurs, which is described by the &lt;transition&gt; element. This event is expected to be generated externally after clicking the <db:guilabel>START</db:guilabel> button on the pinball table.</db:para>
<db:programlisting language="cpp">                    &lt;parallel id=&quot;onState&quot;&gt;
                        &lt;onentry&gt;
                            &lt;assign location=&quot;score&quot; expr=&quot;0&quot;/&gt;
                        &lt;/onentry&gt;
                        &lt;state id=&quot;hurryState&quot;&gt;
                            &lt;state id=&quot;hurryStateOff&quot;&gt;
                                &lt;onentry&gt;
                                    &lt;raise event=&quot;resetLetters&quot;/&gt;
                                    &lt;raise event=&quot;update&quot;/&gt;
                                &lt;/onentry&gt;
                                &lt;transition event=&quot;goToHurryOn&quot; target=&quot;hurryStateOn&quot;/&gt;
                            &lt;/state&gt;
                            &lt;state id=&quot;hurryStateOn&quot;&gt;
                                &lt;onentry&gt;
                                    &lt;send event=&quot;goToHurryOff&quot; id=&quot;hurryId&quot; delay=&quot;5s&quot;/&gt;
                                    &lt;raise event=&quot;resetLetters&quot;/&gt;
                                    &lt;raise event=&quot;update&quot;/&gt;
                                &lt;/onentry&gt;
                                &lt;transition event=&quot;goToHurryOff&quot; target=&quot;hurryStateOff&quot;/&gt;
                                &lt;onexit&gt;
                                    &lt;cancel sendid=&quot;hurryId&quot;/&gt;
                                &lt;/onexit&gt;
                            &lt;/state&gt;
                        &lt;/state&gt;
                        &lt;state id=&quot;jackpotState&quot;&gt;
                            &lt;state id=&quot;jackpotStateOff&quot;&gt;
                                &lt;onentry&gt;
                                    &lt;raise event=&quot;update&quot;/&gt;
                                &lt;/onentry&gt;
                                &lt;transition event=&quot;goForJackpot&quot; target=&quot;jackpotStateOn&quot;/&gt;
                            &lt;/state&gt;
                            &lt;state id=&quot;jackpotStateOn&quot;&gt;
                                &lt;onentry&gt;
                                    &lt;raise event=&quot;update&quot;/&gt;
                                &lt;/onentry&gt;
                            &lt;/state&gt;
                        &lt;/state&gt;
                        &lt;transition event=&quot;ballOutTriggered&quot; target=&quot;offState&quot;/&gt;
                    &lt;/parallel&gt;
</db:programlisting>
</db:section>
<db:section xml:id="game-on">
<db:title>Game On</db:title>
<db:para>When the state machine enters <db:code>onState</db:code>, it first clears the current score variable. The <db:code>onState</db:code> state is of the parallel type and has two direct child states: <db:code>hurryState</db:code> and <db:code>jackpotState</db:code>. They are active as long as their parent, <db:code>onState</db:code>, is active. Both <db:code>hurryState</db:code> and <db:code>jackpotState</db:code> contain two substates that reflect their off and on states. Only one substate of <db:code>hurryState</db:code> and one substate of <db:code>jackpotState</db:code> can be active at a time. Initially, the off substates are active.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/pinball-statechart-onstate.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Whenever we enter <db:code>hurryStateOff</db:code> or <db:code>hurryStateOn</db:code>, we generate the same two events we generate when entering the <db:code>onState</db:code> state: <db:code>resetLetters</db:code> and <db:code>update</db:code>. In addition, when we enter the <db:code>hurryStateOn</db:code> state, we send a delayed event, <db:code>goToHurryOff</db:code>, with a delay of five seconds, marked with <db:code>hurryId</db:code>. This means that after five seconds we just switch the state back to <db:code>hurryStateOff</db:code> without granting the bonus points. In this way, we implement the five-second hurry feature of the pinball table. We also define transitions from <db:code>hurryStateOff</db:code> to <db:code>hurryStateOn</db:code> when the <db:code>goToHurryOn</db:code> event occurs and from <db:code>hurryStateOn</db:code> to <db:code>hurryStateOff</db:code> when the <db:code>goToHurryOff</db:code> event occurs. When we exit the <db:code>hurryStateOn</db:code> state, we cancel the possibly pending delayed event that was marked with <db:code>hurryId</db:code>. This is important in case the five secons have not elapsed yet, but players have collected all the five letters in the hurry state. We then collect the jackpot and want the pending timer to finish.</db:para>
<db:para>The substates of <db:code>jackpotState</db:code> generate the request to update the state of lights. The <db:code>jackpotStateOff</db:code> state defines the transition to <db:code>jackpotStateOn</db:code> when the <db:code>goForJackpot</db:code> event occurs. The opposite transition is not needed, because when the jackpot gets collected, the corresponding light remains lit until the end of game. When a new game starts, the <db:code>jackpotState</db:code> is entered again which causes its initial active substate to be <db:code>jackpotStateOff</db:code>.</db:para>
<db:para>In addition, the <db:code>onState</db:code> state defines one transition in reaction to the <db:code>ballOutTriggered</db:code> event which instructs the machine to go into the <db:code>offState</db:code>. The <db:code>ballOutTriggered</db:code> event is expected to be an event posted into the state machine from outside of the state machine. This event should be generated when the ball gets out of playing area of the table. In our example we mimic it by the clicking <db:guilabel>BALL OUT</db:guilabel> button. Posting the event from outside of state machine will be shown in the <db:link xlink:href="qtscxml-pinball-example.xml#c-part-glue-gui-with-scxml">C++ code</db:link> later on.</db:para>
</db:section>
<db:section xml:id="generating-blinking-lights">
<db:title>Generating Blinking Lights</db:title>
<db:para>The <db:code>workflow</db:code> state is responsible for generating the blinking lights. The generator is defined in its <db:code>lightImpulseGenerator</db:code> substate. In addition, it is responsible for reacting to events that have been posted so far from the other parts of the state machine.</db:para>
<db:programlisting language="cpp">            &lt;state id=&quot;workflow&quot;&gt;
                &lt;state id=&quot;lightImpulseGenerator&quot;&gt;
                    &lt;state id=&quot;lightImpulseOn&quot;/&gt;
                    &lt;state id=&quot;lightImpulseOff&quot;/&gt;

                    &lt;onentry&gt;
                        &lt;raise event=&quot;update&quot;/&gt;
                    &lt;/onentry&gt;

                    &lt;transition event=&quot;scheduleNewImpulse&quot;&gt;
                        &lt;cancel sendid=&quot;lightId&quot;/&gt;
                        &lt;if cond=&quot;In('offState')&quot;&gt;
                            &lt;send event=&quot;lightImpulse&quot; id=&quot;lightId&quot; delay=&quot;1s&quot;/&gt;
                        &lt;elseif cond=&quot;In('hurryStateOff')&quot;/&gt;
                            &lt;send event=&quot;lightImpulse&quot; id=&quot;lightId&quot; delay=&quot;500ms&quot;/&gt;
                        &lt;else/&gt;
                            &lt;send event=&quot;lightImpulse&quot; id=&quot;lightId&quot; delay=&quot;200ms&quot;/&gt;
                        &lt;/if&gt;
                    &lt;/transition&gt;

                    &lt;transition event=&quot;update&quot;&gt;
                        &lt;raise event=&quot;scheduleNewImpulse&quot;/&gt;
                        &lt;raise event=&quot;updateLights&quot;/&gt;
                    &lt;/transition&gt;

                    &lt;transition event=&quot;lightImpulse&quot; cond=&quot;In('lightImpulseOn')&quot; target=&quot;lightImpulseOff&quot;/&gt;
                    &lt;transition event=&quot;lightImpulse&quot; cond=&quot;In('lightImpulseOff')&quot; target=&quot;lightImpulseOn&quot;/&gt;
                &lt;/state&gt;

                &lt;transition event=&quot;done.state.letter.*&quot;&gt;
                    ...
                &lt;/transition&gt;

                &lt;transition event=&quot;done.state.lettersState&quot;&gt;
                    ...
                &lt;/transition&gt;

                &lt;transition event=&quot;updateLights&quot;&gt;
                    ...
                &lt;/transition&gt;
            &lt;/state&gt;
</db:programlisting>
<db:para>The <db:code>lightImpulseGenerator</db:code> contains two child states: <db:code>lightImpulseOn</db:code> and <db:code>lightImpulseOff</db:code>, with only one active at a time.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/pinball-statechart-workflow.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Whenever the delayed <db:code>lightImpulse</db:code> event is being delivered, it immediately causes the transition from <db:code>lightImpluseOn</db:code> into <db:code>lightImpulseOff</db:code> or vice versa, depending on the state the machine was in. In effect, the <db:code>lightImpulseGenerator</db:code> toggles between its on and off state. These transitions are defined inside <db:code>lightImpulseGenerator</db:code>, so it means that during this toggling the machine also exits <db:code>lightImpulseGenerator</db:code> and reenters it immediately afterwards. Entering <db:code>lightImpulseGenerator</db:code> causes the generation of the <db:code>update</db:code> event. The <db:code>update</db:code> event triggers a targetless transition and posts two other events: <db:code>scheduleNewImpulse</db:code> and <db:code>updateLights</db:code>. The first one, <db:code>scheduleNewImpulse</db:code>, returns back to the <db:code>lightImpulseGenerator</db:code>, which posts a delayed <db:code>lightImpulse</db:code> event. After the delay, the <db:code>lightImpulse</db:code> event gets delivered back to <db:code>lightImpulseGenerator</db:code>, which causes it to toggle its substate again. In this way, the machine enters into a cycle. The current delay of the <db:code>lightImpulse</db:code> event depends on the state in which the machine was in the time of posting the delayed event. If a <db:code>scheduleNewImpulse</db:code> event occurs on demand, before the next delayed <db:code>lightImpulse</db:code> event gets delivered, we cancel any possible pending events.</db:para>
<db:programlisting language="cpp">                &lt;transition event=&quot;done.state.letter.*&quot;&gt;
                    &lt;if cond=&quot;In('hurryStateOff')&quot;&gt;
                        &lt;assign location=&quot;score&quot; expr=&quot;score + 1000&quot;/&gt;
                    &lt;elseif cond=&quot;In('hurryStateOn')&quot;/&gt;
                        &lt;assign location=&quot;score&quot; expr=&quot;score + 10000&quot;/&gt;
                    &lt;/if&gt;
                    &lt;raise event=&quot;updateLights&quot;/&gt;
                &lt;/transition&gt;

                &lt;transition event=&quot;done.state.lettersState&quot;&gt;
                    &lt;if cond=&quot;In('hurryStateOff')&quot;&gt;
                        &lt;assign location=&quot;score&quot; expr=&quot;score + 100000&quot;/&gt;
                        &lt;raise event=&quot;goToHurryOn&quot;/&gt;
                    &lt;elseif cond=&quot;In('hurryStateOn')&quot;/&gt;
                        &lt;assign location=&quot;score&quot; expr=&quot;score + 1000000&quot;/&gt;
                        &lt;raise event=&quot;goToHurryOff&quot;/&gt;
                        &lt;raise event=&quot;goForJackpot&quot;/&gt;
                    &lt;/if&gt;
                &lt;/transition&gt;

</db:programlisting>
<db:para>Whenever we receive the event the name of which matches the <db:code>done.state.letter.*</db:code>, we update the current score. When the machine enters the final substate of the <db:code>letter.C</db:code>, it emits the <db:code>done.state.letter.C</db:code> event. The same happens for all other letters we have previously defined. We capture the events for all letters, that is why we have used an asterisk after a dot in the event name. The transition above is targetless, since we just listen for matching events and update the internal data accordingly without changing any active state. The new score is being increased by 1.000 or 10.000 points, depending on whether we currently are in <db:code>hurryStateOff</db:code> or <db:code>hurryStateOn</db:code>. After the score is updated, we generate the <db:code>updateLights</db:code> event in order to immediately update the letters' lights accordingly. We do not generate the <db:code>update</db:code> event here, since we do not want to toggle the light impulse now, but just update the lights according to the current impulse state.</db:para>
<db:para>We also intercept the <db:code>done.state.lettersState</db:code> event, which is being generated when all the letters have been hit. Depending on which state we are currently in, we grant the players either a small bonus of 100.000 or a big one of 1.000.000 (jackpot). In addition, we toggle the <db:code>hurryState</db:code> substate by sending the <db:code>goToHurryOn</db:code> or <db:code>goToHurryOff</db:code> event. When all letters have been collected while in <db:code>hurryStateOn</db:code>, we also raise the <db:code>goForJackpot</db:code> event which instructs the machine to activate the <db:code>jackpotStateOn</db:code>.</db:para>
<db:programlisting language="cpp">                &lt;transition event=&quot;updateLights&quot;&gt;
                    &lt;send type=&quot;qt:signal&quot; event=&quot;updateScore&quot;&gt;
                        &lt;param name=&quot;highScore&quot; expr=&quot;highScore&quot;/&gt;
                        &lt;param name=&quot;score&quot; expr=&quot;score&quot;/&gt;
                    &lt;/send&gt;
                    &lt;if cond=&quot;In('jackpotStateOn')&quot;&gt;
                        &lt;raise event=&quot;turnOnJackpot&quot;/&gt;
                    &lt;else/&gt;
                        &lt;raise event=&quot;turnOffJackpot&quot;/&gt;
                    &lt;/if&gt;

                    &lt;if cond=&quot;In('lightImpulseOn')&quot;&gt;
                        &lt;if cond=&quot;In('offState')&quot;&gt;
                            &lt;raise event=&quot;turnOnC&quot;/&gt;
                            &lt;raise event=&quot;turnOnR&quot;/&gt;
                            &lt;raise event=&quot;turnOnA&quot;/&gt;
                            &lt;raise event=&quot;turnOnZ&quot;/&gt;
                            &lt;raise event=&quot;turnOnY&quot;/&gt;
                            &lt;raise event=&quot;turnOnHurry&quot;/&gt;
                            &lt;raise event=&quot;turnOnJackpot&quot;/&gt;
                            &lt;raise event=&quot;turnOnGameOver&quot;/&gt;
                        &lt;elseif cond=&quot;In('hurryStateOff')&quot;/&gt;
                            &lt;if cond=&quot;In('cLetterOn')&quot;&gt;
                                &lt;raise event=&quot;turnOnC&quot;/&gt;
                            &lt;else/&gt;
                                &lt;raise event=&quot;turnOffC&quot;/&gt;
                            &lt;/if&gt;
                            &lt;if cond=&quot;In('rLetterOn')&quot;&gt;
                                ...
                            &lt;/if&gt;
                            &lt;if cond=&quot;In('aLetterOn')&quot;&gt;
                                ...
                            &lt;/if&gt;
                            &lt;if cond=&quot;In('zLetterOn')&quot;&gt;
                                ...
                            &lt;/if&gt;
                            &lt;if cond=&quot;In('yLetterOn')&quot;&gt;
                                ...
                            &lt;/if&gt;
                            &lt;raise event=&quot;turnOffHurry&quot;/&gt;
                            &lt;raise event=&quot;turnOffGameOver&quot;/&gt;
                        &lt;else/&gt;
                            &lt;raise event=&quot;turnOnC&quot;/&gt;
                            &lt;raise event=&quot;turnOnR&quot;/&gt;
                            &lt;raise event=&quot;turnOnA&quot;/&gt;
                            &lt;raise event=&quot;turnOnZ&quot;/&gt;
                            &lt;raise event=&quot;turnOnY&quot;/&gt;
                            &lt;raise event=&quot;turnOnHurry&quot;/&gt;
                            &lt;raise event=&quot;turnOffGameOver&quot;/&gt;
                        &lt;/if&gt;
                    &lt;else/&gt;
                        &lt;if cond=&quot;In('offState')&quot;&gt;
                            &lt;raise event=&quot;turnOffC&quot;/&gt;
                            &lt;raise event=&quot;turnOffR&quot;/&gt;
                            &lt;raise event=&quot;turnOffA&quot;/&gt;
                            &lt;raise event=&quot;turnOffZ&quot;/&gt;
                            &lt;raise event=&quot;turnOffY&quot;/&gt;
                            &lt;raise event=&quot;turnOffHurry&quot;/&gt;
                            &lt;raise event=&quot;turnOffJackpot&quot;/&gt;
                        &lt;elseif cond=&quot;In('hurryStateOff')&quot;/&gt;
                            &lt;raise event=&quot;turnOffC&quot;/&gt;
                            &lt;raise event=&quot;turnOffR&quot;/&gt;
                            &lt;raise event=&quot;turnOffA&quot;/&gt;
                            &lt;raise event=&quot;turnOffZ&quot;/&gt;
                            &lt;raise event=&quot;turnOffY&quot;/&gt;
                        &lt;else/&gt;
                            &lt;if cond=&quot;In('cLetterOn')&quot;&gt;
                                &lt;raise event=&quot;turnOnC&quot;/&gt;
                            &lt;else/&gt;
                                &lt;raise event=&quot;turnOffC&quot;/&gt;
                            &lt;/if&gt;
                            &lt;if cond=&quot;In('rLetterOn')&quot;&gt;
                                ...
                            &lt;/if&gt;
                            &lt;if cond=&quot;In('aLetterOn')&quot;&gt;
                                ...
                            &lt;/if&gt;
                            &lt;if cond=&quot;In('zLetterOn')&quot;&gt;
                                ...
                            &lt;/if&gt;
                            &lt;if cond=&quot;In('yLetterOn')&quot;&gt;
                                ...
                            &lt;/if&gt;
                        &lt;/if&gt;
                        &lt;raise event=&quot;turnOffHurry&quot;/&gt;
                        &lt;raise event=&quot;turnOffGameOver&quot;/&gt;
                    &lt;/if&gt;
                &lt;/transition&gt;
</db:programlisting>
<db:para>When we receive the <db:code>updateLights</db:code> event, we first want to send a <db:code>updateScore</db:code> signal outside of the state machine. We pass the current values of the <db:code>highScore</db:code> and <db:code>score</db:code> variables to the signal. This signal is received by the C++ part.</db:para>
<db:para>Next, depending on whether we are in <db:code>jackpotStateOn</db:code> or <db:code>jackpotStateOff</db:code>, we send the <db:code>turnOnJackpot</db:code> or the <db:code>turnOffJackpot</db:code> signal, which instructs the <db:code>guiControl</db:code> state to transition to <db:code>jackpotLightOn</db:code> or <db:code>jackpotLightOff</db:code>, respectively.</db:para>
<db:para>When the machine is in <db:emphasis>idle</db:emphasis> state, (that is, in the off state) or when the game is on, but no interaction occurs, the <db:code>updateLights</db:code> event is delivered periodically during the game, each time with the <db:code>lightImpulseOn</db:code> or <db:code>lightImpulseOff</db:code> state toggled. Depending on the current state of the light impulse and on the active state (<db:code>offState</db:code>, <db:code>hurryStateOff</db:code> or <db:code>hurryStateOn</db:code>), we turn on or off all the lights according to the description of the pinball table.</db:para>
</db:section>
</db:section>
<db:section xml:id="gui-part-user-interface-description">
<db:title>GUI Part: User Interface Description</db:title>
<db:para>The GUI part of the application consists of a <db:emphasis>mainwindow.ui</db:emphasis> file which describes the static user interface of the game.</db:para>
<db:anchor xml:id="cpp"/>
</db:section>
<db:section xml:id="c-part-glue-gui-with-scxml">
<db:title>C++ Part: Glue GUI with SCXML</db:title>
<db:para>The C++ part of the application consists of a <db:code>MainWindow</db:code> class which glues the GUI part with the SCXML part. The class is declared in <db:emphasis>mainwindow.h</db:emphasis>.</db:para>
<db:programlisting language="cpp">class Pinball;

class MainWindow : public QWidget
{
    Q_OBJECT

public:
    explicit MainWindow(Pinball *machine, QWidget *parent = 0);
    ~MainWindow();

private slots:
    void eventOccurred(const QScxmlEvent &amp;event);

private:
    void initAndConnect(const QString &amp;state, QWidget *widget);
    QT_PREPEND_NAMESPACE(Ui::MainWindow) *m_ui;
    Pinball *m_machine;
};

</db:programlisting>
<db:para>The <db:code>MainWindow</db:code> class holds the pointer to the <db:code>Pinball *m_machine</db:code> which is the state machine class automatically generated by Qt out of SCMXL file and the pointer to the <db:code>Ui::MainWindow *m_ui</db:code> which describes the GUI part. It also declares two helper methods.</db:para>
<db:programlisting language="cpp">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;

#include &lt;QStringListModel&gt;
#include &quot;pinball.h&quot;

QT_USE_NAMESPACE

MainWindow::MainWindow(Pinball *machine, QWidget *parent) :
    QWidget(parent),
    m_ui(new Ui::MainWindow),
    m_machine(machine)
{
    m_ui-&gt;setupUi(this);

    // lights
    initAndConnect(QLatin1String(&quot;cLightOn&quot;), m_ui-&gt;cLabel);
    initAndConnect(QLatin1String(&quot;rLightOn&quot;), m_ui-&gt;rLabel);
    initAndConnect(QLatin1String(&quot;aLightOn&quot;), m_ui-&gt;aLabel);
    initAndConnect(QLatin1String(&quot;zLightOn&quot;), m_ui-&gt;zLabel);
    initAndConnect(QLatin1String(&quot;yLightOn&quot;), m_ui-&gt;yLabel);
    initAndConnect(QLatin1String(&quot;hurryLightOn&quot;), m_ui-&gt;hurryLabel);
    initAndConnect(QLatin1String(&quot;jackpotLightOn&quot;), m_ui-&gt;jackpotLabel);
    initAndConnect(QLatin1String(&quot;gameOverLightOn&quot;), m_ui-&gt;gameOverLabel);

    // help labels
    initAndConnect(QLatin1String(&quot;offState&quot;), m_ui-&gt;offStateLabel);
    initAndConnect(QLatin1String(&quot;hurryStateOff&quot;), m_ui-&gt;normalStateLabel);
    initAndConnect(QLatin1String(&quot;hurryStateOn&quot;), m_ui-&gt;hurryStateLabel);
    initAndConnect(QLatin1String(&quot;jackpotStateOn&quot;), m_ui-&gt;jackpotStateLabel);

    // context enablement
    initAndConnect(QLatin1String(&quot;offState&quot;), m_ui-&gt;startButton);
    initAndConnect(QLatin1String(&quot;onState&quot;), m_ui-&gt;cButton);
    initAndConnect(QLatin1String(&quot;onState&quot;), m_ui-&gt;rButton);
    initAndConnect(QLatin1String(&quot;onState&quot;), m_ui-&gt;aButton);
    initAndConnect(QLatin1String(&quot;onState&quot;), m_ui-&gt;zButton);
    initAndConnect(QLatin1String(&quot;onState&quot;), m_ui-&gt;yButton);
    initAndConnect(QLatin1String(&quot;onState&quot;), m_ui-&gt;ballOutButton);

    // datamodel update
    connect(m_machine, SIGNAL(eventOccurred(const QScxmlEvent &amp;)),
            this, SLOT(eventOccurred(const QScxmlEvent &amp;)));

    // gui interaction
    connect(m_ui-&gt;cButton, &amp;QAbstractButton::clicked,
            [this] { m_machine-&gt;submitEvent(&quot;cLetterTriggered&quot;);
            });
    connect(m_ui-&gt;rButton, &amp;QAbstractButton::clicked,
            [this] { m_machine-&gt;submitEvent(&quot;rLetterTriggered&quot;);
            });
    connect(m_ui-&gt;aButton, &amp;QAbstractButton::clicked,
            [this] { m_machine-&gt;submitEvent(&quot;aLetterTriggered&quot;);
            });
    connect(m_ui-&gt;zButton, &amp;QAbstractButton::clicked,
            [this] { m_machine-&gt;submitEvent(&quot;zLetterTriggered&quot;);
            });
    connect(m_ui-&gt;yButton, &amp;QAbstractButton::clicked,
            [this] { m_machine-&gt;submitEvent(&quot;yLetterTriggered&quot;);
            });
    connect(m_ui-&gt;startButton, &amp;QAbstractButton::clicked,
            [this] { m_machine-&gt;submitEvent(&quot;startTriggered&quot;);
            });
    connect(m_ui-&gt;ballOutButton, &amp;QAbstractButton::clicked,
            [this] { m_machine-&gt;submitEvent(&quot;ballOutTriggered&quot;);
            });
}

</db:programlisting>
<db:para>The constructor of the <db:code>MainWindow</db:code> class instantiates the GUI part of the application and stores the pointer to the passed <db:code>Pinball</db:code> state machine. It also initializes the GUI part and glues the GUI part to the state machine by connecting their communication interfaces together.</db:para>
<db:para>The <db:code>initAndConnect()</db:code> method connects the state with the corresponding GUI widget by binding its activity with the enabling of the widget, so that whenever the state is active, its corresponding widget is enabled and whenever the state is inactive, the widget is disabled. We do that for all lights, targets, and description labels.</db:para>
<db:para>We also connect to the <db:code>eventOccurred()</db:code> signal, propagated by the state machine and intercept the <db:code>updateScore</db:code> event sent from the SCXML document in order to update the score displays with the values passed with the event.</db:para>
<db:para>The info about hitting any GUI target needs to be passed to the state machine and we do that by connecting all target buttons' <db:code>clicked</db:code> signals to the lambda expressions which submit the corresponding event into the state machine.</db:para>
<db:programlisting language="cpp">#include &quot;pinball.h&quot;
#include &quot;mainwindow.h&quot;

#include &lt;QApplication&gt;

int main(int argc, char **argv)
{
    QApplication app(argc, argv);

    Pinball machine;
    MainWindow mainWindow(&amp;machine);

    machine.start();
    mainWindow.show();
    return app.exec();
}

</db:programlisting>
<db:para>In the <db:code>main()</db:code> function in the <db:emphasis>main.cpp</db:emphasis> file, we instantiate the <db:code>app</db:code> application object, <db:code>Pinball</db:code> state machine, and <db:code>MainWindow</db:code> GUI class. We initialize and start the state machine, show the main window, and execute the application.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="pinball/main.cpp">pinball/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="pinball/mainwindow.cpp">pinball/mainwindow.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="pinball/mainwindow.h">pinball/mainwindow.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="pinball/mainwindow.ui">pinball/mainwindow.ui</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="pinball/pinball.pro">pinball/pinball.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="pinball/pinball.scxml">pinball/pinball.scxml</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
