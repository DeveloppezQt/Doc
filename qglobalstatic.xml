<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title></db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qglobalstatic.xml">QGlobalStatic</db:link> class is used to implement a global static object.</db:para>
<db:para>This struct was introduced in Qt 5.1.</db:para>
<db:note>
<db:para>All functions in this struct are <db:link xlink:href="threads-reentrancy.xml">thread-safe</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QGlobalStatic</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.1</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qglobalstatic.xml">QGlobalStatic</db:link> class is the front-end API exported when <db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC">Q_GLOBAL_STATIC</db:link>() is used. See the documentation for the macro for a discussion on when to use it and its requirements.</db:para>
<db:para>Normally, you will never use this class directly, but instead you will use the <db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC">Q_GLOBAL_STATIC</db:link>() or <db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC_WITH_ARGS">Q_GLOBAL_STATIC_WITH_ARGS</db:link>() macros, as follows:</db:para>
<db:programlisting language="cpp">Q_GLOBAL_STATIC(MyType, staticType)
</db:programlisting>
<db:para>The above example creates an object of type <db:link xlink:href="qglobalstatic.xml">QGlobalStatic</db:link> called <db:code>staticType</db:code>. After the above declaration, the <db:code>staticType</db:code> object may be used as if it were a pointer, guaranteed to be initialized exactly once. In addition to the use as a pointer, the object offers two methods to determine the current status of the global: exists() and isDestroyed().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC">Q_GLOBAL_STATIC</db:link>()</db:member>
<db:member><db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC_WITH_ARGS">Q_GLOBAL_STATIC_WITH_ARGS</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Type-typedef">
<db:title>QGlobalStatic::Type</db:title>
<db:para>This type is equivalent to the <db:code>Type</db:code> parameter passed to the <db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC">Q_GLOBAL_STATIC</db:link>() or <db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC_WITH_ARGS">Q_GLOBAL_STATIC_WITH_ARGS</db:link>() macros. It is used in the return types of some functions.</db:para>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="Q_GLOBAL_STATIC">
<db:title>[since 5.1] Q_GLOBAL_STATIC(<db:emphasis>Type</db:emphasis>, <db:emphasis>VariableName</db:emphasis>)</db:title>
<db:para>Creates a global and static object of type <db:link xlink:href="qglobalstatic.xml">QGlobalStatic</db:link>, of name <db:code role="parameter">VariableName</db:code> and that behaves as a pointer to <db:code role="parameter">Type</db:code>. The object created by Q_GLOBAL_STATIC initializes itself on the first use, which means that it will not increase the application or the library's load time. Additionally, the object is initialized in a thread-safe manner on all platforms.</db:para>
<db:para>The typical use of this macro is as follows, in a global context (that is, outside of any function bodies):</db:para>
<db:programlisting language="cpp">Q_GLOBAL_STATIC(MyType, staticType)
</db:programlisting>
<db:para>This macro is intended to replace global static objects that are not POD (Plain Old Data, or in C++11 terms, not made of a trivial type), hence the name. For example, the following C++ code creates a global static:</db:para>
<db:programlisting language="cpp">static MyType staticType;
</db:programlisting>
<db:para>Compared to Q_GLOBAL_STATIC, and assuming that <db:code>MyType</db:code> is a class or struct that has a constructor, a destructor, or is otherwise non-POD, the above has the following drawbacks:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>it requires load-time initialization of <db:code>MyType</db:code> (that is, the default constructor for <db:code>MyType</db:code> is called when the library or application is loaded);</db:para>
</db:listitem>
<db:listitem>
<db:para>the type will be initialized even if it is never used;</db:para>
</db:listitem>
<db:listitem>
<db:para>the order of initialization and destruction among different translation units is not determined, leading to possible uses before initialization or after destruction;</db:para>
</db:listitem>
<db:listitem>
<db:para>if it is found inside a function (that is, not global), it will be initialized on first use, but many current compilers (as of 2013) do not guarantee that the initialization will be thread-safe;</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The Q_GLOBAL_STATIC macro solves all of the above problems by guaranteeing thread-safe initialization on first use and allowing the user to query for whether the type has already been destroyed, to avoid the use-after-destruction problem (see QGlobalStatic::isDestroyed()).</db:para>
<db:section xml:id="constructor-and-destructor">
<db:title>Constructor and Destructor</db:title>
<db:para>For Q_GLOBAL_STATIC, the type <db:code>Type</db:code> must be publicly default-constructible and publicly destructible. For <db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC_WITH_ARGS">Q_GLOBAL_STATIC_WITH_ARGS</db:link>(), there must be a public constructor that matches the arguments passed.</db:para>
<db:para>It is not possible to use Q_GLOBAL_STATIC with types that have protected or private default constructors or destructors (for <db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC_WITH_ARGS">Q_GLOBAL_STATIC_WITH_ARGS</db:link>(), a protected or private constructor matching the arguments). If the type in question has those members as protected, it is possible to overcome the issue by deriving from the type and creating public a constructor and destructor. If the type has them as private, a friend declaration is necessary before deriving.</db:para>
<db:para>For example, the following is enough to create <db:code>MyType</db:code> based on a previously-defined <db:code>MyOtherType</db:code> which has a protected default constructor and/or a protected destructor (or has them as private, but that defines <db:code>MyType</db:code> as a friend).</db:para>
<db:programlisting language="cpp">class MyType : public MyOtherType { };
Q_GLOBAL_STATIC(MyType, staticType)
</db:programlisting>
<db:para>No body for <db:code>MyType</db:code> is required since the destructor is an implicit member and so is the default constructor if no other constructors are defined. For use with <db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC_WITH_ARGS">Q_GLOBAL_STATIC_WITH_ARGS</db:link>(), however, a suitable constructor body is necessary:</db:para>
<db:programlisting language="cpp">class MyType : public MyOtherType
{
public:
    MyType(int i) : MyOtherType(i) {}
};
Q_GLOBAL_STATIC_WITH_ARGS(MyType, staticType, (42))
</db:programlisting>
<db:para>Alternatively, if the compiler supports C++11 inheriting constructors, one could write:</db:para>
<db:programlisting language="cpp">class MyType : public MyOtherType
{
public:
    using MyOtherType::MyOtherType;
};
Q_GLOBAL_STATIC_WITH_ARGS(MyType, staticType, (42))
</db:programlisting>
</db:section>
<db:section xml:id="placement">
<db:title>Placement</db:title>
<db:para>The Q_GLOBAL_STATIC macro creates a type that is necessarily static, at the global scope. It is not possible to place the Q_GLOBAL_STATIC macro inside a function (doing so will result in compilation errors).</db:para>
<db:para>More importantly, this macro should be placed in source files, never in headers. Since the resulting object is has static linkage, if the macro is placed in a header and included by multiple source files, the object will be defined multiple times and will not cause linking errors. Instead, each translation unit will refer to a different object, which could lead to subtle and hard-to-track errors.</db:para>
</db:section>
<db:section xml:id="non-recommended-uses">
<db:title>Non-recommended uses</db:title>
<db:para>Note that the macro is not recommended for use with types that are POD or that have C++11 constexpr constructors (trivially constructible and destructible). For those types, it is still recommended to use regular static, whether global or function-local.</db:para>
<db:para>This macro will work, but it will add unnecessary overhead.</db:para>
</db:section>
<db:section xml:id="reentrancy-thread-safety-deadlocks-and-exception-safety-on-construction">
<db:title>Reentrancy, Thread-safety, Deadlocks, and Exception-safety on Construction</db:title>
<db:para>The Q_GLOBAL_STATIC macro creates an object that initializes itself on first use in a thread-safe manner: if multiple threads attempt to initialize the object at the same time, only one thread will proceed to initialize, while all other threads wait for completion.</db:para>
<db:para>If the initialization process throws an exception, the initialization is deemed not complete and will be attempted again when control reaches any use of the object. If there are any threads waiting for initialization, one of them will be woken up to attempt to initialize.</db:para>
<db:para>The macro makes no guarantee about reentrancy from the same thread. If the global static object is accessed directly or indirectly from inside the constructor, a deadlock will surely happen.</db:para>
<db:para>In addition, if two Q_GLOBAL_STATIC objects are being initialized on two different threads and each one's initialization sequence accesses the other, a deadlock might happen. For that reason, it is recommended to keep global static constructors simple or, failing that, to ensure that there's no cross-dependency of uses of global static during construction.</db:para>
</db:section>
<db:section xml:id="destruction">
<db:title>Destruction</db:title>
<db:para>If the object is never used during the lifetime of the program, aside from the QGlobalStatic::exists() and QGlobalStatic::isDestroyed() functions, the contents of type <db:code role="parameter">Type</db:code> will not be created and there will not be any exit-time operation.</db:para>
<db:para>If the object is created, it will be destroyed at exit-time, similar to the C <db:code>atexit</db:code> function. On most systems, in fact, the destructor will also be called if the library or plugin is unloaded from memory before exit.</db:para>
<db:para>Since the destruction is meant to happen at program exit, no thread-safety is provided. This includes the case of plugin or library unload. In addition, since destructors are not supposed to throw exceptions, no exception safety is provided either.</db:para>
<db:para>However, reentrancy is permitted: during destruction, it is possible to access the global static object and the pointer returned will be the same as it was before destruction began. After the destruction has completed, accessing the global static object is not permitted, except as noted in the <db:link xlink:href="qglobalstatic.xml">QGlobalStatic</db:link> API.</db:para>
</db:section>
<db:section>
<db:title>Notes</db:title>
<db:para>This macro was introduced in Qt 5.1.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC_WITH_ARGS">Q_GLOBAL_STATIC_WITH_ARGS</db:link>()</db:member>
<db:member><db:link xlink:href="qglobalstatic.xml">QGlobalStatic</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Q_GLOBAL_STATIC_WITH_ARGS">
<db:title>[since 5.1] Q_GLOBAL_STATIC_WITH_ARGS(<db:emphasis>Type</db:emphasis>, <db:emphasis>VariableName</db:emphasis>, <db:emphasis>Arguments</db:emphasis>)</db:title>
<db:para>Creates a global and static object of type <db:link xlink:href="qglobalstatic.xml">QGlobalStatic</db:link>, of name <db:code role="parameter">VariableName</db:code>, initialized by the arguments <db:code role="parameter">Arguments</db:code> and that behaves as a pointer to <db:code role="parameter">Type</db:code>. The object created by Q_GLOBAL_STATIC_WITH_ARGS initializes itself on the first use, which means that it will not increase the application or the library's load time. Additionally, the object is initialized in a thread-safe manner on all platforms.</db:para>
<db:para>The typical use of this macro is as follows, in a global context (that is, outside of any function bodies):</db:para>
<db:programlisting language="cpp">Q_GLOBAL_STATIC_WITH_ARGS(MyType, staticType, (42, &quot;Hello&quot;, &quot;World&quot;))
</db:programlisting>
<db:para>The <db:code role="parameter">Arguments</db:code> macro parameter must always include the parentheses or, if C++11 uniform initialization is allowed, the braces.</db:para>
<db:para>Aside from the actual initialization of the contents with the supplied arguments, this macro behaves identically to <db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC">Q_GLOBAL_STATIC</db:link>(). Please see that macro's documentation for more information.</db:para>
<db:para>This macro was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglobalstatic.xml#Q_GLOBAL_STATIC">Q_GLOBAL_STATIC</db:link>()</db:member>
<db:member><db:link xlink:href="qglobalstatic.xml">QGlobalStatic</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
