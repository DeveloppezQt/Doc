<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Part 5 - Adding a Find Function</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.5.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Widgets Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Here we look at ways to locate contacts and addresses in the address book.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part5-screenshot.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>As we add contacts to our address book, it becomes tedious to navigate the list with the <db:emphasis>Next</db:emphasis> and <db:emphasis>Previous</db:emphasis> buttons. A <db:emphasis>Find</db:emphasis> function would be more efficient. The screenshot above shows the <db:emphasis>Find</db:emphasis> button and its position on the panel of buttons.</db:para>
<db:para>When the user clicks on the <db:emphasis>Find</db:emphasis> button, it is useful to display a dialog that prompts for a contact's name. Qt provides QDialog, which we subclass here to implement a <db:code>FindDialog</db:code> class.</db:para>
<db:section xml:id="defining-the-finddialog-class">
<db:title>Defining the FindDialog Class</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part5-finddialog.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>In order to subclass QDialog, we first include the header for QDialog in the <db:code>finddialog.h</db:code> file. Also, we use forward declaration to declare QLineEdit and QPushButton since we will be using those widgets in our dialog class.</db:para>
<db:para>As in our <db:code>AddressBook</db:code> class, the <db:code>FindDialog</db:code> class includes the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro and its constructor is defined to accept a parent QWidget, even though the dialog will be opened as a separate window.</db:para>
<db:programlisting language="cpp">#include &lt;QDialog&gt;

class QLineEdit;
class QPushButton;

class FindDialog : public QDialog
{
    Q_OBJECT

public:
    FindDialog(QWidget *parent = 0);
    QString getFindText();

public slots:
    void findClicked();

private:
    QPushButton *findButton;
    QLineEdit *lineEdit;
    QString findText;
};
</db:programlisting>
<db:para>We define a public function, <db:code>getFindText()</db:code>, to be used by classes that instantiate <db:code>FindDialog</db:code>. This function allows these classes to obtain the search string entered by the user. A public slot, <db:code>findClicked()</db:code>, is also defined to handle the search string when the user clicks the <db:guilabel>Find</db:guilabel> button.</db:para>
<db:para>Lastly, we define the private variables, <db:code>findButton</db:code>, <db:code>lineEdit</db:code> and <db:code>findText</db:code>, corresponding to the <db:guilabel>Find</db:guilabel> button, the line edit into which the user types the search string, and an internal string used to store the search string for later use.</db:para>
</db:section>
<db:section xml:id="implementing-the-finddialog-class">
<db:title>Implementing the FindDialog Class</db:title>
<db:para>Within the constructor of <db:code>FindDialog</db:code>, we set up the private variables, <db:code>lineEdit</db:code>, <db:code>findButton</db:code> and <db:code>findText</db:code>. We use a QHBoxLayout to position the widgets.</db:para>
<db:programlisting language="cpp">FindDialog::FindDialog(QWidget *parent)
    : QDialog(parent)
{
    QLabel *findLabel = new QLabel(tr(&quot;Enter the name of a contact:&quot;));
    lineEdit = new QLineEdit;

    findButton = new QPushButton(tr(&quot;&amp;Find&quot;));
    findText = &quot;&quot;;

    QHBoxLayout *layout = new QHBoxLayout;
    layout-&gt;addWidget(findLabel);
    layout-&gt;addWidget(lineEdit);
    layout-&gt;addWidget(findButton);

    setLayout(layout);
    setWindowTitle(tr(&quot;Find a Contact&quot;));
    connect(findButton, SIGNAL(clicked()), this, SLOT(findClicked()));
    connect(findButton, SIGNAL(clicked()), this, SLOT(accept()));
}
</db:programlisting>
<db:para>We set the layout and window title, as well as connect the signals to their respective slots. Notice that <db:code>findButton</db:code>'s <db:link xlink:href="">clicked()</db:link> signal is connected to <db:code>findClicked()</db:code> and <db:link xlink:href="">accept()</db:link>. The <db:link xlink:href="">accept()</db:link> slot provided by QDialog hides the dialog and sets the result code to Accepted. We use this function to help <db:code>AddressBook</db:code>'s <db:code>findContact()</db:code> function know when the <db:code>FindDialog</db:code> object has been closed. We will explain this logic in further detail when discussing the <db:code>findContact()</db:code> function.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part5-signals-and-slots.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>In <db:code>findClicked()</db:code>, we validate <db:code>lineEdit</db:code> to ensure that the user did not click the <db:guilabel>Find</db:guilabel> button without entering a contact's name. Then, we set <db:code>findText</db:code> to the search string, extracted from <db:code>lineEdit</db:code>. After that, we clear the contents of <db:code>lineEdit</db:code> and hide the dialog.</db:para>
<db:programlisting language="cpp">void FindDialog::findClicked()
{
    QString text = lineEdit-&gt;text();

    if (text.isEmpty()) {
        QMessageBox::information(this, tr(&quot;Empty Field&quot;),
            tr(&quot;Please enter a name.&quot;));
        return;
    } else {
        findText = text;
        lineEdit-&gt;clear();
        hide();
    }
}
</db:programlisting>
<db:para>The <db:code>findText</db:code> variable has a public getter function, <db:code>getFindText()</db:code>, associated with it. Since we only ever set <db:code>findText</db:code> directly in both the constructor and in the <db:code>findClicked()</db:code> function, we do not create a setter function to accompany <db:code>getFindText()</db:code>. Because <db:code>getFindText()</db:code> is public, classes instantiating and using <db:code>FindDialog</db:code> can always access the search string that the user has entered and accepted.</db:para>
<db:programlisting language="cpp">QString FindDialog::getFindText()
{
    return findText;
}
</db:programlisting>
</db:section>
<db:section xml:id="defining-the-addressbook-class">
<db:title>Defining the AddressBook Class</db:title>
<db:para>To ensure we can use <db:code>FindDialog</db:code> from within our <db:code>AddressBook</db:code> class, we include <db:code>finddialog.h</db:code> in the <db:code>addressbook.h</db:code> file.</db:para>
<db:programlisting language="cpp">#include &quot;finddialog.h&quot;
</db:programlisting>
<db:para>So far, all our address book features have a QPushButton and a corresponding slot. Similarly, for the <db:guilabel>Find</db:guilabel> feature we have <db:code>findButton</db:code> and <db:code>findContact()</db:code>.</db:para>
<db:para>The <db:code>findButton</db:code> is declared as a private variable and the <db:code>findContact()</db:code> function is declared as a public slot.</db:para>
<db:programlisting language="cpp">    void findContact();
    ...
    QPushButton *findButton;
</db:programlisting>
<db:para>Lastly, we declare the private variable, <db:code>dialog</db:code>, which we will use to refer to an instance of <db:code>FindDialog</db:code>.</db:para>
<db:programlisting language="cpp">    FindDialog *dialog;
</db:programlisting>
<db:para>Once we have instantiated a dialog, we will want to use it more than once; using a private variable allows us to refer to it from more than one place in the class.</db:para>
</db:section>
<db:section xml:id="implementing-the-addressbook-class">
<db:title>Implementing the AddressBook Class</db:title>
<db:para>Within the <db:code>AddressBook</db:code> class's constructor, we instantiate our private objects, <db:code>findButton</db:code> and <db:code>findDialog</db:code>:</db:para>
<db:programlisting language="cpp">    findButton = new QPushButton(tr(&quot;&amp;Find&quot;));
    findButton-&gt;setEnabled(false);
    ...
    dialog = new FindDialog(this);
</db:programlisting>
<db:para>Next, we connect the <db:code>findButton</db:code>'s <db:link xlink:href="">clicked()</db:link> signal to <db:code>findContact()</db:code>.</db:para>
<db:programlisting language="cpp">    connect(findButton, SIGNAL(clicked()), this, SLOT(findContact()));
</db:programlisting>
<db:para>Now all that is left is the code for our <db:code>findContact()</db:code> function:</db:para>
<db:programlisting language="cpp">void AddressBook::findContact()
{
    dialog-&gt;show();

    if (dialog-&gt;exec() == QDialog::Accepted) {
        QString contactName = dialog-&gt;getFindText();

        if (contacts.contains(contactName)) {
            nameLine-&gt;setText(contactName);
            addressText-&gt;setText(contacts.value(contactName));
        } else {
            QMessageBox::information(this, tr(&quot;Contact Not Found&quot;),
                tr(&quot;Sorry, \&quot;%1\&quot; is not in your address book.&quot;).arg(contactName));
            return;
        }
    }

    updateInterface(NavigationMode);
}
</db:programlisting>
<db:para>We start out by displaying the <db:code>FindDialog</db:code> instance, <db:code>dialog</db:code>. This is when the user enters a contact name to look up. Once the user clicks the dialog's <db:code>findButton</db:code>, the dialog is hidden and the result code is set to QDialog::Accepted. This ensures that our <db:code>if</db:code> statement is always true.</db:para>
<db:para>We then proceed to extract the search string, which in this case is <db:code>contactName</db:code>, using <db:code>FindDialog</db:code>'s <db:code>getFindText()</db:code> function. If the contact exists in our address book, we display it immediately. Otherwise, we display the QMessageBox shown below to indicate that their search failed.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part5-notfound.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part5/addressbook.cpp">tutorials/addressbook/part5/addressbook.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part5/addressbook.h">tutorials/addressbook/part5/addressbook.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part5/finddialog.cpp">tutorials/addressbook/part5/finddialog.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part5/finddialog.h">tutorials/addressbook/part5/finddialog.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part5/main.cpp">tutorials/addressbook/part5/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorials/addressbook/part5/part5.pro">tutorials/addressbook/part5/part5.pro</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
