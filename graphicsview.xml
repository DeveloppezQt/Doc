<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Graphics View Framework</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.14.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>An overview of the Graphics View framework for interactive 2D graphics.</db:para>
<db:para>This documentation was introduced in Qt 4.2.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Graphics View provides a surface for managing and interacting with a large number of custom-made 2D graphical items, and a view widget for visualizing the items, with support for zooming and rotation.</db:para>
<db:para>The framework includes an event propagation architecture that allows precise double-precision interaction capabilities for the items on the scene. Items can handle key events, mouse press, move, release and double click events, and they can also track mouse movement.</db:para>
<db:para>Graphics View uses a BSP (Binary Space Partitioning) tree to provide very fast item discovery, and as a result of this, it can visualize large scenes in real-time, even with millions of items.</db:para>
<db:para>Graphics View was introduced in Qt 4.2, replacing its predecessor, QCanvas.</db:para>
<db:para>Topics:</db:para>
<db:section xml:id="the-graphics-view-architecture">
<db:title>The Graphics View Architecture</db:title>
<db:para>Graphics View provides an item-based approach to model-view programming, much like InterView's convenience classes QTableView, QTreeView and QListView. Several views can observe a single scene, and the scene contains items of varying geometric shapes.</db:para>
<db:section xml:id="the-scene">
<db:title>The Scene</db:title>
<db:para>QGraphicsScene provides the Graphics View scene. The scene has the following responsibilities:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Providing a fast interface for managing a large number of items</db:para>
</db:listitem>
<db:listitem>
<db:para>Propagating events to each item</db:para>
</db:listitem>
<db:listitem>
<db:para>Managing item state, such as selection and focus handling</db:para>
</db:listitem>
<db:listitem>
<db:para>Providing untransformed rendering functionality; mainly for printing</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The scene serves as a container for QGraphicsItem objects. Items are added to the scene by calling QGraphicsScene::addItem(), and then retrieved by calling one of the many item discovery functions. QGraphicsScene::items() and its overloads return all items contained by or intersecting with a point, a rectangle, a polygon or a general vector path. QGraphicsScene::itemAt() returns the topmost item at a particular point. All item discovery functions return the items in descending stacking order (i.e., the first returned item is topmost, and the last item is bottom-most).</db:para>
<db:programlisting language="cpp">QGraphicsScene scene;
QGraphicsRectItem *rect = scene.addRect(QRectF(0, 0, 100, 100));

QGraphicsItem *item = scene.itemAt(50, 50);
// item == rect
</db:programlisting>
<db:para>QGraphicsScene's event propagation architecture schedules scene events for delivery to items, and also manages propagation between items. If the scene receives a mouse press event at a certain position, the scene passes the event on to whichever item is at that position.</db:para>
<db:para>QGraphicsScene also manages certain item states, such as item selection and focus. You can select items on the scene by calling QGraphicsScene::setSelectionArea(), passing an arbitrary shape. This functionality is also used as a basis for rubberband selection in QGraphicsView. To get the list of all currently selected items, call QGraphicsScene::selectedItems(). Another state handled by QGraphicsScene is whether or not an item has keyboard input focus. You can set focus on an item by calling QGraphicsScene::setFocusItem() or QGraphicsItem::setFocus(), or get the current focus item by calling QGraphicsScene::focusItem().</db:para>
<db:para>Finally, QGraphicsScene allows you to render parts of the scene into a paint device through the QGraphicsScene::render() function. You can read more about this in the Printing section later in this document.</db:para>
</db:section>
<db:section xml:id="the-view">
<db:title>The View</db:title>
<db:para>QGraphicsView provides the view widget, which visualizes the contents of a scene. You can attach several views to the same scene, to provide several viewports into the same data set. The view widget is a scroll area, and provides scroll bars for navigating through large scenes. To enable OpenGL support, you can set a QGLWidget as the viewport by calling QGraphicsView::setViewport().</db:para>
<db:programlisting language="cpp">QGraphicsScene scene;
myPopulateScene(&amp;amp;scene);

QGraphicsView view(&amp;amp;scene);
view.show();
</db:programlisting>
<db:para>The view receives input events from the keyboard and mouse, and translates these to scene events (converting the coordinates used to scene coordinates where appropriate), before sending the events to the visualized scene.</db:para>
<db:para>Using its transformation matrix, QGraphicsView::transform(), the view can <db:emphasis>transform</db:emphasis> the scene's coordinate system. This allows advanced navigation features such as zooming and rotation. For convenience, QGraphicsView also provides functions for translating between view and scene coordinates: QGraphicsView::mapToScene() and QGraphicsView::mapFromScene().</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/graphicsview-view.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
<db:section xml:id="the-item">
<db:title>The Item</db:title>
<db:para>QGraphicsItem is the base class for graphical items in a scene. Graphics View provides several standard items for typical shapes, such as rectangles (QGraphicsRectItem), ellipses (QGraphicsEllipseItem) and text items (QGraphicsTextItem), but the most powerful QGraphicsItem features are available when you write a custom item. Among other things, QGraphicsItem supports the following features:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Mouse press, move, release and double click events, as well as mouse hover events, wheel events, and context menu events.</db:para>
</db:listitem>
<db:listitem>
<db:para>Keyboard input focus, and key events</db:para>
</db:listitem>
<db:listitem>
<db:para>Drag and drop</db:para>
</db:listitem>
<db:listitem>
<db:para>Grouping, both through parent-child relationships, and with QGraphicsItemGroup</db:para>
</db:listitem>
<db:listitem>
<db:para>Collision detection</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Items live in a local coordinate system, and like QGraphicsView, it also provides many functions for mapping coordinates between the item and the scene, and from item to item. Also, like QGraphicsView, it can transform its coordinate system using a matrix: QGraphicsItem::transform(). This is useful for rotating and scaling individual items.</db:para>
<db:para>Items can contain other items (children). Parent items' transformations are inherited by all its children. Regardless of an item's accumulated transformation, though, all its functions (e.g., QGraphicsItem::contains(), QGraphicsItem::boundingRect(), QGraphicsItem::collidesWith()) still operate in local coordinates.</db:para>
<db:para>QGraphicsItem supports collision detection through the QGraphicsItem::shape() function, and QGraphicsItem::collidesWith(), which are both virtual functions. By returning your item's shape as a local coordinate QPainterPath from QGraphicsItem::shape(), QGraphicsItem will handle all collision detection for you. If you want to provide your own collision detection, however, you can reimplement QGraphicsItem::collidesWith().</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/graphicsview-items.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
</db:section>
<db:section xml:id="classes-in-the-graphics-view-framework">
<db:title>Classes in the Graphics View Framework</db:title>
<db:para>These classes provide a framework for creating interactive applications.</db:para>
</db:section>
<db:section xml:id="the-graphics-view-coordinate-system">
<db:title>The Graphics View Coordinate System</db:title>
<db:para>Graphics View is based on the Cartesian coordinate system; items' position and geometry on the scene are represented by sets of two numbers: the x-coordinate, and the y-coordinate. When observing a scene using an untransformed view, one unit on the scene is represented by one pixel on the screen.</db:para>
<db:note>
<db:para>The inverted Y-axis coordinate system (where <db:code>y</db:code> grows upwards) is unsupported as Graphics Views uses Qt's coordinate system.</db:para>
</db:note>
<db:para>There are three effective coordinate systems in play in Graphics View: Item coordinates, scene coordinates, and view coordinates. To simplify your implementation, Graphics View provides convenience functions that allow you to map between the three coordinate systems.</db:para>
<db:para>When rendering, Graphics View's scene coordinates correspond to QPainter's <db:emphasis>logical</db:emphasis> coordinates, and view coordinates are the same as <db:emphasis>device</db:emphasis> coordinates. In the <db:link xlink:href="coordsys.xml">Coordinate System</db:link> documentation, you can read about the relationship between logical coordinates and device coordinates.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/graphicsview-parentchild.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="item-coordinates">
<db:title>Item Coordinates</db:title>
<db:para>Items live in their own local coordinate system. Their coordinates are usually centered around its center point (0, 0), and this is also the center for all transformations. Geometric primitives in the item coordinate system are often referred to as item points, item lines, or item rectangles.</db:para>
<db:para>When creating a custom item, item coordinates are all you need to worry about; QGraphicsScene and QGraphicsView will perform all transformations for you. This makes it very easy to implement custom items. For example, if you receive a mouse press or a drag enter event, the event position is given in item coordinates. The QGraphicsItem::contains() virtual function, which returns <db:code>true</db:code> if a certain point is inside your item, and false otherwise, takes a point argument in item coordinates. Similarly, an item's bounding rect and shape are in item coordinates.</db:para>
<db:para>At item's <db:emphasis>position</db:emphasis> is the coordinate of the item's center point in its parent's coordinate system; sometimes referred to as <db:emphasis>parent</db:emphasis> coordinates. The scene is in this sense regarded as all parent-less items' &quot;parent&quot;. Top level items' position are in scene coordinates.</db:para>
<db:para>Child coordinates are relative to the parent's coordinates. If the child is untransformed, the difference between a child coordinate and a parent coordinate is the same as the distance between the items in parent coordinates. For example: If an untransformed child item is positioned precisely in its parent's center point, then the two items' coordinate systems will be identical. If the child's position is (10, 0), however, the child's (0, 10) point will correspond to its parent's (10, 10) point.</db:para>
<db:para>Because items' position and transformation are relative to the parent, child items' coordinates are unaffected by the parent's transformation, although the parent's transformation implicitly transforms the child. In the above example, even if the parent is rotated and scaled, the child's (0, 10) point will still correspond to the parent's (10, 10) point. Relative to the scene, however, the child will follow the parent's transformation and position. If the parent is scaled (2x, 2x), the child's position will be at scene coordinate (20, 0), and its (10, 0) point will correspond to the point (40, 0) on the scene.</db:para>
<db:para>With QGraphicsItem::pos() being one of the few exceptions, QGraphicsItem's functions operate in item coordinates, regardless of the item, or any of its parents' transformation. For example, an item's bounding rect (i.e. QGraphicsItem::boundingRect()) is always given in item coordinates.</db:para>
</db:section>
<db:section xml:id="scene-coordinates">
<db:title>Scene Coordinates</db:title>
<db:para>The scene represents the base coordinate system for all its items. The scene coordinate system describes the position of each top-level item, and also forms the basis for all scene events delivered to the scene from the view. Each item on the scene has a scene position and bounding rectangle (QGraphicsItem::scenePos(), QGraphicsItem::sceneBoundingRect()), in addition to its local item pos and bounding rectangle. The scene position describes the item's position in scene coordinates, and its scene bounding rect forms the basis for how QGraphicsScene determines what areas of the scene have changed. Changes in the scene are communicated through the QGraphicsScene::changed() signal, and the argument is a list of scene rectangles.</db:para>
</db:section>
<db:section xml:id="view-coordinates">
<db:title>View Coordinates</db:title>
<db:para>View coordinates are the coordinates of the widget. Each unit in view coordinates corresponds to one pixel. What's special about this coordinate system is that it is relative to the widget, or viewport, and unaffected by the observed scene. The top left corner of QGraphicsView's viewport is always (0, 0), and the bottom right corner is always (viewport width, viewport height). All mouse events and drag and drop events are originally received as view coordinates, and you need to map these coordinates to the scene in order to interact with items.</db:para>
</db:section>
<db:section xml:id="coordinate-mapping">
<db:title>Coordinate Mapping</db:title>
<db:para>Often when dealing with items in a scene, it can be useful to map coordinates and arbitrary shapes from the scene to an item, from item to item, or from the view to the scene. For example, when you click your mouse in QGraphicsView's viewport, you can ask the scene what item is under the cursor by calling QGraphicsView::mapToScene(), followed by QGraphicsScene::itemAt(). If you want to know where in the viewport an item is located, you can call QGraphicsItem::mapToScene() on the item, then QGraphicsView::mapFromScene() on the view. Finally, if you use want to find what items are inside a view ellipse, you can pass a QPainterPath to mapToScene(), and then pass the mapped path to QGraphicsScene::items().</db:para>
<db:para>You can map coordinates and shapes to and from an item's scene by calling QGraphicsItem::mapToScene() and QGraphicsItem::mapFromScene(). You can also map to an item's parent item by calling QGraphicsItem::mapToParent() and QGraphicsItem::mapFromParent(), or between items by calling QGraphicsItem::mapToItem() and QGraphicsItem::mapFromItem(). All mapping functions can map both points, rectangles, polygons and paths.</db:para>
<db:para>The same mapping functions are available in the view, for mapping to and from the scene. QGraphicsView::mapFromScene() and QGraphicsView::mapToScene(). To map from a view to an item, you first map to the scene, and then map from the scene to the item.</db:para>
</db:section>
</db:section>
<db:section xml:id="key-features">
<db:title>Key Features</db:title>
<db:section xml:id="zooming-and-rotating">
<db:title>Zooming and rotating</db:title>
<db:para>QGraphicsView supports the same affine transformations as QPainter does through QGraphicsView::setMatrix(). By applying a transformation to the view, you can easily add support for common navigation features such as zooming and rotating.</db:para>
<db:para>Here is an example of how to implement zoom and rotate slots in a subclass of QGraphicsView:</db:para>
<db:programlisting language="cpp">class View : public QGraphicsView
{
Q_OBJECT
    ...
public slots:
    void zoomIn() { scale(1.2, 1.2); }
    void zoomOut() { scale(1 / 1.2, 1 / 1.2); }
    void rotateLeft() { rotate(-10); }
    void rotateRight() { rotate(10); }
    ...
};
</db:programlisting>
<db:para>The slots could be connected to QToolButtons with autoRepeat enabled.</db:para>
<db:para>QGraphicsView keeps the center of the view aligned when you transform the view.</db:para>
<db:para>See also the <db:link xlink:href="qtwidgets-graphicsview-elasticnodes-example.xml">Elastic Nodes</db:link> example for code that shows how to implement basic zooming features.</db:para>
</db:section>
<db:section xml:id="printing">
<db:title>Printing</db:title>
<db:para>Graphics View provides single-line printing through its rendering functions, QGraphicsScene::render() and QGraphicsView::render(). The functions provide the same API: You can have the scene or the view render all or parts of their contents into any paint device by passing a QPainter to either of the rendering functions. This example shows how to print the whole scene into a full page, using QPrinter.</db:para>
<db:programlisting language="cpp">QGraphicsScene scene;
scene.addRect(QRectF(0, 0, 100, 200), QPen(Qt::black), QBrush(Qt::green));

QPrinter printer;
if (QPrintDialog(&amp;amp;printer).exec() == QDialog::Accepted) {
    QPainter painter(&amp;amp;printer);
    painter.setRenderHint(QPainter::Antialiasing);
    scene.render(&amp;amp;painter);
}
</db:programlisting>
<db:para>The difference between the scene and view rendering functions is that one operates in scene coordinates, and the other in view coordinates. QGraphicsScene::render() is often preferred for printing whole segments of a scene untransformed, such as for plotting geometrical data, or for printing a text document. QGraphicsView::render(), on the other hand, is suitable for taking screenshots; its default behavior is to render the exact contents of the viewport using the provided painter.</db:para>
<db:programlisting language="cpp">QGraphicsScene scene;
scene.addRect(QRectF(0, 0, 100, 200), QPen(Qt::black), QBrush(Qt::green));

QPixmap pixmap;
QPainter painter(&amp;amp;pixmap);
painter.setRenderHint(QPainter::Antialiasing);
scene.render(&amp;amp;painter);
painter.end();

pixmap.save(&quot;scene.png&quot;);
</db:programlisting>
<db:para>When the source and target areas' sizes do not match, the source contents are stretched to fit into the target area. By passing a Qt::AspectRatioMode to the rendering function you are using, you can choose to maintain or ignore the aspect ratio of the scene when the contents are stretched.</db:para>
</db:section>
<db:section xml:id="drag-and-drop">
<db:title>Drag and Drop</db:title>
<db:para>Because QGraphicsView inherits QWidget indirectly, it already provides the same drag and drop functionality that QWidget provides. In addition, as a convenience, the Graphics View framework provides drag and drop support for the scene, and for each and every item. As the view receives a drag, it translates the drag and drop events into a QGraphicsSceneDragDropEvent, which is then forwarded to the scene. The scene takes over scheduling of this event, and sends it to the first item under the mouse cursor that accepts drops.</db:para>
<db:para>To start a drag from an item, create a QDrag object, passing a pointer to the widget that starts the drag. Items can be observed by many views at the same time, but only one view can start the drag. Drags are in most cases started as a result of pressing or moving the mouse, so in mousePressEvent() or mouseMoveEvent(), you can get the originating widget pointer from the event. For example:</db:para>
<db:programlisting language="cpp">void CustomItem::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    QMimeData *data = new QMimeData;
    data-&amp;gt;setColor(Qt::green);

    QDrag *drag = new QDrag(event-&amp;gt;widget());
    drag-&amp;gt;setMimeData(data);
    drag-&amp;gt;start();
}
</db:programlisting>
<db:para>To intercept drag and drop events for the scene, you reimplement QGraphicsScene::dragEnterEvent() and whichever event handlers your particular scene needs, in a QGraphicsItem subclass. You can read more about drag and drop in Graphics View in the documentation for each of QGraphicsScene's event handlers.</db:para>
<db:para>Items can enable drag and drop support by calling QGraphicsItem::setAcceptDrops(). To handle the incoming drag, reimplement QGraphicsItem::dragEnterEvent(), QGraphicsItem::dragMoveEvent(), QGraphicsItem::dragLeaveEvent(), and QGraphicsItem::dropEvent().</db:para>
<db:para>See also the <db:link xlink:href="qtwidgets-graphicsview-dragdroprobot-example.xml">Drag and Drop Robot</db:link> example for a demonstration of Graphics View's support for drag and drop operations.</db:para>
</db:section>
<db:section xml:id="cursors-and-tooltips">
<db:title>Cursors and Tooltips</db:title>
<db:para>Like QWidget, QGraphicsItem also supports cursors (QGraphicsItem::setCursor()), and tooltips (QGraphicsItem::setToolTip()). The cursors and tooltips are activated by QGraphicsView as the mouse cursor enters the item's area (detected by calling QGraphicsItem::contains()).</db:para>
<db:para>You can also set a default cursor directly on the view by calling QGraphicsView::setCursor().</db:para>
<db:para>See also the <db:link xlink:href="qtwidgets-graphicsview-dragdroprobot-example.xml">Drag and Drop Robot</db:link> example for code that implements tooltips and cursor shape handling.</db:para>
</db:section>
<db:section xml:id="animation">
<db:title>Animation</db:title>
<db:para>Graphics View supports animation at several levels. You can easily assemble animation by using the Animation Framework. For that you'll need your items to inherit from QGraphicsObject and associate QPropertyAnimation with them. QPropertyAnimation allows to animate any QObject property.</db:para>
<db:para>Another option is to create a custom item that inherits from QObject and QGraphicsItem. The item can the set up its own timers, and control animations with incremental steps in QObject::timerEvent().</db:para>
<db:para>A third option, which is mostly available for compatibility with QCanvas in Qt 3, is to <db:emphasis>advance</db:emphasis> the scene by calling QGraphicsScene::advance(), which in turn calls QGraphicsItem::advance().</db:para>
</db:section>
<db:section xml:id="opengl-rendering">
<db:title>OpenGL Rendering</db:title>
<db:para>To enable OpenGL rendering, you simply set a new QGLWidget as the viewport of QGraphicsView by calling QGraphicsView::setViewport(). If you want OpenGL with antialiasing, you need OpenGL sample buffer support (see QGLFormat::sampleBuffers()).</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QGraphicsView view(&amp;amp;scene);
view.setViewport(new QGLWidget(QGLFormat(QGL::SampleBuffers)));
</db:programlisting>
</db:section>
<db:section xml:id="item-groups">
<db:title>Item Groups</db:title>
<db:para>By making an item a child of another, you can achieve the most essential feature of item grouping: the items will move together, and all transformations are propagated from parent to child.</db:para>
<db:para>In addition, QGraphicsItemGroup is a special item that combines child event handling with a useful interface for adding and removing items to and from a group. Adding an item to a QGraphicsItemGroup will keep the item's original position and transformation, whereas reparenting items in general will cause the child to reposition itself relative to its new parent. For convenience, you can create QGraphicsItemGroups through the scene by calling QGraphicsScene::createItemGroup().</db:para>
</db:section>
<db:section xml:id="widgets-and-layouts">
<db:title>Widgets and Layouts</db:title>
<db:para>Qt 4.4 introduced support for geometry and layout-aware items through QGraphicsWidget. This special base item is similar to QWidget, but unlike QWidget, it doesn't inherit from QPaintDevice; rather from QGraphicsItem instead. This allows you to write complete widgets with events, signals &amp; slots, size hints and policies, and you can also manage your widgets geometries in layouts through QGraphicsLinearLayout and QGraphicsGridLayout.</db:para>
<db:section xml:id="qgraphicswidget">
<db:title>QGraphicsWidget</db:title>
<db:para>Building on top of QGraphicsItem's capabilities and lean footprint, QGraphicsWidget provides the best of both worlds: extra functionality from QWidget, such as the style, font, palette, layout direction, and its geometry, and resolution independence and transformation support from QGraphicsItem. Because Graphics View uses real coordinates instead of integers, QGraphicsWidget's geometry functions also operate on <db:link xlink:href="qrectf.xml">QRectF</db:link> and QPointF. This also applies to frame rects, margins and spacing. With QGraphicsWidget it's not uncommon to specify contents margins of (0.5, 0.5, 0.5, 0.5), for example. You can create both subwidgets and &quot;top-level&quot; windows; in some cases you can now use Graphics View for advanced MDI applications.</db:para>
<db:para>Some of QWidget's properties are supported, including window flags and attributes, but not all. You should refer to QGraphicsWidget's class documentation for a complete overview of what is and what is not supported. For example, you can create decorated windows by passing the Qt::Window window flag to QGraphicsWidget's constructor, but Graphics View currently doesn't support the Qt::Sheet and Qt::Drawer flags that are common on macOS.</db:para>
</db:section>
<db:section xml:id="qgraphicslayout">
<db:title>QGraphicsLayout</db:title>
<db:para>QGraphicsLayout is part of a second-generation layout framework designed specifically for QGraphicsWidget. Its API is very similar to that of QLayout. You can manage widgets and sublayouts inside either QGraphicsLinearLayout and QGraphicsGridLayout. You can also easily write your own layout by subclassing QGraphicsLayout yourself, or add your own QGraphicsItem items to the layout by writing an adaptor subclass of QGraphicsLayoutItem.</db:para>
</db:section>
</db:section>
<db:section xml:id="embedded-widget-support">
<db:title>Embedded Widget Support</db:title>
<db:para>Graphics View provides seamless support for embedding any widget into the scene. You can embed simple widgets, such as QLineEdit or QPushButton, complex widgets such as QTabWidget, and even complete main windows. To embed your widget to the scene, simply call QGraphicsScene::addWidget(), or create an instance of QGraphicsProxyWidget to embed your widget manually.</db:para>
<db:para>Through QGraphicsProxyWidget, Graphics View is able to deeply integrate the client widget features including its cursors, tooltips, mouse, tablet and keyboard events, child widgets, animations, pop-ups (e.g., QComboBox or QCompleter), and the widget's input focus and activation. QGraphicsProxyWidget even integrates the embedded widget's tab order so that you can tab in and out of embedded widgets. You can even embed a new QGraphicsView into your scene to provide complex nested scenes.</db:para>
<db:para>When transforming an embedded widget, Graphics View makes sure that the widget is transformed resolution independently, allowing the fonts and style to stay crisp when zoomed in. (Note that the effect of resolution independence depends on the style.)</db:para>
</db:section>
</db:section>
<db:section xml:id="performance">
<db:title>Performance</db:title>
<db:section xml:id="floating-point-instructions">
<db:title>Floating Point Instructions</db:title>
<db:para>In order to accurately and quickly apply transformations and effects to items, Graphics View is built with the assumption that the user's hardware is able to provide reasonable performance for floating point instructions.</db:para>
<db:para>Many workstations and desktop computers are equipped with suitable hardware to accelerate this kind of computation, but some embedded devices may only provide libraries to handle mathematical operations or emulate floating point instructions in software.</db:para>
<db:para>As a result, certain kinds of effects may be slower than expected on certain devices. It may be possible to compensate for this performance hit by making optimizations in other areas; for example, by using <db:link xlink:href="graphicsview.xml#opengl-rendering">OpenGL</db:link> to render a scene. However, any such optimizations may themselves cause a reduction in performance if they also rely on the presence of floating point hardware.</db:para>
</db:section>
</db:section>
</db:article>
