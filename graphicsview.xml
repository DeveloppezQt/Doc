<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Graphics View Framework</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>An overview of the Graphics View framework for interactive 2D graphics.</db:para>
<db:para>This documentation was introduced in Qt 4.2.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Graphics View provides a surface for managing and interacting with a large number of custom-made 2D graphical items, and a view widget for visualizing the items, with support for zooming and rotation.</db:para>
<db:para>The framework includes an event propagation architecture that allows precise double-precision interaction capabilities for the items on the scene. Items can handle key events, mouse press, move, release and double click events, and they can also track mouse movement.</db:para>
<db:para>Graphics View uses a BSP (Binary Space Partitioning) tree to provide very fast item discovery, and as a result of this, it can visualize large scenes in real-time, even with millions of items.</db:para>
<db:para>Graphics View was introduced in Qt 4.2, replacing its predecessor, QCanvas.</db:para>
<db:para>Topics:</db:para>
<db:section xml:id="the-graphics-view-architecture">
<db:title>The Graphics View Architecture</db:title>
<db:para>Graphics View provides an item-based approach to model-view programming, much like InterView's convenience classes <db:link xlink:href="qtableview.xml">QTableView</db:link>, <db:link xlink:href="qtreeview.xml">QTreeView</db:link> and <db:link xlink:href="qlistview.xml">QListView</db:link>. Several views can observe a single scene, and the scene contains items of varying geometric shapes.</db:para>
<db:section xml:id="the-scene">
<db:title>The Scene</db:title>
<db:para><db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> provides the Graphics View scene. The scene has the following responsibilities:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Providing a fast interface for managing a large number of items</db:para>
</db:listitem>
<db:listitem>
<db:para>Propagating events to each item</db:para>
</db:listitem>
<db:listitem>
<db:para>Managing item state, such as selection and focus handling</db:para>
</db:listitem>
<db:listitem>
<db:para>Providing untransformed rendering functionality; mainly for printing</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The scene serves as a container for <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link> objects. Items are added to the scene by calling <db:link xlink:href="qgraphicsscene.xml#addItem">QGraphicsScene::addItem</db:link>(), and then retrieved by calling one of the many item discovery functions. <db:link xlink:href="qgraphicsscene.xml#items">QGraphicsScene::items</db:link>() and its overloads return all items contained by or intersecting with a point, a rectangle, a polygon or a general vector path. <db:link xlink:href="qgraphicsscene.xml#itemAt">QGraphicsScene::itemAt</db:link>() returns the topmost item at a particular point. All item discovery functions return the items in descending stacking order (i.e., the first returned item is topmost, and the last item is bottom-most).</db:para>
<db:programlisting language="cpp">QGraphicsScene scene;
QGraphicsRectItem *rect = scene.addRect(QRectF(0, 0, 100, 100));

QGraphicsItem *item = scene.itemAt(50, 50);
// item == rect
</db:programlisting>
<db:para><db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link>'s event propagation architecture schedules scene events for delivery to items, and also manages propagation between items. If the scene receives a mouse press event at a certain position, the scene passes the event on to whichever item is at that position.</db:para>
<db:para><db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> also manages certain item states, such as item selection and focus. You can select items on the scene by calling <db:link xlink:href="qgraphicsscene.xml#setSelectionArea">QGraphicsScene::setSelectionArea</db:link>(), passing an arbitrary shape. This functionality is also used as a basis for rubberband selection in <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link>. To get the list of all currently selected items, call <db:link xlink:href="qgraphicsscene.xml#selectedItems">QGraphicsScene::selectedItems</db:link>(). Another state handled by <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> is whether or not an item has keyboard input focus. You can set focus on an item by calling <db:link xlink:href="qgraphicsscene.xml#setFocusItem">QGraphicsScene::setFocusItem</db:link>() or <db:link xlink:href="qgraphicsitem.xml#setFocus">QGraphicsItem::setFocus</db:link>(), or get the current focus item by calling <db:link xlink:href="qgraphicsscene.xml#focusItem">QGraphicsScene::focusItem</db:link>().</db:para>
<db:para>Finally, <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> allows you to render parts of the scene into a paint device through the <db:link xlink:href="qgraphicsscene.xml#render">QGraphicsScene::render</db:link>() function. You can read more about this in the Printing section later in this document.</db:para>
</db:section>
<db:section xml:id="the-view">
<db:title>The View</db:title>
<db:para><db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link> provides the view widget, which visualizes the contents of a scene. You can attach several views to the same scene, to provide several viewports into the same data set. The view widget is a scroll area, and provides scroll bars for navigating through large scenes. To enable OpenGL support, you can set a QGLWidget as the viewport by calling <db:link xlink:href="qabstractscrollarea.xml#setViewport">QGraphicsView::setViewport</db:link>().</db:para>
<db:programlisting language="cpp">QGraphicsScene scene;
myPopulateScene(&amp;scene);

QGraphicsView view(&amp;scene);
view.show();
</db:programlisting>
<db:para>The view receives input events from the keyboard and mouse, and translates these to scene events (converting the coordinates used to scene coordinates where appropriate), before sending the events to the visualized scene.</db:para>
<db:para>Using its transformation matrix, <db:link xlink:href="qgraphicsview.xml#transform">QGraphicsView::transform</db:link>(), the view can <db:emphasis>transform</db:emphasis> the scene's coordinate system. This allows advanced navigation features such as zooming and rotation. For convenience, <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link> also provides functions for translating between view and scene coordinates: <db:link xlink:href="qgraphicsview.xml#mapToScene">QGraphicsView::mapToScene</db:link>() and <db:link xlink:href="qgraphicsview.xml#mapFromScene">QGraphicsView::mapFromScene</db:link>().</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/graphicsview-view.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
<db:section xml:id="the-item">
<db:title>The Item</db:title>
<db:para><db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link> is the base class for graphical items in a scene. Graphics View provides several standard items for typical shapes, such as rectangles (<db:link xlink:href="qgraphicsrectitem.xml">QGraphicsRectItem</db:link>), ellipses (<db:link xlink:href="qgraphicsellipseitem.xml">QGraphicsEllipseItem</db:link>) and text items (<db:link xlink:href="qgraphicstextitem.xml">QGraphicsTextItem</db:link>), but the most powerful <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link> features are available when you write a custom item. Among other things, <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link> supports the following features:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Mouse press, move, release and double click events, as well as mouse hover events, wheel events, and context menu events.</db:para>
</db:listitem>
<db:listitem>
<db:para>Keyboard input focus, and key events</db:para>
</db:listitem>
<db:listitem>
<db:para>Drag and drop</db:para>
</db:listitem>
<db:listitem>
<db:para>Grouping, both through parent-child relationships, and with <db:link xlink:href="qgraphicsitemgroup.xml">QGraphicsItemGroup</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>Collision detection</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Items live in a local coordinate system, and like <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link>, it also provides many functions for mapping coordinates between the item and the scene, and from item to item. Also, like <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link>, it can transform its coordinate system using a matrix: <db:link xlink:href="qgraphicsitem.xml#transform">QGraphicsItem::transform</db:link>(). This is useful for rotating and scaling individual items.</db:para>
<db:para>Items can contain other items (children). Parent items' transformations are inherited by all its children. Regardless of an item's accumulated transformation, though, all its functions (e.g., <db:link xlink:href="qgraphicsitem.xml#contains">QGraphicsItem::contains</db:link>(), <db:link xlink:href="qgraphicsitem.xml#boundingRect">QGraphicsItem::boundingRect</db:link>(), QGraphicsItem::collidesWith()) still operate in local coordinates.</db:para>
<db:para><db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link> supports collision detection through the <db:link xlink:href="qgraphicsitem.xml#shape">QGraphicsItem::shape</db:link>() function, and QGraphicsItem::collidesWith(), which are both virtual functions. By returning your item's shape as a local coordinate <db:link xlink:href="qpainterpath.xml">QPainterPath</db:link> from <db:link xlink:href="qgraphicsitem.xml#shape">QGraphicsItem::shape</db:link>(), <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link> will handle all collision detection for you. If you want to provide your own collision detection, however, you can reimplement QGraphicsItem::collidesWith().</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/graphicsview-items.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
</db:section>
<db:section xml:id="classes-in-the-graphics-view-framework">
<db:title>Classes in the Graphics View Framework</db:title>
<db:para>These classes provide a framework for creating interactive applications.</db:para>
<db:variablelist role="graphicsview-api">
<db:varlistentry>
<db:term><db:link xlink:href="qabstractgraphicsshapeitem.xml" xlink:role="class">QAbstractGraphicsShapeItem</db:link></db:term>
<db:listitem>
<db:para>The QAbstractGraphicsShapeItem class provides a common base for all path items.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsanchor.xml" xlink:role="class">QGraphicsAnchor</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsAnchor class represents an anchor between two items in a QGraphicsAnchorLayout.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsanchorlayout.xml" xlink:role="class">QGraphicsAnchorLayout</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsAnchorLayout class provides a layout where one can anchor widgets together in Graphics View.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicseffect.xml" xlink:role="class">QGraphicsEffect</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsEffect class is the base class for all graphics effects.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsellipseitem.xml" xlink:role="class">QGraphicsEllipseItem</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsEllipseItem class provides an ellipse item that you can add to a QGraphicsScene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsgridlayout.xml" xlink:role="class">QGraphicsGridLayout</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsGridLayout class provides a grid layout for managing widgets in Graphics View.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsitem.xml" xlink:role="class">QGraphicsItem</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsItem class is the base class for all graphical items in a QGraphicsScene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsitemgroup.xml" xlink:role="class">QGraphicsItemGroup</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsItemGroup class provides a container that treats a group of items as a single item.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicslayout.xml" xlink:role="class">QGraphicsLayout</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsLayout class provides the base class for all layouts in Graphics View.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicslayoutitem.xml" xlink:role="class">QGraphicsLayoutItem</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsLayoutItem class can be inherited to allow your custom items to be managed by layouts.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicslineitem.xml" xlink:role="class">QGraphicsLineItem</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsLineItem class provides a line item that you can add to a QGraphicsScene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicslinearlayout.xml" xlink:role="class">QGraphicsLinearLayout</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsLinearLayout class provides a horizontal or vertical layout for managing widgets in Graphics View.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsobject.xml" xlink:role="class">QGraphicsObject</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsObject class provides a base class for all graphics items that require signals, slots and properties.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicspathitem.xml" xlink:role="class">QGraphicsPathItem</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsPathItem class provides a path item that you can add to a QGraphicsScene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicspixmapitem.xml" xlink:role="class">QGraphicsPixmapItem</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsPixmapItem class provides a pixmap item that you can add to a QGraphicsScene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicspolygonitem.xml" xlink:role="class">QGraphicsPolygonItem</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsPolygonItem class provides a polygon item that you can add to a QGraphicsScene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsproxywidget.xml" xlink:role="class">QGraphicsProxyWidget</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsProxyWidget class provides a proxy layer for embedding a QWidget in a QGraphicsScene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsrectitem.xml" xlink:role="class">QGraphicsRectItem</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsRectItem class provides a rectangle item that you can add to a QGraphicsScene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsscene.xml" xlink:role="class">QGraphicsScene</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsScene class provides a surface for managing a large number of 2D graphical items.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsscenecontextmenuevent.xml" xlink:role="class">QGraphicsSceneContextMenuEvent</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsSceneContextMenuEvent class provides context menu events in the graphics view framework.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsscenedragdropevent.xml" xlink:role="class">QGraphicsSceneDragDropEvent</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsSceneDragDropEvent class provides events for drag and drop in the graphics view framework.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicssceneevent.xml" xlink:role="class">QGraphicsSceneEvent</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsSceneEvent class provides a base class for all graphics view related events.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsscenehelpevent.xml" xlink:role="class">QGraphicsSceneHelpEvent</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsSceneHelpEvent class provides events when a tooltip is requested.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsscenehoverevent.xml" xlink:role="class">QGraphicsSceneHoverEvent</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsSceneHoverEvent class provides hover events in the graphics view framework.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsscenemouseevent.xml" xlink:role="class">QGraphicsSceneMouseEvent</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsSceneMouseEvent class provides mouse events in the graphics view framework.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsscenemoveevent.xml" xlink:role="class">QGraphicsSceneMoveEvent</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsSceneMoveEvent class provides events for widget moving in the graphics view framework.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicssceneresizeevent.xml" xlink:role="class">QGraphicsSceneResizeEvent</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsSceneResizeEvent class provides events for widget resizing in the graphics view framework.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsscenewheelevent.xml" xlink:role="class">QGraphicsSceneWheelEvent</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsSceneWheelEvent class provides wheel events in the graphics view framework.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicssimpletextitem.xml" xlink:role="class">QGraphicsSimpleTextItem</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsSimpleTextItem class provides a simple text path item that you can add to a QGraphicsScene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicstextitem.xml" xlink:role="class">QGraphicsTextItem</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsTextItem class provides a text item that you can add to a QGraphicsScene to display formatted text.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicstransform.xml" xlink:role="class">QGraphicsTransform</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsTransform class is an abstract base class for building advanced transformations on QGraphicsItems.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicsview.xml" xlink:role="class">QGraphicsView</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsView class provides a widget for displaying the contents of a QGraphicsScene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qgraphicswidget.xml" xlink:role="class">QGraphicsWidget</db:link></db:term>
<db:listitem>
<db:para>The QGraphicsWidget class is the base class for all widget items in a QGraphicsScene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qstyleoptiongraphicsitem.xml" xlink:role="class">QStyleOptionGraphicsItem</db:link></db:term>
<db:listitem>
<db:para>The QStyleOptionGraphicsItem class is used to describe the parameters needed to draw a QGraphicsItem.</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
</db:section>
<db:section xml:id="the-graphics-view-coordinate-system">
<db:title>The Graphics View Coordinate System</db:title>
<db:para>Graphics View is based on the Cartesian coordinate system; items' position and geometry on the scene are represented by sets of two numbers: the x-coordinate, and the y-coordinate. When observing a scene using an untransformed view, one unit on the scene is represented by one pixel on the screen.</db:para>
<db:note>
<db:para>The inverted Y-axis coordinate system (where y grows upwards) is unsupported as Graphics Views uses Qt's coordinate system.</db:para>
</db:note>
<db:para>There are three effective coordinate systems in play in Graphics View: Item coordinates, scene coordinates, and view coordinates. To simplify your implementation, Graphics View provides convenience functions that allow you to map between the three coordinate systems.</db:para>
<db:para>When rendering, Graphics View's scene coordinates correspond to <db:link xlink:href="qpainter.xml">QPainter</db:link>'s <db:emphasis>logical</db:emphasis> coordinates, and view coordinates are the same as <db:emphasis>device</db:emphasis> coordinates. In the <db:link xlink:href="coordsys.xml">Coordinate System</db:link> documentation, you can read about the relationship between logical coordinates and device coordinates.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/graphicsview-parentchild.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="item-coordinates">
<db:title>Item Coordinates</db:title>
<db:para>Items live in their own local coordinate system. Their coordinates are usually centered around its center point (0, 0), and this is also the center for all transformations. Geometric primitives in the item coordinate system are often referred to as item points, item lines, or item rectangles.</db:para>
<db:para>When creating a custom item, item coordinates are all you need to worry about; <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> and <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link> will perform all transformations for you. This makes it very easy to implement custom items. For example, if you receive a mouse press or a drag enter event, the event position is given in item coordinates. The <db:link xlink:href="qgraphicsitem.xml#contains">QGraphicsItem::contains</db:link>() virtual function, which returns true if a certain point is inside your item, and false otherwise, takes a point argument in item coordinates. Similarly, an item's bounding rect and shape are in item coordinates.</db:para>
<db:para>At item's <db:emphasis>position</db:emphasis> is the coordinate of the item's center point in its parent's coordinate system; sometimes referred to as <db:emphasis>parent</db:emphasis> coordinates. The scene is in this sense regarded as all parent-less items' &quot;parent&quot;. Top level items' position are in scene coordinates.</db:para>
<db:para>Child coordinates are relative to the parent's coordinates. If the child is untransformed, the difference between a child coordinate and a parent coordinate is the same as the distance between the items in parent coordinates. For example: If an untransformed child item is positioned precisely in its parent's center point, then the two items' coordinate systems will be identical. If the child's position is (10, 0), however, the child's (0, 10) point will correspond to its parent's (10, 10) point.</db:para>
<db:para>Because items' position and transformation are relative to the parent, child items' coordinates are unaffected by the parent's transformation, although the parent's transformation implicitly transforms the child. In the above example, even if the parent is rotated and scaled, the child's (0, 10) point will still correspond to the parent's (10, 10) point. Relative to the scene, however, the child will follow the parent's transformation and position. If the parent is scaled (2x, 2x), the child's position will be at scene coordinate (20, 0), and its (10, 0) point will correspond to the point (40, 0) on the scene.</db:para>
<db:para>With <db:link xlink:href="qgraphicsitem.xml#pos">QGraphicsItem::pos</db:link>() being one of the few exceptions, <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link>'s functions operate in item coordinates, regardless of the item, or any of its parents' transformation. For example, an item's bounding rect (i.e. <db:link xlink:href="qgraphicsitem.xml#boundingRect">QGraphicsItem::boundingRect</db:link>()) is always given in item coordinates.</db:para>
</db:section>
<db:section xml:id="scene-coordinates">
<db:title>Scene Coordinates</db:title>
<db:para>The scene represents the base coordinate system for all its items. The scene coordinate system describes the position of each top-level item, and also forms the basis for all scene events delivered to the scene from the view. Each item on the scene has a scene position and bounding rectangle (<db:link xlink:href="qgraphicsitem.xml#scenePos">QGraphicsItem::scenePos</db:link>(), <db:link xlink:href="qgraphicsitem.xml#sceneBoundingRect">QGraphicsItem::sceneBoundingRect</db:link>()), in addition to its local item pos and bounding rectangle. The scene position describes the item's position in scene coordinates, and its scene bounding rect forms the basis for how <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> determines what areas of the scene have changed. Changes in the scene are communicated through the <db:link xlink:href="qgraphicsscene.xml#changed">QGraphicsScene::changed</db:link>() signal, and the argument is a list of scene rectangles.</db:para>
</db:section>
<db:section xml:id="view-coordinates">
<db:title>View Coordinates</db:title>
<db:para>View coordinates are the coordinates of the widget. Each unit in view coordinates corresponds to one pixel. What's special about this coordinate system is that it is relative to the widget, or viewport, and unaffected by the observed scene. The top left corner of <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link>'s viewport is always (0, 0), and the bottom right corner is always (viewport width, viewport height). All mouse events and drag and drop events are originally received as view coordinates, and you need to map these coordinates to the scene in order to interact with items.</db:para>
</db:section>
<db:section xml:id="coordinate-mapping">
<db:title>Coordinate Mapping</db:title>
<db:para>Often when dealing with items in a scene, it can be useful to map coordinates and arbitrary shapes from the scene to an item, from item to item, or from the view to the scene. For example, when you click your mouse in <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link>'s viewport, you can ask the scene what item is under the cursor by calling <db:link xlink:href="qgraphicsview.xml#mapToScene">QGraphicsView::mapToScene</db:link>(), followed by <db:link xlink:href="qgraphicsscene.xml#itemAt">QGraphicsScene::itemAt</db:link>(). If you want to know where in the viewport an item is located, you can call <db:link xlink:href="qgraphicsitem.xml#mapToScene">QGraphicsItem::mapToScene</db:link>() on the item, then <db:link xlink:href="qgraphicsview.xml#mapFromScene">QGraphicsView::mapFromScene</db:link>() on the view. Finally, if you use want to find what items are inside a view ellipse, you can pass a <db:link xlink:href="qpainterpath.xml">QPainterPath</db:link> to mapToScene(), and then pass the mapped path to <db:link xlink:href="qgraphicsscene.xml#items">QGraphicsScene::items</db:link>().</db:para>
<db:para>You can map coordinates and shapes to and from an item's scene by calling <db:link xlink:href="qgraphicsitem.xml#mapToScene">QGraphicsItem::mapToScene</db:link>() and <db:link xlink:href="qgraphicsitem.xml#mapFromScene">QGraphicsItem::mapFromScene</db:link>(). You can also map to an item's parent item by calling <db:link xlink:href="qgraphicsitem.xml#mapToParent">QGraphicsItem::mapToParent</db:link>() and <db:link xlink:href="qgraphicsitem.xml#mapFromParent">QGraphicsItem::mapFromParent</db:link>(), or between items by calling <db:link xlink:href="qgraphicsitem.xml#mapToItem">QGraphicsItem::mapToItem</db:link>() and <db:link xlink:href="qgraphicsitem.xml#mapFromItem">QGraphicsItem::mapFromItem</db:link>(). All mapping functions can map both points, rectangles, polygons and paths.</db:para>
<db:para>The same mapping functions are available in the view, for mapping to and from the scene. <db:link xlink:href="qgraphicsview.xml#mapFromScene">QGraphicsView::mapFromScene</db:link>() and <db:link xlink:href="qgraphicsview.xml#mapToScene">QGraphicsView::mapToScene</db:link>(). To map from a view to an item, you first map to the scene, and then map from the scene to the item.</db:para>
</db:section>
</db:section>
<db:section xml:id="key-features">
<db:title>Key Features</db:title>
<db:section xml:id="zooming-and-rotating">
<db:title>Zooming and rotating</db:title>
<db:para><db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link> supports the same affine transformations as <db:link xlink:href="qpainter.xml">QPainter</db:link> does through <db:link xlink:href="qgraphicsview.xml#setMatrix">QGraphicsView::setMatrix</db:link>(). By applying a transformation to the view, you can easily add support for common navigation features such as zooming and rotating.</db:para>
<db:para>Here is an example of how to implement zoom and rotate slots in a subclass of <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link>:</db:para>
<db:programlisting language="cpp">class View : public QGraphicsView
{
Q_OBJECT
    ...
public slots:
    void zoomIn() { scale(1.2, 1.2); }
    void zoomOut() { scale(1 / 1.2, 1 / 1.2); }
    void rotateLeft() { rotate(-10); }
    void rotateRight() { rotate(10); }
    ...
};
</db:programlisting>
<db:para>The slots could be connected to <db:link xlink:href="qtoolbutton.xml">QToolButtons</db:link> with <db:link xlink:href="qabstractbutton.xml#autoRepeat-prop">autoRepeat</db:link> enabled.</db:para>
<db:para><db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link> keeps the center of the view aligned when you transform the view.</db:para>
<db:para>See also the <db:link xlink:href="qtwidgets-graphicsview-elasticnodes-example.xml">Elastic Nodes</db:link> example for code that shows how to implement basic zooming features.</db:para>
</db:section>
<db:section xml:id="printing">
<db:title>Printing</db:title>
<db:para>Graphics View provides single-line printing through its rendering functions, <db:link xlink:href="qgraphicsscene.xml#render">QGraphicsScene::render</db:link>() and <db:link xlink:href="qgraphicsview.xml#render">QGraphicsView::render</db:link>(). The functions provide the same API: You can have the scene or the view render all or parts of their contents into any paint device by passing a <db:link xlink:href="qpainter.xml">QPainter</db:link> to either of the rendering functions. This example shows how to print the whole scene into a full page, using <db:link xlink:href="qprinter.xml">QPrinter</db:link>.</db:para>
<db:programlisting language="cpp">QGraphicsScene scene;
scene.addRect(QRectF(0, 0, 100, 200), QPen(Qt::black), QBrush(Qt::green));

QPrinter printer;
if (QPrintDialog(&amp;printer).exec() == QDialog::Accepted) {
    QPainter painter(&amp;printer);
    painter.setRenderHint(QPainter::Antialiasing);
    scene.render(&amp;painter);
}
</db:programlisting>
<db:para>The difference between the scene and view rendering functions is that one operates in scene coordinates, and the other in view coordinates. <db:link xlink:href="qgraphicsscene.xml#render">QGraphicsScene::render</db:link>() is often preferred for printing whole segments of a scene untransformed, such as for plotting geometrical data, or for printing a text document. <db:link xlink:href="qgraphicsview.xml#render">QGraphicsView::render</db:link>(), on the other hand, is suitable for taking screenshots; its default behavior is to render the exact contents of the viewport using the provided painter.</db:para>
<db:programlisting language="cpp">QGraphicsScene scene;
scene.addRect(QRectF(0, 0, 100, 200), QPen(Qt::black), QBrush(Qt::green));

QPixmap pixmap;
QPainter painter(&amp;pixmap);
painter.setRenderHint(QPainter::Antialiasing);
scene.render(&amp;painter);
painter.end();

pixmap.save(&quot;scene.png&quot;);
</db:programlisting>
<db:para>When the source and target areas' sizes do not match, the source contents are stretched to fit into the target area. By passing a <db:link xlink:href="qt.xml#AspectRatioMode-enum">Qt::AspectRatioMode</db:link> to the rendering function you are using, you can choose to maintain or ignore the aspect ratio of the scene when the contents are stretched.</db:para>
</db:section>
<db:section xml:id="drag-and-drop">
<db:title>Drag and Drop</db:title>
<db:para>Because <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link> inherits <db:link xlink:href="qwidget.xml">QWidget</db:link> indirectly, it already provides the same drag and drop functionality that <db:link xlink:href="qwidget.xml">QWidget</db:link> provides. In addition, as a convenience, the Graphics View framework provides drag and drop support for the scene, and for each and every item. As the view receives a drag, it translates the drag and drop events into a <db:link xlink:href="qgraphicsscenedragdropevent.xml">QGraphicsSceneDragDropEvent</db:link>, which is then forwarded to the scene. The scene takes over scheduling of this event, and sends it to the first item under the mouse cursor that accepts drops.</db:para>
<db:para>To start a drag from an item, create a <db:link xlink:href="qdrag.xml">QDrag</db:link> object, passing a pointer to the widget that starts the drag. Items can be observed by many views at the same time, but only one view can start the drag. Drags are in most cases started as a result of pressing or moving the mouse, so in mousePressEvent() or mouseMoveEvent(), you can get the originating widget pointer from the event. For example:</db:para>
<db:programlisting language="cpp">void CustomItem::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    QMimeData *data = new QMimeData;
    data-&gt;setColor(Qt::green);

    QDrag *drag = new QDrag(event-&gt;widget());
    drag-&gt;setMimeData(data);
    drag-&gt;start();
}
</db:programlisting>
<db:para>To intercept drag and drop events for the scene, you reimplement <db:link xlink:href="qgraphicsscene.xml#dragEnterEvent">QGraphicsScene::dragEnterEvent</db:link>() and whichever event handlers your particular scene needs, in a <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link> subclass. You can read more about drag and drop in Graphics View in the documentation for each of <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link>'s event handlers.</db:para>
<db:para>Items can enable drag and drop support by calling <db:link xlink:href="qgraphicsitem.xml#setAcceptDrops">QGraphicsItem::setAcceptDrops</db:link>(). To handle the incoming drag, reimplement <db:link xlink:href="qgraphicsitem.xml#dragEnterEvent">QGraphicsItem::dragEnterEvent</db:link>(), <db:link xlink:href="qgraphicsitem.xml#dragMoveEvent">QGraphicsItem::dragMoveEvent</db:link>(), <db:link xlink:href="qgraphicsitem.xml#dragLeaveEvent">QGraphicsItem::dragLeaveEvent</db:link>(), and <db:link xlink:href="qgraphicsitem.xml#dropEvent">QGraphicsItem::dropEvent</db:link>().</db:para>
<db:para>See also the <db:link xlink:href="qtwidgets-graphicsview-dragdroprobot-example.xml">Drag and Drop Robot</db:link> example for a demonstration of Graphics View's support for drag and drop operations.</db:para>
</db:section>
<db:section xml:id="cursors-and-tooltips">
<db:title>Cursors and Tooltips</db:title>
<db:para>Like <db:link xlink:href="qwidget.xml">QWidget</db:link>, <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link> also supports cursors (<db:link xlink:href="qgraphicsitem.xml#setCursor">QGraphicsItem::setCursor</db:link>()), and tooltips (<db:link xlink:href="qgraphicsitem.xml#setToolTip">QGraphicsItem::setToolTip</db:link>()). The cursors and tooltips are activated by <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link> as the mouse cursor enters the item's area (detected by calling <db:link xlink:href="qgraphicsitem.xml#contains">QGraphicsItem::contains</db:link>()).</db:para>
<db:para>You can also set a default cursor directly on the view by calling <db:link xlink:href="qwidget.xml#cursor-prop">QGraphicsView::setCursor</db:link>().</db:para>
<db:para>See also the <db:link xlink:href="qtwidgets-graphicsview-dragdroprobot-example.xml">Drag and Drop Robot</db:link> example for code that implements tooltips and cursor shape handling.</db:para>
</db:section>
<db:section xml:id="animation">
<db:title>Animation</db:title>
<db:para>Graphics View supports animation at several levels. You can easily assemble animation by using the Animation Framework. For that you'll need your items to inherit from <db:link xlink:href="qgraphicsobject.xml">QGraphicsObject</db:link> and associate <db:link xlink:href="qpropertyanimation.xml">QPropertyAnimation</db:link> with them. <db:link xlink:href="qpropertyanimation.xml">QPropertyAnimation</db:link> allows to animate any <db:link xlink:href="qobject.xml">QObject</db:link> property.</db:para>
<db:para>Another option is to create a custom item that inherits from <db:link xlink:href="qobject.xml">QObject</db:link> and <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link>. The item can the set up its own timers, and control animations with incremental steps in <db:link xlink:href="qobject.xml#timerEvent">QObject::timerEvent</db:link>().</db:para>
<db:para>A third option, which is mostly available for compatibility with QCanvas in Qt 3, is to <db:emphasis>advance</db:emphasis> the scene by calling <db:link xlink:href="qgraphicsscene.xml#advance">QGraphicsScene::advance</db:link>(), which in turn calls <db:link xlink:href="qgraphicsitem.xml#advance">QGraphicsItem::advance</db:link>().</db:para>
</db:section>
<db:section xml:id="opengl-rendering">
<db:title>OpenGL Rendering</db:title>
<db:para>To enable OpenGL rendering, you simply set a new QGLWidget as the viewport of <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link> by calling <db:link xlink:href="qabstractscrollarea.xml#setViewport">QGraphicsView::setViewport</db:link>(). If you want OpenGL with antialiasing, you need OpenGL sample buffer support (see <db:link xlink:href="qglformat.xml#sampleBuffers">QGLFormat::sampleBuffers</db:link>()).</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QGraphicsView view(&amp;scene);
view.setViewport(new QGLWidget(QGLFormat(QGL::SampleBuffers)));
</db:programlisting>
</db:section>
<db:section xml:id="item-groups">
<db:title>Item Groups</db:title>
<db:para>By making an item a child of another, you can achieve the most essential feature of item grouping: the items will move together, and all transformations are propagated from parent to child.</db:para>
<db:para>In addition, <db:link xlink:href="qgraphicsitemgroup.xml">QGraphicsItemGroup</db:link> is a special item that combines child event handling with a useful interface for adding and removing items to and from a group. Adding an item to a <db:link xlink:href="qgraphicsitemgroup.xml">QGraphicsItemGroup</db:link> will keep the item's original position and transformation, whereas reparenting items in general will cause the child to reposition itself relative to its new parent. For convenience, you can create <db:link xlink:href="qgraphicsitemgroup.xml">QGraphicsItemGroup</db:link>s through the scene by calling <db:link xlink:href="qgraphicsscene.xml#createItemGroup">QGraphicsScene::createItemGroup</db:link>().</db:para>
</db:section>
<db:section xml:id="widgets-and-layouts">
<db:title>Widgets and Layouts</db:title>
<db:para>Qt 4.4 introduced support for geometry and layout-aware items through <db:link xlink:href="qgraphicswidget.xml">QGraphicsWidget</db:link>. This special base item is similar to <db:link xlink:href="qwidget.xml">QWidget</db:link>, but unlike <db:link xlink:href="qwidget.xml">QWidget</db:link>, it doesn't inherit from <db:link xlink:href="qpaintdevice.xml">QPaintDevice</db:link>; rather from <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link> instead. This allows you to write complete widgets with events, signals &amp; slots, size hints and policies, and you can also manage your widgets geometries in layouts through <db:link xlink:href="qgraphicslinearlayout.xml">QGraphicsLinearLayout</db:link> and <db:link xlink:href="qgraphicsgridlayout.xml">QGraphicsGridLayout</db:link>.</db:para>
<db:section xml:id="qgraphicswidget">
<db:title>QGraphicsWidget</db:title>
<db:para>Building on top of <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link>'s capabilities and lean footprint, <db:link xlink:href="qgraphicswidget.xml">QGraphicsWidget</db:link> provides the best of both worlds: extra functionality from <db:link xlink:href="qwidget.xml">QWidget</db:link>, such as the style, font, palette, layout direction, and its geometry, and resolution independence and transformation support from <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link>. Because Graphics View uses real coordinates instead of integers, <db:link xlink:href="qgraphicswidget.xml">QGraphicsWidget</db:link>'s geometry functions also operate on <db:link xlink:href="qrectf.xml">QRectF</db:link> and <db:link xlink:href="qpointf.xml">QPointF</db:link>. This also applies to frame rects, margins and spacing. With <db:link xlink:href="qgraphicswidget.xml">QGraphicsWidget</db:link> it's not uncommon to specify contents margins of (0.5, 0.5, 0.5, 0.5), for example. You can create both subwidgets and &quot;top-level&quot; windows; in some cases you can now use Graphics View for advanced MDI applications.</db:para>
<db:para>Some of <db:link xlink:href="qwidget.xml">QWidget</db:link>'s properties are supported, including window flags and attributes, but not all. You should refer to <db:link xlink:href="qgraphicswidget.xml">QGraphicsWidget</db:link>'s class documentation for a complete overview of what is and what is not supported. For example, you can create decorated windows by passing the <db:link xlink:href="qt.xml#WindowType-enum">Qt::Window</db:link> window flag to <db:link xlink:href="qgraphicswidget.xml">QGraphicsWidget</db:link>'s constructor, but Graphics View currently doesn't support the <db:link xlink:href="qt.xml#WindowType-enum">Qt::Sheet</db:link> and <db:link xlink:href="qt.xml#WindowType-enum">Qt::Drawer</db:link> flags that are common on macOS.</db:para>
</db:section>
<db:section xml:id="qgraphicslayout">
<db:title>QGraphicsLayout</db:title>
<db:para><db:link xlink:href="qgraphicslayout.xml">QGraphicsLayout</db:link> is part of a second-generation layout framework designed specifically for <db:link xlink:href="qgraphicswidget.xml">QGraphicsWidget</db:link>. Its API is very similar to that of <db:link xlink:href="qlayout.xml">QLayout</db:link>. You can manage widgets and sublayouts inside either <db:link xlink:href="qgraphicslinearlayout.xml">QGraphicsLinearLayout</db:link> and <db:link xlink:href="qgraphicsgridlayout.xml">QGraphicsGridLayout</db:link>. You can also easily write your own layout by subclassing <db:link xlink:href="qgraphicslayout.xml">QGraphicsLayout</db:link> yourself, or add your own <db:link xlink:href="qgraphicsitem.xml">QGraphicsItem</db:link> items to the layout by writing an adaptor subclass of <db:link xlink:href="qgraphicslayoutitem.xml">QGraphicsLayoutItem</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="embedded-widget-support">
<db:title>Embedded Widget Support</db:title>
<db:para>Graphics View provides seamless support for embedding any widget into the scene. You can embed simple widgets, such as <db:link xlink:href="qlineedit.xml">QLineEdit</db:link> or <db:link xlink:href="qpushbutton.xml">QPushButton</db:link>, complex widgets such as <db:link xlink:href="qtabwidget.xml">QTabWidget</db:link>, and even complete main windows. To embed your widget to the scene, simply call <db:link xlink:href="qgraphicsscene.xml#addWidget">QGraphicsScene::addWidget</db:link>(), or create an instance of <db:link xlink:href="qgraphicsproxywidget.xml">QGraphicsProxyWidget</db:link> to embed your widget manually.</db:para>
<db:para>Through <db:link xlink:href="qgraphicsproxywidget.xml">QGraphicsProxyWidget</db:link>, Graphics View is able to deeply integrate the client widget features including its cursors, tooltips, mouse, tablet and keyboard events, child widgets, animations, pop-ups (e.g., <db:link xlink:href="qcombobox.xml">QComboBox</db:link> or <db:link xlink:href="qcompleter.xml">QCompleter</db:link>), and the widget's input focus and activation. <db:link xlink:href="qgraphicsproxywidget.xml">QGraphicsProxyWidget</db:link> even integrates the embedded widget's tab order so that you can tab in and out of embedded widgets. You can even embed a new <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link> into your scene to provide complex nested scenes.</db:para>
<db:para>When transforming an embedded widget, Graphics View makes sure that the widget is transformed resolution independently, allowing the fonts and style to stay crisp when zoomed in. (Note that the effect of resolution independence depends on the style.)</db:para>
</db:section>
</db:section>
<db:section xml:id="performance">
<db:title>Performance</db:title>
<db:section xml:id="floating-point-instructions">
<db:title>Floating Point Instructions</db:title>
<db:para>In order to accurately and quickly apply transformations and effects to items, Graphics View is built with the assumption that the user's hardware is able to provide reasonable performance for floating point instructions.</db:para>
<db:para>Many workstations and desktop computers are equipped with suitable hardware to accelerate this kind of computation, but some embedded devices may only provide libraries to handle mathematical operations or emulate floating point instructions in software.</db:para>
<db:para>As a result, certain kinds of effects may be slower than expected on certain devices. It may be possible to compensate for this performance hit by making optimizations in other areas; for example, by using <db:link xlink:href="graphicsview.xml#opengl-rendering">OpenGL</db:link> to render a scene. However, any such optimizations may themselves cause a reduction in performance if they also rely on the presence of floating point hardware.</db:para>
</db:section>
</db:section>
</db:article>
