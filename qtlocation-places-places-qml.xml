<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Places (QML)</db:title>
<db:productname>QtLocation</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Location Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Places example demonstrates how to search for Places and access related content.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="qml">/****************************************************************************
**
** Copyright (C) 2015 The Qt Company Ltd.
** Contact: http://www.qt.io/licensing/
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** You may use this file under the terms of the BSD license as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

import QtQuick 2.5
import QtQuick.Controls 1.4
import QtQuick.Layouts 1.2
import QtPositioning 5.5
import QtLocation 5.6
import &quot;items&quot;

ApplicationWindow {
    id: appWindow
    property Map map
    property variant parameters
    property variant searchLocation: map ? map.center : QtPositioning.coordinate()
    property variant searchRegion: QtPositioning.circle(searchLocation)
    property variant searchRegionItem

    property Plugin favoritesPlugin

    function getPlugins() {
        var plugin = Qt.createQmlObject('import QtLocation 5.3; Plugin {}', appWindow);
        var myArray = new Array;
        for (var i = 0; i &lt; plugin.availableServiceProviders.length; i++) {
            var tempPlugin = Qt.createQmlObject ('import QtLocation 5.3; Plugin {name: &quot;' + plugin.availableServiceProviders[i]+ '&quot;}', appWindow)

            if (tempPlugin.supportsPlaces() &amp;&amp; tempPlugin.supportsMapping() )
                myArray.push(tempPlugin.name)
        }
        myArray.sort()
        return myArray;
    }

    function initializeProviders(pluginParameters)
    {
        var parameters = new Array()
        for (var prop in pluginParameters) {
            var parameter = Qt.createQmlObject('import QtLocation 5.3; PluginParameter{ name: &quot;'+ prop + '&quot;; value: &quot;' + pluginParameters[prop]+'&quot;}',appWindow)
            parameters.push(parameter)
        }
        appWindow.parameters = parameters
        var plugins = getPlugins()
        mainMenu.providerMenu.createMenu(plugins)
        for (var i = 0; i&lt;plugins.length; i++) {
            if (plugins[i] === &quot;osm&quot;)
                mainMenu.selectProvider(plugins[i])
        }
    }

    function createMap(provider) {
        var plugin;
        if (parameters &amp;&amp; parameters.length&gt;0)
            plugin = Qt.createQmlObject ('import QtLocation 5.3; Plugin{ name:&quot;' + provider + '&quot;; parameters: appWindow.parameters}', appWindow)
        else
            plugin = Qt.createQmlObject ('import QtLocation 5.3; Plugin{ name:&quot;' + provider + '&quot;}', appWindow)

        if (map)
            map.destroy();
        map = mapComponent.createObject(page);
        map.plugin = plugin;
        map.zoomLevel = (map.maximumZoomLevel - map.minimumZoomLevel)/2
        categoryModel.plugin = plugin;
        categoryModel.update();
        placeSearchModel.plugin = plugin;
        suggestionModel.plugin = plugin;
    }

    title: qsTr(&quot;Places&quot;)
    width: 360
    height: 640
    visible: true
    menuBar: mainMenu
    toolBar: searchBar

    MainMenu {
        id: mainMenu
        onSelectProvider: {
            stackView.pop(page)
            for (var i = 0; i &lt; providerMenu.items.length; i++) {
                providerMenu.items[i].checked = providerMenu.items[i].text === providerName
            }

            createMap(providerName)
            if (map.error === Map.NoError) {
                settingsMenu.createMenu(map);
            } else {
                settingsMenu.clear();
            }
        }
        onSelectSetting: {
            stackView.pop({tem:page,immediate: true})
            switch (setting) {
            case &quot;searchCenter&quot;:
                stackView.push({ item: Qt.resolvedUrl(&quot;forms/SearchCenter.qml&quot;) ,
                                   properties: { &quot;coordinate&quot;: map.center}})
                stackView.currentItem.changeSearchCenter.connect(stackView.changeSearchCenter)
                stackView.currentItem.closeForm.connect(stackView.closeForm)
                break
            case &quot;searchBoundingBox&quot;:
                stackView.push({ item: Qt.resolvedUrl(&quot;forms/SearchBoundingBox.qml&quot;) ,
                                   properties: { &quot;searchRegion&quot;: searchRegion}})
                stackView.currentItem.changeSearchBoundingBox.connect(stackView.changeSearchBoundingBox)
                stackView.currentItem.closeForm.connect(stackView.closeForm)
                break
            case &quot;searchBoundingCircle&quot;:
                stackView.push({ item: Qt.resolvedUrl(&quot;forms/SearchBoundingCircle.qml&quot;) ,
                                   properties: { &quot;searchRegion&quot;: searchRegion}})
                stackView.currentItem.changeSearchBoundingCircle.connect(stackView.changeSearchBoundingCircle)
                stackView.currentItem.closeForm.connect(stackView.closeForm)
                break
            case &quot;SearchOptions&quot;:
                stackView.push({ item: Qt.resolvedUrl(&quot;forms/SearchOptions.qml&quot;) ,
                                   properties: { &quot;plugin&quot;: map.plugin,
                                       &quot;model&quot;: placeSearchModel}})
                stackView.currentItem.changeSearchSettings.connect(stackView.changeSearchSettings)
                stackView.currentItem.closeForm.connect(stackView.closeForm)
                break
            default:
                console.log(&quot;Unsupported setting !&quot;)
            }
        }
    }

    SearchBar {
        id: searchBar
        width: appWindow.width
        searchBarVisbile: stackView.depth &gt; 1 &amp;&amp;
                          stackView.currentItem &amp;&amp;
                          stackView.currentItem.objectName != &quot;suggestionView&quot; ? false : true
        onShowCategories: {
            if (map &amp;&amp; map.plugin) {
                stackView.pop({tem:page,immediate: true})
                stackView.enterCategory()
            }
        }
        onGoBack: stackView.pop()
        onSearchTextChanged: {
            if (searchText.length &gt;= 3 &amp;&amp; suggestionModel != null) {
                suggestionModel.searchTerm = searchText;
                suggestionModel.update();
            }
        }
        onDoSearch: {
            if (searchText.length &gt; 0)
                placeSearchModel.searchForText(searchText);
        }
        onShowMap: stackView.pop(page)
    }

    StackView {
        id: stackView

        function showMessage(title,message,backPage)
        {
            push({ item: Qt.resolvedUrl(&quot;forms/Message.qml&quot;) ,
                     properties: {
                         &quot;title&quot; : title,
                         &quot;message&quot; : message,
                         &quot;backPage&quot; : backPage
                     }})
            currentItem.closeForm.connect(closeMessage)
        }

        function closeMessage(backPage)
        {
            pop(backPage)
        }

        function closeForm()
        {
            pop(page)
        }

        function enterCategory(index)
        {
            push({ item: Qt.resolvedUrl(&quot;views/CategoryView.qml&quot;) ,
                     properties: { &quot;categoryModel&quot;: categoryModel,
                         &quot;rootIndex&quot; : index
                     }})
            currentItem.showSubcategories.connect(stackView.enterCategory)
            currentItem.searchCategory.connect(placeSearchModel.searchForCategory)
        }

        function showSuggestions()
        {
            if (currentItem.objectName != &quot;suggestionView&quot;) {
                stackView.pop(page)
                push({ item: Qt.resolvedUrl(&quot;views/SuggestionView.qml&quot;) ,
                         properties: { &quot;suggestionModel&quot;: suggestionModel }
                     })
                currentItem.objectName = &quot;suggestionView&quot;
                currentItem.suggestionSelected.connect(searchBar.showSearch)
                currentItem.suggestionSelected.connect(placeSearchModel.searchForText)
            }
        }

        function showPlaces()
        {
            if (currentItem.objectName != &quot;searchResultView&quot;) {
                stackView.pop({tem:page,immediate: true})
                push({ item: Qt.resolvedUrl(&quot;views/SearchResultView.qml&quot;) ,
                         properties: { &quot;placeSearchModel&quot;: placeSearchModel }
                     })
                currentItem.showPlaceDetails.connect(showPlaceDatails)
                currentItem.showMap.connect(searchBar.showMap)
                currentItem.objectName = &quot;searchResultView&quot;
            }
        }

        function showPlaceDatails(place, distance)
        {
            push({ item: Qt.resolvedUrl(&quot;forms/PlaceDetails.qml&quot;) ,
                     properties: { &quot;place&quot;: place,
                         &quot;distanceToPlace&quot;: distance }
                 })
            currentItem.searchForSimilar.connect(searchForSimilar)
            currentItem.showReviews.connect(showReviews)
            currentItem.showEditorials.connect(showEditorials)
            currentItem.showImages.connect(showImages)
        }

        function showEditorials(place)
        {
            push({ item: Qt.resolvedUrl(&quot;views/EditorialView.qml&quot;) ,
                     properties: { &quot;place&quot;: place }
                 })
            currentItem.showEditorial.connect(showEditorial)
        }

        function showReviews(place)
        {
            push({ item: Qt.resolvedUrl(&quot;views/ReviewView.qml&quot;) ,
                     properties: { &quot;place&quot;: place }
                 })
            currentItem.showReview.connect(showReview)
        }

        function showImages(place)
        {
            push({ item: Qt.resolvedUrl(&quot;views/ImageView.qml&quot;) ,
                     properties: { &quot;place&quot;: place }
                 })
        }

        function showEditorial(editorial)
        {
            push({ item: Qt.resolvedUrl(&quot;views/EditorialPage.qml&quot;) ,
                     properties: { &quot;editorial&quot;: editorial }
                 })
        }

        function showReview(review)
        {
            push({ item: Qt.resolvedUrl(&quot;views/ReviewPage.qml&quot;) ,
                     properties: { &quot;review&quot;: review }
                 })
        }

        function changeSearchCenter(coordinate)
        {
            stackView.pop(page)
            map.center = coordinate;
            if (searchRegionItem) {
                map.removeMapItem(searchRegionItem);
                searchRegionItem.destroy();
            }
        }

        function changeSearchBoundingBox(coordinate,widthDeg,heightDeg)
        {
            stackView.pop(page)
            map.center = coordinate
            searchRegion = QtPositioning.rectangle(map.center, widthDeg, heightDeg)
            if (searchRegionItem) {
                map.removeMapItem(searchRegionItem);
                searchRegionItem.destroy();
            }
            searchRegionItem = Qt.createQmlObject('import QtLocation 5.3; MapRectangle { color: &quot;#46a2da&quot;; border.color: &quot;#190a33&quot;; border.width: 2; opacity: 0.25 }', page, &quot;MapRectangle&quot;);
            searchRegionItem.topLeft = searchRegion.topLeft;
            searchRegionItem.bottomRight = searchRegion.bottomRight;
            map.addMapItem(searchRegionItem);
        }

        function changeSearchBoundingCircle(coordinate,radius)
        {
            stackView.pop(page)
            map.center = coordinate;
            searchRegion = QtPositioning.circle(coordinate, radius)

            if (searchRegionItem) {
                map.removeMapItem(searchRegionItem);
                searchRegionItem.destroy();
            }
            searchRegionItem = Qt.createQmlObject('import QtLocation 5.3; MapCircle { color: &quot;#46a2da&quot;; border.color: &quot;#190a33&quot;; border.width: 2; opacity: 0.25 }', page, &quot;MapRectangle&quot;);
            searchRegionItem.center = searchRegion.center;
            searchRegionItem.radius = searchRegion.radius;
            map.addMapItem(searchRegionItem);
        }

        function changeSearchSettings(orderByDistance, orderByName, locales)
        {
            stackView.pop(page)
            /*if (isFavoritesEnabled) {
                if (favoritesPlugin == null)
                    favoritesPlugin = Qt.createQmlObject('import QtLocation 5.3; Plugin { name: &quot;places_jsondb&quot; }', page);
                favoritesPlugin.parameters = pluginParametersFromMap(pluginParameters);
                placeSearchModel.favoritesPlugin = favoritesPlugin;
            } else {
                placeSearchModel.favoritesPlugin = null;
            }*/
            placeSearchModel.favoritesPlugin = null;

            placeSearchModel.relevanceHint = orderByDistance ? PlaceSearchModel.DistanceHint :
                                                               orderByName ? PlaceSearchModel.LexicalPlaceNameHint :
                                                                             PlaceSearchModel.UnspecifiedHint;
            map.plugin.locales = locales.split(Qt.locale().groupSeparator);
        }

        function searchForSimilar(place) {
            stackView.pop(page)
            searchBar.showSearch(place.name)
            placeSearchModel.searchForRecommendations(place.placeId);
        }

        anchors.fill: parent
        focus: true
        initialItem:  Item {
            id: page

            PlaceSearchModel {
                id: placeSearchModel
                searchArea: searchRegion

                function searchForCategory(category) {
                    searchTerm = &quot;&quot;;
                    categories = category;
                    recommendationId = &quot;&quot;;
                    searchArea = searchRegion
                    limit = -1;
                    update();
                }

                function searchForText(text) {
                    searchTerm = text;
                    categories = null;
                    recommendationId = &quot;&quot;;
                    searchArea = searchRegion
                    limit = -1;
                    update();
                }

                function searchForRecommendations(placeId) {
                    searchTerm = &quot;&quot;;
                    categories = null;
                    recommendationId = placeId;
                    searchArea = null;
                    limit = -1;
                    update();
                }

                onStatusChanged: {
                    switch (status) {
                    case PlaceSearchModel.Ready:
                        if (count &gt; 0)
                            stackView.showPlaces()
                        else
                            stackView.showMessage(qsTr(&quot;Search Place Error&quot;),qsTr(&quot;Place not found !&quot;))
                        break;
                    case PlaceSearchModel.Error:
                        stackView.showMessage(qsTr(&quot;Search Place Error&quot;),errorString())
                        break;
                    }
                }
            }

            PlaceSearchSuggestionModel {
                id: suggestionModel
                searchArea: searchRegion

                onStatusChanged: {
                    if (status == PlaceSearchSuggestionModel.Ready)
                        stackView.showSuggestions()
                }
            }

            CategoryModel {
                id: categoryModel
                hierarchical: true
            }

            Component {
                id: mapComponent

                MapComponent {
                    width: page.width
                    height: page.height

                    onErrorChanged: {
                        if (map.error != Map.NoError) {
                            var title = qsTr(&quot;ProviderError&quot;);
                            var message =  map.errorString + &quot;&lt;br/&gt;&lt;br/&gt;&lt;b&gt;&quot; + qsTr(&quot;Try to select other provider&quot;) + &quot;&lt;/b&gt;&quot;;
                            if (map.error == Map.MissingRequiredParameterError)
                                message += &quot;&lt;br/&gt;&quot; + qsTr(&quot;or see&quot;) + &quot; \'mapviewer --help\' &quot;
                                        + qsTr(&quot;how to pass plugin parameters.&quot;);
                            stackView.showMessage(title,message);
                        }
                    }

                    MapItemView {
                        model: placeSearchModel
                        delegate: MapQuickItem {
                            coordinate: model.type === PlaceSearchModel.PlaceResult ? place.location.coordinate : QtPositioning.coordinate()

                            visible: model.type === PlaceSearchModel.PlaceResult

                            anchorPoint.x: image.width * 0.28
                            anchorPoint.y: image.height

                            sourceItem: Image {
                                id: image
                                source: &quot;resources/marker.png&quot;
                                MouseArea {
                                    anchors.fill: parent
                                    onClicked: stackView.showPlaceDatails(model.place,model.distance)
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    Rectangle {
        color: &quot;white&quot;
        opacity: busyIndicator.running ? 0.8 : 0
        anchors.fill: parent
        Behavior on opacity { NumberAnimation{} }
    }
    BusyIndicator {
        id: busyIndicator
        anchors.centerIn: parent
        running: placeSearchModel.status == PlaceSearchModel.Loading ||
                 categoryModel.status === CategoryModel.Loading
    }
}

</db:programlisting>
</db:article>
