<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Overview Qt Remote Objects</db:title>
<db:productname>QtRemoteObjects</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Remote Objects Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Introduction to using Qt Remote Objects.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="introduction">
<db:title>Introduction</db:title>
<db:para>The <db:emphasis>Qt Remote Objects</db:emphasis> (QtRO) module provides an easy way to share Qt APIs between processes and devices. A data channel between processes and devices is required for this to work. Therefore, the first thing you need in QtRO is a <db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link>. In QtRO, a node is an endpoint for communication. Each participant in a remote objects network, be it a process or a device, needs its own node. QtRO is a peer-to-peer network, with connected nodes being the links in the network.</db:para>
<db:para>Nodes, by themselves, don’t provide much use. The value comes from adding <db:link xlink:href="qobject.xml">QObject</db:link> classes to a node for sharing. Any peer node can then request a copy/instance of the shared object from the node that shares it (called the <db:emphasis>host node</db:emphasis>). Unlike when using normal class instances (with independent properties and signal emissions), the idea in QtRO is to synchronize the changes of the shared object to all of the copies. With a few exceptions, the copies have the exact same Qt API as the original object, and are intended to be used exactly as if the original object were available. In QtRO, the original object is called the <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link>. It is a fully implemented C++ class, with whatever business logic is needed to provide the desired functionality. Copies of this object are called <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link>s. You don’t need to write any C++ code for a replica; instead, you simply request an instance from a node. You still need some code to use it, such as connecting signals to your own slots, but you don’t need to implement the internal behavior – that was already done in the source object.</db:para>
<db:para>Because the source can be in a different process or even on a different device, there are concerns in QtRO that you won’t run into when developing without Inter-Process Communication (IPC). Specifically, what happens if the process or device isn’t there? This is where the additions to the <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link> API come in. There is an <db:link xlink:href="qremoteobjectreplica.xml#initialized">initialized</db:link>() signal that is emitted once the replica has received the <db:link xlink:href="qtremoteobjects-source.xml#source">source</db:link> state from the QtRO network. There is also an <db:link xlink:href="qremoteobjectreplica.xml#isReplicaValid">isReplicaValid</db:link> property and a <db:link xlink:href="qremoteobjectreplica.xml#stateChanged">stateChanged</db:link>() signal to alert you if the connection is lost.</db:para>
<db:para>Objects shared over QtRO use the links (conduits) between nodes for all communication. If you intend to share a <db:link xlink:href="qobject.xml">QObject</db:link>, you must create a <db:emphasis>host node</db:emphasis> with a URL other nodes can connect to. You can also use the QtRO <db:link xlink:href="qtremoteobjects-registry.xml#registry">Registry</db:link> to facilitate connections, but your nodes sharing <db:link xlink:href="qtremoteobjects-source.xml#source">sources</db:link> still need to be Host nodes. Each shared object is given a name (a <db:link xlink:href="qstring.xml">QString</db:link>), used for identifying it on the QtRO network.</db:para>
<db:para>See the <db:link xlink:href="qtremoteobjects-index.xml">Overview</db:link> for a more detailed description, or use the following examples to get started with QtRO.</db:para>
</db:section>
<db:section xml:id="implementation">
<db:title>Implementation</db:title>
<db:para>To illustrate the use of remote objects, on the source side we need to:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Create the <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> object that will be replicated to other nodes (with or without using <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link>, the Qt Remote Objects Compiler).</db:para>
</db:listitem>
<db:listitem>
<db:para>(Optional) Create the <db:link xlink:href="qtremoteobjects-registry.xml#registry">Registry</db:link>. If not used, direct connections are required.</db:para>
</db:listitem>
<db:listitem>
<db:para>Create a host node so the source object can be shared.</db:para>
</db:listitem>
<db:listitem>
<db:para>Call the node's <db:link xlink:href="qremoteobjecthostbase.xml#enableRemoting">enableRemoting</db:link>() function to share the source object.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>And on the replica side:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>(Optional) Use <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link> to generate a <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link> header for your project.</db:para>
</db:listitem>
<db:listitem>
<db:para>Create the node that will connect with the <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> host node.</db:para>
</db:listitem>
<db:listitem>
<db:para>Call the node's <db:link xlink:href="qremoteobjectnode.xml#acquire">acquire</db:link>() function to create a pointer to a replica.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>The examples below will show both <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link>-compiled static objects and dynamic source objects. The examples will also show direct connections as well as connections using a <db:link xlink:href="qtremoteobjects-registry.xml#registry">Registry</db:link> between nodes.</db:para>
<db:anchor xml:id="qtro-example1"/>
</db:section>
<db:section xml:id="example-1-direct-connection-using-a-static-source">
<db:title>Example 1: Direct Connection Using a Static Source</db:title>
<db:para>In this example, the source object is a simple binary switch that will toggle its state based on a timer. When the state changes, a signal is emitted by the source which QtRO propagates to all replicas. As the replica will have the same properties, signals and slots as were exposed from the source object, any slots connected to the replica's signal will be called when the replica receives the signal. The client process then echoes back the received switch state to the source by emitting its own signal which is connected to a slot on the replica.</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para><db:emphasis role="bold">Create a source object</db:emphasis></db:para>
<db:para>To create this <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> object, we first create the definition file, <db:code>simpleswitch.rep</db:code>. This file describes the properties and methods for the object and is input to the <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link> utility which is part of Qt Remote Objects. Only the interfaces that need to be exposed to <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link> objects are defined in this file.</db:para>
<db:para><db:code>simpleswitch.rep</db:code></db:para>
<db:programlisting language="cpp">class SimpleSwitch
{
    PROP(bool currState=false);
    SLOT(server_slot(bool clientState));
};
</db:programlisting>
<db:para>Above,</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>currState</db:code> holds the current state of the switch, and</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>server_slot()</db:code> allows us to interact with the <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> - it will be connected to the <db:code>echoSwitchState(bool newstate)</db:code> signal.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link> to process this file, add the following line to the <db:code>.pro</db:code> file:</db:para>
<db:programlisting language="cpp">REPC_SOURCE = simpleswitch.rep
</db:programlisting>
<db:para>The <db:code>REPC_SOURCE</db:code> variable is only relevant for the Qt Remote Object module, so you need to add it to your project as well:</db:para>
<db:programlisting language="cpp">QT       += remoteobjects
</db:programlisting>
<db:para><db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link> creates the header <db:code>rep_SimpleSwitch_source.h</db:code> in your specified build directory. Refer to the <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> section for more details about this file.</db:para>
<db:para>Repc creates three helper classes for use with QtRO. For this example, we will use the most basic: <db:code>SimpleSwitchSimpleSource</db:code>. It is an abstract class, defined in <db:code>rep_SimpleSwitch_source.h</db:code>. We derive from it to define our SimpleSwitch implementation class as shown below:</db:para>
<db:para><db:code>simpleswitch.h</db:code></db:para>
<db:programlisting language="cpp">#ifndef SIMPLESWITCH_H
#define SIMPLESWITCH_H

#include &quot;rep_SimpleSwitch_source.h&quot;

class SimpleSwitch : public SimpleSwitchSimpleSource
{
    Q_OBJECT
public:
    SimpleSwitch(QObject *parent = nullptr);
    ~SimpleSwitch();
    virtual void server_slot(bool clientState);
public Q_SLOTS:
    void timeout_slot();
private:
    QTimer *stateChangeTimer;
};

#endif
</db:programlisting>
<db:para>Above,</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>stateChangeTimer</db:code> is a <db:link xlink:href="qtimer.xml">QTimer</db:link> that is used to toggle the state of our SimpleSwitch,</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>timeout_slot()</db:code> is connected to the timeout() signal of <db:code>stateChangeTimer</db:code>,</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>server_slot()</db:code> – which is called on the source (automatically via QtRO) whenever any replica calls their version of the slot – outputs the received value, and</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>currStateChanged(bool)</db:code>, defined in <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link>-generated <db:code>rep_SimpleSwitch_source.h</db:code>, is emitted whenever currState toggles. In this example, we ignore the signal on the source side, and handle it later on the replica side.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The definition of our <db:code>SwitchState</db:code> class is shown below:</db:para>
<db:para><db:code>simpleswitch.cpp</db:code></db:para>
<db:programlisting language="cpp">#include &quot;simpleswitch.h&quot;

// constructor
SimpleSwitch::SimpleSwitch(QObject *parent) : SimpleSwitchSimpleSource(parent)
{
    stateChangeTimer = new QTimer(this); // Initialize timer
    QObject::connect(stateChangeTimer, &amp;amp;SimpleSwitch::timeout, this, &amp;amp;SimpleSwitch::timeout_slot); // connect timeout() signal from stateChangeTimer to timeout_slot() of simpleSwitch
    stateChangeTimer-&amp;gt;start(2000); // Start timer and set timout to 2 seconds
    qDebug() &amp;lt;&amp;lt; &quot;Source Node Started&quot;;
}

//destructor
SimpleSwitch::~SimpleSwitch()
{
    stateChangeTimer-&amp;gt;stop();
}

void SimpleSwitch::server_slot(bool clientState)
{
    qDebug() &amp;lt;&amp;lt; &quot;Replica state is &quot; &amp;lt;&amp;lt; clientState; // print switch state echoed back by client
}

void SimpleSwitch::timeout_slot()
{
    // slot called on timer timeout
    if (currState()) // check if current state is true, currState() is defined in repc generated rep_SimpleSwitch_source.h
        setCurrState(false); // set state to false
    else
        setCurrState(true); // set state to true
    qDebug() &amp;lt;&amp;lt; &quot;Source State is &quot;&amp;lt;&amp;lt;currState();

}
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Create a registry</db:emphasis></db:para>
<db:para>Because this example involves using a direct connection between nodes, step 2 for <db:link xlink:href="qtremoteobjects-registry.xml#registry">Registry</db:link> creation is omitted.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Create a host node</db:emphasis></db:para>
<db:para>The host node is created as shown below:</db:para>
<db:programlisting language="cpp">QRemoteObjectHost srcNode(QUrl(QStringLiteral(&quot;local:switch&quot;)));
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Host source object and remoting</db:emphasis></db:para>
<db:para>The following statements instantiate the <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> object and pass it to the host to enable &quot;remoting&quot;, that is, making the object visible to the QtRO network:</db:para>
<db:programlisting language="cpp">SimpleSwitch srcSwitch; // create simple switch
srcNode.enableRemoting(&amp;amp;srcSwitch); // enable remoting
</db:programlisting>
<db:para>The contents of <db:code>main.cpp</db:code> file that implements the above steps are shown below:</db:para>
<db:para><db:code>main.cpp</db:code></db:para>
<db:programlisting language="cpp">#include &amp;lt;QCoreApplication&amp;gt;
#include &quot;simpleswitch.h&quot;

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    SimpleSwitch srcSwitch; // create simple switch

    QRemoteObjectHost srcNode(QUrl(QStringLiteral(&quot;local:switch&quot;))); // create host node without Registry
    srcNode.enableRemoting(&amp;amp;srcSwitch); // enable remoting/sharing

    return a.exec();
}
</db:programlisting>
<db:para>Compile and run this (source side) project. The output (without any replicas created) should look as shown below with the switch state toggling between <db:code>true</db:code> and <db:code>false</db:code> every two seconds.</db:para>
<db:mediaobject>
<db:alt>&quot;Example 1: Server output&quot;</db:alt>
<db:imageobject>
<db:imagedata fileref="images/DirectConnectServerOutput.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Next are the steps for creating the replica side of the network, which in this example gets the state of switch from the <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> and echoes it back.</db:para>
</db:listitem>
</db:orderedlist>
<db:section xml:id="replica-code">
<db:title>Replica Code</db:title>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para><db:emphasis role="bold">Use repc to add a replica to your project</db:emphasis></db:para>
<db:para>The same API definition file as was used on the source side, <db:code>SimpleSwitch.rep</db:code>, is used for creating a <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link> header file using the <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link> utility. Include the following line in your client side <db:code>.pro</db:code> file, specifying a <db:code>.rep</db:code> file input:</db:para>
<db:programlisting language="cpp">REPC_REPLICA = simpleswitch.rep
</db:programlisting>
<db:para>The <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link> tool generates a <db:code>rep_SimpleSwitch_replica.h</db:code> file in the build directory. Refer to <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link> section for more details about this file.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Create a node to connect with the source's host node</db:emphasis></db:para>
<db:para>The following code instantiates the second node on the network and connects it with the source host node:</db:para>
<db:programlisting language="cpp">QRemoteObjectNode repNode; // create remote object node
repNode.connectToNode(QUrl(QStringLiteral(&quot;local:switch&quot;))); // connect with remote host node
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Call node's <db:link xlink:href="qremoteobjectnode.xml#acquire">acquire</db:link>() to create a pointer to a replica</db:emphasis></db:para>
<db:para>First, a replica is instantiated:</db:para>
<db:programlisting language="cpp">QSharedPointer&amp;lt;SimpleSwitchReplica&amp;gt; ptr;
ptr.reset(repNode.acquire&amp;lt;SimpleSwitchReplica&amp;gt;()); // acquire replica of source from host node
</db:programlisting>
<db:para>Note that <db:link xlink:href="qremoteobjectnode.xml#acquire">acquire</db:link>() returns a pointer to the replica. However, it does not manage the pointer lifetime. This example uses the recommended process of wrapping the returned pointer in a <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> or <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link> to ensure the pointer is properly deleted.</db:para>
<db:para><db:code>main.cpp</db:code> implements above steps and instantiates our object:</db:para>
<db:para><db:code>main.cpp</db:code></db:para>
<db:programlisting language="cpp">#include &amp;lt;QCoreApplication&amp;gt;
#include &quot;client.h&quot;

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    QSharedPointer&amp;lt;SimpleSwitchReplica&amp;gt; ptr; // shared pointer to hold source replica

    QRemoteObjectNode repNode; // create remote object node
    repNode.connectToNode(QUrl(QStringLiteral(&quot;local:switch&quot;))); // connect with remote host node

    ptr.reset(repNode.acquire&amp;lt;SimpleSwitchReplica&amp;gt;()); // acquire replica of source from host node

    Client rswitch(ptr); // create client switch object and pass reference of replica to it

    return a.exec();
}
</db:programlisting>
<db:para>Complete declaration and definition of the <db:code>Client</db:code> class:</db:para>
<db:para><db:code>client.h</db:code></db:para>
<db:programlisting language="cpp">#ifndef _CLIENT_H
#define _CLIENT_H

#include &amp;lt;QObject&amp;gt;
#include &amp;lt;QSharedPointer&amp;gt;

#include &quot;rep_SimpleSwitch_replica.h&quot;

class Client : public QObject
{
    Q_OBJECT
public:
    Client(QSharedPointer&amp;lt;SimpleSwitchReplica&amp;gt; ptr);
    ~Client();
    void initConnections();// Function to connect signals and slots of source and client

Q_SIGNALS:
    void echoSwitchState(bool switchState);// this signal is connected with server_slot(..) on the source object and echoes back switch state received from source

public Q_SLOTS:
    void recSwitchState_slot(); // slot to receive source state
private:
    bool clientSwitchState; // holds received server switch state
    QSharedPointer&amp;lt;SimpleSwitchReplica&amp;gt; reptr;// holds reference to replica

 };

#endif
</db:programlisting>
<db:para><db:code>client.cpp</db:code></db:para>
<db:programlisting language="cpp">#include &quot;client.h&quot;

// constructor
Client::Client(QSharedPointer&amp;lt;SimpleSwitchReplica&amp;gt; ptr) :
    QObject(nullptr),reptr(ptr)
{
    initConnections();
    //We can connect to SimpleSwitchReplica Signals/Slots
    //directly because our Replica was generated by repc.
}

//destructor
Client::~Client()
{
}

void Client::initConnections()
{
    // initialize connections between signals and slots

    // connect source replica signal currStateChanged() with client's recSwitchState() slot to receive source's current state
    QObject::connect(reptr.data(), &amp;amp;SimpleSwitchReplica::currStateChanged, this, &amp;amp;Client::recSwitchState_slot);
    // connect client's echoSwitchState(..) signal with replica's server_slot(..) to echo back received state
    QObject::connect(this, &amp;amp;Client::echoSwitchState, reptr.data(), &amp;amp;SimpleSwitchReplica::server_slot);
}

void Client::recSwitchState_slot()
{
    qDebug() &amp;lt;&amp;lt; &quot;Received source state &quot;&amp;lt;&amp;lt;reptr.data()-&amp;gt;currState();
    clientSwitchState = reptr.data()-&amp;gt;currState();
    Q_EMIT echoSwitchState(clientSwitchState); // Emit signal to echo received state back to server
}
</db:programlisting>
<db:para>Compiling and executing this example together with the source-side example generates the following output:</db:para>
<db:mediaobject>
<db:alt>&quot;Direct Connect Server Client Communication output&quot;</db:alt>
<db:imageobject>
<db:imagedata fileref="images/DirectConnectClientServerOutput.png"/>
</db:imageobject>
</db:mediaobject>
</db:listitem>
</db:orderedlist>
<db:anchor xml:id="qtro-example2"/>
</db:section>
</db:section>
<db:section xml:id="example-2-direct-connection-with-a-dynamic-replica">
<db:title>Example 2: Direct Connection with a Dynamic Replica</db:title>
<db:para>A dynamic replica is initially created as a &quot;bare&quot; <db:link xlink:href="qobject.xml">QObject</db:link> - that is, it has no properties, signals or slots. QtRO returns the API for the object during initialization (after the connection to the source is made), thus the API is added to the object at runtime.</db:para>
<db:para>There are no changes to the source side as a dynamic <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link> only impacts how the requestor node acquires the replica. The source-side code shown in <db:link xlink:href="qtremoteobjects-gettingstarted.xml#qtro-example1">Example 1</db:link> will be used.</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Add replica generation to project.</db:para>
<db:para>Because the replica is dynamically acquired, no <db:code>.rep</db:code> file is required unlike in <db:link xlink:href="qtremoteobjects-gettingstarted.xml#qtro-example1">Example 1</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Create the remote node and connect it with the source host node.</db:para>
<db:para>The code for this step is unchanged from <db:link xlink:href="qtremoteobjects-gettingstarted.xml#qtro-example1">Example 1</db:link>.</db:para>
<db:programlisting language="cpp">QRemoteObjectNode repNode; // create remote object node
repNode.connectToNode(QUrl(QStringLiteral(&quot;local:switch&quot;))); // connect with remote host node
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para>Acquire a replica of the remote source object.</db:para>
<db:para>In <db:code>main.cpp</db:code>, we use a <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> to hold a replica of the remote object, and then instantiate a replica requestor object:</db:para>
<db:programlisting language="cpp">#include &amp;lt;QCoreApplication&amp;gt;

#include &quot;dynamicclient.h&quot;

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    QSharedPointer&amp;lt;QRemoteObjectDynamicReplica&amp;gt; ptr; // shared pointer to hold replica

    QRemoteObjectNode repNode;
    repNode.connectToNode(QUrl(QStringLiteral(&quot;local:switch&quot;)));

    ptr.reset(repNode.acquireDynamic(&quot;SimpleSwitch&quot;)); // acquire replica of source from host node

    DynamicClient rswitch(ptr); // create client switch object and pass replica reference to it
}
</db:programlisting>
</db:listitem>
</db:orderedlist>
<db:para>Below is the complete declaration and definition of the requestor class (<db:code>DynamicClient</db:code> in this example):</db:para>
<db:para><db:code>dynamicclient.h</db:code></db:para>
<db:programlisting language="cpp">#ifndef _DYNAMICCLIENT_H
#define _DYNAMICCLIENT_H

#include &amp;lt;QObject&amp;gt;
#include &amp;lt;QSharedPointer&amp;gt;

#include &amp;lt;QRemoteObjectNode&amp;gt;
#include &amp;lt;qremoteobjectdynamicreplica.h&amp;gt;

class DynamicClient : public QObject
{
    Q_OBJECT
public:
    DynamicClient(QSharedPointer&amp;lt;QRemoteObjectDynamicReplica&amp;gt; ptr);
    ~DynamicClient();

Q_SIGNALS:
    void echoSwitchState(bool switchState);// this signal is connected with server_slot(..) slot of source object and echoes back switch state received from source

public Q_SLOTS:
    void recSwitchState_slot(); // Slot to receive source state
    void initConnection_slot(); //Slot to connect signals/slot on replica initialization

private:
    bool clientSwitchState; // holds received server switch state
    QSharedPointer&amp;lt;QRemoteObjectDynamicReplica&amp;gt; reptr;// holds reference to replica
 };

#endif
</db:programlisting>
<db:para><db:code>dynamicclient.cpp</db:code></db:para>
<db:programlisting language="cpp">#include &quot;dynamicclient.h&quot;

// constructor
DynamicClient::DynamicClient(QSharedPointer&amp;lt;QRemoteObjectDynamicReplica&amp;gt; ptr) :
    QObject(nullptr), reptr(ptr)
{

    //connect signal for replica valid changed with signal slot initialization
    QObject::connect(reptr.data(), &amp;amp;QRemoteObjectDynamicReplica::initialized, this,
                     &amp;amp;DynamicClient::initConnection_slot);
}

//destructor
DynamicClient::~DynamicClient()
{
}

// Function to initialize connections between slots and signals
void DynamicClient::initConnection_slot()
{

    // connect source replica signal currStateChanged() with client's recSwitchState() slot to receive source's current state
   QObject::connect(reptr.data(), SIGNAL(currStateChanged()), this, SLOT(recSwitchState_slot()));
   // connect client's echoSwitchState(..) signal with replica's server_slot(..) to echo back received state
   QObject::connect(this, SIGNAL(echoSwitchState(bool)),reptr.data(), SLOT(server_slot(bool)));
}

void DynamicClient::recSwitchState_slot()
{
   clientSwitchState = reptr-&amp;gt;property(&quot;currState&quot;).toBool(); // use replica property to get currState from source
   qDebug() &amp;lt;&amp;lt; &quot;Received source state &quot; &amp;lt;&amp;lt; clientSwitchState;
   Q_EMIT echoSwitchState(clientSwitchState); // Emit signal to echo received state back to server
}
</db:programlisting>
<db:para>When executed together with the source-side example, the output is identical to <db:link xlink:href="qtremoteobjects-gettingstarted.xml#qtro-example1">Example 1</db:link>.</db:para>
<db:anchor xml:id="qtro-example3"/>
</db:section>
<db:section xml:id="example-3-remote-nodes-using-a-registry">
<db:title>Example 3: Remote Nodes using a Registry</db:title>
<db:para>This example will illustrate the use of a <db:link xlink:href="qtremoteobjects-registry.xml#registry">Registry</db:link> for building the node topology. For only two nodes, the benefits of using a registry are minimal. With a registry, instead of using a <db:link xlink:href="qurl.xml">QUrl</db:link> to create a direct connection between two nodes, you use a different <db:link xlink:href="qurl.xml">QUrl</db:link> to point both the host and replica nodes to the registry. As the network grows, using a registry means that all nodes only need to connect to the registry via a single <db:link xlink:href="qurl.xml">QUrl</db:link>. With direct connections, nodes would have to maintain a list of <db:link xlink:href="qurl.xml">QUrl</db:link>s for each node they link to.</db:para>
<db:section xml:id="source-code">
<db:title>Source Code</db:title>
<db:para>The <db:code>simpleswitch.h</db:code> and <db:code>simpleswitch.cpp</db:code> sources from <db:link xlink:href="qtremoteobjects-gettingstarted.xml#qtro-example1">Example</db:link> can be used without modification. The difference is in the way a host node is created and connected to the <db:link xlink:href="qtremoteobjects-registry.xml#registry">Registry</db:link>:</db:para>
<db:para><db:code>main.cpp</db:code></db:para>
<db:programlisting language="cpp">#include &amp;lt;QCoreApplication&amp;gt;
#include &quot;simpleswitch.h&quot;

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    SimpleSwitch srcSwitch; // create SimpleSwitch

    QRemoteObjectRegistryHost regNode(QUrl(QStringLiteral(&quot;local:registry&quot;))); // create node that hosts registry
    QRemoteObjectHost srcNode(QUrl(QStringLiteral(&quot;local:switch&quot;)), QUrl(QStringLiteral(&quot;local:registry&quot;))); // create node that will host source and connect to registry
    //Note, you can add srcSwitch directly to regNode if desired.
    //We use two Nodes here, as the regNode could easily be in a third process.

    srcNode.enableRemoting(&amp;amp;srcSwitch); // enable remoting of source object

    return a.exec();
}
</db:programlisting>
</db:section>
<db:section xml:id="replica-code">
<db:title>Replica Code</db:title>
<db:para>The requestor object used for this example is the dynamic replica client discussed in <db:link xlink:href="qtremoteobjects-gettingstarted.xml#qtro-example2">Example 2</db:link>.</db:para>
<db:para>The only modification is in <db:code>main.cpp</db:code>: a <db:link xlink:href="qtremoteobjects-registry.xml#registry">Registry</db:link> node is created to acquire a <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link>:</db:para>
<db:programlisting language="cpp">    QRemoteObjectNode repNode(QUrl(QStringLiteral(&quot;local:registry&quot;)));
</db:programlisting>
<db:para>When executed together with the source-side example, the output is identical to <db:link xlink:href="qtremoteobjects-gettingstarted.xml#qtro-example1">Example 1</db:link>.</db:para>
</db:section>
</db:section>
</db:article>
