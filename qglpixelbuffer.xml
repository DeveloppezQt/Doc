<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QGLPixelBuffer Class</db:title>
<db:productname>QtOpenGL</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>QtOpenGL Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qglpixelbuffer.xml">QGLPixelBuffer</db:link> class encapsulates an OpenGL pbuffer.</db:para>
<db:para><db:emphasis role="bold">This class is deprecated. We strongly advise against using it in new code.</db:emphasis></db:para>
<db:para>This class was introduced in Qt 4.1.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QGLPixelBuffer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.1</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += opengl</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qpaintdevice.xml" xlink:role="class">QPaintDevice</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QGLPixelBuffer is part of <db:simplelist><db:member>painting-3D</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Status</db:term>
<db:listitem>
<db:para>Deprecated</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:para><db:emphasis role="bold">This class is deprecated. We strongly advise against using it in new code.</db:emphasis></db:para>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Rendering into a pbuffer is normally done using full hardware acceleration. This can be significantly faster than rendering into a <db:link xlink:href="qpixmap.xml">QPixmap</db:link>.</db:para>
<db:para>There are three approaches to using this class:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para><db:emphasis role="bold">We can draw into the pbuffer and convert it to a <db:link xlink:href="qimage.xml">QImage</db:link> using <db:link xlink:href="qglpixelbuffer.xml#toImage">toImage</db:link>().</db:emphasis> This is normally much faster than calling <db:link xlink:href="qglwidget.xml#renderPixmap">QGLWidget::renderPixmap</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">We can draw into the pbuffer and copy the contents into an OpenGL texture using <db:link xlink:href="qglpixelbuffer.xml#updateDynamicTexture">updateDynamicTexture</db:link>().</db:emphasis> This allows us to create dynamic textures and works on all systems with pbuffer support.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">On systems that support it, we can bind the pbuffer to an OpenGL texture.</db:emphasis> The texture is then updated automatically when the pbuffer contents change, eliminating the need for additional copy operations. This is supported only on Windows and macOS systems that provide the <db:code>render_texture</db:code> extension. Note that under Windows, a multi-sampled pbuffer can't be used in conjunction with the <db:code>render_texture</db:code> extension. If a multi-sampled pbuffer is requested under Windows, the <db:code>render_texture</db:code> extension is turned off for that pbuffer.</db:para>
</db:listitem>
</db:orderedlist>
<db:note>
<db:para>This class has been deprecated, use <db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link> for offscreen rendering.</db:para>
</db:note>
<db:section xml:id="threading">
<db:title>Threading</db:title>
<db:para>As of Qt 4.8, it's possible to render into a <db:link xlink:href="qglpixelbuffer.xml">QGLPixelBuffer</db:link> using a <db:link xlink:href="qpainter.xml">QPainter</db:link> in a separate thread. Note that OpenGL 2.0 or OpenGL ES 2.0 is required for this to work.</db:para>
<db:para>Pbuffers are provided by the OpenGL <db:code>pbuffer</db:code> extension; call hasOpenGLPbuffer() to find out if the system provides pbuffers.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QGLPixelBuffer">
<db:title>QGLPixelBuffer::QGLPixelBuffer(const QSize &amp;<db:emphasis>size</db:emphasis>, const QGLFormat &amp;<db:emphasis>format</db:emphasis> = QGLFormat::defaultFormat(), QGLWidget *<db:emphasis>shareWidget</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Constructs an OpenGL pbuffer of the given <db:code role="parameter">size</db:code>. If no <db:code role="parameter">format</db:code> is specified, the <db:link xlink:href="qglformat.xml#defaultFormat">default format</db:link> is used. If the <db:code role="parameter">shareWidget</db:code> parameter points to a valid QGLWidget, the pbuffer will share its context with <db:code role="parameter">shareWidget</db:code>.</db:para>
<db:para>If you intend to bind this pbuffer as a dynamic texture, the width and height components of <db:code>size</db:code> must be powers of two (e.g., 512 x 128).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglpixelbuffer.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qglpixelbuffer.xml#format">format</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QGLPixelBuffer-2">
<db:title>QGLPixelBuffer::QGLPixelBuffer(int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, const QGLFormat &amp;<db:emphasis>format</db:emphasis> = QGLFormat::defaultFormat(), QGLWidget *<db:emphasis>shareWidget</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Constructs an OpenGL pbuffer with the <db:code role="parameter">width</db:code> and <db:code role="parameter">height</db:code>. If no <db:code role="parameter">format</db:code> is specified, the <db:link xlink:href="qglformat.xml#defaultFormat">default format</db:link> is used. If the <db:code role="parameter">shareWidget</db:code> parameter points to a valid QGLWidget, the pbuffer will share its context with <db:code role="parameter">shareWidget</db:code>.</db:para>
<db:para>If you intend to bind this pbuffer as a dynamic texture, the width and height components of <db:code>size</db:code> must be powers of two (e.g., 512 x 128).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglpixelbuffer.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qglpixelbuffer.xml#format">format</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QGLPixelBuffer">
<db:title>[virtual noexcept] QGLPixelBuffer::~QGLPixelBuffer()</db:title>
<db:para>Destroys the pbuffer and frees any allocated resources.</db:para>
</db:section>
<db:section xml:id="bindTexture">
<db:title>GLuint QGLPixelBuffer::bindTexture(const QImage &amp;<db:emphasis>image</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>Generates and binds a 2D GL texture to the current context, based on <db:code role="parameter">image</db:code>. The generated texture id is returned and can be used in later glBindTexture() calls.</db:para>
<db:para>The <db:code role="parameter">target</db:code> parameter specifies the texture target.</db:para>
<db:para>Equivalent to calling <db:link xlink:href="qglcontext.xml#bindTexture">QGLContext::bindTexture</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglpixelbuffer.xml#deleteTexture">deleteTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindTexture-1">
<db:title>GLuint QGLPixelBuffer::bindTexture(const QString &amp;<db:emphasis>fileName</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Reads the DirectDrawSurface (DDS) compressed file <db:code role="parameter">fileName</db:code> and generates a 2D GL texture from it.</db:para>
<db:para>Equivalent to calling <db:link xlink:href="qglcontext.xml#bindTexture">QGLContext::bindTexture</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglpixelbuffer.xml#deleteTexture">deleteTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindTexture-2">
<db:title>GLuint QGLPixelBuffer::bindTexture(const QPixmap &amp;<db:emphasis>pixmap</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Generates and binds a 2D GL texture based on <db:code role="parameter">pixmap</db:code>.</db:para>
<db:para>Equivalent to calling <db:link xlink:href="qglcontext.xml#bindTexture">QGLContext::bindTexture</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglpixelbuffer.xml#deleteTexture">deleteTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindToDynamicTexture">
<db:title>bool QGLPixelBuffer::bindToDynamicTexture(GLuint <db:emphasis>texture_id</db:emphasis>)</db:title>
<db:para>Binds the texture specified by <db:code role="parameter">texture_id</db:code> to this pbuffer. Returns <db:code>true</db:code> on success; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The texture must be of the same size and format as the pbuffer.</db:para>
<db:para>To unbind the texture, call <db:link xlink:href="qglpixelbuffer.xml#releaseFromDynamicTexture">releaseFromDynamicTexture</db:link>(). While the texture is bound, it is updated automatically when the pbuffer contents change, eliminating the need for additional copy operations.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QGLPixelBuffer pbuffer(...);
...
pbuffer.makeCurrent();
GLuint dynamicTexture = pbuffer.generateDynamicTexture();
pbuffer.bindToDynamicTexture(dynamicTexture);
...
pbuffer.releaseFromDynamicTexture();
</db:programlisting>
<db:warning>
<db:para>This function uses the <db:code>render_texture</db:code> extension, which is currently not supported under X11. An alternative that works on all systems (including X11) is to manually copy the pbuffer contents to a texture using <db:link xlink:href="qglpixelbuffer.xml#updateDynamicTexture">updateDynamicTexture</db:link>().</db:para>
</db:warning>
<db:warning>
<db:para>For the bindToDynamicTexture() call to succeed on the macOS, the pbuffer needs a shared context, i.e. the <db:link xlink:href="qglpixelbuffer.xml" role="deprecated">QGLPixelBuffer</db:link> must be created with a share widget.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglpixelbuffer.xml#generateDynamicTexture">generateDynamicTexture</db:link>()</db:member>
<db:member><db:link xlink:href="qglpixelbuffer.xml#releaseFromDynamicTexture">releaseFromDynamicTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="context">
<db:title>QGLContext *QGLPixelBuffer::context() const</db:title>
<db:para>Returns the context of this pixelbuffer.</db:para>
</db:section>
<db:section xml:id="deleteTexture">
<db:title>void QGLPixelBuffer::deleteTexture(GLuint <db:emphasis>texture_id</db:emphasis>)</db:title>
<db:para>Removes the texture identified by <db:code role="parameter">texture_id</db:code> from the texture cache.</db:para>
<db:para>Equivalent to calling <db:link xlink:href="qglcontext.xml#deleteTexture">QGLContext::deleteTexture</db:link>().</db:para>
</db:section>
<db:section xml:id="doneCurrent">
<db:title>bool QGLPixelBuffer::doneCurrent()</db:title>
<db:para>Makes no context the current OpenGL context. Returns <db:code>true</db:code> on success; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="drawTexture">
<db:title>[since 4.4] void QGLPixelBuffer::drawTexture(const QPointF &amp;<db:emphasis>point</db:emphasis>, GLuint <db:emphasis>textureId</db:emphasis>, GLenum <db:emphasis>textureTarget</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>Draws the given texture, <db:code role="parameter">textureId</db:code>, at the given <db:code role="parameter">point</db:code> in OpenGL model space. The textureTarget parameter should be a 2D texture target.</db:para>
<db:para>Equivalent to the corresponding <db:link xlink:href="qglcontext.xml#drawTexture">QGLContext::drawTexture</db:link>().</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
</db:section>
<db:section xml:id="drawTexture-1">
<db:title>[since 4.4] void QGLPixelBuffer::drawTexture(const QRectF &amp;<db:emphasis>target</db:emphasis>, GLuint <db:emphasis>textureId</db:emphasis>, GLenum <db:emphasis>textureTarget</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>Draws the given texture, <db:code role="parameter">textureId</db:code>, to the given target rectangle, <db:code role="parameter">target</db:code>, in OpenGL model space. The <db:code role="parameter">textureTarget</db:code> should be a 2D texture target.</db:para>
<db:para>Equivalent to the corresponding <db:link xlink:href="qglcontext.xml#drawTexture">QGLContext::drawTexture</db:link>().</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
</db:section>
<db:section xml:id="format">
<db:title>QGLFormat QGLPixelBuffer::format() const</db:title>
<db:para>Returns the format of the pbuffer. The format may be different from the one that was requested.</db:para>
</db:section>
<db:section xml:id="generateDynamicTexture">
<db:title>GLuint QGLPixelBuffer::generateDynamicTexture() const</db:title>
<db:para>Generates and binds a 2D GL texture that is the same size as the pbuffer, and returns the texture's ID. This can be used in conjunction with <db:link xlink:href="qglpixelbuffer.xml#bindToDynamicTexture">bindToDynamicTexture</db:link>() and <db:link xlink:href="qglpixelbuffer.xml#updateDynamicTexture">updateDynamicTexture</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglpixelbuffer.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="handle">
<db:title>Qt::HANDLE QGLPixelBuffer::handle() const</db:title>
<db:para>Returns the native pbuffer handle.</db:para>
</db:section>
<db:section xml:id="hasOpenGLPbuffers">
<db:title>[static] bool QGLPixelBuffer::hasOpenGLPbuffers()</db:title>
<db:para>Returns <db:code>true</db:code> if the OpenGL <db:code>pbuffer</db:code> extension is present on this system; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QGLPixelBuffer::isValid() const</db:title>
<db:para>Returns <db:code>true</db:code> if this pbuffer is valid; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="makeCurrent">
<db:title>bool QGLPixelBuffer::makeCurrent()</db:title>
<db:para>Makes this pbuffer the current OpenGL rendering context. Returns true on success; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglcontext.xml#makeCurrent">QGLContext::makeCurrent</db:link>()</db:member>
<db:member><db:link xlink:href="qglpixelbuffer.xml#doneCurrent">doneCurrent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="metric">
<db:title>[override virtual protected] int QGLPixelBuffer::metric(QPaintDevice::PaintDeviceMetric <db:emphasis>metric</db:emphasis>) const</db:title>
<db:para>Reimplements: <db:link xlink:href="qpaintdevice.xml#metric" role="function">QPaintDevice::metric(QPaintDevice::PaintDeviceMetric metric) const</db:link>.</db:para>
</db:section>
<db:section xml:id="paintEngine">
<db:title>[override virtual] QPaintEngine *QGLPixelBuffer::paintEngine() const</db:title>
<db:para>Reimplements: <db:link xlink:href="qpaintdevice.xml#paintEngine" role="function">QPaintDevice::paintEngine() const</db:link>.</db:para>
</db:section>
<db:section xml:id="releaseFromDynamicTexture">
<db:title>void QGLPixelBuffer::releaseFromDynamicTexture()</db:title>
<db:para>Releases the pbuffer from any previously bound texture.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglpixelbuffer.xml#bindToDynamicTexture">bindToDynamicTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>QSize QGLPixelBuffer::size() const</db:title>
<db:para>Returns the size of the pbuffer.</db:para>
</db:section>
<db:section xml:id="toImage">
<db:title>QImage QGLPixelBuffer::toImage() const</db:title>
<db:para>Returns the contents of the pbuffer as a <db:link xlink:href="qimage.xml">QImage</db:link>.</db:para>
</db:section>
<db:section xml:id="updateDynamicTexture">
<db:title>void QGLPixelBuffer::updateDynamicTexture(GLuint <db:emphasis>texture_id</db:emphasis>) const</db:title>
<db:para>Copies the pbuffer contents into the texture specified with <db:code role="parameter">texture_id</db:code>.</db:para>
<db:para>The texture must be of the same size and format as the pbuffer.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QGLPixelBuffer pbuffer(...);
...
pbuffer.makeCurrent();
GLuint dynamicTexture = pbuffer.generateDynamicTexture();
...
pbuffer.updateDynamicTexture(dynamicTexture);
</db:programlisting>
<db:para>An alternative on Windows and macOS systems that support the <db:code>render_texture</db:code> extension is to use <db:link xlink:href="qglpixelbuffer.xml#bindToDynamicTexture">bindToDynamicTexture</db:link>() to get dynamic updates of the texture.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglpixelbuffer.xml#generateDynamicTexture">generateDynamicTexture</db:link>()</db:member>
<db:member><db:link xlink:href="qglpixelbuffer.xml#bindToDynamicTexture">bindToDynamicTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
