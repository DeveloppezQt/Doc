<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Port QML modules to CMake</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Qml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Port your QML modules to the qt_add_qml_module CMake API.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>QML modules have become more powerful and easier to use in Qt 6. The following sections describe how to port QML modules to the <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> CMake API.</db:para>
<db:para>See also <db:link xlink:href="qt6-modernize-qml-modules.xml">Modern QML modules</db:link> on how to modernize a QML module that already uses <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link>.</db:para>
<db:section xml:id="identify-issues-to-fix">
<db:title>Identify issues to fix</db:title>
<db:para>Use <db:link xlink:href="qtqml-tooling-qmllint.xml">qmllint</db:link> to support you through the process.</db:para>
<db:para>Each QML module defined with <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> has a _qmllint CMake target that you can use to identify potential issues or improvements. For a QML module called MyQmlLibrary use MyQmlLibrary_qmllint, for example. To run <db:link xlink:href="qtqml-tooling-qmllint.xml">qmllint</db:link> on all QML modules, use all_qmllint.</db:para>
<db:para>The warning categories of <db:link xlink:href="qtqml-tooling-qmllint.xml">qmllint</db:link> that hint at QML module issues are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qmllint-warnings-and-errors-import.xml">[import]</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qmllint-warnings-and-errors-unused-imports.xml">[unused-imports]</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qmllint-warnings-and-errors-unresolved-type.xml">[unresolved-type]</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qmllint-warnings-and-errors-unresolved-alias.xml">[unresolved-alias]</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qmllint-warnings-and-errors-missing-enum-entry.xml">[missing-enum-entry]</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qmllint-warnings-and-errors-missing-property.xml">[missing-property]</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qmllint-warnings-and-errors-missing-type.xml">[missing-type]</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="prepare-the-project-for-qt-add-qml-module">
<db:title>Prepare the project for qt_add_qml_module</db:title>
<db:section xml:id="make-qt-add-qml-module-available-in-cmake">
<db:title>Make qt_add_qml_module available in CMake</db:title>
<db:para>To make <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> available in CMake, add Core and Qml to your find_package call in the project's top-level CMakeLists.txt file:</db:para>
<db:programlisting language="cpp" role="bad">find_package(Qt6 REQUIRED COMPONENTS Core Qml)
</db:programlisting>
</db:section>
<db:section xml:id="use-qt-standard-project-setup">
<db:title>Use qt_standard_project_setup</db:title>
<db:para><db:link xlink:href="qt-standard-project-setup.xml">qt_standard_project_setup</db:link> sets up <db:link xlink:href="">Qt CMake policies</db:link> needed for <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link>, among other things.</db:para>
<db:para>Call <db:link xlink:href="qt-standard-project-setup.xml">qt_standard_project_setup</db:link> in the project's top-level CMakeLists.txt file before any <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> call:</db:para>
<db:programlisting language="cpp" role="bad">qt_standard_project_setup(REQUIRES 6.8)
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="use-qt-add-qml-module">
<db:title>Use qt_add_qml_module</db:title>
<db:para><db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> is the CMake function that takes care of generating QML modules. It automatically generates qmldir and qmltypes files, and sets up tooling like <db:link xlink:href="qtqml-tool-qmlcachegen.xml">qmlcachegen</db:link> or <db:link xlink:href="qtqml-tooling-qmllint.xml">qmllint</db:link>.</db:para>
<db:para>QML modules can be added to both executable and library targets in CMake. QML modules attached to the executable target can't be used or linked by other executables, while QML modules attached to library targets can.</db:para>
<db:section xml:id="add-a-qml-module-to-your-executable-target">
<db:title>Add a QML module to your executable target</db:title>
<db:para>In this case, the source files of the QML module are treated as part of the executable itself, rather than being compiled into a separate library. This means neither a module nor plugin library for this module is created—–the module is fully integrated into the executable. As a result, the module is tied to that specific program and cannot be reused by other executables or libraries.</db:para>
<db:para>To add a QML module to your executable, in your CMakeLists.txt:</db:para>
<db:programlisting language="cpp" role="bad"># pre-existing:
qt_add_executable(MyApp main.cpp)

# add this
qt_add_qml_module(MyApp
    URI MyAppModule
    QML_FILES
        Main.qml # and possibly more .qml files
)
</db:programlisting>
<db:para>The Main.qml should start with an upper case letter so that it can be instantiated by loadFromModule methods like <db:link xlink:href="qqmlapplicationengine.xml#loadFromModule">QQmlApplicationEngine::loadFromModule</db:link> or <db:link xlink:href="qqmlcomponent.xml#loadFromModule">QQmlComponent::loadFromModule</db:link>. Also, the QML module URI should be different from the target name to avoid name clashes in the build folder.</db:para>
</db:section>
<db:section xml:id="add-a-qml-module-to-your-library-target">
<db:title>Add a QML module to your library target</db:title>
<db:para>To add a QML module to your library, in your CMakeLists.txt:</db:para>
<db:programlisting language="cpp" role="bad">qt_add_qml_module(MyQmlLibrary
    URI MyQmlModule
    QML_FILES MyQmlComponent1.qml MyQmlComponent2.qml...
    SOURCES MyCppComponent1.h MyCppComponent1.cpp MyCppComponent2.h MyCppComponent2.cpp...
    RESOURCES MyResource1.png MyResource2.png...
)
</db:programlisting>
<db:para><db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> creates a SHARED library via <db:link xlink:href="qt-add-library.xml">qt_add_library</db:link> if the MyQmlLibrary target does not exist yet, like in this example.</db:para>
<db:note>
<db:para>Your QML module URI should be different from the target name to avoid name clashes in the build folder.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="use-loadfrommodule-to-load-your-qml-files">
<db:title>Use loadFromModule to load your QML files</db:title>
<db:para>Use loadFromModule to load your QML file, for example:</db:para>
<db:programlisting language="cpp" role="bad">engine.load(QUrl(QStringLiteral(&quot;qrc:/MyQmlModule/Main.qml&quot;)));
// becomes
engine.loadFromModule(&quot;MyQmlModule&quot;, &quot;Main&quot;);
</db:programlisting>
</db:section>
<db:section xml:id="remove-handwritten-qmldir-files">
<db:title>Remove handwritten qmldir files</db:title>
<db:para><db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> automatically generates qmldir files. If you have singletons in your qmldir, declare them in your CMakeLists.txt before the <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> call with:</db:para>
<db:programlisting language="cpp" role="bad">set_source_files_properties(MySingleton.qml PROPERTIES QT_QML_SINGLETON_TYPE TRUE)
</db:programlisting>
<db:para>Delete the handwritten qmldir after that.</db:para>
</db:section>
<db:section xml:id="remove-qmltypes-files-generated-by-qmlplugindump">
<db:title>Remove qmltypes files generated by qmlplugindump</db:title>
<db:para><db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> auto-generates qmltypes files when all your types are using <db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-c-types-with-the-qml-type-system">declarative type registration</db:link>, which removes the need to generate qmltypes files by hand using tools like qmlplugindump.</db:para>
<db:para>To achieve that, remove manual calls to qmlRegisterType and its variants. Then, <db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-c-types-with-the-qml-type-system">register your types declaratively</db:link> by using <db:link xlink:href="qqmlintegration-h.xml#QML_ELEMENT">QML_ELEMENT</db:link>, for example:</db:para>
<db:programlisting language="cpp" role="bad">// add this header
#include &lt;QtQml/qqmlregistrations.h&gt;

class MyComponent: public QObject {
    Q_OBJECT

    // add this line to register MyComponent as 'MyComponent' in QML.
    QML_ELEMENT
    ....
};
</db:programlisting>
<db:para>See <db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-c-types-with-the-qml-type-system">Registering C++ Types with the QML Type System</db:link> on how to handle more complicated registration cases like foreign type registration.</db:para>
<db:para>Delete the handwritten qmltypes files after that.</db:para>
</db:section>
<db:section xml:id="remove-handwritten-type-registration-plugins">
<db:title>Remove handwritten type registration plugins</db:title>
<db:para><db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> can generate a <db:link xlink:href="qtqml-modules-cppplugins.xml">QML module plugin</db:link> automatically for you. You don't need a handwritten plugin if your plugin's only task is to do type registration. Remove the plugin altogether if switching to declarative type registration did remove all the code from your plugin.</db:para>
<db:para>Make sure that you <db:emphasis>remove</db:emphasis> the NO_PLUGIN, NO_PLUGIN_OPTIONAL, NO_CREATE_PLUGIN_TARGET, and NO_GENERATE_PLUGIN_SOURCE arguments from <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> to allow automatic plugin generation.</db:para>
</db:section>
<db:section xml:id="remove-qrc-files">
<db:title>Remove qrc files</db:title>
<db:para><db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> automatically generates qrc files. To list resources in the qrc files, like images or sound files, add them to <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link>'s RESOURCES argument. You can find the Module's resources under :/qt/qml/MyQmlLibraryModule/.</db:para>
</db:section>
<db:section xml:id="replace-directory-imports-with-qml-module-imports">
<db:title>Replace directory imports with QML module imports</db:title>
<db:para>Replace directory imports with QML module imports. For example,</db:para>
<db:programlisting language="cpp" role="bad">import &quot;content&quot; // contains SomeType.qml
// becomes
import MyQmlModule // contains SomeType.qml

SomeType {
    ...
}
</db:programlisting>
<db:para>Note that files inside a QML module automatically import their own QML module. You can remove the self-imports.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-changes-qt6.xml">Changes to Qt QML</db:link></db:member>
<db:member><db:link xlink:href="qt6-modernize-qml-modules.xml">Modern QML modules</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
