<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QScxmlStateMachine Class</db:title>
<db:productname>QtScxml</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt SCXML Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qscxmlstatemachine.xml">QScxmlStateMachine</db:link> class provides an interface to the state machines created from SCXML files.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QScxmlStateMachine</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Scxml)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Scxml)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += scxml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Instantiated By</db:term>
<db:listitem>
<db:para>qml-qtscxml-scxmlstatemachine.xml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qscxmlstatemachine.xml">QScxmlStateMachine</db:link> is an implementation of the <db:link xlink:href="http://www.w3.org/TR/scxml/">State Chart XML (SCXML)</db:link>.</db:para>
<db:para>All states that are defined in the SCXML file are accessible as properties of <db:link xlink:href="qscxmlstatemachine.xml">QScxmlStateMachine</db:link>. These properties are boolean values and indicate whether the state is active or inactive.</db:para>
<db:note>
<db:para>The <db:link xlink:href="qscxmlstatemachine.xml">QScxmlStateMachine</db:link> needs a <db:link xlink:href="qeventloop.xml">QEventLoop</db:link> to work correctly. The event loop is used to implement the <db:code>delay</db:code> attribute for events and to schedule the processing of a state machine when events are received from nested (or parent) state machines.</db:para>
</db:note>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="dataModel-prop">
<db:title>[bindable] dataModel : QScxmlDataModel*</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QScxmlDataModel*</db:type>
<db:varname>dataModel</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">dataModel</db:synopsisinfo>
<db:synopsisinfo role="setter">setDataModel</db:synopsisinfo>
<db:synopsisinfo role="notifier">dataModelChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>This property holds the data model to be used for this state machine.</db:para>
<db:para>SCXML data models are described in <db:link xlink:href="https://www.w3.org/TR/scxml/#data-module">SCXML Specification - 5 Data Model and Data Manipulation</db:link>. For more information about supported data models, see <db:link xlink:href="qtscxml-scxml-compliance.xml">SCXML Compliance</db:link>.</db:para>
<db:para>Changing the data model when the state machine has been <db:code>initialized</db:code> is not specified in the SCXML standard and leads to undefined behavior.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmldatamodel.xml">QScxmlDataModel</db:link></db:member>
<db:member><db:link xlink:href="qscxmlnulldatamodel.xml">QScxmlNullDataModel</db:link></db:member>
<db:member><db:link xlink:href="qscxmlcppdatamodel.xml">QScxmlCppDataModel</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="initialValues-prop">
<db:title>[bindable] initialValues : QVariantMap</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QVariantMap</db:type>
<db:varname>initialValues</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">initialValues</db:synopsisinfo>
<db:synopsisinfo role="setter">setInitialValues</db:synopsisinfo>
<db:synopsisinfo role="notifier">initialValuesChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>This property holds the initial values to be used for setting up the data model.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#init">QScxmlStateMachine::init</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmldatamodel.xml">QScxmlDataModel</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="initialized-prop">
<db:title>[bindable read-only] initialized : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>initialized</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isInitialized</db:synopsisinfo>
<db:synopsisinfo role="notifier">initializedChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>This property holds whether the state machine has been initialized.</db:para>
<db:para>It is <db:code>true</db:code> if the state machine has been initialized, <db:code>false</db:code> otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#init">QScxmlStateMachine::init</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmldatamodel.xml">QScxmlDataModel</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="invoked-prop">
<db:title>[read-only] invoked : const bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>invoked</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isInvoked</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether the state machine was invoked from an outer state machine.</db:para>
<db:para><db:code>true</db:code> when the state machine was started as a service with the <db:code>&lt;invoke&gt;</db:code> element, <db:code>false</db:code> otherwise.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isInvoked</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="invokedServices-prop">
<db:title>[bindable read-only] invokedServices : QList&lt;QScxmlInvokableService*&gt;</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QList&lt;QScxmlInvokableService*&gt;</db:type>
<db:varname>invokedServices</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">invokedServices</db:synopsisinfo>
<db:synopsisinfo role="notifier">invokedServicesChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>This property holds a list of SCXML services that were invoked from the main state machine (possibly recursively).</db:para>
</db:section>
<db:section xml:id="loader-prop">
<db:title>[bindable] loader : QScxmlCompiler::Loader*</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QScxmlCompiler::Loader*</db:type>
<db:varname>loader</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">loader</db:synopsisinfo>
<db:synopsisinfo role="setter">setLoader</db:synopsisinfo>
<db:synopsisinfo role="notifier">loaderChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>This property holds the loader that is currently used to resolve and load URIs for the state machine.</db:para>
</db:section>
<db:section xml:id="name-prop">
<db:title>[read-only] name : const QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>name</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">name</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the name of the state machine as set by the <db:emphasis>name</db:emphasis> attribute of the <db:code>&lt;scxml&gt;</db:code> tag.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">name</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="parseErrors-prop">
<db:title>[read-only] parseErrors : const QList&lt;QScxmlError&gt;</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QList&lt;QScxmlError&gt;</db:type>
<db:varname>parseErrors</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">parseErrors</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the list of parse errors that occurred while creating a state machine from an SCXML file.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qlist.xml">QList</db:link></db:type>&lt;<db:type><db:link xlink:href="qscxmlerror.xml">QScxmlError</db:link></db:type>&gt; <db:emphasis role="bold">parseErrors</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="running-prop">
<db:title>running : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>running</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isRunning</db:synopsisinfo>
<db:synopsisinfo role="setter">setRunning</db:synopsisinfo>
<db:synopsisinfo role="notifier">runningChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the running state of this state machine</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold"><db:link xlink:href="qscxmlstatemachine.xml#isRunning">isRunning</db:link></db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qscxmlstatemachine.xml#setRunning">setRunning</db:link></db:emphasis>(<db:type>bool</db:type> <db:emphasis>running</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qscxmlstatemachine.xml#runningChanged">runningChanged</db:link></db:emphasis>(<db:type>bool</db:type> <db:emphasis>running</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#start">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sessionId-prop">
<db:title>[read-only] sessionId : const QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>sessionId</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">sessionId</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the session ID of the current state machine.</db:para>
<db:para>The session ID is used for message routing between parent and child state machines. If a state machine is started by an <db:code>&lt;invoke&gt;</db:code> element, any event it sends will have the <db:code>invokeid</db:code> field set to the session ID. The state machine will use the origin of an event (which is set by the <db:emphasis>target</db:emphasis> or <db:emphasis>targetexpr</db:emphasis> attribute in a <db:code>&lt;send&gt;</db:code> element) to dispatch messages to the correct child state machine.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">sessionId</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlevent.xml#invokeId">QScxmlEvent::invokeId</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="tableData-prop">
<db:title>[bindable] tableData : QScxmlTableData*</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QScxmlTableData*</db:type>
<db:varname>tableData</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">tableData</db:synopsisinfo>
<db:synopsisinfo role="setter">setTableData</db:synopsisinfo>
<db:synopsisinfo role="notifier">tableDataChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>This property holds the table data that is used when generating C++ from an SCXML file.</db:para>
<db:para>The class implementing the state machine will use this property to assign the generated table data. The state machine does not assume ownership of the table data.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="activeStateNames">
<db:title>QStringList QScxmlStateMachine::activeStateNames(bool <db:emphasis>compress</db:emphasis> = true) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>activeStateNames</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>compress</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList activeStateNames(bool compress) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Retrieves a list of state names of all active states.</db:para>
<db:para>When a state is active, all its parent states are active by definition. When <db:code role="parameter">compress</db:code> is <db:code>true</db:code> (the default), the parent states will be filtered out and only the <db:emphasis>leaf states</db:emphasis> will be returned. When it is <db:code>false</db:code>, the full list of active states will be returned.</db:para>
</db:section>
<db:section xml:id="cancelDelayedEvent">
<db:title>void QScxmlStateMachine::cancelDelayedEvent(const QString &amp;<db:emphasis>sendId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>cancelDelayedEvent</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>sendId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void cancelDelayedEvent(const QString &amp;sendId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Cancels a delayed event with the specified <db:code role="parameter">sendId</db:code>.</db:para>
</db:section>
<db:section xml:id="connectToEvent">
<db:title>QMetaObject::Connection QScxmlStateMachine::connectToEvent(const QString &amp;<db:emphasis>scxmlEventSpec</db:emphasis>, const QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>method</db:emphasis>, Qt::ConnectionType <db:emphasis>type</db:emphasis> = Qt::AutoConnection)</db:title>
<db:methodsynopsis>
<db:type>QMetaObject::Connection</db:type>
<db:methodname>connectToEvent</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>scxmlEventSpec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ConnectionType</db:type>
<db:parameter>type</db:parameter>
<db:initializer>Qt::AutoConnection</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaObject::Connection connectToEvent(const QString &amp;scxmlEventSpec, const QObject *receiver, const char *method, Qt::ConnectionType type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a connection of the specified <db:code role="parameter">type</db:code> from the event specified by <db:code role="parameter">scxmlEventSpec</db:code> to the <db:code role="parameter">method</db:code> in the <db:code role="parameter">receiver</db:code> object. The receiver's <db:code role="parameter">method</db:code> may take a <db:link xlink:href="qscxmlevent.xml">QScxmlEvent</db:link> as a parameter. For example:</db:para>
<db:programlisting language="cpp">void mySlot(const QScxmlEvent &amp;amp;event);
</db:programlisting>
<db:para>In contrast to event specifications in SCXML documents, spaces are not allowed in the <db:code role="parameter">scxmlEventSpec</db:code> here. In order to connect to multiple events with different prefixes, connectToEvent() has to be called multiple times.</db:para>
<db:para>Returns a handle to the connection, which can be used later to disconnect.</db:para>
</db:section>
<db:section xml:id="connectToEvent-1">
<db:title>QMetaObject::Connection QScxmlStateMachine::connectToEvent(const QString &amp;<db:emphasis>scxmlEventSpec</db:emphasis>, const typename QtPrivate::FunctionPointer&lt;PointerToMemberFunction&gt;::Object *<db:emphasis>receiver</db:emphasis>, PointerToMemberFunction <db:emphasis>method</db:emphasis>, Qt::ConnectionType <db:emphasis>type</db:emphasis> = Qt::AutoConnection)</db:title>
<db:methodsynopsis>
<db:type>QMetaObject::Connection</db:type>
<db:methodname>connectToEvent</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>scxmlEventSpec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const typename QtPrivate::FunctionPointer&lt;PointerToMemberFunction&gt;::Object *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>PointerToMemberFunction</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ConnectionType</db:type>
<db:parameter>type</db:parameter>
<db:initializer>Qt::AutoConnection</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaObject::Connection connectToEvent(const QString &amp;scxmlEventSpec, const typename QtPrivate::FunctionPointer&lt;PointerToMemberFunction&gt;::Object *receiver, PointerToMemberFunction method, Qt::ConnectionType type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a connection of the given <db:code role="parameter">type</db:code> from the event specified by <db:code role="parameter">scxmlEventSpec</db:code> to <db:code role="parameter">method</db:code> in the <db:code role="parameter">receiver</db:code> object.</db:para>
<db:para>The receiver's <db:code role="parameter">method</db:code> must take a <db:link xlink:href="qscxmlevent.xml">QScxmlEvent</db:link> as a parameter.</db:para>
<db:para>In contrast to event specifications in SCXML documents, spaces are not allowed in the <db:code role="parameter">scxmlEventSpec</db:code> here. In order to connect to multiple events with different prefixes, <db:link xlink:href="qscxmlstatemachine.xml#connectToEvent">connectToEvent</db:link>() has to be called multiple times.</db:para>
<db:para>Returns a handle to the connection, which can be used later to disconnect.</db:para>
</db:section>
<db:section xml:id="connectToEvent-2">
<db:title>typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Functor&gt;::IsPointerToMemberFunction &amp;&amp; !std::is_same&lt;const char *, Functor&gt;::value, QMetaObject::Connection&gt;::type QScxmlStateMachine::connectToEvent(const QString &amp;<db:emphasis>scxmlEventSpec</db:emphasis>, Functor <db:emphasis>functor</db:emphasis>, Qt::ConnectionType <db:emphasis>type</db:emphasis> = Qt::AutoConnection)</db:title>
<db:methodsynopsis>
<db:type>typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Functor&gt;::IsPointerToMemberFunction &amp;&amp; !std::is_same&lt;const char *, Functor&gt;::value, QMetaObject::Connection&gt;::type</db:type>
<db:methodname>connectToEvent</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>scxmlEventSpec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>functor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ConnectionType</db:type>
<db:parameter>type</db:parameter>
<db:initializer>Qt::AutoConnection</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Functor&gt;::IsPointerToMemberFunction &amp;&amp; !std::is_same&lt;const char *, Functor&gt;::value, QMetaObject::Connection&gt;::type connectToEvent(const QString &amp;scxmlEventSpec, Functor functor, Qt::ConnectionType type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a connection of the given <db:code role="parameter">type</db:code> from the event specified by <db:code role="parameter">scxmlEventSpec</db:code> to <db:code role="parameter">functor</db:code>.</db:para>
<db:para>The <db:code role="parameter">functor</db:code> must take a <db:link xlink:href="qscxmlevent.xml">QScxmlEvent</db:link> as a parameter.</db:para>
<db:para>In contrast to event specifications in SCXML documents, spaces are not allowed in the <db:code role="parameter">scxmlEventSpec</db:code> here. In order to connect to multiple events with different prefixes, <db:link xlink:href="qscxmlstatemachine.xml#connectToEvent">connectToEvent</db:link>() has to be called multiple times.</db:para>
<db:para>Returns a handle to the connection, which can be used later to disconnect.</db:para>
</db:section>
<db:section xml:id="connectToEvent-3">
<db:title>typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Functor&gt;::IsPointerToMemberFunction &amp;&amp; !std::is_same&lt;const char *, Functor&gt;::value, QMetaObject::Connection&gt;::type QScxmlStateMachine::connectToEvent(const QString &amp;<db:emphasis>scxmlEventSpec</db:emphasis>, const QObject *<db:emphasis>context</db:emphasis>, Functor <db:emphasis>functor</db:emphasis>, Qt::ConnectionType <db:emphasis>type</db:emphasis> = Qt::AutoConnection)</db:title>
<db:methodsynopsis>
<db:type>typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Functor&gt;::IsPointerToMemberFunction &amp;&amp; !std::is_same&lt;const char *, Functor&gt;::value, QMetaObject::Connection&gt;::type</db:type>
<db:methodname>connectToEvent</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>scxmlEventSpec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>context</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>functor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ConnectionType</db:type>
<db:parameter>type</db:parameter>
<db:initializer>Qt::AutoConnection</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Functor&gt;::IsPointerToMemberFunction &amp;&amp; !std::is_same&lt;const char *, Functor&gt;::value, QMetaObject::Connection&gt;::type connectToEvent(const QString &amp;scxmlEventSpec, const QObject *context, Functor functor, Qt::ConnectionType type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a connection of the given <db:code role="parameter">type</db:code> from the event specified by <db:code role="parameter">scxmlEventSpec</db:code> to <db:code role="parameter">functor</db:code> using <db:code role="parameter">context</db:code> as context.</db:para>
<db:para>The <db:code role="parameter">functor</db:code> must take a <db:link xlink:href="qscxmlevent.xml">QScxmlEvent</db:link> as a parameter.</db:para>
<db:para>In contrast to event specifications in SCXML documents, spaces are not allowed in the <db:code role="parameter">scxmlEventSpec</db:code> here. In order to connect to multiple events with different prefixes, <db:link xlink:href="qscxmlstatemachine.xml#connectToEvent">connectToEvent</db:link>() has to be called multiple times.</db:para>
<db:para>Returns a handle to the connection, which can be used later to disconnect.</db:para>
</db:section>
<db:section xml:id="connectToState">
<db:title>QMetaObject::Connection QScxmlStateMachine::connectToState(const QString &amp;<db:emphasis>scxmlStateName</db:emphasis>, const QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>method</db:emphasis>, Qt::ConnectionType <db:emphasis>type</db:emphasis> = Qt::AutoConnection)</db:title>
<db:methodsynopsis>
<db:type>QMetaObject::Connection</db:type>
<db:methodname>connectToState</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>scxmlStateName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ConnectionType</db:type>
<db:parameter>type</db:parameter>
<db:initializer>Qt::AutoConnection</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaObject::Connection connectToState(const QString &amp;scxmlStateName, const QObject *receiver, const char *method, Qt::ConnectionType type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a connection of the given <db:code role="parameter">type</db:code> from the state identified by <db:code role="parameter">scxmlStateName</db:code> to the <db:code role="parameter">method</db:code> in the <db:code role="parameter">receiver</db:code> object. The receiver's <db:code role="parameter">method</db:code> may take a boolean argument that indicates whether the state connected became active or inactive. For example:</db:para>
<db:programlisting language="cpp">void mySlot(bool active);
</db:programlisting>
<db:para>Returns a handle to the connection, which can be used later to disconnect.</db:para>
</db:section>
<db:section xml:id="connectToState-1">
<db:title>QMetaObject::Connection QScxmlStateMachine::connectToState(const QString &amp;<db:emphasis>scxmlStateName</db:emphasis>, const typename QtPrivate::FunctionPointer&lt;PointerToMemberFunction&gt;::Object *<db:emphasis>receiver</db:emphasis>, PointerToMemberFunction <db:emphasis>method</db:emphasis>, Qt::ConnectionType <db:emphasis>type</db:emphasis> = Qt::AutoConnection)</db:title>
<db:methodsynopsis>
<db:type>QMetaObject::Connection</db:type>
<db:methodname>connectToState</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>scxmlStateName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const typename QtPrivate::FunctionPointer&lt;PointerToMemberFunction&gt;::Object *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>PointerToMemberFunction</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ConnectionType</db:type>
<db:parameter>type</db:parameter>
<db:initializer>Qt::AutoConnection</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaObject::Connection connectToState(const QString &amp;scxmlStateName, const typename QtPrivate::FunctionPointer&lt;PointerToMemberFunction&gt;::Object *receiver, PointerToMemberFunction method, Qt::ConnectionType type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a connection of the given <db:code role="parameter">type</db:code> from the state specified by <db:code role="parameter">scxmlStateName</db:code> to <db:code role="parameter">method</db:code> in the <db:code role="parameter">receiver</db:code> object.</db:para>
<db:para>The receiver's <db:code role="parameter">method</db:code> must take a boolean argument that indicates whether the state connected became active or inactive.</db:para>
<db:para>Returns a handle to the connection, which can be used later to disconnect.</db:para>
</db:section>
<db:section xml:id="connectToState-2">
<db:title>typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Functor&gt;::IsPointerToMemberFunction &amp;&amp; !std::is_same&lt;const char *, Functor&gt;::value, QMetaObject::Connection&gt;::type QScxmlStateMachine::connectToState(const QString &amp;<db:emphasis>scxmlStateName</db:emphasis>, Functor <db:emphasis>functor</db:emphasis>, Qt::ConnectionType <db:emphasis>type</db:emphasis> = Qt::AutoConnection)</db:title>
<db:methodsynopsis>
<db:type>typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Functor&gt;::IsPointerToMemberFunction &amp;&amp; !std::is_same&lt;const char *, Functor&gt;::value, QMetaObject::Connection&gt;::type</db:type>
<db:methodname>connectToState</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>scxmlStateName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>functor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ConnectionType</db:type>
<db:parameter>type</db:parameter>
<db:initializer>Qt::AutoConnection</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Functor&gt;::IsPointerToMemberFunction &amp;&amp; !std::is_same&lt;const char *, Functor&gt;::value, QMetaObject::Connection&gt;::type connectToState(const QString &amp;scxmlStateName, Functor functor, Qt::ConnectionType type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a connection of the given <db:code role="parameter">type</db:code> from the state specified by <db:code role="parameter">scxmlStateName</db:code> to <db:code role="parameter">functor</db:code>.</db:para>
<db:para>The <db:code role="parameter">functor</db:code> must take a boolean argument that indicates whether the state connected became active or inactive.</db:para>
<db:para>Returns a handle to the connection, which can be used later to disconnect.</db:para>
</db:section>
<db:section xml:id="connectToState-3">
<db:title>typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Functor&gt;::IsPointerToMemberFunction &amp;&amp; !std::is_same&lt;const char *, Functor&gt;::value, QMetaObject::Connection&gt;::type QScxmlStateMachine::connectToState(const QString &amp;<db:emphasis>scxmlStateName</db:emphasis>, const QObject *<db:emphasis>context</db:emphasis>, Functor <db:emphasis>functor</db:emphasis>, Qt::ConnectionType <db:emphasis>type</db:emphasis> = Qt::AutoConnection)</db:title>
<db:methodsynopsis>
<db:type>typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Functor&gt;::IsPointerToMemberFunction &amp;&amp; !std::is_same&lt;const char *, Functor&gt;::value, QMetaObject::Connection&gt;::type</db:type>
<db:methodname>connectToState</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>scxmlStateName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>context</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>functor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ConnectionType</db:type>
<db:parameter>type</db:parameter>
<db:initializer>Qt::AutoConnection</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Functor&gt;::IsPointerToMemberFunction &amp;&amp; !std::is_same&lt;const char *, Functor&gt;::value, QMetaObject::Connection&gt;::type connectToState(const QString &amp;scxmlStateName, const QObject *context, Functor functor, Qt::ConnectionType type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a connection of the given <db:code role="parameter">type</db:code> from the state specified by <db:code role="parameter">scxmlStateName</db:code> to <db:code role="parameter">functor</db:code> using <db:code role="parameter">context</db:code> as context.</db:para>
<db:para>The <db:code role="parameter">functor</db:code> must take a boolean argument that indicates whether the state connected became active or inactive.</db:para>
<db:para>Returns a handle to the connection, which can be used later to disconnect.</db:para>
</db:section>
<db:section xml:id="dataModel">
<db:title>QScxmlDataModel *QScxmlStateMachine::dataModel() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QScxmlDataModel *</db:type>
<db:methodname>dataModel</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">dataModel</db:synopsisinfo>
<db:synopsisinfo role="signature">QScxmlDataModel * dataModel() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the data model used by the state machine.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qscxmlstatemachine.xml#dataModel-prop">dataModel</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#setDataModel">setDataModel</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="finished">
<db:title>void QScxmlStateMachine::finished()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>finished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void finished()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the state machine reaches a top-level final state.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#running-prop">running</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromData">
<db:title>[static] QScxmlStateMachine *QScxmlStateMachine::fromData(QIODevice *<db:emphasis>data</db:emphasis>, const QString &amp;<db:emphasis>fileName</db:emphasis> = QString())</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QScxmlStateMachine *</db:type>
<db:methodname>fromData</db:methodname>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>fileName</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QScxmlStateMachine * fromData(QIODevice *data, const QString &amp;fileName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a state machine by reading from the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> specified by <db:code role="parameter">data</db:code>.</db:para>
<db:para>This method will always return a state machine. If errors occur while reading the SCXML file, <db:code role="parameter">fileName</db:code>, the state machine cannot be started. The errors can be retrieved by calling the <db:link xlink:href="qscxmlstatemachine.xml#parseErrors-prop">parseErrors</db:link>() method.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#parseErrors-prop">parseErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromFile">
<db:title>[static] QScxmlStateMachine *QScxmlStateMachine::fromFile(const QString &amp;<db:emphasis>fileName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QScxmlStateMachine *</db:type>
<db:methodname>fromFile</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>fileName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QScxmlStateMachine * fromFile(const QString &amp;fileName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a state machine from the SCXML file specified by <db:code role="parameter">fileName</db:code>.</db:para>
<db:para>This method will always return a state machine. If errors occur while reading the SCXML file, the state machine cannot be started. The errors can be retrieved by calling the <db:link xlink:href="qscxmlstatemachine.xml#parseErrors-prop">parseErrors</db:link>() method.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#parseErrors-prop">parseErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="init">
<db:title>bool QScxmlStateMachine::init()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>init</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool init()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Initializes the state machine.</db:para>
<db:para>State machine initialization consists of calling <db:link xlink:href="qscxmldatamodel.xml#setup">QScxmlDataModel::setup</db:link>(), setting the initial values for <db:code>&lt;data&gt;</db:code> elements, and executing any <db:code>&lt;script&gt;</db:code> tags of the <db:code>&lt;scxml&gt;</db:code> tag. The initial data values are taken from the <db:code>initialValues</db:code> property.</db:para>
<db:para>Returns <db:code>false</db:code> if parse errors occur or if any of the initialization steps fail. Returns <db:code>true</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isActive">
<db:title>bool QScxmlStateMachine::isActive(const QString &amp;<db:emphasis>scxmlStateName</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isActive</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>scxmlStateName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isActive(const QString &amp;scxmlStateName) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the state specified by <db:code role="parameter">scxmlStateName</db:code> is active, <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isActive-1">
<db:title>[protected] bool QScxmlStateMachine::isActive(int <db:emphasis>stateIndex</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isActive</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>stateIndex</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isActive(int stateIndex) const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the state with the ID <db:code role="parameter">stateIndex</db:code> is active.</db:para>
<db:para>This method is part of the interface to the compiled representation of SCXML state machines. It should only be used internally and by state machines compiled from SCXML documents.</db:para>
</db:section>
<db:section xml:id="isDispatchableTarget">
<db:title>bool QScxmlStateMachine::isDispatchableTarget(const QString &amp;<db:emphasis>target</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isDispatchableTarget</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>target</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isDispatchableTarget(const QString &amp;target) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if a message to <db:code role="parameter">target</db:code> can be dispatched by this state machine.</db:para>
<db:para>Valid targets are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>#_parent</db:code> for the parent state machine if the current state machine is started by <db:code>&lt;invoke&gt;</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>#_internal</db:code> for the current state machine</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>#_scxml_sessionid</db:code>, where <db:code>sessionid</db:code> is the session ID of the current state machine</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>#_servicename</db:code>, where <db:code>servicename</db:code> is the ID or name of a service started with <db:code>&lt;invoke&gt;</db:code> by this state machine</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="isRunning">
<db:title>bool QScxmlStateMachine::isRunning() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isRunning</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">running</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isRunning() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the state machine is running, <db:code>false</db:code> otherwise.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qscxmlstatemachine.xml#running-prop">running</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#setRunning">setRunning</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#runningChanged">runningChanged</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="log">
<db:title>void QScxmlStateMachine::log(const QString &amp;<db:emphasis>label</db:emphasis>, const QString &amp;<db:emphasis>msg</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>log</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>label</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>msg</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void log(const QString &amp;label, const QString &amp;msg)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted if a <db:code>&lt;log&gt;</db:code> tag is used in the SCXML. <db:code role="parameter">label</db:code> is the value of the <db:emphasis>label</db:emphasis> attribute of the <db:code>&lt;log&gt;</db:code> tag. <db:code role="parameter">msg</db:code> is the value of the evaluated <db:emphasis>expr</db:emphasis> attribute of the <db:code>&lt;log&gt;</db:code> tag. If there is no <db:emphasis>expr</db:emphasis> attribute, a null string will be returned.</db:para>
</db:section>
<db:section xml:id="onEntry">
<db:title>[static] std::function&lt;void (bool)&gt; QScxmlStateMachine::onEntry(const QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>method</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>std::function&lt;void (bool)&gt;</db:type>
<db:methodname>onEntry</db:methodname>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">std::function&lt;void (bool)&gt; onEntry(const QObject *receiver, const char *method)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a functor that accepts a boolean argument and calls the given <db:code role="parameter">method</db:code> on <db:code role="parameter">receiver</db:code> using <db:link xlink:href="qmetaobject.xml#invokeMethod">QMetaObject::invokeMethod</db:link>() if that argument is <db:code>true</db:code> and <db:code role="parameter">receiver</db:code> has not been deleted, yet.</db:para>
<db:para>The given <db:code role="parameter">method</db:code> must not accept any arguments. <db:code role="parameter">method</db:code> is the plain method name, not enclosed in <db:code>SIGNAL()</db:code> or <db:code>SLOT()</db:code>.</db:para>
<db:para>This is useful to wrap handlers for <db:link xlink:href="qscxmlstatemachine.xml#connectToState">connectToState</db:link>() that should only be executed when the state is entered.</db:para>
</db:section>
<db:section xml:id="onEntry-1">
<db:title>[static] std::function&lt;void (bool)&gt; QScxmlStateMachine::onEntry(Functor <db:emphasis>functor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>std::function&lt;void (bool)&gt;</db:type>
<db:methodname>onEntry</db:methodname>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>functor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">std::function&lt;void (bool)&gt; onEntry(Functor functor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a functor that accepts a boolean argument and calls the given <db:code role="parameter">functor</db:code> if that argument is <db:code>true</db:code>. The given <db:code role="parameter">functor</db:code> must not accept any arguments.</db:para>
<db:para>This is useful to wrap handlers for <db:link xlink:href="qscxmlstatemachine.xml#connectToState">connectToState</db:link>() that should only be executed when the state is entered.</db:para>
</db:section>
<db:section xml:id="onEntry-2">
<db:title>[static] std::function&lt;void (bool)&gt; QScxmlStateMachine::onEntry(const typename QtPrivate::FunctionPointer&lt;PointerToMemberFunction&gt;::Object *<db:emphasis>receiver</db:emphasis>, PointerToMemberFunction <db:emphasis>method</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>std::function&lt;void (bool)&gt;</db:type>
<db:methodname>onEntry</db:methodname>
<db:methodparam>
<db:type>const typename QtPrivate::FunctionPointer&lt;PointerToMemberFunction&gt;::Object *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>PointerToMemberFunction</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">std::function&lt;void (bool)&gt; onEntry(const typename QtPrivate::FunctionPointer&lt;PointerToMemberFunction&gt;::Object *receiver, PointerToMemberFunction method)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a functor that accepts a boolean argument and calls the given <db:code role="parameter">method</db:code> on <db:code role="parameter">receiver</db:code> if that argument is <db:code>true</db:code> and the <db:code role="parameter">receiver</db:code> has not been deleted, yet. The given <db:code role="parameter">method</db:code> must not accept any arguments.</db:para>
<db:para>This is useful to wrap handlers for <db:link xlink:href="qscxmlstatemachine.xml#connectToState">connectToState</db:link>() that should only be executed when the state is entered.</db:para>
</db:section>
<db:section xml:id="onExit">
<db:title>[static] std::function&lt;void (bool)&gt; QScxmlStateMachine::onExit(const QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>method</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>std::function&lt;void (bool)&gt;</db:type>
<db:methodname>onExit</db:methodname>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">std::function&lt;void (bool)&gt; onExit(const QObject *receiver, const char *method)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a functor that accepts a boolean argument and calls the given <db:code role="parameter">method</db:code> on <db:code role="parameter">receiver</db:code> using <db:link xlink:href="qmetaobject.xml#invokeMethod">QMetaObject::invokeMethod</db:link>() if that argument is <db:code>false</db:code> and <db:code role="parameter">receiver</db:code> has not been deleted, yet.</db:para>
<db:para>The given <db:code role="parameter">method</db:code> must not accept any arguments. <db:code role="parameter">method</db:code> is the plain method name, not enclosed in SIGNAL(...) or SLOT(...).</db:para>
<db:para>This is useful to wrap handlers for <db:link xlink:href="qscxmlstatemachine.xml#connectToState">connectToState</db:link>() that should only be executed when the state is left.</db:para>
</db:section>
<db:section xml:id="onExit-1">
<db:title>[static] std::function&lt;void (bool)&gt; QScxmlStateMachine::onExit(Functor <db:emphasis>functor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>std::function&lt;void (bool)&gt;</db:type>
<db:methodname>onExit</db:methodname>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>functor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">std::function&lt;void (bool)&gt; onExit(Functor functor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a functor that accepts a boolean argument and calls the given <db:code role="parameter">functor</db:code> if that argument is <db:code>false</db:code>. The given <db:code role="parameter">functor</db:code> must not accept any arguments.</db:para>
<db:para>This is useful to wrap handlers for <db:link xlink:href="qscxmlstatemachine.xml#connectToState">connectToState</db:link>() that should only be executed when the state is left.</db:para>
</db:section>
<db:section xml:id="onExit-2">
<db:title>[static] std::function&lt;void (bool)&gt; QScxmlStateMachine::onExit(const typename QtPrivate::FunctionPointer&lt;PointerToMemberFunction&gt;::Object *<db:emphasis>receiver</db:emphasis>, PointerToMemberFunction <db:emphasis>method</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>std::function&lt;void (bool)&gt;</db:type>
<db:methodname>onExit</db:methodname>
<db:methodparam>
<db:type>const typename QtPrivate::FunctionPointer&lt;PointerToMemberFunction&gt;::Object *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>PointerToMemberFunction</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">std::function&lt;void (bool)&gt; onExit(const typename QtPrivate::FunctionPointer&lt;PointerToMemberFunction&gt;::Object *receiver, PointerToMemberFunction method)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a functor that accepts a boolean argument and calls the given <db:code role="parameter">method</db:code> on <db:code role="parameter">receiver</db:code> if that argument is <db:code>false</db:code> and the <db:code role="parameter">receiver</db:code> has not been deleted, yet. The given <db:code role="parameter">method</db:code> must not accept any arguments.</db:para>
<db:para>This is useful to wrap handlers for <db:link xlink:href="qscxmlstatemachine.xml#connectToState">connectToState</db:link>() that should only be executed when the state is left.</db:para>
</db:section>
<db:section xml:id="reachedStableState">
<db:title>void QScxmlStateMachine::reachedStableState()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>reachedStableState</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void reachedStableState()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the event queue is empty at the end of a macro step or when a final state is reached.</db:para>
</db:section>
<db:section xml:id="runningChanged">
<db:title>void QScxmlStateMachine::runningChanged(bool <db:emphasis>running</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>runningChanged</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>running</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">running</db:synopsisinfo>
<db:synopsisinfo role="signature">void runningChanged(bool running)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the <db:code>running</db:code> property is changed with <db:code role="parameter">running</db:code> as argument.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qscxmlstatemachine.xml#running-prop">running</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="setDataModel">
<db:title>void QScxmlStateMachine::setDataModel(QScxmlDataModel *<db:emphasis>model</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDataModel</db:methodname>
<db:methodparam>
<db:type>QScxmlDataModel *</db:type>
<db:parameter>model</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">dataModel</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDataModel(QScxmlDataModel *model)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the data model for this state machine to <db:code role="parameter">model</db:code>. There is a 1:1 relation between state machines and models. After setting the model once you cannot change it anymore. Any further attempts to set the model using this method will be ignored.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qscxmlstatemachine.xml#dataModel-prop">dataModel</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#dataModel">dataModel</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setRunning">
<db:title>void QScxmlStateMachine::setRunning(bool <db:emphasis>running</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setRunning</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>running</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">running</db:synopsisinfo>
<db:synopsisinfo role="signature">void setRunning(bool running)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Starts the state machine if <db:code role="parameter">running</db:code> is <db:code>true</db:code>, or stops it otherwise.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qscxmlstatemachine.xml#running-prop">running</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#start">start</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#stop">stop</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#isRunning">isRunning</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#runningChanged">runningChanged</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="start">
<db:title>void QScxmlStateMachine::start()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>start</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void start()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Starts this state machine. The machine will reset its configuration and transition to the initial state. When a final top-level state is entered, the machine will emit the <db:link xlink:href="qscxmlstatemachine.xml#finished">finished</db:link>() signal.</db:para>
<db:note>
<db:para>A state machine will not run without a running event loop, such as the main application event loop started with <db:link xlink:href="qcoreapplication.xml#exec">QCoreApplication::exec</db:link>() or <db:link xlink:href="qapplication.xml#exec">QApplication::exec</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#runningChanged">runningChanged</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#setRunning">setRunning</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#stop">stop</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#finished">finished</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stateNames">
<db:title>QStringList QScxmlStateMachine::stateNames(bool <db:emphasis>compress</db:emphasis> = true) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>stateNames</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>compress</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList stateNames(bool compress) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Retrieves a list of state names of all states.</db:para>
<db:para>When <db:code role="parameter">compress</db:code> is <db:code>true</db:code> (the default), the states that contain child states will be filtered out and only the <db:emphasis>leaf states</db:emphasis> will be returned. When it is <db:code>false</db:code>, the full list of all states will be returned.</db:para>
<db:para>The returned list does not contain the states of possible nested state machines.</db:para>
<db:note>
<db:para>The order of the state names in the list is the order in which the states occurred in the SCXML document.</db:para>
</db:note>
</db:section>
<db:section xml:id="stop">
<db:title>void QScxmlStateMachine::stop()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>stop</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void stop()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Stops this state machine. The machine will not execute any further state transitions. Its <db:code>running</db:code> property is set to <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#runningChanged">runningChanged</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#start">start</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#setRunning">setRunning</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="submitEvent">
<db:title>void QScxmlStateMachine::submitEvent(QScxmlEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>submitEvent</db:methodname>
<db:methodparam>
<db:type>QScxmlEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void submitEvent(QScxmlEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Submits the SCXML event <db:code role="parameter">event</db:code> to the internal or external event queue depending on the priority of the event.</db:para>
<db:para>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of <db:code role="parameter">event</db:code> and deletes it after processing.</db:para>
</db:section>
<db:section xml:id="submitEvent-1">
<db:title>void QScxmlStateMachine::submitEvent(const QString &amp;<db:emphasis>eventName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>submitEvent</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>eventName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void submitEvent(const QString &amp;eventName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>A utility method to create and submit an external event with the specified <db:code role="parameter">eventName</db:code> as the name.</db:para>
</db:section>
<db:section xml:id="submitEvent-2">
<db:title>void QScxmlStateMachine::submitEvent(const QString &amp;<db:emphasis>eventName</db:emphasis>, const QVariant &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>submitEvent</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>eventName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void submitEvent(const QString &amp;eventName, const QVariant &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>A utility method to create and submit an external event with the specified <db:code role="parameter">eventName</db:code> as the name and <db:code role="parameter">data</db:code> as the payload data.</db:para>
</db:section>
</db:section>
</db:article>
