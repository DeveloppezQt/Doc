<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QScxmlStateMachine Class</db:title>
<db:productname>QtScxml</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Scxml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qscxmlstatemachine.xml">QScxmlStateMachine</db:link> class provides an interface to the state machines created from SCXML files.</db:para>
<db:para>This class was introduced in Qt 5.7.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QScxmlStateMachine</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.7</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += scxml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qscxmlstatemachine.xml">QScxmlStateMachine</db:link> is an implementation of the <db:link xlink:href="http://www.w3.org/TR/scxml/">State Chart XML (SCXML)</db:link>.</db:para>
<db:para>All states that are defined in the SCXML file are accessible as properties of <db:link xlink:href="qscxmlstatemachine.xml">QScxmlStateMachine</db:link>. These properties are boolean values and indicate whether the state is active or inactive.</db:para>
<db:para>All external signals defined inside the SCXML file that are of the <db:code>qt:signal</db:code> type, are accessible as signals of <db:link xlink:href="qscxmlstatemachine.xml">QScxmlStateMachine</db:link> in the <db:emphasis>Qt mode</db:emphasis>. The only argument of these signals is always <db:link xlink:href="qvariant.xml">QVariant</db:link>, which is of <db:link xlink:href="qmap.xml">QMap</db:link>&lt;<db:link xlink:href="qstring.xml">QString</db:link>, <db:link xlink:href="qvariant.xml">QVariant</db:link>&gt; type containing the content of all the <db:code>&lt;param&gt;</db:code> elements specified as children of a <db:code>&lt;send&gt;</db:code> element. The name of each <db:link xlink:href="qscxmlstatemachine.xml">QScxmlStateMachine</db:link> signal corresponds to the value defined in the <db:emphasis>event</db:emphasis> attribute of one <db:code>&lt;send&gt;</db:code> tag in the SCXML file.</db:para>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="BindingMethod-enum">
<db:title>enum QScxmlStateMachine::BindingMethod</db:title>
<db:para>This enum specifies the binding method. The binding method controls the point in time when the initial values are assigned to the data elements.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscxmlstatemachine.xml">QScxmlStateMachine</db:link></db:emphasis>::EarlyBinding</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>All data elements are created and initialized at data-model initialization. This is the default.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qscxmlstatemachine.xml">QScxmlStateMachine</db:link></db:emphasis>::LateBinding</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>All data elements are created at initialization, but the initial values are assigned only when the containing state is entered for the first time. This is done before any executable content is executed.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="dataModel-prop">
<db:title>dataModel : QScxmlDataModel*</db:title>
<db:para>This property holds the data model to be used for this state machine.</db:para>
<db:para>SCXML data models are described in <db:link xlink:href="https://www.w3.org/TR/scxml/#data-module">SCXML Specification - 5 Data Model and Data Manipulation</db:link>. For more information about supported data models, see <db:link xlink:href="qtscxml-scxml-compliance.xml">SCXML Compliance</db:link>.</db:para>
<db:para>Changing the data model when the state machine has been <db:code>initialized</db:code> is not specified in the SCXML standard and leads to undefined behavior.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qscxmldatamodel.xml">QScxmlDataModel</db:link></db:type> *<db:emphasis role="bold"><db:link xlink:href="qscxmlstatemachine.xml#dataModel">dataModel</db:link></db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qscxmlstatemachine.xml#setDataModel">setDataModel</db:link></db:emphasis>(<db:type><db:link xlink:href="qscxmldatamodel.xml">QScxmlDataModel</db:link></db:type> *<db:emphasis>model</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">dataModelChanged</db:emphasis>(<db:type><db:link xlink:href="qscxmldatamodel.xml">QScxmlDataModel</db:link></db:type> *<db:emphasis>model</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmldatamodel.xml">QScxmlDataModel</db:link></db:member>
<db:member><db:link xlink:href="qscxmlnulldatamodel.xml">QScxmlNullDataModel</db:link></db:member>
<db:member><db:link xlink:href="qscxmlecmascriptdatamodel.xml">QScxmlEcmaScriptDataModel</db:link></db:member>
<db:member><db:link xlink:href="qscxmlcppdatamodel.xml">QScxmlCppDataModel</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="initialValues-prop">
<db:title>initialValues : QVariantMap</db:title>
<db:para>This property holds the initial values to be used for setting up the data model.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link></db:type> <db:emphasis role="bold">initialValues</db:emphasis>()</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setInitialValues</db:emphasis>(const <db:type><db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link></db:type> &amp;<db:emphasis>initialValues</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">initialValuesChanged</db:emphasis>(const <db:type><db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link></db:type> &amp;<db:emphasis>initialValues</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#init">QScxmlStateMachine::init</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmldatamodel.xml">QScxmlDataModel</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="initialized-prop">
<db:title>[read-only] initialized : const bool</db:title>
<db:para>This property holds whether the state machine has been initialized.</db:para>
<db:para>It is <db:code>true</db:code> if the state machine has been initialized, <db:code>false</db:code> otherwise.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isInitialized</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">initializedChanged</db:emphasis>(<db:type>bool</db:type> <db:emphasis>initialized</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#init">QScxmlStateMachine::init</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmldatamodel.xml">QScxmlDataModel</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="running-prop">
<db:title>running : bool</db:title>
<db:para>This property holds the running state of this state machine</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold"><db:link xlink:href="qscxmlstatemachine.xml#isRunning">isRunning</db:link></db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qscxmlstatemachine.xml#setRunning">setRunning</db:link></db:emphasis>(<db:type>bool</db:type> <db:emphasis>running</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qscxmlstatemachine.xml#runningChanged">runningChanged</db:link></db:emphasis>(<db:type>bool</db:type> <db:emphasis>running</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#start">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="activeStateNames">
<db:title>QStringList QScxmlStateMachine::activeStateNames(bool <db:emphasis>compress</db:emphasis> = true) const</db:title>
<db:para>Retrieves a list of state names of all active states.</db:para>
<db:para>When a state is active, all its parent states are active by definition. When <db:code role="parameter">compress</db:code> is <db:code>true</db:code> (the default), the parent states will be filtered out and only the <db:emphasis>leaf states</db:emphasis> will be returned. When it is <db:code>false</db:code>, the full list of active states will be returned.</db:para>
</db:section>
<db:section xml:id="cancelDelayedEvent">
<db:title>void QScxmlStateMachine::cancelDelayedEvent(const QString &amp;<db:emphasis>sendId</db:emphasis>)</db:title>
<db:para>Cancels a delayed event with the specified <db:code role="parameter">sendId</db:code>.</db:para>
</db:section>
<db:section xml:id="connectToState">
<db:title>QMetaObject::Connection QScxmlStateMachine::connectToState(const QString &amp;<db:emphasis>scxmlStateName</db:emphasis>, const QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>method</db:emphasis>, Qt::ConnectionType <db:emphasis>type</db:emphasis> = Qt::AutoConnection)</db:title>
<db:para>Creates a connection of the given <db:code role="parameter">type</db:code> from the state identified by <db:code role="parameter">scxmlStateName</db:code> to the <db:code role="parameter">method</db:code> in the <db:code role="parameter">receiver</db:code> object. The receiver's <db:code role="parameter">method</db:code> may contain a boolean argument that indicates whether the state connected became active or inactive.</db:para>
<db:para>Returns a handle to the connection, which can be used later to disconnect.</db:para>
</db:section>
<db:section xml:id="dataBinding">
<db:title>QScxmlStateMachine::BindingMethod QScxmlStateMachine::dataBinding() const</db:title>
<db:para>Returns the binding method used by the state machine.</db:para>
</db:section>
<db:section xml:id="dataModel">
<db:title>QScxmlDataModel *QScxmlStateMachine::dataModel() const</db:title>
<db:para>Returns the data model used by the state machine.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qscxmlstatemachine.xml#dataModel-prop">dataModel</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#setDataModel">setDataModel</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="eventOccurred">
<db:title>void QScxmlStateMachine::eventOccurred(const QScxmlEvent &amp;<db:emphasis>event</db:emphasis>)</db:title>
<db:para>This signal is emitted when the SCXML event <db:code role="parameter">event</db:code> occurs. This signal is emitted for all events.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#externalEventOccurred">externalEventOccurred</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="externalEventOccurred">
<db:title>void QScxmlStateMachine::externalEventOccurred(const QScxmlEvent &amp;<db:emphasis>event</db:emphasis>)</db:title>
<db:para>This signal is emitted for each <db:code>&lt;send&gt;</db:code> element in the SCXML file that contains the attribute <db:code>type=&quot;qt:signal&quot;</db:code>. The event that occurred is specified by <db:code role="parameter">event</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#eventOccurred">eventOccurred</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="finished">
<db:title>void QScxmlStateMachine::finished()</db:title>
<db:para>This signal is emitted when the state machine reaches a top-level final state.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#running-prop">running</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromData">
<db:title>[static] QScxmlStateMachine *QScxmlStateMachine::fromData(QIODevice *<db:emphasis>data</db:emphasis>, const QString &amp;<db:emphasis>fileName</db:emphasis> = QString())</db:title>
<db:para>Creates a state machine by reading from the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> specified by <db:code role="parameter">data</db:code>.</db:para>
<db:para>This method will always return a state machine. If errors occur while reading the SCXML file, <db:code role="parameter">fileName</db:code>, the state machine cannot be started. The errors can be retrieved by calling the <db:link xlink:href="qscxmlstatemachine.xml#parseErrors">parseErrors</db:link>() method.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#parseErrors">parseErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromFile">
<db:title>[static] QScxmlStateMachine *QScxmlStateMachine::fromFile(const QString &amp;<db:emphasis>fileName</db:emphasis>)</db:title>
<db:para>Creates a state machine from the SCXML file specified by <db:code role="parameter">fileName</db:code>.</db:para>
<db:para>This method will always return a state machine. If errors occur while reading the SCXML file, the state machine cannot be started. The errors can be retrieved by calling the <db:link xlink:href="qscxmlstatemachine.xml#parseErrors">parseErrors</db:link>() method.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#parseErrors">parseErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="generateSessionId">
<db:title>[static] QString QScxmlStateMachine::generateSessionId(const QString &amp;<db:emphasis>prefix</db:emphasis>)</db:title>
<db:para>Generates a unique ID by appending a unique number to the <db:code role="parameter">prefix</db:code>.</db:para>
<db:para>The number is only unique within a single run of an application. This method is used when an invoked service does not have an ID set (the <db:emphasis>id</db:emphasis> attribute in <db:code>&lt;invoke&gt;</db:code>).</db:para>
</db:section>
<db:section xml:id="init">
<db:title>bool QScxmlStateMachine::init()</db:title>
<db:para>Initializes the state machine.</db:para>
<db:para>State machine initialization consists of calling <db:link xlink:href="qscxmldatamodel.xml#setup">QScxmlDataModel::setup</db:link>(), setting the initial values for <db:code>&lt;data&gt;</db:code> elements, and executing any <db:code>&lt;script&gt;</db:code> tags of the <db:code>&lt;scxml&gt;</db:code> tag. The initial data values are taken from the <db:code>initialValues</db:code> property.</db:para>
<db:para>Returns <db:code>false</db:code> if parse errors occur or if any of the initialization steps fail. Returns <db:code>true</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isActive">
<db:title>bool QScxmlStateMachine::isActive(const QString &amp;<db:emphasis>scxmlStateName</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if the state specified by <db:code role="parameter">scxmlStateName</db:code> is active, <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isDispatchableTarget">
<db:title>bool QScxmlStateMachine::isDispatchableTarget(const QString &amp;<db:emphasis>target</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if a message to <db:code role="parameter">target</db:code> can be dispatched by this state machine.</db:para>
<db:para>Valid targets are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>#_parent</db:code> for the parent state machine if the current state machine is started by <db:code>&lt;invoke&gt;</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>#_internal</db:code> for the current state machine</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>#_scxml_sessionid</db:code>, where <db:code>sessionid</db:code> is the session ID of the current state machine</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>#_servicename</db:code>, where <db:code>servicename</db:code> is the ID or name of a service started with <db:code>&lt;invoke&gt;</db:code> by this state machine</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="isInvoked">
<db:title>bool QScxmlStateMachine::isInvoked() const</db:title>
<db:para>Returns <db:code>true</db:code> when the state machine was started as a service with the <db:code>&lt;invoke&gt;</db:code> element, <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isRunning">
<db:title>bool QScxmlStateMachine::isRunning() const</db:title>
<db:para>Returns <db:code>true</db:code> if the state machine is running, <db:code>false</db:code> otherwise.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qscxmlstatemachine.xml#running-prop">running</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#setRunning">setRunning</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#runningChanged">runningChanged</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="log">
<db:title>void QScxmlStateMachine::log(const QString &amp;<db:emphasis>label</db:emphasis>, const QString &amp;<db:emphasis>msg</db:emphasis>)</db:title>
<db:para>This signal is emitted if a <db:code>&lt;log&gt;</db:code> tag is used in the SCXML. <db:code role="parameter">label</db:code> is the value of the <db:emphasis>label</db:emphasis> attribute of the <db:code>&lt;log&gt;</db:code> tag. <db:code role="parameter">msg</db:code> is the value of the evaluated <db:emphasis>expr</db:emphasis> attribute of the <db:code>&lt;log&gt;</db:code> tag. If there is no <db:emphasis>expr</db:emphasis> attribute, a null string will be returned.</db:para>
</db:section>
<db:section xml:id="name">
<db:title>QString QScxmlStateMachine::name() const</db:title>
<db:para>Returns the name of the state machine as set by the <db:emphasis>name</db:emphasis> attribute of the <db:code>&lt;scxml&gt;</db:code> tag.</db:para>
</db:section>
<db:section xml:id="parseErrors">
<db:title>QVector&lt;QScxmlError&gt; QScxmlStateMachine::parseErrors() const</db:title>
<db:para>Returns the list of parse errors that occurred while creating a state machine from an SCXML file.</db:para>
</db:section>
<db:section xml:id="reachedStableState">
<db:title>void QScxmlStateMachine::reachedStableState()</db:title>
<db:para>This signal is emitted when the event queue is empty at the end of a macro step or when a final state is reached.</db:para>
</db:section>
<db:section xml:id="runningChanged">
<db:title>void QScxmlStateMachine::runningChanged(bool <db:emphasis>running</db:emphasis>)</db:title>
<db:para>This signal is emitted when the <db:code>running</db:code> property is changed with <db:code role="parameter">running</db:code> as argument.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qscxmlstatemachine.xml#running-prop">running</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="scxmlEventFilter">
<db:title>QScxmlEventFilter *QScxmlStateMachine::scxmlEventFilter() const</db:title>
<db:para>Returns the SCXML event filter if one is set, otherwise returns null.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#setScxmlEventFilter">setScxmlEventFilter</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sessionId">
<db:title>QString QScxmlStateMachine::sessionId() const</db:title>
<db:para>Returns the session ID for the current state machine.</db:para>
<db:para>The session ID is used for message routing between parent and child state machines. If a state machine is started by an <db:code>&lt;invoke&gt;</db:code> element, any event it sends will have the <db:code>invokeid</db:code> field set to the session ID. The state machine will use the origin of an event (which is set by the <db:emphasis>target</db:emphasis> or <db:emphasis>targetexpr</db:emphasis> attribute in a <db:code>&lt;send&gt;</db:code> element) to dispatch messages to the correct child state machine.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#setSessionId">setSessionId</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlevent.xml#invokeId">QScxmlEvent::invokeId</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDataModel">
<db:title>void QScxmlStateMachine::setDataModel(QScxmlDataModel *<db:emphasis>model</db:emphasis>)</db:title>
<db:para>Sets the data model for this state machine to <db:code role="parameter">model</db:code>. There is a 1:1 relation between state machines and models. After setting the model once you cannot change it anymore. Any further attempts to set the model using this method will be ignored.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qscxmlstatemachine.xml#dataModel-prop">dataModel</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#dataModel">dataModel</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setRunning">
<db:title>void QScxmlStateMachine::setRunning(bool <db:emphasis>running</db:emphasis>)</db:title>
<db:para>Starts the state machine if <db:code role="parameter">running</db:code> is <db:code>true</db:code>, or stops it otherwise.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qscxmlstatemachine.xml#running-prop">running</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#start">start</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#stop">stop</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#isRunning">isRunning</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#runningChanged">runningChanged</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setScxmlEventFilter">
<db:title>void QScxmlStateMachine::setScxmlEventFilter(QScxmlEventFilter *<db:emphasis>newFilter</db:emphasis>)</db:title>
<db:para>Sets the <db:code role="parameter">newFilter</db:code> as the SCXML event filter. Passing null will remove the current filter.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#scxmlEventFilter">scxmlEventFilter</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSessionId">
<db:title>void QScxmlStateMachine::setSessionId(const QString &amp;<db:emphasis>id</db:emphasis>)</db:title>
<db:para>Sets the session ID for the current state machine to <db:code role="parameter">id</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#sessionId">sessionId</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="start">
<db:title>void QScxmlStateMachine::start()</db:title>
<db:para>Starts this state machine. The machine will reset its configuration and transition to the initial state. When a final top-level state is entered, the machine will emit the <db:link xlink:href="qscxmlstatemachine.xml#finished">finished</db:link>() signal.</db:para>
<db:note>
<db:para>A state machine will not run without a running event loop, such as the main application event loop started with <db:link xlink:href="qcoreapplication.xml#exec">QCoreApplication::exec</db:link>() or <db:link xlink:href="qapplication.xml#exec">QApplication::exec</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#runningChanged">runningChanged</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#setRunning">setRunning</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#stop">stop</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#finished">finished</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stateNames">
<db:title>QStringList QScxmlStateMachine::stateNames(bool <db:emphasis>compress</db:emphasis> = true) const</db:title>
<db:para>Retrieves a list of state names of all states.</db:para>
<db:para>When <db:code role="parameter">compress</db:code> is <db:code>true</db:code> (the default), the states that contain child states will be filtered out and only the <db:emphasis>leaf states</db:emphasis> will be returned. When it is <db:code>false</db:code>, the full list of all states will be returned.</db:para>
<db:para>The returned list does not contain the states of possible nested state machines.</db:para>
</db:section>
<db:section xml:id="stop">
<db:title>void QScxmlStateMachine::stop()</db:title>
<db:para>Stops this state machine. The machine will not execute any further state transitions. Its <db:code>running</db:code> property is set to <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscxmlstatemachine.xml#runningChanged">runningChanged</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#start">start</db:link>()</db:member>
<db:member><db:link xlink:href="qscxmlstatemachine.xml#setRunning">setRunning</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="submitEvent">
<db:title>void QScxmlStateMachine::submitEvent(QScxmlEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:para>Submits the SCXML event <db:code role="parameter">event</db:code> to the internal or external event queue depending on the priority of the event.</db:para>
<db:para>When a delay is set, the event will be queued for delivery after the timeout has passed.</db:para>
</db:section>
<db:section xml:id="submitEvent-1">
<db:title>void QScxmlStateMachine::submitEvent(const QString &amp;<db:emphasis>eventName</db:emphasis>)</db:title>
<db:para>A utility method to create and submit an external event with the specified <db:code role="parameter">eventName</db:code> as the name.</db:para>
</db:section>
<db:section xml:id="submitEvent-2">
<db:title>void QScxmlStateMachine::submitEvent(const QString &amp;<db:emphasis>eventName</db:emphasis>, const QVariant &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:para>A utility method to create and submit an external event with the specified <db:code role="parameter">eventName</db:code> as the name and <db:code role="parameter">data</db:code> as the payload data.</db:para>
</db:section>
</db:section>
</db:article>
