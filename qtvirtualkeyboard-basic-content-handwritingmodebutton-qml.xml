<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Quick Virtual Keyboard - Basic Example</db:title>
<db:productname>QtVirtualKeyboard</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Virtual Keyboard</db:titleabbrev>
<db:abstract>
<db:para>This is a basic QML example that uses the virtual keyboard.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="qml">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the Qt Virtual Keyboard module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:GPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3 or (at your option) any later version
** approved by the KDE Free Qt Foundation. The licenses are as published by
** the Free Software Foundation and appearing in the file LICENSE.GPL3
** included in the packaging of this file. Please review the following
** information to ensure the GNU General Public License requirements will
** be met: https://www.gnu.org/licenses/gpl-3.0.html.
**
** $QT_END_LICENSE$
**
****************************************************************************/

import QtQuick 2.0

Item {
    id: handwritingModeButton
    state: &quot;unavailable&quot;
    property bool floating
    property bool flipable
    readonly property real __minWidthHeight: Math.min(width, height)

    signal clicked()
    signal doubleClicked()

    Flipable {
        id: flipableImage
        anchors.fill: parent

        property bool flipped

        front: Image {
            sourceSize.width: handwritingModeButton.__minWidthHeight
            sourceSize.height: handwritingModeButton.__minWidthHeight
            smooth: false
            source: &quot;qrc:/content/FloatingButton_Unavailable.svg&quot;
        }

        back: Image {
            id: buttonImage
            sourceSize.width: handwritingModeButton.__minWidthHeight
            sourceSize.height: handwritingModeButton.__minWidthHeight
            smooth: false
            source: &quot;qrc:/content/FloatingButton_Available.svg&quot;
        }

        states: State {
            PropertyChanges { target: rotation; angle: 180 }
            when: flipableImage.flipped
        }

        transform: Rotation {
            id: rotation
            origin.x: flipableImage.width / 2
            origin.y: flipableImage.height / 2
            axis { x: 0; y: 1; z: 0 }
            angle: 0
        }

        transitions: Transition {
            enabled: handwritingModeButton.flipable
            NumberAnimation { target: rotation; property: &quot;angle&quot;; duration: 400 }
        }
    }

    states: [
        State {
            name: &quot;available&quot;
            PropertyChanges { target: flipableImage; flipped: true }
        },
        State {
            name: &quot;active&quot;
            PropertyChanges { target: flipableImage; flipped: true }
            PropertyChanges { target: buttonImage; source: &quot;qrc:/content/FloatingButton_Active.svg&quot; }
        }
    ]

    function snapHorizontal() {
        if (!floating)
            return
        if (mouseArea.drag.maximumX &gt; mouseArea.drag.minimumX) {
            if (x + 20 &gt;= mouseArea.drag.maximumX) {
                anchors.left = undefined
                anchors.right = parent.right
            } else if (x - 20 &lt;= mouseArea.drag.minimumX) {
                anchors.right = undefined
                anchors.left = parent.left
            }
        }
    }

    function snapVertical() {
        if (!floating)
            return
        if (mouseArea.drag.maximumY &gt; mouseArea.drag.minimumY) {
            if (y + 20 &gt;= mouseArea.drag.maximumY) {
                anchors.top = undefined
                anchors.bottom = parent.bottom
            } else if (y - 20 &lt;= mouseArea.drag.minimumY) {
                anchors.bottom = undefined
                anchors.top = parent.top
            }
        }
    }

    MouseArea {
        id: mouseArea
        anchors.fill: parent
        drag {
            target: handwritingModeButton.floating ? handwritingModeButton : undefined
            axis: Drag.XAxis | Drag.YAxis
            minimumX: 0
            maximumX: handwritingModeButton.parent.width - handwritingModeButton.width
            onMaximumXChanged: !mouseArea.drag.active &amp;&amp; handwritingModeButton.snapHorizontal()
            minimumY: 0
            maximumY: handwritingModeButton.parent.height - handwritingModeButton.height
            onMaximumYChanged: !mouseArea.drag.active &amp;&amp; handwritingModeButton.snapVertical()
        }
        onPressed: {
            if (!handwritingModeButton.floating)
                return
            handwritingModeButton.anchors.left = undefined
            handwritingModeButton.anchors.top = undefined
            handwritingModeButton.anchors.right = undefined
            handwritingModeButton.anchors.bottom = undefined
        }
        onReleased: {
            handwritingModeButton.snapHorizontal()
            handwritingModeButton.snapVertical()
        }
        onClicked: {
            handwritingModeButton.snapHorizontal()
            handwritingModeButton.snapVertical()
            clickTimer.restart()
        }
        onDoubleClicked: {
            clickTimer.stop()
            handwritingModeButton.snapHorizontal()
            handwritingModeButton.snapVertical()
            handwritingModeButton.doubleClicked()
        }
        Timer {
            id: clickTimer
            interval: Qt.styleHints ? Qt.styleHints.mouseDoubleClickInterval / 3 : 0
            repeat: false
            onTriggered: handwritingModeButton.clicked()
        }
    }
}

</db:programlisting>
</db:article>
