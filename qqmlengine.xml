<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QQmlEngine Class</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt QML Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> class provides an environment for instantiating QML components.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QQmlEngine</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Qml)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Qml)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += qml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qjsengine.xml" xlink:role="class">QJSEngine</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qqmlapplicationengine.xml" xlink:role="class">QQmlApplicationEngine</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> is used to manage <db:link xlink:href="qqmlcomponent.xml">components</db:link> and objects created from them and execute their bindings and functions. <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> also inherits from <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> which allows seamless integration between your QML components and JavaScript code.</db:para>
<db:para>Each QML component is instantiated in a <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link>. In QML, contexts are arranged hierarchically and this hierarchy is managed by the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>. By default, components are instantiated in the <db:link xlink:href="qqmlengine.xml#rootContext">root context</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlcomponent.xml">QQmlComponent</db:link></db:member>
<db:member><db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link></db:member>
<db:member><db:link xlink:href="qtqml-javascript-qmlglobalobject.xml">QML Global Object</db:link></db:member>
<db:member><db:link xlink:href="qqmlapplicationengine.xml">QQmlApplicationEngine</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="offlineStoragePath-prop">
<db:title>offlineStoragePath : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>offlineStoragePath</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">offlineStoragePath</db:synopsisinfo>
<db:synopsisinfo role="setter">setOfflineStoragePath</db:synopsisinfo>
<db:synopsisinfo role="notifier">offlineStoragePathChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the directory for storing offline user data</db:para>
<db:para>Returns the directory where SQL and other offline storage is placed.</db:para>
<db:para>The SQL databases created with <db:code>openDatabaseSync()</db:code> are stored here.</db:para>
<db:para>The default is QML/OfflineStorage in the platform-standard user application data directory.</db:para>
<db:para>Note that the path may not currently exist on the filesystem, so callers wanting to <db:emphasis>create</db:emphasis> new files at this location should create it first - see <db:link xlink:href="qdir.xml#mkpath">QDir::mkpath</db:link>().</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">offlineStoragePath</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setOfflineStoragePath</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>dir</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qqmlengine.xml#offlineStoragePathChanged">offlineStoragePathChanged</db:link></db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-localstorage-qmlmodule.xml">Qt Quick Local Storage QML Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QQmlEngine">
<db:title>[explicit] QQmlEngine::QQmlEngine(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QQmlEngine</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QQmlEngine(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Create a new <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> with the given <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QQmlEngine">
<db:title>[override virtual] QQmlEngine::~QQmlEngine()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QQmlEngine</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QQmlEngine() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>.</db:para>
<db:para>Any <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link>'s created on this engine will be invalidated, but not destroyed (unless they are parented to the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> object).</db:para>
<db:para>See ~<db:link xlink:href="qjsengine.xml#QJSEngine">QJSEngine</db:link>() for details on cleaning up the JS engine.</db:para>
</db:section>
<db:section xml:id="addImageProvider">
<db:title>void QQmlEngine::addImageProvider(const QString &amp;<db:emphasis>providerId</db:emphasis>, QQmlImageProviderBase *<db:emphasis>provider</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addImageProvider</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>providerId</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QQmlImageProviderBase *</db:type>
<db:parameter>provider</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addImageProvider(const QString &amp;providerId, QQmlImageProviderBase *provider)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the <db:code role="parameter">provider</db:code> to use for images requested via the <db:emphasis>image</db:emphasis>: url scheme, with host <db:code role="parameter">providerId</db:code>. The <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> takes ownership of <db:code role="parameter">provider</db:code>.</db:para>
<db:para>Image providers enable support for pixmap and threaded image requests. See the <db:link xlink:href="qquickimageprovider.xml">QQuickImageProvider</db:link> documentation for details on implementing and using image providers.</db:para>
<db:para>All required image providers should be added to the engine before any QML sources files are loaded.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#removeImageProvider">removeImageProvider</db:link>()</db:member>
<db:member><db:link xlink:href="qquickimageprovider.xml">QQuickImageProvider</db:link></db:member>
<db:member><db:link xlink:href="qqmlimageproviderbase.xml">QQmlImageProviderBase</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addImportPath">
<db:title>void QQmlEngine::addImportPath(const QString &amp;<db:emphasis>path</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addImportPath</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addImportPath(const QString &amp;path)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds <db:code role="parameter">path</db:code> as a directory where the engine searches for installed modules in a URL-based directory structure.</db:para>
<db:para>The <db:code role="parameter">path</db:code> may be a local filesystem directory, a <db:link xlink:href="resources.xml">Qt Resource</db:link> path (<db:code>:/imports</db:code>), a <db:link xlink:href="resources.xml">Qt Resource</db:link> url (<db:code>qrc:/imports</db:code>) or a URL.</db:para>
<db:para>The <db:code role="parameter">path</db:code> will be converted into canonical form before it is added to the import path list.</db:para>
<db:para>The newly added <db:code role="parameter">path</db:code> will be first in the <db:link xlink:href="qqmlengine.xml#importPathList">importPathList</db:link>().</db:para>
<db:para><db:emphasis role="bold">See also</db:emphasis> <db:link xlink:href="qqmlengine.xml#setImportPathList">setImportPathList</db:link>(), <db:link xlink:href="qtqml-modules-topic.xml">QML Modules</db:link>, and <db:link xlink:href="qtqml-syntax-imports.xml#qml-import-path">QML Import Path</db:link></db:para>
</db:section>
<db:section xml:id="addPluginPath">
<db:title>void QQmlEngine::addPluginPath(const QString &amp;<db:emphasis>path</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addPluginPath</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addPluginPath(const QString &amp;path)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds <db:code role="parameter">path</db:code> as a directory where the engine searches for native plugins for imported modules (referenced in the <db:code>qmldir</db:code> file).</db:para>
<db:para>By default, the list contains only <db:code>.</db:code>, i.e. the engine searches in the directory of the <db:code>qmldir</db:code> file itself.</db:para>
<db:para>The newly added <db:code role="parameter">path</db:code> will be first in the <db:link xlink:href="qqmlengine.xml#pluginPathList">pluginPathList</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setPluginPathList">setPluginPathList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addUrlInterceptor">
<db:title>void QQmlEngine::addUrlInterceptor(QQmlAbstractUrlInterceptor *<db:emphasis>urlInterceptor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addUrlInterceptor</db:methodname>
<db:methodparam>
<db:type>QQmlAbstractUrlInterceptor *</db:type>
<db:parameter>urlInterceptor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addUrlInterceptor(QQmlAbstractUrlInterceptor *urlInterceptor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds a <db:code role="parameter">urlInterceptor</db:code> to be used when resolving URLs in QML. This also applies to URLs used for loading script files and QML types. The URL interceptors should not be modifed while the engine is loading files, or URL selection may be inconsistent. Multiple URL interceptors, when given, will be called in the order they were added for each URL.</db:para>
<db:para><db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> does not take ownership of the interceptor and won't delete it.</db:para>
</db:section>
<db:section xml:id="baseUrl">
<db:title>QUrl QQmlEngine::baseUrl() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>baseUrl</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl baseUrl() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Return the base URL for this engine. The base URL is only used to resolve components when a relative URL is passed to the <db:link xlink:href="qqmlcomponent.xml">QQmlComponent</db:link> constructor.</db:para>
<db:para>If a base URL has not been explicitly set, this method returns the application's current working directory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setBaseUrl">setBaseUrl</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clearComponentCache">
<db:title>void QQmlEngine::clearComponentCache()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clearComponentCache</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clearComponentCache()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Clears the engine's internal component cache.</db:para>
<db:para>This function causes the property metadata of all components previously loaded by the engine to be destroyed. All previously loaded components and the property bindings for all extant objects created from those components will cease to function.</db:para>
<db:para>This function returns the engine to a state where it does not contain any loaded component data. This may be useful in order to reload a smaller subset of the previous component set, or to load a new version of a previously loaded component.</db:para>
<db:para>Once the component cache has been cleared, components must be loaded before any new objects can be created.</db:para>
<db:note>
<db:para>Any existing objects created from QML components retain their types, even if you clear the component cache. This includes singleton objects. If you create more objects from the same QML code after clearing the cache, the new objects will be of different types than the old ones. Assigning such a new object to a property of its declared type belonging to an object created before clearing the cache won't work.</db:para>
</db:note>
<db:para>As a general rule of thumb, make sure that no objects created from QML components are alive when you clear the component cache.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#trimComponentCache">trimComponentCache</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#clearSingletons">clearSingletons</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clearSingletons">
<db:title>void QQmlEngine::clearSingletons()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clearSingletons</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clearSingletons()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Clears all singletons the engine owns.</db:para>
<db:para>This function drops all singleton instances, deleting any QObjects owned by the engine among them. This is useful to make sure that no QML-created objects are left before calling <db:link xlink:href="qqmlengine.xml#clearComponentCache">clearComponentCache</db:link>().</db:para>
<db:para>QML properties holding <db:link xlink:href="qobject.xml">QObject</db:link>-based singleton instances become null if the engine owns the singleton or retain their value if the engine doesn't own it. The singletons are not automatically re-created by accessing existing QML-created objects. Only when new components are instantiated, the singletons are re-created.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#clearComponentCache">clearComponentCache</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contextForObject">
<db:title>[static] QQmlContext *QQmlEngine::contextForObject(const QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QQmlContext *</db:type>
<db:methodname>contextForObject</db:methodname>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQmlContext * contextForObject(const QObject *object)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link> for the <db:code role="parameter">object</db:code>, or nullptr if no context has been set.</db:para>
<db:para>When the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> instantiates a <db:link xlink:href="qobject.xml">QObject</db:link>, an internal context is assigned to it automatically. Such internal contexts are read-only. You cannot set context properties on them.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setContextForObject">setContextForObject</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlContext">qmlContext</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlEngine">qmlEngine</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlcontext.xml#setContextProperty">QQmlContext::setContextProperty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="event">
<db:title>[override virtual protected] bool QQmlEngine::event(QEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>event</db:methodname>
<db:methodparam>
<db:type>QEvent *</db:type>
<db:parameter>e</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool event(QEvent *e) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qobject.xml#event" role="function">QObject::event(QEvent *e)</db:link>.</db:para>
</db:section>
<db:section xml:id="exit">
<db:title>void QQmlEngine::exit(int <db:emphasis>retCode</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>exit</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>retCode</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void exit(int retCode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the QML loaded by the engine would like to exit from the event loop with the specified return code <db:code role="parameter">retCode</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#quit">quit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="imageProvider">
<db:title>QQmlImageProviderBase *QQmlEngine::imageProvider(const QString &amp;<db:emphasis>providerId</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQmlImageProviderBase *</db:type>
<db:methodname>imageProvider</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>providerId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQmlImageProviderBase * imageProvider(const QString &amp;providerId) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the image provider set for <db:code role="parameter">providerId</db:code> if found; otherwise returns <db:code>nullptr</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickimageprovider.xml">QQuickImageProvider</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="importPathList">
<db:title>QStringList QQmlEngine::importPathList() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>importPathList</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList importPathList() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of directories where the engine searches for installed modules in a URL-based directory structure.</db:para>
<db:para>For example, if <db:code>/opt/MyApp/lib/imports</db:code> is in the path, then QML that imports <db:code>com.mycompany.Feature</db:code> will cause the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> to look in <db:code>/opt/MyApp/lib/imports/com/mycompany/Feature/</db:code> for the components provided by that module. A <db:code>qmldir</db:code> file is required for defining the type version mapping and possibly QML extensions plugins.</db:para>
<db:para>By default, this list contains the paths mentioned in <db:link xlink:href="qtqml-syntax-imports.xml#qml-import-path">QML Import Path</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#addImportPath">addImportPath</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#setImportPathList">setImportPathList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="incubationController">
<db:title>QQmlIncubationController *QQmlEngine::incubationController() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQmlIncubationController *</db:type>
<db:methodname>incubationController</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQmlIncubationController * incubationController() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the currently set incubation controller, or 0 if no controller has been set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setIncubationController">setIncubationController</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="interceptUrl">
<db:title>QUrl QQmlEngine::interceptUrl(const QUrl &amp;<db:emphasis>url</db:emphasis>, QQmlAbstractUrlInterceptor::DataType <db:emphasis>type</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>interceptUrl</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QQmlAbstractUrlInterceptor::DataType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl interceptUrl(const QUrl &amp;url, QQmlAbstractUrlInterceptor::DataType type) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Run the current URL interceptors on the given <db:code role="parameter">url</db:code> of the given <db:code role="parameter">type</db:code> and return the result.</db:para>
</db:section>
<db:section xml:id="markCurrentFunctionAsTranslationBinding">
<db:title>[since 6.6] void QQmlEngine::markCurrentFunctionAsTranslationBinding()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>markCurrentFunctionAsTranslationBinding</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void markCurrentFunctionAsTranslationBinding()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If this method is called inside of a function that is part of a binding in QML, the binding will be treated as a translation binding.</db:para>
<db:programlisting language="cpp">class I18nAwareClass : public QObject {

  //...

   QString text() const
   {
        if (auto engine = qmlEngine(this))
            engine-&amp;gt;markCurrentFunctionAsTranslationBinding();
        return tr(&quot;Hello, world!&quot;);
   }
};
</db:programlisting>
<db:note>
<db:para>This function is mostly useful if you wish to provide your own alternative to the qsTr function. To ensure that properties exposed from C++ classes are updated on language changes, it is instead recommended to react to <db:code>LanguageChange</db:code> events. That is a more general mechanism which also works when the class is used in a non-QML context, and has slightly less overhead. However, using <db:code>markCurrentFunctionAsTranslationBinding</db:code> can be acceptable when the class is already closely tied to the QML engine. For more details, see <db:link xlink:href="i18n-source-translation.xml#prepare-for-dynamic-language-changes">Prepare for Dynamic Language Changes</db:link></db:para>
</db:note>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#retranslate">QQmlEngine::retranslate</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="networkAccessManager">
<db:title>QNetworkAccessManager *QQmlEngine::networkAccessManager() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkAccessManager *</db:type>
<db:methodname>networkAccessManager</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkAccessManager * networkAccessManager() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a common <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> which can be used by any QML type instantiated by this engine.</db:para>
<db:para>If a <db:link xlink:href="qqmlnetworkaccessmanagerfactory.xml">QQmlNetworkAccessManagerFactory</db:link> has been set and a <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> has not yet been created, the <db:link xlink:href="qqmlnetworkaccessmanagerfactory.xml">QQmlNetworkAccessManagerFactory</db:link> will be used to create the <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>; otherwise the returned <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> will have no proxy or cache set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setNetworkAccessManagerFactory">setNetworkAccessManagerFactory</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="networkAccessManagerFactory">
<db:title>QQmlNetworkAccessManagerFactory *QQmlEngine::networkAccessManagerFactory() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQmlNetworkAccessManagerFactory *</db:type>
<db:methodname>networkAccessManagerFactory</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQmlNetworkAccessManagerFactory * networkAccessManagerFactory() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current <db:link xlink:href="qqmlnetworkaccessmanagerfactory.xml">QQmlNetworkAccessManagerFactory</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setNetworkAccessManagerFactory">setNetworkAccessManagerFactory</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="offlineStorageDatabaseFilePath">
<db:title>QString QQmlEngine::offlineStorageDatabaseFilePath(const QString &amp;<db:emphasis>databaseName</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>offlineStorageDatabaseFilePath</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>databaseName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString offlineStorageDatabaseFilePath(const QString &amp;databaseName) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the file path where a <db:link xlink:href="qtquick-localstorage-qmlmodule.xml">Local Storage</db:link> database with the identifier <db:code role="parameter">databaseName</db:code> is (or would be) located.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-localstorage-qmlmodule.xml#opendatabasesync">LocalStorage.openDatabaseSync()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="offlineStoragePathChanged">
<db:title>[since 6.5] void QQmlEngine::offlineStoragePathChanged()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>offlineStoragePathChanged</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">offlineStoragePath</db:synopsisinfo>
<db:synopsisinfo role="signature">void offlineStoragePathChanged()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when <db:link xlink:href="qqmlengine.xml#offlineStoragePath-prop">offlineStoragePath</db:link> changes.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qqmlengine.xml#offlineStoragePath-prop">offlineStoragePath</db:link>. </db:para>
</db:note>
<db:para>This function was introduced in Qt 6.5.</db:para>
</db:section>
<db:section xml:id="outputWarningsToStandardError">
<db:title>bool QQmlEngine::outputWarningsToStandardError() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>outputWarningsToStandardError</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool outputWarningsToStandardError() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if warning messages will be output to stderr in addition to being emitted by the <db:link xlink:href="qqmlengine.xml#warnings">warnings</db:link>() signal, otherwise false.</db:para>
<db:para>The default value is true.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setOutputWarningsToStandardError">setOutputWarningsToStandardError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pluginPathList">
<db:title>QStringList QQmlEngine::pluginPathList() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>pluginPathList</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList pluginPathList() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of directories where the engine searches for native plugins for imported modules (referenced in the <db:code>qmldir</db:code> file).</db:para>
<db:para>By default, the list contains only <db:code>.</db:code>, i.e. the engine searches in the directory of the <db:code>qmldir</db:code> file itself.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#addPluginPath">addPluginPath</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#setPluginPathList">setPluginPathList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quit">
<db:title>void QQmlEngine::quit()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>quit</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void quit()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the QML loaded by the engine would like to quit.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#exit">exit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeImageProvider">
<db:title>void QQmlEngine::removeImageProvider(const QString &amp;<db:emphasis>providerId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeImageProvider</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>providerId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeImageProvider(const QString &amp;providerId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the image provider for <db:code role="parameter">providerId</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#addImageProvider">addImageProvider</db:link>()</db:member>
<db:member><db:link xlink:href="qquickimageprovider.xml">QQuickImageProvider</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeUrlInterceptor">
<db:title>void QQmlEngine::removeUrlInterceptor(QQmlAbstractUrlInterceptor *<db:emphasis>urlInterceptor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeUrlInterceptor</db:methodname>
<db:methodparam>
<db:type>QQmlAbstractUrlInterceptor *</db:type>
<db:parameter>urlInterceptor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeUrlInterceptor(QQmlAbstractUrlInterceptor *urlInterceptor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Remove a <db:code role="parameter">urlInterceptor</db:code> that was previously added using <db:link xlink:href="qqmlengine.xml#addUrlInterceptor">addUrlInterceptor</db:link>. The URL interceptors should not be modifed while the engine is loading files, or URL selection may be inconsistent.</db:para>
<db:para>This does not delete the interceptor, but merely removes it from the engine. You can re-use it on the same or a different engine afterwards.</db:para>
</db:section>
<db:section xml:id="retranslate">
<db:title>void QQmlEngine::retranslate()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>retranslate</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void retranslate()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Refreshes all binding expressions that use strings marked for translation.</db:para>
<db:para>Call this function after you have installed a new translator with <db:link xlink:href="qcoreapplication.xml#installTranslator">QCoreApplication::installTranslator</db:link>, to ensure that your user-interface shows up-to-date translations.</db:para>
</db:section>
<db:section xml:id="rootContext">
<db:title>QQmlContext *QQmlEngine::rootContext() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQmlContext *</db:type>
<db:methodname>rootContext</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQmlContext * rootContext() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the engine's root context.</db:para>
<db:para>The root context is automatically created by the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>. Data that should be available to all QML component instances instantiated by the engine should be put in the root context.</db:para>
<db:para>Additional data that should only be available to a subset of component instances should be added to sub-contexts parented to the root context.</db:para>
</db:section>
<db:section xml:id="setBaseUrl">
<db:title>void QQmlEngine::setBaseUrl(const QUrl &amp;<db:emphasis>url</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setBaseUrl</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setBaseUrl(const QUrl &amp;url)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Set the base URL for this engine to <db:code role="parameter">url</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#baseUrl">baseUrl</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setContextForObject">
<db:title>[static] void QQmlEngine::setContextForObject(QObject *<db:emphasis>object</db:emphasis>, QQmlContext *<db:emphasis>context</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>setContextForObject</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QQmlContext *</db:type>
<db:parameter>context</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setContextForObject(QObject *object, QQmlContext *context)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link> for the <db:code role="parameter">object</db:code> to <db:code role="parameter">context</db:code>. If the <db:code role="parameter">object</db:code> already has a context, a warning is output, but the context is not changed.</db:para>
<db:para>When the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> instantiates a <db:link xlink:href="qobject.xml">QObject</db:link>, the context is set automatically.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#contextForObject">contextForObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setImportPathList">
<db:title>void QQmlEngine::setImportPathList(const QStringList &amp;<db:emphasis>paths</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setImportPathList</db:methodname>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>paths</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setImportPathList(const QStringList &amp;paths)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets <db:code role="parameter">paths</db:code> as the list of directories where the engine searches for installed modules in a URL-based directory structure.</db:para>
<db:para>By default, this list contains the paths mentioned in <db:link xlink:href="qtqml-syntax-imports.xml#qml-import-path">QML Import Path</db:link>.</db:para>
<db:warning>
<db:para>Calling setImportPathList does not preserve the default import paths.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#importPathList">importPathList</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#addImportPath">addImportPath</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setIncubationController">
<db:title>void QQmlEngine::setIncubationController(QQmlIncubationController *<db:emphasis>controller</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setIncubationController</db:methodname>
<db:methodparam>
<db:type>QQmlIncubationController *</db:type>
<db:parameter>controller</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setIncubationController(QQmlIncubationController *controller)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the engine's incubation <db:code role="parameter">controller</db:code>. The engine can only have one active controller and it does not take ownership of it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#incubationController">incubationController</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNetworkAccessManagerFactory">
<db:title>void QQmlEngine::setNetworkAccessManagerFactory(QQmlNetworkAccessManagerFactory *<db:emphasis>factory</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setNetworkAccessManagerFactory</db:methodname>
<db:methodparam>
<db:type>QQmlNetworkAccessManagerFactory *</db:type>
<db:parameter>factory</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setNetworkAccessManagerFactory(QQmlNetworkAccessManagerFactory *factory)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the <db:code role="parameter">factory</db:code> to use for creating <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>(s).</db:para>
<db:para><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> is used for all network access by QML. By implementing a factory it is possible to create custom <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> with specialized caching, proxy and cookie support.</db:para>
<db:para>The factory must be set before executing the engine.</db:para>
<db:note>
<db:para><db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> does not take ownership of the factory.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#networkAccessManagerFactory">networkAccessManagerFactory</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setOutputWarningsToStandardError">
<db:title>void QQmlEngine::setOutputWarningsToStandardError(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setOutputWarningsToStandardError</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enabled</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setOutputWarningsToStandardError(bool enabled)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Set whether warning messages will be output to stderr to <db:code role="parameter">enabled</db:code>.</db:para>
<db:para>If <db:code role="parameter">enabled</db:code> is true, any warning messages generated by QML will be output to stderr and emitted by the <db:link xlink:href="qqmlengine.xml#warnings">warnings</db:link>() signal. If <db:code role="parameter">enabled</db:code> is false, only the <db:link xlink:href="qqmlengine.xml#warnings">warnings</db:link>() signal will be emitted. This allows applications to handle warning output themselves.</db:para>
<db:para>The default value is true.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#outputWarningsToStandardError">outputWarningsToStandardError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPluginPathList">
<db:title>void QQmlEngine::setPluginPathList(const QStringList &amp;<db:emphasis>paths</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPluginPathList</db:methodname>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>paths</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPluginPathList(const QStringList &amp;paths)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the list of directories where the engine searches for native plugins for imported modules (referenced in the <db:code>qmldir</db:code> file) to <db:code role="parameter">paths</db:code>.</db:para>
<db:para>By default, the list contains only <db:code>.</db:code>, i.e. the engine searches in the directory of the <db:code>qmldir</db:code> file itself.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#pluginPathList">pluginPathList</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#addPluginPath">addPluginPath</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singletonInstance">
<db:title>T QQmlEngine::singletonInstance(int <db:emphasis>qmlTypeId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>singletonInstance</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>qmlTypeId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T singletonInstance(int qmlTypeId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the instance of a singleton type that was registered under <db:code role="parameter">qmlTypeId</db:code>.</db:para>
<db:para>The template argument <db:emphasis>T</db:emphasis> may be either <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> or a pointer to a <db:link xlink:href="qobject.xml">QObject</db:link>-derived type and depends on how the singleton was registered. If no instance of <db:emphasis>T</db:emphasis> has been created yet, it is created now. If <db:code role="parameter">qmlTypeId</db:code> does not represent a valid singleton type, either a default constructed <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> or a <db:code>nullptr</db:code> is returned.</db:para>
<db:para><db:link xlink:href="qobject.xml">QObject</db:link>* example:</db:para>
<db:programlisting language="cpp">class MySingleton : public QObject {
    Q_OBJECT

    // Register as default constructed singleton.
    QML_ELEMENT
    QML_SINGLETON

    static int typeId;
    // ...
};

    MySingleton::typeId = qmlTypeId(...);

    // Retrieve as QObject*
    QQmlEngine engine;
    MySingleton* instance = engine.singletonInstance&amp;lt;MySingleton*&amp;gt;(MySingleton::typeId);
</db:programlisting>
<db:para><db:link xlink:href="qjsvalue.xml">QJSValue</db:link> example:</db:para>
<db:programlisting language="cpp">    // Register with QJSValue callback
    int typeId = qmlRegisterSingletonType(...);

    // Retrieve as QJSValue
    QQmlEngine engine;
    QJSValue instance = engine.singletonInstance&amp;lt;QJSValue&amp;gt;(typeId);
</db:programlisting>
<db:para>It is recommended to store the QML type id, e.g. as a static member in the singleton class. The lookup via <db:link xlink:href="qqmlengine.xml#qmlTypeId">qmlTypeId</db:link>() is costly.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlTypeId">qmlTypeId</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singletonInstance-1">
<db:title>[since 6.5] T QQmlEngine::singletonInstance(QAnyStringView <db:emphasis>uri</db:emphasis>, QAnyStringView <db:emphasis>typeName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>singletonInstance</db:methodname>
<db:methodparam>
<db:type>QAnyStringView</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QAnyStringView</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T singletonInstance(QAnyStringView uri, QAnyStringView typeName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the instance of a singleton type named <db:code role="parameter">typeName</db:code> from the module specified by <db:code role="parameter">uri</db:code>.</db:para>
<db:para>This method can be used as an alternative to calling <db:link xlink:href="qqmlengine.xml#qmlTypeId">qmlTypeId</db:link> followed by the id based overload of <db:link xlink:href="qqmlengine.xml#singletonInstance">singletonInstance</db:link>. This is convenient when one only needs to do a one time setup of a singleton; if repeated access to the singleton is required, caching its typeId will allow faster subsequent access via the <db:link xlink:href="qqmlengine.xml#singletonInstance">type-id based overload</db:link>.</db:para>
<db:para>The template argument <db:emphasis>T</db:emphasis> may be either <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> or a pointer to a <db:link xlink:href="qobject.xml">QObject</db:link>-derived type and depends on how the singleton was registered. If no instance of <db:emphasis>T</db:emphasis> has been created yet, it is created now. If <db:code role="parameter">typeName</db:code> does not represent a valid singleton type, either a default constructed <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> or a <db:code>nullptr</db:code> is returned.</db:para>
<db:programlisting language="cpp">    QQmlEngine engine;
    MySingleton *singleton = engine.singletonInstance&amp;lt;MySingleton *&amp;gt;(&quot;mymodule&quot;, &quot;MySingleton&quot;);
/</db:programlisting>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlTypeId">qmlTypeId</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="trimComponentCache">
<db:title>void QQmlEngine::trimComponentCache()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>trimComponentCache</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void trimComponentCache()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Trims the engine's internal component cache.</db:para>
<db:para>This function causes the property metadata of any loaded components which are not currently in use to be destroyed.</db:para>
<db:para>A component is considered to be in use if there are any extant instances of the component itself, any instances of other components that use the component, or any objects instantiated by any of those components.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#clearComponentCache">clearComponentCache</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="urlInterceptors">
<db:title>QList&lt;QQmlAbstractUrlInterceptor *&gt; QQmlEngine::urlInterceptors() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QQmlAbstractUrlInterceptor *&gt;</db:type>
<db:methodname>urlInterceptors</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QQmlAbstractUrlInterceptor *&gt; urlInterceptors() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of currently active URL interceptors.</db:para>
</db:section>
<db:section xml:id="warnings">
<db:title>void QQmlEngine::warnings(const QList&lt;QQmlError&gt; &amp;<db:emphasis>warnings</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>warnings</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QQmlError&gt; &amp;</db:type>
<db:parameter>warnings</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void warnings(const QList&lt;QQmlError&gt; &amp;warnings)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when <db:code role="parameter">warnings</db:code> messages are generated by QML.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="QQmlModuleImportSpecialVersions-enum">
<db:title>enum QQmlModuleImportSpecialVersions</db:title>
<db:enumsynopsis>
<db:enumname>QQmlModuleImportSpecialVersions</db:enumname>
<db:enumitem>
<db:enumidentifier>QQmlModuleImportModuleAny</db:enumidentifier>
<db:enumvalue>-1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QQmlModuleImportLatest</db:enumidentifier>
<db:enumvalue>-1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>QQmlModuleImportAuto</db:enumidentifier>
<db:enumvalue>-2</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Defines some special values that can be passed to the version arguments of <db:link xlink:href="qqmlengine.xml#qmlRegisterModuleImport">qmlRegisterModuleImport</db:link>() and <db:link xlink:href="qqmlengine.xml#qmlUnregisterModuleImport">qmlUnregisterModuleImport</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link></db:emphasis>::QQmlModuleImportModuleAny</db:code></db:para>
</db:td>
<db:td><db:code>-1</db:code></db:td>
<db:td>
<db:para>When passed as majorVersion of the base module, signifies that the import is to be applied to any version of the module.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link></db:emphasis>::QQmlModuleImportLatest</db:code></db:para>
</db:td>
<db:td><db:code>-1</db:code></db:td>
<db:td>
<db:para>When passed as major or minor version of the imported module, signifies that the latest overall, or latest minor version of a specified major version shall be imported.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link></db:emphasis>::QQmlModuleImportAuto</db:code></db:para>
</db:td>
<db:td><db:code>-2</db:code></db:td>
<db:td>
<db:para>When passed as major version of the imported module, signifies that the version of the base module shall be forwarded.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="qmlAttachedPropertiesObject">
<db:title>QObject *qmlAttachedPropertiesObject(const QObject *<db:emphasis>attachee</db:emphasis>, bool <db:emphasis>create</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:type>QObject *</db:type>
<db:methodname>qmlAttachedPropertiesObject</db:methodname>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>attachee</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>create</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QObject * qmlAttachedPropertiesObject(const QObject *attachee, bool create)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The form of this template function is:</db:para>
<db:programlisting language="cpp">template&amp;lt;typename T&amp;gt; QObject *qmlAttachedPropertiesObject(const QObject *attachee, bool create = true)
</db:programlisting>
<db:para>This returns the attached object instance that has been attached to the specified <db:code role="parameter">attachee</db:code> by the attaching type <db:emphasis>T</db:emphasis>.</db:para>
<db:para>If <db:code role="parameter">create</db:code> is true and type <db:emphasis>T</db:emphasis> is a valid attaching type, this creates and returns a new attached object instance.</db:para>
<db:para>Returns <db:code>nullptr</db:code> if type <db:emphasis>T</db:emphasis> is not a valid attaching type, or if <db:code role="parameter">create</db:code> is false and no attachment object instance has previously been created for <db:code role="parameter">attachee</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ATTACHED">QML_ATTACHED</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-definetypes.xml#providing-attached-properties">Providing Attached Properties</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlClearTypeRegistrations">
<db:title>void qmlClearTypeRegistrations()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qmlClearTypeRegistrations</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qmlClearTypeRegistrations()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Clears all stored type registrations, such as those produced with <db:link xlink:href="qqmlengine.xml#qmlRegisterType">qmlRegisterType</db:link>().</db:para>
<db:para>Do not call this function while a <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> exists or behavior will be undefined. Any existing QQmlEngines must be deleted before calling this function. This function only affects the application global cache. Delete the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> to clear all cached data relating to that engine.</db:para>
</db:section>
<db:section xml:id="qmlContext">
<db:title>QQmlContext *qmlContext(const QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QQmlContext *</db:type>
<db:methodname>qmlContext</db:methodname>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQmlContext * qmlContext(const QObject *object)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link> associated with <db:code role="parameter">object</db:code>, if any. This is equivalent to <db:link xlink:href="qqmlengine.xml#contextForObject">QQmlEngine::contextForObject</db:link>(object).</db:para>
<db:note>
<db:para>Add <db:code>#include &lt;QtQml&gt;</db:code> to use this function.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#contextForObject">contextForObject</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlEngine">qmlEngine</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlEngine">
<db:title>QQmlEngine *qmlEngine(const QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QQmlEngine *</db:type>
<db:methodname>qmlEngine</db:methodname>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQmlEngine * qmlEngine(const QObject *object)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> associated with <db:code role="parameter">object</db:code>, if any. This is equivalent to <db:link xlink:href="qqmlengine.xml#contextForObject">QQmlEngine::contextForObject</db:link>(object)-&gt;engine(), but more efficient.</db:para>
<db:note>
<db:para>Add <db:code>#include &lt;QtQml&gt;</db:code> to use this function.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#contextForObject">contextForObject</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlContext">qmlContext</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlProtectModule">
<db:title>bool qmlProtectModule(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>majVersion</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>qmlProtectModule</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>majVersion</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool qmlProtectModule(const char *uri, int majVersion)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function protects a module from further modification. This can be used to prevent other plugins from injecting types into your module. It can also be a performance improvement, as it allows the engine to skip checking for the possibility of new types or plugins when this import is reached.</db:para>
<db:para>Once qmlProtectModule has been called, a QML engine will not search for a new <db:code>qmldir</db:code> file to load the module anymore. It will re-use any <db:code>qmldir</db:code> files it has loaded before, though. Therefore, types present at this point continue to work. Mind that different QML engines may load different modules. The module protection, however, is global and affects all engines. The overhead of locating <db:code>qmldir</db:code> files and loading plugins may be noticeable with slow file systems. Therefore, protecting a module once you are sure you won't need to load it anymore can be a good optimization. Mind also that the module lock not only affects plugins but also any other qmldir directives, like <db:code>import</db:code> or <db:code>prefer</db:code>, as well as any composite types or scripts declared in a <db:code>qmldir</db:code> file.</db:para>
<db:para>In addition, after this function is called, any attempt to register C++ types into this uri, major version combination will lead to a runtime error.</db:para>
<db:para>Returns true if the module with <db:code role="parameter">uri</db:code> as a <db:link xlink:href="qtqml-modules-identifiedmodules.xml">module identifier</db:link> and <db:code role="parameter">majVersion</db:code> as a major version number was found and locked, otherwise returns false. The module must contain exported types in order to be found.</db:para>
</db:section>
<db:section xml:id="qmlRegisterAnonymousType">
<db:title>int qmlRegisterAnonymousType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterAnonymousType</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterAnonymousType(const char *uri, int versionMajor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This template function registers the C++ type in the QML system as an anonymous type. The resulting QML type does not have a name. Therefore, instances of this type cannot be created from the QML system. You can, however, access instances of the type when they are exposed as properties of other types.</db:para>
<db:para>Use this function when the type will not be referenced by name, specifically for C++ types that are used on the left-hand side of a property binding. To indicate to which module the type belongs use <db:code role="parameter">uri</db:code> and <db:code role="parameter">versionMajor</db:code>.</db:para>
<db:para>For example, consider the following two classes:</db:para>
<db:programlisting language="cpp">class Bar : public QObject
{
    Q_OBJECT
    Q_PROPERTY(QString baz READ baz WRITE setBaz NOTIFY bazChanged)

public:
    Bar() {}

    QString baz() const { return mBaz; }

    void setBaz(const QString &amp;amp;baz)
    {
        if (baz == mBaz)
            return;

        mBaz = baz;
        emit bazChanged();
    }

signals:
    void bazChanged();

private:
    QString mBaz;
};

class Foo : public QObject
{
    Q_OBJECT
    Q_PROPERTY(Bar *bar READ bar CONSTANT FINAL)

public:
    Foo() {}

    Bar *bar() { return &amp;amp;mBar; }

private:
    Bar mBar;
};
</db:programlisting>
<db:para>In QML, we assign a string to the <db:code>baz</db:code> property of <db:code>bar</db:code>:</db:para>
<db:programlisting language="cpp">Foo {
    bar.baz: &quot;abc&quot;
    Component.onCompleted: print(bar.baz)
}
</db:programlisting>
<db:para>For the QML engine to know that the <db:code>Bar</db:code> type has a <db:code>baz</db:code> property, we have to make <db:code>Bar</db:code> known:</db:para>
<db:programlisting language="cpp">qmlRegisterType&amp;lt;Foo&amp;gt;(&quot;App&quot;, 1, 0, &quot;Foo&quot;);
qmlRegisterAnonymousType&amp;lt;Bar&amp;gt;(&quot;App&quot;, 1);
</db:programlisting>
<db:para>As the <db:code>Foo</db:code> type is instantiated in QML, it must be registered with the version of <db:link xlink:href="qqmlengine.xml#qmlRegisterType">qmlRegisterType</db:link>() that takes an element name.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link></db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterExtendedType">
<db:title>int qmlRegisterExtendedType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterExtendedType</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>qmlName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterExtendedType(const char *uri, int versionMajor, int versionMinor, const char *qmlName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This template function registers the C++ type and its extension object in the QML system with the name <db:code role="parameter">qmlName</db:code> in the library imported from <db:code role="parameter">uri</db:code> having version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>. Properties not available in the main type will be searched for in the extension object.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_EXTENDED">QML_EXTENDED</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlRegisterType">qmlRegisterType</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-extension-objects">Registering Extension Objects</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterExtendedUncreatableType">
<db:title>int qmlRegisterExtendedUncreatableType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>, const QString &amp;<db:emphasis>reason</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterExtendedUncreatableType</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>qmlName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>reason</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterExtendedUncreatableType(const char *uri, int versionMajor, int versionMinor, const char *qmlName, const QString &amp;reason)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This template function registers the C++ type and its extension in the QML system with the name <db:code role="parameter">qmlName</db:code> in the library imported from <db:code role="parameter">uri</db:code> having version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>While the type has a name and a type, it cannot be created. An error message with the given <db:code role="parameter">reason</db:code> is printed if the user attempts to create an instance of this type.</db:para>
<db:para>This is useful where the type is only intended for providing attached properties, enum values or an abstract base class with its extension.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_EXTENDED">QML_EXTENDED</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlRegisterUncreatableType">qmlRegisterUncreatableType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterModule">
<db:title>void qmlRegisterModule(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qmlRegisterModule</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qmlRegisterModule(const char *uri, int versionMajor, int versionMinor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function registers a module in a particular <db:code role="parameter">uri</db:code> with a version specified in <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>This can be used to make a certain module version available, even if no types are registered for that version. This is particularly useful for keeping the versions of related modules in sync.</db:para>
</db:section>
<db:section xml:id="qmlRegisterModuleImport">
<db:title>void qmlRegisterModuleImport(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>moduleMajor</db:emphasis>, const char *<db:emphasis>import</db:emphasis>, int <db:emphasis>importMajor</db:emphasis> = QQmlModuleImportLatest, int <db:emphasis>importMinor</db:emphasis> = QQmlModuleImportLatest)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qmlRegisterModuleImport</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>moduleMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>import</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>importMajor</db:parameter>
<db:initializer>QQmlModuleImportLatest</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>importMinor</db:parameter>
<db:initializer>QQmlModuleImportLatest</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qmlRegisterModuleImport(const char *uri, int moduleMajor, const char *import, int importMajor, int importMinor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers a qmldir-import for module <db:code role="parameter">uri</db:code> of major version <db:code role="parameter">moduleMajor</db:code>.</db:para>
<db:para>This has the same effect as an <db:code>import</db:code> statement in a qmldir file: Whenever <db:code role="parameter">uri</db:code> of version <db:code role="parameter">moduleMajor</db:code> is imported, <db:code role="parameter">import</db:code> of version <db:code role="parameter">importMajor</db:code>. <db:code role="parameter">importMinor</db:code> is automatically imported, too. If <db:code role="parameter">importMajor</db:code> is <db:link xlink:href="qqmlengine.xml#QQmlModuleImportSpecialVersions-enum">QQmlModuleImportLatest</db:link> the latest version available of that module is imported, and <db:code role="parameter">importMinor</db:code> does not matter. If <db:code role="parameter">importMinor</db:code> is <db:link xlink:href="qqmlengine.xml#QQmlModuleImportSpecialVersions-enum">QQmlModuleImportLatest</db:link> the latest minor version of a <db:code role="parameter">importMajor</db:code> is chosen. If <db:code role="parameter">importMajor</db:code> is <db:link xlink:href="qqmlengine.xml#QQmlModuleImportSpecialVersions-enum">QQmlModuleImportAuto</db:link> the version of <db:code role="parameter">import</db:code> is version of <db:code role="parameter">uri</db:code> being imported, and <db:code role="parameter">importMinor</db:code> does not matter. If <db:code role="parameter">moduleMajor</db:code> is <db:link xlink:href="qqmlengine.xml#QQmlModuleImportSpecialVersions-enum">QQmlModuleImportModuleAny</db:link> the module import is applied for any major version of <db:code role="parameter">uri</db:code>. For example, you may specify that whenever any version of MyModule is imported, the latest version of MyOtherModule should be imported. Then, the following call would be appropriate:</db:para>
<db:programlisting language="cpp">qmlRegisterModuleImport(&quot;MyModule&quot;, QQmlModuleImportModuleAny,
                        &quot;MyOtherModule&quot;, QQmlModuleImportLatest);
</db:programlisting>
<db:para>Or, you may specify that whenever major version 5 of &quot;MyModule&quot; is imported, then version 3.14 of &quot;MyOtherModule&quot; should be imported:</db:para>
<db:programlisting language="cpp">qmlRegisterModuleImport(&quot;MyModule&quot;, 5, &quot;MyOtherModule&quot;, 3, 14);
</db:programlisting>
<db:para>Finally, if you always want the same version of &quot;MyOtherModule&quot; to be imported whenever &quot;MyModule&quot; is imported, specify the following:</db:para>
<db:programlisting language="cpp">qmlRegisterModuleImport(&quot;MyModule&quot;, QQmlModuleImportModuleAny,
                        &quot;MyOtherModule&quot;, QQmlModuleImportAuto);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#qmlUnregisterModuleImport">qmlUnregisterModuleImport</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterRevision">
<db:title>int qmlRegisterRevision(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterRevision</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterRevision(const char *uri, int versionMajor, int versionMinor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This template function registers the specified revision of a C++ type in the QML system with the library imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:programlisting language="cpp">template&amp;lt;typename T, int metaObjectRevision&amp;gt;
int qmlRegisterRevision(const char *uri, int versionMajor, int versionMinor);
</db:programlisting>
<db:para>This function is typically used to register the revision of a base class to use for the specified version of the type (see <db:link xlink:href="qtqml-cppintegration-definetypes.xml#type-revisions-and-versions">Type Revisions and Versions</db:link>).</db:para>
</db:section>
<db:section xml:id="qmlRegisterSingletonInstance">
<db:title>int qmlRegisterSingletonInstance(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>typeName</db:emphasis>, QObject *<db:emphasis>cppObject</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterSingletonInstance</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>cppObject</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterSingletonInstance(const char *uri, int versionMajor, int versionMinor, const char *typeName, QObject *cppObject)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is used to register a singleton object <db:code role="parameter">cppObject</db:code>, with a particular <db:code role="parameter">uri</db:code> and <db:code role="parameter">typeName</db:code>. Its version is a combination of <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>Installing a singleton type into a URI allows you to provide arbitrary functionality (methods and properties) to QML code without requiring individual instances of the type to be instantiated by the client.</db:para>
<db:para>Use this function to register an object of the given type T as a singleton type.</db:para>
<db:para>A <db:link xlink:href="qobject.xml">QObject</db:link> singleton type may be referenced via the type name with which it was registered; in turn this type name may be used as the target in a <db:link xlink:href="qml-qtqml-connections.xml">Connections</db:link> type, or like any other type ID. However, there's one exception: a <db:link xlink:href="qobject.xml">QObject</db:link> singleton type property can't be aliased because the singleton type name does not identify an object within the same component as any other item.</db:para>
<db:note>
<db:para><db:code role="parameter">cppObject</db:code> must outlive the QML engine in which it is used. Moreover, cppObject must have the same thread affinity as the engine. If you want separate singleton instances for multiple engines, you need to use <db:link xlink:href="qqmlengine.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link>. See <db:link xlink:href="threads-qobject.xml">Threads and QObjects</db:link> for more information about thread safety.</db:para>
</db:note>
<db:para><db:emphasis role="bold">NOTE:</db:emphasis> qmlRegisterSingleton can only be used when all types of that module are registered procedurally.</db:para>
<db:para>Usage:</db:para>
<db:programlisting language="cpp">// First, define your QObject which provides the functionality.
class SingletonTypeExample : public QObject
{
    Q_OBJECT
    Q_PROPERTY(int someProperty READ someProperty WRITE setSomeProperty NOTIFY somePropertyChanged)

public:
    explicit SingletonTypeExample(QObject* parent = nullptr) : QObject(parent) {}

    Q_INVOKABLE int doSomething()
    {
        setSomeProperty(5);
        return m_someProperty;
    }

    int someProperty() const { return m_someProperty; }
    void setSomeProperty(int val) {
        if (m_someProperty != val) {
            m_someProperty = val;
            emit somePropertyChanged(val);
        }
    }

signals:
    void somePropertyChanged(int newValue);

private:
    int m_someProperty = 0;
};
</db:programlisting>
<db:programlisting language="cpp">// Second, create an instance of the object

// allocate example before the engine to ensure that it outlives it
QScopedPointer&amp;lt;SingletonTypeExample&amp;gt; example(new SingletonTypeExample);
QQmlEngine engine;

// Third, register the singleton type provider with QML by calling this
// function in an initialization function.
qmlRegisterSingletonInstance(&quot;Qt.example.qobjectSingleton&quot;, 1, 0, &quot;MyApi&quot;, example.get());
</db:programlisting>
<db:para>In order to use the registered singleton type in QML, you must import the URI with the corresponding version.</db:para>
<db:programlisting language="qml">import QtQuick 2.0
import Qt.example.qobjectSingleton 1.0
Item {
    id: root
    property int someValue: MyApi.someProperty

    Component.onCompleted: {
        console.log(MyApi.doSomething())
    }
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterSingletonType">
<db:title>int qmlRegisterSingletonType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>typeName</db:emphasis>, std::function&lt;QJSValue (QQmlEngine *, QJSEngine *)&gt; <db:emphasis>callback</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterSingletonType</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>std::function&lt;QJSValue (QQmlEngine *, QJSEngine *)&gt;</db:type>
<db:parameter>callback</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterSingletonType(const char *uri, int versionMajor, int versionMinor, const char *typeName, std::function&lt;QJSValue (QQmlEngine *, QJSEngine *)&gt; callback)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function may be used to register a singleton type provider <db:code role="parameter">callback</db:code> in a particular <db:code role="parameter">uri</db:code> and <db:code role="parameter">typeName</db:code> with a version specified in <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>Installing a singleton type allows developers to provide arbitrary functionality (methods and properties) to a client without requiring individual instances of the type to be instantiated by the client.</db:para>
<db:para>A singleton type may be either a <db:link xlink:href="qobject.xml">QObject</db:link> or a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>. This function should be used to register a singleton type provider function which returns a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> as a singleton type.</db:para>
<db:para><db:emphasis role="bold">NOTE:</db:emphasis> <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> singleton type properties will <db:emphasis role="bold">not</db:emphasis> trigger binding re-evaluation if changed.</db:para>
<db:para>Usage:</db:para>
<db:programlisting language="cpp">// First, define the singleton type provider function (callback).
static QJSValue example_qjsvalue_singletontype_provider(QQmlEngine *engine, QJSEngine *scriptEngine)
{
    Q_UNUSED(engine)

    static int seedValue = 5;
    QJSValue example = scriptEngine-&amp;gt;newObject();
    example.setProperty(&quot;someProperty&quot;, seedValue++);
    return example;
}

// Second, register the singleton type provider with QML by calling this function in an initialization function.
qmlRegisterSingletonType(&quot;Qt.example.qjsvalueApi&quot;, 1, 0, &quot;MyApi&quot;, example_qjsvalue_singletontype_provider);
</db:programlisting>
<db:para>Alternatively, you can use a C++11 lambda:</db:para>
<db:programlisting language="cpp">qmlRegisterSingletonType(&quot;Qt.example.qjsvalueApi&quot;, 1, 0, &quot;MyApi&quot;, [](QQmlEngine *engine, QJSEngine *scriptEngine) -&amp;gt; QJSValue {
    Q_UNUSED(engine)

    static int seedValue = 5;
    QJSValue example = scriptEngine-&amp;gt;newObject();
    example.setProperty(&quot;someProperty&quot;, seedValue++);
    return example;
});
</db:programlisting>
<db:para>In order to use the registered singleton type in QML, you must import the singleton type.</db:para>
<db:programlisting language="qml">import QtQuick 2.0
import Qt.example.qjsvalueApi 1.0 as ExampleApi
Item {
    id: root
    property int someValue: ExampleApi.MyApi.someProperty
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterSingletonType-1">
<db:title>int qmlRegisterSingletonType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>typeName</db:emphasis>, std::function&lt;QObject *(QQmlEngine *, QJSEngine *)&gt; <db:emphasis>callback</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterSingletonType</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>std::function&lt;QObject *(QQmlEngine *, QJSEngine *)&gt;</db:type>
<db:parameter>callback</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterSingletonType(const char *uri, int versionMajor, int versionMinor, const char *typeName, std::function&lt;QObject *(QQmlEngine *, QJSEngine *)&gt; callback)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function may be used to register a singleton type provider <db:code role="parameter">callback</db:code> in a particular <db:code role="parameter">uri</db:code> and <db:code role="parameter">typeName</db:code> with a version specified in <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>Installing a singleton type into a uri allows developers to provide arbitrary functionality (methods and properties) to clients without requiring individual instances ot the type to be instantiated by the client.</db:para>
<db:para>A singleton type may be either a <db:link xlink:href="qobject.xml">QObject</db:link> or a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>. This function should be used to register a singleton type provider function which returns a <db:link xlink:href="qobject.xml">QObject</db:link> of the given type T as a singleton type.</db:para>
<db:para>A <db:link xlink:href="qobject.xml">QObject</db:link> singleton type may be referenced via the type name with which it was registered, and this typename may be used as the target in a <db:link xlink:href="qml-qtqml-connections.xml">Connections</db:link> type or otherwise used as any other type id would. One exception to this is that a <db:link xlink:href="qobject.xml">QObject</db:link> singleton type property may not be aliased.</db:para>
<db:para><db:emphasis role="bold">NOTE:</db:emphasis> A <db:link xlink:href="qobject.xml">QObject</db:link> singleton type instance returned from a singleton type provider is owned by the QML engine unless the object has explicit QQmlEngine::CppOwnership flag set.</db:para>
<db:para>Usage:</db:para>
<db:programlisting language="cpp">// First, define your QObject which provides the functionality.
class SingletonTypeExample : public QObject
{
    Q_OBJECT
    Q_PROPERTY (int someProperty READ someProperty WRITE setSomeProperty NOTIFY somePropertyChanged)

public:
    SingletonTypeExample(QObject *parent = nullptr)
        : QObject(parent), m_someProperty(0)
    {
    }

    ~SingletonTypeExample() {}

    Q_INVOKABLE int doSomething() { setSomeProperty(5); return m_someProperty; }

    int someProperty() const { return m_someProperty; }
    void setSomeProperty(int val) { m_someProperty = val; emit somePropertyChanged(val); }

signals:
    void somePropertyChanged(int newValue);

private:
    int m_someProperty;
};

// Second, define the singleton type provider function (callback).
static QObject *example_qobject_singletontype_provider(QQmlEngine *engine, QJSEngine *scriptEngine)
{
    Q_UNUSED(engine)
    Q_UNUSED(scriptEngine)

    SingletonTypeExample *example = new SingletonTypeExample();
    return example;
}

// Third, register the singleton type provider with QML by calling this function in an initialization function.
qmlRegisterSingletonType&amp;lt;SingletonTypeExample&amp;gt;(&quot;Qt.example.qobjectSingleton&quot;, 1, 0, &quot;MyApi&quot;, example_qobject_singletontype_provider);
</db:programlisting>
<db:para>Alternatively, you can use a C++11 lambda:</db:para>
<db:programlisting language="cpp">qmlRegisterSingletonType&amp;lt;SingletonTypeExample&amp;gt;(&quot;Qt.example.qobjectSingleton&quot;, 1, 0, &quot;MyApi&quot;, [](QQmlEngine *engine, QJSEngine *scriptEngine) -&amp;gt; QObject * {
    Q_UNUSED(engine)
    Q_UNUSED(scriptEngine)

    SingletonTypeExample *example = new SingletonTypeExample();
    return example;
});
</db:programlisting>
<db:para>In order to use the registered singleton type in QML, you must import the singleton type.</db:para>
<db:programlisting language="qml">import QtQuick 2.0
import Qt.example.qobjectSingleton 1.0
Item {
    id: root
    property int someValue: MyApi.someProperty

    Component.onCompleted: {
        someValue = MyApi.doSomething()
    }
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterSingletonType-2">
<db:title>int qmlRegisterSingletonType(const QUrl &amp;<db:emphasis>url</db:emphasis>, const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterSingletonType</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>qmlName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterSingletonType(const QUrl &amp;url, const char *uri, int versionMajor, int versionMinor, const char *qmlName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function may be used to register a singleton type with the name <db:code role="parameter">qmlName</db:code>, in the library imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>. The type is defined by the QML file located at <db:code role="parameter">url</db:code>. The url must be an absolute URL, i.e. url.isRelative() == false.</db:para>
<db:para>In addition the type's QML file must have pragma Singleton statement among its import statements.</db:para>
<db:para>A singleton type may be referenced via the type name with which it was registered, and this typename may be used as the target in a <db:link xlink:href="qml-qtqml-connections.xml">Connections</db:link> type or otherwise used as any other type id would. One exception to this is that a singleton type property may not be aliased (because the singleton type name does not identify an object within the same component as any other item).</db:para>
<db:para>Usage:</db:para>
<db:programlisting language="qml">// First, define your QML singleton type which provides the functionality.
pragma Singleton
import QtQuick 2.0
Item {
    property int testProp1: 125
}
</db:programlisting>
<db:programlisting language="cpp">// Second, register the QML singleton type by calling this function in an initialization function.
qmlRegisterSingletonType(QUrl(&quot;file:///absolute/path/SingletonType.qml&quot;), &quot;Qt.example.qobjectSingleton&quot;, 1, 0, &quot;RegisteredSingleton&quot;);
</db:programlisting>
<db:para>In order to use the registered singleton type in QML, you must import the singleton type.</db:para>
<db:programlisting language="qml">import QtQuick 2.0
import Qt.example.qobjectSingleton 1.0
Item {
    id: root
    property int someValue: RegisteredSingleton.testProp1
}
</db:programlisting>
<db:para>It is also possible to have QML singleton types registered without using the <db:link xlink:href="qqmlengine.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link> function. That can be done by adding a pragma Singleton statement among the imports of the type's QML file. In addition the type must be defined in a qmldir file with a singleton keyword and the qmldir must be imported by the QML files using the singleton.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterType">
<db:title>int qmlRegisterType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterType</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>qmlName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterType(const char *uri, int versionMajor, int versionMinor, const char *qmlName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This template function registers the C++ type in the QML system with the name <db:code role="parameter">qmlName</db:code>, in the library imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:para>There are two forms of this template function:</db:para>
<db:programlisting language="cpp">template&amp;lt;typename T&amp;gt;
int qmlRegisterType(const char *uri, int versionMajor, int versionMinor, const char *qmlName);

template&amp;lt;typename T, int metaObjectRevision&amp;gt;
int qmlRegisterType(const char *uri, int versionMajor, int versionMinor, const char *qmlName);
</db:programlisting>
<db:para>The former is the standard form which registers the type <db:emphasis>T</db:emphasis> as a new type. The latter allows a particular revision of a class to be registered in a specified version (see <db:link xlink:href="qtqml-cppintegration-definetypes.xml#type-revisions-and-versions">Type Revisions and Versions</db:link>).</db:para>
<db:para>For example, this registers a C++ class <db:code>MySliderItem</db:code> as a QML type named <db:code>Slider</db:code> for version 1.0 of a type namespace called &quot;com.mycompany.qmlcomponents&quot;:</db:para>
<db:programlisting language="cpp">qmlRegisterType&amp;lt;MySliderItem&amp;gt;(&quot;com.mycompany.qmlcomponents&quot;, 1, 0, &quot;Slider&quot;);
</db:programlisting>
<db:para>Once this is registered, the type can be used in QML by importing the specified type namespace and version number:</db:para>
<db:programlisting language="qml">import com.mycompany.qmlcomponents 1.0

Slider {
    // ...
}
</db:programlisting>
<db:para>Note that it's perfectly reasonable for a library to register types to older versions than the actual version of the library. Indeed, it is normal for the new library to allow QML written to previous versions to continue to work, even if more advanced versions of some of its types are available.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterType-1">
<db:title>int qmlRegisterType(const QUrl &amp;<db:emphasis>url</db:emphasis>, const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterType</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>qmlName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterType(const QUrl &amp;url, const char *uri, int versionMajor, int versionMinor, const char *qmlName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function registers a type in the QML system with the name <db:code role="parameter">qmlName</db:code>, in the library imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>. The type is defined by the QML file located at <db:code role="parameter">url</db:code>. The url must be an absolute URL, i.e. url.isRelative() == false.</db:para>
<db:para>Normally QML files can be loaded as types directly from other QML files, or using a qmldir file. This function allows registration of files to types from C++ code, such as when the type mapping needs to be procedurally determined at startup.</db:para>
<db:para>Returns -1 if the registration was not successful.</db:para>
</db:section>
<db:section xml:id="qmlRegisterTypeNotAvailable">
<db:title>int qmlRegisterTypeNotAvailable(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>, const QString &amp;<db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterTypeNotAvailable</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>qmlName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterTypeNotAvailable(const char *uri, int versionMajor, int versionMinor, const char *qmlName, const QString &amp;message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function registers a type in the QML system with the name <db:code role="parameter">qmlName</db:code>, in the type namespace imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>, but any attempt to instantiate the type will produce the given error <db:code role="parameter">message</db:code>.</db:para>
<db:para>Normally, the types exported by a plugin should be fixed. However, if a C++ type is not available, you should at least &quot;reserve&quot; the QML type name, and give the user of the unavailable type a meaningful error message.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">#ifdef NO_GAMES_ALLOWED
qmlRegisterTypeNotAvailable(&quot;MinehuntCore&quot;, 0, 1, &quot;Game&quot;, &quot;Get back to work, slacker!&quot;);
#else
qmlRegisterType&amp;lt;MinehuntGame&amp;gt;(&quot;MinehuntCore&quot;, 0, 1, &quot;Game&quot;);
#endif
</db:programlisting>
<db:para>This will cause any QML which imports the &quot;MinehuntCore&quot; type namespace and attempts to use the type to produce an error message:</db:para>
<db:programlisting language="cpp">fun.qml: Get back to work, slacker!
   Game {
   ^
</db:programlisting>
<db:para>Without this, a generic &quot;Game is not a type&quot; message would be given.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_UNAVAILABLE">QML_UNAVAILABLE</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlRegisterUncreatableType">qmlRegisterUncreatableType</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterUncreatableMetaObject">
<db:title>int qmlRegisterUncreatableMetaObject(const QMetaObject &amp;<db:emphasis>staticMetaObject</db:emphasis>, const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>, const QString &amp;<db:emphasis>reason</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterUncreatableMetaObject</db:methodname>
<db:methodparam>
<db:type>const QMetaObject &amp;</db:type>
<db:parameter>staticMetaObject</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>qmlName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>reason</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterUncreatableMetaObject(const QMetaObject &amp;staticMetaObject, const char *uri, int versionMajor, int versionMinor, const char *qmlName, const QString &amp;reason)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function registers the <db:code role="parameter">staticMetaObject</db:code> and its extension in the QML system with the name <db:code role="parameter">qmlName</db:code> in the library imported from <db:code role="parameter">uri</db:code> having version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>An instance of the meta object cannot be created. An error message with the given <db:code role="parameter">reason</db:code> is printed if the user attempts to create it.</db:para>
<db:para>This function is useful for registering <db:link xlink:href="qobject.xml#Q_NAMESPACE">Q_NAMESPACE</db:link> namespaces.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">namespace MyNamespace {
  Q_NAMESPACE
  enum MyEnum {
      Key1,
      Key2,
  };
  Q_ENUM_NS(MyEnum)
}

//...
qmlRegisterUncreatableMetaObject(MyNamespace::staticMetaObject, &quot;io.qt&quot;, 1, 0, &quot;MyNamespace&quot;, &quot;Access to enums &amp;amp; flags only&quot;);
</db:programlisting>
<db:para>On the QML side, you can now use the registered enums:</db:para>
<db:programlisting language="cpp">Component.onCompleted: console.log(MyNamespace.Key2)
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlRegisterUncreatableType">
<db:title>int qmlRegisterUncreatableType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>, const QString &amp;<db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlRegisterUncreatableType</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>qmlName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlRegisterUncreatableType(const char *uri, int versionMajor, int versionMinor, const char *qmlName, const QString &amp;message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This template function registers the C++ type in the QML system with the name <db:code role="parameter">qmlName</db:code>, in the library imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>While the type has a name and a type, it cannot be created, and the given error <db:code role="parameter">message</db:code> will result if creation is attempted.</db:para>
<db:para>This is useful where the type is only intended for providing attached properties or enum values.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlRegisterTypeNotAvailable">qmlRegisterTypeNotAvailable</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlTypeId">
<db:title>int qmlTypeId(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qmlTypeId</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>versionMinor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>qmlName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qmlTypeId(const char *uri, int versionMajor, int versionMinor, const char *qmlName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the QML type id of a type that was registered with the name <db:code role="parameter">qmlName</db:code> in a particular <db:code role="parameter">uri</db:code> and a version specified in <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>This function returns the same value as the QML type registration functions such as <db:link xlink:href="qqmlengine.xml#qmlRegisterType">qmlRegisterType</db:link>() and <db:link xlink:href="qqmlengine.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link>().</db:para>
<db:para>If <db:code role="parameter">qmlName</db:code>, <db:code role="parameter">uri</db:code> and <db:code role="parameter">versionMajor</db:code> match a registered type, but the specified minor version in <db:code role="parameter">versionMinor</db:code> is higher, then the id of the type with the closest minor version is returned.</db:para>
<db:para>Returns -1 if no matching type was found or one of the given parameters was invalid.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlRegisterType">qmlRegisterType</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlUnregisterModuleImport">
<db:title>void qmlUnregisterModuleImport(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>moduleMajor</db:emphasis>, const char *<db:emphasis>import</db:emphasis>, int <db:emphasis>importMajor</db:emphasis> = QQmlModuleImportLatest, int <db:emphasis>importMinor</db:emphasis> = QQmlModuleImportLatest)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qmlUnregisterModuleImport</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>moduleMajor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>import</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>importMajor</db:parameter>
<db:initializer>QQmlModuleImportLatest</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>importMinor</db:parameter>
<db:initializer>QQmlModuleImportLatest</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qmlUnregisterModuleImport(const char *uri, int moduleMajor, const char *import, int importMajor, int importMinor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes a module import previously registered with <db:link xlink:href="qqmlengine.xml#qmlRegisterModuleImport">qmlRegisterModuleImport</db:link>()</db:para>
<db:para>Calling this function makes sure that <db:code role="parameter">import</db:code> of version <db:code role="parameter">importMajor</db:code>.<db:code role="parameter">importMinor</db:code> is not automatically imported anymore when <db:code role="parameter">uri</db:code> of version <db:code role="parameter">moduleMajor</db:code> is. The version resolution works the same way as with <db:link xlink:href="qqmlengine.xml#qmlRegisterModuleImport">qmlRegisterModuleImport</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#qmlRegisterModuleImport">qmlRegisterModuleImport</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QML_ADDED_IN_VERSION">
<db:title>QML_ADDED_IN_VERSION(<db:emphasis>MAJOR</db:emphasis>, <db:emphasis>MINOR</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_ADDED_IN_VERSION</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>MAJOR</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>MINOR</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_ADDED_IN_VERSION(MAJOR, MINOR)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares that the enclosing type or namespace was added in the specified <db:code role="parameter">MAJOR</db:code>.<db:code role="parameter">MINOR</db:code> version. The version is assumed to be in line with any revisions given by <db:link xlink:href="qobject.xml#Q_REVISION">Q_REVISION</db:link>() macros on methods, slots, or signals, and any REVISION() attributes on properties declared with <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>().</db:para>
<db:para><db:link xlink:href="">QML_ADDED_IN_VERSION</db:link>() only takes effect if the type or namespace is available in QML, by having a <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link>, <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link>, or <db:link xlink:href="qqmlengine.xml#QML_INTERFACE">QML_INTERFACE</db:link> macro.</db:para>
<db:para>If the QML module the type belongs to is imported with a lower version than the one determined this way, the QML type is invisible.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_ANONYMOUS">
<db:title>QML_ANONYMOUS</db:title>
<db:methodsynopsis>
<db:methodname>QML_ANONYMOUS</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_ANONYMOUS</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares the enclosing type to be available, but anonymous in QML. The type cannot be created or used to declare properties in QML, but when passed from C++, it is recognized. In QML, you can use properties of this type if they are declared in C++.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_INTERFACE">QML_INTERFACE</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_ATTACHED">
<db:title>QML_ATTACHED(<db:emphasis>ATTACHED_TYPE</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_ATTACHED</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>ATTACHED_TYPE</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_ATTACHED(ATTACHED_TYPE)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares that the enclosing type attaches <db:code role="parameter">ATTACHED_TYPE</db:code> as an <db:link xlink:href="qtqml-syntax-objectattributes.xml#attached-properties-and-attached-signal-handlers">attached property</db:link> to other types. This takes effect if the type is exposed to QML using a <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() macro.</db:para>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlAttachedPropertiesObject">qmlAttachedPropertiesObject</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-definetypes.xml#providing-attached-properties">Providing Attached Properties</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_CONSTRUCTIBLE_VALUE">
<db:title>[since 6.5] QML_CONSTRUCTIBLE_VALUE</db:title>
<db:methodsynopsis>
<db:methodname>QML_CONSTRUCTIBLE_VALUE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_CONSTRUCTIBLE_VALUE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Marks the surrounding value type as constructible. That is, any <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> constructors of the type that take exactly one argument can be used when assigning a JavaScript value to a property of this type.</db:para>
<db:para>You can declare a constructible value type as follows:</db:para>
<db:programlisting language="cpp">class MyValueType
{
    Q_GADGET
    QML_VALUE_TYPE(myValueType)
    QML_CONSTRUCTIBLE_VALUE
public:
    Q_INVOKABLE MyValueType(double d);

    // ...
};
</db:programlisting>
<db:para>With the above type, the following QML code will produce a <db:code>MyValueType</db:code> value using the given constructor and assign it to the property.</db:para>
<db:programlisting language="qml">QtObject {
    property myValueType v: 5.4
}
</db:programlisting>
<db:para>You can also construct lists of values this way:</db:para>
<db:programlisting language="qml">QtObject {
    property list&amp;lt;myValueType&amp;gt; v: [5.4, 4.5, 3.3]
}
</db:programlisting>
<db:para>If you make value types <db:link xlink:href="qtqml-documents-structure.xml#valuetypebehavior">addressable</db:link>, you can use such a type in a <db:link xlink:href="qtqml-javascript-hostenvironment.xml#type-annotations-and-assertions">type assertion</db:link> to explicitly construct it:</db:para>
<db:programlisting language="qml">pragma ValueTypeBehavior: Addressable

QtObject {
    function process(d: real) {
        let v = d as myValueType;
        // v is a myValueType now, not a number
    }
}
</db:programlisting>
<db:para>This macro was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_VALUE_TYPE">QML_VALUE_TYPE</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_DECLARE_TYPE">
<db:title>QML_DECLARE_TYPE</db:title>
<db:methodsynopsis>
<db:methodname>QML_DECLARE_TYPE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_DECLARE_TYPE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Equivalent to <db:code>Q_DECLARE_METATYPE(TYPE *)</db:code> and <db:code>Q_DECLARE_METATYPE(QQmlListProperty&lt;TYPE&gt;)</db:code></db:para>
</db:section>
<db:section xml:id="QML_DECLARE_TYPEINFO">
<db:title>QML_DECLARE_TYPEINFO(<db:emphasis>Type</db:emphasis>, <db:emphasis>Flags</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_DECLARE_TYPEINFO</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>Flags</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_DECLARE_TYPEINFO(Type, Flags)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares additional properties of the given <db:code role="parameter">Type</db:code> as described by the specified <db:code role="parameter">Flags</db:code>.</db:para>
<db:para>Current the only supported type info is <db:code>QML_HAS_ATTACHED_PROPERTIES</db:code> which declares that the <db:code role="parameter">Type</db:code> supports <db:link xlink:href="qtqml-syntax-objectattributes.xml#attached-properties-and-attached-signal-handlers">attached properties</db:link>. QML_DECLARE_TYPEINFO() is not necessary if <db:code role="parameter">Type</db:code> contains the <db:link xlink:href="qqmlengine.xml#QML_ATTACHED">QML_ATTACHED</db:link> macro.</db:para>
</db:section>
<db:section xml:id="QML_ELEMENT">
<db:title>QML_ELEMENT</db:title>
<db:methodsynopsis>
<db:methodname>QML_ELEMENT</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_ELEMENT</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares the enclosing type or namespace to be available in QML, using its class or namespace name as the QML element name.</db:para>
<db:para>For example, this makes the C++ class <db:code>Slider</db:code> available as a QML type named <db:code>Slider</db:code>. All its properties, invokable methods and enums are exposed.</db:para>
<db:programlisting language="cpp">class Slider : public QObject
{
    Q_OBJECT
    QML_ELEMENT
    Q_PROPERTY(int value READ value WRITE setValue NOTIFY valueChanged FINAL)
    // ...
public:
    enum Slippiness {
        Dry, Wet, Icy
    };
    Q_ENUM(Slippiness)

    Q_INVOKABLE void slide(Slippiness slippiness);

    // ...
}
</db:programlisting>
<db:para>You can use the build system to register the type in the type namespace <db:emphasis>com.mycompany.qmlcomponents</db:emphasis> with major version <db:code>1</db:code>. For qmake, specify the following in your project file:</db:para>
<db:programlisting language="cpp" role="bad">CONFIG += qmltypes
QML_IMPORT_NAME = com.mycompany.qmlcomponents
QML_IMPORT_MAJOR_VERSION = 1
</db:programlisting>
<db:para>With CMake, you pass the URI and version to qt_add_qml_module</db:para>
<db:programlisting language="cpp" role="bad">qt6_add_qml_module(myapp
  URI com.mycompany.qmlcomponents
  VERSION 1.0
)
</db:programlisting>
<db:para>Once registered, the type can be used in QML by importing the same type namespace and version number:</db:para>
<db:programlisting language="qml">import com.mycompany.qmlcomponents 1.0

Slider {
    value: 12
    Component.onCompleted: slide(Slider.Icy)

    // ...
}
</db:programlisting>
<db:para>You can also make namespaces tagged with <db:link xlink:href="qobject.xml#Q_NAMESPACE">Q_NAMESPACE</db:link> available this way, in order to expose any enums tagged with <db:link xlink:href="qobject.xml#Q_ENUM_NS">Q_ENUM_NS</db:link> they contain:</db:para>
<db:programlisting language="cpp">namespace MyNamespace {
  Q_NAMESPACE
  QML_ELEMENT

  enum MyEnum {
      Key1,
      Key2,
  };
  Q_ENUM_NS(MyEnum)
}
</db:programlisting>
<db:para>In QML, you can then use the enums:</db:para>
<db:programlisting language="qml">Component.onCompleted: console.log(MyNamespace.Key2)
</db:programlisting>
<db:para><db:emphasis role="bold">NOTE:</db:emphasis> When classes have the same name but are located in different namespaces using <db:link xlink:href="">QML_ELEMENT</db:link> on both of them will cause a conflict. Make sure to use <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() for one of them instead.</db:para>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qobject.xml#Q_REVISION">Q_REVISION</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_EXTENDED">
<db:title>QML_EXTENDED(<db:emphasis>EXTENDED_TYPE</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_EXTENDED</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>EXTENDED_TYPE</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_EXTENDED(EXTENDED_TYPE)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares that the enclosing type uses <db:code role="parameter">EXTENDED_TYPE</db:code> as an extension to provide further properties, methods, and enumerations in QML. This takes effect if the type is exposed to QML using a <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() macro.</db:para>
<db:warning>
<db:para>Members of <db:code role="parameter">EXTENDED_TYPE</db:code> are implicitly treated as FINAL.</db:para>
</db:warning>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_EXTENDED_NAMESPACE">QML_EXTENDED_NAMESPACE</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-extension-objects">Registering Extension Objects</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_EXTENDED_NAMESPACE">
<db:title>QML_EXTENDED_NAMESPACE(<db:emphasis>EXTENDED_NAMESPACE</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_EXTENDED_NAMESPACE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>EXTENDED_NAMESPACE</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_EXTENDED_NAMESPACE(EXTENDED_NAMESPACE)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares that the enclosing type uses <db:code role="parameter">EXTENDED_NAMESPACE</db:code> as an extension to provide further enumerations in QML. This takes effect if the type is exposed to QML using a <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() macro. The enumerations need to be exposed to the metaobject system for this to work.</db:para>
<db:para>For example, give the following C++ code</db:para>
<db:programlisting language="cpp">namespace MyNamespace {
    Q_NAMESPACE
    enum MyEnum { MyEnumerator = 10 };
    Q_ENUM_NS(MyEnum)
}

class QmlType : public QObject
{
    Q_OBJECT
    QML_ELEMENT
    QML_EXTENDED_NAMESPACE(MyNamespace)
}
</db:programlisting>
<db:para>we can access the enum in QML:</db:para>
<db:programlisting language="qml">QmlType {
    property int i: QmlType.MyEnumerator // i will be 10
}
</db:programlisting>
<db:note>
<db:para>EXTENDED_NAMESPACE can also be a <db:link xlink:href="qobject.xml">QObject</db:link> or QGadget; in that case - and in contrast to <db:link xlink:href="qqmlengine.xml#QML_EXTENDED">QML_EXTENDED</db:link>, which also exposes methods and properties - only its enumerations are exposed.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">EXTENDED_NAMESPACE</db:code> must have a metaobject; i.e. it must either be a namespace which contains the <db:link xlink:href="qobject.xml#Q_NAMESPACE">Q_NAMESPACE</db:link> macro or a <db:link xlink:href="qobject.xml">QObject</db:link>/QGadget.</db:para>
</db:note>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_EXTENDED">QML_EXTENDED</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-extension-objects">Registering Extension Objects</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml#Q_ENUM">Q_ENUM</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml#Q_ENUM_NS">Q_ENUM_NS</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_EXTRA_VERSION">
<db:title>QML_EXTRA_VERSION(<db:emphasis>MAJOR</db:emphasis>, <db:emphasis>MINOR</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_EXTRA_VERSION</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>MAJOR</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>MINOR</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_EXTRA_VERSION(MAJOR, MINOR)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declare that the type should also be available in version <db:code role="parameter">MAJOR</db:code>.<db:code role="parameter">MINOR</db:code>. This can be helpful if a type should be available in multiple major versions.</db:para>
<db:para>Types are automatically registered for:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The major version they were introduced in, see <db:link xlink:href="qqmlengine.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Any major versions any their members were introduced in.</db:para>
</db:listitem>
<db:listitem>
<db:para>The current major version of their module, unless they were <db:link xlink:href="qqmlengine.xml#QML_REMOVED_IN_VERSION">QML_REMOVED_IN_VERSION</db:link> before that.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Notably, they are not automatically registered in any <db:link xlink:href="qt-add-qml-module.xml#past-major-versions">PAST_MAJOR_VERSIONS</db:link> between the above. You can use QML_EXTRA_VERSION to manually register your types in further major versions.</db:para>
<db:note>
<db:para>Keeping multiple <db:link xlink:href="qt-add-qml-module.xml#past-major-versions">PAST_MAJOR_VERSIONS</db:link> around is computationally expensive.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_FOREIGN">
<db:title>QML_FOREIGN(<db:emphasis>FOREIGN_TYPE</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_FOREIGN</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>FOREIGN_TYPE</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_FOREIGN(FOREIGN_TYPE)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares that any <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link>, <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link>, <db:link xlink:href="qqmlengine.xml#QML_INTERFACE">QML_INTERFACE</db:link>, <db:link xlink:href="qqmlengine.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_SINGLETON">QML_SINGLETON</db:link>, <db:link xlink:href="qqmlengine.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_REMOVED_IN_VERSION">QML_REMOVED_IN_VERSION</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_ADDED_IN_MINOR_VERSION" role="deprecated">QML_ADDED_IN_MINOR_VERSION</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_REMOVED_IN_MINOR_VERSION" role="deprecated">QML_REMOVED_IN_MINOR_VERSION</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_EXTENDED">QML_EXTENDED</db:link>(), or <db:link xlink:href="qqmlengine.xml#QML_EXTENDED_NAMESPACE">QML_EXTENDED_NAMESPACE</db:link>() macros in the enclosing C++ type do not apply to the enclosing type but instead to <db:code role="parameter">FOREIGN_TYPE</db:code>. The enclosing type still needs to be registered with the <db:link xlink:href="metaobjects.xml">meta object system</db:link> using a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link> or <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:para>This is useful for registering types that cannot be amended to add the macros, for example because they belong to 3rdparty libraries. To register a namespace, see <db:link xlink:href="qqmlengine.xml#QML_FOREIGN_NAMESPACE">QML_FOREIGN_NAMESPACE</db:link>().</db:para>
<db:note>
<db:para>You may want to use <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() instead of <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link>. With <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link>, the element is named after the struct it is contained in, not the foreign type. The <db:link xlink:href="qtqml-tutorials-extending-qml-advanced-example.xml#foreign-objects-integration">Foreign objects integration</db:link> chapter in <db:link xlink:href="qtqml-tutorials-extending-qml-advanced-example.xml">Writing advanced QML Extensions with C++</db:link> demonstrates this.</db:para>
</db:note>
<db:note>
<db:para><db:link xlink:href="qqmlengine.xml#QML_ATTACHED">QML_ATTACHED</db:link>() can currently not be redirected like this. It has to be specificed in the same type that implements qmlAttachedProperties().</db:para>
</db:note>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_FOREIGN_NAMESPACE">QML_FOREIGN_NAMESPACE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_FOREIGN_NAMESPACE">
<db:title>QML_FOREIGN_NAMESPACE(<db:emphasis>FOREIGN_NAMESPACE</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_FOREIGN_NAMESPACE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>FOREIGN_NAMESPACE</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_FOREIGN_NAMESPACE(FOREIGN_NAMESPACE)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares that any <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link>, <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link>, <db:link xlink:href="qqmlengine.xml#QML_INTERFACE">QML_INTERFACE</db:link>, <db:link xlink:href="qqmlengine.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_SINGLETON">QML_SINGLETON</db:link>, <db:link xlink:href="qqmlengine.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_REMOVED_IN_VERSION">QML_REMOVED_IN_VERSION</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_ADDED_IN_MINOR_VERSION" role="deprecated">QML_ADDED_IN_MINOR_VERSION</db:link>(), or <db:link xlink:href="qqmlengine.xml#QML_REMOVED_IN_MINOR_VERSION" role="deprecated">QML_REMOVED_IN_MINOR_VERSION</db:link>() macros in the enclosing C++ namespace do not apply to the enclosing type but instead to <db:code role="parameter">FOREIGN_NAMESPACE</db:code>. The enclosing namespace still needs to be registered with the <db:link xlink:href="metaobjects.xml">meta object system</db:link> using a <db:link xlink:href="qobject.xml#Q_NAMESPACE">Q_NAMESPACE</db:link> macro.</db:para>
<db:para>This is useful for registering namespaces that cannot be amended to add the macros, for example because they belong to 3rdparty libraries.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_FOREIGN">QML_FOREIGN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_IMPLEMENTS_INTERFACES">
<db:title>QML_IMPLEMENTS_INTERFACES(<db:emphasis>interfaces</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_IMPLEMENTS_INTERFACES</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>interfaces</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_IMPLEMENTS_INTERFACES(interfaces)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro tells Qt which QML <db:code role="parameter">interfaces</db:code> the class implements. This macro should only be used for interfacing with classes using <db:link xlink:href="qqmlengine.xml#QML_INTERFACE">QML_INTERFACE</db:link>, use <db:link xlink:href="qobject.xml#Q_INTERFACES">Q_INTERFACES</db:link> otherwise. It's required in order for declarative registration via <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link> to function properly.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_INTERFACE">QML_INTERFACE</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml#Q_INTERFACES">Q_INTERFACES</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_INTERFACE">
<db:title>QML_INTERFACE</db:title>
<db:methodsynopsis>
<db:methodname>QML_INTERFACE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_INTERFACE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro registers the enclosing C++ type in the QML system as an interface.</db:para>
<db:para>Types registered as an interface in QML should also declare themselves as an interface with the <db:link xlink:href="metaobjects.xml">meta object system</db:link>. For example:</db:para>
<db:programlisting language="cpp">struct FooInterface
{
    QML_INTERFACE
public:
    virtual ~FooInterface();
    virtual void doSomething() = 0;
};

Q_DECLARE_INTERFACE(FooInterface, &quot;org.foo.FooInterface&quot;)
</db:programlisting>
<db:para>When registered with QML in this way, they can be used as property types:</db:para>
<db:para><db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>(FooInterface *foo READ foo WRITE setFoo)</db:para>
<db:para>When you assign a <db:link xlink:href="qobject.xml">QObject</db:link> sub-class to this property, the QML engine does the interface cast to <db:code>FooInterface*</db:code> automatically.</db:para>
<db:para>Interface types are implicitly anonymous and uncreatable in QML.</db:para>
<db:para><db:emphasis role="bold">NOTE:</db:emphasis> When inheriting from types using QML_INTERFACE, use <db:link xlink:href="qqmlengine.xml#QML_IMPLEMENTS_INTERFACES">QML_IMPLEMENTS_INTERFACES</db:link> instead of <db:link xlink:href="qobject.xml#Q_INTERFACES">Q_INTERFACES</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_IMPLEMENTS_INTERFACES">QML_IMPLEMENTS_INTERFACES</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_NAMED_ELEMENT">
<db:title>QML_NAMED_ELEMENT(<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_NAMED_ELEMENT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_NAMED_ELEMENT(name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares the enclosing type or namespace to be available in QML, using <db:code role="parameter">name</db:code> as the element name. Otherwise behaves the same as <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link>.</db:para>
<db:programlisting language="cpp">class SqlEventDatabase : public QObject
{
    Q_OBJECT
    QML_NAMED_ELEMENT(EventDatabase)

    // ...
};
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_REMOVED_IN_VERSION">
<db:title>QML_REMOVED_IN_VERSION(<db:emphasis>MAJOR</db:emphasis>, <db:emphasis>MINOR</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_REMOVED_IN_VERSION</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>MAJOR</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>MINOR</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_REMOVED_IN_VERSION(MAJOR, MINOR)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares that the enclosing type or namespace was removed in the specified <db:code role="parameter">MAJOR</db:code>.<db:code role="parameter">MINOR</db:code> version. This is primarily useful when replacing the implementation of a QML type. If a corresponding <db:link xlink:href="qqmlengine.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link>() is present on a different type or namespace of the same QML name, then the removed type is used when importing versions of the module lower than <db:code role="parameter">MAJOR</db:code>.<db:code role="parameter">MINOR</db:code>, and the added type is used when importing versions of the module greater or equal <db:code role="parameter">MAJOR</db:code>.<db:code role="parameter">MINOR</db:code>.</db:para>
<db:para><db:link xlink:href="">QML_REMOVED_IN_VERSION</db:link>() only takes effect if type or namespace is available in QML, by having a <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link>, <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link>, or <db:link xlink:href="qqmlengine.xml#QML_INTERFACE">QML_INTERFACE</db:link> macro.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_SEQUENTIAL_CONTAINER">
<db:title>QML_SEQUENTIAL_CONTAINER(<db:emphasis>VALUE_TYPE</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_SEQUENTIAL_CONTAINER</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>VALUE_TYPE</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_SEQUENTIAL_CONTAINER(VALUE_TYPE)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro declares the enclosing or referenced type as a sequential container managing a sequence of <db:code role="parameter">VALUE_TYPE</db:code> elements. <db:code role="parameter">VALUE_TYPE</db:code> can be an actual <db:link xlink:href="qtqml-typesystem-valuetypes.xml">value type</db:link> or a pointer to an <db:link xlink:href="qtqml-typesystem-objecttypes.xml">object type</db:link>. You will rarely be able to add this macro to the actual container declaration since containers are usually templates. You should use <db:link xlink:href="qqmlengine.xml#QML_FOREIGN">QML_FOREIGN</db:link> to attach the type registration to a template instantiation. Using this technique you can, for example, declare sequential containers like this:</db:para>
<db:programlisting language="cpp">class IntDequeRegistration
{
  Q_GADGET
  QML_FOREIGN(std::deque&amp;lt;int&amp;gt;)
  QML_ANONYMOUS
  QML_SEQUENTIAL_CONTAINER(int)
};
</db:programlisting>
<db:para>After this, you can use the container like a JavaScript array in QML.</db:para>
<db:programlisting language="cpp">class Maze
{
  Q_OBJECT
  Q_ELEMENT
  // 0: North, 1: East, 2: South, 3: West
  Q_PROPERTY(std::deque&amp;lt;int&amp;gt; solution READ solution CONSTANT FINAL)
  [...]
}
</db:programlisting>
<db:programlisting language="cpp">Item {
  Maze {
    id: maze
  }

  function showSolution() {
      maze.solution.forEach([...])
  }
}
</db:programlisting>
<db:note>
<db:para>For <db:link xlink:href="qtqml-typesystem-valuetypes.xml">QML Value Types</db:link> <db:link xlink:href="qlist.xml">QList</db:link> is automatically registered as sequential container. For <db:link xlink:href="qtqml-typesystem-objecttypes.xml">QML Object Types</db:link> <db:link xlink:href="qqmllistproperty.xml">QQmlListProperty</db:link> is. You don't have to add these registrations.</db:para>
</db:note>
<db:note>
<db:para>You cannot currently give the container a custom name. Any argument passed to <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link> is ignored. The automatically registered sequential containers are available under the familiar <db:emphasis>list&lt;...&gt;</db:emphasis> names, for example <db:emphasis>list&lt;<db:link xlink:href="qml-qtqml-qtobject.xml">QtObject</db:link>&gt;</db:emphasis> or <db:emphasis>list&lt;font&gt;</db:emphasis>.</db:para>
</db:note>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_FOREIGN">QML_FOREIGN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_SINGLETON">
<db:title>QML_SINGLETON</db:title>
<db:methodsynopsis>
<db:methodname>QML_SINGLETON</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_SINGLETON</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares the enclosing type to be a singleton in QML. This only takes effect if the type is a <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> and is available in QML (by having a <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() macro). By default, each <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> will try to create a singleton instance using either the type's default constructor or a static factory function of the signature <db:code>T *create(QQmlEngine *, QJSEngine *)</db:code> when the type is first accessed. If both do exist and are accessible, the default constructor is preferred. If there is no default constructor and no factory function the singleton is inaccessible. The QML engine generally assumes ownership of the singleton and will delete it when the engine itself is destroyed. You can prevent this by calling <db:link xlink:href="qjsengine.xml#setObjectOwnership">QJSEngine::setObjectOwnership</db:link>() on the singleton.</db:para>
<db:para>In order to declare a default-constructible class as singleton, all you have to do is add <db:link xlink:href="">QML_SINGLETON</db:link>:</db:para>
<db:programlisting language="cpp">class MySingleton : public QObject
{
    Q_OBJECT
    QML_ELEMENT
    QML_SINGLETON
    // Q_PROPERTY( ... )
public:
    // members, Q_INVOKABLE functions, etc.
};
</db:programlisting>
<db:para>If the singleton class is not default-constructible, but you can modify it, you can add a factory function to it, in order to make it accessible:</db:para>
<db:programlisting language="cpp">class MySingleton : public QObject
{
    Q_OBJECT
    QML_ELEMENT
    QML_SINGLETON
    // Q_PROPERTY( ... )

public:
    static MySingleton *create(QQmlEngine *qmlEngine, QJSEngine *jsEngine)
    {
        MySingleton *result = nullptr;
        // Create the object using some custom constructor or factory.
        // The QML engine will assume ownership and delete it, eventually.
        return result;
    }

    // members, Q_INVOKABLE functions, etc
};
</db:programlisting>
<db:para>If you cannot modify the class and it does not have a default constructor or a suitable factory function, you can provide a <db:link xlink:href="qqmlengine.xml#QML_FOREIGN">QML_FOREIGN</db:link> wrapper to define the factory function:</db:para>
<db:programlisting language="cpp">struct SingletonForeign
{
    Q_GADGET
    QML_FOREIGN(MySingleton)
    QML_SINGLETON
    QML_NAMED_ELEMENT(MySingleton)
public:

    static MySingleton *create(QQmlEngine *, QJSEngine *engine)
    {
        MySingleton *result = nullptr;
        // Create the instance using some custom constructor or factory.
        // The QML engine will assume ownership and delete it, eventually.
        return result;
    }
};
</db:programlisting>
<db:para>Finally, if you want to provide one specific singleton object, the creation of which you cannot control, you can return that from a factory function. This is a replacement for the <db:link xlink:href="qqmlengine.xml#qmlRegisterSingletonInstance">qmlRegisterSingletonInstance</db:link> function. If you were calling</db:para>
<db:programlisting language="cpp">qmlRegisterSingletonInstance(&quot;MyModule&quot;, 1, 0, &quot;MySingleton&quot;, myObject);
</db:programlisting>
<db:para>with myObject being of type <db:code>MySingleton *</db:code>, you can do the following instead:</db:para>
<db:programlisting language="cpp">struct SingletonForeign
{
    Q_GADGET
    QML_FOREIGN(MySingleton)
    QML_SINGLETON
    QML_NAMED_ELEMENT(MySingleton)
public:

    // Initialize this using myObject where you would previously
    // call qmlRegisterSingletonInstance().
    inline static MySingleton *s_singletonInstance = nullptr;

    static MySingleton *create(QQmlEngine *, QJSEngine *engine)
    {
        // The instance has to exist before it is used. We cannot replace it.
        Q_ASSERT(s_singletonInstance);

        // The engine has to have the same thread affinity as the singleton.
        Q_ASSERT(engine-&amp;gt;thread() == s_singletonInstance-&amp;gt;thread());

        // There can only be one engine accessing the singleton.
        if (s_engine)
            Q_ASSERT(engine == s_engine);
        else
            s_engine = engine;

        // Explicitly specify C++ ownership so that the engine doesn't delete
        // the instance.
        QJSEngine::setObjectOwnership(s_singletonInstance,
                                      QJSEngine::CppOwnership);
        return s_singletonInstance;
    }

private:
    inline static QJSEngine *s_engine = nullptr;
};
</db:programlisting>
<db:para>This way, the pre-existing class <db:code>MySingleton</db:code> is declared to be a QML singleton, called <db:code>MySingleton</db:code>. You can specify an instance for it any time before it is used by setting the <db:code>s_singletonInstance</db:code> member. None of this requires modification of <db:code>MySingleton</db:code> itself.</db:para>
<db:note>
<db:para>This pattern doesn't work if either the singleton is accessed by multiple QML engines, or if the QML engine accessing it has a different thread affinity than the singleton object itself. As shown above, you can check the parameters to the <db:code>create()</db:code> method for identity and thread affinity of the engine in order to assert on that.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlRegisterSingletonInstance">qmlRegisterSingletonInstance</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#singletonInstance">QQmlEngine::singletonInstance</db:link>()</db:member>
<db:member><db:link xlink:href="qml-singleton.xml">Singletons in QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_STRUCTURED_VALUE">
<db:title>[since 6.5] QML_STRUCTURED_VALUE</db:title>
<db:methodsynopsis>
<db:methodname>QML_STRUCTURED_VALUE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_STRUCTURED_VALUE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Marks the surrounding value type as structured. Structured value types can and will preferably be constructed property-by-property from a JavaScript object. A structured value type, however is always <db:link xlink:href="qqmlengine.xml#QML_CONSTRUCTIBLE_VALUE">QML_CONSTRUCTIBLE_VALUE</db:link>, too. This means, you can still provide <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> constructors in order to handle construction from primitive types.</db:para>
<db:para>You can declare a structured value type as follows:</db:para>
<db:programlisting language="cpp">class MyValueType
{
    Q_GADGET
    QML_VALUE_TYPE(myValueType)
    QML_STRUCTURED_VALUE
    Q_PROPERTY(double d READ d WRITE setD)
    Q_PROPERTY(string e READ e WRITE setE)

    // ...
};
</db:programlisting>
<db:para>Then you can populate a property of this type as follows:</db:para>
<db:programlisting language="qml">QtObject {
    property myValueType v: ({d: 4.4, e: &quot;a string&quot;})
}
</db:programlisting>
<db:para>The extra parentheses are necessary to disambiguate the JavaScript object from what might be interpreted as a JavaScript code block.</db:para>
<db:para>You can also construct lists of values this way:</db:para>
<db:programlisting language="qml">QtObject {
    property list&amp;lt;myValueType&amp;gt; v: [
        {d: 4.4, e: &quot;a string&quot;},
        {d: 7.1, e: &quot;another string&quot;}
    ]
}
</db:programlisting>
<db:para>If you make value types <db:link xlink:href="qtqml-documents-structure.xml#valuetypebehavior">addressable</db:link>, you can use such a type in a <db:link xlink:href="qtqml-javascript-hostenvironment.xml#type-annotations-and-assertions">type assertion</db:link> to explicitly construct it:</db:para>
<db:programlisting language="qml">pragma ValueTypeBehavior: Addressable

QtObject {
    function process(d: real) {
        let v = {d: d, e: objectName} as myValueType;
        // v is a myValueType now
    }
}
</db:programlisting>
<db:para>This macro was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_VALUE_TYPE">QML_VALUE_TYPE</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_CONSTRUCTIBLE_VALUE">QML_CONSTRUCTIBLE_VALUE</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_UNAVAILABLE">
<db:title>QML_UNAVAILABLE</db:title>
<db:methodsynopsis>
<db:methodname>QML_UNAVAILABLE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_UNAVAILABLE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro declares the enclosing type to be unavailable in QML. It registers an internal dummy type called <db:code>QQmlTypeNotAvailable</db:code> as <db:link xlink:href="qqmlengine.xml#QML_FOREIGN">QML_FOREIGN</db:link>() type, using any further QML macros you specify.</db:para>
<db:para>Normally, the types exported by a module should be fixed. However, if a C++ type is not available, you should at least &quot;reserve&quot; the QML type name, and give the user of the unavailable type a meaningful error message.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">#ifdef NO_GAMES_ALLOWED
struct MinehuntGame
{
    Q_GADGET
    QML_NAMED_ELEMENT(Game)
    QML_UNAVAILABLE
    QML_UNCREATABLE(&quot;Get back to work, slacker!&quot;);
};
#else
class MinehuntGame : public QObject
{
    Q_OBJECT
    QML_NAMED_ELEMENT(Game)
    // ...
};
#endif
</db:programlisting>
<db:para>This will cause any QML which attempts to use the &quot;Game&quot; type to produce an error message:</db:para>
<db:programlisting language="cpp" role="bad">fun.qml: Get back to work, slacker!
   Game {
   ^
</db:programlisting>
<db:para>Using this technique, you only need a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link> struct to customize the error message, not a full-blown <db:link xlink:href="qobject.xml">QObject</db:link>. Without <db:link xlink:href="qqmlengine.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>(), <db:link xlink:href="">QML_UNAVAILABLE</db:link> still results in a more specific error message than the usual &quot;is not a type&quot; for completely unknown types.</db:para>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_FOREIGN">QML_FOREIGN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_UNCREATABLE">
<db:title>QML_UNCREATABLE(<db:emphasis>reason</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_UNCREATABLE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>reason</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_UNCREATABLE(reason)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares that the enclosing type shall not be creatable from QML. This takes effect if the type is available in QML, by having a <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() macro. The <db:code role="parameter">reason</db:code> will be emitted as error message if an attempt to create the type from QML is detected.</db:para>
<db:para>Some QML types are implicitly uncreatable, in particular types exposed with <db:link xlink:href="qqmlengine.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link> or namespaces exposed with <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>().</db:para>
<db:para>Since Qt 6.0 you can use &quot;&quot; instead of a reason to use a standard message instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_VALUE_TYPE">
<db:title>QML_VALUE_TYPE(<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_VALUE_TYPE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_VALUE_TYPE(name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Declares the enclosing type or namespace to be available in QML, using <db:code role="parameter">name</db:code> as the name. The type has to be a value type and the name has to be lower case.</db:para>
<db:programlisting language="cpp">class MyValueType
{
    Q_GADGET
    QML_VALUE_TYPE(myValueType)

    // ...
};
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QQmlEngine</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="importPlugin">
<db:title>bool QQmlEngine::importPlugin(const QString &amp;<db:emphasis>filePath</db:emphasis>, const QString &amp;<db:emphasis>uri</db:emphasis>, QList&lt;QQmlError&gt; *<db:emphasis>errors</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>importPlugin</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>filePath</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>uri</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QList&lt;QQmlError&gt; *</db:type>
<db:parameter>errors</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool importPlugin(const QString &amp;filePath, const QString &amp;uri, QList&lt;QQmlError&gt; *errors)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.4. We strongly advise against using it in new code.</db:para>
<db:para>Import the module from QML with an &quot;import&quot; statement instead.</db:para>
<db:para>Imports the plugin named <db:code role="parameter">filePath</db:code> with the <db:code role="parameter">uri</db:code> provided. Returns true if the plugin was successfully imported; otherwise returns false.</db:para>
<db:para>On failure and if non-null, the <db:code role="parameter">errors</db:code> list will have any errors which occurred prepended to it.</db:para>
<db:para>The plugin has to be a Qt plugin which implements the <db:link xlink:href="qqmlengineextensionplugin.xml">QQmlEngineExtensionPlugin</db:link> interface.</db:para>
<db:note>
<db:para>Directly loading plugins like this can confuse the module import logic. In order to make the import logic load plugins from a specific place, you can use <db:link xlink:href="qqmlengine.xml#addPluginPath">addPluginPath</db:link>(). Each plugin should be part of a QML module that you can import using the &quot;import&quot; statement.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="obsolete-macro-documentation">
<db:title>Obsolete Macro Documentation</db:title>
<db:section xml:id="QML_ADDED_IN_MINOR_VERSION">
<db:title>QML_ADDED_IN_MINOR_VERSION(<db:emphasis>VERSION</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_ADDED_IN_MINOR_VERSION</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>VERSION</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_ADDED_IN_MINOR_VERSION(VERSION)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is deprecated since 6.7. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qqmlengine.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link> and specify the full version</db:para>
<db:para>Declares that the enclosing type or namespace was added in the specified minor <db:code role="parameter">VERSION</db:code>, relative to the module major version. The minor version is assumed to be in line with any revisions given by <db:link xlink:href="qobject.xml#Q_REVISION">Q_REVISION</db:link>() macros on methods, slots, or signals, and any REVISION() attributes on properties declared with <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>().</db:para>
<db:para><db:link xlink:href="">QML_ADDED_IN_MINOR_VERSION</db:link>() only takes effect if the type or namespace is available in QML, by having a <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link>, <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link>, or <db:link xlink:href="qqmlengine.xml#QML_INTERFACE">QML_INTERFACE</db:link> macro.</db:para>
<db:para>If the QML module the type belongs to is imported with a lower version than the one determined this way, the QML type is invisible.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_REMOVED_IN_MINOR_VERSION">
<db:title>QML_REMOVED_IN_MINOR_VERSION(<db:emphasis>VERSION</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QML_REMOVED_IN_MINOR_VERSION</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>VERSION</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QML_REMOVED_IN_MINOR_VERSION(VERSION)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is deprecated since 6.7. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qqmlengine.xml#QML_REMOVED_IN_VERSION">QML_REMOVED_IN_VERSION</db:link> and specify the full version</db:para>
<db:para>Declares that the enclosing type or namespace was removed in the specified minor <db:code role="parameter">VERSION</db:code>, relative to the module major version. This is primarily useful when replacing the implementation of a QML type. If a corresponding <db:link xlink:href="qqmlengine.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link>() is present on a different type or namespace of the same QML name, then the removed type is used when importing versions of the module lower than <db:code role="parameter">VERSION</db:code>, and the added type is used when importing versions of the module greater or equal <db:code role="parameter">VERSION</db:code>.</db:para>
<db:para><db:link xlink:href="">QML_REMOVED_IN_MINOR_VERSION</db:link>() only takes effect if type or namespace is available in QML, by having a <db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link>, <db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>(), <db:link xlink:href="qqmlengine.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link>, or <db:link xlink:href="qqmlengine.xml#QML_INTERFACE">QML_INTERFACE</db:link> macro.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_REMOVED_IN_VERSION">QML_REMOVED_IN_VERSION</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
