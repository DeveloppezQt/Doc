<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QQmlEngine Class</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Qml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> class provides an environment for instantiating QML components.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QQmlEngine</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Qml)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Qml)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += qml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qjsengine.xml" xlink:role="class">QJSEngine</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qqmlapplicationengine.xml" xlink:role="class">QQmlApplicationEngine</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> is used to manage <db:link xlink:href="qqmlcomponent.xml">components</db:link> and objects created from them and execute their bindings and functions. <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> also inherits from <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> which allows seamless integration between your QML components and JavaScript code.</db:para>
<db:para>Each QML component is instantiated in a <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link>. In QML, contexts are arranged hierarchically and this hierarchy is managed by the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>. By default, components are instantiated in the <db:link xlink:href="qqmlengine.xml#rootContext">root context</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlcomponent.xml">QQmlComponent</db:link></db:member>
<db:member><db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link></db:member>
<db:member><db:link xlink:href="qtqml-javascript-qmlglobalobject.xml">QML Global Object</db:link></db:member>
<db:member><db:link xlink:href="qqmlapplicationengine.xml">QQmlApplicationEngine</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="offlineStoragePath-prop">
<db:title>offlineStoragePath : QString</db:title>
<db:para>This property holds the directory for storing offline user data</db:para>
<db:para>Returns the directory where SQL and other offline storage is placed.</db:para>
<db:para>The SQL databases created with <db:code>openDatabaseSync()</db:code> are stored here.</db:para>
<db:para>The default is QML/OfflineStorage in the platform-standard user application data directory.</db:para>
<db:para>Note that the path may not currently exist on the filesystem, so callers wanting to <db:emphasis>create</db:emphasis> new files at this location should create it first - see <db:link xlink:href="qdir.xml#mkpath">QDir::mkpath</db:link>().</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">offlineStoragePath</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setOfflineStoragePath</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>dir</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qqmlengine.xml#offlineStoragePathChanged">offlineStoragePathChanged</db:link></db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">Qt Quick Local Storage QML Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QQmlEngine">
<db:title>[explicit] QQmlEngine::QQmlEngine(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:para>Create a new <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> with the given <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QQmlEngine">
<db:title>[override virtual noexcept] QQmlEngine::~QQmlEngine()</db:title>
<db:para>Destroys the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>.</db:para>
<db:para>Any <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link>'s created on this engine will be invalidated, but not destroyed (unless they are parented to the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> object).</db:para>
<db:para>See ~<db:link xlink:href="qjsengine.xml#QJSEngine">QJSEngine</db:link>() for details on cleaning up the JS engine.</db:para>
</db:section>
<db:section xml:id="addImageProvider">
<db:title>void QQmlEngine::addImageProvider(const QString &amp;<db:emphasis>providerId</db:emphasis>, QQmlImageProviderBase *<db:emphasis>provider</db:emphasis>)</db:title>
<db:para>Sets the <db:code role="parameter">provider</db:code> to use for images requested via the <db:emphasis>image</db:emphasis>: url scheme, with host <db:code role="parameter">providerId</db:code>. The <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> takes ownership of <db:code role="parameter">provider</db:code>.</db:para>
<db:para>Image providers enable support for pixmap and threaded image requests. See the QQuickImageProvider documentation for details on implementing and using image providers.</db:para>
<db:para>All required image providers should be added to the engine before any QML sources files are loaded.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#removeImageProvider">removeImageProvider</db:link>()</db:member>
<db:member>QQuickImageProvider</db:member>
<db:member><db:link xlink:href="qqmlimageproviderbase.xml">QQmlImageProviderBase</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addImportPath">
<db:title>void QQmlEngine::addImportPath(const QString &amp;<db:emphasis>path</db:emphasis>)</db:title>
<db:para>Adds <db:code role="parameter">path</db:code> as a directory where the engine searches for installed modules in a URL-based directory structure.</db:para>
<db:para>The <db:code role="parameter">path</db:code> may be a local filesystem directory, a <db:link xlink:href="resources.xml">Qt Resource</db:link> path (<db:code>:/imports</db:code>), a <db:link xlink:href="resources.xml">Qt Resource</db:link> url (<db:code>qrc:/imports</db:code>) or a URL.</db:para>
<db:para>The <db:code role="parameter">path</db:code> will be converted into canonical form before it is added to the import path list.</db:para>
<db:para>The newly added <db:code role="parameter">path</db:code> will be first in the <db:link xlink:href="qqmlengine.xml#importPathList">importPathList</db:link>().</db:para>
<db:para><db:emphasis role="bold">See also</db:emphasis> <db:link xlink:href="qqmlengine.xml#setImportPathList">setImportPathList</db:link>(), <db:link xlink:href="qtqml-modules-topic.xml">QML Modules</db:link>, and <db:link xlink:href="qtqml-syntax-imports.xml#qml-import-path">QML Import Path</db:link></db:para>
</db:section>
<db:section xml:id="addPluginPath">
<db:title>void QQmlEngine::addPluginPath(const QString &amp;<db:emphasis>path</db:emphasis>)</db:title>
<db:para>Adds <db:code role="parameter">path</db:code> as a directory where the engine searches for native plugins for imported modules (referenced in the <db:code>qmldir</db:code> file).</db:para>
<db:para>By default, the list contains only <db:code>.</db:code>, i.e. the engine searches in the directory of the <db:code>qmldir</db:code> file itself.</db:para>
<db:para>The newly added <db:code role="parameter">path</db:code> will be first in the <db:link xlink:href="qqmlengine.xml#pluginPathList">pluginPathList</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setPluginPathList">setPluginPathList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addUrlInterceptor">
<db:title>void QQmlEngine::addUrlInterceptor(QQmlAbstractUrlInterceptor *<db:emphasis>urlInterceptor</db:emphasis>)</db:title>
<db:para>Adds a <db:code role="parameter">urlInterceptor</db:code> to be used when resolving URLs in QML. This also applies to URLs used for loading script files and QML types. The URL interceptors should not be modifed while the engine is loading files, or URL selection may be inconsistent. Multiple URL interceptors, when given, will be called in the order they were added for each URL.</db:para>
<db:para><db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> does not take ownership of the interceptor and won't delete it.</db:para>
</db:section>
<db:section xml:id="baseUrl">
<db:title>QUrl QQmlEngine::baseUrl() const</db:title>
<db:para>Return the base URL for this engine. The base URL is only used to resolve components when a relative URL is passed to the <db:link xlink:href="qqmlcomponent.xml">QQmlComponent</db:link> constructor.</db:para>
<db:para>If a base URL has not been explicitly set, this method returns the application's current working directory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setBaseUrl">setBaseUrl</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clearComponentCache">
<db:title>void QQmlEngine::clearComponentCache()</db:title>
<db:para>Clears the engine's internal component cache.</db:para>
<db:para>This function causes the property metadata of most components previously loaded by the engine to be destroyed. It does so by dropping unreferenced components from the engine's component cache. It does not drop components that are still referenced since that would almost certainly lead to crashes further down the line.</db:para>
<db:para>If no components are referenced, this function returns the engine to a state where it does not contain any loaded component data. This may be useful in order to reload a smaller subset of the previous component set, or to load a new version of a previously loaded component.</db:para>
<db:para>Once the component cache has been cleared, components must be loaded before any new objects can be created.</db:para>
<db:note>
<db:para>Any existing objects created from QML components retain their types, even if you clear the component cache. This includes singleton objects. If you create more objects from the same QML code after clearing the cache, the new objects will be of different types than the old ones. Assigning such a new object to a property of its declared type belonging to an object created before clearing the cache won't work.</db:para>
</db:note>
<db:para>As a general rule of thumb, make sure that no objects created from QML components are alive when you clear the component cache.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#trimComponentCache">trimComponentCache</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#clearSingletons">clearSingletons</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clearSingletons">
<db:title>void QQmlEngine::clearSingletons()</db:title>
<db:para>Clears all singletons the engine owns.</db:para>
<db:para>This function drops all singleton instances, deleting any QObjects owned by the engine among them. This is useful to make sure that no QML-created objects are left before calling <db:link xlink:href="qqmlengine.xml#clearComponentCache">clearComponentCache</db:link>().</db:para>
<db:para>QML properties holding <db:link xlink:href="qobject.xml">QObject</db:link>-based singleton instances become null if the engine owns the singleton or retain their value if the engine doesn't own it. The singletons are not automatically re-created by accessing existing QML-created objects. Only when new components are instantiated, the singletons are re-created.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#clearComponentCache">clearComponentCache</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contextForObject">
<db:title>[static] QQmlContext *QQmlEngine::contextForObject(const QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:para>Returns the <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link> for the <db:code role="parameter">object</db:code>, or nullptr if no context has been set.</db:para>
<db:para>When the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> instantiates a <db:link xlink:href="qobject.xml">QObject</db:link>, an internal context is assigned to it automatically. Such internal contexts are read-only. You cannot set context properties on them.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setContextForObject">setContextForObject</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlContext">qmlContext</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlEngine">qmlEngine</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlcontext.xml#setContextProperty">QQmlContext::setContextProperty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="event">
<db:title>[override virtual protected] bool QQmlEngine::event(QEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qobject.xml#event" role="function">QObject::event(QEvent *e)</db:link>.</db:para>
</db:section>
<db:section xml:id="exit">
<db:title>void QQmlEngine::exit(int <db:emphasis>retCode</db:emphasis>)</db:title>
<db:para>This signal is emitted when the QML loaded by the engine would like to exit from the event loop with the specified return code <db:code role="parameter">retCode</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#quit">quit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="imageProvider">
<db:title>QQmlImageProviderBase *QQmlEngine::imageProvider(const QString &amp;<db:emphasis>providerId</db:emphasis>) const</db:title>
<db:para>Returns the image provider set for <db:code role="parameter">providerId</db:code> if found; otherwise returns <db:code>nullptr</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>QQuickImageProvider</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="importPathList">
<db:title>QStringList QQmlEngine::importPathList() const</db:title>
<db:para>Returns the list of directories where the engine searches for installed modules in a URL-based directory structure.</db:para>
<db:para>For example, if <db:code>/opt/MyApp/lib/imports</db:code> is in the path, then QML that imports <db:code>com.mycompany.Feature</db:code> will cause the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> to look in <db:code>/opt/MyApp/lib/imports/com/mycompany/Feature/</db:code> for the components provided by that module. A <db:code>qmldir</db:code> file is required for defining the type version mapping and possibly QML extensions plugins.</db:para>
<db:para>By default, this list contains the paths mentioned in <db:link xlink:href="qtqml-syntax-imports.xml#qml-import-path">QML Import Path</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#addImportPath">addImportPath</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#setImportPathList">setImportPathList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="incubationController">
<db:title>QQmlIncubationController *QQmlEngine::incubationController() const</db:title>
<db:para>Returns the currently set incubation controller, or 0 if no controller has been set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setIncubationController">setIncubationController</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="interceptUrl">
<db:title>QUrl QQmlEngine::interceptUrl(const QUrl &amp;<db:emphasis>url</db:emphasis>, QQmlAbstractUrlInterceptor::DataType <db:emphasis>type</db:emphasis>) const</db:title>
<db:para>Run the current URL interceptors on the given <db:code role="parameter">url</db:code> of the given <db:code role="parameter">type</db:code> and return the result.</db:para>
</db:section>
<db:section xml:id="markCurrentFunctionAsTranslationBinding">
<db:title>[since 6.6] void QQmlEngine::markCurrentFunctionAsTranslationBinding()</db:title>
<db:para>If this method is called inside of a function that is part of a binding in QML, the binding will be treated as a translation binding.</db:para>
<db:programlisting language="cpp">class I18nAwareClass : public QObject {

  //...

   QString text() const
   {
        if (auto engine = qmlEngine(this))
            engine-&gt;markCurrentFunctionAsTranslationBinding();
        return tr(&quot;Hello, world!&quot;);
   }
};
</db:programlisting>
<db:note>
<db:para>This function is mostly useful if you wish to provide your own alternative to the qsTr function. To ensure that properties exposed from C++ classes are updated on language changes, it is instead recommended to react to <db:code>LanguageChange</db:code> events. That is a more general mechanism which also works when the class is used in a non-QML context, and has slightly less overhead. However, using <db:code>markCurrentFunctionAsTranslationBinding</db:code> can be acceptable when the class is already closely tied to the QML engine. For more details, see <db:link xlink:href="">Prepare for Dynamic Language Changes</db:link></db:para>
</db:note>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#retranslate">QQmlEngine::retranslate</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="networkAccessManager">
<db:title>QNetworkAccessManager *QQmlEngine::networkAccessManager() const</db:title>
<db:para>Returns a common <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> which can be used by any QML type instantiated by this engine.</db:para>
<db:para>If a <db:link xlink:href="qqmlnetworkaccessmanagerfactory.xml">QQmlNetworkAccessManagerFactory</db:link> has been set and a <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> has not yet been created, the <db:link xlink:href="qqmlnetworkaccessmanagerfactory.xml">QQmlNetworkAccessManagerFactory</db:link> will be used to create the <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>; otherwise the returned <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> will have no proxy or cache set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setNetworkAccessManagerFactory">setNetworkAccessManagerFactory</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="networkAccessManagerFactory">
<db:title>QQmlNetworkAccessManagerFactory *QQmlEngine::networkAccessManagerFactory() const</db:title>
<db:para>Returns the current <db:link xlink:href="qqmlnetworkaccessmanagerfactory.xml">QQmlNetworkAccessManagerFactory</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setNetworkAccessManagerFactory">setNetworkAccessManagerFactory</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="offlineStorageDatabaseFilePath">
<db:title>QString QQmlEngine::offlineStorageDatabaseFilePath(const QString &amp;<db:emphasis>databaseName</db:emphasis>) const</db:title>
<db:para>Returns the file path where a <db:link xlink:href="">Local Storage</db:link> database with the identifier <db:code role="parameter">databaseName</db:code> is (or would be) located.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">LocalStorage.openDatabaseSync()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="offlineStoragePathChanged">
<db:title>[since 6.5] void QQmlEngine::offlineStoragePathChanged()</db:title>
<db:para>This signal is emitted when <db:link xlink:href="qqmlengine.xml#offlineStoragePath-prop">offlineStoragePath</db:link> changes.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qqmlengine.xml#offlineStoragePath-prop">offlineStoragePath</db:link>. </db:para>
</db:note>
<db:para>This function was introduced in Qt 6.5.</db:para>
</db:section>
<db:section xml:id="outputWarningsToStandardError">
<db:title>bool QQmlEngine::outputWarningsToStandardError() const</db:title>
<db:para>Returns true if warning messages will be output to stderr in addition to being emitted by the <db:link xlink:href="qqmlengine.xml#warnings">warnings</db:link>() signal, otherwise false.</db:para>
<db:para>The default value is true.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setOutputWarningsToStandardError">setOutputWarningsToStandardError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pluginPathList">
<db:title>QStringList QQmlEngine::pluginPathList() const</db:title>
<db:para>Returns the list of directories where the engine searches for native plugins for imported modules (referenced in the <db:code>qmldir</db:code> file).</db:para>
<db:para>By default, the list contains only <db:code>.</db:code>, i.e. the engine searches in the directory of the <db:code>qmldir</db:code> file itself.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#addPluginPath">addPluginPath</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#setPluginPathList">setPluginPathList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quit">
<db:title>void QQmlEngine::quit()</db:title>
<db:para>This signal is emitted when the QML loaded by the engine would like to quit.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#exit">exit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeImageProvider">
<db:title>void QQmlEngine::removeImageProvider(const QString &amp;<db:emphasis>providerId</db:emphasis>)</db:title>
<db:para>Removes the image provider for <db:code role="parameter">providerId</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#addImageProvider">addImageProvider</db:link>()</db:member>
<db:member>QQuickImageProvider</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeUrlInterceptor">
<db:title>void QQmlEngine::removeUrlInterceptor(QQmlAbstractUrlInterceptor *<db:emphasis>urlInterceptor</db:emphasis>)</db:title>
<db:para>Remove a <db:code role="parameter">urlInterceptor</db:code> that was previously added using <db:link xlink:href="qqmlengine.xml#addUrlInterceptor">addUrlInterceptor</db:link>. The URL interceptors should not be modifed while the engine is loading files, or URL selection may be inconsistent.</db:para>
<db:para>This does not delete the interceptor, but merely removes it from the engine. You can re-use it on the same or a different engine afterwards.</db:para>
</db:section>
<db:section xml:id="retranslate">
<db:title>void QQmlEngine::retranslate()</db:title>
<db:para>Refreshes all binding expressions that use strings marked for translation.</db:para>
<db:para>Call this function after you have installed a new translator with <db:link xlink:href="qcoreapplication.xml#installTranslator">QCoreApplication::installTranslator</db:link>, to ensure that your user-interface shows up-to-date translations.</db:para>
</db:section>
<db:section xml:id="rootContext">
<db:title>QQmlContext *QQmlEngine::rootContext() const</db:title>
<db:para>Returns the engine's root context.</db:para>
<db:para>The root context is automatically created by the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>. Data that should be available to all QML component instances instantiated by the engine should be put in the root context.</db:para>
<db:para>Additional data that should only be available to a subset of component instances should be added to sub-contexts parented to the root context.</db:para>
</db:section>
<db:section xml:id="setBaseUrl">
<db:title>void QQmlEngine::setBaseUrl(const QUrl &amp;<db:emphasis>url</db:emphasis>)</db:title>
<db:para>Set the base URL for this engine to <db:code role="parameter">url</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#baseUrl">baseUrl</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setContextForObject">
<db:title>[static] void QQmlEngine::setContextForObject(QObject *<db:emphasis>object</db:emphasis>, QQmlContext *<db:emphasis>context</db:emphasis>)</db:title>
<db:para>Sets the <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link> for the <db:code role="parameter">object</db:code> to <db:code role="parameter">context</db:code>. If the <db:code role="parameter">object</db:code> already has a context, a warning is output, but the context is not changed.</db:para>
<db:para>When the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> instantiates a <db:link xlink:href="qobject.xml">QObject</db:link>, the context is set automatically.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#contextForObject">contextForObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setImportPathList">
<db:title>void QQmlEngine::setImportPathList(const QStringList &amp;<db:emphasis>paths</db:emphasis>)</db:title>
<db:para>Sets <db:code role="parameter">paths</db:code> as the list of directories where the engine searches for installed modules in a URL-based directory structure.</db:para>
<db:para>By default, this list contains the paths mentioned in <db:link xlink:href="qtqml-syntax-imports.xml#qml-import-path">QML Import Path</db:link>.</db:para>
<db:warning>
<db:para>Calling setImportPathList does not preserve the default import paths.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#importPathList">importPathList</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#addImportPath">addImportPath</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setIncubationController">
<db:title>void QQmlEngine::setIncubationController(QQmlIncubationController *<db:emphasis>controller</db:emphasis>)</db:title>
<db:para>Sets the engine's incubation <db:code role="parameter">controller</db:code>. The engine can only have one active controller and it does not take ownership of it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#incubationController">incubationController</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNetworkAccessManagerFactory">
<db:title>void QQmlEngine::setNetworkAccessManagerFactory(QQmlNetworkAccessManagerFactory *<db:emphasis>factory</db:emphasis>)</db:title>
<db:para>Sets the <db:code role="parameter">factory</db:code> to use for creating <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>(s).</db:para>
<db:para><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> is used for all network access by QML. By implementing a factory it is possible to create custom <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> with specialized caching, proxy and cookie support.</db:para>
<db:para>The factory must be set before executing the engine.</db:para>
<db:note>
<db:para><db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> does not take ownership of the factory.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#networkAccessManagerFactory">networkAccessManagerFactory</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setOutputWarningsToStandardError">
<db:title>void QQmlEngine::setOutputWarningsToStandardError(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:para>Set whether warning messages will be output to stderr to <db:code role="parameter">enabled</db:code>.</db:para>
<db:para>If <db:code role="parameter">enabled</db:code> is true, any warning messages generated by QML will be output to stderr and emitted by the <db:link xlink:href="qqmlengine.xml#warnings">warnings</db:link>() signal. If <db:code role="parameter">enabled</db:code> is false, only the <db:link xlink:href="qqmlengine.xml#warnings">warnings</db:link>() signal will be emitted. This allows applications to handle warning output themselves.</db:para>
<db:para>The default value is true.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#outputWarningsToStandardError">outputWarningsToStandardError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPluginPathList">
<db:title>void QQmlEngine::setPluginPathList(const QStringList &amp;<db:emphasis>paths</db:emphasis>)</db:title>
<db:para>Sets the list of directories where the engine searches for native plugins for imported modules (referenced in the <db:code>qmldir</db:code> file) to <db:code role="parameter">paths</db:code>.</db:para>
<db:para>By default, the list contains only <db:code>.</db:code>, i.e. the engine searches in the directory of the <db:code>qmldir</db:code> file itself.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#pluginPathList">pluginPathList</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#addPluginPath">addPluginPath</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singletonInstance">
<db:title>T QQmlEngine::singletonInstance(int <db:emphasis>qmlTypeId</db:emphasis>)</db:title>
<db:para>Returns the instance of a singleton type that was registered under <db:code role="parameter">qmlTypeId</db:code>.</db:para>
<db:para>The template argument <db:emphasis>T</db:emphasis> may be either <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> or a pointer to a <db:link xlink:href="qobject.xml">QObject</db:link>-derived type and depends on how the singleton was registered. If no instance of <db:emphasis>T</db:emphasis> has been created yet, it is created now. If <db:code role="parameter">qmlTypeId</db:code> does not represent a valid singleton type, either a default constructed <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> or a <db:code>nullptr</db:code> is returned.</db:para>
<db:para><db:link xlink:href="qobject.xml">QObject</db:link>* example:</db:para>
<db:programlisting language="cpp">class MySingleton : public QObject {
    Q_OBJECT

    // Register as default constructed singleton.
    QML_ELEMENT
    QML_SINGLETON

    static int typeId;
    // ...
};

    MySingleton::typeId = qmlTypeId(...);

    // Retrieve as QObject*
    QQmlEngine engine;
    MySingleton* instance = engine.singletonInstance&lt;MySingleton*&gt;(MySingleton::typeId);
</db:programlisting>
<db:para><db:link xlink:href="qjsvalue.xml">QJSValue</db:link> example:</db:para>
<db:programlisting language="cpp">    // Register with QJSValue callback
    int typeId = qmlRegisterSingletonType(...);

    // Retrieve as QJSValue
    QQmlEngine engine;
    QJSValue instance = engine.singletonInstance&lt;QJSValue&gt;(typeId);
</db:programlisting>
<db:para>It is recommended to store the QML type id, e.g. as a static member in the singleton class. The lookup via <db:link xlink:href="qqml-h.xml#qmlTypeId">qmlTypeId</db:link>() is costly.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
<db:member><db:link xlink:href="qqml-h.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link>()</db:member>
<db:member><db:link xlink:href="qqml-h.xml#qmlTypeId">qmlTypeId</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singletonInstance-1">
<db:title>[since 6.5] T QQmlEngine::singletonInstance(QAnyStringView <db:emphasis>uri</db:emphasis>, QAnyStringView <db:emphasis>typeName</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the instance of a singleton type named <db:code role="parameter">typeName</db:code> from the module specified by <db:code role="parameter">uri</db:code>.</db:para>
<db:para>This method can be used as an alternative to calling <db:link xlink:href="qqml-h.xml#qmlTypeId">qmlTypeId</db:link> followed by the id based overload of <db:link xlink:href="qqmlengine.xml#singletonInstance">singletonInstance</db:link>. This is convenient when one only needs to do a one time setup of a singleton; if repeated access to the singleton is required, caching its typeId will allow faster subsequent access via the <db:link xlink:href="qqmlengine.xml#singletonInstance">type-id based overload</db:link>.</db:para>
<db:para>The template argument <db:emphasis>T</db:emphasis> may be either <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> or a pointer to a <db:link xlink:href="qobject.xml">QObject</db:link>-derived type and depends on how the singleton was registered. If no instance of <db:emphasis>T</db:emphasis> has been created yet, it is created now. If <db:code role="parameter">typeName</db:code> does not represent a valid singleton type, either a default constructed <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> or a <db:code>nullptr</db:code> is returned.</db:para>
<db:programlisting language="cpp">    QQmlEngine engine;
    MySingleton *singleton = engine.singletonInstance&lt;MySingleton *&gt;(&quot;mymodule&quot;, &quot;MySingleton&quot;);
/</db:programlisting>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_SINGLETON">QML_SINGLETON</db:link></db:member>
<db:member><db:link xlink:href="qqml-h.xml#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link>()</db:member>
<db:member><db:link xlink:href="qqml-h.xml#qmlTypeId">qmlTypeId</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="trimComponentCache">
<db:title>void QQmlEngine::trimComponentCache()</db:title>
<db:para>Trims the engine's internal component cache.</db:para>
<db:para>This function causes the property metadata of any loaded components which are not currently in use to be destroyed.</db:para>
<db:para>A component is considered to be in use if there are any extant instances of the component itself, any instances of other components that use the component, or any objects instantiated by any of those components.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#clearComponentCache">clearComponentCache</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="urlInterceptors">
<db:title>QList&lt;QQmlAbstractUrlInterceptor *&gt; QQmlEngine::urlInterceptors() const</db:title>
<db:para>Returns the list of currently active URL interceptors.</db:para>
</db:section>
<db:section xml:id="warnings">
<db:title>void QQmlEngine::warnings(const QList&lt;QQmlError&gt; &amp;<db:emphasis>warnings</db:emphasis>)</db:title>
<db:para>This signal is emitted when <db:code role="parameter">warnings</db:code> messages are generated by QML.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qmlContext">
<db:title>QQmlContext *qmlContext(const QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:para>Returns the <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link> associated with <db:code role="parameter">object</db:code>, if any. This is equivalent to <db:link xlink:href="qqmlengine.xml#contextForObject">QQmlEngine::contextForObject</db:link>(object).</db:para>
<db:note>
<db:para>Add <db:code>#include &lt;QtQml&gt;</db:code> to use this function.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#contextForObject">contextForObject</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlEngine">qmlEngine</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlEngine">
<db:title>QQmlEngine *qmlEngine(const QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:para>Returns the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> associated with <db:code role="parameter">object</db:code>, if any. This is equivalent to <db:link xlink:href="qqmlengine.xml#contextForObject">QQmlEngine::contextForObject</db:link>(object)-&gt;engine(), but more efficient.</db:para>
<db:note>
<db:para>Add <db:code>#include &lt;QtQml&gt;</db:code> to use this function.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#contextForObject">contextForObject</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlContext">qmlContext</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QML_NAMESPACE_EXTENDED">
<db:title>QML_NAMESPACE_EXTENDED(<db:emphasis>EXTENSION_NAMESPACE</db:emphasis>)</db:title>
<db:para>Behaves the same way as <db:link xlink:href="qqmlintegration-h.xml#QML_EXTENDED_NAMESPACE">QML_EXTENDED_NAMESPACE</db:link> with the distinction that what is being extended is a namespace and not a type.</db:para>
<db:para>Declares that the enclosing <db:emphasis role="bold">namespace</db:emphasis> uses <db:code role="parameter">EXTENSION_NAMESPACE</db:code> as an extension to provide further enumerations in QML. This takes effect if the extended namespace is exposed to QML using a <db:link xlink:href="qqmlintegration-h.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlintegration-h.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() macro. The enumerations need to be exposed to the metaobject system for this to work.</db:para>
<db:para>For example, in the following C++ code,</db:para>
<db:programlisting language="cpp">namespace NS2 {
    Q_NAMESPACE

    enum class E2 { D = 3, E, F };
    Q_ENUM_NS(E2)
}

namespace NS1 {
    Q_NAMESPACE
    QML_ELEMENT

    enum class E1 { A, B, C };
    Q_ENUM_NS(E1)

    // Extends NS1 with NS2
    QML_NAMESPACE_EXTENDED(NS2)
}
</db:programlisting>
<db:para>the namespace <db:code>NS1</db:code> is extended with <db:code>NS2</db:code> and the <db:code>E2</db:code> enum becomes available within <db:code>NS1</db:code> from QML.</db:para>
<db:programlisting language="qml">Item {
    Component.onCompleted: console.log(NS1.E1.A, NS1.E2.D)
}
</db:programlisting>
<db:note>
<db:para><db:code role="parameter">EXTENSION_NAMESPACE</db:code> can also be a <db:link xlink:href="qobject.xml">QObject</db:link> or QGadget; in that case - and in contrast to <db:link xlink:href="qqmlintegration-h.xml#QML_EXTENDED">QML_EXTENDED</db:link>, which also exposes methods and properties - only its enumerations are exposed.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">EXTENSION_NAMESPACE</db:code> must have a metaobject; i.e. it must either be a namespace which contains the <db:link xlink:href="qobject.xml#Q_NAMESPACE">Q_NAMESPACE</db:link> macro or a <db:link xlink:href="qobject.xml">QObject</db:link>/QGadget.</db:para>
</db:note>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_EXTENDED_NAMESPACE">QML_EXTENDED_NAMESPACE</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h.xml#QML_EXTENDED">QML_EXTENDED</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-extension-objects">Registering Extension Objects</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml#Q_ENUM">Q_ENUM</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml#Q_ENUM_NS">Q_ENUM_NS</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QQmlEngine</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="importPlugin">
<db:title>[deprecated in 6.4] bool QQmlEngine::importPlugin(const QString &amp;<db:emphasis>filePath</db:emphasis>, const QString &amp;<db:emphasis>uri</db:emphasis>, QList&lt;QQmlError&gt; *<db:emphasis>errors</db:emphasis>)</db:title>
<db:para>This function is deprecated since 6.4. We strongly advise against using it in new code.</db:para>
<db:para>Import the module from QML with an &quot;import&quot; statement instead.</db:para>
<db:para>Imports the plugin named <db:code role="parameter">filePath</db:code> with the <db:code role="parameter">uri</db:code> provided. Returns true if the plugin was successfully imported; otherwise returns false.</db:para>
<db:para>On failure and if non-null, the <db:code role="parameter">errors</db:code> list will have any errors which occurred prepended to it.</db:para>
<db:para>The plugin has to be a Qt plugin which implements the <db:link xlink:href="qqmlengineextensionplugin.xml">QQmlEngineExtensionPlugin</db:link> interface.</db:para>
<db:note>
<db:para>Directly loading plugins like this can confuse the module import logic. In order to make the import logic load plugins from a specific place, you can use <db:link xlink:href="qqmlengine.xml#addPluginPath">addPluginPath</db:link>(). Each plugin should be part of a QML module that you can import using the &quot;import&quot; statement.</db:para>
</db:note>
</db:section>
</db:section>
</db:section>
</db:article>
