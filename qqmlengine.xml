<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QQmlEngine Class</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt QML Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> class provides an environment for instantiating QML components.</db:para>
<db:para>This class was introduced in Qt 5.0.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QQmlEngine</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += qml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qjsengine.xml" xlink:role="class">QJSEngine</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qqmlapplicationengine.xml" xlink:role="class">QQmlApplicationEngine</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Each QML component is instantiated in a <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link>. <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link>'s are essential for passing data to QML components. In QML, contexts are arranged hierarchically and this hierarchy is managed by the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>.</db:para>
<db:para>Prior to creating any QML components, an application must have created a <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> to gain access to a QML context. The following example shows how to create a simple Text item.</db:para>
<db:programlisting language="cpp">QQmlEngine engine;
QQmlComponent component(&amp;engine);
component.setData(&quot;import QtQuick 2.0\nText { text: \&quot;Hello world!\&quot; }&quot;, QUrl());
QQuickItem *item = qobject_cast&lt;QQuickItem *&gt;(component.create());

//add item to view, etc
...
</db:programlisting>
<db:para>In this case, the Text item will be created in the engine's <db:link xlink:href="qqmlengine.xml#rootContext">root context</db:link>.</db:para>
<db:para>Note that the <db:link xlink:href="qtquick-porting-qt5.xml#qtdeclarative-module-in-qt-5">Qt Quick 1</db:link> version is called QDeclarativeEngine.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlcomponent.xml">QQmlComponent</db:link></db:member>
<db:member><db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link></db:member>
<db:member><db:link xlink:href="qtqml-javascript-qmlglobalobject.xml">QML Global Object</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ObjectOwnership-enum">
<db:title>enum QQmlEngine::ObjectOwnership</db:title>
<db:para>ObjectOwnership controls whether or not QML automatically destroys the <db:link xlink:href="qobject.xml">QObject</db:link> when the corresponding JavaScript object is garbage collected by the engine. The two ownership options are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link></db:emphasis>::CppOwnership</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The object is owned by C++ code and QML will never delete it. The JavaScript destroy() method cannot be used on these objects. This option is similar to <db:link xlink:href="qscriptengine.xml#ValueOwnership-enum">QScriptEngine::QtOwnership</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link></db:emphasis>::JavaScriptOwnership</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The object is owned by JavaScript. When the object is returned to QML as the return value of a method call, QML will track it and delete it if there are no remaining JavaScript references to it and it has no <db:link xlink:href="qobject.xml#parent">QObject::parent</db:link>(). An object tracked by one <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> will be deleted during that <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>'s destructor. Thus, JavaScript references between objects with JavaScriptOwnership from two different engines will not be valid if one of these engines is deleted. This option is similar to <db:link xlink:href="qscriptengine.xml#ValueOwnership-enum">QScriptEngine::ScriptOwnership</db:link>.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Generally an application doesn't need to set an object's ownership explicitly. QML uses a heuristic to set the default ownership. By default, an object that is created by QML has JavaScriptOwnership. The exception to this are the root objects created by calling <db:link xlink:href="qqmlcomponent.xml#create">QQmlComponent::create</db:link>() or <db:link xlink:href="qqmlcomponent.xml#beginCreate">QQmlComponent::beginCreate</db:link>(), which have CppOwnership by default. The ownership of these root-level objects is considered to have been transferred to the C++ caller.</db:para>
<db:para>Objects not-created by QML have CppOwnership by default. The exception to this are objects returned from C++ method calls; their ownership will be set to JavaScriptOwnership. This applies only to explicit invocations of <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> methods or slots, but not to property getter invocations.</db:para>
<db:para>Calling <db:link xlink:href="qqmlengine.xml#setObjectOwnership">setObjectOwnership</db:link>() overrides the default ownership heuristic used by QML.</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="offlineStoragePath-prop">
<db:title>offlineStoragePath : QString</db:title>
<db:para>This property holds the directory for storing offline user data</db:para>
<db:para>Returns the directory where SQL and other offline storage is placed.</db:para>
<db:para>QQuickWebView and the SQL databases created with openDatabase() are stored here.</db:para>
<db:para>The default is QML/OfflineStorage in the platform-standard user application data directory.</db:para>
<db:para>Note that the path may not currently exist on the filesystem, so callers wanting to <db:emphasis>create</db:emphasis> new files at this location should create it first - see <db:link xlink:href="qdir.xml#mkpath">QDir::mkpath</db:link>().</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">offlineStoragePath</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setOfflineStoragePath</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>dir</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QQmlEngine">
<db:title>[explicit] QQmlEngine::QQmlEngine(QObject *<db:emphasis>parent</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Create a new <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> with the given <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QQmlEngine">
<db:title>[virtual noexcept] QQmlEngine::~QQmlEngine()</db:title>
<db:para>Destroys the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>.</db:para>
<db:para>Any <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link>'s created on this engine will be invalidated, but not destroyed (unless they are parented to the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> object).</db:para>
<db:para>See <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> docs for details on cleaning up the JS engine.</db:para>
</db:section>
<db:section xml:id="addImageProvider">
<db:title>void QQmlEngine::addImageProvider(const QString &amp;<db:emphasis>providerId</db:emphasis>, QQmlImageProviderBase *<db:emphasis>provider</db:emphasis>)</db:title>
<db:para>Sets the <db:code role="parameter">provider</db:code> to use for images requested via the <db:emphasis>image</db:emphasis>: url scheme, with host <db:code role="parameter">providerId</db:code>. The <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> takes ownership of <db:code role="parameter">provider</db:code>.</db:para>
<db:para>Image providers enable support for pixmap and threaded image requests. See the <db:link xlink:href="qquickimageprovider.xml">QQuickImageProvider</db:link> documentation for details on implementing and using image providers.</db:para>
<db:para>All required image providers should be added to the engine before any QML sources files are loaded.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#removeImageProvider">removeImageProvider</db:link>()</db:member>
<db:member><db:link xlink:href="qquickimageprovider.xml">QQuickImageProvider</db:link></db:member>
<db:member><db:link xlink:href="qqmlimageproviderbase.xml">QQmlImageProviderBase</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addImportPath">
<db:title>void QQmlEngine::addImportPath(const QString &amp;<db:emphasis>path</db:emphasis>)</db:title>
<db:para>Adds <db:code role="parameter">path</db:code> as a directory where the engine searches for installed modules in a URL-based directory structure.</db:para>
<db:para>The <db:code role="parameter">path</db:code> may be a local filesystem directory, a <db:link xlink:href="resources.xml">Qt Resource</db:link> path (<db:code>:/imports</db:code>), a <db:link xlink:href="resources.xml">Qt Resource</db:link> url (<db:code>qrc:/imports</db:code>) or a URL.</db:para>
<db:para>The <db:code role="parameter">path</db:code> will be converted into canonical form before it is added to the import path list.</db:para>
<db:para>The newly added <db:code role="parameter">path</db:code> will be first in the <db:link xlink:href="qqmlengine.xml#importPathList">importPathList</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setImportPathList">setImportPathList</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-modules-topic.xml">QML Modules</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addPluginPath">
<db:title>void QQmlEngine::addPluginPath(const QString &amp;<db:emphasis>path</db:emphasis>)</db:title>
<db:para>Adds <db:code role="parameter">path</db:code> as a directory where the engine searches for native plugins for imported modules (referenced in the <db:code>qmldir</db:code> file).</db:para>
<db:para>By default, the list contains only <db:code>.</db:code>, i.e. the engine searches in the directory of the <db:code>qmldir</db:code> file itself.</db:para>
<db:para>The newly added <db:code role="parameter">path</db:code> will be first in the <db:link xlink:href="qqmlengine.xml#pluginPathList">pluginPathList</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setPluginPathList">setPluginPathList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="baseUrl">
<db:title>QUrl QQmlEngine::baseUrl() const</db:title>
<db:para>Return the base URL for this engine. The base URL is only used to resolve components when a relative URL is passed to the <db:link xlink:href="qqmlcomponent.xml">QQmlComponent</db:link> constructor.</db:para>
<db:para>If a base URL has not been explicitly set, this method returns the application's current working directory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setBaseUrl">setBaseUrl</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clearComponentCache">
<db:title>void QQmlEngine::clearComponentCache()</db:title>
<db:para>Clears the engine's internal component cache.</db:para>
<db:para>This function causes the property metadata of all components previously loaded by the engine to be destroyed. All previously loaded components and the property bindings for all extant objects created from those components will cease to function.</db:para>
<db:para>This function returns the engine to a state where it does not contain any loaded component data. This may be useful in order to reload a smaller subset of the previous component set, or to load a new version of a previously loaded component.</db:para>
<db:para>Once the component cache has been cleared, components must be loaded before any new objects can be created.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#trimComponentCache">trimComponentCache</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contextForObject">
<db:title>[static] QQmlContext *QQmlEngine::contextForObject(const QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:para>Returns the <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link> for the <db:code role="parameter">object</db:code>, or 0 if no context has been set.</db:para>
<db:para>When the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> instantiates a <db:link xlink:href="qobject.xml">QObject</db:link>, the context is set automatically.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setContextForObject">setContextForObject</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlContext">qmlContext</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlEngine">qmlEngine</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="event">
<db:title>[override virtual protected] bool QQmlEngine::event(QEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qobject.xml#event" role="function">QObject::event(QEvent *e)</db:link>.</db:para>
</db:section>
<db:section xml:id="imageProvider">
<db:title>QQmlImageProviderBase *QQmlEngine::imageProvider(const QString &amp;<db:emphasis>providerId</db:emphasis>) const</db:title>
<db:para>Returns the image provider set for <db:code role="parameter">providerId</db:code>.</db:para>
<db:para>Returns the provider if it was found; otherwise returns 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickimageprovider.xml">QQuickImageProvider</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="importPathList">
<db:title>QStringList QQmlEngine::importPathList() const</db:title>
<db:para>Returns the list of directories where the engine searches for installed modules in a URL-based directory structure.</db:para>
<db:para>For example, if <db:code>/opt/MyApp/lib/imports</db:code> is in the path, then QML that imports <db:code>com.mycompany.Feature</db:code> will cause the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> to look in <db:code>/opt/MyApp/lib/imports/com/mycompany/Feature/</db:code> for the components provided by that module. A <db:code>qmldir</db:code> file is required for defining the type version mapping and possibly QML extensions plugins.</db:para>
<db:para>By default, the list contains the directory of the application executable, paths specified in the <db:code>QML2_IMPORT_PATH</db:code> environment variable, and the builtin <db:code>Qml2ImportsPath</db:code> from <db:link xlink:href="qlibraryinfo.xml">QLibraryInfo</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#addImportPath">addImportPath</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#setImportPathList">setImportPathList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="importPlugin">
<db:title>bool QQmlEngine::importPlugin(const QString &amp;<db:emphasis>filePath</db:emphasis>, const QString &amp;<db:emphasis>uri</db:emphasis>, QList&lt;QQmlError&gt; *<db:emphasis>errors</db:emphasis>)</db:title>
<db:para>Imports the plugin named <db:code role="parameter">filePath</db:code> with the <db:code role="parameter">uri</db:code> provided. Returns true if the plugin was successfully imported; otherwise returns false.</db:para>
<db:para>On failure and if non-null, the <db:code role="parameter">errors</db:code> list will have any errors which occurred prepended to it.</db:para>
<db:para>The plugin has to be a Qt plugin which implements the <db:link xlink:href="qqmlextensionplugin.xml">QQmlExtensionPlugin</db:link> interface.</db:para>
</db:section>
<db:section xml:id="incubationController">
<db:title>QQmlIncubationController *QQmlEngine::incubationController() const</db:title>
<db:para>Returns the currently set incubation controller, or 0 if no controller has been set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setIncubationController">setIncubationController</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="networkAccessManager">
<db:title>QNetworkAccessManager *QQmlEngine::networkAccessManager() const</db:title>
<db:para>Returns a common <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> which can be used by any QML type instantiated by this engine.</db:para>
<db:para>If a <db:link xlink:href="qqmlnetworkaccessmanagerfactory.xml">QQmlNetworkAccessManagerFactory</db:link> has been set and a <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> has not yet been created, the <db:link xlink:href="qqmlnetworkaccessmanagerfactory.xml">QQmlNetworkAccessManagerFactory</db:link> will be used to create the <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>; otherwise the returned <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> will have no proxy or cache set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setNetworkAccessManagerFactory">setNetworkAccessManagerFactory</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="networkAccessManagerFactory">
<db:title>QQmlNetworkAccessManagerFactory *QQmlEngine::networkAccessManagerFactory() const</db:title>
<db:para>Returns the current <db:link xlink:href="qqmlnetworkaccessmanagerfactory.xml">QQmlNetworkAccessManagerFactory</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setNetworkAccessManagerFactory">setNetworkAccessManagerFactory</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="objectOwnership">
<db:title>[static] QQmlEngine::ObjectOwnership QQmlEngine::objectOwnership(QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:para>Returns the ownership of <db:code role="parameter">object</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setObjectOwnership">setObjectOwnership</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="outputWarningsToStandardError">
<db:title>bool QQmlEngine::outputWarningsToStandardError() const</db:title>
<db:para>Returns true if warning messages will be output to stderr in addition to being emitted by the <db:link xlink:href="qqmlengine.xml#warnings">warnings</db:link>() signal, otherwise false.</db:para>
<db:para>The default value is true.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#setOutputWarningsToStandardError">setOutputWarningsToStandardError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pluginPathList">
<db:title>QStringList QQmlEngine::pluginPathList() const</db:title>
<db:para>Returns the list of directories where the engine searches for native plugins for imported modules (referenced in the <db:code>qmldir</db:code> file).</db:para>
<db:para>By default, the list contains only <db:code>.</db:code>, i.e. the engine searches in the directory of the <db:code>qmldir</db:code> file itself.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#addPluginPath">addPluginPath</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#setPluginPathList">setPluginPathList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="quit">
<db:title>void QQmlEngine::quit()</db:title>
<db:para>This signal is emitted when the QML loaded by the engine would like to quit.</db:para>
</db:section>
<db:section xml:id="removeImageProvider">
<db:title>void QQmlEngine::removeImageProvider(const QString &amp;<db:emphasis>providerId</db:emphasis>)</db:title>
<db:para>Removes the image provider for <db:code role="parameter">providerId</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#addImageProvider">addImageProvider</db:link>()</db:member>
<db:member><db:link xlink:href="qquickimageprovider.xml">QQuickImageProvider</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rootContext">
<db:title>QQmlContext *QQmlEngine::rootContext() const</db:title>
<db:para>Returns the engine's root context.</db:para>
<db:para>The root context is automatically created by the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>. Data that should be available to all QML component instances instantiated by the engine should be put in the root context.</db:para>
<db:para>Additional data that should only be available to a subset of component instances should be added to sub-contexts parented to the root context.</db:para>
</db:section>
<db:section xml:id="setBaseUrl">
<db:title>void QQmlEngine::setBaseUrl(const QUrl &amp;<db:emphasis>url</db:emphasis>)</db:title>
<db:para>Set the base URL for this engine to <db:code role="parameter">url</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#baseUrl">baseUrl</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setContextForObject">
<db:title>[static] void QQmlEngine::setContextForObject(QObject *<db:emphasis>object</db:emphasis>, QQmlContext *<db:emphasis>context</db:emphasis>)</db:title>
<db:para>Sets the <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link> for the <db:code role="parameter">object</db:code> to <db:code role="parameter">context</db:code>. If the <db:code role="parameter">object</db:code> already has a context, a warning is output, but the context is not changed.</db:para>
<db:para>When the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> instantiates a <db:link xlink:href="qobject.xml">QObject</db:link>, the context is set automatically.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#contextForObject">contextForObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setImportPathList">
<db:title>void QQmlEngine::setImportPathList(const QStringList &amp;<db:emphasis>paths</db:emphasis>)</db:title>
<db:para>Sets <db:code role="parameter">paths</db:code> as the list of directories where the engine searches for installed modules in a URL-based directory structure.</db:para>
<db:para>By default, the list contains the directory of the application executable, paths specified in the <db:code>QML2_IMPORT_PATH</db:code> environment variable, and the builtin <db:code>Qml2ImportsPath</db:code> from <db:link xlink:href="qlibraryinfo.xml">QLibraryInfo</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#importPathList">importPathList</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#addImportPath">addImportPath</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setIncubationController">
<db:title>void QQmlEngine::setIncubationController(QQmlIncubationController *<db:emphasis>controller</db:emphasis>)</db:title>
<db:para>Sets the engine's incubation <db:code role="parameter">controller</db:code>. The engine can only have one active controller and it does not take ownership of it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#incubationController">incubationController</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNetworkAccessManagerFactory">
<db:title>void QQmlEngine::setNetworkAccessManagerFactory(QQmlNetworkAccessManagerFactory *<db:emphasis>factory</db:emphasis>)</db:title>
<db:para>Sets the <db:code role="parameter">factory</db:code> to use for creating <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>(s).</db:para>
<db:para><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> is used for all network access by QML. By implementing a factory it is possible to create custom <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> with specialized caching, proxy and cookie support.</db:para>
<db:para>The factory must be set before executing the engine.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#networkAccessManagerFactory">networkAccessManagerFactory</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setObjectOwnership">
<db:title>[static] void QQmlEngine::setObjectOwnership(QObject *<db:emphasis>object</db:emphasis>, QQmlEngine::ObjectOwnership <db:emphasis>ownership</db:emphasis>)</db:title>
<db:para>Sets the <db:code role="parameter">ownership</db:code> of <db:code role="parameter">object</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#objectOwnership">objectOwnership</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setOutputWarningsToStandardError">
<db:title>void QQmlEngine::setOutputWarningsToStandardError(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:para>Set whether warning messages will be output to stderr to <db:code role="parameter">enabled</db:code>.</db:para>
<db:para>If <db:code role="parameter">enabled</db:code> is true, any warning messages generated by QML will be output to stderr and emitted by the <db:link xlink:href="qqmlengine.xml#warnings">warnings</db:link>() signal. If <db:code role="parameter">enabled</db:code> is false, only the <db:link xlink:href="qqmlengine.xml#warnings">warnings</db:link>() signal will be emitted. This allows applications to handle warning output themselves.</db:para>
<db:para>The default value is true.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#outputWarningsToStandardError">outputWarningsToStandardError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPluginPathList">
<db:title>void QQmlEngine::setPluginPathList(const QStringList &amp;<db:emphasis>paths</db:emphasis>)</db:title>
<db:para>Sets the list of directories where the engine searches for native plugins for imported modules (referenced in the <db:code>qmldir</db:code> file) to <db:code role="parameter">paths</db:code>.</db:para>
<db:para>By default, the list contains only <db:code>.</db:code>, i.e. the engine searches in the directory of the <db:code>qmldir</db:code> file itself.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#pluginPathList">pluginPathList</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#addPluginPath">addPluginPath</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="trimComponentCache">
<db:title>void QQmlEngine::trimComponentCache()</db:title>
<db:para>Trims the engine's internal component cache.</db:para>
<db:para>This function causes the property metadata of any loaded components which are not currently in use to be destroyed.</db:para>
<db:para>A component is considered to be in use if there are any extant instances of the component itself, any instances of other components that use the component, or any objects instantiated by any of those components.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#clearComponentCache">clearComponentCache</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="warnings">
<db:title>void QQmlEngine::warnings(const QList&lt;QQmlError&gt; &amp;<db:emphasis>warnings</db:emphasis>)</db:title>
<db:para>This signal is emitted when <db:code role="parameter">warnings</db:code> messages are generated by QML.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qmlClearTypeRegistrations">
<db:title>void qmlClearTypeRegistrations()</db:title>
<db:para>Clears all stored type registrations, such as those produced with <db:link xlink:href="qqmlengine.xml#qmlRegisterType">qmlRegisterType</db:link>().</db:para>
<db:para>Do not call this function while a <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> exists or behavior will be undefined. Any existing QQmlEngines must be deleted before calling this function. This function only affects the application global cache. Delete the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> to clear all cached data relating to that engine.</db:para>
<db:para>#include &lt;<db:link xlink:href="qtqml-qmlmodule.xml">QtQml</db:link>&gt; to use this method.</db:para>
</db:section>
<db:section xml:id="qmlContext">
<db:title>QQmlContext *qmlContext(const QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:para>Returns the <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link> associated with <db:code role="parameter">object</db:code>, if any. This is equivalent to <db:link xlink:href="qqmlengine.xml#contextForObject">QQmlEngine::contextForObject</db:link>(object).</db:para>
<db:note>
<db:para>Add <db:code>#include &lt;QtQml&gt;</db:code> to use this function.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#contextForObject">contextForObject</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlEngine">qmlEngine</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlEngine">
<db:title>QQmlEngine *qmlEngine(const QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:para>Returns the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> associated with <db:code role="parameter">object</db:code>, if any. This is equivalent to <db:link xlink:href="qqmlengine.xml#contextForObject">QQmlEngine::contextForObject</db:link>(object)-&gt;engine(), but more efficient.</db:para>
<db:note>
<db:para>Add <db:code>#include &lt;QtQml&gt;</db:code> to use this function.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#contextForObject">contextForObject</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#qmlContext">qmlContext</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qmlInfo">
<db:title>QQmlInfo qmlInfo(const QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:para>Prints warning messages that include the file and line number for the specified QML <db:code role="parameter">object</db:code>.</db:para>
<db:para>When QML types display warning messages, it improves traceability if they include the QML file and line number on which the particular instance was instantiated.</db:para>
<db:para>To include the file and line number, an object must be passed. If the file and line number is not available for that instance (either it was not instantiated by the QML engine or location information is disabled), &quot;unknown location&quot; will be used instead.</db:para>
<db:para>For example,</db:para>
<db:programlisting language="cpp">qmlInfo(object) &lt;&lt; tr(&quot;component property is a write-once property&quot;);
</db:programlisting>
<db:para>prints</db:para>
<db:programlisting language="cpp">QML MyCustomType (unknown location): component property is a write-once property
</db:programlisting>
</db:section>
<db:section xml:id="qmlProtectModule">
<db:title>bool qmlProtectModule(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>majVersion</db:emphasis>)</db:title>
<db:para>This function protects a module from having types registered into it. This can be used to prevent other plugins from injecting types into your module. It can also be a performance improvement, as it allows the engine to skip checking for the possibility of new types or plugins when this import is reached.</db:para>
<db:para>The performance benefit is primarily seen when registering application specific types from within the application instead of through a plugin. Using qmlProtectModule allows the engine to skip checking for a plugin when that uri is imported, which can be noticeable with slow file systems.</db:para>
<db:para>After this function is called, any attempt to register C++ types into this uri, major version combination will lead to a runtime error. Call this after you have registered all of your types with the engine.</db:para>
<db:para>#include &lt;<db:link xlink:href="qtqml-qmlmodule.xml">QtQml</db:link>&gt; to use this function.</db:para>
<db:para>Returns true if the module with <db:code role="parameter">uri</db:code> as a <db:link xlink:href="qtqml-modules-identifiedmodules.xml">module identifier</db:link> and <db:code role="parameter">majVersion</db:code> as a major version number was found and locked, otherwise returns false. The module must contain exported types in order to be found.</db:para>
</db:section>
<db:section xml:id="qmlRegisterSingletonType">
<db:title>int qmlRegisterSingletonType(const QUrl &amp;<db:emphasis>url</db:emphasis>, const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>)</db:title>
<db:para>This function may be used to register a singleton type with the name <db:code role="parameter">qmlName</db:code>, in the library imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>. The type is defined by the QML file located at <db:code role="parameter">url</db:code>. The url must be an absolute URL, i.e. url.isRelative() == false.</db:para>
<db:para>In addition the type's QML file must have pragma Singleton statement among its import statements.</db:para>
<db:para>A singleton type may be referenced via the type name with which it was registered, and this typename may be used as the target in a <db:link xlink:href="qml-qtqml-connections.xml">Connections</db:link> type or otherwise used as any other type id would. One exception to this is that a singleton type property may not be aliased (because the singleton type name does not identify an object within the same component as any other item).</db:para>
<db:para>Usage:</db:para>
<db:programlisting language="qml">// First, define your QML singleton type which provides the functionality.
pragma Singleton
import QtQuick 2.0
Item {
    property int testProp1: 125
}
</db:programlisting>
<db:programlisting language="cpp">// Second, register the QML singleton type by calling this function in an initialization function.
#include &lt;QtQml&gt;
...
qmlRegisterSingletonType(QUrl(&quot;file:///absolute/path/SingletonType.qml&quot;), &quot;Qt.example.qobjectSingleton&quot;, 1, 0, &quot;RegisteredSingleton&quot;);
...
</db:programlisting>
<db:para>In order to use the registered singleton type in QML, you must import the singleton type.</db:para>
<db:programlisting language="qml">import QtQuick 2.0
import Qt.example.qobjectSingleton 1.0
Item {
    id: root
    property int someValue: RegisteredSingleton.testProp1
}
</db:programlisting>
<db:para>It is also possible to have QML singleton types registered without using the qmlRegisterSingletonType function. That can be done by adding a pragma Singleton statement among the imports of the type's QML file. In addition the type must be defined in a qmldir file with a singleton keyword and the qmldir must be imported by the QML files using the singleton.</db:para>
</db:section>
<db:section xml:id="qmlRegisterSingletonType-1">
<db:title>int qmlRegisterSingletonType(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>typeName</db:emphasis>, QJSValue (*)(QQmlEngine *, QJSEngine *) <db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This function may be used to register a singleton type provider <db:code role="parameter">callback</db:code> in a particular <db:code role="parameter">uri</db:code> and <db:code role="parameter">typeName</db:code> with a version specified in <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>.</db:para>
<db:para>Installing a singleton type allows developers to provide arbitrary functionality (methods and properties) to a client without requiring individual instances of the type to be instantiated by the client.</db:para>
<db:para>A singleton type may be either a <db:link xlink:href="qobject.xml">QObject</db:link> or a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>. This function should be used to register a singleton type provider function which returns a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> as a singleton type.</db:para>
<db:para><db:emphasis role="bold">NOTE:</db:emphasis> <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> singleton type properties will <db:emphasis role="bold">not</db:emphasis> trigger binding re-evaluation if changed.</db:para>
<db:para>Usage:</db:para>
<db:programlisting language="cpp">// First, define the singleton type provider function (callback).
static QJSValue example_qjsvalue_singletontype_provider(QQmlEngine *engine, QJSEngine *scriptEngine)
{
    Q_UNUSED(engine)

    static int seedValue = 5;
    QJSValue example = scriptEngine-&gt;newObject();
    example.setProperty(&quot;someProperty&quot;, seedValue++);
    return example;
}

// Second, register the singleton type provider with QML by calling this function in an initialization function.
#include &lt;QtQml&gt;
...
qmlRegisterSingletonType(&quot;Qt.example.qjsvalueApi&quot;, 1, 0, &quot;MyApi&quot;, example_qjsvalue_singletontype_provider);
...
</db:programlisting>
<db:para>In order to use the registered singleton type in QML, you must import the singleton type.</db:para>
<db:programlisting language="qml">import QtQuick 2.0
import Qt.example.qjsvalueApi 1.0 as ExampleApi
Item {
    id: root
    property int someValue: ExampleApi.MyApi.someProperty
}
</db:programlisting>
</db:section>
<db:section xml:id="qmlRegisterType">
<db:title>int qmlRegisterType(const QUrl &amp;<db:emphasis>url</db:emphasis>, const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>)</db:title>
<db:para>This function registers a type in the QML system with the name <db:code role="parameter">qmlName</db:code>, in the library imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>. The type is defined by the QML file located at <db:code role="parameter">url</db:code>. The url must be an absolute URL, i.e. url.isRelative() == false.</db:para>
<db:para>Normally QML files can be loaded as types directly from other QML files, or using a qmldir file. This function allows registration of files to types from C++ code, such as when the type mapping needs to be procedurally determined at startup.</db:para>
<db:para>#include &lt;<db:link xlink:href="qtqml-qmlmodule.xml">QtQml</db:link>&gt; to use this function.</db:para>
<db:para>Returns -1 if the registration was not successful.</db:para>
</db:section>
<db:section xml:id="qmlRegisterTypeNotAvailable">
<db:title>int qmlRegisterTypeNotAvailable(const char *<db:emphasis>uri</db:emphasis>, int <db:emphasis>versionMajor</db:emphasis>, int <db:emphasis>versionMinor</db:emphasis>, const char *<db:emphasis>qmlName</db:emphasis>, const QString &amp;<db:emphasis>message</db:emphasis>)</db:title>
<db:para>This function registers a type in the QML system with the name <db:code role="parameter">qmlName</db:code>, in the type namespace imported from <db:code role="parameter">uri</db:code> having the version number composed from <db:code role="parameter">versionMajor</db:code> and <db:code role="parameter">versionMinor</db:code>, but any attempt to instantiate the type will produce the given error <db:code role="parameter">message</db:code>.</db:para>
<db:para>Normally, the types exported by a plugin should be fixed. However, if a C++ type is not available, you should at least &quot;reserve&quot; the QML type name, and give the user of the unavailable type a meaningful error message.</db:para>
<db:para>Returns the QML type id.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">#ifdef NO_GAMES_ALLOWED
qmlRegisterTypeNotAvailable(&quot;MinehuntCore&quot;, 0, 1, &quot;Game&quot;, &quot;Get back to work, slacker!&quot;);
#else
qmlRegisterType&lt;MinehuntGame&gt;(&quot;MinehuntCore&quot;, 0, 1, &quot;Game&quot;);
#endif
</db:programlisting>
<db:para>This will cause any QML which imports the &quot;MinehuntCore&quot; type namespace and attempts to use the type to produce an error message:</db:para>
<db:programlisting language="cpp">fun.qml: Get back to work, slacker!
   Game {
   ^
</db:programlisting>
<db:para>Without this, a generic &quot;Game is not a type&quot; message would be given.</db:para>
<db:para>#include &lt;<db:link xlink:href="qtqml-qmlmodule.xml">QtQml</db:link>&gt; to use this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">qmlRegisterUncreatableType()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QML_DECLARE_TYPE">
<db:title>QML_DECLARE_TYPE</db:title>
<db:para>Equivalent to <db:code>Q_DECLARE_METATYPE(TYPE *)</db:code> and <db:code>Q_DECLARE_METATYPE(QQmlListProperty&lt;TYPE&gt;)</db:code></db:para>
<db:para>#include &lt;<db:link xlink:href="qtqml-qmlmodule.xml">QtQml</db:link>&gt; to use this macro.</db:para>
</db:section>
<db:section xml:id="QML_DECLARE_TYPEINFO">
<db:title>QML_DECLARE_TYPEINFO(<db:emphasis>Type</db:emphasis>, <db:emphasis>Flags</db:emphasis>)</db:title>
<db:para>Declares additional properties of the given <db:code role="parameter">Type</db:code> as described by the specified <db:code role="parameter">Flags</db:code>.</db:para>
<db:para>Current the only supported type info is <db:code>QML_HAS_ATTACHED_PROPERTIES</db:code> which declares that the <db:code role="parameter">Type</db:code> supports <db:link xlink:href="qtqml-syntax-objectattributes.xml#attached-properties-and-attached-signal-handlers">attached properties</db:link>.</db:para>
<db:para>#include &lt;<db:link xlink:href="qtqml-qmlmodule.xml">QtQml</db:link>&gt; to use this macro.</db:para>
</db:section>
</db:section>
</db:article>
