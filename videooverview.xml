<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Video Overview</db:title>
<db:productname>QtMultimedia</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Multimedia Documentation</db:titleabbrev>
<db:abstract>
<db:para>Video playback.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="video-features">
<db:title>Video Features</db:title>
<db:para>Qt Multimedia offers both high and low level C++ classes for playing and manipulating video data, and QML types for playback and control. Some of these classes also overlap with both <db:link xlink:href="cameraoverview.xml">camera</db:link> and <db:link xlink:href="audiooverview.xml">audio</db:link> classes, which can be useful.</db:para>
</db:section>
<db:section xml:id="video-implementation-details">
<db:title>Video Implementation Details</db:title>
<db:anchor xml:id="multimedia-playing-video"/>
<db:section xml:id="playing-video-in-c">
<db:title>Playing Video in C++</db:title>
<db:para>You can use the <db:link xlink:href="qmediaplayer.xml">QMediaPlayer</db:link> class to decode a video file, and display it using <db:link xlink:href="qvideowidget.xml">QVideoWidget</db:link>, <db:link xlink:href="qgraphicsvideoitem.xml">QGraphicsVideoItem</db:link>, or a custom class.</db:para>
<db:para>Here's an example of using <db:link xlink:href="qvideowidget.xml">QVideoWidget</db:link>:</db:para>
<db:programlisting language="cpp">player = new QMediaPlayer;

playlist = new QMediaPlaylist(player);
playlist-&gt;addMedia(QUrl(&quot;http://example.com/myclip1.mp4&quot;));
playlist-&gt;addMedia(QUrl(&quot;http://example.com/myclip2.mp4&quot;));

videoWidget = new QVideoWidget;
player-&gt;setVideoOutput(videoWidget);

videoWidget-&gt;show();
playlist-&gt;setCurrentIndex(1);
player-&gt;play();
</db:programlisting>
<db:para>And an example with <db:link xlink:href="qgraphicsvideoitem.xml">QGraphicsVideoItem</db:link>:</db:para>
<db:programlisting language="cpp">player = new QMediaPlayer(this);

QGraphicsVideoItem *item = new QGraphicsVideoItem;
player-&gt;setVideoOutput(item);
graphicsView-&gt;scene()-&gt;addItem(item);
graphicsView-&gt;show();

player-&gt;setMedia(QUrl(&quot;http://example.com/myclip4.ogv&quot;));
player-&gt;play();
</db:programlisting>
</db:section>
<db:section xml:id="playing-video-in-qml">
<db:title>Playing Video in QML</db:title>
<db:para>You can use <db:link xlink:href="qml-qtmultimedia-videooutput.xml">VideoOutput</db:link> to render content that is provided by either a <db:link xlink:href="qml-qtmultimedia-mediaplayer.xml">MediaPlayer</db:link> or a <db:link xlink:href="qml-qtmultimedia-camera.xml">Camera</db:link>. The <db:link xlink:href="qml-qtmultimedia-videooutput.xml">VideoOutput</db:link> is a visual component that can be transformed or acted upon by shaders (as the <db:link xlink:href="qtmultimedia-multimedia-video-qmlvideofx-example.xml">QML Video Shader Effects Example</db:link> shows), while all media decoding and playback control is handled by the <db:link xlink:href="qml-qtmultimedia-mediaplayer.xml">MediaPlayer</db:link>.</db:para>
<db:para>Alternatively there is also a higher level <db:link xlink:href="qml-qtmultimedia-video.xml">Video</db:link> type that acts as a single, visual element to play video and control playback.</db:para>
</db:section>
<db:section xml:id="working-with-low-level-video-frames">
<db:title>Working with Low Level Video Frames</db:title>
<db:para>Qt Multimedia offers a number of low level classes to make handling video frames a bit easier. These classes are primarily used when writing code that processes video or camera frames (for example, detecting barcodes, or applying a fancy vignette effect), or needs to display video in a special way that is otherwise unsupported.</db:para>
<db:para>The <db:link xlink:href="qvideoframe.xml">QVideoFrame</db:link> class encapsulates a video frame and allows the contents to be mapped into system memory for manipulation or processing, while deriving a class from <db:link xlink:href="qabstractvideosurface.xml">QAbstractVideoSurface</db:link> allows you to receive these frames from <db:link xlink:href="qmediaplayer.xml">QMediaPlayer</db:link> and <db:link xlink:href="qcamera.xml">QCamera</db:link>.</db:para>
<db:programlisting language="cpp">class MyVideoSurface : public QAbstractVideoSurface
{
    QList&lt;QVideoFrame::PixelFormat&gt; supportedPixelFormats(
            QAbstractVideoBuffer::HandleType handleType = QAbstractVideoBuffer::NoHandle) const
    {
        Q_UNUSED(handleType);

        // Return the formats you will support
        return QList&lt;QVideoFrame::PixelFormat&gt;() &lt;&lt; QVideoFrame::Format_RGB565;
    }

    bool present(const QVideoFrame &amp;frame)
    {
        Q_UNUSED(frame);
        // Handle the frame and do your processing

        return true;
    }
};
</db:programlisting>
<db:para>and with an instance of this surface, <db:code>myVideoSurface</db:code>, you can set the surface as the <db:link xlink:href="qmediaplayer.xml#setVideoOutput">video output</db:link> for <db:link xlink:href="qmediaplayer.xml">QMediaPlayer</db:link>.</db:para>
<db:programlisting language="cpp">player-&gt;setVideoOutput(myVideoSurface);
</db:programlisting>
<db:para>Several of the built-in Qt classes offer this functionality as well, so if you decode video in your application, you can present it to classes that offer a <db:link xlink:href="qvideorenderercontrol.xml">QVideoRendererControl</db:link> class, and in QML you can set a custom object for the source of a <db:link xlink:href="qml-qtmultimedia-videooutput.xml">VideoOutput</db:link> with either a writable <db:code>videoSurface</db:code> property (that the instance will set it's internal video surface to) or a readable <db:code>mediaObject</db:code> property with a <db:link xlink:href="qmediaobject.xml">QMediaObject</db:link> derived class that implements the <db:link xlink:href="qvideorenderercontrol.xml">QVideoRendererControl</db:link> interface.</db:para>
<db:para>The following snippet shows a class that has a writable <db:code>videoSurface</db:code> property and receives frames through a public slot <db:code>onNewVideoContentReceived()</db:code>. These frames are then presented on the surface set in <db:code>setVideoSurface()</db:code>.</db:para>
<db:programlisting language="cpp">class MyVideoProducer : public QObject
{
    Q_OBJECT
    Q_PROPERTY(QAbstractVideoSurface *videoSurface READ videoSurface WRITE setVideoSurface)

public:
    QAbstractVideoSurface* videoSurface() const { return m_surface; }

    void setVideoSurface(QAbstractVideoSurface *surface)
    {
        if (m_surface != surface &amp;&amp; m_surface &amp;&amp; m_surface-&gt;isActive()) {
            m_surface-&gt;stop();
        }
        m_surface = surface;
        if (m_surface)
            m_surface-&gt;start(m_format);
    }

    // ...

public slots:
    void onNewVideoContentReceived(const QVideoFrame &amp;frame)
    {
        if (m_surface)
            m_surface-&gt;present(frame);
    }

private:
    QAbstractVideoSurface *m_surface;
    QVideoSurfaceFormat m_format;
};

</db:programlisting>
</db:section>
<db:section xml:id="recording-video">
<db:title>Recording Video</db:title>
<db:para>You can use the <db:link xlink:href="qmediarecorder.xml">QMediaRecorder</db:link> class in conjunction with other classes to record video to disk. Primarily this is used with the camera, so consult the <db:link xlink:href="cameraoverview.xml">Camera Overview</db:link> for more information.</db:para>
</db:section>
<db:section xml:id="monitoring-video-frames">
<db:title>Monitoring Video Frames</db:title>
<db:para>You can use the <db:link xlink:href="qvideoprobe.xml">QVideoProbe</db:link> class to access video frames as they flow through different parts of a media pipeline when using other classes like <db:link xlink:href="qmediaplayer.xml">QMediaPlayer</db:link>, <db:link xlink:href="qmediarecorder.xml">QMediaRecorder</db:link> or <db:link xlink:href="qcamera.xml">QCamera</db:link>. After creating the high level media class, you can set the source of the video probe to that instance. This can be useful for performing some video processing tasks (like barcode recognition, or object detection) while the video is rendered normally. You can not affect the video frames using this class, and they may arrive at a slightly different time than they are being rendered.</db:para>
<db:para>Here's an example of installing a video probe while recording the camera:</db:para>
<db:programlisting language="cpp">camera = new QCamera;
viewfinder = new QCameraViewfinder();
camera-&gt;setViewfinder(viewfinder);

camera-&gt;setCaptureMode(QCamera::CaptureVideo);

videoProbe = new QVideoProbe(this);

if (videoProbe-&gt;setSource(camera)) {
    // Probing succeeded, videoProbe-&gt;isValid() should be true.
    connect(videoProbe, SIGNAL(videoFrameProbed(QVideoFrame)),
            this, SLOT(detectBarcodes(QVideoFrame)));
}

camera-&gt;start();
// Viewfinder frames should now also be emitted by
// the video probe, even in still image capture mode.
// Another alternative is to install the probe on a
// QMediaRecorder connected to the camera to get the
// recorded frames, if they are different from the
// viewfinder frames.

</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="examples">
<db:title>Examples</db:title>
<db:para>There are both C++ and QML examples available.</db:para>
<db:section xml:id="c-examples">
<db:title>C++ Examples</db:title>
</db:section>
<db:section xml:id="qml-examples">
<db:title>QML Examples</db:title>
</db:section>
</db:section>
<db:section xml:id="reference-documentation">
<db:title>Reference Documentation</db:title>
<db:section xml:id="c-classes">
<db:title>C++ Classes</db:title>
<db:variablelist role="multimedia_video">
<db:varlistentry>
<db:term><db:link xlink:href="qabstractplanarvideobuffer.xml" xlink:role="class">QAbstractPlanarVideoBuffer</db:link></db:term>
<db:listitem>
<db:para>The QAbstractPlanarVideoBuffer class is an abstraction for planar video data.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qabstractvideobuffer.xml" xlink:role="class">QAbstractVideoBuffer</db:link></db:term>
<db:listitem>
<db:para>The QAbstractVideoBuffer class is an abstraction for video data.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qabstractvideofilter.xml" xlink:role="class">QAbstractVideoFilter</db:link></db:term>
<db:listitem>
<db:para>The QAbstractVideoFilter class represents a filter that is applied to the video frames received by a VideoOutput type.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qabstractvideosurface.xml" xlink:role="class">QAbstractVideoSurface</db:link></db:term>
<db:listitem>
<db:para>The QAbstractVideoSurface class is a base class for video presentation surfaces.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qvideofilterrunnable.xml" xlink:role="class">QVideoFilterRunnable</db:link></db:term>
<db:listitem>
<db:para>The QVideoFilterRunnable class represents the implementation of a filter that owns all graphics and computational resources, and performs the actual filtering or calculations.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qvideoframe.xml" xlink:role="class">QVideoFrame</db:link></db:term>
<db:listitem>
<db:para>The QVideoFrame class represents a frame of video data.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qvideoprobe.xml" xlink:role="class">QVideoProbe</db:link></db:term>
<db:listitem>
<db:para>The QVideoProbe class allows you to monitor video frames being played or recorded.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qvideosurfaceformat.xml" xlink:role="class">QVideoSurfaceFormat</db:link></db:term>
<db:listitem>
<db:para>The QVideoSurfaceFormat class specifies the stream format of a video presentation surface.</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
</db:section>
<db:section xml:id="qml-types">
<db:title>QML Types</db:title>
<db:variablelist role="multimedia_video_qml">
<db:varlistentry>
<db:term><db:link xlink:href="qml-qtmultimedia-mediaplayer.xml" xlink:role="">MediaPlayer</db:link></db:term>
<db:listitem>
<db:para>Add media playback to a scene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qml-qtmultimedia-playlist.xml" xlink:role="">Playlist</db:link></db:term>
<db:listitem>
<db:para>For specifying a list of media to be played.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qml-qtmultimedia-playlistitem.xml" xlink:role="">PlaylistItem</db:link></db:term>
<db:listitem>
<db:para>Defines an item in a Playlist.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qml-qtmultimedia-video.xml" xlink:role="">Video</db:link></db:term>
<db:listitem>
<db:para>A convenience type for showing a specified video.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qml-qtmultimedia-videooutput.xml" xlink:role="">VideoOutput</db:link></db:term>
<db:listitem>
<db:para>Render video or camera viewfinder.</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
</db:section>
</db:section>
</db:article>
