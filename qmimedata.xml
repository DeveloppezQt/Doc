<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QMimeData Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.0.4 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qmimedata.xml">QMimeData</db:link> class provides a container for data that records information about its MIME type.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QMimeData</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qmimedata.xml">QMimeData</db:link> is used to describe information that can be stored in the <db:link xlink:href="qclipboard.xml">clipboard</db:link>, and transferred via the <db:link xlink:href="dnd.xml">drag and drop</db:link> mechanism. <db:link xlink:href="qmimedata.xml">QMimeData</db:link> objects associate the data that they hold with the corresponding MIME types to ensure that information can be safely transferred between applications, and copied around within the same application.</db:para>
<db:para><db:link xlink:href="qmimedata.xml">QMimeData</db:link> objects are usually created using new and supplied to <db:link xlink:href="qdrag.xml">QDrag</db:link> or <db:link xlink:href="qclipboard.xml">QClipboard</db:link> objects. This is to enable Qt to manage the memory that they use.</db:para>
<db:para>A single <db:link xlink:href="qmimedata.xml">QMimeData</db:link> object can store the same data using several different formats at the same time. The <db:link xlink:href="qmimedata.xml#formats">formats</db:link>() function returns a list of the available formats in order of preference. The <db:link xlink:href="qmimedata.xml#data">data</db:link>() function returns the raw data associated with a MIME type, and <db:link xlink:href="qmimedata.xml#setData">setData</db:link>() allows you to set the data for a MIME type.</db:para>
<db:para>For the most common MIME types, <db:link xlink:href="qmimedata.xml">QMimeData</db:link> provides convenience functions to access the data:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Tester</db:para>
</db:th>
<db:th>
<db:para>Getter</db:para>
</db:th>
<db:th>
<db:para>Setter</db:para>
</db:th>
<db:th>
<db:para>MIME Types</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#hasText">hasText</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#text">text</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#setText">setText</db:link>()</db:para>
</db:td>
<db:td>
<db:para>text/plain</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#hasHtml">hasHtml</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#html">html</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#setHtml">setHtml</db:link>()</db:para>
</db:td>
<db:td>
<db:para>text/html</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#hasUrls">hasUrls</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#urls">urls</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#setUrls">setUrls</db:link>()</db:para>
</db:td>
<db:td>
<db:para>text/uri-list</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#hasImage">hasImage</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#imageData">imageData</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#setImageData">setImageData</db:link>()</db:para>
</db:td>
<db:td>
<db:para>image/ *</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#hasColor">hasColor</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#colorData">colorData</db:link>()</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qmimedata.xml#setColorData">setColorData</db:link>()</db:para>
</db:td>
<db:td>
<db:para>application/x-color</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>For example, if your write a widget that accepts URL drags, you would end up writing code like this:</db:para>
<db:programlisting language="cpp">void MyWidget::dragEnterEvent(QDragEnterEvent *event)
{
    if (event-&amp;gt;mimeData()-&amp;gt;hasUrls())
        event-&amp;gt;acceptProposedAction();
}

void MyWidget::dropEvent(QDropEvent *event)
{
    if (event-&amp;gt;mimeData()-&amp;gt;hasUrls()) {
        foreach (QUrl url, event-&amp;gt;mimeData()-&amp;gt;urls()) {
            ...
        }
    }
}
</db:programlisting>
<db:para>There are three approaches for storing custom data in a <db:link xlink:href="qmimedata.xml">QMimeData</db:link> object:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Custom data can be stored directly in a <db:link xlink:href="qmimedata.xml">QMimeData</db:link> object as a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> using <db:link xlink:href="qmimedata.xml#setData">setData</db:link>(). For example:</db:para>
<db:programlisting language="cpp">QByteArray csvData = ...;

QMimeData *mimeData = new QMimeData;
mimeData-&amp;gt;setData(&quot;text/csv&quot;, csvData);
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para>We can subclass <db:link xlink:href="qmimedata.xml">QMimeData</db:link> and reimplement <db:link xlink:href="qmimedata.xml#hasFormat">hasFormat</db:link>(), <db:link xlink:href="qmimedata.xml#formats">formats</db:link>(), and <db:link xlink:href="qmimedata.xml#retrieveData">retrieveData</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para>If the drag and drop operation occurs within a single application, we can subclass <db:link xlink:href="qmimedata.xml">QMimeData</db:link> and add extra data in it, and use a <db:link xlink:href="qobject.xml#qobject_cast">qobject_cast</db:link>() in the receiver's drop event handler. For example:</db:para>
<db:programlisting language="cpp">void MyWidget::dropEvent(QDropEvent *event)
{
    const MyMimeData *myData =
            qobject_cast&amp;lt;const MyMimeData *&amp;gt;(event-&amp;gt;mimeData());
    if (myData) {
        // access myData's data directly (not through QMimeData's API)
    }
}
</db:programlisting>
</db:listitem>
</db:orderedlist>
<db:section xml:id="platform-specific-mime-types">
<db:title>Platform-Specific MIME Types</db:title>
<db:para>On Windows, <db:link xlink:href="qmimedata.xml#formats">formats</db:link>() will also return custom formats available in the MIME data, using the x-qt-windows-mime subtype to indicate that they represent data in non-standard formats. The formats will take the following form:</db:para>
<db:programlisting language="cpp">application/x-qt-windows-mime;value=&quot;&amp;lt;custom type&amp;gt;&quot;
</db:programlisting>
<db:para>The following are examples of custom MIME types:</db:para>
<db:programlisting language="cpp">application/x-qt-windows-mime;value=&quot;FileGroupDescriptor&quot;
application/x-qt-windows-mime;value=&quot;FileContents&quot;
</db:programlisting>
<db:para>The value declaration of each format describes the way in which the data is encoded.</db:para>
<db:para>In some cases (e.g. dropping multiple email attachments), multiple data values are available. They can be accessed by adding an index value:</db:para>
<db:programlisting language="cpp">application/x-qt-windows-mime;value=&quot;FileContents&quot;;index=0
application/x-qt-windows-mime;value=&quot;FileContents&quot;;index=1
</db:programlisting>
<db:para>On Windows, the MIME format does not always map directly to the clipboard formats. Qt provides QWinMime to map clipboard formats to open-standard MIME formats. Similarly, the QMacPasteboardMime maps MIME to Mac flavors.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qclipboard.xml">QClipboard</db:link></db:member>
<db:member><db:link xlink:href="qdragenterevent.xml">QDragEnterEvent</db:link></db:member>
<db:member><db:link xlink:href="qdragmoveevent.xml">QDragMoveEvent</db:link></db:member>
<db:member><db:link xlink:href="qdropevent.xml">QDropEvent</db:link></db:member>
<db:member><db:link xlink:href="qdrag.xml">QDrag</db:link></db:member>
<db:member><db:link xlink:href="dnd.xml">Drag and Drop</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QMimeData">
<db:title>QMimeData::QMimeData()</db:title>
<db:constructorsynopsis>
<db:methodname>QMimeData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QMimeData()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new MIME data object with no data in it.</db:para>
</db:section>
<db:section xml:id="dtor.QMimeData">
<db:title>[virtual] QMimeData::~QMimeData()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QMimeData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QMimeData()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the MIME data object.</db:para>
</db:section>
<db:section xml:id="clear">
<db:title>void QMimeData::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all the MIME type and data entries in the object.</db:para>
</db:section>
<db:section xml:id="colorData">
<db:title>QVariant QMimeData::colorData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>colorData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant colorData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a color if the data stored in the object represents a color (MIME type application/x-color); otherwise returns a null variant.</db:para>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> is used because <db:link xlink:href="qmimedata.xml">QMimeData</db:link> belongs to the Qt Core module, whereas <db:link xlink:href="qcolor.xml">QColor</db:link> belongs to Qt GUI. To convert the <db:link xlink:href="qvariant.xml">QVariant</db:link> to a <db:link xlink:href="qcolor.xml">QColor</db:link>, simply use <db:link xlink:href="qvariant.xml#qvariant_cast">qvariant_cast</db:link>(). For example:</db:para>
<db:programlisting language="cpp">if (event-&amp;gt;mimeData()-&amp;gt;hasColor()) {
    QColor color = qvariant_cast&amp;lt;QColor&amp;gt;(event-&amp;gt;mimeData()-&amp;gt;colorData());
    ...
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#hasColor">hasColor</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#setColorData">setColorData</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>QByteArray QMimeData::data(const QString &amp;<db:emphasis>mimeType</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>data</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>mimeType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray data(const QString &amp;mimeType) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the data stored in the object in the format described by the MIME type specified by <db:code role="parameter">mimeType</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#setData">setData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="formats">
<db:title>[virtual] QStringList QMimeData::formats() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>formats</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList formats() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list of formats supported by the object. This is a list of MIME types for which the object can return suitable data. The formats in the list are in a priority order.</db:para>
<db:para>For the most common types of data, you can call the higher-level functions <db:link xlink:href="qmimedata.xml#hasText">hasText</db:link>(), <db:link xlink:href="qmimedata.xml#hasHtml">hasHtml</db:link>(), <db:link xlink:href="qmimedata.xml#hasUrls">hasUrls</db:link>(), <db:link xlink:href="qmimedata.xml#hasImage">hasImage</db:link>(), and <db:link xlink:href="qmimedata.xml#hasColor">hasColor</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#hasFormat">hasFormat</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#setData">setData</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasColor">
<db:title>bool QMimeData::hasColor() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasColor</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasColor() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the object can return a color (MIME type application/x-color); otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#setColorData">setColorData</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#colorData">colorData</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasFormat">hasFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasFormat">
<db:title>[virtual] bool QMimeData::hasFormat(const QString &amp;<db:emphasis>mimeType</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasFormat</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>mimeType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasFormat(const QString &amp;mimeType) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the object can return data for the MIME type specified by <db:code role="parameter">mimeType</db:code>; otherwise returns false.</db:para>
<db:para>For the most common types of data, you can call the higher-level functions <db:link xlink:href="qmimedata.xml#hasText">hasText</db:link>(), <db:link xlink:href="qmimedata.xml#hasHtml">hasHtml</db:link>(), <db:link xlink:href="qmimedata.xml#hasUrls">hasUrls</db:link>(), <db:link xlink:href="qmimedata.xml#hasImage">hasImage</db:link>(), and <db:link xlink:href="qmimedata.xml#hasColor">hasColor</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#formats">formats</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#setData">setData</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasHtml">
<db:title>bool QMimeData::hasHtml() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasHtml</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasHtml() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the object can return HTML (MIME type text/html); otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#setHtml">setHtml</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#html">html</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasFormat">hasFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasImage">
<db:title>bool QMimeData::hasImage() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasImage</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasImage() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the object can return an image; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#setImageData">setImageData</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#imageData">imageData</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasFormat">hasFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasText">
<db:title>bool QMimeData::hasText() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasText</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasText() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the object can return plain text (MIME type text/plain); otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#setText">setText</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#text">text</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasHtml">hasHtml</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasFormat">hasFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasUrls">
<db:title>bool QMimeData::hasUrls() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasUrls</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasUrls() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the object can return a list of urls; otherwise returns false.</db:para>
<db:para>URLs correspond to the MIME type text/uri-list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#setUrls">setUrls</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#urls">urls</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasFormat">hasFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="html">
<db:title>QString QMimeData::html() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>html</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString html() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a string if the data stored in the object is HTML (MIME type text/html); otherwise returns an empty string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#setHtml">setHtml</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasHtml">hasHtml</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#setData">setData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="imageData">
<db:title>QVariant QMimeData::imageData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>imageData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant imageData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qvariant.xml">QVariant</db:link> storing a <db:link xlink:href="qimage.xml">QImage</db:link> if the object can return an image; otherwise returns a null variant.</db:para>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> is used because <db:link xlink:href="qmimedata.xml">QMimeData</db:link> belongs to the Qt Core module, whereas <db:link xlink:href="qimage.xml">QImage</db:link> belongs to Qt GUI. To convert the <db:link xlink:href="qvariant.xml">QVariant</db:link> to a <db:link xlink:href="qimage.xml">QImage</db:link>, simply use <db:link xlink:href="qvariant.xml#qvariant_cast">qvariant_cast</db:link>(). For example:</db:para>
<db:programlisting language="cpp">if (event-&amp;gt;mimeData()-&amp;gt;hasImage()) {
    QImage image = qvariant_cast&amp;lt;QImage&amp;gt;(event-&amp;gt;mimeData()-&amp;gt;imageData());
    ...
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#setImageData">setImageData</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasImage">hasImage</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeFormat">
<db:title>void QMimeData::removeFormat(const QString &amp;<db:emphasis>mimeType</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeFormat</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>mimeType</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeFormat(const QString &amp;mimeType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the data entry for <db:code role="parameter">mimeType</db:code> in the object.</db:para>
</db:section>
<db:section xml:id="retrieveData">
<db:title>[virtual protected] QVariant QMimeData::retrieveData(const QString &amp;<db:emphasis>mimeType</db:emphasis>, QMetaType <db:emphasis>type</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>retrieveData</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>mimeType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QMetaType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant retrieveData(const QString &amp;mimeType, QMetaType type) const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a variant with the given <db:code role="parameter">type</db:code> containing data for the MIME type specified by <db:code role="parameter">mimeType</db:code>. If the object does not support the MIME type or variant type given, a null variant is returned instead.</db:para>
<db:para>This function is called by the general <db:link xlink:href="qmimedata.xml#data">data</db:link>() getter and by the convenience getters (<db:link xlink:href="qmimedata.xml#text">text</db:link>(), <db:link xlink:href="qmimedata.xml#html">html</db:link>(), <db:link xlink:href="qmimedata.xml#urls">urls</db:link>(), <db:link xlink:href="qmimedata.xml#imageData">imageData</db:link>(), and <db:link xlink:href="qmimedata.xml#colorData">colorData</db:link>()). You can reimplement it if you want to store your data using a custom data structure (instead of a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, which is what <db:link xlink:href="qmimedata.xml#setData">setData</db:link>() provides). You would then also need to reimplement <db:link xlink:href="qmimedata.xml#hasFormat">hasFormat</db:link>() and <db:link xlink:href="qmimedata.xml#formats">formats</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setColorData">
<db:title>void QMimeData::setColorData(const QVariant &amp;<db:emphasis>color</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setColorData</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>color</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setColorData(const QVariant &amp;color)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the color data in the object to the given <db:code role="parameter">color</db:code>.</db:para>
<db:para>Colors correspond to the MIME type application/x-color.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#colorData">colorData</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasColor">hasColor</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#setData">setData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setData">
<db:title>void QMimeData::setData(const QString &amp;<db:emphasis>mimeType</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setData</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>mimeType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setData(const QString &amp;mimeType, const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the data associated with the MIME type given by <db:code role="parameter">mimeType</db:code> to the specified <db:code role="parameter">data</db:code>.</db:para>
<db:para>For the most common types of data, you can call the higher-level functions <db:link xlink:href="qmimedata.xml#setText">setText</db:link>(), <db:link xlink:href="qmimedata.xml#setHtml">setHtml</db:link>(), <db:link xlink:href="qmimedata.xml#setUrls">setUrls</db:link>(), <db:link xlink:href="qmimedata.xml#setImageData">setImageData</db:link>(), and <db:link xlink:href="qmimedata.xml#setColorData">setColorData</db:link>() instead.</db:para>
<db:para>Note that if you want to use a custom data type in an item view drag and drop operation, you must register it as a Qt <db:link xlink:href="qmetatype.xml">meta type</db:link>, using the <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() macro, and implement stream operators for it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasFormat">hasFormat</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:member>
<db:member><db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setHtml">
<db:title>void QMimeData::setHtml(const QString &amp;<db:emphasis>html</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setHtml</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>html</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setHtml(const QString &amp;html)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets <db:code role="parameter">html</db:code> as the HTML (MIME type text/html) used to represent the data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#html">html</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasHtml">hasHtml</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#setText">setText</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#setData">setData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setImageData">
<db:title>void QMimeData::setImageData(const QVariant &amp;<db:emphasis>image</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setImageData</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>image</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setImageData(const QVariant &amp;image)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the data in the object to the given <db:code role="parameter">image</db:code>.</db:para>
<db:para>A <db:link xlink:href="qvariant.xml">QVariant</db:link> is used because <db:link xlink:href="qmimedata.xml">QMimeData</db:link> belongs to the Qt Core module, whereas <db:link xlink:href="qimage.xml">QImage</db:link> belongs to Qt GUI. The conversion from <db:link xlink:href="qimage.xml">QImage</db:link> to <db:link xlink:href="qvariant.xml">QVariant</db:link> is implicit. For example:</db:para>
<db:programlisting language="cpp">mimeData-&amp;gt;setImageData(QImage(&quot;beautifulfjord.png&quot;));
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#imageData">imageData</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasImage">hasImage</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#setData">setData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setText">
<db:title>void QMimeData::setText(const QString &amp;<db:emphasis>text</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setText</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>text</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setText(const QString &amp;text)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets <db:code role="parameter">text</db:code> as the plain text (MIME type text/plain) used to represent the data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#text">text</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasText">hasText</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#setHtml">setHtml</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#setData">setData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setUrls">
<db:title>void QMimeData::setUrls(const QList&lt;QUrl&gt; &amp;<db:emphasis>urls</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setUrls</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QUrl&gt; &amp;</db:type>
<db:parameter>urls</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setUrls(const QList&lt;QUrl&gt; &amp;urls)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the URLs stored in the MIME data object to those specified by <db:code role="parameter">urls</db:code>.</db:para>
<db:para>URLs correspond to the MIME type text/uri-list.</db:para>
<db:para>Since Qt 5.0, setUrls also exports the urls as plain text, if <db:link xlink:href="qmimedata.xml#setText">setText</db:link> was not called before, to make it possible to drop them into any lineedit and text editor.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#urls">urls</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasUrls">hasUrls</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#setData">setData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="text">
<db:title>QString QMimeData::text() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>text</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString text() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a plain text (MIME type text/plain) representation of the data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#setText">setText</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasText">hasText</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#html">html</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="urls">
<db:title>QList&lt;QUrl&gt; QMimeData::urls() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QUrl&gt;</db:type>
<db:methodname>urls</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QUrl&gt; urls() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list of URLs contained within the MIME data object.</db:para>
<db:para>URLs correspond to the MIME type text/uri-list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qmimedata.xml#setUrls">setUrls</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#hasUrls">hasUrls</db:link>()</db:member>
<db:member><db:link xlink:href="qmimedata.xml#data">data</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
