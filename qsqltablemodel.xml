<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSqlTableModel Class</db:title>
<db:productname>QtSql</db:productname>
<db:edition>Qt 6.0.4 Reference Documentation</db:edition>
<db:titleabbrev>Qt SQL Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link> class provides an editable data model for a single database table.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSqlTableModel</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Sql)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Sql)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += sql</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qsqlquerymodel.xml" xlink:role="class">QSqlQueryModel</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qsqlrelationaltablemodel.xml" xlink:role="class">QSqlRelationalTableModel</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QSqlTableModel is part of <db:simplelist><db:member><db:link xlink:href="database.xml">Database Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link> is a high-level interface for reading and writing database records from a single table. It is built on top of the lower-level <db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link> and can be used to provide data to view classes such as <db:link xlink:href="qtableview.xml">QTableView</db:link>. For example:</db:para>
<db:programlisting language="cpp">    QSqlTableModel *model = new QSqlTableModel;
    model-&amp;gt;setTable(&quot;employee&quot;);
    model-&amp;gt;setEditStrategy(QSqlTableModel::OnManualSubmit);
    model-&amp;gt;select();
    model-&amp;gt;setHeaderData(0, Qt::Horizontal, tr(&quot;Name&quot;));
    model-&amp;gt;setHeaderData(1, Qt::Horizontal, tr(&quot;Salary&quot;));

    QTableView *view = new QTableView;
    view-&amp;gt;setModel(model);
    view-&amp;gt;hideColumn(0); // don't show the ID
    view-&amp;gt;show();
</db:programlisting>
<db:para>We set the SQL table's name and the edit strategy, then we set up the labels displayed in the view header. The edit strategy dictates when the changes done by the user in the view are actually applied to the database. The possible values are <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnFieldChange</db:link>, <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnRowChange</db:link>, and <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnManualSubmit</db:link>.</db:para>
<db:para><db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link> can also be used to access a database programmatically, without binding it to a view:</db:para>
<db:programlisting language="cpp">    QSqlTableModel model;
    model.setTable(&quot;employee&quot;);
    model.select();
    int salary = model.record(4).value(&quot;salary&quot;).toInt();
</db:programlisting>
<db:para>The code snippet above extracts the <db:code>salary</db:code> field from record 4 in the result set of the query <db:code>SELECT * from employee</db:code>.</db:para>
<db:para>It is possible to set filters using <db:link xlink:href="qsqltablemodel.xml#setFilter">setFilter</db:link>(), or modify the sort order using <db:link xlink:href="qsqltablemodel.xml#setSort">setSort</db:link>(). At the end, you must call <db:link xlink:href="qsqltablemodel.xml#select">select</db:link>() to populate the model with data.</db:para>
<db:para>The <db:link xlink:href="qtsql-tablemodel-example.xml">tablemodel</db:link> example illustrates how to use <db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link> as the data source for a <db:link xlink:href="qtableview.xml">QTableView</db:link>.</db:para>
<db:para><db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link> provides no direct support for foreign keys. Use the <db:link xlink:href="qsqlrelationaltablemodel.xml">QSqlRelationalTableModel</db:link> and <db:link xlink:href="qsqlrelationaldelegate.xml">QSqlRelationalDelegate</db:link> if you want to resolve foreign keys.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlrelationaltablemodel.xml">QSqlRelationalTableModel</db:link></db:member>
<db:member><db:link xlink:href="qsqlquery.xml">QSqlQuery</db:link></db:member>
<db:member><db:link xlink:href="model-view-programming.xml">Model/View Programming</db:link></db:member>
<db:member><db:link xlink:href="qtsql-tablemodel-example.xml">Table Model Example</db:link></db:member>
<db:member><db:link xlink:href="qtsql-cachedtable-example.xml">Cached Table Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="EditStrategy-enum">
<db:title>enum QSqlTableModel::EditStrategy</db:title>
<db:enumsynopsis>
<db:enumname>EditStrategy</db:enumname>
<db:enumitem>
<db:enumidentifier>OnFieldChange</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>OnRowChange</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>OnManualSubmit</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum type describes which strategy to choose when editing values in the database.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link></db:emphasis>::OnFieldChange</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>All changes to the model will be applied immediately to the database.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link></db:emphasis>::OnRowChange</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Changes to a row will be applied when the user selects a different row.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link></db:emphasis>::OnManualSubmit</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>All changes will be cached in the model until either <db:link xlink:href="qsqltablemodel.xml#submitAll">submitAll</db:link>() or <db:link xlink:href="qsqltablemodel.xml#revertAll">revertAll</db:link>() is called.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Note: To prevent inserting only partly initialized rows into the database, <db:code>OnFieldChange</db:code> will behave like <db:code>OnRowChange</db:code> for newly inserted rows.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#setEditStrategy">setEditStrategy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QSqlTableModel">
<db:title>[explicit] QSqlTableModel::QSqlTableModel(QObject *<db:emphasis>parent</db:emphasis> = nullptr, const QSqlDatabase &amp;<db:emphasis>db</db:emphasis> = QSqlDatabase())</db:title>
<db:constructorsynopsis>
<db:methodname>QSqlTableModel</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QSqlDatabase &amp;</db:type>
<db:parameter>db</db:parameter>
<db:initializer>QSqlDatabase()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QSqlTableModel(QObject *parent, const QSqlDatabase &amp;db)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates an empty <db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link> and sets the parent to <db:code role="parameter">parent</db:code> and the database connection to <db:code role="parameter">db</db:code>. If <db:code role="parameter">db</db:code> is not valid, the default database connection will be used.</db:para>
<db:para>The default edit strategy is <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnRowChange</db:link>.</db:para>
</db:section>
<db:section xml:id="dtor.QSqlTableModel">
<db:title>[virtual] QSqlTableModel::~QSqlTableModel()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QSqlTableModel</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QSqlTableModel()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the object and frees any allocated resources.</db:para>
</db:section>
<db:section xml:id="beforeDelete">
<db:title>void QSqlTableModel::beforeDelete(int <db:emphasis>row</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>beforeDelete</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void beforeDelete(int row)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted by <db:link xlink:href="qsqltablemodel.xml#deleteRowFromTable">deleteRowFromTable</db:link>() before the <db:code role="parameter">row</db:code> is deleted from the currently active database table.</db:para>
</db:section>
<db:section xml:id="beforeInsert">
<db:title>void QSqlTableModel::beforeInsert(QSqlRecord &amp;<db:emphasis>record</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>beforeInsert</db:methodname>
<db:methodparam>
<db:type>QSqlRecord &amp;</db:type>
<db:parameter>record</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void beforeInsert(QSqlRecord &amp;record)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted by <db:link xlink:href="qsqltablemodel.xml#insertRowIntoTable">insertRowIntoTable</db:link>() before a new row is inserted into the currently active database table. The values that are about to be inserted are stored in <db:code role="parameter">record</db:code> and can be modified before they will be inserted.</db:para>
</db:section>
<db:section xml:id="beforeUpdate">
<db:title>void QSqlTableModel::beforeUpdate(int <db:emphasis>row</db:emphasis>, QSqlRecord &amp;<db:emphasis>record</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>beforeUpdate</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSqlRecord &amp;</db:type>
<db:parameter>record</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void beforeUpdate(int row, QSqlRecord &amp;record)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted by <db:link xlink:href="qsqltablemodel.xml#updateRowInTable">updateRowInTable</db:link>() before the <db:code role="parameter">row</db:code> is updated in the currently active database table with the values from <db:code role="parameter">record</db:code>.</db:para>
<db:para>Note that only values that are marked as generated will be updated. The generated flag can be set with <db:link xlink:href="qsqlrecord.xml#setGenerated">QSqlRecord::setGenerated</db:link>() and checked with <db:link xlink:href="qsqlrecord.xml#isGenerated">QSqlRecord::isGenerated</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlrecord.xml#isGenerated">QSqlRecord::isGenerated</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>[override virtual] void QSqlTableModel::clear()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qsqlquerymodel.xml#clear" role="function">QSqlQueryModel::clear()</db:link>.</db:para>
</db:section>
<db:section xml:id="clearItemData">
<db:title>[override virtual] bool QSqlTableModel::clearItemData(const QModelIndex &amp;<db:emphasis>index</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>clearItemData</db:methodname>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool clearItemData(const QModelIndex &amp;index) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemmodel.xml#clearItemData" role="function">QAbstractItemModel::clearItemData(const QModelIndex &amp;index)</db:link>.</db:para>
</db:section>
<db:section xml:id="data">
<db:title>[override virtual] QVariant QSqlTableModel::data(const QModelIndex &amp;<db:emphasis>index</db:emphasis>, int <db:emphasis>role</db:emphasis> = Qt::DisplayRole) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>data</db:methodname>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>role</db:parameter>
<db:initializer>Qt::DisplayRole</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant data(const QModelIndex &amp;index, int role) const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qsqlquerymodel.xml#data" role="function">QSqlQueryModel::data(const QModelIndex &amp;item, int role) const</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#setData">setData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="database">
<db:title>QSqlDatabase QSqlTableModel::database() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSqlDatabase</db:type>
<db:methodname>database</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSqlDatabase database() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the model's database connection.</db:para>
</db:section>
<db:section xml:id="deleteRowFromTable">
<db:title>[virtual protected] bool QSqlTableModel::deleteRowFromTable(int <db:emphasis>row</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>deleteRowFromTable</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool deleteRowFromTable(int row)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Deletes the given <db:code role="parameter">row</db:code> from the currently active database table.</db:para>
<db:para>This is a low-level method that operates directly on the database and should not be called directly. Use <db:link xlink:href="qabstractitemmodel.xml#removeRow">removeRow</db:link>() or <db:link xlink:href="qsqltablemodel.xml#removeRows">removeRows</db:link>() to delete values. The model will decide depending on its edit strategy when to modify the database.</db:para>
<db:para>Returns <db:code>true</db:code> if the row was deleted; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractitemmodel.xml#removeRow">removeRow</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#removeRows">removeRows</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="editStrategy">
<db:title>QSqlTableModel::EditStrategy QSqlTableModel::editStrategy() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSqlTableModel::EditStrategy</db:type>
<db:methodname>editStrategy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSqlTableModel::EditStrategy editStrategy() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current edit strategy.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#setEditStrategy">setEditStrategy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fieldIndex">
<db:title>int QSqlTableModel::fieldIndex(const QString &amp;<db:emphasis>fieldName</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>fieldIndex</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>fieldName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int fieldIndex(const QString &amp;fieldName) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the index of the field <db:code role="parameter">fieldName</db:code>, or -1 if no corresponding field exists in the model.</db:para>
</db:section>
<db:section xml:id="filter">
<db:title>QString QSqlTableModel::filter() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>filter</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString filter() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the currently set filter.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#setFilter">setFilter</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#select">select</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="flags">
<db:title>[override virtual] Qt::ItemFlags QSqlTableModel::flags(const QModelIndex &amp;<db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>Qt::ItemFlags</db:type>
<db:methodname>flags</db:methodname>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">Qt::ItemFlags flags(const QModelIndex &amp;index) const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstracttablemodel.xml#flags" role="function">QAbstractTableModel::flags(const QModelIndex &amp;index) const</db:link>.</db:para>
</db:section>
<db:section xml:id="headerData">
<db:title>[override virtual] QVariant QSqlTableModel::headerData(int <db:emphasis>section</db:emphasis>, Qt::Orientation <db:emphasis>orientation</db:emphasis>, int <db:emphasis>role</db:emphasis> = Qt::DisplayRole) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>headerData</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>section</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::Orientation</db:type>
<db:parameter>orientation</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>role</db:parameter>
<db:initializer>Qt::DisplayRole</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant headerData(int section, Qt::Orientation orientation, int role) const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qsqlquerymodel.xml#headerData" role="function">QSqlQueryModel::headerData(int section, Qt::Orientation orientation, int role) const</db:link>.</db:para>
</db:section>
<db:section xml:id="indexInQuery">
<db:title>[override virtual protected] QModelIndex QSqlTableModel::indexInQuery(const QModelIndex &amp;<db:emphasis>item</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QModelIndex</db:type>
<db:methodname>indexInQuery</db:methodname>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>item</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QModelIndex indexInQuery(const QModelIndex &amp;item) const override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qsqlquerymodel.xml#indexInQuery" role="function">QSqlQueryModel::indexInQuery(const QModelIndex &amp;item) const</db:link>.</db:para>
<db:para>Returns the index of the value in the database result set for the given <db:code role="parameter">item</db:code> in the model.</db:para>
<db:para>The return value is identical to <db:code role="parameter">item</db:code> if no columns or rows have been inserted, removed, or moved around.</db:para>
<db:para>Returns an invalid model index if <db:code role="parameter">item</db:code> is out of bounds or if <db:code role="parameter">item</db:code> does not point to a value in the result set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquerymodel.xml#indexInQuery">QSqlQueryModel::indexInQuery</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insertRecord">
<db:title>bool QSqlTableModel::insertRecord(int <db:emphasis>row</db:emphasis>, const QSqlRecord &amp;<db:emphasis>record</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>insertRecord</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QSqlRecord &amp;</db:type>
<db:parameter>record</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool insertRecord(int row, const QSqlRecord &amp;record)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts the <db:code role="parameter">record</db:code> at position <db:code role="parameter">row</db:code>. If <db:code role="parameter">row</db:code> is negative, the record will be appended to the end. Calls <db:link xlink:href="qsqltablemodel.xml#insertRows">insertRows</db:link>() and <db:link xlink:href="qsqltablemodel.xml#setRecord">setRecord</db:link>() internally.</db:para>
<db:para>Returns <db:code>true</db:code> if the record could be inserted, otherwise false.</db:para>
<db:para>Changes are submitted immediately for <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnFieldChange</db:link> and <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnRowChange</db:link>. Failure does not leave a new row in the model.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#insertRows">insertRows</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#removeRows">removeRows</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#setRecord">setRecord</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insertRowIntoTable">
<db:title>[virtual protected] bool QSqlTableModel::insertRowIntoTable(const QSqlRecord &amp;<db:emphasis>values</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>insertRowIntoTable</db:methodname>
<db:methodparam>
<db:type>const QSqlRecord &amp;</db:type>
<db:parameter>values</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool insertRowIntoTable(const QSqlRecord &amp;values)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts the values <db:code role="parameter">values</db:code> into the currently active database table.</db:para>
<db:para>This is a low-level method that operates directly on the database and should not be called directly. Use <db:link xlink:href="qabstractitemmodel.xml#insertRow">insertRow</db:link>() and <db:link xlink:href="qsqltablemodel.xml#setData">setData</db:link>() to insert values. The model will decide depending on its edit strategy when to modify the database.</db:para>
<db:para>Returns <db:code>true</db:code> if the values could be inserted, otherwise false. Error information can be retrieved with <db:link xlink:href="qsqlquerymodel.xml#lastError">lastError</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlquerymodel.xml#lastError">lastError</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractitemmodel.xml#insertRow">insertRow</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#insertRows">insertRows</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insertRows">
<db:title>[override virtual] bool QSqlTableModel::insertRows(int <db:emphasis>row</db:emphasis>, int <db:emphasis>count</db:emphasis>, const QModelIndex &amp;<db:emphasis>parent</db:emphasis> = QModelIndex())</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>insertRows</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>QModelIndex()</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool insertRows(int row, int count, const QModelIndex &amp;parent) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemmodel.xml#insertRows" role="function">QAbstractItemModel::insertRows(int row, int count, const QModelIndex &amp;parent)</db:link>.</db:para>
<db:para>Inserts <db:code role="parameter">count</db:code> empty rows at position <db:code role="parameter">row</db:code>. Note that <db:code role="parameter">parent</db:code> must be invalid, since this model does not support parent-child relations.</db:para>
<db:para>For edit strategies <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnFieldChange</db:link> and <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnRowChange</db:link>, only one row may be inserted at a time and the model may not contain other cached changes.</db:para>
<db:para>The <db:link xlink:href="qsqltablemodel.xml#primeInsert">primeInsert</db:link>() signal will be emitted for each new row. Connect to it if you want to initialize the new row with default values.</db:para>
<db:para>Does not submit rows, regardless of edit strategy.</db:para>
<db:para>Returns <db:code>false</db:code> if the parameters are out of bounds or the row cannot be inserted; otherwise returns <db:code>true</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#primeInsert">primeInsert</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#insertRecord">insertRecord</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isDirty">
<db:title>bool QSqlTableModel::isDirty(const QModelIndex &amp;<db:emphasis>index</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isDirty</db:methodname>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isDirty(const QModelIndex &amp;index) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the value at the index <db:code role="parameter">index</db:code> is dirty, otherwise false. Dirty values are values that were modified in the model but not yet written into the database.</db:para>
<db:para>If <db:code role="parameter">index</db:code> is invalid or points to a non-existing row, false is returned.</db:para>
</db:section>
<db:section xml:id="isDirty-1">
<db:title>[since 5.0] bool QSqlTableModel::isDirty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isDirty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isDirty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if the model contains modified values that have not been committed to the database, otherwise false.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="orderByClause">
<db:title>[virtual protected] QString QSqlTableModel::orderByClause() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>orderByClause</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString orderByClause() const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an SQL <db:code>ORDER BY</db:code> clause based on the currently set sort order.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#setSort">setSort</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#selectStatement">selectStatement</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="primaryKey">
<db:title>QSqlIndex QSqlTableModel::primaryKey() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSqlIndex</db:type>
<db:methodname>primaryKey</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSqlIndex primaryKey() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the primary key for the current table, or an empty <db:link xlink:href="qsqlindex.xml">QSqlIndex</db:link> if the table is not set or has no primary key.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#setTable">setTable</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#setPrimaryKey">setPrimaryKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsqldatabase.xml#primaryIndex">QSqlDatabase::primaryIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="primaryValues">
<db:title>[protected, since 5.1] QSqlRecord QSqlTableModel::primaryValues(int <db:emphasis>row</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSqlRecord</db:type>
<db:methodname>primaryValues</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSqlRecord primaryValues(int row) const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a record containing the fields represented in the primary key set to the values at <db:code role="parameter">row</db:code>. If no primary key is defined, the returned record will contain all fields.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#primaryKey">primaryKey</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="primeInsert">
<db:title>void QSqlTableModel::primeInsert(int <db:emphasis>row</db:emphasis>, QSqlRecord &amp;<db:emphasis>record</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>primeInsert</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSqlRecord &amp;</db:type>
<db:parameter>record</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void primeInsert(int row, QSqlRecord &amp;record)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted by <db:link xlink:href="qsqltablemodel.xml#insertRows">insertRows</db:link>(), when an insertion is initiated in the given <db:code role="parameter">row</db:code> of the currently active database table. The <db:code role="parameter">record</db:code> parameter can be written to (since it is a reference), for example to populate some fields with default values and set the generated flags of the fields. Do not try to edit the record via other means such as <db:link xlink:href="qsqltablemodel.xml#setData">setData</db:link>() or <db:link xlink:href="qsqltablemodel.xml#setRecord">setRecord</db:link>() while handling this signal.</db:para>
</db:section>
<db:section xml:id="record">
<db:title>QSqlRecord QSqlTableModel::record() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSqlRecord</db:type>
<db:methodname>record</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSqlRecord record() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>It returns an empty record, having only the field names. This function can be used to retrieve the field names of a record.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#setRecord">setRecord</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlrecord.xml#isEmpty">QSqlRecord::isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="record-1">
<db:title>[since 5.0] QSqlRecord QSqlTableModel::record(int <db:emphasis>row</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSqlRecord</db:type>
<db:methodname>record</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSqlRecord record(int row) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the record at <db:code role="parameter">row</db:code> in the model.</db:para>
<db:para>If <db:code role="parameter">row</db:code> is the index of a valid row, the record will be populated with values from that row.</db:para>
<db:para>If the model is not initialized, an empty record will be returned.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlrecord.xml#isEmpty">QSqlRecord::isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeColumns">
<db:title>[override virtual] bool QSqlTableModel::removeColumns(int <db:emphasis>column</db:emphasis>, int <db:emphasis>count</db:emphasis>, const QModelIndex &amp;<db:emphasis>parent</db:emphasis> = QModelIndex())</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>removeColumns</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>column</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>QModelIndex()</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool removeColumns(int column, int count, const QModelIndex &amp;parent) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qsqlquerymodel.xml#removeColumns" role="function">QSqlQueryModel::removeColumns(int column, int count, const QModelIndex &amp;parent)</db:link>.</db:para>
<db:para>Removes <db:code role="parameter">count</db:code> columns from the <db:code role="parameter">parent</db:code> model, starting at index <db:code role="parameter">column</db:code>.</db:para>
<db:para>Returns if the columns were successfully removed; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#removeRows">removeRows</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeRows">
<db:title>[override virtual] bool QSqlTableModel::removeRows(int <db:emphasis>row</db:emphasis>, int <db:emphasis>count</db:emphasis>, const QModelIndex &amp;<db:emphasis>parent</db:emphasis> = QModelIndex())</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>removeRows</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>QModelIndex()</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool removeRows(int row, int count, const QModelIndex &amp;parent) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemmodel.xml#removeRows" role="function">QAbstractItemModel::removeRows(int row, int count, const QModelIndex &amp;parent)</db:link>.</db:para>
<db:para>Removes <db:code role="parameter">count</db:code> rows starting at <db:code role="parameter">row</db:code>. Since this model does not support hierarchical structures, <db:code role="parameter">parent</db:code> must be an invalid model index.</db:para>
<db:para>When the edit strategy is <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnManualSubmit</db:link>, deletion of rows from the database is delayed until <db:link xlink:href="qsqltablemodel.xml#submitAll">submitAll</db:link>() is called.</db:para>
<db:para>For <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnFieldChange</db:link> and <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnRowChange</db:link>, only one row may be deleted at a time and only if no other row has a cached change. Deletions are submitted immediately to the database. The model retains a blank row for successfully deleted row until refreshed with <db:link xlink:href="qsqltablemodel.xml#select">select</db:link>().</db:para>
<db:para>After failed deletion, the operation is not reverted in the model. The application may resubmit or revert.</db:para>
<db:para>Inserted but not yet successfully submitted rows in the range to be removed are immediately removed from the model.</db:para>
<db:para>Before a row is deleted from the database, the <db:link xlink:href="qsqltablemodel.xml#beforeDelete">beforeDelete</db:link>() signal is emitted.</db:para>
<db:para>If row &lt; 0 or row + count &gt; <db:link xlink:href="qsqltablemodel.xml#rowCount">rowCount</db:link>(), no action is taken and false is returned. Returns <db:code>true</db:code> if all rows could be removed; otherwise returns <db:code>false</db:code>. Detailed database error information can be retrieved using <db:link xlink:href="qsqlquerymodel.xml#lastError">lastError</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#removeColumns">removeColumns</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#insertRows">insertRows</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="revert">
<db:title>[override virtual] void QSqlTableModel::revert()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>revert</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void revert() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemmodel.xml#revert" role="function">QAbstractItemModel::revert()</db:link>.</db:para>
<db:para>This reimplemented slot is called by the item delegates when the user canceled editing the current row.</db:para>
<db:para>Reverts the changes if the model's strategy is set to <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnRowChange</db:link> or <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnFieldChange</db:link>. Does nothing for the <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnManualSubmit</db:link> strategy.</db:para>
<db:para>Use <db:link xlink:href="qsqltablemodel.xml#revertAll">revertAll</db:link>() to revert all pending changes for the <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnManualSubmit</db:link> strategy or <db:link xlink:href="qsqltablemodel.xml#revertRow">revertRow</db:link>() to revert a specific row.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#submit">submit</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#submitAll">submitAll</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#revertRow">revertRow</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#revertAll">revertAll</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="revertAll">
<db:title>void QSqlTableModel::revertAll()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>revertAll</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void revertAll()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reverts all pending changes.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#revert">revert</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#revertRow">revertRow</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#submitAll">submitAll</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="revertRow">
<db:title>[virtual] void QSqlTableModel::revertRow(int <db:emphasis>row</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>revertRow</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void revertRow(int row)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reverts all changes for the specified <db:code role="parameter">row</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#revert">revert</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#revertAll">revertAll</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#submit">submit</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#submitAll">submitAll</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rowCount">
<db:title>[override virtual] int QSqlTableModel::rowCount(const QModelIndex &amp;<db:emphasis>parent</db:emphasis> = QModelIndex()) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>rowCount</db:methodname>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>QModelIndex()</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int rowCount(const QModelIndex &amp;parent) const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qsqlquerymodel.xml#rowCount" role="function">QSqlQueryModel::rowCount(const QModelIndex &amp;parent) const</db:link>.</db:para>
</db:section>
<db:section xml:id="select">
<db:title>[virtual] bool QSqlTableModel::select()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>select</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool select()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Populates the model with data from the table that was set via <db:link xlink:href="qsqltablemodel.xml#setTable">setTable</db:link>(), using the specified filter and sort condition, and returns <db:code>true</db:code> if successful; otherwise returns <db:code>false</db:code>.</db:para>
<db:note>
<db:para>Calling select() will revert any unsubmitted changes and remove any inserted columns.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#setTable">setTable</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#setFilter">setFilter</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#selectStatement">selectStatement</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="selectRow">
<db:title>[virtual, since 5.0] bool QSqlTableModel::selectRow(int <db:emphasis>row</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>selectRow</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool selectRow(int row)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Refreshes <db:code role="parameter">row</db:code> in the model with values from the database table row matching on primary key values. Without a primary key, all column values must match. If no matching row is found, the model will show an empty row.</db:para>
<db:para>Returns <db:code>true</db:code> if successful; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#select">select</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="selectStatement">
<db:title>[virtual protected] QString QSqlTableModel::selectStatement() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>selectStatement</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString selectStatement() const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the SQL <db:code>SELECT</db:code> statement used internally to populate the model. The statement includes the filter and the <db:code>ORDER BY</db:code> clause.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#filter">filter</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#orderByClause">orderByClause</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setData">
<db:title>[override virtual] bool QSqlTableModel::setData(const QModelIndex &amp;<db:emphasis>index</db:emphasis>, const QVariant &amp;<db:emphasis>value</db:emphasis>, int <db:emphasis>role</db:emphasis> = Qt::EditRole)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>setData</db:methodname>
<db:methodparam>
<db:type>const QModelIndex &amp;</db:type>
<db:parameter>index</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>role</db:parameter>
<db:initializer>Qt::EditRole</db:initializer>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setData(const QModelIndex &amp;index, const QVariant &amp;value, int role) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemmodel.xml#setData" role="function">QAbstractItemModel::setData(const QModelIndex &amp;index, const QVariant &amp;value, int role)</db:link>.</db:para>
<db:para>Sets the data for the item <db:code role="parameter">index</db:code> for the role <db:code role="parameter">role</db:code> to <db:code role="parameter">value</db:code>.</db:para>
<db:para>For edit strategy <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnFieldChange</db:link>, an index may receive a change only if no other index has a cached change. Changes are submitted immediately. However, rows that have not yet been inserted in the database may be freely changed and are not submitted automatically. Submitted changes are not reverted upon failure.</db:para>
<db:para>For <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnRowChange</db:link>, an index may receive a change only if no other row has a cached change. Changes are not submitted automatically.</db:para>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">value</db:code> is equal to the current value. However, the value will not be submitted to the database.</db:para>
<db:para>Returns <db:code>true</db:code> if the value could be set or false on error, for example if <db:code role="parameter">index</db:code> is out of bounds.</db:para>
<db:para>Returns <db:code>false</db:code> if the role is not <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::EditRole</db:link>. To set data for roles other than EditRole, either use a custom proxy model or subclass <db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#editStrategy">editStrategy</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#submit">submit</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#submitAll">submitAll</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#revertRow">revertRow</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setEditStrategy">
<db:title>[virtual] void QSqlTableModel::setEditStrategy(QSqlTableModel::EditStrategy <db:emphasis>strategy</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>setEditStrategy</db:methodname>
<db:methodparam>
<db:type>QSqlTableModel::EditStrategy</db:type>
<db:parameter>strategy</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setEditStrategy(QSqlTableModel::EditStrategy strategy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the strategy for editing values in the database to <db:code role="parameter">strategy</db:code>.</db:para>
<db:para>This will revert any pending changes.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#editStrategy">editStrategy</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#revertAll">revertAll</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFilter">
<db:title>[virtual] void QSqlTableModel::setFilter(const QString &amp;<db:emphasis>filter</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>setFilter</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>filter</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFilter(const QString &amp;filter)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the current filter to <db:code role="parameter">filter</db:code>.</db:para>
<db:para>The filter is a SQL <db:code>WHERE</db:code> clause without the keyword <db:code>WHERE</db:code> (for example, <db:code>name='Josephine')</db:code>.</db:para>
<db:para>If the model is already populated with data from a database, the model re-selects it with the new filter. Otherwise, the filter will be applied the next time <db:link xlink:href="qsqltablemodel.xml#select">select</db:link>() is called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#filter">filter</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#select">select</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#selectStatement">selectStatement</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#orderByClause">orderByClause</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPrimaryKey">
<db:title>[protected] void QSqlTableModel::setPrimaryKey(const QSqlIndex &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPrimaryKey</db:methodname>
<db:methodparam>
<db:type>const QSqlIndex &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPrimaryKey(const QSqlIndex &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Protected method that allows subclasses to set the primary key to <db:code role="parameter">key</db:code>.</db:para>
<db:para>Normally, the primary index is set automatically whenever you call <db:link xlink:href="qsqltablemodel.xml#setTable">setTable</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#primaryKey">primaryKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsqldatabase.xml#primaryIndex">QSqlDatabase::primaryIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setQuery">
<db:title>[protected] void QSqlTableModel::setQuery(const QSqlQuery &amp;<db:emphasis>query</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setQuery</db:methodname>
<db:methodparam>
<db:type>const QSqlQuery &amp;</db:type>
<db:parameter>query</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setQuery(const QSqlQuery &amp;query)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function simply calls <db:link xlink:href="qsqlquerymodel.xml#setQuery">QSqlQueryModel::setQuery</db:link>(<db:code role="parameter">query</db:code>). You should normally not call it on a <db:link xlink:href="qsqltablemodel.xml">QSqlTableModel</db:link>. Instead, use <db:link xlink:href="qsqltablemodel.xml#setTable">setTable</db:link>(), <db:link xlink:href="qsqltablemodel.xml#setSort">setSort</db:link>(), <db:link xlink:href="qsqltablemodel.xml#setFilter">setFilter</db:link>(), etc., to set up the query.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#selectStatement">selectStatement</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setRecord">
<db:title>bool QSqlTableModel::setRecord(int <db:emphasis>row</db:emphasis>, const QSqlRecord &amp;<db:emphasis>values</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>setRecord</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QSqlRecord &amp;</db:type>
<db:parameter>values</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setRecord(int row, const QSqlRecord &amp;values)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Applies <db:code role="parameter">values</db:code> to the <db:code role="parameter">row</db:code> in the model. The source and target fields are mapped by field name, not by position in the record.</db:para>
<db:para>Note that the generated flags in <db:code role="parameter">values</db:code> are preserved to determine whether the corresponding fields are used when changes are submitted to the database. By default, it is set to <db:code>true</db:code> for all fields in a <db:link xlink:href="qsqlrecord.xml">QSqlRecord</db:link>. You must set the flag to <db:code>false</db:code> using <db:link xlink:href="qsqlrecord.xml#setGenerated">setGenerated</db:link>(false) for any value in <db:code role="parameter">values</db:code>, to save changes back to the database.</db:para>
<db:para>For edit strategies <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnFieldChange</db:link> and <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnRowChange</db:link>, a row may receive a change only if no other row has a cached change. Changes are submitted immediately. Submitted changes are not reverted upon failure.</db:para>
<db:para>Returns <db:code>true</db:code> if all the values could be set; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#record">record</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#editStrategy">editStrategy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSort">
<db:title>[virtual] void QSqlTableModel::setSort(int <db:emphasis>column</db:emphasis>, Qt::SortOrder <db:emphasis>order</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>setSort</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>column</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::SortOrder</db:type>
<db:parameter>order</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSort(int column, Qt::SortOrder order)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the sort order for <db:code role="parameter">column</db:code> to <db:code role="parameter">order</db:code>. This does not affect the current data, to refresh the data using the new sort order, call <db:link xlink:href="qsqltablemodel.xml#select">select</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#sort">sort</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#select">select</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#orderByClause">orderByClause</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setTable">
<db:title>[virtual] void QSqlTableModel::setTable(const QString &amp;<db:emphasis>tableName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>setTable</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>tableName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setTable(const QString &amp;tableName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the database table on which the model operates to <db:code role="parameter">tableName</db:code>. Does not select data from the table, but fetches its field information.</db:para>
<db:para>To populate the model with the table's data, call <db:link xlink:href="qsqltablemodel.xml#select">select</db:link>().</db:para>
<db:para>Error information can be retrieved with <db:link xlink:href="qsqlquerymodel.xml#lastError">lastError</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#select">select</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#setFilter">setFilter</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquerymodel.xml#lastError">lastError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sort">
<db:title>[override virtual] void QSqlTableModel::sort(int <db:emphasis>column</db:emphasis>, Qt::SortOrder <db:emphasis>order</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>sort</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>column</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::SortOrder</db:type>
<db:parameter>order</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void sort(int column, Qt::SortOrder order) override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemmodel.xml#sort" role="function">QAbstractItemModel::sort(int column, Qt::SortOrder order)</db:link>.</db:para>
<db:para>Sorts the data by <db:code role="parameter">column</db:code> with the sort order <db:code role="parameter">order</db:code>. This will immediately select data, use <db:link xlink:href="qsqltablemodel.xml#setSort">setSort</db:link>() to set a sort order without populating the model with data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#setSort">setSort</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#select">select</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#orderByClause">orderByClause</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="submit">
<db:title>[override virtual] bool QSqlTableModel::submit()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>submit</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool submit() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qabstractitemmodel.xml#submit" role="function">QAbstractItemModel::submit()</db:link>.</db:para>
<db:para>This reimplemented slot is called by the item delegates when the user stopped editing the current row.</db:para>
<db:para>Submits the currently edited row if the model's strategy is set to <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnRowChange</db:link> or <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnFieldChange</db:link>. Does nothing for the <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnManualSubmit</db:link> strategy.</db:para>
<db:para>Use <db:link xlink:href="qsqltablemodel.xml#submitAll">submitAll</db:link>() to submit all pending changes for the <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnManualSubmit</db:link> strategy.</db:para>
<db:para>Returns <db:code>true</db:code> on success; otherwise returns <db:code>false</db:code>. Use <db:link xlink:href="qsqlquerymodel.xml#lastError">lastError</db:link>() to query detailed error information.</db:para>
<db:para>Does not automatically repopulate the model. Submitted rows are refreshed from the database on success.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#revert">revert</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#revertRow">revertRow</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#submitAll">submitAll</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#revertAll">revertAll</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquerymodel.xml#lastError">lastError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="submitAll">
<db:title>bool QSqlTableModel::submitAll()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>submitAll</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool submitAll()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Submits all pending changes and returns <db:code>true</db:code> on success. Returns <db:code>false</db:code> on error, detailed error information can be obtained with <db:link xlink:href="qsqlquerymodel.xml#lastError">lastError</db:link>().</db:para>
<db:para>In <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnManualSubmit</db:link>, on success the model will be repopulated. Any views presenting it will lose their selections.</db:para>
<db:para>Note: In <db:link xlink:href="qsqltablemodel.xml#EditStrategy-enum">OnManualSubmit</db:link> mode, already submitted changes won't be cleared from the cache when submitAll() fails. This allows transactions to be rolled back and resubmitted without losing data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqltablemodel.xml#revertAll">revertAll</db:link>()</db:member>
<db:member><db:link xlink:href="qsqlquerymodel.xml#lastError">lastError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="tableName">
<db:title>QString QSqlTableModel::tableName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>tableName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString tableName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name of the currently selected table.</db:para>
</db:section>
<db:section xml:id="updateRowInTable">
<db:title>[virtual protected] bool QSqlTableModel::updateRowInTable(int <db:emphasis>row</db:emphasis>, const QSqlRecord &amp;<db:emphasis>values</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>updateRowInTable</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QSqlRecord &amp;</db:type>
<db:parameter>values</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool updateRowInTable(int row, const QSqlRecord &amp;values)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Updates the given <db:code role="parameter">row</db:code> in the currently active database table with the specified <db:code role="parameter">values</db:code>. Returns <db:code>true</db:code> if successful; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This is a low-level method that operates directly on the database and should not be called directly. Use <db:link xlink:href="qsqltablemodel.xml#setData">setData</db:link>() to update values. The model will decide depending on its edit strategy when to modify the database.</db:para>
<db:para>Note that only values that have the generated-flag set are updated. The generated-flag can be set with <db:link xlink:href="qsqlrecord.xml#setGenerated">QSqlRecord::setGenerated</db:link>() and tested with <db:link xlink:href="qsqlrecord.xml#isGenerated">QSqlRecord::isGenerated</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsqlrecord.xml#isGenerated">QSqlRecord::isGenerated</db:link>()</db:member>
<db:member><db:link xlink:href="qsqltablemodel.xml#setData">setData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
