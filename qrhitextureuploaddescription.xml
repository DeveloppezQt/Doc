<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRhiTextureUploadDescription Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Describes a texture upload operation.</db:para>
<db:para>This class was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>rhi/qrhi.h</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui-private</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Used with <db:link xlink:href="qrhiresourceupdatebatch.xml#uploadTexture">QRhiResourceUpdateBatch::uploadTexture</db:link>(). That function has two variants: one taking a <db:link xlink:href="qimage.xml">QImage</db:link> and one taking a <db:link xlink:href="qrhitextureuploaddescription.xml">QRhiTextureUploadDescription</db:link>. The former is a convenience version, internally creating a <db:link xlink:href="qrhitextureuploaddescription.xml">QRhiTextureUploadDescription</db:link> with a single image targeting level 0 for layer 0.</db:para>
<db:para>An example of the the common, simple case of wanting to upload the contents of a <db:link xlink:href="qimage.xml">QImage</db:link> to a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> with a matching pixel size:</db:para>
<db:programlisting language="cpp">QImage image(256, 256, QImage::Format_RGBA8888);
image.fill(Qt::green); // or could use a QPainter targeting image
QRhiTexture *texture = rhi-&gt;newTexture(QRhiTexture::RGBA8, QSize(256, 256));
texture-&gt;create();
QRhiResourceUpdateBatch *u = rhi-&gt;nextResourceUpdateBatch();
u-&gt;uploadTexture(texture, image);
</db:programlisting>
<db:para>When cubemaps, pre-generated mip images, compressed textures, or partial uploads are involved, applications will have to use this class instead.</db:para>
<db:para><db:link xlink:href="qrhitextureuploaddescription.xml">QRhiTextureUploadDescription</db:link> also enables specifying batched uploads, which are useful for example when generating an atlas or glyph cache texture: multiple, partial uploads for the same subresource (meaning the same layer and level) are supported, and can be, depending on the backend and the underlying graphics API, more efficient when batched into the same <db:link xlink:href="qrhitextureuploaddescription.xml">QRhiTextureUploadDescription</db:link> as opposed to issuing individual <db:link xlink:href="qrhiresourceupdatebatch.xml#uploadTexture">uploadTexture</db:link>() commands for each of them.</db:para>
<db:note>
<db:para>Cubemaps have one layer for each of the six faces in the order +X, -X, +Y, -Y, +Z, -Z.</db:para>
</db:note>
<db:para>For example, specifying the faces of a cubemap could look like the following:</db:para>
<db:programlisting language="cpp">QImage faces[6];
// ...
QVarLengthArray&lt;QRhiTextureUploadEntry, 6&gt; entries;
for (int i = 0; i &lt; 6; ++i)
  entries.append(QRhiTextureUploadEntry(i, 0, faces[i]));
QRhiTextureUploadDescription desc;
desc.setEntries(entries.cbegin(), entries.cend());
resourceUpdates-&gt;uploadTexture(texture, desc);
</db:programlisting>
<db:para>Another example that specifies mip images for a compressed texture:</db:para>
<db:programlisting language="cpp">QList&lt;QRhiTextureUploadEntry&gt; entries;
const int mipCount = rhi-&gt;mipLevelsForSize(compressedTexture-&gt;pixelSize());
for (int level = 0; level &lt; mipCount; ++level) {
    const QByteArray compressedDataForLevel = ..
    entries.append(QRhiTextureUploadEntry(0, level, compressedDataForLevel));
}
QRhiTextureUploadDescription desc;
desc.setEntries(entries.cbegin(), entries.cend());
resourceUpdates-&gt;uploadTexture(compressedTexture, desc);
</db:programlisting>
<db:para>With partial uploads targeting the same subresource, it is recommended to batch them into a single upload request, whenever possible:</db:para>
<db:programlisting language="cpp">QRhiTextureSubresourceUploadDescription subresDesc(image);
subresDesc.setSourceSize(QSize(10, 10));
subResDesc.setDestinationTopLeft(QPoint(50, 40));
QRhiTextureUploadEntry entry(0, 0, subresDesc); // layer 0, level 0

QRhiTextureSubresourceUploadDescription subresDesc2(image);
subresDesc2.setSourceSize(QSize(30, 40));
subResDesc2.setDestinationTopLeft(QPoint(100, 200));
QRhiTextureUploadEntry entry2(0, 0, subresDesc2); // layer 0, level 0, i.e. same subresource

QRhiTextureUploadDescription desc({ entry, entry2});
resourceUpdates-&gt;uploadTexture(texture, desc);
</db:programlisting>
<db:note>
<db:para>This is a RHI API with limited compatibility guarantees, see <db:link xlink:href="qrhi.xml">QRhi</db:link> for details.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QRhiTextureUploadDescription">
<db:title>QRhiTextureUploadDescription::QRhiTextureUploadDescription(const QRhiTextureUploadEntry &amp;<db:emphasis>entry</db:emphasis>)</db:title>
<db:para>Constructs a texture upload description with a single subresource upload described by <db:code role="parameter">entry</db:code>.</db:para>
</db:section>
<db:section xml:id="QRhiTextureUploadDescription-1">
<db:title>QRhiTextureUploadDescription::QRhiTextureUploadDescription(std::initializer_list&lt;QRhiTextureUploadEntry&gt; <db:emphasis>list</db:emphasis>)</db:title>
<db:para>Constructs a texture upload description with the specified <db:code role="parameter">list</db:code> of entries.</db:para>
<db:note>
<db:para><db:code role="parameter">list</db:code> can also contain multiple <db:link xlink:href="qrhitextureuploadentry.xml">QRhiTextureUploadEntry</db:link> elements with the same layer and level. This makes sense when those uploads are partial, meaning their subresource description has a source size or image smaller than the subresource dimensions, and can be more efficient than issuing separate uploadTexture()'s.</db:para>
</db:note>
</db:section>
</db:section>
</db:article>
