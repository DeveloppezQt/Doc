<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QVector Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QVector</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.15.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qvector.xml">QVector</db:link> class is a template class that provides a dynamic array.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QVector</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qpolygon.xml" xlink:role="class">QPolygon</db:link>, <db:link xlink:href="qpolygonf.xml" xlink:role="class">QPolygonF</db:link>, <db:link xlink:href="qstack.xml" xlink:role="class">QStack</db:link>, <db:link xlink:href="qvulkaninfovector.xml" xlink:role="class">QVulkanInfoVector</db:link>, and <db:link xlink:href="qxmlstreamattributes.xml" xlink:role="class">QXmlStreamAttributes</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QVector is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores its items in adjacent memory locations and provides fast index-based access.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, QLinkedList&lt;T&gt;, <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt;, and <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>&lt;T&gt; provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> should be your default first choice. <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; will usually give better performance than <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, because <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; always stores its items sequentially in memory, where <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; will allocate its items on the heap unless <db:code>sizeof(T) &lt;= sizeof(void*)</db:code> and T has been declared to be either a <db:code>Q_MOVABLE_TYPE</db:code> or a <db:code>Q_PRIMITIVE_TYPE</db:code> using <db:link xlink:href="qtglobal.xml#Q_DECLARE_TYPEINFO">Q_DECLARE_TYPEINFO</db:link>. See the <db:link xlink:href="http://marcmutz.wordpress.com/effective-qt/containers/#containers-qlist">Pros and Cons of Using QList</db:link> for an explanation.</db:para>
</db:listitem>
<db:listitem>
<db:para>However, <db:link xlink:href="qlist.xml">QList</db:link> is used throughout the Qt APIs for passing parameters and for returning values. Use <db:link xlink:href="qlist.xml">QList</db:link> to interface with those APIs.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you need a real linked list, which guarantees <db:link xlink:href="containers.xml#algorithmic-complexity">constant time</db:link> insertions mid-list and uses iterators to items rather than indexes, use QLinkedList.</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> and <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> both guarantee C-compatible array layout. <db:link xlink:href="qlist.xml">QList</db:link> does not. This might be important if your application must interface with a C API.</db:para>
</db:note>
<db:note>
<db:para>Iterators into a QLinkedList and references into heap-allocating QLists remain valid as long as the referenced items remain in the container. This is not true for iterators and references into a <db:link xlink:href="qvector.xml">QVector</db:link> and non-heap-allocating QLists.</db:para>
</db:note>
<db:para>Here's an example of a <db:link xlink:href="qvector.xml">QVector</db:link> that stores integers and a <db:link xlink:href="qvector.xml">QVector</db:link> that stores <db:link xlink:href="qstring.xml">QString</db:link> values:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;int&amp;gt; integerVector;
QVector&amp;lt;QString&amp;gt; stringVector;
</db:programlisting>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> stores its items in a vector (array). Typically, vectors are created with an initial size. For example, the following code constructs a <db:link xlink:href="qvector.xml">QVector</db:link> with 200 elements:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;QString&amp;gt; vector(200);
</db:programlisting>
<db:para>The elements are automatically initialized with a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;QString&amp;gt; vector(200, &quot;Pass&quot;);
</db:programlisting>
<db:para>You can also call <db:link xlink:href="qvector.xml#fill">fill</db:link>() at any time to fill the vector with a value.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const vectors, operator[]() returns a reference to the item that can be used on the left side of an assignment:</db:para>
<db:programlisting language="cpp">if (vector[0] == &quot;Liz&quot;)
    vector[0] = &quot;Elizabeth&quot;;
</db:programlisting>
<db:para>For read-only access, an alternative syntax is to use <db:link xlink:href="qvector.xml#at">at</db:link>():</db:para>
<db:programlisting language="cpp">for (int i = 0; i &amp;lt; vector.size(); ++i) {
    if (vector.at(i) == &quot;Alfonso&quot;)
        cout &amp;lt;&amp;lt; &quot;Found Alfonso at position &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; Qt::endl;
}
</db:programlisting>
<db:para><db:link xlink:href="qvector.xml#at">at</db:link>() can be faster than operator[](), because it never causes a <db:link xlink:href="implicit-sharing.xml#deep-copy">deep copy</db:link> to occur.</db:para>
<db:para>Another way to access the data stored in a <db:link xlink:href="qvector.xml">QVector</db:link> is to call <db:link xlink:href="qvector.xml#data">data</db:link>(). The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a <db:link xlink:href="qvector.xml">QVector</db:link> to a function that accepts a plain C++ array.</db:para>
<db:para>If you want to find all occurrences of a particular value in a vector, use <db:link xlink:href="qvector.xml#indexOf">indexOf</db:link>() or <db:link xlink:href="qvector.xml#lastIndexOf">lastIndexOf</db:link>(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:</db:para>
<db:programlisting language="cpp">int i = vector.indexOf(&quot;Harumi&quot;);
if (i != -1)
    cout &amp;lt;&amp;lt; &quot;First occurrence of Harumi is at position &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; Qt::endl;
</db:programlisting>
<db:para>If you simply want to check whether a vector contains a particular value, use <db:link xlink:href="qvector.xml#contains">contains</db:link>(). If you want to find out how many times a particular value occurs in the vector, use <db:link xlink:href="qvector.xml#count-1">count</db:link>().</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> provides these basic functions to add, move, and remove items: <db:link xlink:href="qvector.xml#insert">insert</db:link>(), <db:link xlink:href="qvector.xml#replace">replace</db:link>(), <db:link xlink:href="qvector.xml#remove">remove</db:link>(), <db:link xlink:href="qvector.xml#prepend">prepend</db:link>(), <db:link xlink:href="qvector.xml#append">append</db:link>(). With the exception of <db:link xlink:href="qvector.xml#append">append</db:link>() and <db:link xlink:href="qvector.xml#replace">replace</db:link>(), these functions can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use <db:link xlink:href="qlist.xml">QList</db:link> or QLinkedList instead.</db:para>
<db:para>Unlike plain C++ arrays, QVectors can be resized at any time by calling <db:link xlink:href="qvector.xml#resize">resize</db:link>(). If the new size is larger than the old size, <db:link xlink:href="qvector.xml">QVector</db:link> might need to reallocate the whole vector. <db:link xlink:href="qvector.xml">QVector</db:link> tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.</db:para>
<db:para>If you know in advance approximately how many items the <db:link xlink:href="qvector.xml">QVector</db:link> will contain, you can call <db:link xlink:href="qvector.xml#reserve">reserve</db:link>(), asking <db:link xlink:href="qvector.xml">QVector</db:link> to preallocate a certain amount of memory. You can also call <db:link xlink:href="qvector.xml#capacity">capacity</db:link>() to find out how much memory <db:link xlink:href="qvector.xml">QVector</db:link> actually allocated.</db:para>
<db:para>Note that using non-const operators and functions can cause <db:link xlink:href="qvector.xml">QVector</db:link> to do a deep copy of the data. This is due to <db:link xlink:href="implicit-sharing.xml">implicit sharing</db:link>.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link>'s value type must be an <db:link xlink:href="containers.xml#assignable-data-type">assignable data type</db:link>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> as a value; instead, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> *. A few functions have additional requirements; for example, <db:link xlink:href="qvector.xml#indexOf">indexOf</db:link>() and <db:link xlink:href="qvector.xml#lastIndexOf">lastIndexOf</db:link>() expect the value type to support <db:code>operator==()</db:code>. These requirements are documented on a per-function basis.</db:para>
<db:para>Like the other container classes, <db:link xlink:href="qvector.xml">QVector</db:link> provides <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qvectoriterator.xml">QVectorIterator</db:link> and <db:link xlink:href="qmutablevectoriterator.xml">QMutableVectorIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qvector.xml#const_iterator-typedef">QVector::const_iterator</db:link> and <db:link xlink:href="qvector.xml#iterator-typedef">QVector::iterator</db:link>). In practice, these are rarely used, because you can use indexes into the <db:link xlink:href="qvector.xml">QVector</db:link>.</db:para>
<db:para>In addition to <db:link xlink:href="qvector.xml">QVector</db:link>, Qt also provides <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>, a very low-level class with little functionality that is optimized for speed.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> does <db:emphasis>not</db:emphasis> support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.</db:para>
<db:section xml:id="more-information-on-using-qt-containers">
<db:title>More Information on Using Qt Containers</db:title>
<db:para>For a detailed discussion comparing Qt containers with each other and with STL containers, see <db:link xlink:href="http://marcmutz.wordpress.com/effective-qt/containers/">Understand the Qt Containers</db:link>.</db:para>
</db:section>
<db:section xml:id="maximum-size-and-out-of-memory-conditions">
<db:title>Maximum size and out-of-memory conditions</db:title>
<db:para>The current version of <db:link xlink:href="qvector.xml">QVector</db:link> is limited to just under 2 GB (2^31 bytes) in size. The exact value is architecture-dependent, since it depends on the overhead required for managing the data block, but is no more than 32 bytes. The number of elements that can be stored in a <db:link xlink:href="qvector.xml">QVector</db:link> is that size divided by the size of each element.</db:para>
<db:para>In case memory allocation fails, <db:link xlink:href="qvector.xml">QVector</db:link> will use the <db:link xlink:href="qtglobal.xml#Q_CHECK_PTR">Q_CHECK_PTR</db:link> macro, which will throw a <db:code>std::bad_alloc</db:code> exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.</db:para>
<db:para>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the Qt API.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvectoriterator.xml">QVectorIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablevectoriterator.xml">QMutableVectorIterator</db:link></db:member>
<db:member><db:link xlink:href="qlist.xml">QList</db:link></db:member>
<db:member><db:link xlink:href="qlinkedlist.xml" role="deprecated">QLinkedList</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QVector::ConstIterator</db:title>
<db:typedefsynopsis>
<db:typedefname>ConstIterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qvector.xml#const_iterator-typedef">QVector::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedefx">
<db:title>QVector::Iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>Iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qvector.xml#iterator-typedef">QVector::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="const_iterator-typedef">
<db:title>QVector::const_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>const_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The QVector::const_iterator typedef provides an STL-style const iterator for <db:link xlink:href="qvector.xml">QVector</db:link> and <db:link xlink:href="qstack.xml">QStack</db:link>.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> provides both <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> and <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link>. The STL-style const iterator is simply a typedef for &quot;const T *&quot; (pointer to const T).</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#constBegin">QVector::constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#constEnd">QVector::constEnd</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#iterator-typedef">QVector::iterator</db:link></db:member>
<db:member><db:link xlink:href="qvectoriterator.xml">QVectorIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="const_pointer-typedef">
<db:title>QVector::const_pointer</db:title>
<db:typedefsynopsis>
<db:typedefname>const_pointer</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for const T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>QVector::const_reference</db:title>
<db:typedefsynopsis>
<db:typedefname>const_reference</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reverse_iterator-typedef">
<db:title>[since 5.6] QVector::const_reverse_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>const_reverse_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The QVector::const_reverse_iterator typedef provides an STL-style const reverse iterator for <db:link xlink:href="qvector.xml">QVector</db:link>.</db:para>
<db:para>It is simply a typedef for <db:code>std::reverse_iterator&lt;const T*&gt;</db:code>.</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#rbegin">QVector::rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#rend">QVector::rend</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#reverse_iterator-typedef">QVector::reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qvector.xml#const_iterator-typedef">QVector::const_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>QVector::difference_type</db:title>
<db:typedefsynopsis>
<db:typedefname>difference_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="iterator-typedef">
<db:title>QVector::iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The QVector::iterator typedef provides an STL-style non-const iterator for <db:link xlink:href="qvector.xml">QVector</db:link> and <db:link xlink:href="qstack.xml">QStack</db:link>.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> provides both <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> and <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link>. The STL-style non-const iterator is simply a typedef for &quot;T *&quot; (pointer to T).</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#begin">QVector::begin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#end">QVector::end</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#const_iterator-typedef">QVector::const_iterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablevectoriterator.xml">QMutableVectorIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pointer-typedef">
<db:title>QVector::pointer</db:title>
<db:typedefsynopsis>
<db:typedefname>pointer</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>QVector::reference</db:title>
<db:typedefsynopsis>
<db:typedefname>reference</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reverse_iterator-typedef">
<db:title>[since 5.6] QVector::reverse_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>reverse_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The QVector::reverse_iterator typedef provides an STL-style non-const reverse iterator for <db:link xlink:href="qvector.xml">QVector</db:link>.</db:para>
<db:para>It is simply a typedef for <db:code>std::reverse_iterator&lt;T*&gt;</db:code>.</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#rbegin">QVector::rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#rend">QVector::rend</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#const_reverse_iterator-typedef">QVector::const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qvector.xml#iterator-typedef">QVector::iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>QVector::size_type</db:title>
<db:typedefsynopsis>
<db:typedefname>size_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>QVector::value_type</db:title>
<db:typedefsynopsis>
<db:typedefname>value_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="prepend">
<db:title>void QVector::prepend(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="prepend-1">void QVector::prepend(const T &amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Inserts <db:code role="parameter">value</db:code> at the beginning of the vector.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;QString&amp;gt; vector;
vector.prepend(&quot;one&quot;);
vector.prepend(&quot;two&quot;);
vector.prepend(&quot;three&quot;);
// vector: [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]
</db:programlisting>
<db:para>This is the same as vector.insert(0, <db:code role="parameter">value</db:code>).</db:para>
<db:para>For large vectors, this operation can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast <db:link xlink:href="qvector.xml#prepend">prepend</db:link>() function, use <db:link xlink:href="qlist.xml">QList</db:link> or QLinkedList instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert">
<db:title>void QVector::insert(int <db:emphasis>i</db:emphasis>, T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="insert-1">void QVector::insert(int <db:emphasis>i</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Inserts <db:code role="parameter">value</db:code> at index position <db:code role="parameter">i</db:code> in the vector. If <db:code role="parameter">i</db:code> is 0, the value is prepended to the vector. If <db:code role="parameter">i</db:code> is <db:link xlink:href="qvector.xml#size">size</db:link>(), the value is appended to the vector.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;QString&amp;gt; vector;
vector &amp;lt;&amp;lt; &quot;alpha&quot; &amp;lt;&amp;lt; &quot;beta&quot; &amp;lt;&amp;lt; &quot;delta&quot;;
vector.insert(2, &quot;gamma&quot;);
// vector: [&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;]
</db:programlisting>
<db:para>For large vectors, this operation can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because it requires moving all the items at indexes <db:code role="parameter">i</db:code> and above by one position further in memory. If you want a container class that provides a fast <db:link xlink:href="qvector.xml#insert">insert</db:link>() function, use QLinkedList instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-5">
<db:title>QVector::iterator QVector::insert(QVector::iterator <db:emphasis>before</db:emphasis>, T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="insert-4">QVector::iterator QVector::insert(QVector::iterator <db:emphasis>before</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts <db:code role="parameter">value</db:code> in front of the item pointed to by the iterator <db:code role="parameter">before</db:code>. Returns an iterator pointing at the inserted item.</db:para>
</db:section>
<db:section xml:id="push_front">
<db:title>void QVector::push_front(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="push_front-1">void QVector::push_front(const T &amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>This function is provided for STL compatibility. It is equivalent to prepend(<db:code role="parameter">value</db:code>).</db:para>
</db:section>
<db:section xml:id="QVector">
<db:title>QVector::QVector()</db:title>
<db:constructorsynopsis>
<db:methodname>QVector</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty vector.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVector-1">
<db:title>[explicit] QVector::QVector(int <db:emphasis>size</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVector</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector(int size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a vector with an initial size of <db:code role="parameter">size</db:code> elements.</db:para>
<db:para>The elements are initialized with a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVector-2">
<db:title>QVector::QVector(int <db:emphasis>size</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVector</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector(int size, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a vector with an initial size of <db:code role="parameter">size</db:code> elements. Each element is initialized with <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#resize">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#fill">fill</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVector-3">
<db:title>QVector::QVector(const QVector&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVector</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector(const QVector&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:para>This operation takes <db:link xlink:href="containers.xml#algorithmic-complexity">constant time</db:link>, because <db:link xlink:href="qvector.xml">QVector</db:link> is <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>. This makes returning a <db:link xlink:href="qvector.xml">QVector</db:link> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <db:link xlink:href="containers.xml#algorithmic-complexity">linear time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVector-4">
<db:title>[since 5.2] QVector::QVector(QVector&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVector</db:methodname>
<db:methodparam>
<db:type>QVector&lt;T&gt; &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector(QVector&lt;T&gt; &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Move-constructs a <db:link xlink:href="qvector.xml">QVector</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="QVector-5">
<db:title>[since 4.8] QVector::QVector(std::initializer_list&lt;T&gt; <db:emphasis>args</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVector</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;T&gt;</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector(std::initializer_list&lt;T&gt; args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a vector from the std::initializer_list given by <db:code role="parameter">args</db:code>.</db:para>
<db:para>This constructor is only enabled if the compiler supports C++11 initializer lists.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
</db:section>
<db:section xml:id="QVector-6">
<db:title>[since 5.14] QVector::QVector(InputIterator <db:emphasis>first</db:emphasis>, InputIterator <db:emphasis>last</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVector</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>first</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>last</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector(InputIterator first, InputIterator last)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a vector with the contents in the iterator range [<db:code role="parameter">first</db:code>, <db:code role="parameter">last</db:code>).</db:para>
<db:para>The value type of <db:code>InputIterator</db:code> must be convertible to <db:code>T</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
</db:section>
<db:section xml:id="dtor.QVector">
<db:title>QVector::~QVector()</db:title>
<db:destructorsynopsis>
<db:methodname>~QVector</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QVector()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the vector.</db:para>
</db:section>
<db:section xml:id="append">
<db:title>void QVector::append(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts <db:code role="parameter">value</db:code> at the end of the vector.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;QString&amp;gt; vector;
vector.append(&quot;one&quot;);
vector.append(&quot;two&quot;);
QString three = &quot;three&quot;;
vector.append(three);
// vector: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
// three: &quot;three&quot;
</db:programlisting>
<db:para>This is the same as calling resize(<db:link xlink:href="qvector.xml#size">size</db:link>() + 1) and assigning <db:code role="parameter">value</db:code> to the new last element in the vector.</db:para>
<db:para>This operation is relatively fast, because <db:link xlink:href="qvector.xml">QVector</db:link> typically allocates more memory than necessary, so it can grow without reallocating the entire vector each time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-1">
<db:title>[since 5.6] void QVector::append(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>T &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(T &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;QString&amp;gt; vector;
vector.append(&quot;one&quot;);
vector.append(&quot;two&quot;);
QString three = &quot;three&quot;;
vector.append(std::move(three));
// vector: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
// three: &quot;&quot;
</db:programlisting>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="append-2">
<db:title>[since 5.5] void QVector::append(const QVector&lt;T&gt; &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(const QVector&lt;T&gt; &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the items of the <db:code role="parameter">value</db:code> vector to this vector.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="at">
<db:title>const T &amp;QVector::at(int <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>at</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; at(int i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the item at index position <db:code role="parameter">i</db:code> in the vector.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the vector (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qvector.xml#size">size</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#value">value</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="back">
<db:title>QVector::reference QVector::back()</db:title>
<db:methodsynopsis>
<db:type>QVector::reference</db:type>
<db:methodname>back</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::reference back()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qvector.xml#last">last</db:link>().</db:para>
</db:section>
<db:section xml:id="back-1">
<db:title>QVector::const_reference QVector::back() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector::const_reference</db:type>
<db:methodname>back</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::const_reference back() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QVector::iterator QVector::begin()</db:title>
<db:methodsynopsis>
<db:type>QVector::iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::iterator begin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the vector.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>QVector::const_iterator QVector::begin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector::const_iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::const_iterator begin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="capacity">
<db:title>int QVector::capacity() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>capacity</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int capacity() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum number of items that can be stored in the vector without forcing a reallocation.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qvector.xml">QVector</db:link>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call <db:link xlink:href="qvector.xml#size">size</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>[since 5.0] QVector::const_iterator QVector::cbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector::const_iterator</db:type>
<db:methodname>cbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::const_iterator cbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the vector.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[since 5.0] QVector::const_iterator QVector::cend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector::const_iterator</db:type>
<db:methodname>cend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::const_iterator cend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the vector.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QVector::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all the elements from the vector.</db:para>
<db:note>
<db:para>Until Qt 5.6, this also released the memory used by the vector. From Qt 5.7, the capacity is preserved. To shed all capacity, swap with a default-constructed vector:</db:para>
</db:note>
<db:programlisting language="cpp">QVector&amp;lt;T&amp;gt; v ...;
QVector&amp;lt;T&amp;gt;().swap(v);
Q_ASSERT(v.capacity() == 0);
</db:programlisting>
<db:para>or call <db:link xlink:href="qvector.xml#squeeze">squeeze</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>QVector::const_iterator QVector::constBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector::const_iterator</db:type>
<db:methodname>constBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::const_iterator constBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the vector.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constData">
<db:title>const T *QVector::constData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T *</db:type>
<db:methodname>constData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const T * constData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const pointer to the data stored in the vector. The pointer can be used to access the items in the vector. The pointer remains valid as long as the vector isn't reallocated.</db:para>
<db:para>This function is mostly useful to pass a vector to a function that accepts a plain C++ array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QVector::const_iterator QVector::constEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector::const_iterator</db:type>
<db:methodname>constEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::const_iterator constEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the vector.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFirst">
<db:title>[since 5.6] const T &amp;QVector::constFirst() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>constFirst</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; constFirst() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const reference to the first item in the vector. This function assumes that the vector isn't empty.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#constLast">constLast</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#first">first</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constLast">
<db:title>[since 5.6] const T &amp;QVector::constLast() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>constLast</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; constLast() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const reference to the last item in the vector. This function assumes that the vector isn't empty.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#constFirst">constFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#last">last</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>bool QVector::contains(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the vector contains an occurrence of <db:code role="parameter">value</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#count-1">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>int QVector::count(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>count</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int count(const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of occurrences of <db:code role="parameter">value</db:code> in the vector.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#indexOf">indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count-1">
<db:title>int QVector::count() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>count</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int count() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qvector.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="crbegin">
<db:title>[since 5.6] QVector::const_reverse_iterator QVector::crbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector::const_reverse_iterator</db:type>
<db:methodname>crbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::const_reverse_iterator crbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first item in the vector, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="crend">
<db:title>[since 5.6] QVector::const_reverse_iterator QVector::crend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector::const_reverse_iterator</db:type>
<db:methodname>crend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::const_reverse_iterator crend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to one past the last item in the vector, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>T *QVector::data()</db:title>
<db:methodsynopsis>
<db:type>T *</db:type>
<db:methodname>data</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T * data()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the data stored in the vector. The pointer can be used to access and modify the items in the vector.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;int&amp;gt; vector(10);
int *data = vector.data();
for (int i = 0; i &amp;lt; 10; ++i)
    data[i] = 2 * i;
</db:programlisting>
<db:para>The pointer remains valid as long as the vector isn't reallocated.</db:para>
<db:para>This function is mostly useful to pass a vector to a function that accepts a plain C++ array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#constData">constData</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data-1">
<db:title>const T *QVector::data() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T *</db:type>
<db:methodname>data</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T * data() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="empty">
<db:title>bool QVector::empty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>empty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool empty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>(), returning <db:code>true</db:code> if the vector is empty; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="end">
<db:title>QVector::iterator QVector::end()</db:title>
<db:methodsynopsis>
<db:type>QVector::iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::iterator end()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the vector.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>QVector::const_iterator QVector::end() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector::const_iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::const_iterator end() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="endsWith">
<db:title>[since 4.5] bool QVector::endsWith(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>endsWith</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool endsWith(const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this vector is not empty and its last item is equal to <db:code role="parameter">value</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#last">last</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase">
<db:title>QVector::iterator QVector::erase(QVector::iterator <db:emphasis>pos</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVector::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QVector::iterator</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::iterator erase(QVector::iterator pos)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the item pointed to by the iterator <db:code role="parameter">pos</db:code> from the vector, and returns an iterator to the next item in the vector (which may be <db:link xlink:href="qvector.xml#end">end</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase-1">
<db:title>QVector::iterator QVector::erase(QVector::iterator <db:emphasis>begin</db:emphasis>, QVector::iterator <db:emphasis>end</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVector::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QVector::iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QVector::iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::iterator erase(QVector::iterator begin, QVector::iterator end)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Removes all the items from <db:code role="parameter">begin</db:code> up to (but not including) <db:code role="parameter">end</db:code>. Returns an iterator to the same item that <db:code role="parameter">end</db:code> referred to before the call.</db:para>
</db:section>
<db:section xml:id="fill">
<db:title>QVector&lt;T&gt; &amp;QVector::fill(const T &amp;<db:emphasis>value</db:emphasis>, int <db:emphasis>size</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:type>QVector&lt;T&gt; &amp;</db:type>
<db:methodname>fill</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>size</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; &amp; fill(const T &amp;value, int size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">value</db:code> to all items in the vector. If <db:code role="parameter">size</db:code> is different from -1 (the default), the vector is resized to size <db:code role="parameter">size</db:code> beforehand.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;QString&amp;gt; vector(3);
vector.fill(&quot;Yes&quot;);
// vector: [&quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;]

vector.fill(&quot;oh&quot;, 5);
// vector: [&quot;oh&quot;, &quot;oh&quot;, &quot;oh&quot;, &quot;oh&quot;, &quot;oh&quot;]
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first">
<db:title>T &amp;QVector::first()</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>first</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; first()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a reference to the first item in the vector. This function assumes that the vector isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#constFirst">constFirst</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first-1">
<db:title>const T &amp;QVector::first() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>first</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; first() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="fromList">
<db:title>[static] QVector&lt;T&gt; QVector::fromList(const QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QVector&lt;T&gt;</db:type>
<db:methodname>fromList</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; fromList(const QList&lt;T&gt; &amp;list)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qvector.xml">QVector</db:link> object with the data contained in <db:code role="parameter">list</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QStringList list;
list &amp;lt;&amp;lt; &quot;Sven&quot; &amp;lt;&amp;lt; &quot;Kim&quot; &amp;lt;&amp;lt; &quot;Ola&quot;;

QVector&amp;lt;QString&amp;gt; vect = QVector&amp;lt;QString&amp;gt;::fromList(list);
// vect: [&quot;Sven&quot;, &quot;Kim&quot;, &quot;Ola&quot;]
</db:programlisting>
<db:note>
<db:para>Since Qt 5.14, range constructors are available for Qt's generic <db:link xlink:href="containers.xml">container classes</db:link> and should be used in place of this method.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#toList">toList</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#toVector">QList::toVector</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromStdVector">
<db:title>[static] QVector&lt;T&gt; QVector::fromStdVector(const std::vector&lt;T&gt; &amp;<db:emphasis>vector</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QVector&lt;T&gt;</db:type>
<db:methodname>fromStdVector</db:methodname>
<db:methodparam>
<db:type>const std::vector&lt;T&gt; &amp;</db:type>
<db:parameter>vector</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; fromStdVector(const std::vector&lt;T&gt; &amp;vector)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qvector.xml">QVector</db:link> object with the data contained in <db:code role="parameter">vector</db:code>. The order of the elements in the <db:link xlink:href="qvector.xml">QVector</db:link> is the same as in <db:code role="parameter">vector</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">std::vector&amp;lt;double&amp;gt; stdvector;
vector.push_back(1.2);
vector.push_back(0.5);
vector.push_back(3.14);

QVector&amp;lt;double&amp;gt; vector = QVector&amp;lt;double&amp;gt;::fromStdVector(stdvector);
</db:programlisting>
<db:note>
<db:para>Since Qt 5.14, range constructors are available for Qt's generic <db:link xlink:href="containers.xml">container classes</db:link> and should be used in place of this method.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#toStdVector">toStdVector</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#fromStdList">QList::fromStdList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="front">
<db:title>T &amp;QVector::front()</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>front</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; front()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qvector.xml#first">first</db:link>().</db:para>
</db:section>
<db:section xml:id="front-1">
<db:title>QVector::const_reference QVector::front() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector::const_reference</db:type>
<db:methodname>front</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::const_reference front() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="indexOf">
<db:title>int QVector::indexOf(const T &amp;<db:emphasis>value</db:emphasis>, int <db:emphasis>from</db:emphasis> = 0) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>indexOf</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>from</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int indexOf(const T &amp;value, int from) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the index position of the first occurrence of <db:code role="parameter">value</db:code> in the vector, searching forward from index position <db:code role="parameter">from</db:code>. Returns -1 if no item matched.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;QString&amp;gt; vector;
vector &amp;lt;&amp;lt; &quot;A&quot; &amp;lt;&amp;lt; &quot;B&quot; &amp;lt;&amp;lt; &quot;C&quot; &amp;lt;&amp;lt; &quot;B&quot; &amp;lt;&amp;lt; &quot;A&quot;;
vector.indexOf(&quot;B&quot;);            // returns 1
vector.indexOf(&quot;B&quot;, 1);         // returns 1
vector.indexOf(&quot;B&quot;, 2);         // returns 3
vector.indexOf(&quot;X&quot;);            // returns -1
</db:programlisting>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#lastIndexOf">lastIndexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-2">
<db:title>void QVector::insert(int <db:emphasis>i</db:emphasis>, int <db:emphasis>count</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void insert(int i, int count, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts <db:code role="parameter">count</db:code> copies of <db:code role="parameter">value</db:code> at index position <db:code role="parameter">i</db:code> in the vector.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;double&amp;gt; vector;
vector &amp;lt;&amp;lt; 2.718 &amp;lt;&amp;lt; 1.442 &amp;lt;&amp;lt; 0.4342;
vector.insert(1, 3, 9.9);
// vector: [2.718, 9.9, 9.9, 9.9, 1.442, 0.4342]
</db:programlisting>
</db:section>
<db:section xml:id="insert-3">
<db:title>QVector::iterator QVector::insert(QVector::iterator <db:emphasis>before</db:emphasis>, int <db:emphasis>count</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVector::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>QVector::iterator</db:type>
<db:parameter>before</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::iterator insert(QVector::iterator before, int count, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts <db:code role="parameter">count</db:code> copies of <db:code role="parameter">value</db:code> in front of the item pointed to by the iterator <db:code role="parameter">before</db:code>. Returns an iterator pointing at the first of the inserted items.</db:para>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QVector::isEmpty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isEmpty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isEmpty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the vector has size 0; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last">
<db:title>T &amp;QVector::last()</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>last</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; last()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a reference to the last item in the vector. This function assumes that the vector isn't empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#constLast">constLast</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last-1">
<db:title>const T &amp;QVector::last() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>last</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; last() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="lastIndexOf">
<db:title>int QVector::lastIndexOf(const T &amp;<db:emphasis>value</db:emphasis>, int <db:emphasis>from</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>lastIndexOf</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>from</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int lastIndexOf(const T &amp;value, int from) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the index position of the last occurrence of the value <db:code role="parameter">value</db:code> in the vector, searching backward from index position <db:code role="parameter">from</db:code>. If <db:code role="parameter">from</db:code> is -1 (the default), the search starts at the last item. Returns -1 if no item matched.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QString&amp;gt; vector;
vector &amp;lt;&amp;lt; &quot;A&quot; &amp;lt;&amp;lt; &quot;B&quot; &amp;lt;&amp;lt; &quot;C&quot; &amp;lt;&amp;lt; &quot;B&quot; &amp;lt;&amp;lt; &quot;A&quot;;
vector.lastIndexOf(&quot;B&quot;);        // returns 3
vector.lastIndexOf(&quot;B&quot;, 3);     // returns 3
vector.lastIndexOf(&quot;B&quot;, 2);     // returns 1
vector.lastIndexOf(&quot;X&quot;);        // returns -1
</db:programlisting>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#indexOf">indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="length">
<db:title>[since 5.2] int QVector::length() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>length</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int length() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Same as <db:link xlink:href="qvector.xml#size">size</db:link>() and <db:link xlink:href="qvector.xml#count-1">count</db:link>().</db:para>
<db:para>Provided for compatibility with <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#count-1">count</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#length">QList::length</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mid">
<db:title>QVector&lt;T&gt; QVector::mid(int <db:emphasis>pos</db:emphasis>, int <db:emphasis>length</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector&lt;T&gt;</db:type>
<db:methodname>mid</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>length</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; mid(int pos, int length) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a sub-vector which contains elements from this vector, starting at position <db:code role="parameter">pos</db:code>. If <db:code role="parameter">length</db:code> is -1 (the default), all elements after <db:code role="parameter">pos</db:code> are included; otherwise <db:code role="parameter">length</db:code> elements (or all remaining elements if there are less than <db:code role="parameter">length</db:code> elements) are included.</db:para>
</db:section>
<db:section xml:id="move">
<db:title>[since 5.6] void QVector::move(int <db:emphasis>from</db:emphasis>, int <db:emphasis>to</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>move</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>from</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>to</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void move(int from, int to)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Moves the item at index position <db:code role="parameter">from</db:code> to index position <db:code role="parameter">to</db:code>.</db:para>
<db:para>Provided for compatibility with <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml#move">QList::move</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pop_back">
<db:title>void QVector::pop_back()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pop_back</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pop_back()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qvector.xml#removeLast">removeLast</db:link>().</db:para>
</db:section>
<db:section xml:id="pop_front">
<db:title>void QVector::pop_front()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pop_front</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pop_front()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qvector.xml#removeFirst">removeFirst</db:link>().</db:para>
</db:section>
<db:section xml:id="push_back">
<db:title>void QVector::push_back(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_back</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_back(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to append(<db:code role="parameter">value</db:code>).</db:para>
</db:section>
<db:section xml:id="push_back-1">
<db:title>[since 5.6] void QVector::push_back(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_back</db:methodname>
<db:methodparam>
<db:type>T &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_back(T &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="rbegin">
<db:title>[since 5.6] QVector::reverse_iterator QVector::rbegin()</db:title>
<db:methodsynopsis>
<db:type>QVector::reverse_iterator</db:type>
<db:methodname>rbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::reverse_iterator rbegin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first item in the vector, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rbegin-1">
<db:title>[since 5.6] QVector::const_reverse_iterator QVector::rbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector::const_reverse_iterator</db:type>
<db:methodname>rbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::const_reverse_iterator rbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="remove">
<db:title>void QVector::remove(int <db:emphasis>i</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void remove(int i)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Removes the element at index position <db:code role="parameter">i</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#replace">replace</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#fill">fill</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remove-1">
<db:title>void QVector::remove(int <db:emphasis>i</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void remove(int i, int count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Removes <db:code role="parameter">count</db:code> elements from the middle of the vector, starting at index position <db:code role="parameter">i</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#replace">replace</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#fill">fill</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeAll">
<db:title>[since 5.4] int QVector::removeAll(const T &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>removeAll</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int removeAll(const T &amp;t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements that compare equal to <db:code role="parameter">t</db:code> from the vector. Returns the number of elements removed, if any.</db:para>
<db:para>Provided for compatibility with <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#removeOne">removeOne</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#removeAll">QList::removeAll</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeAt">
<db:title>[since 5.2] void QVector::removeAt(int <db:emphasis>i</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeAt(int i)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the element at index position <db:code role="parameter">i</db:code>. Equivalent to</db:para>
<db:programlisting language="cpp">remove(i);
</db:programlisting>
<db:para>Provided for compatibility with <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#removeAt">QList::removeAt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeFirst">
<db:title>[since 5.1] void QVector::removeFirst()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeFirst</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeFirst()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the first item in the vector. Calling this function is equivalent to calling remove(0). The vector must not be empty. If the vector can be empty, call <db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#takeFirst">takeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeLast">
<db:title>[since 5.1] void QVector::removeLast()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeLast</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeLast()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the last item in the vector. Calling this function is equivalent to calling remove(<db:link xlink:href="qvector.xml#size">size</db:link>() - 1). The vector must not be empty. If the vector can be empty, call <db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#takeLast">takeLast</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#removeFirst">removeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeOne">
<db:title>[since 5.4] bool QVector::removeOne(const T &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>removeOne</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool removeOne(const T &amp;t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the first element that compares equal to <db:code role="parameter">t</db:code> from the vector. Returns whether an element was, in fact, removed.</db:para>
<db:para>Provided for compatibility with <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#removeAll">removeAll</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#removeOne">QList::removeOne</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend">
<db:title>[since 5.6] QVector::reverse_iterator QVector::rend()</db:title>
<db:methodsynopsis>
<db:type>QVector::reverse_iterator</db:type>
<db:methodname>rend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::reverse_iterator rend()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to one past the last item in the vector, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend-1">
<db:title>[since 5.6] QVector::const_reverse_iterator QVector::rend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector::const_reverse_iterator</db:type>
<db:methodname>rend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector::const_reverse_iterator rend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="replace">
<db:title>void QVector::replace(int <db:emphasis>i</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>replace</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void replace(int i, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces the item at index position <db:code role="parameter">i</db:code> with <db:code role="parameter">value</db:code>.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the vector (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qvector.xml#size">size</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#operator-5b-5d">operator[]</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reserve">
<db:title>void QVector::reserve(int <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>reserve</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void reserve(int size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to allocate memory for at least <db:code role="parameter">size</db:code> elements. If you know in advance how large the vector will be, you should call this function to prevent reallocations and memory fragmentation.</db:para>
<db:para>If <db:code role="parameter">size</db:code> is an underestimate, the worst that will happen is that the <db:link xlink:href="qvector.xml">QVector</db:link> will be a bit slower. If <db:code role="parameter">size</db:code> is an overestimate, you may have used more memory than the normal <db:link xlink:href="qvector.xml">QVector</db:link> growth strategy would have allocated—or you may have used less.</db:para>
<db:para>An alternative to reserve() is calling <db:link xlink:href="qvector.xml#resize">resize</db:link>(). Whether or not that is faster than reserve() depends on the element type, because <db:link xlink:href="qvector.xml#resize">resize</db:link>() default-constructs all elements, and requires assignment to existing entries rather than calling <db:link xlink:href="qvector.xml#append">append</db:link>(), which copy- or move-constructs. For simple types, like <db:code>int</db:code> or <db:code>double</db:code>, <db:link xlink:href="qvector.xml#resize">resize</db:link>() is typically faster, but for anything more complex, you should prefer reserve().</db:para>
<db:warning>
<db:para>If the size passed to <db:link xlink:href="qvector.xml#resize">resize</db:link>() was underestimated, you run out of allocated space and into undefined behavior. This problem does not exist with reserve(), because it treats the size as just a hint.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#squeeze">squeeze</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resize">
<db:title>void QVector::resize(int <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resize</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resize(int size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the size of the vector to <db:code role="parameter">size</db:code>. If <db:code role="parameter">size</db:code> is greater than the current size, elements are added to the end; the new elements are initialized with a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If <db:code role="parameter">size</db:code> is less than the current size, elements are removed from the end.</db:para>
<db:para>Since Qt 5.6, resize() doesn't shrink the capacity anymore. To shed excess capacity, use <db:link xlink:href="qvector.xml#squeeze">squeeze</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="shrink_to_fit">
<db:title>[since 5.10] void QVector::shrink_to_fit()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>shrink_to_fit</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void shrink_to_fit()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qvector.xml#squeeze">squeeze</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
</db:section>
<db:section xml:id="size">
<db:title>int QVector::size() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int size() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of items in the vector.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="squeeze">
<db:title>void QVector::squeeze()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>squeeze</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void squeeze()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Releases any memory not required to store the items.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qvector.xml">QVector</db:link>'s memory usage. In general, you will rarely ever need to call this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startsWith">
<db:title>[since 4.5] bool QVector::startsWith(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>startsWith</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool startsWith(const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this vector is not empty and its first item is equal to <db:code role="parameter">value</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#first">first</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>[since 4.8] void QVector::swap(QVector&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QVector&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QVector&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps vector <db:code role="parameter">other</db:code> with this vector. This operation is very fast and never fails.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
</db:section>
<db:section xml:id="swapItemsAt">
<db:title>[since 5.14] void QVector::swapItemsAt(int <db:emphasis>i</db:emphasis>, int <db:emphasis>j</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swapItemsAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>j</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swapItemsAt(int i, int j)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Exchange the item at index position <db:code role="parameter">i</db:code> with the item at index position <db:code role="parameter">j</db:code>. This function assumes that both <db:code role="parameter">i</db:code> and <db:code role="parameter">j</db:code> are at least 0 but less than <db:link xlink:href="qvector.xml#size">size</db:link>(). To avoid failure, test that both <db:code role="parameter">i</db:code> and <db:code role="parameter">j</db:code> are at least 0 and less than <db:link xlink:href="qvector.xml#size">size</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
</db:section>
<db:section xml:id="takeAt">
<db:title>[since 5.2] T QVector::takeAt(int <db:emphasis>i</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>takeAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T takeAt(int i)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the element at index position <db:code role="parameter">i</db:code> and returns it.</db:para>
<db:para>Equivalent to</db:para>
<db:programlisting language="cpp">T t = at(i);
remove(i);
return t;
</db:programlisting>
<db:para>Provided for compatibility with <db:link xlink:href="qlist.xml">QList</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#takeFirst">takeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#takeLast">takeLast</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#takeAt">QList::takeAt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="takeFirst">
<db:title>[since 5.1] T QVector::takeFirst()</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>takeFirst</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T takeFirst()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the first item in the vector and returns it. This function assumes the vector is not empty. To avoid failure, call <db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#takeLast">takeLast</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#removeFirst">removeFirst</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="takeLast">
<db:title>[since 5.1] T QVector::takeLast()</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>takeLast</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T takeLast()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the last item in the list and returns it. This function assumes the vector is not empty. To avoid failure, call <db:link xlink:href="qvector.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:para>If you don't use the return value, <db:link xlink:href="qvector.xml#removeLast">removeLast</db:link>() is more efficient.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#takeFirst">takeFirst</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#removeLast">removeLast</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toList">
<db:title>QList&lt;T&gt; QVector::toList() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>toList</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; toList() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qlist.xml">QList</db:link> object with the data contained in this <db:link xlink:href="qvector.xml">QVector</db:link>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;double&amp;gt; vect;
vect &amp;lt;&amp;lt; &quot;red&quot; &amp;lt;&amp;lt; &quot;green&quot; &amp;lt;&amp;lt; &quot;blue&quot; &amp;lt;&amp;lt; &quot;black&quot;;

QList&amp;lt;double&amp;gt; list = vect.toList();
// list: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;black&quot;]
</db:programlisting>
<db:note>
<db:para>Since Qt 5.14, range constructors are available for Qt's generic <db:link xlink:href="containers.xml">container classes</db:link> and should be used in place of this method.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#fromList">fromList</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#fromVector">QList::fromVector</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toStdVector">
<db:title>std::vector&lt;T&gt; QVector::toStdVector() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>std::vector&lt;T&gt;</db:type>
<db:methodname>toStdVector</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">std::vector&lt;T&gt; toStdVector() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a std::vector object with the data contained in this <db:link xlink:href="qvector.xml">QVector</db:link>. Example:</db:para>
<db:programlisting language="cpp">QVector&amp;lt;double&amp;gt; vector;
vector &amp;lt;&amp;lt; 1.2 &amp;lt;&amp;lt; 0.5 &amp;lt;&amp;lt; 3.14;

std::vector&amp;lt;double&amp;gt; stdvector = vector.toStdVector();
</db:programlisting>
<db:note>
<db:para>Since Qt 5.14, range constructors are available for Qt's generic <db:link xlink:href="containers.xml">container classes</db:link> and should be used in place of this method.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#fromStdVector">fromStdVector</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#toStdList">QList::toStdList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value">
<db:title>T QVector::value(int <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T value(int i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the value at index position <db:code role="parameter">i</db:code> in the vector.</db:para>
<db:para>If the index <db:code role="parameter">i</db:code> is out of bounds, the function returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If you are certain that <db:code role="parameter">i</db:code> is within bounds, you can use <db:link xlink:href="qvector.xml#at">at</db:link>() instead, which is slightly faster.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value-1">
<db:title>T QVector::value(int <db:emphasis>i</db:emphasis>, const T &amp;<db:emphasis>defaultValue</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>defaultValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T value(int i, const T &amp;defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>If the index <db:code role="parameter">i</db:code> is out of bounds, the function returns <db:code role="parameter">defaultValue</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QVector::operator!=(const QVector&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QVector&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">other</db:code> is not equal to this vector; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Two vectors are considered equal if they contain the same values in the same order.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b">
<db:title>QVector&lt;T&gt; QVector::operator+(const QVector&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector&lt;T&gt;</db:type>
<db:methodname>operator+</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; operator+(const QVector&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a vector that contains all the items in this vector followed by all the items in the <db:code role="parameter">other</db:code> vector.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq">
<db:title>QVector&lt;T&gt; &amp;QVector::operator+=(const QVector&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVector&lt;T&gt; &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; &amp; operator+=(const QVector&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends the items of the <db:code role="parameter">other</db:code> vector to this vector and returns a reference to this vector.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#operator-2b">operator+</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#append">append</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq-1">
<db:title>QVector&lt;T&gt; &amp;QVector::operator+=(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVector&lt;T&gt; &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; &amp; operator+=(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends <db:code role="parameter">value</db:code> to the vector.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq-2">
<db:title>[since 5.11] QVector&lt;T&gt; &amp;QVector::operator+=(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVector&lt;T&gt; &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>T &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; &amp; operator+=(T &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.11.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt">
<db:title>QVector&lt;T&gt; &amp;QVector::operator&lt;&lt;(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVector&lt;T&gt; &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; &amp; operator&lt;&lt;(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends <db:code role="parameter">value</db:code> to the vector and returns a reference to this vector.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt-1">
<db:title>QVector&lt;T&gt; &amp;QVector::operator&lt;&lt;(const QVector&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVector&lt;T&gt; &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; &amp; operator&lt;&lt;(const QVector&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends <db:code role="parameter">other</db:code> to the vector and returns a reference to the vector.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt-2">
<db:title>[since 5.11] QVector&lt;T&gt; &amp;QVector::operator&lt;&lt;(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVector&lt;T&gt; &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>T &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; &amp; operator&lt;&lt;(T &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.11.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QVector&lt;T&gt; &amp;QVector::operator=(const QVector&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVector&lt;T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; &amp; operator=(const QVector&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">other</db:code> to this vector and returns a reference to this vector.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[since 5.2] QVector&lt;T&gt; &amp;QVector::operator=(QVector&lt;T&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVector&lt;T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QVector&lt;T&gt; &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; &amp; operator=(QVector&lt;T&gt; &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qvector.xml">QVector</db:link> instance.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="operator-eq-2">
<db:title>[since 5.14] QVector&lt;T&gt; &amp;QVector::operator=(std::initializer_list&lt;T&gt; <db:emphasis>args</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVector&lt;T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;T&gt;</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;T&gt; &amp; operator=(std::initializer_list&lt;T&gt; args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns the collection of values in <db:code role="parameter">args</db:code> to this <db:link xlink:href="qvector.xml">QVector</db:link> instance.</db:para>
<db:para>This operator is only enabled if the compiler supports C++11 initializer lists.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QVector::operator==(const QVector&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QVector&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">other</db:code> is equal to this vector; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Two vectors are considered equal if they contain the same values in the same order.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator==()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>T &amp;QVector::operator[](int <db:emphasis>i</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; operator[](int i)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the item at index position <db:code role="parameter">i</db:code> as a modifiable reference.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the vector (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qvector.xml#size">size</db:link>()).</db:para>
<db:para>Note that using non-const operators can cause <db:link xlink:href="qvector.xml">QVector</db:link> to do a deep copy.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qvector.xml#value">value</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>const T &amp;QVector::operator[](int <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; operator[](int i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as at(<db:code role="parameter">i</db:code>).</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qHash">
<db:title>[since 5.6] uint qHash(const QVector&lt;T&gt; &amp;<db:emphasis>key</db:emphasis>, uint <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>uint</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uint qHash(const QVector&lt;T&gt; &amp;key, uint seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function requires qHash() to be overloaded for the value type <db:code>T</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="operator-lt">
<db:title>[since 5.6] bool operator&lt;(const QVector&lt;T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const QVector&lt;T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&lt;</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>lhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;(const QVector&lt;T&gt; &amp;lhs, const QVector&lt;T&gt; &amp;rhs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if vector <db:code role="parameter">lhs</db:code> is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexicographically less than</db:link> <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator&lt;()</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt-3">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QVector&lt;T&gt; &amp;<db:emphasis>vector</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>out</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>vector</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&lt;&lt;(QDataStream &amp;out, const QVector&lt;T&gt; &amp;vector)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the vector <db:code role="parameter">vector</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:para>This function requires the value type to implement <db:code>operator&lt;&lt;()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-eq">
<db:title>[since 5.6] bool operator&lt;=(const QVector&lt;T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const QVector&lt;T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&lt;=</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>lhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;=(const QVector&lt;T&gt; &amp;lhs, const QVector&lt;T&gt; &amp;rhs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if vector <db:code role="parameter">lhs</db:code> is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexicographically less than or equal to</db:link> <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator&lt;()</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="operator-gt">
<db:title>[since 5.6] bool operator&gt;(const QVector&lt;T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const QVector&lt;T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&gt;</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>lhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;(const QVector&lt;T&gt; &amp;lhs, const QVector&lt;T&gt; &amp;rhs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if vector <db:code role="parameter">lhs</db:code> is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexicographically greater than</db:link> <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator&lt;()</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq">
<db:title>[since 5.6] bool operator&gt;=(const QVector&lt;T&gt; &amp;<db:emphasis>lhs</db:emphasis>, const QVector&lt;T&gt; &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&gt;=</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>lhs</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVector&lt;T&gt; &amp;</db:type>
<db:parameter>rhs</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;=(const QVector&lt;T&gt; &amp;lhs, const QVector&lt;T&gt; &amp;rhs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if vector <db:code role="parameter">lhs</db:code> is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexicographically greater than or equal to</db:link> <db:code role="parameter">rhs</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function requires the value type to have an implementation of <db:code>operator&lt;()</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QVector&lt;T&gt; &amp;<db:emphasis>vector</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>in</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QVector&lt;T&gt; &amp;</db:type>
<db:parameter>vector</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&gt;&gt;(QDataStream &amp;in, QVector&lt;T&gt; &amp;vector)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a vector from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">vector</db:code>.</db:para>
<db:para>This function requires the value type to implement <db:code>operator&gt;&gt;()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
