<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QVector Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QVector</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qvector.xml">QVector</db:link> class is a template class that provides a dynamic array.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QVector</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qpolygon.xml" xlink:role="class">QPolygon</db:link>, <db:link xlink:href="qpolygonf.xml" xlink:role="class">QPolygonF</db:link>, <db:link xlink:href="qstack.xml" xlink:role="class">QStack</db:link>, and <db:link xlink:href="qxmlstreamattributes.xml" xlink:role="class">QXmlStreamAttributes</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QVector is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores its items in adjacent memory locations and provides fast index-based access.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>&lt;T&gt;, <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt;, and <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>&lt;T&gt; provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> should be your default first choice. <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; will usually give better performance than <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, because <db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; always stores its items sequentially in memory, where <db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt; will allocate its items on the heap unless <db:code>sizeof(T) &lt;= sizeof(void*)</db:code> and T has been declared to be either a <db:code>Q_MOVABLE_TYPE</db:code> or a <db:code>Q_PRIMITIVE_TYPE</db:code> using <db:link xlink:href="qtglobal.xml#Q_DECLARE_TYPEINFO">Q_DECLARE_TYPEINFO</db:link>. See the <db:link xlink:href="http://marcmutz.wordpress.com/effective-qt/containers/#containers-qlist">Pros and Cons of Using QList</db:link> for an explanation.</db:para>
</db:listitem>
<db:listitem>
<db:para>However, <db:link xlink:href="qlist.xml">QList</db:link> is used throughout the Qt APIs for passing parameters and for returning values. Use <db:link xlink:href="qlist.xml">QList</db:link> to interface with those APIs.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you need a real linked list, which guarantees <db:link xlink:href="containers.xml#algorithmic-complexity">constant time</db:link> insertions mid-list and uses iterators to items rather than indexes, use <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> and <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> both guarantee C-compatible array layout. <db:link xlink:href="qlist.xml">QList</db:link> does not. This might be important if your application must interface with a C API.</db:para>
</db:note>
<db:note>
<db:para>Iterators into a <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link> and references into heap-allocating QLists remain valid as long as the referenced items remain in the container. This is not true for iterators and references into a <db:link xlink:href="qvector.xml">QVector</db:link> and non-heap-allocating QLists.</db:para>
</db:note>
<db:para>Here's an example of a <db:link xlink:href="qvector.xml">QVector</db:link> that stores integers and a <db:link xlink:href="qvector.xml">QVector</db:link> that stores <db:link xlink:href="qstring.xml">QString</db:link> values:</db:para>
<db:programlisting language="cpp">QVector&lt;int&gt; integerVector;
QVector&lt;QString&gt; stringVector;
</db:programlisting>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> stores its items in a vector (array). Typically, vectors are created with an initial size. For example, the following code constructs a <db:link xlink:href="qvector.xml">QVector</db:link> with 200 elements:</db:para>
<db:programlisting language="cpp">QVector&lt;QString&gt; vector(200);
</db:programlisting>
<db:para>The elements are automatically initialized with a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:</db:para>
<db:programlisting language="cpp">QVector&lt;QString&gt; vector(200, &quot;Pass&quot;);
</db:programlisting>
<db:para>You can also call fill() at any time to fill the vector with a value.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const vectors, operator[]() returns a reference to the item that can be used on the left side of an assignment:</db:para>
<db:programlisting language="cpp">if (vector[0] == &quot;Liz&quot;)
    vector[0] = &quot;Elizabeth&quot;;
</db:programlisting>
<db:para>For read-only access, an alternative syntax is to use at():</db:para>
<db:programlisting language="cpp">for (int i = 0; i &lt; vector.size(); ++i) {
    if (vector.at(i) == &quot;Alfonso&quot;)
        cout &lt;&lt; &quot;Found Alfonso at position &quot; &lt;&lt; i &lt;&lt; endl;
}
</db:programlisting>
<db:para>at() can be faster than operator[](), because it never causes a <db:link xlink:href="implicit-sharing.xml#deep-copy">deep copy</db:link> to occur.</db:para>
<db:para>Another way to access the data stored in a <db:link xlink:href="qvector.xml">QVector</db:link> is to call data(). The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a <db:link xlink:href="qvector.xml">QVector</db:link> to a function that accepts a plain C++ array.</db:para>
<db:para>If you want to find all occurrences of a particular value in a vector, use indexOf() or lastIndexOf(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:</db:para>
<db:programlisting language="cpp">int i = vector.indexOf(&quot;Harumi&quot;);
if (i != -1)
    cout &lt;&lt; &quot;First occurrence of Harumi is at position &quot; &lt;&lt; i &lt;&lt; endl;
</db:programlisting>
<db:para>If you simply want to check whether a vector contains a particular value, use <db:link xlink:href="qml-geoshape.xml#contains">contains()</db:link>. If you want to find out how many times a particular value occurs in the vector, use count().</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> provides these basic functions to add, move, and remove items: insert(), replace(), remove(), prepend(), append(). With the exception of append() and replace(), these functions can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use <db:link xlink:href="qlist.xml">QList</db:link> or <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link> instead.</db:para>
<db:para>Unlike plain C++ arrays, QVectors can be resized at any time by calling resize(). If the new size is larger than the old size, <db:link xlink:href="qvector.xml">QVector</db:link> might need to reallocate the whole vector. <db:link xlink:href="qvector.xml">QVector</db:link> tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.</db:para>
<db:para>If you know in advance approximately how many items the <db:link xlink:href="qvector.xml">QVector</db:link> will contain, you can call reserve(), asking <db:link xlink:href="qvector.xml">QVector</db:link> to preallocate a certain amount of memory. You can also call capacity() to find out how much memory <db:link xlink:href="qvector.xml">QVector</db:link> actually allocated.</db:para>
<db:para>Note that using non-const operators and functions can cause <db:link xlink:href="qvector.xml">QVector</db:link> to do a deep copy of the data. This is due to <db:link xlink:href="implicit-sharing.xml">implicit sharing</db:link>.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link>'s value type must be an <db:link xlink:href="containers.xml#assignable-data-type">assignable data type</db:link>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> as a value; instead, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> *. A few functions have additional requirements; for example, indexOf() and lastIndexOf() expect the value type to support <db:code>operator==()</db:code>. These requirements are documented on a per-function basis.</db:para>
<db:para>Like the other container classes, <db:link xlink:href="qvector.xml">QVector</db:link> provides <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qvectoriterator.xml">QVectorIterator</db:link> and <db:link xlink:href="qmutablevectoriterator.xml">QMutableVectorIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qvector.xml#const_iterator-typedef">QVector::const_iterator</db:link> and <db:link xlink:href="qvector.xml#iterator-typedef">QVector::iterator</db:link>). In practice, these are rarely used, because you can use indexes into the <db:link xlink:href="qvector.xml">QVector</db:link>.</db:para>
<db:para>In addition to <db:link xlink:href="qvector.xml">QVector</db:link>, Qt also provides <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>, a very low-level class with little functionality that is optimized for speed.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> does <db:emphasis>not</db:emphasis> support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.</db:para>
<db:section xml:id="more-information-on-using-qt-containers">
<db:title>More Information on Using Qt Containers</db:title>
<db:para>For a detailed discussion comparing Qt containers with each other and with STL containers, see <db:link xlink:href="http://marcmutz.wordpress.com/effective-qt/containers/">Understand the Qt Containers</db:link>.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvectoriterator.xml">QVectorIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablevectoriterator.xml">QMutableVectorIterator</db:link></db:member>
<db:member><db:link xlink:href="qlist.xml">QList</db:link></db:member>
<db:member><db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QVector::ConstIterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qvector.xml#const_iterator-typedef">QVector::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedefx">
<db:title>QVector::Iterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qvector.xml#iterator-typedef">QVector::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="const_iterator-typedef">
<db:title>QVector::const_iterator</db:title>
<db:para>The QVector::const_iterator typedef provides an STL-style const iterator for <db:link xlink:href="qvector.xml">QVector</db:link> and <db:link xlink:href="qstack.xml">QStack</db:link>.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> provides both <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> and <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link>. The STL-style const iterator is simply a typedef for &quot;const T *&quot; (pointer to const T).</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QVector::constBegin()</db:link></db:member>
<db:member><db:link xlink:href="">QVector::constEnd()</db:link></db:member>
<db:member><db:link xlink:href="qvector.xml#iterator-typedef">QVector::iterator</db:link></db:member>
<db:member><db:link xlink:href="qvectoriterator.xml">QVectorIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="const_pointer-typedef">
<db:title>QVector::const_pointer</db:title>
<db:para>Typedef for const T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>QVector::const_reference</db:title>
<db:para>Typedef for T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reverse_iterator-typedef">
<db:title>[since 5.6] QVector::const_reverse_iterator</db:title>
<db:para>The QVector::const_reverse_iterator typedef provides an STL-style const reverse iterator for <db:link xlink:href="qvector.xml">QVector</db:link>.</db:para>
<db:para>It is simply a typedef for <db:code>std::reverse_iterator&lt;const T*&gt;</db:code>.</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QVector::rbegin()</db:link></db:member>
<db:member><db:link xlink:href="">QVector::rend()</db:link></db:member>
<db:member><db:link xlink:href="qvector.xml#reverse_iterator-typedef">QVector::reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qvector.xml#const_iterator-typedef">QVector::const_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>QVector::difference_type</db:title>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="iterator-typedef">
<db:title>QVector::iterator</db:title>
<db:para>The QVector::iterator typedef provides an STL-style non-const iterator for <db:link xlink:href="qvector.xml">QVector</db:link> and <db:link xlink:href="qstack.xml">QStack</db:link>.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> provides both <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> and <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link>. The STL-style non-const iterator is simply a typedef for &quot;T *&quot; (pointer to T).</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QVector::begin()</db:link></db:member>
<db:member><db:link xlink:href="">QVector::end()</db:link></db:member>
<db:member><db:link xlink:href="qvector.xml#const_iterator-typedef">QVector::const_iterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablevectoriterator.xml">QMutableVectorIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pointer-typedef">
<db:title>QVector::pointer</db:title>
<db:para>Typedef for T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>QVector::reference</db:title>
<db:para>Typedef for T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reverse_iterator-typedef">
<db:title>[since 5.6] QVector::reverse_iterator</db:title>
<db:para>The QVector::reverse_iterator typedef provides an STL-style non-const reverse iterator for <db:link xlink:href="qvector.xml">QVector</db:link>.</db:para>
<db:para>It is simply a typedef for <db:code>std::reverse_iterator&lt;T*&gt;</db:code>.</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QVector::rbegin()</db:link></db:member>
<db:member><db:link xlink:href="">QVector::rend()</db:link></db:member>
<db:member><db:link xlink:href="qvector.xml#const_reverse_iterator-typedef">QVector::const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qvector.xml#iterator-typedef">QVector::iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>QVector::size_type</db:title>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>QVector::value_type</db:title>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
</db:article>
