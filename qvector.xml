<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QVector Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QVector</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.4.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qvector.xml">QVector</db:link> class is a template class that provides a dynamic array.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QVector</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qstack.xml" xlink:role="class">QStack</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QVector is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link>&lt;T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores its items in adjacent memory locations and provides fast index-based access.</db:para>
<db:para><db:link xlink:href="qlist.xml">QList</db:link>&lt;T&gt;, <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>&lt;T&gt;, and <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>&lt;T&gt; provide similar functionality. Here's an overview:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>For most purposes, <db:link xlink:href="qlist.xml">QList</db:link> is the right class to use. Operations like prepend() and insert() are usually faster than with <db:link xlink:href="qvector.xml">QVector</db:link> because of the way <db:link xlink:href="qlist.xml">QList</db:link> stores its items in memory (see <db:link xlink:href="containers.xml#algorithmic-complexity">Algorithmic Complexity</db:link> for details), and its index-based API is more convenient than <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>'s iterator-based API. It also expands to less code in your executable.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you need a real linked list, with guarantees of <db:link xlink:href="containers.xml">constant time</db:link> insertions in the middle of the list and iterators to items rather than indexes, use <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you want the items to occupy adjacent memory positions, or if your items are larger than a pointer and you want to avoid the overhead of allocating them on the heap individually at insertion time, then use <db:link xlink:href="qvector.xml">QVector</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you want a low-level variable-size array, <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> may be sufficient.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Here's an example of a <db:link xlink:href="qvector.xml">QVector</db:link> that stores integers and a <db:link xlink:href="qvector.xml">QVector</db:link> that stores <db:link xlink:href="qstring.xml">QString</db:link> values:</db:para>
<db:programlisting language="cpp">QVector&lt;int&gt; integerVector;
QVector&lt;QString&gt; stringVector;
</db:programlisting>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> stores a vector (or array) of items. Typically, vectors are created with an initial size. For example, the following code constructs a <db:link xlink:href="qvector.xml">QVector</db:link> with 200 elements:</db:para>
<db:programlisting language="cpp">QVector&lt;QString&gt; vector(200);
</db:programlisting>
<db:para>The elements are automatically initialized with a <db:link xlink:href="containers.xml">default-constructed value</db:link>. If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:</db:para>
<db:programlisting language="cpp">QVector&lt;QString&gt; vector(200, &quot;Pass&quot;);
</db:programlisting>
<db:para>You can also call fill() at any time to fill the vector with a value.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const vectors, operator[]() returns a reference to the item that can be used on the left side of an assignment:</db:para>
<db:programlisting language="cpp">if (vector[0] == &quot;Liz&quot;)
    vector[0] = &quot;Elizabeth&quot;;
</db:programlisting>
<db:para>For read-only access, an alternative syntax is to use at():</db:para>
<db:programlisting language="cpp">for (int i = 0; i &lt; vector.size(); ++i) {
    if (vector.at(i) == &quot;Alfonso&quot;)
        cout &lt;&lt; &quot;Found Alfonso at position &quot; &lt;&lt; i &lt;&lt; endl;
}
</db:programlisting>
<db:para>at() can be faster than operator[](), because it never causes a <db:link xlink:href="implicit-sharing.xml">deep copy</db:link> to occur.</db:para>
<db:para>Another way to access the data stored in a <db:link xlink:href="qvector.xml">QVector</db:link> is to call data(). The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a <db:link xlink:href="qvector.xml">QVector</db:link> to a function that accepts a plain C++ array.</db:para>
<db:para>If you want to find all occurrences of a particular value in a vector, use indexOf() or lastIndexOf(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:</db:para>
<db:programlisting language="cpp">int i = vector.indexOf(&quot;Harumi&quot;);
if (i != -1)
    cout &lt;&lt; &quot;First occurrence of Harumi is at position &quot; &lt;&lt; i &lt;&lt; endl;
</db:programlisting>
<db:para>If you simply want to check whether a vector contains a particular value, use contains(). If you want to find out how many times a particular value occurs in the vector, use count().</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> provides these basic functions to add, move, and remove items: insert(), replace(), remove(), prepend(), append(). With the exception of append() and replace(), these functions can be slow (<db:link xlink:href="containers.xml">linear time</db:link>) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use <db:link xlink:href="qlist.xml">QList</db:link> or <db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link> instead.</db:para>
<db:para>Unlike plain C++ arrays, QVectors can be resized at any time by calling resize(). If the new size is larger than the old size, <db:link xlink:href="qvector.xml">QVector</db:link> might need to reallocate the whole vector. <db:link xlink:href="qvector.xml">QVector</db:link> tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.</db:para>
<db:para>If you know in advance approximately how many items the <db:link xlink:href="qvector.xml">QVector</db:link> will contain, you can call reserve(), asking <db:link xlink:href="qvector.xml">QVector</db:link> to preallocate a certain amount of memory. You can also call capacity() to find out how much memory <db:link xlink:href="qvector.xml">QVector</db:link> actually allocated.</db:para>
<db:para>Note that using non-const operators and functions can cause <db:link xlink:href="qvector.xml">QVector</db:link> to do a deep copy of the data. This is due to <db:link xlink:href="implicit-sharing.xml">implicit sharing</db:link>.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link>'s value type must be an <db:link xlink:href="containers.xml">assignable data type</db:link>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *. A few functions have additional requirements; for example, indexOf() and lastIndexOf() expect the value type to support operator==(). These requirements are documented on a per-function basis.</db:para>
<db:para>Like the other container classes, <db:link xlink:href="qvector.xml">QVector</db:link> provides <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qvectoriterator.xml">QVectorIterator</db:link> and <db:link xlink:href="qmutablevectoriterator.xml">QMutableVectorIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qvector.xml#const_iterator-typedef">QVector::const_iterator</db:link> and <db:link xlink:href="qvector.xml#iterator-typedef">QVector::iterator</db:link>). In practice, these are rarely used, because you can use indexes into the <db:link xlink:href="qvector.xml">QVector</db:link>.</db:para>
<db:para>In addition to <db:link xlink:href="qvector.xml">QVector</db:link>, Qt also provides <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>, a very low-level class with little functionality that is optimized for speed.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> does <db:emphasis>not</db:emphasis> support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvectoriterator.xml">QVectorIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablevectoriterator.xml">QMutableVectorIterator</db:link></db:member>
<db:member><db:link xlink:href="qlist.xml">QList</db:link></db:member>
<db:member><db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QVector::ConstIterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qvector.xml#const_iterator-typedef">QVector::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedefx">
<db:title>QVector::Iterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qvector.xml#iterator-typedef">QVector::iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="const_iterator-typedef">
<db:title>QVector::const_iterator</db:title>
<db:para>The QVector::const_iterator typedef provides an STL-style const iterator for <db:link xlink:href="qvector.xml">QVector</db:link> and <db:link xlink:href="qstack.xml">QStack</db:link>.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> provides both <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> and <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link>. The STL-style const iterator is simply a typedef for &quot;const T *&quot; (pointer to const T).</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QVector::constBegin()</db:link></db:member>
<db:member><db:link xlink:href="">QVector::constEnd()</db:link></db:member>
<db:member><db:link xlink:href="qvector.xml#iterator-typedef">QVector::iterator</db:link></db:member>
<db:member><db:link xlink:href="qvectoriterator.xml">QVectorIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="const_pointer-typedef">
<db:title>QVector::const_pointer</db:title>
<db:para>Typedef for const T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>QVector::const_reference</db:title>
<db:para>Typedef for T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>QVector::difference_type</db:title>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="iterator-typedef">
<db:title>QVector::iterator</db:title>
<db:para>The QVector::iterator typedef provides an STL-style non-const iterator for <db:link xlink:href="qvector.xml">QVector</db:link> and <db:link xlink:href="qstack.xml">QStack</db:link>.</db:para>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> provides both <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> and <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link>. The STL-style non-const iterator is simply a typedef for &quot;T *&quot; (pointer to T).</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QVector::begin()</db:link></db:member>
<db:member><db:link xlink:href="">QVector::end()</db:link></db:member>
<db:member><db:link xlink:href="qvector.xml#const_iterator-typedef">QVector::const_iterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablevectoriterator.xml">QMutableVectorIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pointer-typedef">
<db:title>QVector::pointer</db:title>
<db:para>Typedef for T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>QVector::reference</db:title>
<db:para>Typedef for T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>QVector::size_type</db:title>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>QVector::value_type</db:title>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
</db:article>
