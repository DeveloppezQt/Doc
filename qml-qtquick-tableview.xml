<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>TableView QML Type</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Provides a table view of items to display data from a model.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Import Statement</db:term>
<db:listitem>
<db:para>import QtQuick</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By:</db:term>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick-treeview.xml" xlink:role="">TreeView</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick-flickable.xml">Flickable</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>TableView is part of <db:simplelist><db:member>qtquick-views</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> has a <db:link xlink:href="qml-qtquick-tableview.xml#model-prop">model</db:link> that defines the data to be displayed, and a <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">delegate</db:link> that defines how the data should be displayed.</db:para>
<db:para><db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> inherits <db:link xlink:href="qml-qtquick-flickable.xml">Flickable</db:link>. This means that while the model can have any number of rows and columns, only a subsection of the table is usually visible inside the viewport. As soon as you flick, new rows and columns enter the viewport, while old ones exit and are removed from the viewport. The rows and columns that move out are reused for building the rows and columns that move into the viewport. As such, the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> support models of any size without affecting performance.</db:para>
<db:para>A <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> displays data from models created from built-in QML types such as ListModel and XmlListModel, which populates the first column only in a <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>. To create models with multiple columns, either use TableModel or a C++ model that inherits <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link>.</db:para>
<db:para>A <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> does not include headers by default. You can add headers using the HorizontalHeaderView and VerticalHeaderView from Qt Quick Controls.</db:para>
<db:note>
<db:para><db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will only <db:link xlink:href="qml-qtquick-tableview.xml#isRowLoaded-method">load</db:link> as many delegate items as needed to fill up the view. There is no guarantee that items outside the view will be loaded, although <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will sometimes pre-load items for optimization reasons. Hence, a <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> with zero width or height might not load any delegate items at all.</db:para>
</db:note>
<db:section xml:id="example-usage">
<db:title>Example Usage</db:title>
<db:section xml:id="c-models">
<db:title>C++ Models</db:title>
<db:para>The following example shows how to create a model from C++ with multiple columns:</db:para>
<db:programlisting language="cpp">#include &lt;qqml.h&gt;
#include &lt;QAbstractTableModel&gt;

class TableModel : public QAbstractTableModel
{
    Q_OBJECT
    QML_ELEMENT

public:
    int rowCount(const QModelIndex &amp; = QModelIndex()) const override
    {
        return 200;
    }

    int columnCount(const QModelIndex &amp; = QModelIndex()) const override
    {
        return 200;
    }

    QVariant data(const QModelIndex &amp;index, int role) const override
    {
        switch (role) {
            case Qt::DisplayRole:
                return QString(&quot;%1, %2&quot;).arg(index.column()).arg(index.row());
            default:
                break;
        }

        return QVariant();
    }

    QHash&lt;int, QByteArray&gt; roleNames() const override
    {
        return { {Qt::DisplayRole, &quot;display&quot;} };
    }
};
</db:programlisting>
<db:para>And then how to use it from QML:</db:para>
<db:programlisting language="qml">import QtQuick
import TableModel

TableView {
    anchors.fill: parent
    columnSpacing: 1
    rowSpacing: 1
    clip: true

    model: TableModel {}

    delegate: Rectangle {
        implicitWidth: 100
        implicitHeight: 50
        Text {
            text: display
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="qml-models">
<db:title>QML Models</db:title>
<db:para>For prototyping and displaying very simple data (from a web API, for example), TableModel can be used:</db:para>
<db:programlisting language="qml">import QtQuick
import Qt.labs.qmlmodels

TableView {
    anchors.fill: parent
    columnSpacing: 1
    rowSpacing: 1
    clip: true

    model: TableModel {
        TableModelColumn { display: &quot;name&quot; }
        TableModelColumn { display: &quot;color&quot; }

        rows: [
            {
                &quot;name&quot;: &quot;cat&quot;,
                &quot;color&quot;: &quot;black&quot;
            },
            {
                &quot;name&quot;: &quot;dog&quot;,
                &quot;color&quot;: &quot;brown&quot;
            },
            {
                &quot;name&quot;: &quot;bird&quot;,
                &quot;color&quot;: &quot;white&quot;
            }
        ]
    }

    delegate: Rectangle {
        implicitWidth: 100
        implicitHeight: 50
        border.width: 1

        Text {
            text: display
            anchors.centerIn: parent
        }
    }
}
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="reusing-items">
<db:title>Reusing items</db:title>
<db:para><db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> recycles delegate items by default, instead of instantiating from the <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">delegate</db:link> whenever new rows and columns are flicked into view. This approach gives a huge performance boost, depending on the complexity of the delegate.</db:para>
<db:para>When an item is flicked out, it moves to the <db:emphasis>reuse pool</db:emphasis>, which is an internal cache of unused items. When this happens, the <db:link xlink:href="qml-qtquick-tableview.xml#pooled-signal">TableView::pooled</db:link> signal is emitted to inform the item about it. Likewise, when the item is moved back from the pool, the <db:link xlink:href="qml-qtquick-tableview.xml#reused-signal">TableView::reused</db:link> signal is emitted.</db:para>
<db:para>Any item properties that come from the model are updated when the item is reused. This includes <db:code>index</db:code>, <db:code>row</db:code>, and <db:code>column</db:code>, but also any model roles.</db:para>
<db:note>
<db:para>Avoid storing any state inside a delegate. If you do, reset it manually on receiving the <db:link xlink:href="qml-qtquick-tableview.xml#reused-signal">TableView::reused</db:link> signal.</db:para>
</db:note>
<db:para>If an item has timers or animations, consider pausing them on receiving the <db:link xlink:href="qml-qtquick-tableview.xml#pooled-signal">TableView::pooled</db:link> signal. That way you avoid using the CPU resources for items that are not visible. Likewise, if an item has resources that cannot be reused, they could be freed up.</db:para>
<db:para>If you don't want to reuse items or if the <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">delegate</db:link> cannot support it, you can set the <db:link xlink:href="qml-qtquick-tableview.xml#reuseItems-prop">reuseItems</db:link> property to <db:code>false</db:code>.</db:para>
<db:note>
<db:para>While an item is in the pool, it might still be alive and respond to connected signals and bindings.</db:para>
</db:note>
<db:para>The following example shows a delegate that animates a spinning rectangle. When it is pooled, the animation is temporarily paused:</db:para>
<db:programlisting language="qml">Component {
    id: tableViewDelegate
    Rectangle {
        implicitWidth: 100
        implicitHeight: 50

        TableView.onPooled: rotationAnimation.pause()
        TableView.onReused: rotationAnimation.resume()

        Rectangle {
            id: rect
            anchors.centerIn: parent
            width: 40
            height: 5
            color: &quot;green&quot;

            RotationAnimation {
                id: rotationAnimation
                target: rect
                duration: (Math.random() * 2000) + 200
                from: 0
                to: 359
                running: true
                loops: Animation.Infinite
            }
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="row-heights-and-column-widths">
<db:title>Row heights and column widths</db:title>
<db:para>When a new column is flicked into view, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will determine its width by calling the <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link>. If set, this function will alone decide the width of the column. Otherwise, it will check if an explicit width has been set with <db:link xlink:href="qml-qtquick-tableview.xml#setColumnWidth-method">setColumnWidth</db:link>(). If not, <db:link xlink:href="qml-qtquick-tableview.xml#implicitColumnWidth-method">implicitColumnWidth</db:link>() will be used. The implicit width of a column is the same as the largest <db:link xlink:href="qml-qtquick-item.xml#implicitWidth-prop">implicit width</db:link> found among the currently loaded delegate items in that column. Trying to set an explicit <db:code>width</db:code> directly on a delegate has no effect, and will be ignored and overwritten. The same logic also applies to row heights.</db:para>
<db:para>An implementation of a <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link> that is equivalent to the default logic would be:</db:para>
<db:programlisting language="cpp">columnWidthProvider: function(column) {
    let w = explicitColumnWidth(column)
    if (w &gt;= 0)
        return w;
    return implicitColumnWidth(column)
}
</db:programlisting>
<db:para>Once the column width is resolved, all other items in the same column are resized to this width, including any items that are flicked into the view at a later point.</db:para>
<db:note>
<db:para>The resolved width of a column is discarded when the whole column is flicked out of the view, and is recalculated again if it's flicked back in. This means that if the width depends on the <db:link xlink:href="qml-qtquick-tableview.xml#implicitColumnWidth-method">implicitColumnWidth</db:link>(), the calculation can be different each time, depending on which row you're at when the column enters (since <db:link xlink:href="qml-qtquick-tableview.xml#implicitColumnWidth-method">implicitColumnWidth</db:link>() only considers the delegate items that are currently <db:link xlink:href="qml-qtquick-tableview.xml#isColumnLoaded-method">loaded</db:link>). To avoid this, you should use a <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link>, or ensure that all the delegate items in the same column have the same <db:code>implicitWidth</db:code>.</db:para>
</db:note>
<db:para>If you change the values that a <db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link> or a <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link> return for rows and columns inside the viewport, you must call <db:link xlink:href="qml-qtquick-tableview.xml#forceLayout-method">forceLayout</db:link>. This informs <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> that it needs to use the provider functions again to recalculate and update the layout.</db:para>
<db:para>Since Qt 5.13, if you want to hide a specific column, you can return <db:code>0</db:code> from the <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link> for that column. Likewise, you can return 0 from the <db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link> to hide a row. If you return a negative number, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will fall back to calculate the size based on the delegate items.</db:para>
<db:note>
<db:para>The size of a row or column should be a whole number to avoid sub-pixel alignment of items.</db:para>
</db:note>
<db:para>The following example shows how to set a simple <db:code>columnWidthProvider</db:code> together with a timer that modifies the values the function returns. When the array is modified, <db:link xlink:href="qml-qtquick-tableview.xml#forceLayout-method">forceLayout</db:link> is called to let the changes take effect:</db:para>
<db:programlisting language="qml">TableView {
    id: tableView

    property var columnWidths: [100, 50, 80, 150]
    columnWidthProvider: function (column) { return columnWidths[column] }

    Timer {
        running: true
        interval: 2000
        onTriggered: {
            tableView.columnWidths[2] = 150
            tableView.forceLayout();
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="editing-cells">
<db:title>Editing cells</db:title>
<db:para>You can let the user edit table cells by providing an edit delegate. The edit delegate will be instantiated according to the <db:link xlink:href="qml-qtquick-tableview.xml#editTriggers-prop">editTriggers</db:link>, which by default is when the user double taps on a cell, or presses e.g <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Enter</db:link> or <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Return</db:link>. The edit delegate is set using <db:link xlink:href="qml-qtquick-tableview.xml#editDelegate-attached-prop">TableView::editDelegate</db:link>, which is an attached property that you set on the <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">delegate</db:link>. The following snippet shows how to do that:</db:para>
<db:programlisting language="qml">    TableView {
        id: tableView
        anchors.fill: parent
        clip: true

        model: TableModel {
            TableModelColumn { display: &quot;name&quot; }
            rows: [ { &quot;name&quot;: &quot;Harry&quot; }, { &quot;name&quot;: &quot;Hedwig&quot; } ]
        }

        selectionModel: ItemSelectionModel {}

        delegate: Rectangle {
            implicitWidth: 100
            implicitHeight: 50

            Text {
                anchors.centerIn: parent
                text: display
            }

            TableView.editDelegate: TextField {
                anchors.fill: parent
                text: display
                horizontalAlignment: TextInput.AlignHCenter
                verticalAlignment: TextInput.AlignVCenter
                Component.onCompleted: selectAll()

                TableView.onCommit: {
                    display = text
                    // 'display = text' is short-hand for:
                    // let index = TableView.view.index(row, column)
                    // TableView.view.model.setData(index, &quot;display&quot;, text)
                }
            }
        }
    }
</db:programlisting>
<db:para>If the user presses <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Enter</db:link> or <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Return</db:link> while the edit delegate is active, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will emit the <db:link xlink:href="qml-qtquick-tableview.xml#commit-signal">TableView::commit</db:link> signal to the edit delegate, so that it can write back the changed data to the model.</db:para>
<db:note>
<db:para>In order for a cell to be editable, the model needs to override <db:link xlink:href="qabstractitemmodel.xml#flags">QAbstractItemModel::flags</db:link>(), and return <db:code>Qt::ItemIsEditable</db:code>. This flag is not enabled in <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link> by default. The override could for example look like this:</db:para>
</db:note>
<db:programlisting language="cpp">Qt::ItemFlags QAbstractItemModelSubClass::flags(const QModelIndex &amp;index) const override
{
    Q_UNUSED(index)
    return Qt::ItemIsSelectable | Qt::ItemIsEnabled | Qt::ItemIsEditable;
}
</db:programlisting>
<db:para>If the <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">TableView delegate</db:link> has a property <db:code>required property bool editing</db:code> defined, it will be set to <db:code>true</db:code> for the delegate being edited. See the documentation for <db:link xlink:href="qml-qtquick-tableview.xml#editDelegate-attached-prop">editDelegate</db:link> for an example on how to use it.</db:para>
</db:section>
<db:section xml:id="overlays-and-underlays">
<db:title>Overlays and underlays</db:title>
<db:para>All new items that are instantiated from the delegate are parented to the <db:link xlink:href="qml-qtquick-flickable.xml#contentItem-prop">contentItem</db:link> with the <db:code>z</db:code> value, <db:code>1</db:code>. You can add your own items inside the Tableview, as child items of the Flickable. By controlling their <db:code>z</db:code> value, you can make them be on top of or underneath the table items.</db:para>
<db:para>Here is an example that shows how to add some text on top of the table, that moves together with the table as you flick:</db:para>
<db:programlisting language="qml">TableView {
    id: tableView

    topMargin: header.implicitHeight

    Text {
        id: header
        text: &quot;A table header&quot;
    }
}
</db:programlisting>
<db:para>Here is another example that shows how to create an overlay item that stays on top of a particular cell. This requires a bit more code, since the location of a cell will <db:link xlink:href="qml-qtquick-tableview.xml#layoutChanged-signal">change</db:link> if the user, for example, is resizing a column in front of it.</db:para>
<db:programlisting language="qml">Rectangle {
    id: overlay
    width: 20
    height: 20
    radius: 10
    color: &quot;blue&quot;

    z: 10
    parent: tableView.contentItem

    Connections {
        target: tableView
        function onLayoutChanged() {
            let item = tableView.itemAtCell(5, 5)
            let insideViewport = item !== null

            overlay.visible = insideViewport
            if (insideViewport) {
                overlay.x = item.x
                overlay.y = item.y
            }
        }
    }
}
</db:programlisting>
<db:para>You could also parent the overlay directly to the cell instead of the <db:link xlink:href="qml-qtquick-flickable.xml#contentItem-prop">contentItem</db:link>. But doing so will be fragile since the cell is unloaded or reused whenever it's flicked out of the viewport.</db:para>
</db:section>
<db:section xml:id="selecting-items">
<db:title>Selecting items</db:title>
<db:para>You can add selection support to <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> by assigning an ItemSelectionModel to the <db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selectionModel</db:link> property. It will then use this model to control which delegate items should be shown as selected, and which item should be shown as current. You can set <db:link xlink:href="qml-qtquick-tableview.xml#selectionBehavior-prop">selectionBehavior</db:link> to control if the user should be allowed to select individual cells, rows, or columns.</db:para>
<db:para>To find out whether a delegate is selected or current, declare the following properties:</db:para>
<db:programlisting language="cpp">delegate: Item {
    required property bool selected
    required property bool current
    // ...
}
</db:programlisting>
<db:note>
<db:para>the <db:code>selected</db:code> and <db:code>current</db:code> properties must be defined as <db:code>required</db:code>. This will inform <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> that it should take responsibility for updating their values. If not, they will simply be ignored. See also <db:link xlink:href="qtqml-syntax-objectattributes.xml#required-properties">Required Properties</db:link>.</db:para>
</db:note>
<db:para>The following snippet shows how an application can render the delegate differently depending on the <db:code>selected</db:code> property:</db:para>
<db:programlisting language="qml">    TableView {
        id: tableView
        anchors.fill: parent
        clip: true

        model: TableModel {
            TableModelColumn { display: &quot;name&quot; }
            rows: [ { &quot;name&quot;: &quot;Harry&quot; }, { &quot;name&quot;: &quot;Hedwig&quot; } ]
        }

        selectionModel: ItemSelectionModel {}

        delegate: Rectangle {
            implicitWidth: 100
            implicitHeight: 30
            color: selected ? &quot;blue&quot; : &quot;lightgray&quot;

            required property bool selected

            Text { text: display }
        }
    }
</db:programlisting>
<db:para>The <db:link xlink:href="qml-qtquick-tableview.xml#currentRow-prop">currentRow</db:link> and <db:link xlink:href="qml-qtquick-tableview.xml#currentColumn-prop">currentColumn</db:link> properties can also be useful if you need to render a delegate differently depending on if it lies on the same row or column as the current item.</db:para>
<db:note>
<db:para><db:link xlink:href="">Qt Quick Controls</db:link> offers a SelectionRectangle that can be used to let the user select cells.</db:para>
</db:note>
<db:note>
<db:para>By default, a cell will become current, and any selections will be removed, when the user taps on it. If such default tap behavior is not wanted (e.g if you use custom pointer handlers inside your delegate), you can set <db:link xlink:href="qml-qtquick-tableview.xml#pointerNavigationEnabled-prop">pointerNavigationEnabled</db:link> to <db:code>false</db:code>.</db:para>
</db:note>
</db:section>
<db:section xml:id="keyboard-navigation">
<db:title>Keyboard navigation</db:title>
<db:para>In order to support keyboard navigation, you need to assign an ItemSelectionModel to the <db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selectionModel</db:link> property. <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will then use this model to manipulate the model's currentIndex.</db:para>
<db:para>It's the responsibility of the delegate to render itself as current. You can do this by adding a property <db:code>required property bool current</db:code> to it, and let the appearance depend on its state. The <db:code>current</db:code> property's value is set by the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>. You can also disable keyboard navigation fully (in case you want to implement your own key handlers) by setting <db:link xlink:href="qml-qtquick-tableview.xml#keyNavigationEnabled-prop">keyNavigationEnabled</db:link> to <db:code>false</db:code>.</db:para>
<db:para>The following example demonstrates how you can use keyboard navigation together with <db:code>current</db:code> and <db:code>selected</db:code> properties:</db:para>
<db:programlisting language="qml">ApplicationWindow {
    width: 800
    height: 600
    visible: true
    ScrollView {
        anchors.fill: parent
        TableView {
            id: tableView
            clip: true
            interactive: true
            rowSpacing: 1
            columnSpacing: 1
            model: TableModel {
                TableModelColumn { display: &quot;checked&quot; }
                TableModelColumn { display: &quot;amount&quot; }
                TableModelColumn { display: &quot;fruitType&quot; }
                TableModelColumn { display: &quot;fruitName&quot; }
                TableModelColumn { display: &quot;fruitPrice&quot; }

                rows: [
                    {
                        checked: false,
                        amount: 1,
                        fruitType: &quot;Apple&quot;,
                        fruitName: &quot;Granny Smith&quot;,
                        fruitPrice: 1.50
                    },
                    {
                        checked: true,
                        amount: 4,
                        fruitType: &quot;Orange&quot;,
                        fruitName: &quot;Navel&quot;,
                        fruitPrice: 2.50
                    },
                    {
                        checked: false,
                        amount: 1,
                        fruitType: &quot;Banana&quot;,
                        fruitName: &quot;Cavendish&quot;,
                        fruitPrice: 3.50
                    }
                ]
            }
            selectionModel: ItemSelectionModel {}
            delegate: Rectangle {
                implicitWidth: 100
                implicitHeight: 50
                required property bool selected
                required property bool current
                border.width: current ? 2 : 0
                color: selected ? &quot;lightblue&quot; : palette.base
                Text{
                    text: model.display
                    padding: 12
                }
            }
        }
    }
    SelectionRectangle {
        target: tableView
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="copy-and-paste">
<db:title>Copy and paste</db:title>
<db:para>Implementing copy and paste operations for a <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> usually also includes using a <db:link xlink:href="qundostack.xml">QUndoStack</db:link> (or some other undo/redo framework). The <db:link xlink:href="qundostack.xml">QUndoStack</db:link> can be used to store the different operations done on the model, like adding or removing rows, or pasting data from the clipboard, with a way to undo it again later. However, an accompanying <db:link xlink:href="qundostack.xml">QUndoStack</db:link> that describes the possible operations, and how to undo them, should be designed according to the needs of the model and the application. As such, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> doesn't offer a built-in API for handling copy and paste.</db:para>
<db:para>The following snippet can be used as a reference for how to add copy and paste support to your model and <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>. It uses the existing mime data API in <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link>, together with <db:link xlink:href="qclipboard.xml">QClipboard</db:link>. The snippet will work as it is, but can also be extended to use a <db:link xlink:href="qundostack.xml">QUndoStack</db:link>.</db:para>
<db:programlisting language="cpp">// Inside your C++ QAbstractTableModel subclass:

Q_INVOKABLE void copyToClipboard(const QModelIndexList &amp;indexes) const
{
    QGuiApplication::clipboard()-&gt;setMimeData(mimeData(indexes));
}

Q_INVOKABLE bool pasteFromClipboard(const QModelIndex &amp;targetIndex)
{
    const QMimeData *mimeData = QGuiApplication::clipboard()-&gt;mimeData();
    // Consider using a QUndoCommand for the following call. It should store
    // the (mime) data for the model items that are about to be overwritten, so
    // that a later call to undo can revert it.
    return dropMimeData(mimeData, Qt::CopyAction, -1, -1, targetIndex);
}
</db:programlisting>
<db:para>The two functions can, for example, be used from QML like this:</db:para>
<db:programlisting language="cpp">TableView {
    id: tableView
    model: tableModel
    selectionModel: ItemSelectionModel {}

    Shortcut {
       sequence: StandardKey.Copy
       onActivated: {
           let indexes = tableView.selectionModel.selectedIndexes
           tableView.model.copyToClipboard(indexes)
       }
    }

    Shortcut {
       sequence: StandardKey.Paste
       onActivated: {
           let targetIndex = tableView.selectionModel.currentIndex
           tableView.model.pasteFromClipboard(targetIndex)
       }
    }
}
</db:programlisting>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editDelegate-attached-prop">TableView::editDelegate</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#commit-signal">TableView::commit</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editTriggers-prop">editTriggers</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#edit-method">edit</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#closeEditor-method">closeEditor</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#layoutChanged-signal">layoutChanged</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractitemmodel.xml#mimeData">QAbstractItemModel::mimeData</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractitemmodel.xml#dropMimeData">QAbstractItemModel::dropMimeData</db:link>()</db:member>
<db:member><db:link xlink:href="qundostack.xml">QUndoStack</db:link></db:member>
<db:member><db:link xlink:href="qundocommand.xml">QUndoCommand</db:link></db:member>
<db:member><db:link xlink:href="qclipboard.xml">QClipboard</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="alternatingRows-prop">
<db:title>alternatingRows : bool</db:title>
<db:para>This property controls whether the background color of the rows should alternate. The default value is style dependent.</db:para>
<db:note>
<db:para>This property is only a hint, and might therefore not be respected by custom delegates. It's recommended that a delegate alternates between <db:code>palette.base</db:code> and <db:code>palette.alternateBase</db:code> when this hint is <db:code>true</db:code>, so that the colors can be set from outside of the delegate. For example:</db:para>
</db:note>
<db:programlisting language="cpp">background: Rectangle {
    color: control.row === control.tableView.currentRow
           ? control.palette.highlight
           : (control.tableView.alternatingRows &amp;&amp; control.row % 2 !== 0
           ? control.palette.alternateBase
           : control.palette.base)
}
</db:programlisting>
</db:section>
<db:section xml:id="animate-prop">
<db:title>[since 6.4] animate : bool</db:title>
<db:para>This property can be set to control if <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> should animate the <db:link xlink:href="qml-qtquick-flickable.xml#contentItem-prop">contentItem</db:link> (<db:link xlink:href="qml-qtquick-flickable.xml#contentX-prop">contentX</db:link> and <db:link xlink:href="qml-qtquick-flickable.xml#contentY-prop">contentY</db:link>). It is used by <db:link xlink:href="qml-qtquick-tableview.xml#positionViewAtCell-method">positionViewAtCell</db:link>(), and when navigating <db:link xlink:href="qitemselectionmodel.xml#currentIndex">the current index</db:link> with the keyboard. The default value is <db:code>true</db:code>.</db:para>
<db:para>If set to <db:code>false</db:code>, any ongoing animation will immediately stop.</db:para>
<db:note>
<db:para>This property is only a hint. <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> might choose to position the content item without an animation if, for example, the target cell is not <db:link xlink:href="qml-qtquick-tableview.xml#isRowLoaded-method">loaded</db:link>. However, if set to <db:code>false</db:code>, animations will always be off.</db:para>
</db:note>
<db:para>This property was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#positionViewAtCell-method">positionViewAtCell</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bottomRow-prop">
<db:title>bottomRow : int</db:title>
<db:para>This property holds the bottom-most row that is currently visible inside the view.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#leftColumn-prop">leftColumn</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rightColumn-prop">rightColumn</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#topRow-prop">topRow</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="columnSpacing-prop">
<db:title>columnSpacing : real</db:title>
<db:para>This property holds the spacing between the columns.</db:para>
<db:para>The default value is <db:code>0</db:code>.</db:para>
</db:section>
<db:section xml:id="columnWidthProvider-prop">
<db:title>columnWidthProvider : var</db:title>
<db:para>This property can hold a function that returns the column width for each column in the model. It is called whenever <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> needs to know the width of a specific column. The function takes one argument, <db:code>column</db:code>, for which the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> needs to know the width.</db:para>
<db:para>Since Qt 5.13, if you want to hide a specific column, you can return <db:code>0</db:code> width for that column. If you return a negative number, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> calculates the width based on the delegate items.</db:para>
<db:note>
<db:para>The columnWidthProvider will usually be called two times when a column is about to load (or when doing layout). First, to know if the column is visible and should be loaded. And second, to determine the width of the column after all items have been loaded. If you need to calculate the column width based on the size of the delegate items, you need to wait for the second call, when all the items have been loaded. You can check for this by calling <db:link xlink:href="qml-qtquick-tableview.xml#isColumnLoaded-method">isColumnLoaded</db:link>(column), and simply return -1 if that is not yet the case.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#isColumnLoaded-method">isColumnLoaded</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="columns-prop">
<db:title>[read-only] columns : int</db:title>
<db:para>This property holds the number of columns in the table.</db:para>
<db:note>
<db:para><db:code role="parameter">columns</db:code> is usually equal to the number of columns in the model, but can temporarily differ until all pending model changes have been processed.</db:para>
</db:note>
<db:para>If the model is a list, columns will be <db:code>1</db:code>.</db:para>
<db:para>This property is read only.</db:para>
</db:section>
<db:section xml:id="contentHeight-prop">
<db:title>contentHeight : real</db:title>
<db:para>This property holds the table height required to accommodate the number of rows in the data model. This is usually not the same as the <db:code>height</db:code> of the <db:code>view</db:code>, which means that the table's height could be larger or smaller than the viewport height. As a <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> cannot always know the exact height of the table without loading all rows in the model, the <db:code>contentHeight</db:code> is usually an estimate based on the initially loaded table.</db:para>
<db:para>If you know what the height of the table will be, assign a value to <db:code>contentHeight</db:code>, to avoid unnecessary calculations and updates to the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#contentWidth-prop">contentWidth</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contentWidth-prop">
<db:title>contentWidth : real</db:title>
<db:para>This property holds the table width required to accommodate the number of columns in the model. This is usually not the same as the <db:code>width</db:code> of the <db:link xlink:href="qml-qtquick-tableview.xml#view-attached-prop">view</db:link>, which means that the table's width could be larger or smaller than the viewport width. As a <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> cannot always know the exact width of the table without loading all columns in the model, the <db:code>contentWidth</db:code> is usually an estimate based on the initially loaded table.</db:para>
<db:para>If you know what the width of the table will be, assign a value to <db:code>contentWidth</db:code>, to avoid unnecessary calculations and updates to the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#contentHeight-prop">contentHeight</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentColumn-prop">
<db:title>[read-only] currentColumn : int</db:title>
<db:para>This read-only property holds the column in the view that contains the item that is <db:link xlink:href="qml-qtquick-tableview.xml#keyboard-navigation">current.</db:link> If no item is current, it will be <db:code>-1</db:code>.</db:para>
<db:note>
<db:para>In order for <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> to report what the current column is, you need to assign an ItemSelectionModel to <db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selectionModel</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#currentRow-prop">currentRow</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selectionModel</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selecting-items">Selecting items</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentRow-prop">
<db:title>[read-only] currentRow : int</db:title>
<db:para>This read-only property holds the row in the view that contains the item that is <db:link xlink:href="qml-qtquick-tableview.xml#keyboard-navigation">current.</db:link> If no item is current, it will be <db:code>-1</db:code>.</db:para>
<db:note>
<db:para>In order for <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> to report what the current row is, you need to assign an ItemSelectionModel to <db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selectionModel</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#currentColumn-prop">currentColumn</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selectionModel</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selecting-items">Selecting items</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="delegate-prop">
<db:title>delegate : Component</db:title>
<db:para>The delegate provides a template defining each cell item instantiated by the view. The model index is exposed as an accessible <db:code>index</db:code> property. The same applies to <db:code>row</db:code> and <db:code>column</db:code>. Properties of the model are also available depending upon the type of <db:link xlink:href="qtquick-modelviewsdata-modelview.xml#models">Data Model</db:link>.</db:para>
<db:para>A delegate should specify its size using <db:link xlink:href="qml-qtquick-item.xml#implicitWidth-prop">implicitWidth</db:link> and <db:link xlink:href="qml-qtquick-item.xml#implicitHeight-prop">implicitHeight</db:link>. The <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> lays out the items based on that information. Explicit width or height settings are ignored and overwritten.</db:para>
<db:para>Inside the delegate, you can optionally add one or more of the following properties. <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> modifies the values of these properties to inform the delegate which state it's in. This can be used by the delegate to render itself differently according on its own state.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>required property bool current - <db:code>true</db:code> if the delegate is <db:link xlink:href="qml-qtquick-tableview.xml#keyboard-navigation">current.</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>required property bool selected - <db:code>true</db:code> if the delegate is <db:link xlink:href="qml-qtquick-tableview.xml#selecting-items">selected.</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>required property bool editing - <db:code>true</db:code> if the delegate is being <db:link xlink:href="qml-qtquick-tableview.xml#editing-cells">edited.</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>required property bool containsDrag - <db:code>true</db:code> if a column or row is currently being dragged over this delegate. This property is only supported for HorizontalHeaderView and VerticalHeaderView. (since Qt 6.8)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The following example shows how to use these properties:</db:para>
<db:programlisting language="cpp">delegate: Rectangle {
    required property bool current
    required property bool selected
    border.width: current ? 1 : 0
    color: selected ? palette.highlight : palette.base
}
</db:programlisting>
<db:note>
<db:para>Delegates are instantiated as needed and may be destroyed at any time. They are also reused if the <db:link xlink:href="qml-qtquick-tableview.xml#reuseItems-prop">reuseItems</db:link> property is set to <db:code>true</db:code>. You should therefore avoid storing state information in the delegates.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reusing-items">Reusing items</db:link></db:member>
<db:member><db:link xlink:href="qtqml-syntax-objectattributes.xml#required-properties">Required Properties</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="editTriggers-prop">
<db:title>[default: TableView.DoubleTapped | TableView.EditKeyPressed., since 6.5] editTriggers : enumeration</db:title>
<db:para>This property holds the different ways the user can start to edit a cell. It can be a combination of the following values:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>TableView.NoEditTriggers</db:para>
</db:td>
<db:td>
<db:para>- the user cannot trigger editing of cells. When this value is set, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will neither <db:emphasis>open or close</db:emphasis> the edit delegate as a response to any user interaction. But the application can call <db:link xlink:href="qml-qtquick-tableview.xml#edit-method">edit</db:link>() and <db:link xlink:href="qml-qtquick-tableview.xml#closeEditor-method">closeEditor</db:link>() manually.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.SingleTapped</db:para>
</db:td>
<db:td>
<db:para>- the user can edit a cell by single tapping it.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.DoubleTapped</db:para>
</db:td>
<db:td>
<db:para>- the user can edit a cell by double tapping it.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.SelectedTapped</db:para>
</db:td>
<db:td>
<db:para>- the user can edit a <db:link xlink:href="qitemselectionmodel.xml#selectedIndexes">selected cell</db:link> by tapping it.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.EditKeyPressed</db:para>
</db:td>
<db:td>
<db:para>- the user can edit the <db:link xlink:href="">current cell</db:link> by pressing one of the edit keys. The edit keys are decided by the OS, but are normally <db:code>Qt::Key_Enter</db:code> and <db:code>Qt::Key_Return</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.AnyKeyPressed</db:para>
</db:td>
<db:td>
<db:para>- the user can edit the <db:link xlink:href="">current cell</db:link> by pressing any key, other than the cell navigation keys. The pressed key is also sent to the focus object inside the <db:link xlink:href="qml-qtquick-tableview.xml#editDelegate-attached-prop">edit delegate</db:link>.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>For <db:code>TableView.SelectedTapped</db:code>, <db:code>TableView.EditKeyPressed</db:code>, and <db:code>TableView.AnyKeyPressed</db:code> to have any effect, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> needs to have a <db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selection model</db:link> assigned, since they depend on a <db:link xlink:href="">current index</db:link> being set. To be able to receive any key events at all, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will also need to have <db:link xlink:href="qquickitem.xml#activeFocus-prop">QQuickItem::activeFocus</db:link>.</db:para>
<db:para>When editing a cell, the user can press <db:code>Qt::Key_Tab</db:code> or <db:code>Qt::Key_Backtab</db:code> to <db:link xlink:href="qml-qtquick-tableview.xml#commit-signal">commit</db:link> the data, and move editing to the next cell. This behavior can be disabled by setting <db:link xlink:href="qquickitem.xml#activeFocusOnTab-prop">QQuickItem::activeFocusOnTab</db:link> on <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> to <db:code>false</db:code>.</db:para>
<db:note>
<db:para>In order for a cell to be editable, the <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">delegate</db:link> needs an <db:link xlink:href="qml-qtquick-tableview.xml#editDelegate-attached-prop">edit delegate</db:link> attached, and the model needs to return <db:code>Qt::ItemIsEditable</db:code> from <db:link xlink:href="qabstractitemmodel.xml#flags">QAbstractItemModel::flags</db:link>() (exemplified underneath). If you still cannot edit a cell after activating one of the specified triggers, you can, as a help, try to call <db:link xlink:href="qml-qtquick-tableview.xml#edit-method">edit</db:link>() explicitly (e.g from a Button/<db:link xlink:href="qml-qtquick-taphandler.xml">TapHandler</db:link>). Doing so will print out a warning explaining why the cell cannot be edited.</db:para>
</db:note>
<db:programlisting language="cpp">Qt::ItemFlags QAbstractItemModelSubClass::flags(const QModelIndex &amp;index) const override
{
    Q_UNUSED(index)
    return Qt::ItemIsSelectable | Qt::ItemIsEnabled | Qt::ItemIsEditable;
}
</db:programlisting>
<db:para>This property was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editDelegate-attached-prop">TableView::editDelegate</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#commit-signal">TableView::commit</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editing-cells">Editing cells</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyNavigationEnabled-prop">
<db:title>[since 6.4] keyNavigationEnabled : bool</db:title>
<db:para>This property can be set to control if the user should be able to change <db:link xlink:href="qitemselectionmodel.xml#currentIndex">the current index</db:link> using the keyboard. The default value is <db:code>true</db:code>.</db:para>
<db:note>
<db:para>In order for <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> to support keyboard navigation, you need to assign an ItemSelectionModel to <db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selectionModel</db:link>.</db:para>
</db:note>
<db:para>This property was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#keyboard-navigation">Keyboard navigation</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selectionModel</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selectionBehavior-prop">selectionBehavior</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#pointerNavigationEnabled-prop">pointerNavigationEnabled</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-flickable.xml#interactive-prop">interactive</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="leftColumn-prop">
<db:title>leftColumn : int</db:title>
<db:para>This property holds the leftmost column that is currently visible inside the view.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rightColumn-prop">rightColumn</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#topRow-prop">topRow</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#bottomRow-prop">bottomRow</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="model-prop">
<db:title>model : model</db:title>
<db:para>This property holds the model that provides data for the table.</db:para>
<db:para>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using TableModel, ListModel, ObjectModel, or provided by a custom C++ model class. The C++ model must be a subclass of <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link> or a simple list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-modelviewsdata-modelview.xml#models">Data Models</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pointerNavigationEnabled-prop">
<db:title>[since 6.4] pointerNavigationEnabled : bool</db:title>
<db:para>This property can be set to control if the user should be able to change <db:link xlink:href="qitemselectionmodel.xml#currentIndex">the current index</db:link> using mouse or touch. The default value is <db:code>true</db:code>.</db:para>
<db:para>This property was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selectionModel</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#keyNavigationEnabled-prop">keyNavigationEnabled</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-flickable.xml#interactive-prop">interactive</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resizableColumns-prop">
<db:title>[since 6.5] resizableColumns : bool</db:title>
<db:para>This property holds whether the user is allowed to resize columns by dragging between the cells. The default value is <db:code>false</db:code>.</db:para>
<db:para>This property was introduced in Qt 6.5.</db:para>
</db:section>
<db:section xml:id="resizableRows-prop">
<db:title>[since 6.5] resizableRows : bool</db:title>
<db:para>This property holds whether the user is allowed to resize rows by dragging between the cells. The default value is <db:code>false</db:code>.</db:para>
<db:para>This property was introduced in Qt 6.5.</db:para>
</db:section>
<db:section xml:id="reuseItems-prop">
<db:title>reuseItems : bool</db:title>
<db:para>This property holds whether or not items instantiated from the <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">delegate</db:link> should be reused. If set to <db:code>false</db:code>, any currently pooled items are destroyed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reusing-items">Reusing items</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#pooled-signal">TableView::pooled</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reused-signal">TableView::reused</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rightColumn-prop">
<db:title>rightColumn : int</db:title>
<db:para>This property holds the rightmost column that is currently visible inside the view.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#leftColumn-prop">leftColumn</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#topRow-prop">topRow</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#bottomRow-prop">bottomRow</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rowHeightProvider-prop">
<db:title>rowHeightProvider : var</db:title>
<db:para>This property can hold a function that returns the row height for each row in the model. It is called whenever <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> needs to know the height of a specific row. The function takes one argument, <db:code>row</db:code>, for which the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> needs to know the height.</db:para>
<db:para>Since Qt 5.13, if you want to hide a specific row, you can return <db:code>0</db:code> height for that row. If you return a negative number, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> calculates the height based on the delegate items.</db:para>
<db:note>
<db:para>The rowHeightProvider will usually be called two times when a row is about to load (or when doing layout). First, to know if the row is visible and should be loaded. And second, to determine the height of the row after all items have been loaded. If you need to calculate the row height based on the size of the delegate items, you need to wait for the second call, when all the items have been loaded. You can check for this by calling <db:link xlink:href="qml-qtquick-tableview.xml#isRowLoaded-method">isRowLoaded</db:link>(row), and simply return -1 if that is not yet the case.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>rowHeightProvider</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#isRowLoaded-method">isRowLoaded</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rowSpacing-prop">
<db:title>rowSpacing : real</db:title>
<db:para>This property holds the spacing between the rows.</db:para>
<db:para>The default value is <db:code>0</db:code>.</db:para>
</db:section>
<db:section xml:id="rows-prop">
<db:title>[read-only] rows : int</db:title>
<db:para>This property holds the number of rows in the table.</db:para>
<db:note>
<db:para><db:code role="parameter">rows</db:code> is usually equal to the number of rows in the model, but can temporarily differ until all pending model changes have been processed.</db:para>
</db:note>
<db:para>This property is read only.</db:para>
</db:section>
<db:section xml:id="selectionBehavior-prop">
<db:title>[since 6.4] selectionBehavior : enumeration</db:title>
<db:para>This property holds whether the user can select cells, rows or columns.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>TableView.SelectionDisabled</db:para>
</db:td>
<db:td>
<db:para>The user cannot perform selections</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.SelectCells</db:para>
</db:td>
<db:td>
<db:para>(Default value) The user can select individual cells</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.SelectRows</db:para>
</db:td>
<db:td>
<db:para>The user can only select rows</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.SelectColumns</db:para>
</db:td>
<db:td>
<db:para>The user can only select columns</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This property was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selecting-items">Selecting items</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selectionMode-prop">selectionMode</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selectionModel</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#keyNavigationEnabled-prop">keyNavigationEnabled</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="selectionMode-prop">
<db:title>[since 6.6] selectionMode : enumeration</db:title>
<db:para>If <db:link xlink:href="qml-qtquick-tableview.xml#selectionBehavior-prop">selectionBehavior</db:link> is set to <db:code>TableView.SelectCells</db:code>, this property holds whether the user can select one cell at a time, or multiple cells. If <db:link xlink:href="qml-qtquick-tableview.xml#selectionBehavior-prop">selectionBehavior</db:link> is set to <db:code>TableView.SelectRows</db:code>, this property holds whether the user can select one row at a time, or multiple rows. If <db:link xlink:href="qml-qtquick-tableview.xml#selectionBehavior-prop">selectionBehavior</db:link> is set to <db:code>TableView.SelectColumns</db:code>, this property holds whether the user can select one column at a time, or multiple columns.</db:para>
<db:para>The following modes are available:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>TableView.SingleSelection</db:para>
</db:td>
<db:td>
<db:para>The user can select a single cell, row or column.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.ContiguousSelection</db:para>
</db:td>
<db:td>
<db:para>The user can select a single contiguous block of cells. An existing selection can be made bigger or smaller by holding down the <db:code>Shift</db:code> modifier while selecting.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.ExtendedSelection</db:para>
</db:td>
<db:td>
<db:para>(Default value) The user can select multiple individual blocks of cells. An existing selection can be made bigger or smaller by holding down the <db:code>Shift</db:code> modifier while selecting. A new selection block can be started without clearing the current selection by holding down the <db:code>Control</db:code> modifier while selecting.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This property was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selecting-items">Selecting items</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selectionBehavior-prop">selectionBehavior</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selectionModel</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#keyNavigationEnabled-prop">keyNavigationEnabled</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="selectionModel-prop">
<db:title>[since 6.2] selectionModel : ItemSelectionModel</db:title>
<db:para>This property can be set to control which delegate items should be shown as selected, and which item should be shown as current. If the delegate has a <db:code>required property bool selected</db:code> defined, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will keep it in sync with the selection state of the corresponding model item in the selection model. If the delegate has a <db:code>required property bool current</db:code> defined, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will keep it in sync with selectionModel.currentIndex.</db:para>
<db:para>This property was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#selecting-items">Selecting items</db:link></db:member>
<db:member>SelectionRectangle</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#keyNavigationEnabled-prop">keyNavigationEnabled</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#pointerNavigationEnabled-prop">pointerNavigationEnabled</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="syncDirection-prop">
<db:title>syncDirection : Qt::Orientations</db:title>
<db:para>If the <db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link> is set on a <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>, this property controls synchronization of flicking direction(s) for both tables. The default is <db:code>Qt.Horizontal | Qt.Vertical</db:code>, which means that if you flick either table in either direction, the other table is flicked the same amount in the same direction.</db:para>
<db:para>This property and <db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link> can be used to make two tableViews synchronize with each other smoothly in flicking regardless of the different overshoot/undershoot, velocity, acceleration/deceleration or rebound animation, and so on.</db:para>
<db:para>A typical use case is to make several headers flick along with the table.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="syncView-prop">
<db:title>syncView : TableView</db:title>
<db:para>If this property of a <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> is set to another <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>, both the tables will synchronize with regard to flicking, column widths/row heights, and spacing according to <db:link xlink:href="qml-qtquick-tableview.xml#syncDirection-prop">syncDirection</db:link>.</db:para>
<db:para>If <db:link xlink:href="qml-qtquick-tableview.xml#syncDirection-prop">syncDirection</db:link> contains <db:link xlink:href="qt.xml#Orientation-enum">Qt.Horizontal</db:link>, current tableView's column widths, column spacing, and horizontal flicking movement synchronizes with syncView's.</db:para>
<db:para>If <db:link xlink:href="qml-qtquick-tableview.xml#syncDirection-prop">syncDirection</db:link> contains <db:link xlink:href="qt.xml#Orientation-enum">Qt.Vertical</db:link>, current tableView's row heights, row spacing, and vertical flicking movement synchronizes with syncView's.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#syncDirection-prop">syncDirection</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="topRow-prop">
<db:title>topRow : int</db:title>
<db:para>This property holds the topmost row that is currently visible inside the view.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#leftColumn-prop">leftColumn</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rightColumn-prop">rightColumn</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#bottomRow-prop">bottomRow</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="attached-property-documentation">
<db:title>Attached Property Documentation</db:title>
<db:section xml:id="editDelegate-attached-prop">
<db:title>TableView.editDelegate : Component</db:title>
<db:para>This attached property holds the edit delegate. It's instantiated when editing begins, and parented to the delegate it edits. It supports the same required properties as the <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">TableView delegate</db:link>, including <db:code>index</db:code>, <db:code>row</db:code> and <db:code>column</db:code>. Properties of the model, like <db:code>display</db:code> and <db:code>edit</db:code>, are also available (depending on the <db:link xlink:href="qabstractitemmodel.xml#roleNames">role names</db:link> exposed by the model).</db:para>
<db:para>Editing starts when the actions specified by <db:link xlink:href="qml-qtquick-tableview.xml#editTriggers-prop">editTriggers</db:link> are met, and the current cell is editable.</db:para>
<db:note>
<db:para>In order for a cell to be editable, the model needs to override <db:link xlink:href="qabstractitemmodel.xml#flags">QAbstractItemModel::flags</db:link>(), and return <db:code>Qt::ItemIsEditable</db:code>.</db:para>
</db:note>
<db:para>You can also open and close the edit delegate manually by calling <db:link xlink:href="qml-qtquick-tableview.xml#edit-method">edit</db:link>() and <db:link xlink:href="qml-qtquick-tableview.xml#closeEditor-method">closeEditor</db:link>(), respectively. The <db:code>Qt::ItemIsEditable</db:code> flag will then be ignored.</db:para>
<db:para>Editing ends when the user presses <db:code>Qt::Key_Enter</db:code> or <db:code>Qt::Key_Return</db:code> (and also <db:code>Qt::Key_Tab</db:code> or <db:code>Qt::Key_Backtab</db:code>, if <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> has <db:link xlink:href="qquickitem.xml#activeFocusOnTab-prop">QQuickItem::activeFocusOnTab</db:link> set). In that case, the <db:link xlink:href="qml-qtquick-tableview.xml#commit-signal">TableView::commit</db:link> signal will be emitted, so that the edit delegate can respond by writing any modified data back to the model. If editing ends because of other reasons (e.g if the user presses <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Escape</db:link>), the signal will not be emitted. In any case will <db:link xlink:href="qml-qtqml-component.xml#destruction-signal">destruction</db:link>() be emitted in the end.</db:para>
<db:para>While the edit delegate is showing, the cell underneath will still be visible, and therefore shine through if the edit delegate is translucent, or otherwise doesn't cover the whole cell. If this is not wanted, you can either let the root item of the edit delegate be a solid <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link>, or hide some of the items inside the <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">TableView delegate.</db:link>. The latter can be done by defining a property <db:code>required property bool editing</db:code> inside it, that you bind to the <db:link xlink:href="qquickitem.xml#visible-prop">visible</db:link> property of some of the child items. The following snippet shows how to do that:</db:para>
<db:programlisting language="qml">        delegate: Rectangle {
            implicitWidth: 100
            implicitHeight: 50

            required property bool editing

            Text {
                id: textField
                anchors.fill: parent
                anchors.margins: 5
                text: display
                visible: !editing
            }

            TableView.editDelegate: TextField {
                x: textField.x
                y: textField.y
                width: textField.width
                height: textField.height
                text: display
                TableView.onCommit: display = text
            }
        }
</db:programlisting>
<db:para>When the edit delegate is instantiated, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will call <db:link xlink:href="qquickitem.xml#forceActiveFocus">QQuickItem::forceActiveFocus</db:link>() on it. If you want active focus to be set on a child of the edit delegate instead, let the edit delegate be a <db:link xlink:href="qml-qtquick-focusscope.xml">FocusScope</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editTriggers-prop">editTriggers</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#commit-signal">TableView::commit</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#edit-method">edit</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#closeEditor-method">closeEditor</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editing-cells">Editing cells</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="view-attached-prop">
<db:title>TableView.view : TableView</db:title>
<db:para>This attached property holds the view that manages the delegate instance. It is attached to each instance of the delegate.</db:para>
</db:section>
</db:section>
<db:section xml:id="signal-documentation">
<db:title>Signal Documentation</db:title>
<db:section xml:id="columnMoved-signal">
<db:title>[since 6.8] columnMoved(int <db:emphasis>logicalIndex</db:emphasis>, int <db:emphasis>oldVisualIndex</db:emphasis>, int <db:emphasis>newVisualIndex</db:emphasis>)</db:title>
<db:para>This signal is emitted when a column is moved. The column's logical index is specified by <db:code role="parameter">logicalIndex</db:code>, the old index by <db:code role="parameter">oldVisualIndex</db:code>, and the new index position by <db:code role="parameter">newVisualIndex</db:code>.</db:para>
<db:note>
<db:para>The corresponding handler is <db:code>onColumnMoved</db:code>.</db:para>
</db:note>
<db:para>This signal was introduced in Qt 6.8.</db:para>
</db:section>
<db:section xml:id="layoutChanged-signal">
<db:title>[since 6.5] layoutChanged()</db:title>
<db:para>This signal is emitted whenever the layout of the <db:link xlink:href="qml-qtquick-tableview.xml#isColumnLoaded-method">loaded</db:link> rows and columns has potentially changed. This will especially be the case when <db:link xlink:href="qml-qtquick-tableview.xml#forceLayout-method">forceLayout</db:link>() is called, but also when e.g resizing a row or a column, or when a row or column have entered or left the viewport.</db:para>
<db:para>This signal can be used to for example update the geometry of overlays.</db:para>
<db:note>
<db:para>The corresponding handler is <db:code>onLayoutChanged</db:code>.</db:para>
</db:note>
<db:para>This signal was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#forceLayout-method">forceLayout</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#overlays-and-underlays">Overlays and underlays</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rowMoved-signal">
<db:title>[since 6.8] rowMoved(int <db:emphasis>logicalIndex</db:emphasis>, int <db:emphasis>oldVisualIndex</db:emphasis>, int <db:emphasis>newVisualIndex</db:emphasis>)</db:title>
<db:para>This signal is emitted when a row is moved. The row's logical index is specified by <db:code role="parameter">logicalIndex</db:code>, the old index by <db:code role="parameter">oldVisualIndex</db:code>, and the new index position by <db:code role="parameter">newVisualIndex</db:code>.</db:para>
<db:note>
<db:para>The corresponding handler is <db:code>onRowMoved</db:code>.</db:para>
</db:note>
<db:para>This signal was introduced in Qt 6.8.</db:para>
</db:section>
</db:section>
<db:section xml:id="attached-signal-documentation">
<db:title>Attached Signal Documentation</db:title>
<db:section xml:id="commit-signal">
<db:title>commit()</db:title>
<db:para>This signal is emitted by the <db:link xlink:href="qml-qtquick-tableview.xml#editDelegate-attached-prop">edit delegate</db:link></db:para>
<db:para>This attached signal is emitted when the <db:link xlink:href="qml-qtquick-tableview.xml#editDelegate-attached-prop">edit delegate</db:link> is active, and the user presses <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Enter</db:link> or <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Return</db:link>. It will also be emitted if <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> has <db:link xlink:href="qquickitem.xml#activeFocusOnTab-prop">QQuickItem::activeFocusOnTab</db:link> set, and the user presses <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Tab</db:link> or <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Backtab</db:link>.</db:para>
<db:para>This signal will <db:emphasis>not</db:emphasis> be emitted if editing ends because of reasons other than the ones mentioned. This includes e.g if the user presses <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Escape</db:link>, taps outside the delegate, the row or column being edited is deleted, or if the application calls <db:link xlink:href="qml-qtquick-tableview.xml#closeEditor-method">closeEditor</db:link>().</db:para>
<db:para>Upon receiving the signal, the edit delegate should write any modified data back to the model.</db:para>
<db:note>
<db:para>This property should be attached to the <db:link xlink:href="qml-qtquick-tableview.xml#editDelegate-attached-prop">edit delegate</db:link>, and not to the <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">delegate</db:link>.</db:para>
</db:note>
<db:note>
<db:para>The corresponding handler is <db:code>onCommit</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editDelegate-attached-prop">TableView::editDelegate</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editTriggers-prop">editTriggers</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editing-cells">Editing cells</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pooled-signal">
<db:title>pooled()</db:title>
<db:para>This signal is emitted after an item has been added to the reuse pool. You can use it to pause ongoing timers or animations inside the item, or free up resources that cannot be reused.</db:para>
<db:para>This signal is emitted only if the <db:link xlink:href="qml-qtquick-tableview.xml#reuseItems-prop">reuseItems</db:link> property is <db:code>true</db:code>.</db:para>
<db:note>
<db:para>The corresponding handler is <db:code>onPooled</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reusing-items">Reusing items</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reuseItems-prop">reuseItems</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reused-signal">reused</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reused-signal">
<db:title>reused()</db:title>
<db:para>This signal is emitted after an item has been reused. At this point, the item has been taken out of the pool and placed inside the content view, and the model properties such as index, row, and column have been updated.</db:para>
<db:para>Other properties that are not provided by the model does not change when an item is reused. You should avoid storing any state inside a delegate, but if you do, manually reset that state on receiving this signal.</db:para>
<db:para>This signal is emitted when the item is reused, and not the first time the item is created.</db:para>
<db:para>This signal is emitted only if the <db:link xlink:href="qml-qtquick-tableview.xml#reuseItems-prop">reuseItems</db:link> property is <db:code>true</db:code>.</db:para>
<db:note>
<db:para>The corresponding handler is <db:code>onReused</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reusing-items">Reusing items</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reuseItems-prop">reuseItems</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#pooled-signal">pooled</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="method-documentation">
<db:title>Method Documentation</db:title>
<db:section xml:id="cellAtIndex-method">
<db:title>[since 6.4] point cellAtIndex(QModelIndex <db:emphasis>modelIndex</db:emphasis>)</db:title>
<db:para>Returns the cell in the view that maps to <db:code role="parameter">modelIndex</db:code> in the model. Convenience function for doing:</db:para>
<db:programlisting language="cpp">Qt.point(columnAtIndex(modelIndex), rowAtIndex(modelIndex))
</db:programlisting>
<db:para>A cell is simply a <db:link xlink:href="qml-point.xml">point</db:link> that combines row and column into a single type.</db:para>
<db:note>
<db:para>that <db:code>point.x</db:code> will map to the column, and <db:code>point.y</db:code> will map to the row.</db:para>
</db:note>
<db:para>This method was introduced in Qt 6.4.</db:para>
</db:section>
<db:section xml:id="cellAtPosition-method">
<db:title>Point cellAtPosition(point <db:emphasis>position</db:emphasis>, bool <db:emphasis>includeSpacing</db:emphasis>)</db:title>
<db:para>Returns the cell at the given <db:code role="parameter">position</db:code> in the table. <db:code role="parameter">position</db:code> should be relative to the <db:link xlink:href="qml-qtquick-flickable.xml#contentItem-prop">contentItem</db:link>. If no <db:link xlink:href="qml-qtquick-tableview.xml#isRowLoaded-method">loaded</db:link> cell intersects with <db:code role="parameter">position</db:code>, the return value will be <db:code>point(-1, -1)</db:code>.</db:para>
<db:para>If <db:code role="parameter">includeSpacing</db:code> is set to <db:code>true</db:code>, a cell's bounding box will be considered to include half the adjacent <db:link xlink:href="qml-qtquick-tableview.xml#rowSpacing-prop">rowSpacing</db:link> and <db:link xlink:href="qml-qtquick-tableview.xml#columnSpacing-prop">columnSpacing</db:link> on each side. The default value is <db:code>false</db:code>.</db:para>
<db:note>
<db:para>A <db:link xlink:href="qtquickhandlers-index.xml">Input Handler</db:link> attached to a <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> installs itself on the <db:link xlink:href="qml-qtquick-flickable.xml#contentItem-prop">contentItem</db:link> rather than the view. So the position reported by the handler can be used directly in a call to this function without any <db:link xlink:href="qquickitem.xml#mapFromItem">mapping</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#columnSpacing-prop">columnSpacing</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rowSpacing-prop">rowSpacing</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cellAtPosition-method-1">
<db:title>Point cellAtPosition(real <db:emphasis>x</db:emphasis>, real <db:emphasis>y</db:emphasis>, bool <db:emphasis>includeSpacing</db:emphasis>)</db:title>
<db:para>Convenience for calling <db:code>cellAtPosition(Qt.point(x, y), includeSpacing)</db:code>.</db:para>
</db:section>
<db:section xml:id="clearColumnReordering-method">
<db:title>[since 6.8] clearColumnReordering()</db:title>
<db:para>Resets any previously applied column reordering.</db:para>
<db:note>
<db:para>If a <db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link> is set, a call to this function will be forwarded to corresponding view item and reset the column ordering.</db:para>
</db:note>
<db:para>This method was introduced in Qt 6.8.</db:para>
</db:section>
<db:section xml:id="clearColumnWidths-method">
<db:title>clearColumnWidths()</db:title>
<db:para>Clears all the column widths set with <db:link xlink:href="qml-qtquick-tableview.xml#setColumnWidth-method">setColumnWidth</db:link>().</db:para>
<db:note>
<db:para>If a <db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link> is set, together with a <db:link xlink:href="qt.xml#Orientation-enum">Qt.Horizontal</db:link> <db:link xlink:href="qml-qtquick-tableview.xml#syncDirection-prop">syncDirection</db:link>, the sync view will control the column widths. Therefore, in that case, any call to this function will be forwarded to the sync view instead.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#setColumnWidth-method">setColumnWidth</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#clearRowHeights-method">clearRowHeights</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clearRowHeights-method">
<db:title>clearRowHeights()</db:title>
<db:para>Clears all the row heights set with <db:link xlink:href="qml-qtquick-tableview.xml#setRowHeight-method">setRowHeight</db:link>().</db:para>
<db:note>
<db:para>If a <db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link> is set, together with a <db:link xlink:href="qt.xml#Orientation-enum">Qt.Vertical</db:link> <db:link xlink:href="qml-qtquick-tableview.xml#syncDirection-prop">syncDirection</db:link>, the sync view will control the row heights. Therefore, in that case, any call to this function will be forwarded to the sync view instead.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#setRowHeight-method">setRowHeight</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#clearColumnWidths-method">clearColumnWidths</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clearRowReordering-method">
<db:title>[since 6.8] clearRowReordering()</db:title>
<db:para>Resets any previously applied row reordering.</db:para>
<db:note>
<db:para>If a <db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link> is set, a call to this function will be forwarded to the corresponding view item and reset the row ordering.</db:para>
</db:note>
<db:para>This method was introduced in Qt 6.8.</db:para>
</db:section>
<db:section xml:id="closeEditor-method">
<db:title>[since 6.5] closeEditor()</db:title>
<db:para>If the user is editing a cell, calling this function will stop the editing, and destroy the edit delegate instance.</db:para>
<db:para>This method was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#edit-method">edit</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editDelegate-attached-prop">TableView::editDelegate</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editing-cells">Editing cells</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="columnAtIndex-method">
<db:title>[since 6.4] int columnAtIndex(QModelIndex <db:emphasis>modelIndex</db:emphasis>)</db:title>
<db:para>Returns the column in the view that maps to <db:code role="parameter">modelIndex</db:code> in the model.</db:para>
<db:para>This method was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rowAtIndex-method">rowAtIndex</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#index-method">index</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="columnWidth-method">
<db:title>[since 6.2] real columnWidth(int <db:emphasis>column</db:emphasis>)</db:title>
<db:para>Returns the width of the given <db:code role="parameter">column</db:code>. If the column is not loaded (and therefore not visible), the return value will be <db:code>-1</db:code>.</db:para>
<db:para>This method was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#setColumnWidth-method">setColumnWidth</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#implicitColumnWidth-method">implicitColumnWidth</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#isColumnLoaded-method">isColumnLoaded</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="edit-method">
<db:title>[since 6.5] edit(QModelIndex <db:emphasis>modelIndex</db:emphasis>)</db:title>
<db:para>This function starts an editing session for the cell that represents <db:code role="parameter">modelIndex</db:code>. If the user is already editing another cell, that session ends.</db:para>
<db:para>Normally you can specify the different ways of starting an edit session by using <db:link xlink:href="qml-qtquick-tableview.xml#editTriggers-prop">editTriggers</db:link> instead. If that isn't sufficient, you can use this function. To take full control over cell editing and keep <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> from interfering, set <db:link xlink:href="qml-qtquick-tableview.xml#editTriggers-prop">editTriggers</db:link> to <db:code>TableView.NoEditTriggers</db:code>.</db:para>
<db:note>
<db:para>The <db:link xlink:href="">current index</db:link> in the <db:link xlink:href="qml-qtquick-tableview.xml#selectionModel-prop">selection model</db:link> will also change to <db:code role="parameter">modelIndex</db:code>.</db:para>
</db:note>
<db:para>This method was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#closeEditor-method">closeEditor</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editTriggers-prop">editTriggers</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editDelegate-attached-prop">TableView::editDelegate</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#editing-cells">Editing cells</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="explicitColumnWidth-method">
<db:title>qreal explicitColumnWidth(int <db:emphasis>column</db:emphasis>)</db:title>
<db:para>Returns the width of the <db:code role="parameter">column</db:code> set with <db:link xlink:href="qml-qtquick-tableview.xml#setColumnWidth-method">setColumnWidth</db:link>(). This width might differ from the actual width of the column, if a <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link> is in use. To get the actual width of a column, use <db:link xlink:href="qml-qtquick-tableview.xml#columnWidth-method">columnWidth</db:link>().</db:para>
<db:para>A return value equal to <db:code>0</db:code> means that the column has been told to hide. A return value equal to <db:code>-1</db:code> means that no explicit width has been set for the column.</db:para>
<db:note>
<db:para>If a <db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link> is set, together with a <db:link xlink:href="qt.xml#Orientation-enum">Qt.Horizontal</db:link> <db:link xlink:href="qml-qtquick-tableview.xml#syncDirection-prop">syncDirection</db:link>, the sync view will control the column widths. Therefore, in that case, any call to this function will be forwarded to the sync view instead.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#setColumnWidth-method">setColumnWidth</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#columnWidth-method">columnWidth</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="explicitRowHeight-method">
<db:title>qreal explicitRowHeight(int <db:emphasis>row</db:emphasis>)</db:title>
<db:para>Returns the height of the <db:code role="parameter">row</db:code> set with <db:link xlink:href="qml-qtquick-tableview.xml#setRowHeight-method">setRowHeight</db:link>(). This height might differ from the actual height of the column, if a <db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link> is in use. To get the actual height of a row, use <db:link xlink:href="qml-qtquick-tableview.xml#rowHeight-method">rowHeight</db:link>().</db:para>
<db:para>A return value equal to <db:code>0</db:code> means that the row has been told to hide. A return value equal to <db:code>-1</db:code> means that no explicit height has been set for the row.</db:para>
<db:note>
<db:para>If a <db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link> is set, together with a <db:link xlink:href="qt.xml#Orientation-enum">Qt.Vertical</db:link> <db:link xlink:href="qml-qtquick-tableview.xml#syncDirection-prop">syncDirection</db:link>, the sync view will control the row heights. Therefore, in that case, any call to this function will be forwarded to the sync view instead.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#setRowHeight-method">setRowHeight</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rowHeight-method">rowHeight</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="forceLayout-method">
<db:title>forceLayout()</db:title>
<db:para>Responding to changes in the model are batched so that they are handled only once per frame. This means the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> delays showing any changes while a script is being run. The same is also true when changing properties, such as <db:link xlink:href="qml-qtquick-tableview.xml#rowSpacing-prop">rowSpacing</db:link> or <db:link xlink:href="qml-qtquick-item.xml#anchors.leftMargin-prop">leftMargin</db:link>.</db:para>
<db:para>This method forces the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> to immediately update the layout so that any recent changes take effect.</db:para>
<db:para>Calling this function re-evaluates the size and position of each visible row and column. This is needed if the functions assigned to <db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link> or <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link> return different values than what is already assigned.</db:para>
</db:section>
<db:section xml:id="implicitColumnWidth-method">
<db:title>[since 6.2] real implicitColumnWidth(int <db:emphasis>column</db:emphasis>)</db:title>
<db:para>Returns the implicit width of the given <db:code role="parameter">column</db:code>. This is the largest <db:link xlink:href="qml-qtquick-item.xml#implicitWidth-prop">implicitWidth</db:link> found among the currently <db:link xlink:href="qml-qtquick-tableview.xml#isRowLoaded-method">loaded</db:link> delegate items inside that column.</db:para>
<db:para>If the <db:code role="parameter">column</db:code> is not loaded (and therefore not visible), the return value is <db:code>-1</db:code>.</db:para>
<db:para>This method was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#columnWidth-method">columnWidth</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#isRowLoaded-method">isRowLoaded</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="implicitRowHeight-method">
<db:title>[since 6.2] real implicitRowHeight(int <db:emphasis>row</db:emphasis>)</db:title>
<db:para>Returns the implicit height of the given <db:code role="parameter">row</db:code>. This is the largest <db:link xlink:href="qml-qtquick-item.xml#implicitHeight-prop">implicitHeight</db:link> found among the currently <db:link xlink:href="qml-qtquick-tableview.xml#isColumnLoaded-method">loaded</db:link> delegate items inside that row.</db:para>
<db:para>If the <db:code role="parameter">row</db:code> is not loaded (and therefore not visible), the return value is <db:code>-1</db:code>.</db:para>
<db:para>This method was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rowHeight-method">rowHeight</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#isColumnLoaded-method">isColumnLoaded</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="index-method">
<db:title>[since 6.4.3] QModelIndex index(int <db:emphasis>row</db:emphasis>, int <db:emphasis>column</db:emphasis>)</db:title>
<db:para>Returns the <db:link xlink:href="qmodelindex.xml">QModelIndex</db:link> that maps to <db:code role="parameter">row</db:code> and <db:code role="parameter">column</db:code> in the view.</db:para>
<db:para><db:code role="parameter">row</db:code> and <db:code role="parameter">column</db:code> should be the row and column in the view (table row and table column), and not a row and column in the model. For a plain <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>, this is equivalent of calling <db:code>model.index(row, column).</db:code> But for a subclass of <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>, like <db:link xlink:href="qml-qtquick-treeview.xml">TreeView</db:link>, where the data model is wrapped inside an internal proxy model that flattens the tree structure into a table, you need to use this function to resolve the model index.</db:para>
<db:para>This method was introduced in Qt 6.4.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rowAtIndex-method">rowAtIndex</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#columnAtIndex-method">columnAtIndex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isColumnLoaded-method">
<db:title>[since 6.2] bool isColumnLoaded(int <db:emphasis>column</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if the given <db:code role="parameter">column</db:code> is loaded.</db:para>
<db:para>A column is loaded when <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> has loaded the delegate items needed to show the column inside the view. This also usually means that the column is visible for the user, but not always.</db:para>
<db:para>This function can be used whenever you need to iterate over the delegate items for a column, e.g from a <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link>, to be sure that the delegate items are available for iteration.</db:para>
<db:para>This method was introduced in Qt 6.2.</db:para>
</db:section>
<db:section xml:id="isRowLoaded-method">
<db:title>[since 6.2] bool isRowLoaded(int <db:emphasis>row</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if the given <db:code role="parameter">row</db:code> is loaded.</db:para>
<db:para>A row is loaded when <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> has loaded the delegate items needed to show the row inside the view. This also usually means that the row is visible for the user, but not always.</db:para>
<db:para>This function can be used whenever you need to iterate over the delegate items for a row, e.g from a <db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link>, to be sure that the delegate items are available for iteration.</db:para>
<db:para>This method was introduced in Qt 6.2.</db:para>
</db:section>
<db:section xml:id="itemAtCell-method">
<db:title>Item itemAtCell(point <db:emphasis>cell</db:emphasis>)</db:title>
<db:para>Returns the delegate item at <db:code role="parameter">cell</db:code> if loaded, otherwise <db:code>null</db:code>.</db:para>
<db:note>
<db:para>only the items that are visible in the view are normally loaded. As soon as a cell is flicked out of the view, the item inside will either be unloaded or placed in the recycle pool. As such, the return value should never be stored.</db:para>
</db:note>
</db:section>
<db:section xml:id="itemAtIndex-method">
<db:title>[since 6.5] Item itemAtIndex(QModelIndex <db:emphasis>index</db:emphasis>)</db:title>
<db:para>Returns the instantiated delegate item for the cell that represents <db:code role="parameter">index</db:code>. If the item is not <db:link xlink:href="qml-qtquick-tableview.xml#isRowLoaded-method">loaded</db:link>, the value will be <db:code>null</db:code>.</db:para>
<db:note>
<db:para>only the items that are visible in the view are normally loaded. As soon as a cell is flicked out of the view, the item inside will either be unloaded or placed in the recycle pool. As such, the return value should never be stored.</db:para>
</db:note>
<db:note>
<db:para>If the <db:link xlink:href="qml-qtquick-tableview.xml#model-prop">model</db:link> is not a <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link>, you can also use <db:link xlink:href="qml-qtquick-tableview.xml#itemAtCell-method">itemAtCell(Qt.point</db:link>(column, row)). But be aware that <db:code>point.x</db:code> maps to columns and <db:code>point.y</db:code> maps to rows.</db:para>
</db:note>
<db:para>This method was introduced in Qt 6.5.</db:para>
</db:section>
<db:section xml:id="modelIndex-method">
<db:title>[since 6.4] QModelIndex modelIndex(point <db:emphasis>cell</db:emphasis>)</db:title>
<db:para>Convenience function for doing:</db:para>
<db:programlisting language="cpp">index(cell.y, cell.x)
</db:programlisting>
<db:para>A <db:code role="parameter">cell</db:code> is simply a <db:link xlink:href="qml-point.xml">point</db:link> that combines row and column into a single type.</db:para>
<db:note>
<db:para><db:code>point.x</db:code> will map to the column, and <db:code>point.y</db:code> will map to the row.</db:para>
</db:note>
<db:para>This method was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#index-method">index</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="moveColumn-method">
<db:title>[since 6.8] moveColumn(int <db:emphasis>source</db:emphasis>, int <db:emphasis>destination</db:emphasis>)</db:title>
<db:para>Moves a column from the <db:code role="parameter">source</db:code> to the <db:code role="parameter">destination</db:code> position.</db:para>
<db:note>
<db:para>If a <db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link> is set, the sync view will control the internal index mapping for column reordering. Therefore, in that case, a call to this function will be forwarded to the sync view instead.</db:para>
</db:note>
<db:para>This method was introduced in Qt 6.8.</db:para>
</db:section>
<db:section xml:id="moveRow-method">
<db:title>[since 6.8] moveRow(int <db:emphasis>source</db:emphasis>, int <db:emphasis>destination</db:emphasis>)</db:title>
<db:para>Moves a row from the <db:code role="parameter">source</db:code> to the <db:code role="parameter">destination</db:code> position.</db:para>
<db:note>
<db:para>If a <db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link> is set, the sync view will control the internal index mapping for row reordering. Therefore, in that case, a call to this function will be forwarded to the sync view instead.</db:para>
</db:note>
<db:para>This method was introduced in Qt 6.8.</db:para>
</db:section>
<db:section xml:id="positionViewAtCell-method">
<db:title>positionViewAtCell(point <db:emphasis>cell</db:emphasis>, PositionMode <db:emphasis>mode</db:emphasis>, point <db:emphasis>offset</db:emphasis>, rect <db:emphasis>subRect</db:emphasis>)</db:title>
<db:para>Positions <db:link xlink:href="qml-qtquick-flickable.xml#contentX-prop">contentX</db:link> and <db:link xlink:href="qml-qtquick-flickable.xml#contentY-prop">contentY</db:link> such that <db:code role="parameter">cell</db:code> is at the position specified by <db:code role="parameter">mode</db:code>. <db:code role="parameter">mode</db:code> can be an or-ed combination of the following:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>TableView.AlignLeft</db:para>
</db:td>
<db:td>
<db:para>Position the cell at the left of the view.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.AlignHCenter</db:para>
</db:td>
<db:td>
<db:para>Position the cell at the horizontal center of the view.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.AlignRight</db:para>
</db:td>
<db:td>
<db:para>Position the cell at the right of the view.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.AlignTop</db:para>
</db:td>
<db:td>
<db:para>Position the cell at the top of the view.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.AlignVCenter</db:para>
</db:td>
<db:td>
<db:para>Position the cell at the vertical center of the view.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.AlignBottom</db:para>
</db:td>
<db:td>
<db:para>Position the cell at the bottom of the view.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.AlignCenter</db:para>
</db:td>
<db:td>
<db:para>The same as (<db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>.AlignHCenter | <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>.AlignVCenter)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.Visible</db:para>
</db:td>
<db:td>
<db:para>If any part of the cell is visible then take no action. Otherwise move the content item so that the entire cell becomes visible.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>TableView.Contain</db:para>
</db:td>
<db:td>
<db:para>If the entire cell is visible then take no action. Otherwise move the content item so that the entire cell becomes visible. If the cell is bigger than the view, the top-left part of the cell will be preferred.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>If no vertical alignment is specified, vertical positioning will be ignored. The same is true for horizontal alignment.</db:para>
<db:para>Optionally, you can specify <db:code role="parameter">offset</db:code> to move <db:emphasis>contentX</db:emphasis> and <db:emphasis>contentY</db:emphasis> an extra number of pixels beyond the target alignment. E.g if you want to position the view so that cell [10, 10] ends up at the top-left corner with a 5px margin, you could do:</db:para>
<db:programlisting language="cpp">positionViewAtCell(Qt.point(10, 10), TableView.AlignLeft | TableView.AlignTop, Qt.point(-5, -5))
</db:programlisting>
<db:para>As of Qt 6.4, you can specify a <db:code role="parameter">subRect</db:code> to position on a rectangle inside the <db:code role="parameter">cell</db:code>, rather than on the bounding rectangle of the whole cell. This can be useful if the cell is e.g larger than the view, and you want to ensure that a specific part of it is visible. The <db:code role="parameter">subRect</db:code> needs to be <db:link xlink:href="qrectf.xml#isValid">valid</db:link> to be taken into consideration.</db:para>
<db:note>
<db:para>It is not recommended to use <db:emphasis>contentX</db:emphasis> or <db:emphasis>contentY</db:emphasis> to position the view at a particular cell. This is unreliable since removing items from the start of the table does not cause all other items to be repositioned. <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> can also sometimes place rows and columns at approximate positions to optimize for speed. The only exception is if the cell is already visible in the view, which can be checked upfront by calling <db:link xlink:href="qml-qtquick-tableview.xml#itemAtCell-method">itemAtCell</db:link>().</db:para>
</db:note>
<db:para>Methods should only be called after the Component has completed. To position the view at startup, this method should be called by Component.onCompleted. For example, to position the view at the end:</db:para>
<db:programlisting language="cpp">Component.onCompleted: positionViewAtCell(Qt.point(columns - 1, rows - 1), TableView.AlignRight | TableView.AlignBottom)
</db:programlisting>
<db:note>
<db:para>The second argument to this function used to be Qt.Alignment. For backwards compatibility, that enum can still be used. The change to use PositionMode was done in Qt 6.4.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#animate-prop">animate</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="positionViewAtColumn-method">
<db:title>positionViewAtColumn(int <db:emphasis>column</db:emphasis>, PositionMode <db:emphasis>mode</db:emphasis>, real <db:emphasis>offset</db:emphasis>, rect <db:emphasis>subRect</db:emphasis>)</db:title>
<db:para>Positions {Flickable::}{contentX} such that <db:code role="parameter">column</db:code> is at the position specified by <db:code role="parameter">mode</db:code>, <db:code role="parameter">offset</db:code> and <db:code role="parameter">subRect</db:code>.</db:para>
<db:para>Convenience method for calling</db:para>
<db:programlisting language="cpp">positionViewAtCell(Qt.point(column, 0), mode &amp; Qt.AlignHorizontal_Mask, offset, subRect)
</db:programlisting>
</db:section>
<db:section xml:id="positionViewAtIndex-method">
<db:title>[since 6.5] positionViewAtIndex(QModelIndex <db:emphasis>index</db:emphasis>, PositionMode <db:emphasis>mode</db:emphasis>, point <db:emphasis>offset</db:emphasis>, rect <db:emphasis>subRect</db:emphasis>)</db:title>
<db:para>Positions the view such that <db:code role="parameter">index</db:code> is at the position specified by <db:code role="parameter">mode</db:code>, <db:code role="parameter">offset</db:code> and <db:code role="parameter">subRect</db:code>.</db:para>
<db:para>Convenience method for calling</db:para>
<db:programlisting language="cpp">positionViewAtRow(rowAtIndex(index), mode &amp; Qt.AlignVertical_Mask, offset.y, subRect)
positionViewAtColumn(columnAtIndex(index), mode &amp; Qt.AlignVertical_Mask, offset.x, subRect)
</db:programlisting>
<db:para>This method was introduced in Qt 6.5.</db:para>
</db:section>
<db:section xml:id="positionViewAtRow-method">
<db:title>positionViewAtRow(int <db:emphasis>row</db:emphasis>, PositionMode <db:emphasis>mode</db:emphasis>, real <db:emphasis>offset</db:emphasis>, rect <db:emphasis>subRect</db:emphasis>)</db:title>
<db:para>Positions {Flickable::}{contentY} such that <db:code role="parameter">row</db:code> is at the position specified by <db:code role="parameter">mode</db:code>, <db:code role="parameter">offset</db:code> and <db:code role="parameter">subRect</db:code>.</db:para>
<db:para>Convenience method for calling</db:para>
<db:programlisting language="cpp">positionViewAtCell(Qt.point(0, row), mode &amp; Qt.AlignVertical_Mask, offset, subRect)
</db:programlisting>
</db:section>
<db:section xml:id="rowAtIndex-method">
<db:title>[since 6.4] int rowAtIndex(QModelIndex <db:emphasis>modelIndex</db:emphasis>)</db:title>
<db:para>Returns the row in the view that maps to <db:code role="parameter">modelIndex</db:code> in the model.</db:para>
<db:para>This method was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#columnAtIndex-method">columnAtIndex</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#index-method">index</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rowHeight-method">
<db:title>[since 6.2] real rowHeight(int <db:emphasis>row</db:emphasis>)</db:title>
<db:para>Returns the height of the given <db:code role="parameter">row</db:code>. If the row is not loaded (and therefore not visible), the return value will be <db:code>-1</db:code>.</db:para>
<db:para>This method was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#setRowHeight-method">setRowHeight</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#implicitRowHeight-method">implicitRowHeight</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#isRowLoaded-method">isRowLoaded</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setColumnWidth-method">
<db:title>setColumnWidth(int <db:emphasis>column</db:emphasis>, real <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Sets the explicit column width of column <db:code role="parameter">column</db:code> to <db:code role="parameter">size</db:code>.</db:para>
<db:para>If you want to read back the values you set with this function, you should use <db:link xlink:href="qml-qtquick-tableview.xml#explicitColumnWidth-method">explicitColumnWidth</db:link>(). <db:link xlink:href="qml-qtquick-tableview.xml#columnWidth-method">columnWidth</db:link>() will return the actual size of the column, which can be different if a <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link> is set.</db:para>
<db:para>When <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> needs to resolve the width of <db:code role="parameter">column</db:code>, it will first try to call the <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link>. Only if a provider is not set, will the widths set with this function be used by default. You can, however, call <db:link xlink:href="qml-qtquick-tableview.xml#explicitColumnWidth-method">explicitColumnWidth</db:link>() from within the provider, and if needed, moderate the values to e.g always be within a certain interval. The following snippet shows an example on how to do that:</db:para>
<db:programlisting language="cpp">columnWidthProvider: function(column) {
    let w = explicitColumnWidth(column)
    if (w &gt;= 0)
        return Math.max(100, w);
    return implicitColumnWidth(column)
}
</db:programlisting>
<db:para>If <db:code role="parameter">size</db:code> is equal to <db:code>0</db:code>, the column will be hidden. If <db:code role="parameter">size</db:code> is equal to <db:code>-1</db:code>, the column will be reset back to use <db:link xlink:href="qml-qtquick-tableview.xml#implicitColumnWidth-method">implicitColumnWidth</db:link>(). You are allowed to specify column sizes for columns that are outside the size of the model.</db:para>
<db:note>
<db:para>The sizes you set will not be cleared if you change the <db:link xlink:href="qml-qtquick-tableview.xml#model-prop">model</db:link>. To clear the sizes, you need to call <db:link xlink:href="qml-qtquick-tableview.xml#clearColumnWidths-method">clearColumnWidths</db:link>() explicitly.</db:para>
</db:note>
<db:note>
<db:para>If a <db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link> is set, together with a <db:link xlink:href="qt.xml#Orientation-enum">Qt.Horizontal</db:link> <db:link xlink:href="qml-qtquick-tableview.xml#syncDirection-prop">syncDirection</db:link>, the sync view will control the column widths. Therefore, in that case, any call to this function will be forwarded to the sync view instead.</db:para>
</db:note>
<db:note>
<db:para>For models with <db:emphasis>lots</db:emphasis> of columns, using setColumnWidth() to set the widths for all the columns at start-up, can be suboptimal. This will consume start-up time and memory (for storing all the widths). A more scalable approach is to use a <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link> instead, or rely on the implicit width of the delegate. A <db:code>columnWidthProvider</db:code> will only be called on an as-needed basis, and will not be affected by the size of the model.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#columnWidth-method">columnWidth</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#explicitColumnWidth-method">explicitColumnWidth</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#setRowHeight-method">setRowHeight</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#clearColumnWidths-method">clearColumnWidths</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setRowHeight-method">
<db:title>setRowHeight(int <db:emphasis>row</db:emphasis>, real <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Sets the explicit row height of row <db:code role="parameter">row</db:code> to <db:code role="parameter">size</db:code>.</db:para>
<db:para>If you want to read back the values you set with this function, you should use <db:link xlink:href="qml-qtquick-tableview.xml#explicitRowHeight-method">explicitRowHeight</db:link>(). <db:link xlink:href="qml-qtquick-tableview.xml#rowHeight-method">rowHeight</db:link>() will return the actual height of the row, which can be different if a <db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link> is set.</db:para>
<db:para>When <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> needs to resolve the height of <db:code role="parameter">row</db:code>, it will first try to call the <db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link>. Only if a provider is not set, will the heights set with this function be used by default. You can, however, call <db:link xlink:href="qml-qtquick-tableview.xml#explicitRowHeight-method">explicitRowHeight</db:link>() from within the provider, and if needed, moderate the values to e.g always be within a certain interval. The following snippet shows an example on how to do that:</db:para>
<db:programlisting language="cpp">rowHeightProvider: function(row) {
    let h = explicitRowHeight(row)
    if (h &gt;= 0)
        return Math.max(100, h);
    return implicitRowHeight(row)
}
</db:programlisting>
<db:para>If <db:code role="parameter">size</db:code> is equal to <db:code>0</db:code>, the row will be hidden. If <db:code role="parameter">size</db:code> is equal to <db:code>-1</db:code>, the row will be reset back to use <db:link xlink:href="qml-qtquick-tableview.xml#implicitRowHeight-method">implicitRowHeight</db:link>(). You are allowed to specify row sizes for rows that are outside the size of the model.</db:para>
<db:note>
<db:para>The sizes you set will not be cleared if you change the <db:link xlink:href="qml-qtquick-tableview.xml#model-prop">model</db:link>. To clear the sizes, you need to call <db:link xlink:href="qml-qtquick-tableview.xml#clearRowHeights-method">clearRowHeights</db:link>() explicitly.</db:para>
</db:note>
<db:note>
<db:para>If a <db:link xlink:href="qml-qtquick-tableview.xml#syncView-prop">syncView</db:link> is set, together with a <db:link xlink:href="qt.xml#Orientation-enum">Qt.Vertical</db:link> <db:link xlink:href="qml-qtquick-tableview.xml#syncDirection-prop">syncDirection</db:link>, the sync view will control the row heights. Therefore, in that case, any call to this function will be forwarded to the sync view instead.</db:para>
</db:note>
<db:note>
<db:para>For models with <db:emphasis>lots</db:emphasis> of rows, using setRowHeight() to set the heights for all the rows at start-up, can be suboptimal. This will consume start-up time and memory (for storing all the heights). A more scalable approach is to use a <db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link> instead, or rely on the implicit height of the delegate. A <db:code>rowHeightProvider</db:code> will only be called on an as-needed basis, and will not be affected by the size of the model.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rowHeight-method">rowHeight</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#explicitRowHeight-method">explicitRowHeight</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#setColumnWidth-method">setColumnWidth</db:link>()</db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for TableView</db:title>
<db:para><db:emphasis role="bold">The following members of QML type <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-method-documentation">
<db:title>Obsolete Method Documentation</db:title>
<db:section xml:id="cellAtPos-method">
<db:title>[deprecated] Point cellAtPos(point <db:emphasis>position</db:emphasis>, bool <db:emphasis>includeSpacing</db:emphasis>)</db:title>
<db:para>This method is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qml-qtquick-tableview.xml#cellAtPosition-method">cellAtPosition</db:link>(point position) instead.</db:para>
</db:section>
<db:section xml:id="cellAtPos-method-1">
<db:title>[deprecated] Point cellAtPos(real <db:emphasis>x</db:emphasis>, real <db:emphasis>y</db:emphasis>, bool <db:emphasis>includeSpacing</db:emphasis>)</db:title>
<db:para>This method is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qml-qtquick-tableview.xml#cellAtPosition-method">cellAtPosition</db:link>(real x, real y) instead.</db:para>
</db:section>
<db:section xml:id="itemAtCell-method-1">
<db:title>[deprecated] Item itemAtCell(int <db:emphasis>column</db:emphasis>, int <db:emphasis>row</db:emphasis>)</db:title>
<db:para>This method is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qml-qtquick-tableview.xml#itemAtIndex-method">itemAtIndex(index</db:link>(row, column)) instead.</db:para>
</db:section>
<db:section xml:id="modelIndex-method-1">
<db:title>[since 6.4, deprecated] QModelIndex modelIndex(int <db:emphasis>row</db:emphasis>, int <db:emphasis>column</db:emphasis>)</db:title>
<db:para>This method is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qml-qtquick-tableview.xml#index-method">index</db:link>(int row, int column) instead.</db:para>
<db:note>
<db:para>Because of an API incompatible change between Qt 6.4.0 and Qt 6.4.2, the order of <db:code>row</db:code> and <db:code>column</db:code> was specified in the opposite order. If you rely on the order to be <db:code>modelIndex(column, row)</db:code>, you can set the environment variable <db:code>QT_QUICK_TABLEVIEW_COMPAT_VERSION</db:code> to <db:code>6.4</db:code></db:para>
</db:note>
<db:para>This method was introduced in Qt 6.4.</db:para>
</db:section>
<db:section xml:id="positionViewAtCell-method-1">
<db:title>[deprecated] positionViewAtCell(int <db:emphasis>column</db:emphasis>, int <db:emphasis>row</db:emphasis>, PositionMode <db:emphasis>mode</db:emphasis>, point <db:emphasis>offset</db:emphasis>, rect <db:emphasis>subRect</db:emphasis>)</db:title>
<db:para>This method is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qml-qtquick-tableview.xml#positionViewAtIndex-method">positionViewAtIndex(index</db:link>(row, column), ...) instead.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
