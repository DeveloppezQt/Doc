<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>TableView QML Type</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 5.13.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Provides a table view of items provided by the model.</db:para>
<db:para>This type was introduced in Qt 5.12.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Import Statement</db:term>
<db:listitem>
<db:para>import QtQuick 2.13</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.12</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para>Flickable</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>TableView is part of <db:simplelist><db:member>qtquick-views</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> has a <db:link xlink:href="qml-qtquick-tableview.xml#model-prop">model</db:link> that defines the data to be displayed, and a <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">delegate</db:link> that defines how the data should be displayed.</db:para>
<db:para><db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> inherits <db:link xlink:href="qml-qtquick-flickable.xml">Flickable</db:link>. This means that while the model can have any number of rows and columns, only a subsection of the table is usually visible inside the viewport. As soon as you flick, new rows and columns enter the viewport, while old ones exit and are removed from the viewport. The rows and columns that move out are reused for building the rows and columns that move into the viewport. As such, the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> support models of any size without affecting performance.</db:para>
<db:para>A <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> displays data from models created from built-in QML types such as <db:link xlink:href="qml-qtqml-models-listmodel.xml">ListModel</db:link> and <db:link xlink:href="qml-qtquick-xmllistmodel-xmllistmodel.xml">XmlListModel</db:link>, which populates the first column only in a <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>. To create models with multiple columns, create a model in C++ that inherits QAbstractItemModel, and expose it to QML.</db:para>
<db:section xml:id="example-usage">
<db:title>Example Usage</db:title>
<db:para>The following example shows how to create a model from C++ with multiple columns:</db:para>
<db:programlisting language="cpp">#include &amp;lt;QGuiApplication&amp;gt;
#include &amp;lt;QQmlApplicationEngine&amp;gt;
#include &amp;lt;QAbstractTableModel&amp;gt;

class TableModel : public QAbstractTableModel
{
    Q_OBJECT

public:

    int rowCount(const QModelIndex &amp;amp; = QModelIndex()) const override
    {
        return 200;
    }

    int columnCount(const QModelIndex &amp;amp; = QModelIndex()) const override
    {
        return 200;
    }

    QVariant data(const QModelIndex &amp;amp;index, int role) const override
    {
        switch (role) {
            case Qt::DisplayRole:
                return QString(&quot;%1, %2&quot;).arg(index.column()).arg(index.row());
            default:
                break;
        }

        return QVariant();
    }

    QHash&amp;lt;int, QByteArray&amp;gt; roleNames() const override
    {
        return { {Qt::DisplayRole, &quot;display&quot;} };
    }
};

int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);

    qmlRegisterType&amp;lt;TableModel&amp;gt;(&quot;TableModel&quot;, 0, 1, &quot;TableModel&quot;);

    QQmlApplicationEngine engine;
    engine.load(QUrl(QStringLiteral(&quot;qrc:/main.qml&quot;)));

    return app.exec();
}

#include &quot;main.moc&quot;
</db:programlisting>
<db:para>And then how to use it from QML:</db:para>
<db:programlisting language="qml">import QtQuick 2.12
import TableModel 0.1

TableView {
    anchors.fill: parent
    columnSpacing: 1
    rowSpacing: 1
    clip: true

    model: TableModel {}

    delegate: Rectangle {
        implicitWidth: 100
        implicitHeight: 50
        Text {
            text: display
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="reusing-items">
<db:title>Reusing items</db:title>
<db:para><db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> recycles delegate items by default, instead of instantiating from the <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">delegate</db:link> whenever new rows and columns are flicked into view. This can give a huge performance boost, depending on the complexity of the delegate.</db:para>
<db:para>When an item is flicked out, it moves to the <db:emphasis>reuse pool</db:emphasis>, which is an internal cache of unused items. When this happens, the <db:link xlink:href="qml-qtquick-tableview.xml#pooled-signal">TableView::pooled</db:link> signal is emitted to inform the item about it. Likewise, when the item is moved back from the pool, the <db:link xlink:href="qml-qtquick-tableview.xml#reused-signal">TableView::reused</db:link> signal is emitted.</db:para>
<db:para>Any item properties that come from the model are updated when the item is reused. This includes <db:code>index</db:code>, <db:code>row</db:code>, and <db:code>column</db:code>, but also any model roles.</db:para>
<db:note>
<db:para>Avoid storing any state inside a delegate. If you do, reset it manually on receiving the <db:link xlink:href="qml-qtquick-tableview.xml#reused-signal">TableView::reused</db:link> signal.</db:para>
</db:note>
<db:para>If an item has timers or animations, consider pausing them on receiving the <db:link xlink:href="qml-qtquick-tableview.xml#pooled-signal">TableView::pooled</db:link> signal. That way you avoid using the CPU resources for items that are not visible. Likewise, if an item has resources that cannot be reused, they could be freed up.</db:para>
<db:para>If you don't want to reuse items or if the <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">delegate</db:link> cannot support it, you can set the <db:link xlink:href="qml-qtquick-tableview.xml#reuseItems-prop">reuseItems</db:link> property to <db:code>false</db:code>.</db:para>
<db:note>
<db:para>While an item is in the pool, it might still be alive and respond to connected signals and bindings.</db:para>
</db:note>
<db:para>The following example shows a delegate that animates a spinning rectangle. When it is pooled, the animation is temporarily paused:</db:para>
<db:programlisting language="qml">Component {
    id: tableViewDelegate
    Rectangle {
        implicitWidth: 100
        implicitHeight: 50

        TableView.onPooled: rotationAnimation.pause()
        TableView.onReused: rotationAnimation.resume()

        Rectangle {
            id: rect
            anchors.centerIn: parent
            width: 40
            height: 5
            color: &quot;green&quot;

            RotationAnimation {
                id: rotationAnimation
                target: rect
                duration: (Math.random() * 2000) + 200
                from: 0
                to: 359
                running: true
                loops: Animation.Infinite
            }
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="row-heights-and-column-widths">
<db:title>Row heights and column widths</db:title>
<db:para>When a new column is flicked into view, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will determine its width by calling the <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link> function. <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> itself will never store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</db:para>
<db:para><db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> uses the largest <db:code>implicitWidth</db:code> among the items as the column width, unless the <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link> property is explicitly set. Once the column width is found, all other items in the same column are resized to this width, even if new items that are flicked in later have larger <db:code>implicitWidth</db:code>. Setting an explicit <db:code>width</db:code> on an item is ignored and overwritten.</db:para>
<db:note>
<db:para>The calculated width of a column is discarded when it is flicked out of the viewport, and is recalculated if the column is flicked back in. The calculation is always based on the items that are visible when the column is flicked in. This means that it can end up different each time, depending on which row you're at when the column enters. You should therefore have the same <db:code>implicitWidth</db:code> for all items in a column, or set <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link>. The same logic applies for the row height calculation.</db:para>
</db:note>
<db:para>If you change the values that a <db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link> or a <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link> return for rows and columns inside the viewport, you must call <db:link xlink:href="qml-qtquick-tableview.xml#forceLayout-method">forceLayout</db:link>. This informs <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> that it needs to use the provider functions again to recalculate and update the layout.</db:para>
<db:para>Since Qt 5.13, if you want to hide a specific column, you can return <db:code>0</db:code> from the <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link> for that column. Likewise, you can return 0 from the <db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link> to hide a row. If you return a negative number, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will fall back to calculate the size based on the delegate items.</db:para>
<db:note>
<db:para>The size of a row or column should be a whole number to avoid sub-pixel alignment of items.</db:para>
</db:note>
<db:para>The following example shows how to set a simple <db:code>columnWidthProvider</db:code> together with a timer that modifies the values the function returns. When the array is modified, <db:link xlink:href="qml-qtquick-tableview.xml#forceLayout-method">forceLayout</db:link> is called to let the changes take effect:</db:para>
<db:programlisting language="qml">TableView {
    id: tableView

    property var columnWidths: [100, 50, 80, 150]
    columnWidthProvider: function (column) { return columnWidths[column] }

    Timer {
        running: true
        interval: 2000
        onTriggered: {
            tableView.columnWidths[2] = 150
            tableView.forceLayout();
        }
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="overlays-and-underlays">
<db:title>Overlays and underlays</db:title>
<db:para>Tableview inherits <db:link xlink:href="qml-qtquick-flickable.xml">Flickable</db:link>. And when new items are instantiated from the delegate, it will parent them to the <db:link xlink:href="qml-qtquick-flickable.xml#contentItem-prop">contentItem</db:link> with a <db:code>z</db:code> value equal to <db:code>1</db:code>. You can add your own items inside the Tableview, as child items of the Flickable. By controlling their <db:code>z</db:code> value, you can make them be on top of or underneath the table items.</db:para>
<db:para>Here is an example that shows how to add some text on top of the table, that moves together with the table as you flick:</db:para>
<db:programlisting language="qml">TableView {
    id: tableView

    topMargin: header.implicitHeight

    Text {
        id: header
        text: &quot;A table header&quot;
    }
}
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="columnSpacing-prop">
<db:title>columnSpacing : real</db:title>
<db:fieldsynopsis>
<db:type>real</db:type>
<db:varname>columnSpacing</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the spacing between the columns.</db:para>
<db:para>The default value is 0.</db:para>
</db:section>
<db:section xml:id="columnWidthProvider-prop">
<db:title>columnWidthProvider : var</db:title>
<db:fieldsynopsis>
<db:type>var</db:type>
<db:varname>columnWidthProvider</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property can hold a function that returns the column width for each column in the model. When assigned, it is called whenever <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> needs to know the width of a specific column. The function takes one argument, <db:code>column</db:code>, for which the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> needs to know the width.</db:para>
<db:para>Since Qt 5.13, if you want to hide a specific column, you can return <db:code>0</db:code> width for that column. If you return a negative number, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will fall back to calculate the width based on the delegate items.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="columns-prop">
<db:title>columns : int</db:title>
<db:fieldsynopsis>
<db:type>int</db:type>
<db:varname>columns</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the number of columns in the table. This is equal to the number of columns in the model. If the model is a list, columns will be 1.</db:para>
<db:para>This property is read only.</db:para>
</db:section>
<db:section xml:id="contentHeight-prop">
<db:title>contentHeight : real</db:title>
<db:fieldsynopsis>
<db:type>real</db:type>
<db:varname>contentHeight</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the height of the <db:link xlink:href="qml-qtquick-tableview.xml#view-attached-prop">view</db:link>, which is also the height of the table (including margins). As a <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> cannot always know the exact height of the table without loading all rows in the model, the <db:code>contentHeight</db:code> is usually an estimated height based on the rows it has seen so far. This estimate is recalculated whenever new rows are flicked into view, which means that the content height can change dynamically.</db:para>
<db:para>If you know up front what the height of the table will be, assign a value to <db:code>contentHeight</db:code> explicitly, to avoid unnecessary calculations and updates to the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#contentWidth-prop">contentWidth</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contentWidth-prop">
<db:title>contentWidth : real</db:title>
<db:fieldsynopsis>
<db:type>real</db:type>
<db:varname>contentWidth</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the width of the <db:link xlink:href="qml-qtquick-tableview.xml#view-attached-prop">view</db:link>, which is also the width of the table (including margins). As a <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> cannot always know the exact width of the table without loading all columns in the model, the <db:code>contentWidth</db:code> is usually an estimated width based on the columns it has seen so far. This estimate is recalculated whenever new columns are flicked into view, which means that the content width can change dynamically.</db:para>
<db:para>If you know up front what the width of the table will be, assign a value to <db:code>contentWidth</db:code> explicitly, to avoid unnecessary calculations and updates to the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#contentHeight-prop">contentHeight</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="delegate-prop">
<db:title>delegate : Component</db:title>
<db:fieldsynopsis>
<db:type>Component</db:type>
<db:varname>delegate</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>The delegate provides a template defining each cell item instantiated by the view. The model index is exposed as an accessible <db:code>index</db:code> property. The same applies to <db:code>row</db:code> and <db:code>column</db:code>. Properties of the model are also available depending upon the type of <db:link xlink:href="qtquick-modelviewsdata-modelview.xml#qml-data-models">Data Model</db:link>.</db:para>
<db:para>A delegate should specify its size using <db:link xlink:href="qml-qtquick-item.xml#implicitWidth-prop">implicitWidth</db:link> and <db:link xlink:href="qml-qtquick-item.xml#implicitHeight-prop">implicitHeight</db:link>. The <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> lays out the items based on that information. Explicit width or height settings are ignored and overwritten.</db:para>
<db:note>
<db:para>Delegates are instantiated as needed and may be destroyed at any time. They are also reused if the <db:link xlink:href="qml-qtquick-tableview.xml#reuseItems-prop">reuseItems</db:link> property is set to <db:code>true</db:code>. You should therefore avoid storing state information in the delegates.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reusing-items">Reusing items</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="model-prop">
<db:title>model : model</db:title>
<db:fieldsynopsis>
<db:type>model</db:type>
<db:varname>model</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the model that provides data for the table.</db:para>
<db:para>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using <db:link xlink:href="qml-qtqml-models-listmodel.xml">ListModel</db:link>, <db:link xlink:href="qml-qtquick-xmllistmodel-xmllistmodel.xml">XmlListModel</db:link> or <db:link xlink:href="qml-qtqml-models-objectmodel.xml">ObjectModel</db:link>, or provided by a custom C++ model class. If it is a C++ model, it must be a subclass of QAbstractItemModel or a simple list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-modelviewsdata-modelview.xml#qml-data-models">Data Models</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reuseItems-prop">
<db:title>reuseItems : bool</db:title>
<db:fieldsynopsis>
<db:type>bool</db:type>
<db:varname>reuseItems</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether or not items instantiated from the <db:link xlink:href="qml-qtquick-tableview.xml#delegate-prop">delegate</db:link> should be reused. If set to <db:code>false</db:code>, any currently pooled items are destroyed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reusing-items">Reusing items</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#pooled-signal">TableView::pooled</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reused-signal">TableView::reused</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rowHeightProvider-prop">
<db:title>rowHeightProvider : var</db:title>
<db:fieldsynopsis>
<db:type>var</db:type>
<db:varname>rowHeightProvider</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property can hold a function that returns the row height for each row in the model. When assigned, it will be called whenever <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> needs to know the height of a specific row. The function takes one argument, <db:code>row</db:code>, for which the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> needs to know the height.</db:para>
<db:para>Since Qt 5.13, if you want to hide a specific row, you can return <db:code>0</db:code> height for that row. If you return a negative number, <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> will fall back to calculate the height based on the delegate items.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#row-heights-and-column-widths">Row heights and column widths</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rowSpacing-prop">
<db:title>rowSpacing : real</db:title>
<db:fieldsynopsis>
<db:type>real</db:type>
<db:varname>rowSpacing</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the spacing between the rows.</db:para>
<db:para>The default value is 0.</db:para>
</db:section>
<db:section xml:id="rows-prop">
<db:title>rows : int</db:title>
<db:fieldsynopsis>
<db:type>int</db:type>
<db:varname>rows</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the number of rows in the table. This is equal to the number of rows in the model.</db:para>
<db:para>This property is read only.</db:para>
</db:section>
</db:section>
<db:section xml:id="attached-property-documentation">
<db:title>Attached Property Documentation</db:title>
<db:section xml:id="view-attached-prop">
<db:title>TableView.view : TableView</db:title>
<db:fieldsynopsis>
<db:type>TableView</db:type>
<db:varname>TableView.view</db:varname>
<db:modifier>attached</db:modifier>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This attached property holds the view that manages the delegate instance. It is attached to each instance of the delegate.</db:para>
</db:section>
</db:section>
<db:section xml:id="attached-signal-documentation">
<db:title>Attached Signal Documentation</db:title>
<db:section xml:id="pooled-signal">
<db:title>pooled()</db:title>
<db:para>This signal is emitted after an item has been added to the reuse pool. You can use it to pause ongoing timers or animations inside the item, or free up resources that cannot be reused.</db:para>
<db:para>This signal is emitted only if the <db:link xlink:href="qml-qtquick-tableview.xml#reuseItems-prop">reuseItems</db:link> property is <db:code>true</db:code>.</db:para>
<db:note>
<db:para>The corresponding handler is <db:code>onPooled</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reusing-items">Reusing items</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reuseItems-prop">reuseItems</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reused-signal">reused</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reused-signal">
<db:title>reused()</db:title>
<db:para>This signal is emitted after an item has been reused. At this point, the item has been taken out of the pool and placed inside the content view, and the model properties such as index, row, and column have been updated.</db:para>
<db:para>Other properties that are not provided by the model does not change when an item is reused. You should avoid storing any state inside a delegate, but if you do, manually reset that state on receiving this signal.</db:para>
<db:para>This signal is emitted when the item is reused, and not the first time the item is created.</db:para>
<db:para>This signal is emitted only if the <db:link xlink:href="qml-qtquick-tableview.xml#reuseItems-prop">reuseItems</db:link> property is <db:code>true</db:code>.</db:para>
<db:note>
<db:para>The corresponding handler is <db:code>onReused</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reusing-items">Reusing items</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#reuseItems-prop">reuseItems</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-tableview.xml#pooled-signal">pooled</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="method-documentation">
<db:title>Method Documentation</db:title>
<db:section xml:id="forceLayout-method">
<db:title>forceLayout()</db:title>
<db:para>Responding to changes in the model are batched so that they are handled only once per frame. This means the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> delays showing any changes while a script is being run. The same is also true when changing properties such as <db:link xlink:href="qml-qtquick-tableview.xml#rowSpacing-prop">rowSpacing</db:link> or <db:link xlink:href="qml-qtquick-item.xml#anchors.leftMargin-prop">leftMargin</db:link>.</db:para>
<db:para>This method forces the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> to immediately update the layout so that any recent changes take effect.</db:para>
<db:para>Calling this function re-evaluates the size and position of each visible row and column. This is needed if the functions assigned to <db:link xlink:href="qml-qtquick-tableview.xml#rowHeightProvider-prop">rowHeightProvider</db:link> or <db:link xlink:href="qml-qtquick-tableview.xml#columnWidthProvider-prop">columnWidthProvider</db:link> return different values than what is already assigned.</db:para>
</db:section>
</db:section>
</db:article>
