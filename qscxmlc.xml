<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Using the Qt SCXML Compiler (qscxmlc)</db:title>
<db:productname>QtScxml</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Scxml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Qt SCXML Compiler, <db:code>qscxmlc</db:code>, compiles state chart XML (.scxml) files to C++ source files.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The <db:code>qscxmlc</db:code> tool reads an .scxml file and produces C++ source and header files, containing a class that implements a state machine as defined in SCXML.</db:para>
<db:section xml:id="usage">
<db:title>Usage</db:title>
<db:para>The <db:code>qscxml</db:code> tool is invoked automatically if the QT variable in the project file includes <db:code>scxml</db:code>, and the .scxml file to use is specified using the <db:code>STATECHARTS</db:code> variable.</db:para>
<db:programlisting language="cpp" role="bad">QT += scxml
STATECHARTS = MyStatemachine.scxml
</db:programlisting>
<db:para>With above definitions, <db:code>qmake</db:code> invokes <db:code>qscxmlc</db:code> to generate MyStatemachine.h and MyStatemachine.cpp, and adds them to <db:link xlink:href="qmake-variable-reference.xml#headers">HEADERS</db:link> and <db:link xlink:href="qmake-variable-reference.xml#sources">SOURCES</db:link> variables.</db:para>
<db:para>By default, the name of the generated class that implements the state machine corresponds with the <db:emphasis>name</db:emphasis> attribute of the <db:code>&lt;scxml&gt;</db:code> root element.</db:para>
</db:section>
<db:section xml:id="command-line-options">
<db:title>Command-Line Options</db:title>
<db:para>The <db:code>qscxmlc</db:code> tool supports the following command-line options, which can be specified using the <db:code>QSCXMLC_ARGUMENTS</db:code> variable in the project file:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Option</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:code>--namespace &lt;namespace&gt;</db:code></db:para>
</db:td>
<db:td>
<db:para>Put the generated class(es) in the specified namespace. You can use the <db:code>QSCXMLC_NAMESPACE</db:code> variable to specify this in your project file.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-o &lt;base/out/name&gt;</db:code></db:para>
</db:td>
<db:td>
<db:para>The base name of the output files. This can include a path. If none is specified, the basename of the input file is used.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>--header &lt;header/out&gt;</db:code></db:para>
</db:td>
<db:td>
<db:para>The name of the output header file. If none is specified, .h is added to the base name.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>--impl &lt;cpp/out&gt;</db:code></db:para>
</db:td>
<db:td>
<db:para>The name of the output header file. If none is specified, .cpp is added to the base name.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>--classname &lt;StateMachineClassName&gt;</db:code></db:para>
</db:td>
<db:td>
<db:para>The class name of the generated state machine. If none is specified, the value of the name attribute of the &lt;scxml&gt; tag is taken. If that attribute is not specified either, the basename (excluding path) is taken from the input file name.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>--statemethods</db:code></db:para>
</db:td>
<db:td>
<db:para>Generate extra accessor and signal methods for states. This way you can connect to state changes with plain <db:link xlink:href="qobject.xml#connect">QObject::connect</db:link>() and directly call a method to find out if a state is currently active.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:article>
