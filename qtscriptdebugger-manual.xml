<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Script Debugger Manual</db:title>
<db:productname>QtScript</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>QtScript Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A manual describing how to use the Qt Script debugger.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The <db:link xlink:href="qtscripttools-index.xml">Qt Script Tools</db:link> module provides a debugger for script execution in Qt applications that use <db:link xlink:href="qtscript-index.xml">Qt Script</db:link>. Application developers can embed the debugger into their application through the <db:link xlink:href="qscriptenginedebugger.xml">QScriptEngineDebugger</db:link> class. This manual describes how to use the debugger. We assume that the reader is somewhat familiar with general debugging concepts and existing debugging tools.</db:para>
<db:para>We assume that the debugger has been integrated into the application through the <db:link xlink:href="qscriptenginedebugger.xml#standardWindow">QScriptEngineDebugger::standardWindow</db:link>() function, which provides the standard debugger configuration.</db:para>
<db:section xml:id="getting-started">
<db:title>Getting Started</db:title>
<db:para>The following image shows the debugger as created with <db:link xlink:href="qscriptenginedebugger.xml#standardWindow">standardWindow</db:link>():</db:para>
<db:mediaobject>
<db:alt>Running a script under the Qt Script debugger.</db:alt>
<db:imageobject>
<db:imagedata fileref="images/qtscript-debugger.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The debugger will start, i.e., take control over the script's execution when any of these conditions are met:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The <db:code>debugger</db:code> statement is encountered in the script.</db:para>
</db:listitem>
<db:listitem>
<db:para>Clicking the <db:guilabel>Interrupt</db:guilabel> menu item from the <db:guilabel>Debug</db:guilabel> menu in the main window.</db:para>
</db:listitem>
<db:listitem>
<db:para>A breakpoint is reached.</db:para>
</db:listitem>
<db:listitem>
<db:para>An uncaught script exception is thrown.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Once the debugger is started, the execution state can be inspected, e.g., the value of variables can be queried and the current program stack shown. New breakpoints can be set.</db:para>
<db:para>The debugger will resume, i.e., give the control back to the script engine, when the user clicks <db:guilabel>Continue</db:guilabel> menu item from the <db:guilabel>Debug</db:guilabel> menu. It will be invoked again if one of the conditions described in the list above is met.</db:para>
</db:section>
<db:section xml:id="overview-of-debugger-components">
<db:title>Overview of Debugger Components</db:title>
<db:para>The debugger's functionality is divided into a series of components, each being a widget that can be shown in the main window of the debugger. The following table describes each component and how they relate to each other.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Component</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Console Widget</db:para>
</db:td>
<db:td>
<db:para>The console widget provides a command-line interface to the debugger's functionality, and also serves as an interactive script interpreter. The set of commands and their syntax is inspired by GDB, the GNU Debugger. Commands and script variables are auto-completed through the TAB key.</db:para>
<db:para>Any console command that causes a change in the debugger or debugger target's state will immediately be reflected in the other debugger components (e.g. breakpoints or local variables changed).</db:para>
<db:para>The console provides a simple and powerful way of manipulating the script environment. For example, typing &quot;x&quot; and hitting enter will evaluate &quot;x&quot; in the current stack frame and display the result. Typing &quot;x = 123&quot; will assign the value 123 to the variable <db:code>x</db:code> in the current scope (or create a global variable <db:code>x</db:code> if there isn't one â€“ scripts evaluated through the console can have arbitrary side effects, so be careful).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Stack Widget</db:para>
</db:td>
<db:td>
<db:para>The stack widget shows a backtrace of the script execution state. Each row represents one frame in the stack. A row contains the frame index (0 being the inner-most frame), the name of the script function, and the location (file name and line number). To select a particular stack frame to inspect, click on its row.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Locals Widget</db:para>
</db:td>
<db:td>
<db:para>The locals widget shows the variables that are local to the currently selected stack frame; that is, the properties of the objects in the scope chain and the <db:code>this</db:code>-object. Objects can be expanded, so that their properties can be examined, recursively. Properties whose value has changed are shown in bold font.</db:para>
<db:para>Properties that are not read-only can be edited. Double-click on the value and type in the new value; the value can be an arbitrary expression. The expression will be evaluated in the associated stack frame. While typing, you can press the TAB key to get possible completions for the expression.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Code Widget</db:para>
</db:td>
<db:td>
<db:para>The code widget shows the code of the currently selected script. The widget displays an arrow in the left margin, marking the code line that is being executed. Clicking in the margin of a line will cause a breakpoint to be toggled at that line. A breakpoint has to be set on a line that contains an actual statement in order to be useful.When an uncaught script exception occurs, the offending line will be shown with a red background.</db:para>
<db:para>The code widget is read-only; it cannot currently be used to edit and (re)evaluate scripts. This is however possible from the command-line interface, see <db:link xlink:href="qtscriptdebugger-manual.xml#console-command-reference">Console Command Reference</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Scripts Widget</db:para>
</db:td>
<db:td>
<db:para>The scripts widget shows the scripts that are currently loaded in the script engine. Clicking on a script will cause its code to be shown in the code widget. When a script is no longer referenced by the debugger target it is removed from the scripts widget. Code evaluated through <db:link xlink:href="qscriptengine.xml#evaluate">QScriptEngine::evaluate</db:link>() without a name specified, will be displayed in the widget as Anonymous.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Breakpoints Widget</db:para>
</db:td>
<db:td>
<db:para>The breakpoints widget shows all the breakpoints that are set. A breakpoint can be disabled or enabled by clicking the checkbox next to the breakpoint's ID (the ID is provided so that the breakpoint can be manipulated through the console widget as well).</db:para>
<db:para>A condition can be associated with the breakpoint; the condition can be an arbitrary expression that should evaluate to true or false. The breakpoint will only be triggered when its location is reached <db:emphasis role="bold">and</db:emphasis> the condition evaluates to true.</db:para>
<db:para>Similarly, if the breakpoint's ignore-count is set to N, the breakpoint will be ignored the next N times it is hit.</db:para>
<db:para>A new breakpoint can be set by clicking the New Breakpoint button and typing in a location of the form &lt;filename&gt;<db:emphasis role="bold">:</db:emphasis>&lt;linenumber&gt;. The breakpoint location can refer to an already loaded script, or one that has not been loaded yet.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Debug Output Widget</db:para>
</db:td>
<db:td>
<db:para>The debug output widget shows messages generated by the print() script function. Scripts can use the special variables <db:code>__FILE__</db:code> and <db:code>__LINE__</db:code> to include the current location information in the messages.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Error Log Widget</db:para>
</db:td>
<db:td>
<db:para>The error log widget shows error messages that have been generated. All uncaught exceptions that occur in the engine will appear here.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section xml:id="resuming-script-evaluation">
<db:title>Resuming Script Evaluation</db:title>
<db:para>Script evaluation can be resumed in one of the following ways:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:emphasis role="bold">Continue</db:emphasis>: Evaluation will resume normally.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Step Into</db:emphasis>: Evaluation will resume until the next statement is reached.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Step Over</db:emphasis>: Evaluation will resume until the next statement is reached; but if the current statement is a function call, the debugger will treat it as a single statement.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Step Out</db:emphasis>: Evaluation will resume until the current function exits and the next statement is reached.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Run to Cursor</db:emphasis>: Run until the statement at the cursor is reached.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Run to New Script</db:emphasis>: Run until the first statement of a new script is reached.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In any case, script evaluation can also be stopped due to either of the following reasons:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>A <db:code>debugger</db:code> statement is encountered.</db:para>
</db:listitem>
<db:listitem>
<db:para>A breakpoint is hit.</db:para>
</db:listitem>
<db:listitem>
<db:para>An uncaught script exception occurs.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="resuming-after-an-uncaught-exception">
<db:title>Resuming After an Uncaught Exception</db:title>
<db:para>When an uncaught script exception occurs, it is not possible to continue evaluating the current function normally. However, you can use the console command <db:emphasis role="bold">return</db:emphasis> to catch the exception and return a value to the calling function.</db:para>
</db:section>
</db:section>
<db:section xml:id="console-command-reference">
<db:title>Console Command Reference</db:title>
<db:para>Note that you can also get help on the available commands by typing &quot;.help&quot; in the console.</db:para>
<db:section xml:id="breakpoint-related-commands">
<db:title>Breakpoint-related Commands</db:title>
<db:para>Break points is set</db:para>
<db:section xml:id="break-location">
<db:title>break &lt;location&gt;</db:title>
<db:para>Sets a breakpoint at a given code line.</db:para>
<db:programlisting language="cpp">.break foo.qs:123
</db:programlisting>
<db:para>This command sets a breakpoint at <db:code>foo.qs</db:code>, line 123.</db:para>
<db:programlisting language="cpp">.break 123
</db:programlisting>
<db:para>This command sets a breakpoint at line 123 in the current script; the current script is the script associated with the current stack frame.</db:para>
<db:para>Each breakpoint has a unique identifier (an integer) associated with it. This identifier is needed by other breakpoint-related commands.</db:para>
</db:section>
<db:section xml:id="clear-location">
<db:title>clear &lt;location&gt;</db:title>
<db:programlisting language="cpp">.clear foo.qs:123
</db:programlisting>
<db:para>clears (deletes) the breakpoint at <db:code>foo.qs</db:code>, line 123.</db:para>
<db:programlisting language="cpp">clear 123
</db:programlisting>
<db:para>clears (deletes) the breakpoint at line 123 in the current script; the current script is the script associated with the current stack frame.</db:para>
</db:section>
<db:section xml:id="condition-breakpoint-id-expression">
<db:title>condition &lt;breakpoint-id&gt; &lt;expression&gt;</db:title>
<db:para>Sets a condition for a breakpoint.</db:para>
<db:programlisting language="cpp">.condition 1 i &gt; 42
</db:programlisting>
<db:para>specifies that breakpoint 1 should only be triggered if the variable <db:code>i</db:code> is greater than 42.</db:para>
<db:para>The expression can be an arbitrary one, i.e. it can have side-effects. It can be any valid QScript conditional expression.</db:para>
</db:section>
<db:section xml:id="delete-breakpoint-id">
<db:title>delete &lt;breakpoint-id&gt;</db:title>
<db:para>Deletes a breakpoint, i.e., removes it from the current debugging session.</db:para>
</db:section>
<db:section xml:id="disable-breakpoint-id">
<db:title>disable &lt;breakpoint-id&gt;</db:title>
<db:para>Disables a breakpoint. The breakpoint will continue to exist, but will not stop program execution.</db:para>
</db:section>
<db:section xml:id="enable-breakpoint-id">
<db:title>enable &lt;breakpoint-id&gt;</db:title>
<db:para>Enables a breakpoint. Breakpoints are enabled by default, so you only need to use this command if you have disabled to breakpoint previously.</db:para>
</db:section>
<db:section xml:id="ignore-breakpoint-id-count">
<db:title>ignore &lt;breakpoint-id&gt; &lt;count&gt;</db:title>
<db:para>Sets the ignore-count of a breakpoint, i.e., the breakpoint will not stop the program execution unless it have been reached <db:code>count</db:code> times. This can, for instance, be useful in loops to stop at a specific iteration.</db:para>
<db:programlisting language="cpp">.ignore 1 5
</db:programlisting>
<db:para>Specifies that breakpoint 1 should be ignored the next 5 times it is hit.</db:para>
</db:section>
<db:section xml:id="info-breakpoints">
<db:title>info breakpoints</db:title>
<db:para>Lists the breakpoints that are set.</db:para>
<db:programlisting language="cpp">.info breakpoints
</db:programlisting>
</db:section>
<db:section xml:id="tbreak-location">
<db:title>tbreak &lt;location&gt;</db:title>
<db:para>Sets a temporary breakpoint. This command is identical to the <db:code>break</db:code> command, only the breakpoint will be automatically deleted the first time it is hit.</db:para>
</db:section>
</db:section>
<db:section xml:id="file-related-commands">
<db:title>File-related Commands</db:title>
<db:section xml:id="list-location">
<db:title>list &lt;location&gt;</db:title>
<db:para>Lists the contents of a script around a given location, where the location is given as a line number and, optionally, the name of the file from which you will print. If only a line number is given, <db:code>.list</db:code> will use the file of the current stack frame.</db:para>
<db:programlisting language="cpp">.list foo.qs:125
</db:programlisting>
<db:para>When no arguments are given, <db:code>list</db:code> will incrementally list sections of the current script.</db:para>
</db:section>
<db:section xml:id="info-scripts">
<db:title>info scripts</db:title>
<db:para>Lists the scripts that are currently loaded.</db:para>
</db:section>
</db:section>
<db:section xml:id="execution-related-commands">
<db:title>Execution-related Commands</db:title>
<db:section xml:id="advance-location">
<db:title>advance &lt;location&gt;</db:title>
<db:para>Advances execution to a given location. The syntax of the location is the same as for setting breakpoints. For example:</db:para>
<db:programlisting language="cpp">.advance foo.qs:125
</db:programlisting>
</db:section>
<db:section xml:id="continue">
<db:title>continue</db:title>
<db:para>Continues execution normally, i.e, gives the execution control over the script back to the <db:link xlink:href="qscriptengine.xml">QScriptEngine</db:link>.</db:para>
</db:section>
<db:section xml:id="eval-program">
<db:title>eval &lt;program&gt;</db:title>
<db:para>Evaluates a program.</db:para>
</db:section>
<db:section xml:id="finish">
<db:title>finish</db:title>
<db:para>Continues execution until the current function exits and the next statement is reached (i.e., the statement after the call to the function).</db:para>
</db:section>
<db:section xml:id="interrupt">
<db:title>interrupt</db:title>
<db:para>Requests that execution should be interrupted. Interruption will occur as soon as a new script statement is reached.</db:para>
</db:section>
<db:section xml:id="next-count-1">
<db:title>next &lt;count = 1&gt;</db:title>
<db:para>Continues execution until a new statement is reached; but if the current statement is a function call, the function call will be treated as a single statement. This will be done <db:code>count</db:code> times before execution is stopped; the default is one.</db:para>
</db:section>
<db:section xml:id="return-expression">
<db:title>return &lt;expression&gt;</db:title>
<db:para>Makes the current frame return to its caller. If <db:code>expression</db:code> is given, it will sent as the result of the function (i.e., replacing the functions return value). <db:code>expression</db:code> can be any valid QScript expression.</db:para>
</db:section>
<db:section xml:id="step-count-1">
<db:title>step &lt;count = 1&gt;</db:title>
<db:para>Continues execution until a new statement is reached. If the number <db:code>count</db:code> is given as argument, this will be done <db:code>count</db:code> times before execution is stopped. As opposed to <db:link xlink:href="qtscriptdebugger-manual.xml#next-count-1">next &lt;count = 1&gt;</db:link>, <db:code>step</db:code> will enter functions when encountering a function call statement.</db:para>
</db:section>
</db:section>
<db:section xml:id="stack-related-commands">
<db:title>Stack-related Commands</db:title>
<db:section xml:id="backtrace">
<db:title>backtrace</db:title>
<db:para>Shows a backtrace of the current execution. The trace will list the function name and its position in the script for each stack frame.</db:para>
</db:section>
<db:section xml:id="down">
<db:title>down</db:title>
<db:para>Selects the previous (inner) stack frame. The execution will not return to this frame, but you will get access to its local variables.</db:para>
</db:section>
<db:section xml:id="frame-index">
<db:title>frame &lt;index&gt;</db:title>
<db:para>This command moves to the stack frame with the given <db:code>index</db:code>. The index of the frame on the top of the stack is 0. Previous frames are numbered from 1 and upwards (the bottom frame in the stack has the largest index).</db:para>
</db:section>
<db:section xml:id="info-locals">
<db:title>info locals</db:title>
<db:para>Lists the variables that are in the scope of the current frame.</db:para>
</db:section>
<db:section xml:id="up">
<db:title>up</db:title>
<db:para>Selects the next (outer) stack frame.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
