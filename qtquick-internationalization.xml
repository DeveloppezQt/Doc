<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Internationalization and Localization with Qt Quick</db:title>
<db:productname>QtDoc</db:productname>
<db:edition>Qt 5.11.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Following these steps, you can write your Qt Quick application so it can be localized for multiple languages.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="internationalizing-your-application">
<db:title>Internationalizing Your Application</db:title>
<db:para>The following sections describe various aspects of internationalizing your QML source code. If you follow these guides for all the user interface components in your application, it becomes possible to localize every aspect of your application for different languages and local cultural conventions such as the way dates and numbers are formatted.</db:para>
<db:section xml:id="A1-use-qstr-for-all-literal-user-interface-strings">
<db:title>1. Use qsTr() for all Literal User Interface Strings</db:title>
<db:para>Strings in QML can be marked for translation using the qsTr(), qsTranslate(), qsTrId(), <db:link xlink:href="qtglobal.xml#QT_TR_NOOP">QT_TR_NOOP</db:link>(), <db:link xlink:href="qtglobal.xml#QT_TRANSLATE_NOOP">QT_TRANSLATE_NOOP</db:link>(), and <db:link xlink:href="qtglobal.xml#QT_TRID_NOOP">QT_TRID_NOOP</db:link>() functions. The most common way of marking strings is with the qsTr() function. For example:</db:para>
<db:programlisting language="cpp">Text {
    id: txt1;
    text: qsTr(&quot;Back&quot;);
}
</db:programlisting>
<db:para>This code makes &quot;Back&quot; a key entry in the translation files. At runtime, the translation system looks up the keyword &quot;Back&quot; and then gets the corresponding translation value for the current system locale. The result is returned to the text property and the user interface will show the appropriate translation of &quot;Back&quot; for the current locale.</db:para>
</db:section>
<db:section xml:id="A2-add-context-for-the-translator">
<db:title>2. Add Context for the Translator</db:title>
<db:para>User interface strings are often short so you need to help the person translating the text understand the context of the text. You can add context information in the source code as extra descriptive text before the string to be translated. These extra descriptions are included in the .ts translation files delivered to the translator.</db:para>
<db:note>
<db:para>The .ts files are XML files with the source texts and a place for the translated text. The updated .ts files are converted into binary translation files and included as part of the final application.</db:para>
</db:note>
<db:para>In the following code snippet, the text on the //: line is the main comment for the translator.</db:para>
<db:para>The text on the //~ line is optional extra information. The first word of the text is used as an additional identifier in the XML element in the .ts file so make sure the first word is not part of the sentence. For example, the comment &quot;Context Not related to that&quot; is converted to &quot;&lt;extra-Context&gt;Not related to that&quot; in the .ts file.</db:para>
<db:programlisting language="cpp">Text {
    id: txt1;
    // This user interface string is only used here
    //: The back of the object, not the front
    //~ Context Not related to back-stepping
    text: qsTr(&quot;Back&quot;);
}
</db:programlisting>
</db:section>
<db:section xml:id="A3-disambiguate-identical-texts">
<db:title>3. Disambiguate Identical Texts</db:title>
<db:para>The translation system consolidates the user interface text strings into unique items. This consolidation saves the person doing the translation work having to translate the same text multiple times. However, in some cases, the text is identical but has a different meaning. For example, in English, &quot;back&quot; means take a step backward and also means the part of an object opposite to the front. You need to tell the translation system about these two separate meanings so the translator can create two separate translations.</db:para>
<db:para>Differentiate between identical texts by adding some id text as the second parameter of the qsTr() function.</db:para>
<db:para>In the following code snippet, the not front text is an id to differentiate this &quot;Back&quot; text from the backstepping &quot;Back&quot; text:</db:para>
<db:programlisting language="cpp">Text {
    id: txt1;
    // This user interface string is used only here
    //: The back of the object, not the front
    //~ Context Not related to back-stepping
    text: qsTr(&quot;Back&quot;, &quot;not front&quot;);
}
</db:programlisting>
</db:section>
<db:section xml:id="A4-use-op-op-x-to-insert-parameters-into-a-string">
<db:title>4. Use %x to Insert Parameters into a String</db:title>
<db:para>Different languages put words together in different orders so it is not a good idea to create sentences by concatenating words and data. Instead, use % to insert parameters into strings. For example, the following snippet has a string with two number parameters %1 and %2. These parameters are inserted with the .arg() functions.</db:para>
<db:programlisting language="cpp">Text {
    text: qsTr(&quot;File %1 of %2&quot;).arg(counter).arg(total)
}
</db:programlisting>
<db:para>%1 refers to the first parameter and %2 refers to the second parameter so this code produces output like: &quot;File 2 of 3&quot;.</db:para>
</db:section>
<db:section xml:id="A5-use-lx-so-numbers-are-localized">
<db:title>5. Use %Lx so Numbers are Localized</db:title>
<db:para>If you include the %L modifier when you specify a parameter, the number is localized according to the current regional settings. For example, in the following code snippet, %L1 means to format the first parameters according to the number formatting conventions of the currently selected locale (geographical region):</db:para>
<db:programlisting language="cpp">Text {
    text: qsTr(&quot;%L1&quot;).arg(total)
}
</db:programlisting>
<db:para>Then, with the above code, if total is the number &quot;4321.56&quot; (four thousand three hundred and twenty one point fifty six); with English regional settings, (locale) the output is &quot;4,321.56&quot;; with German regional settings, the output is &quot;4.321,56&quot;.</db:para>
</db:section>
<db:section xml:id="A6-internationalize-dates-times-and-currencies">
<db:title>6. Internationalize Dates, Times and Currencies</db:title>
<db:para>There are no special in-string modifiers for formatting dates and times. Instead, you need to query the current locale (geographical region) and use the methods of <db:link xlink:href="qml-qtqml-date.xml">Date</db:link> to format the string.</db:para>
<db:para>Qt.locale() returns a <db:link xlink:href="qml-qtqml-locale.xml">Locale</db:link> object which contains all kinds of information about the locale. In particular, the <db:link xlink:href="qml-qtqml-locale.xml#name-prop">Locale.name</db:link> property contains the language and country information for the current locale. You can use the value as is, or you can parse it to determine the appropriate content for the current locale.</db:para>
<db:para>The following snippet gets the current date and time with Date(), then converts that to a string for the current locale. Then it inserts the date string into the %1 parameter for the appropriate translation.</db:para>
<db:programlisting language="cpp">Text {
    text: qsTr(&quot;Date %1&quot;).arg(Date().toLocaleString(Qt.locale()))
}
</db:programlisting>
<db:para>To make sure currency numbers are localized, use the <db:link xlink:href="qml-qtqml-number.xml">Number</db:link> type. This type has similar functions as the Date type for converting numbers into localized currency strings.</db:para>
</db:section>
<db:section xml:id="A7-use-qt-tr-noop-for-translatable-data-text-strings">
<db:title>7. Use QT_TR_NOOP() for Translatable Data Text Strings</db:title>
<db:para>If the user changes the system language without a reboot, depending on the system, the strings in arrays and list models and other data structures might not be refreshed automatically. To force the texts to be refreshed when they are displayed in the user interface, you need to declare the strings with the <db:link xlink:href="qtglobal.xml#QT_TR_NOOP">QT_TR_NOOP</db:link>() macro. Then, when you populate the objects for display, you need to explicitly retrieve the translation for each text. For example:</db:para>
<db:programlisting language="cpp">ListModel {
    id: myListModel;
    ListElement {
        //: Capital city of Finland
        name: QT_TR_NOOP(&quot;Helsinki&quot;);
        }
    }

...

Text {
    text: qsTr(myListModel.get(0).name); // get the translation of the name property in element 0
    }
</db:programlisting>
</db:section>
<db:section xml:id="A8-use-locale-to-extend-localization-features">
<db:title>8. Use Locale to Extend Localization Features</db:title>
<db:para>If you want different graphics or audio for different geographical regions, you can use Qt.locale() to get the current locale. Then you choose appropriate graphics or audio for that locale.</db:para>
<db:para>The following code snippet shows how you could select an appropriate icon that represents the language of the current locale.</db:para>
<db:programlisting language="cpp">Component.onCompleted: {
    switch (Qt.locale().name.substring(0,2)) {
        case &quot;en&quot;:   // show the English-language icon
            languageIcon = &quot;../images/language-icon_en.png&quot;;
            break;
        case &quot;fi&quot;:   // show the Finnish language icon
            languageIcon = &quot;../images/language-icon_fi.png&quot;;
            break;
        default:     // show a default language icon
            languageIcon = &quot;../images/language-icon_default.png&quot;;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="A9-prepare-for-dynamic-language-changes">
<db:title>9. Prepare for Dynamic Language Changes</db:title>
<db:para>You can change the language that Qt translation functions use by adding and removing translators with <db:link xlink:href="qcoreapplication.xml#installTranslator">QCoreApplication::installTranslator</db:link>() and <db:link xlink:href="qcoreapplication.xml#removeTranslator">QCoreApplication::removeTranslator</db:link>(). Afterwards you can call <db:link xlink:href="qqmlengine.xml#retranslate">QQmlEngine::retranslate</db:link>() to trigger a refresh of all bindings that use translations. As a result, your user interface will switch, dynamically, to the newly selected language.</db:para>
<db:para>Alternatively, you can also forward a <db:link xlink:href="qevent.xml#Type-enum">QEvent::LanguageChange</db:link> event to your application's <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> instance or connect your own signal to <db:link xlink:href="qqmlengine.xml#retranslate">QQmlEngine::retranslate</db:link>().</db:para>
</db:section>
</db:section>
<db:section xml:id="localizing-your-application">
<db:title>Localizing Your Application</db:title>
<db:para>Qt Quick applications use the same underlying localization system as Qt C++ applications (lupdate, lrelease and .ts files). You use the same tools as described in the <db:link xlink:href="linguist-manager.xml">Qt Linguist Manual</db:link>. You can even have user interface strings in C++ and QML source in the same application. The system will create a single combined translation file and the strings are accessible from QML and C++.</db:para>
<db:section xml:id="use-a-conditional-to-hide-qml-source-from-the-compiler">
<db:title>Use a Conditional to Hide QML Source From the Compiler</db:title>
<db:para>The lupdate tool extracts user interface strings from your application. lupdate reads your application's .pro file to identify which source files contain texts to be translated. This means your source files must be listed in the SOURCES or HEADERS entry in the .pro file. If your files are not listed the texts in them will not be found.</db:para>
<db:para>However, the SOURCES variable is intended for C++ source files. If you list QML or JavaScript source files there, the compiler tries to build them as though they are C++ files. As a workaround, you can use an lupdate_only{...} conditional statement so the lupdate tool sees the .qml files but the C++ compiler ignores them.</db:para>
<db:para>For example, the following .pro file snippet specifies two .qml files in the application.</db:para>
<db:programlisting language="cpp">lupdate_only{
SOURCES = main.qml \
          MainPage.qml
}
</db:programlisting>
<db:para>You can also specify the .qml source files with a wildcard match. The search is not recursive so you need to specify each directory where there are user interface strings in the source code:</db:para>
<db:programlisting language="cpp">lupdate_only{
SOURCES = *.qml \
          *.js \
          content/*.qml \
          content/*.js
}
</db:programlisting>
<db:para>See the <db:link xlink:href="qtlinguist-index.xml">Qt Linguist Manual</db:link> for more details about Qt localization.</db:para>
</db:section>
</db:section>
</db:article>
