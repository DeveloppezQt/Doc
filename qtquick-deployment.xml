<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Deploying QML Applications</db:title>
<db:productname>QtDoc</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Deploying QML applications.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>QML documents are loaded and executed by the QML runtime. This includes the Declarative UI engine along with the built-in QML types and plugin modules, and it also provides access to third-party QML types and modules.</db:para>
<db:para>Applications that use QML need to invoke the QML runtime in order to execute QML documents. This can be done by creating a <db:link xlink:href="qquickview.xml">QQuickView</db:link> or a <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>, as described below. In addition, the Declarative UI package includes the qmlscene tool, which loads .qml files. This tool is useful for developing and testing QML code without the need to write a C++ application to load the QML runtime.</db:para>
<db:section xml:id="deploying-applications-with-qt-creator">
<db:title>Deploying Applications with Qt Creator</db:title>
<db:para><db:link xlink:href="http://doc.qt.io/qtcreator/index.html">Qt Creator</db:link> deploys and packages QML applications to various platforms. For mobile devices, Qt Creator can directly bundle applications to the respective platform package formats such as APK and BAR.</db:para>
<db:para>For more information, visit:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="deployment.xml">Deploying Qt Applications</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="http://doc.qt.io/qtcreator/creator-running-targets.html">Running on Multiple Platforms</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="http://doc.qt.io/qtcreator/creator-deployment.html">Deploying to Mobile Devices</db:link></db:para>
</db:listitem>
</db:itemizedlist>
<db:para>When running applications on the target platform, the application needs to access the location of the QML libraries. When using <db:link xlink:href="qmake-manual.xml">qmake</db:link>, the QT_INSTALL_QML environment points to the location of the libraries. The <db:link xlink:href="http://qt.io/download">Qt Installers</db:link> install the QML libraries in <db:emphasis>&lt;version&gt;</db:emphasis>/<db:emphasis>&lt;compiler&gt;</db:emphasis>/qml directory.</db:para>
</db:section>
<db:section xml:id="prototyping-with-qml-scene">
<db:title>Prototyping with QML Scene</db:title>
<db:para>The Declarative UI package includes a QML runtime tool, <db:link xlink:href="qtquick-qmlscene.xml">qmlscene</db:link>, which loads and displays QML documents. This is useful during the application development phase for prototyping QML-based applications without writing your own C++ applications to invoke the QML runtime.</db:para>
</db:section>
<db:section xml:id="initializing-the-qml-runtime-in-applications">
<db:title>Initializing the QML Runtime in Applications</db:title>
<db:para>To run an application that uses QML, the QML runtime must be invoked by the application. This is done by writing a Qt C++ application that loads the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> by either:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Loading the QML file through a <db:link xlink:href="qquickview.xml">QQuickView</db:link> instance, or</db:para>
</db:listitem>
<db:listitem>
<db:para>Creating a <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> instance and loading QML files with <db:link xlink:href="qqmlcomponent.xml">QQmlComponent</db:link></db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="initializing-with-qquickview">
<db:title>Initializing with QQuickView</db:title>
<db:para><db:link xlink:href="qquickview.xml">QQuickView</db:link> is a <db:link xlink:href="qwindow.xml">QWindow</db:link>-based class that is able to load QML files. For example, if there is a QML file, application.qml, it will look like this:</db:para>
<db:programlisting language="qml">import QtQuick 2.3

Rectangle { width: 100; height: 100; color: &quot;red&quot; }
</db:programlisting>
<db:para>It can be loaded in a Qt application's main.cpp file like this:</db:para>
<db:programlisting language="cpp">#include &lt;QGuiApplication&gt;
#include &lt;QQuickView&gt;

int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);

    QQuickView view;
    view.setSource(QUrl::fromLocalFile(&quot;application.qml&quot;));
    view.show();

    return app.exec();
}
</db:programlisting>
<db:para>This creates a <db:link xlink:href="qwindow.xml">QWindow</db:link>-based view that displays the contents of application.qml.</db:para>
<db:para>The application's .pro <db:link xlink:href="qmake-project-files.xml">project file</db:link> must specify the declarative module for the QT variable. For example:</db:para>
<db:programlisting language="cpp">TEMPLATE += app
QT += quick
SOURCES += main.cpp
</db:programlisting>
</db:section>
<db:section xml:id="creating-a-qqmlengine-directly">
<db:title>Creating a QQmlEngine directly</db:title>
<db:para>If application.qml does not have any graphical components, or if it is preferred to avoid <db:link xlink:href="qquickview.xml">QQuickView</db:link> for other reasons, the <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> can be constructed directly instead. In this case, application.qml is loaded as a <db:link xlink:href="qqmlcomponent.xml">QQmlComponent</db:link> instance rather than placed into a view:</db:para>
<db:programlisting language="cpp">#include &lt;QGuiApplication&gt;
#include &lt;QQmlEngine&gt;
#include &lt;QQmlContext&gt;
#include &lt;QQmlComponent&gt;

int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);

    QQmlEngine engine;
    QQmlContext *objectContext = new QQmlContext(engine.rootContext());

    QQmlComponent component(&amp;engine, &quot;application.qml&quot;);
    QObject *object = component.create(objectContext);

    // ... delete object and objectContext when necessary

    return app.exec();
}
</db:programlisting>
<db:para><db:link xlink:href="qguiapplication.xml">QGuiApplication</db:link> can be replaced by a <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link> in the code above in case you are not using any graphical items from Qt Quick. This allows using QML as a language without any dependencies to the <db:link xlink:href="qtgui-index.xml">Qt GUI</db:link> module.</db:para>
<db:para>See <db:link xlink:href="qtqml-cppintegration-data.xml">qtqml-cppintegration-exposecppattributes.html</db:link>{Exposing Attributes of C++ Types to QML} for more information about using <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link>, <db:link xlink:href="qqmlcontext.xml">QQmlContext</db:link> and <db:link xlink:href="qqmlcomponent.xml">QQmlComponent</db:link>, as well as details on including QML files through <db:link xlink:href="resources.xml">Qt's Resource system</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="managing-resource-files-with-the-qt-resource-system">
<db:title>Managing Resource Files with the Qt Resource System</db:title>
<db:para>The <db:link xlink:href="resources.xml">Qt resource system</db:link> allows resource files to be stored as binary files in an application executable. This can be useful when building a mixed QML/C++ application as it enables QML files (as well as other resources such as images and sound files) to be referred to through the resource system URI scheme rather than relative or absolute paths to filesystem resources. Note, however, that if you use the resource system, the application executable must be re-compiled whenever a QML source file is changed in order to update the resources in the package.</db:para>
<db:para>To use the resource system in a mixed QML/C++ application:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Create a .qrc <db:link xlink:href="resources.xml">resource collection file</db:link> that lists resource files in XML format</db:para>
</db:listitem>
<db:listitem>
<db:para>From C++, load the main QML file as a resource using the :/ prefix or as a URL with the qrc scheme</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Once this is done, all files specified by relative paths in QML will be loaded from the resource system instead. Use of the resource system is completely transparent to the QML layer; this means all QML code should refer to resource files using relative paths and should <db:emphasis>not</db:emphasis> use the qrc scheme. This scheme should only be used from C++ code for referring to resource files.</db:para>
<db:para>Here is a application packaged using the <db:link xlink:href="resources.xml">Qt resource system</db:link>. The directory structure looks like this:</db:para>
<db:programlisting language="cpp">project
    |- example.qrc
    |- main.qml
    |- images
        |- background.png
    |- main.cpp
    |- project.pro
</db:programlisting>
<db:para>The main.qml and background.png files will be packaged as resource files. This is done in the example.qrc resource collection file:</db:para>
<db:programlisting language="cpp">&lt;!DOCTYPE RCC&gt;
&lt;RCC version=&quot;1.0&quot;&gt;

&lt;qresource prefix=&quot;/&quot;&gt;
    &lt;file&gt;main.qml&lt;/file&gt;
    &lt;file&gt;images/background.png&lt;/file&gt;
&lt;/qresource&gt;

&lt;/RCC&gt;

</db:programlisting>
<db:para>Since background.png is a resource file, main.qml can refer to it using the relative path specified in example.qrc:</db:para>
<db:programlisting language="qml">// main.qml
import QtQuick 2.3

Image { source: &quot;images/background.png&quot; }
</db:programlisting>
<db:para>To allow QML to locate resource files correctly, the main.cpp loads the main QML file, main.qml, as a resource file using the qrc scheme:</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    QQuickView view;
    view.setSource(QUrl(&quot;qrc:/main.qml&quot;));
    view.show();

    return app.exec();
}
</db:programlisting>
<db:para>Finally, project.pro uses the RESOURCES variable to indicate that example.qrc should be used to build the application resources:</db:para>
<db:programlisting language="cpp">QT += qml

SOURCES += main.cpp
RESOURCES += example.qrc

</db:programlisting>
<db:para>See <db:link xlink:href="resources.xml">The Qt Resource System</db:link> for more information.</db:para>
</db:section>
</db:article>
