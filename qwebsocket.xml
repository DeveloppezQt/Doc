<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QWebSocket Class</db:title>
<db:productname>QtWebSockets</db:productname>
<db:edition>Qt 6.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt WebSockets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Implements a TCP socket that talks the WebSocket protocol.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QWebSocket</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS WebSockets)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::WebSockets)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += websockets</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>WebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</db:link> in 2011. <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> can both be used in a client application and server application.</db:para>
<db:para>This class was modeled after <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link>.</db:para>
<db:para><db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> currently does not support <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc6455#section-9">WebSocket Extensions</db:link>.</db:para>
<db:para><db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> only supports version 13 of the WebSocket protocol, as outlined in <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</db:link>.</db:para>
<db:note>
<db:para>Some proxies do not understand certain HTTP headers used during a WebSocket handshake. In that case, non-secure WebSocket connections fail. The best way to mitigate against this problem is to use WebSocket over a secure connection.</db:para>
</db:note>
<db:warning>
<db:para>To generate masks, this implementation of WebSockets uses the reasonably secure <db:link xlink:href="qrandomgenerator.xml#global">QRandomGenerator::global</db:link>()-&gt;generate() function. For more information about the importance of good masking, see <db:link xlink:href="https://www.ieee-security.org/TC/W2SP/2011/papers/websocket.pdf">&quot;Talking to Yourself for Fun and Profit&quot; by Lin-Shung Huang et al</db:link>. The best measure against attacks mentioned in the document above, is to use <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> over a secure connection (<db:emphasis>wss://</db:emphasis>). In general, always be careful to not have 3rd party script access to a <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> in your application.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:member>
<db:member><db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link></db:member>
<db:member><db:link xlink:href="echoclient.xml">QWebSocket client example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QWebSocket-1">
<db:title>[explicit] QWebSocket::QWebSocket(const QString &amp;<db:emphasis>origin</db:emphasis> = QString(), QWebSocketProtocol::Version <db:emphasis>version</db:emphasis> = QWebSocketProtocol::VersionLatest, QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QWebSocket</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>origin</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QWebSocketProtocol::Version</db:type>
<db:parameter>version</db:parameter>
<db:initializer>QWebSocketProtocol::VersionLatest</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QWebSocket(const QString &amp;origin, QWebSocketProtocol::Version version, QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a new <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> with the given <db:code role="parameter">origin</db:code>, the <db:code role="parameter">version</db:code> of the protocol to use and <db:code role="parameter">parent</db:code>.</db:para>
<db:para>The <db:code role="parameter">origin</db:code> of the client is as specified in <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc6454">RFC 6454</db:link>. (The <db:code role="parameter">origin</db:code> is not required for non-web browser clients (see <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</db:link>)). The <db:code role="parameter">origin</db:code> may not contain new line characters, otherwise the connection will be aborted immediately during the handshake phase.</db:para>
<db:note>
<db:para>Currently only V13 (<db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</db:link>) is supported</db:para>
</db:note>
</db:section>
<db:section xml:id="dtor.QWebSocket">
<db:title>[override virtual] QWebSocket::~QWebSocket()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QWebSocket</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QWebSocket() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link>. Closes the socket if it is still open, and releases any used resources.</db:para>
</db:section>
<db:section xml:id="abort">
<db:title>void QWebSocket::abort()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>abort</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void abort()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Aborts the current socket and resets the socket. Unlike <db:link xlink:href="qwebsocket.xml#close">close</db:link>(), this function immediately closes the socket, discarding any pending data in the write buffer.</db:para>
</db:section>
<db:section xml:id="aboutToClose">
<db:title>void QWebSocket::aboutToClose()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>aboutToClose</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void aboutToClose()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the socket is about to close. Connect this signal if you have operations that need to be performed before the socket closes (e.g., if you have data in a separate buffer that needs to be written to the device).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="alertReceived">
<db:title>[since 6.2] void QWebSocket::alertReceived(QSsl::AlertLevel <db:emphasis>level</db:emphasis>, QSsl::AlertType <db:emphasis>type</db:emphasis>, const QString &amp;<db:emphasis>description</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>alertReceived</db:methodname>
<db:methodparam>
<db:type>QSsl::AlertLevel</db:type>
<db:parameter>level</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSsl::AlertType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>description</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void alertReceived(QSsl::AlertLevel level, QSsl::AlertType type, const QString &amp;description)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> emits this signal if an alert message was received from a peer. <db:code role="parameter">level</db:code> tells if the alert was fatal or it was a warning. <db:code role="parameter">type</db:code> is the code explaining why the alert was sent. When a textual description of the alert message is available, it is supplied in <db:code role="parameter">description</db:code>.</db:para>
<db:note>
<db:para>The signal is mostly for informational and debugging purposes and does not require any handling in the application. If the alert was fatal, underlying backend will handle it and close the connection.</db:para>
</db:note>
<db:note>
<db:para>Not all backends support this functionality.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#alertSent">alertSent</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#AlertLevel-enum">QSsl::AlertLevel</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml#AlertType-enum">QSsl::AlertType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="alertSent">
<db:title>[since 6.2] void QWebSocket::alertSent(QSsl::AlertLevel <db:emphasis>level</db:emphasis>, QSsl::AlertType <db:emphasis>type</db:emphasis>, const QString &amp;<db:emphasis>description</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>alertSent</db:methodname>
<db:methodparam>
<db:type>QSsl::AlertLevel</db:type>
<db:parameter>level</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSsl::AlertType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>description</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void alertSent(QSsl::AlertLevel level, QSsl::AlertType type, const QString &amp;description)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> emits this signal if an alert message was sent to a peer. <db:code role="parameter">level</db:code> describes if it was a warning or a fatal error. <db:code role="parameter">type</db:code> gives the code of the alert message. When a textual description of the alert message is available, it is supplied in <db:code role="parameter">description</db:code>.</db:para>
<db:note>
<db:para>This signal is mostly informational and can be used for debugging purposes, normally it does not require any actions from the application.</db:para>
</db:note>
<db:note>
<db:para>Not all backends support this functionality.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#alertReceived">alertReceived</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#AlertLevel-enum">QSsl::AlertLevel</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml#AlertType-enum">QSsl::AlertType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="authenticationRequired">
<db:title>[since 6.6] void QWebSocket::authenticationRequired(QAuthenticator *<db:emphasis>authenticator</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>authenticationRequired</db:methodname>
<db:methodparam>
<db:type>QAuthenticator *</db:type>
<db:parameter>authenticator</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void authenticationRequired(QAuthenticator *authenticator)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the server requires authentication. The <db:code role="parameter">authenticator</db:code> object must then be filled in with the required details to allow authentication and continue the connection.</db:para>
<db:para>If you know that the server may require authentication, you can set the username and password on the initial <db:link xlink:href="qurl.xml">QUrl</db:link>, using <db:link xlink:href="qurl.xml#setUserName">QUrl::setUserName</db:link> and <db:link xlink:href="qurl.xml#setPassword">QUrl::setPassword</db:link>. <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> will still try to connect <db:emphasis>once</db:emphasis> without using the provided credentials.</db:para>
<db:note>
<db:para>It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qauthenticator.xml">QAuthenticator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="binaryFrameReceived">
<db:title>void QWebSocket::binaryFrameReceived(const QByteArray &amp;<db:emphasis>frame</db:emphasis>, bool <db:emphasis>isLastFrame</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>binaryFrameReceived</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>frame</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>isLastFrame</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void binaryFrameReceived(const QByteArray &amp;frame, bool isLastFrame)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever a binary frame is received. The <db:code role="parameter">frame</db:code> contains the data and <db:code role="parameter">isLastFrame</db:code> indicates whether this is the last frame of the complete message.</db:para>
<db:para>This signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#textFrameReceived">textFrameReceived</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="binaryMessageReceived">
<db:title>void QWebSocket::binaryMessageReceived(const QByteArray &amp;<db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>binaryMessageReceived</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void binaryMessageReceived(const QByteArray &amp;message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever a binary message is received. The <db:code role="parameter">message</db:code> contains the received bytes.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#textMessageReceived">textMessageReceived</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesToWrite">
<db:title>qint64 QWebSocket::bytesToWrite() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>bytesToWrite</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 bytesToWrite() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of bytes that are waiting to be written. The bytes are written when control goes back to the event loop or when <db:link xlink:href="qwebsocket.xml#flush">flush</db:link>() is called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#flush">flush</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesWritten">
<db:title>void QWebSocket::bytesWritten(qint64 <db:emphasis>bytes</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>bytesWritten</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>bytes</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void bytesWritten(qint64 bytes)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted every time a payload of data has been written to the socket. The <db:code role="parameter">bytes</db:code> argument is set to the number of bytes that were written in this payload.</db:para>
<db:note>
<db:para>This signal has the same meaning both for secure and non-secure WebSockets. As opposed to <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link>, bytesWritten() is only emitted when encrypted data is effectively written (see <db:link xlink:href="qsslsocket.xml#encryptedBytesWritten">QSslSocket::encryptedBytesWritten</db:link>()).</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="close">
<db:title>void QWebSocket::close(QWebSocketProtocol::CloseCode <db:emphasis>closeCode</db:emphasis> = QWebSocketProtocol::CloseCodeNormal, const QString &amp;<db:emphasis>reason</db:emphasis> = QString())</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>close</db:methodname>
<db:methodparam>
<db:type>QWebSocketProtocol::CloseCode</db:type>
<db:parameter>closeCode</db:parameter>
<db:initializer>QWebSocketProtocol::CloseCodeNormal</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>reason</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void close(QWebSocketProtocol::CloseCode closeCode, const QString &amp;reason)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Gracefully closes the socket with the given <db:code role="parameter">closeCode</db:code> and <db:code role="parameter">reason</db:code>.</db:para>
<db:para>Any data in the write buffer is flushed before the socket is closed. The <db:code role="parameter">closeCode</db:code> is a <db:link xlink:href="qwebsocketprotocol.xml#CloseCode-enum">QWebSocketProtocol::CloseCode</db:link> indicating the reason to close, and <db:code role="parameter">reason</db:code> describes the reason of the closure more in detail. All control frames, including the Close frame, are limited to 125 bytes. Since two of these are used for <db:code role="parameter">closeCode</db:code> the maximum length of <db:code role="parameter">reason</db:code> is 123! If <db:code role="parameter">reason</db:code> exceeds this limit it will be truncated.</db:para>
</db:section>
<db:section xml:id="closeCode">
<db:title>QWebSocketProtocol::CloseCode QWebSocket::closeCode() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWebSocketProtocol::CloseCode</db:type>
<db:methodname>closeCode</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWebSocketProtocol::CloseCode closeCode() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the code indicating why the socket was closed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocketprotocol.xml#CloseCode-enum">QWebSocketProtocol::CloseCode</db:link></db:member>
<db:member><db:link xlink:href="qwebsocket.xml#closeReason">closeReason</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="closeReason">
<db:title>QString QWebSocket::closeReason() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>closeReason</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString closeReason() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the reason why the socket was closed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#closeCode">closeCode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connected">
<db:title>void QWebSocket::connected()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connected</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void connected()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Emitted when a connection is successfully established. A connection is successfully established when the socket is connected and the handshake was successful.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#open">open</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocket.xml#disconnected">disconnected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="continueInterruptedHandshake">
<db:title>[since 6.2] void QWebSocket::continueInterruptedHandshake()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>continueInterruptedHandshake</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void continueInterruptedHandshake()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If an application wants to conclude a handshake even after receiving <db:link xlink:href="qwebsocket.xml#handshakeInterruptedOnError">handshakeInterruptedOnError</db:link>() signal, it must call this function. This call must be done from a slot function attached to the signal. The signal-slot connection must be direct.</db:para>
<db:para>This function was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#handshakeInterruptedOnError">handshakeInterruptedOnError</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setHandshakeMustInterruptOnError">QSslConfiguration::setHandshakeMustInterruptOnError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="disconnected">
<db:title>void QWebSocket::disconnected()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>disconnected</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void disconnected()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Emitted when the socket is disconnected.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#close">close</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocket.xml#connected">connected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="error">
<db:title>QAbstractSocket::SocketError QWebSocket::error() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QAbstractSocket::SocketError</db:type>
<db:methodname>error</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QAbstractSocket::SocketError error() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the type of error that last occurred</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorOccurred">
<db:title>[since 6.5] void QWebSocket::errorOccurred(QAbstractSocket::SocketError <db:emphasis>error</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>errorOccurred</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::SocketError</db:type>
<db:parameter>error</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void errorOccurred(QAbstractSocket::SocketError error)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted after an error occurred.</db:para>
<db:para>The <db:code role="parameter">error</db:code> parameter describes the type of error that occurred.</db:para>
<db:para><db:link xlink:href="qabstractsocket.xml#SocketError-enum">QAbstractSocket::SocketError</db:link> is not a registered metatype, so for queued connections, you will have to register it with <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>() and <db:link xlink:href="qmetatype.xml#qRegisterMetaType-3">qRegisterMetaType</db:link>().</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#error">error</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocket.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QWebSocket::errorString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>errorString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString errorString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a human-readable description of the last error that occurred</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#error">error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="flush">
<db:title>bool QWebSocket::flush()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>flush</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool flush()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned. Call this function if you need <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> will start sending data automatically once control goes back to the event loop.</db:para>
</db:section>
<db:section xml:id="handshakeInterruptedOnError">
<db:title>[since 6.2] void QWebSocket::handshakeInterruptedOnError(const QSslError &amp;<db:emphasis>error</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>handshakeInterruptedOnError</db:methodname>
<db:methodparam>
<db:type>const QSslError &amp;</db:type>
<db:parameter>error</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void handshakeInterruptedOnError(const QSslError &amp;error)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> emits this signal if a certificate verification error was found and if early error reporting was enabled in <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link>. An application is expected to inspect the <db:code role="parameter">error</db:code> and decide if it wants to continue the handshake, or abort it and send an alert message to the peer. The signal-slot connection must be direct.</db:para>
<db:para>This function was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#continueInterruptedHandshake">continueInterruptedHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocket.xml#sslErrors">sslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setHandshakeMustInterruptOnError">QSslConfiguration::setHandshakeMustInterruptOnError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="handshakeOptions">
<db:title>[since 6.4] QWebSocketHandshakeOptions QWebSocket::handshakeOptions() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWebSocketHandshakeOptions</db:type>
<db:methodname>handshakeOptions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWebSocketHandshakeOptions handshakeOptions() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the handshake options that were used to open this socket.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
</db:section>
<db:section xml:id="ignoreSslErrors">
<db:title>void QWebSocket::ignoreSslErrors()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>ignoreSslErrors</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void ignoreSslErrors()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This slot tells <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> to ignore errors during <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link>'s handshake phase and continue connecting. If you want to continue with the connection even if errors occur during the handshake phase, then you must call this slot, either from a slot connected to <db:link xlink:href="qwebsocket.xml#sslErrors">sslErrors</db:link>(), or before the handshake phase. If you don't call this slot, either in response to errors or before the handshake, the connection will be dropped after the <db:link xlink:href="qwebsocket.xml#sslErrors">sslErrors</db:link>() signal has been emitted.</db:para>
<db:warning>
<db:para>Be sure to always let the user inspect the errors reported by the <db:link xlink:href="qwebsocket.xml#sslErrors">sslErrors</db:link>() signal, and only call this method upon confirmation from the user that proceeding is ok. If there are unexpected errors, the connection should be aborted. Calling this method without inspecting the actual errors will most likely pose a security risk for your application. Use it with great care!</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#sslErrors">sslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#ignoreSslErrors">QSslSocket::ignoreSslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkreply.xml#ignoreSslErrors">QNetworkReply::ignoreSslErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ignoreSslErrors-1">
<db:title>void QWebSocket::ignoreSslErrors(const QList&lt;QSslError&gt; &amp;<db:emphasis>errors</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>ignoreSslErrors</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QSslError&gt; &amp;</db:type>
<db:parameter>errors</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void ignoreSslErrors(const QList&lt;QSslError&gt; &amp;errors)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This method tells <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> to ignore the errors given in <db:code role="parameter">errors</db:code>.</db:para>
<db:para>Note that you can set the expected certificate in the SSL error: If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</db:para>
<db:programlisting language="cpp">QList&amp;lt;QSslCertificate&amp;gt; cert = QSslCertificate::fromPath(QLatin1String(&quot;server-certificate.pem&quot;));
QSslError error(QSslError::SelfSignedCertificate, cert.at(0));
QList&amp;lt;QSslError&amp;gt; expectedSslErrors;
expectedSslErrors.append(error);

QWebSocket socket;
socket.ignoreSslErrors(expectedSslErrors);
socket.open(QUrl(QStringLiteral(&quot;wss://myserver.at.home&quot;)));
</db:programlisting>
<db:para>Multiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#sslErrors">sslErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QWebSocket::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the socket is ready for reading and writing; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="localAddress">
<db:title>QHostAddress QWebSocket::localAddress() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHostAddress</db:type>
<db:methodname>localAddress</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHostAddress localAddress() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the local address</db:para>
</db:section>
<db:section xml:id="localPort">
<db:title>quint16 QWebSocket::localPort() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint16</db:type>
<db:methodname>localPort</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint16 localPort() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the local port</db:para>
</db:section>
<db:section xml:id="maskGenerator">
<db:title>const QMaskGenerator *QWebSocket::maskGenerator() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QMaskGenerator *</db:type>
<db:methodname>maskGenerator</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QMaskGenerator * maskGenerator() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the mask generator that is currently used by this <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#setMaskGenerator">setMaskGenerator</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="maxAllowedIncomingFrameSize">
<db:title>quint64 QWebSocket::maxAllowedIncomingFrameSize() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint64</db:type>
<db:methodname>maxAllowedIncomingFrameSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint64 maxAllowedIncomingFrameSize() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum allowed size of an incoming websocket frame.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#setMaxAllowedIncomingFrameSize">setMaxAllowedIncomingFrameSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="maxAllowedIncomingMessageSize">
<db:title>quint64 QWebSocket::maxAllowedIncomingMessageSize() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint64</db:type>
<db:methodname>maxAllowedIncomingMessageSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint64 maxAllowedIncomingMessageSize() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum allowed size of an incoming websocket message.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#setMaxAllowedIncomingMessageSize">setMaxAllowedIncomingMessageSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="maxIncomingFrameSize">
<db:title>[static] quint64 QWebSocket::maxIncomingFrameSize()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>quint64</db:type>
<db:methodname>maxIncomingFrameSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint64 maxIncomingFrameSize()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum supported size of an incoming websocket frame for this websocket implementation.</db:para>
</db:section>
<db:section xml:id="maxIncomingMessageSize">
<db:title>[static] quint64 QWebSocket::maxIncomingMessageSize()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>quint64</db:type>
<db:methodname>maxIncomingMessageSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint64 maxIncomingMessageSize()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum supported size of an incoming websocket message for this websocket implementation.</db:para>
</db:section>
<db:section xml:id="maxOutgoingFrameSize">
<db:title>[static] quint64 QWebSocket::maxOutgoingFrameSize()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>quint64</db:type>
<db:methodname>maxOutgoingFrameSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint64 maxOutgoingFrameSize()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum supported size of an outgoing websocket frame for this websocket implementation.</db:para>
</db:section>
<db:section xml:id="open">
<db:title>void QWebSocket::open(const QUrl &amp;<db:emphasis>url</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>open</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void open(const QUrl &amp;url)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Opens a WebSocket connection using the given <db:code role="parameter">url</db:code>.</db:para>
<db:para>If the url contains newline characters (\r\n), then the error signal will be emitted with <db:link xlink:href="qabstractsocket.xml#SocketError-enum">QAbstractSocket::ConnectionRefusedError</db:link> as error type.</db:para>
</db:section>
<db:section xml:id="open-1">
<db:title>void QWebSocket::open(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>open</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void open(const QNetworkRequest &amp;request)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Opens a WebSocket connection using the given <db:code role="parameter">request</db:code>.</db:para>
<db:para>The <db:code role="parameter">request</db:code> url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake.</db:para>
</db:section>
<db:section xml:id="open-2">
<db:title>[since 6.4] void QWebSocket::open(const QUrl &amp;<db:emphasis>url</db:emphasis>, const QWebSocketHandshakeOptions &amp;<db:emphasis>options</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>open</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QWebSocketHandshakeOptions &amp;</db:type>
<db:parameter>options</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void open(const QUrl &amp;url, const QWebSocketHandshakeOptions &amp;options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Opens a WebSocket connection using the given <db:code role="parameter">url</db:code> and <db:code role="parameter">options</db:code>.</db:para>
<db:para>If the url contains newline characters (\r\n), then the error signal will be emitted with <db:link xlink:href="qabstractsocket.xml#SocketError-enum">QAbstractSocket::ConnectionRefusedError</db:link> as error type.</db:para>
<db:para>Additional options for the WebSocket handshake such as subprotocols can be specified in <db:code role="parameter">options</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
</db:section>
<db:section xml:id="open-3">
<db:title>[since 6.4] void QWebSocket::open(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QWebSocketHandshakeOptions &amp;<db:emphasis>options</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>open</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QWebSocketHandshakeOptions &amp;</db:type>
<db:parameter>options</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void open(const QNetworkRequest &amp;request, const QWebSocketHandshakeOptions &amp;options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Opens a WebSocket connection using the given <db:code role="parameter">request</db:code> and <db:code role="parameter">options</db:code>.</db:para>
<db:para>The <db:code role="parameter">request</db:code> url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake.</db:para>
<db:para>Additional options for the WebSocket handshake such as subprotocols can be specified in <db:code role="parameter">options</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
</db:section>
<db:section xml:id="origin">
<db:title>QString QWebSocket::origin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>origin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString origin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current origin.</db:para>
</db:section>
<db:section xml:id="outgoingFrameSize">
<db:title>quint64 QWebSocket::outgoingFrameSize() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint64</db:type>
<db:methodname>outgoingFrameSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint64 outgoingFrameSize() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum size of an outgoing websocket frame.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#setOutgoingFrameSize">setOutgoingFrameSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pauseMode">
<db:title>QAbstractSocket::PauseModes QWebSocket::pauseMode() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QAbstractSocket::PauseModes</db:type>
<db:methodname>pauseMode</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QAbstractSocket::PauseModes pauseMode() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the pause mode of this socket</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#setPauseMode">setPauseMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerAddress">
<db:title>QHostAddress QWebSocket::peerAddress() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QHostAddress</db:type>
<db:methodname>peerAddress</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QHostAddress peerAddress() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the peer address</db:para>
</db:section>
<db:section xml:id="peerName">
<db:title>QString QWebSocket::peerName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>peerName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString peerName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the peerName</db:para>
</db:section>
<db:section xml:id="peerPort">
<db:title>quint16 QWebSocket::peerPort() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint16</db:type>
<db:methodname>peerPort</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint16 peerPort() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the peerport</db:para>
</db:section>
<db:section xml:id="peerVerifyError">
<db:title>[since 6.2] void QWebSocket::peerVerifyError(const QSslError &amp;<db:emphasis>error</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>peerVerifyError</db:methodname>
<db:methodparam>
<db:type>const QSslError &amp;</db:type>
<db:parameter>error</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void peerVerifyError(const QSslError &amp;error)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The <db:code role="parameter">error</db:code> is usually an indication that <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> is unable to securely identify the peer.</db:para>
<db:para>This signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> will proceed to emitting <db:link xlink:href="qwebsocket.xml#sslErrors">QWebSocket::sslErrors</db:link>().</db:para>
<db:para>This function was introduced in Qt 6.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#sslErrors">sslErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ping">
<db:title>void QWebSocket::ping(const QByteArray &amp;<db:emphasis>payload</db:emphasis> = QByteArray())</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>ping</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>payload</db:parameter>
<db:initializer>QByteArray()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void ping(const QByteArray &amp;payload)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Pings the server to indicate that the connection is still alive. Additional <db:code role="parameter">payload</db:code> can be sent along the ping message.</db:para>
<db:para>The size of the <db:code role="parameter">payload</db:code> cannot be bigger than 125. If it is larger, the <db:code role="parameter">payload</db:code> is clipped to 125 bytes.</db:para>
<db:note>
<db:para><db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> and <db:link xlink:href="qwebsocketserver.xml">QWebSocketServer</db:link> handles ping requests internally, which means they automatically send back a pong response to the peer.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#pong">pong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pong">
<db:title>void QWebSocket::pong(quint64 <db:emphasis>elapsedTime</db:emphasis>, const QByteArray &amp;<db:emphasis>payload</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pong</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>elapsedTime</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>payload</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pong(quint64 elapsedTime, const QByteArray &amp;payload)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Emitted when a pong message is received in reply to a previous ping. <db:code role="parameter">elapsedTime</db:code> contains the roundtrip time in milliseconds and <db:code role="parameter">payload</db:code> contains an optional payload that was sent with the ping.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#ping">ping</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="preSharedKeyAuthenticationRequired">
<db:title>void QWebSocket::preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator *<db:emphasis>authenticator</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>preSharedKeyAuthenticationRequired</db:methodname>
<db:methodparam>
<db:type>QSslPreSharedKeyAuthenticator *</db:type>
<db:parameter>authenticator</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator *authenticator)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</db:para>
<db:para>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <db:code role="parameter">authenticator</db:code> object according to their needs.</db:para>
<db:note>
<db:para>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</db:para>
</db:note>
<db:note>
<db:para>The <db:code role="parameter">authenticator</db:code> object is owned by the websocket and must not be deleted by the application.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslpresharedkeyauthenticator.xml">QSslPreSharedKeyAuthenticator</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml#preSharedKeyAuthenticationRequired">QSslSocket::preSharedKeyAuthenticationRequired</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="proxy">
<db:title>QNetworkProxy QWebSocket::proxy() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkProxy</db:type>
<db:methodname>proxy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkProxy proxy() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the currently configured proxy</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#setProxy">setProxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="proxyAuthenticationRequired">
<db:title>void QWebSocket::proxyAuthenticationRequired(const QNetworkProxy &amp;<db:emphasis>proxy</db:emphasis>, QAuthenticator *<db:emphasis>authenticator</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>proxyAuthenticationRequired</db:methodname>
<db:methodparam>
<db:type>const QNetworkProxy &amp;</db:type>
<db:parameter>proxy</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QAuthenticator *</db:type>
<db:parameter>authenticator</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void proxyAuthenticationRequired(const QNetworkProxy &amp;proxy, QAuthenticator *authenticator)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal can be emitted when a <db:code role="parameter">proxy</db:code> that requires authentication is used. The <db:code role="parameter">authenticator</db:code> object can then be filled in with the required details to allow authentication and continue the connection.</db:para>
<db:note>
<db:para>It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qauthenticator.xml">QAuthenticator</db:link></db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readBufferSize">
<db:title>qint64 QWebSocket::readBufferSize() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>readBufferSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 readBufferSize() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size in bytes of the readbuffer that is used by the socket.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#setReadBufferSize">setReadBufferSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readChannelFinished">
<db:title>void QWebSocket::readChannelFinished()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>readChannelFinished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void readChannelFinished()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the input (reading) stream is closed in this device. It is emitted as soon as the closing is detected.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="request">
<db:title>QNetworkRequest QWebSocket::request() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkRequest</db:type>
<db:methodname>request</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkRequest request() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the request that was or will be used to open this socket.</db:para>
</db:section>
<db:section xml:id="requestUrl">
<db:title>QUrl QWebSocket::requestUrl() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>requestUrl</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl requestUrl() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the url the socket is connected to or will connect to.</db:para>
</db:section>
<db:section xml:id="resourceName">
<db:title>QString QWebSocket::resourceName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>resourceName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString resourceName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name of the resource currently accessed.</db:para>
</db:section>
<db:section xml:id="resume">
<db:title>void QWebSocket::resume()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resume</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resume()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Continues data transfer on the socket. This method should only be used after the socket has been set to pause upon notifications and a notification has been received. The only notification currently supported is <db:link xlink:href="qwebsocket.xml#sslErrors">sslErrors</db:link>(). Calling this method if the socket is not paused results in undefined behavior.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#pauseMode">pauseMode</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocket.xml#setPauseMode">setPauseMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sendBinaryMessage">
<db:title>qint64 QWebSocket::sendBinaryMessage(const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qint64</db:type>
<db:methodname>sendBinaryMessage</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 sendBinaryMessage(const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sends the given <db:code role="parameter">data</db:code> over the socket as a binary message and returns the number of bytes actually sent.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#sendTextMessage">sendTextMessage</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sendTextMessage">
<db:title>qint64 QWebSocket::sendTextMessage(const QString &amp;<db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qint64</db:type>
<db:methodname>sendTextMessage</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 sendTextMessage(const QString &amp;message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sends the given <db:code role="parameter">message</db:code> over the socket as a text message and returns the number of bytes actually sent.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#sendBinaryMessage">sendBinaryMessage</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMaskGenerator">
<db:title>void QWebSocket::setMaskGenerator(const QMaskGenerator *<db:emphasis>maskGenerator</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setMaskGenerator</db:methodname>
<db:methodparam>
<db:type>const QMaskGenerator *</db:type>
<db:parameter>maskGenerator</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setMaskGenerator(const QMaskGenerator *maskGenerator)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the generator to use for creating masks to <db:code role="parameter">maskGenerator</db:code>. The default <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> generator can be reset by supplying a <db:emphasis>nullptr</db:emphasis>. The mask generator can be changed at any time, even while the connection is open.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#maskGenerator">maskGenerator</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMaxAllowedIncomingFrameSize">
<db:title>void QWebSocket::setMaxAllowedIncomingFrameSize(quint64 <db:emphasis>maxAllowedIncomingFrameSize</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setMaxAllowedIncomingFrameSize</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>maxAllowedIncomingFrameSize</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setMaxAllowedIncomingFrameSize(quint64 maxAllowedIncomingFrameSize)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the maximum allowed size of an incoming websocket frame to <db:code role="parameter">maxAllowedIncomingFrameSize</db:code>. If an incoming frame exceeds this limit, the peer gets disconnected. The accepted range is between 0 and <db:link xlink:href="qwebsocket.xml#maxIncomingFrameSize">maxIncomingFrameSize</db:link>(), default is <db:link xlink:href="qwebsocket.xml#maxIncomingFrameSize">maxIncomingFrameSize</db:link>(). The purpose of this function is to avoid exhausting virtual memory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#maxAllowedIncomingFrameSize">maxAllowedIncomingFrameSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMaxAllowedIncomingMessageSize">
<db:title>void QWebSocket::setMaxAllowedIncomingMessageSize(quint64 <db:emphasis>maxAllowedIncomingMessageSize</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setMaxAllowedIncomingMessageSize</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>maxAllowedIncomingMessageSize</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setMaxAllowedIncomingMessageSize(quint64 maxAllowedIncomingMessageSize)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the maximum allowed size of an incoming websocket message to <db:code role="parameter">maxAllowedIncomingMessageSize</db:code>. If an incoming message exceeds this limit, the peer gets disconnected. The accepted range is between 0 and <db:link xlink:href="qwebsocket.xml#maxIncomingMessageSize">maxIncomingMessageSize</db:link>(), default is <db:link xlink:href="qwebsocket.xml#maxIncomingMessageSize">maxIncomingMessageSize</db:link>(). The purpose of this function is to avoid exhausting virtual memory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#maxAllowedIncomingMessageSize">maxAllowedIncomingMessageSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setOutgoingFrameSize">
<db:title>void QWebSocket::setOutgoingFrameSize(quint64 <db:emphasis>outgoingFrameSize</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setOutgoingFrameSize</db:methodname>
<db:methodparam>
<db:type>quint64</db:type>
<db:parameter>outgoingFrameSize</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setOutgoingFrameSize(quint64 outgoingFrameSize)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the maximum size of an outgoing websocket frame to <db:code role="parameter">outgoingFrameSize</db:code>. The accepted range is between 0 and <db:link xlink:href="qwebsocket.xml#maxOutgoingFrameSize">maxOutgoingFrameSize</db:link>(), default is 512kB. The purpose of this function is to adapt to the maximum allowed frame size of the receiver.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#outgoingFrameSize">outgoingFrameSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPauseMode">
<db:title>void QWebSocket::setPauseMode(QAbstractSocket::PauseModes <db:emphasis>pauseMode</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPauseMode</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::PauseModes</db:type>
<db:parameter>pauseMode</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPauseMode(QAbstractSocket::PauseModes pauseMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Controls whether to pause upon receiving a notification. The <db:code role="parameter">pauseMode</db:code> parameter specifies the conditions in which the socket should be paused.</db:para>
<db:para>The only notification currently supported is <db:link xlink:href="qwebsocket.xml#sslErrors">sslErrors</db:link>(). If set to PauseOnSslErrors, data transfer on the socket will be paused and needs to be enabled explicitly again by calling <db:link xlink:href="qwebsocket.xml#resume">resume</db:link>(). By default, this option is set to PauseNever. This option must be called before connecting to the server, otherwise it will result in undefined behavior.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#pauseMode">pauseMode</db:link>()</db:member>
<db:member><db:link xlink:href="qwebsocket.xml#resume">resume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProxy">
<db:title>void QWebSocket::setProxy(const QNetworkProxy &amp;<db:emphasis>networkProxy</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setProxy</db:methodname>
<db:methodparam>
<db:type>const QNetworkProxy &amp;</db:type>
<db:parameter>networkProxy</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setProxy(const QNetworkProxy &amp;networkProxy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the proxy to <db:code role="parameter">networkProxy</db:code></db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#proxy">proxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setReadBufferSize">
<db:title>void QWebSocket::setReadBufferSize(qint64 <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setReadBufferSize</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setReadBufferSize(qint64 size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the size of <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link>'s internal read buffer to be <db:code role="parameter">size</db:code> bytes.</db:para>
<db:para>If the buffer size is limited to a certain size, <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default. This option is useful if you only read the data at certain points in time (for example, in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#readBufferSize">readBufferSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSslConfiguration">
<db:title>void QWebSocket::setSslConfiguration(const QSslConfiguration &amp;<db:emphasis>sslConfiguration</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSslConfiguration</db:methodname>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>sslConfiguration</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSslConfiguration(const QSslConfiguration &amp;sslConfiguration)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the socket's SSL configuration to be the contents of <db:code role="parameter">sslConfiguration</db:code>.</db:para>
<db:para>This function sets the local certificate, the ciphers, the private key and the CA certificates to those stored in <db:code role="parameter">sslConfiguration</db:code>. It is not possible to set the SSL-state related fields.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#sslConfiguration">sslConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslConfiguration">
<db:title>QSslConfiguration QWebSocket::sslConfiguration() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslConfiguration</db:type>
<db:methodname>sslConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslConfiguration sslConfiguration() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the socket's SSL configuration state. The default SSL configuration of a socket is to use the default ciphers, default CA certificates, no local private key or certificate. The SSL configuration also contains fields that can change with time without notice.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#setSslConfiguration">setSslConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslErrors">
<db:title>void QWebSocket::sslErrors(const QList&lt;QSslError&gt; &amp;<db:emphasis>errors</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>sslErrors</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QSslError&gt; &amp;</db:type>
<db:parameter>errors</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void sslErrors(const QList&lt;QSslError&gt; &amp;errors)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para><db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted. If you want to continue connecting despite the errors that have occurred, you must call <db:link xlink:href="qwebsocket.xml#ignoreSslErrors">QWebSocket::ignoreSslErrors</db:link>() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call sslErrors() (without arguments).</db:para>
<db:para><db:code role="parameter">errors</db:code> contains one or more errors that prevent <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> from verifying the identity of the peer.</db:para>
<db:note>
<db:para>You cannot use <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::QueuedConnection</db:link> when connecting to this signal, or calling <db:link xlink:href="qwebsocket.xml#ignoreSslErrors">QWebSocket::ignoreSslErrors</db:link>() will have no effect.</db:para>
</db:note>
</db:section>
<db:section xml:id="state">
<db:title>QAbstractSocket::SocketState QWebSocket::state() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QAbstractSocket::SocketState</db:type>
<db:methodname>state</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QAbstractSocket::SocketState state() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current state of the socket.</db:para>
</db:section>
<db:section xml:id="stateChanged">
<db:title>void QWebSocket::stateChanged(QAbstractSocket::SocketState <db:emphasis>state</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>stateChanged</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::SocketState</db:type>
<db:parameter>state</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void stateChanged(QAbstractSocket::SocketState state)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link>'s state changes. The <db:code role="parameter">state</db:code> parameter is the new state.</db:para>
<db:note>
<db:para><db:link xlink:href="qabstractsocket.xml#SocketState-enum">QAbstractSocket::ConnectedState</db:link> is emitted after the handshake with the server has succeeded.</db:para>
</db:note>
<db:para><db:link xlink:href="qabstractsocket.xml#SocketState-enum">QAbstractSocket::SocketState</db:link> is not a registered metatype, so for queued connections, you will have to register it with Q_REGISTER_METATYPE() and <db:link xlink:href="qmetatype.xml#qRegisterMetaType-3">qRegisterMetaType</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#state">state</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="subprotocol">
<db:title>[since 6.4] QString QWebSocket::subprotocol() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>subprotocol</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString subprotocol() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the used WebSocket protocol.</db:para>
<db:para>This function was introduced in Qt 6.4.</db:para>
</db:section>
<db:section xml:id="textFrameReceived">
<db:title>void QWebSocket::textFrameReceived(const QString &amp;<db:emphasis>frame</db:emphasis>, bool <db:emphasis>isLastFrame</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>textFrameReceived</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>frame</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>isLastFrame</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void textFrameReceived(const QString &amp;frame, bool isLastFrame)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever a text frame is received. The <db:code role="parameter">frame</db:code> contains the data and <db:code role="parameter">isLastFrame</db:code> indicates whether this is the last frame of the complete message.</db:para>
<db:para>This signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#binaryFrameReceived">binaryFrameReceived</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="textMessageReceived">
<db:title>void QWebSocket::textMessageReceived(const QString &amp;<db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>textMessageReceived</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void textMessageReceived(const QString &amp;message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever a text message is received. The <db:code role="parameter">message</db:code> contains the received text.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwebsocket.xml#binaryMessageReceived">binaryMessageReceived</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="version">
<db:title>QWebSocketProtocol::Version QWebSocket::version() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWebSocketProtocol::Version</db:type>
<db:methodname>version</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWebSocketProtocol::Version version() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the version the socket is currently using.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QWebSocket</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qwebsocket.xml">QWebSocket</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="error-1">
<db:title>void QWebSocket::error(QAbstractSocket::SocketError <db:emphasis>error</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>error</db:methodname>
<db:methodparam>
<db:type>QAbstractSocket::SocketError</db:type>
<db:parameter>error</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void error(QAbstractSocket::SocketError error)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated since 6.5. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qwebsocket.xml#errorOccurred">errorOccurred</db:link>(<db:link xlink:href="qabstractsocket.xml#SocketError-enum">QAbstractSocket::SocketError</db:link> error) instead.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
