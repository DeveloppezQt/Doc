<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QOpenGLWidget Class</db:title>
<db:productname>QtOpenGL</db:productname>
<db:edition>Qt 6.3.2 Reference Documentation</db:edition>
<db:titleabbrev>QtOpenGL Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> class is a widget for rendering OpenGL graphics.</db:para>
<db:para>This class was introduced in Qt 5.4.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QOpenGLWidget</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.4</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS OpenGLWidgets)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::OpenGLWidgets)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += openglwidgets</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> provides functionality for displaying OpenGL graphics integrated into a Qt application. It is very simple to use: Make your class inherit from it and use the subclass like any other QWidget, except that you have the choice between using <db:link xlink:href="qpainter.xml">QPainter</db:link> and standard OpenGL rendering commands.</db:para>
<db:para><db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> provides three convenient virtual functions that you can reimplement in your subclass to perform the typical OpenGL tasks:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>() - Renders the OpenGL scene. Gets called whenever the widget needs to be updated.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qopenglwidget.xml#resizeGL">resizeGL</db:link>() - Sets up the OpenGL viewport, projection, etc. Gets called whenever the widget has been resized (and also when it is shown for the first time because all newly created widgets get a resize event automatically).</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qopenglwidget.xml#initializeGL">initializeGL</db:link>() - Sets up the OpenGL resources and state. Gets called once before the first time <db:link xlink:href="qopenglwidget.xml#resizeGL">resizeGL</db:link>() or <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>() is called.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>If you need to trigger a repaint from places other than <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>() (a typical example is when using <db:link xlink:href="qtimer.xml">timers</db:link> to animate scenes), you should call the widget's update() function to schedule an update.</db:para>
<db:para>Your widget's OpenGL rendering context is made current when <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>(), <db:link xlink:href="qopenglwidget.xml#resizeGL">resizeGL</db:link>(), or <db:link xlink:href="qopenglwidget.xml#initializeGL">initializeGL</db:link>() is called. If you need to call the standard OpenGL API functions from other places (e.g. in your widget's constructor or in your own paint functions), you must call <db:link xlink:href="qopenglwidget.xml#makeCurrent">makeCurrent</db:link>() first.</db:para>
<db:para>All rendering happens into an OpenGL framebuffer object. <db:link xlink:href="qopenglwidget.xml#makeCurrent">makeCurrent</db:link>() ensure that it is bound in the context. Keep this in mind when creating and binding additional framebuffer objects in the rendering code in <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>(). Never re-bind the framebuffer with ID 0. Instead, call <db:link xlink:href="qopenglwidget.xml#defaultFramebufferObject">defaultFramebufferObject</db:link>() to get the ID that should be bound.</db:para>
<db:para><db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> allows using different OpenGL versions and profiles when the platform supports it. Just set the requested format via <db:link xlink:href="qopenglwidget.xml#setFormat">setFormat</db:link>(). Keep in mind however that having multiple <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> instances in the same window requires that they all use the same format, or at least formats that do not make the contexts non-sharable. To overcome this issue, prefer using <db:link xlink:href="qsurfaceformat.xml#setDefaultFormat">QSurfaceFormat::setDefaultFormat</db:link>() instead of <db:link xlink:href="qopenglwidget.xml#setFormat">setFormat</db:link>().</db:para>
<db:note>
<db:para>Calling <db:link xlink:href="qsurfaceformat.xml#setDefaultFormat">QSurfaceFormat::setDefaultFormat</db:link>() before constructing the QApplication instance is mandatory on some platforms (for example, macOS) when an OpenGL core profile context is requested. This is to ensure that resource sharing between contexts stays functional as all internal contexts are created using the correct version and profile.</db:para>
</db:note>
<db:section xml:id="painting-techniques">
<db:title>Painting Techniques</db:title>
<db:para>As described above, subclass <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> to render pure 3D content in the following way:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Reimplement the <db:link xlink:href="qopenglwidget.xml#initializeGL">initializeGL</db:link>() and <db:link xlink:href="qopenglwidget.xml#resizeGL">resizeGL</db:link>() functions to set up the OpenGL state and provide a perspective transformation.</db:para>
</db:listitem>
<db:listitem>
<db:para>Reimplement <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>() to paint the 3D scene, calling only OpenGL functions.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>It is also possible to draw 2D graphics onto a <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> subclass using <db:link xlink:href="qpainter.xml">QPainter</db:link>:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>In <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>(), instead of issuing OpenGL commands, construct a <db:link xlink:href="qpainter.xml">QPainter</db:link> object for use on the widget.</db:para>
</db:listitem>
<db:listitem>
<db:para>Draw primitives using <db:link xlink:href="qpainter.xml">QPainter</db:link>'s member functions.</db:para>
</db:listitem>
<db:listitem>
<db:para>Direct OpenGL commands can still be issued. However, you must make sure these are enclosed by a call to the painter's beginNativePainting() and endNativePainting().</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>When performing drawing using <db:link xlink:href="qpainter.xml">QPainter</db:link> only, it is also possible to perform the painting like it is done for ordinary widgets: by reimplementing <db:link xlink:href="qopenglwidget.xml#paintEvent">paintEvent</db:link>().</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Reimplement the <db:link xlink:href="qopenglwidget.xml#paintEvent">paintEvent</db:link>() function.</db:para>
</db:listitem>
<db:listitem>
<db:para>Construct a <db:link xlink:href="qpainter.xml">QPainter</db:link> object targeting the widget. Either pass the widget to the constructor or the <db:link xlink:href="qpainter.xml#begin">QPainter::begin</db:link>() function.</db:para>
</db:listitem>
<db:listitem>
<db:para>Draw primitives using <db:link xlink:href="qpainter.xml">QPainter</db:link>'s member functions.</db:para>
</db:listitem>
<db:listitem>
<db:para>Painting finishes then the <db:link xlink:href="qpainter.xml">QPainter</db:link> instance is destroyed. Alternatively, call <db:link xlink:href="qpainter.xml#end">QPainter::end</db:link>() explicitly.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="opengl-function-calls-headers-and-qopenglfunctions">
<db:title>OpenGL Function Calls, Headers and QOpenGLFunctions</db:title>
<db:para>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using <db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link> (when making portable applications) or the versioned variants (for example, <db:link xlink:href="qopenglfunctions-3-2-core.xml">QOpenGLFunctions_3_2_Core</db:link> and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</db:para>
<db:para>In <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>() the current context is always accessible by caling <db:link xlink:href="qopenglcontext.xml#currentContext">QOpenGLContext::currentContext</db:link>(). From this context an already initialized, ready-to-be-used <db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link> instance is retrievable by calling <db:link xlink:href="qopenglcontext.xml#functions">QOpenGLContext::functions</db:link>(). An alternative to prefixing every GL call is to inherit from <db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link> and call <db:link xlink:href="qopenglfunctions.xml#initializeOpenGLFunctions">QOpenGLFunctions::initializeOpenGLFunctions</db:link>() in <db:link xlink:href="qopenglwidget.xml#initializeGL">initializeGL</db:link>().</db:para>
<db:para>As for the OpenGL headers, note that in most cases there will be no need to directly include any headers like GL.h. The OpenGL-related Qt headers will include qopengl.h which will in turn include an appropriate header for the system. This might be an OpenGL ES 3.x or 2.0 header, the highest version that is available, or a system-provided gl.h. In addition, a copy of the extension headers (called glext.h on some systems) is provided as part of Qt both for OpenGL and OpenGL ES. These will get included automatically on platforms where feasible. This means that constants and function pointer typedefs from ARB, EXT, OES extensions are automatically available.</db:para>
</db:section>
<db:section xml:id="code-examples">
<db:title>Code Examples</db:title>
<db:para>To get started, the simplest <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> subclass could like like the following:</db:para>
<db:programlisting language="cpp">class MyGLWidget : public QOpenGLWidget
{
public:
    MyGLWidget(QWidget *parent) : QOpenGLWidget(parent) { }

protected:
    void initializeGL() override
    {
        // Set up the rendering context, load shaders and other resources, etc.:
        QOpenGLFunctions *f = QOpenGLContext::currentContext()-&amp;gt;functions();
        f-&amp;gt;glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
        ...
    }

    void resizeGL(int w, int h) override
    {
        // Update projection matrix and other size related settings:
        m_projection.setToIdentity();
        m_projection.perspective(45.0f, w / float(h), 0.01f, 100.0f);
        ...
    }

    void paintGL() override
    {
        // Draw the scene:
        QOpenGLFunctions *f = QOpenGLContext::currentContext()-&amp;gt;functions();
        f-&amp;gt;glClear(GL_COLOR_BUFFER_BIT);
        ...
    }

};
</db:programlisting>
<db:para>Alternatively, the prefixing of each and every OpenGL call can be avoided by deriving from <db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link> instead:</db:para>
<db:programlisting language="cpp">class MyGLWidget : public QOpenGLWidget, protected QOpenGLFunctions
{
    ...
    void initializeGL() override
    {
        initializeOpenGLFunctions();
        glClearColor(...);
        ...
    }
    ...
};
</db:programlisting>
<db:para>To get a context compatible with a given OpenGL version or profile, or to request depth and stencil buffers, call <db:link xlink:href="qopenglwidget.xml#setFormat">setFormat</db:link>():</db:para>
<db:programlisting language="cpp">QOpenGLWidget *widget = new QOpenGLWidget(parent);
QSurfaceFormat format;
format.setDepthBufferSize(24);
format.setStencilBufferSize(8);
format.setVersion(3, 2);
format.setProfile(QSurfaceFormat::CoreProfile);
widget-&amp;gt;setFormat(format); // must be called before the widget or its parent window gets shown
</db:programlisting>
<db:para>With OpenGL 3.0+ contexts, when portability is not important, the versioned <db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link> variants give easy access to all the modern OpenGL functions available in a given version:</db:para>
<db:programlisting language="cpp">    ...
    void paintGL() override
    {
        QOpenGLFunctions_3_2_Core *f = QOpenGLContext::currentContext()-&amp;gt;versionFunctions&amp;lt;QOpenGLFunctions_3_2_Core&amp;gt;();
        ...
        f-&amp;gt;glDrawArraysInstanced(...);
        ...
    }
    ...
</db:programlisting>
<db:para>As described above, it is simpler and more robust to set the requested format globally so that it applies to all windows and contexts during the lifetime of the application. Below is an example of this:</db:para>
<db:programlisting language="cpp">int main(int argc, char **argv)
{
    QApplication app(argc, argv);

    QSurfaceFormat format;
    format.setDepthBufferSize(24);
    format.setStencilBufferSize(8);
    format.setVersion(3, 2);
    format.setProfile(QSurfaceFormat::CoreProfile);
    QSurfaceFormat::setDefaultFormat(format);

    MyWidget widget;
    widget.show();

    return app.exec();
}
</db:programlisting>
</db:section>
<db:section xml:id="multisampling">
<db:title>Multisampling</db:title>
<db:para>To enable multisampling, set the number of requested samples on the <db:link xlink:href="qsurfaceformat.xml">QSurfaceFormat</db:link> that is passed to <db:link xlink:href="qopenglwidget.xml#setFormat">setFormat</db:link>(). On systems that do not support it the request may get ignored.</db:para>
<db:para>Multisampling support requires support for multisampled renderbuffers and framebuffer blits. On OpenGL ES 2.0 implementations it is likely that these will not be present. This means that multisampling will not be available. With modern OpenGL versions and OpenGL ES 3.0 and up this is usually not a problem anymore.</db:para>
</db:section>
<db:section xml:id="threading">
<db:title>Threading</db:title>
<db:para>Performing offscreen rendering on worker threads, for example to generate textures that are then used in the GUI/main thread in <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>(), are supported by exposing the widget's <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> so that additional contexts sharing with it can be created on each thread.</db:para>
<db:para>Drawing directly to the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>'s framebuffer outside the GUI/main thread is possible by reimplementing <db:link xlink:href="qopenglwidget.xml#paintEvent">paintEvent</db:link>() to do nothing. The context's thread affinity has to be changed via <db:link xlink:href="qobject.xml#moveToThread">QObject::moveToThread</db:link>(). After that, <db:link xlink:href="qopenglwidget.xml#makeCurrent">makeCurrent</db:link>() and <db:link xlink:href="qopenglwidget.xml#doneCurrent">doneCurrent</db:link>() are usable on the worker thread. Be careful to move the context back to the GUI/main thread afterwards.</db:para>
<db:para>Triggering a buffer swap just for the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> is not possible since there is no real, onscreen native surface for it. It is up to the widget stack to manage composition and buffer swaps on the gui thread. When a thread is done updating the framebuffer, call update() <db:emphasis role="bold">on the GUI/main thread</db:emphasis> to schedule composition.</db:para>
<db:para>Extra care has to be taken to avoid using the framebuffer when the GUI/main thread is performing compositing. The signals <db:link xlink:href="qopenglwidget.xml#aboutToCompose">aboutToCompose</db:link>() and <db:link xlink:href="qopenglwidget.xml#frameSwapped">frameSwapped</db:link>() will be emitted when the composition is starting and ending. They are emitted on the GUI/main thread. This means that by using a direct connection <db:link xlink:href="qopenglwidget.xml#aboutToCompose">aboutToCompose</db:link>() can block the GUI/main thread until the worker thread has finished its rendering. After that, the worker thread must perform no further rendering until the <db:link xlink:href="qopenglwidget.xml#frameSwapped">frameSwapped</db:link>() signal is emitted. If this is not acceptable, the worker thread has to implement a double buffering mechanism. This involves drawing using an alternative render target, that is fully controlled by the thread, e.g. an additional framebuffer object, and blitting to the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>'s framebuffer at a suitable time.</db:para>
</db:section>
<db:section xml:id="context-sharing">
<db:title>Context Sharing</db:title>
<db:para>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> instances that belong to different windows.</db:para>
<db:para>This means that all QOpenGLWidgets in the same window can access each other's sharable resources, like textures, and there is no need for an extra &quot;global share&quot; context.</db:para>
<db:para>To set up sharing between <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> instances belonging to different windows, set the <db:link xlink:href="qt.xml#ApplicationAttribute-enum">Qt::AA_ShareOpenGLContexts</db:link> application attribute before instantiating QApplication. This will trigger sharing between all <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> instances without any further steps.</db:para>
<db:para>Creating extra <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> instances that share resources like textures with the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>'s context is also possible. Simply pass the pointer returned from <db:link xlink:href="qopenglwidget.xml#context">context</db:link>() to <db:link xlink:href="qopenglcontext.xml#setShareContext">QOpenGLContext::setShareContext</db:link>() before calling <db:link xlink:href="qopenglcontext.xml#create">QOpenGLContext::create</db:link>(). The resulting context can also be used on a different thread, allowing threaded generation of textures and asynchronous texture uploads.</db:para>
<db:para>Note that <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> expects a standard conformant implementation of resource sharing when it comes to the underlying graphics drivers. For example, some drivers, in particular for mobile and embedded hardware, have issues with setting up sharing between an existing context and others that are created later. Some other drivers may behave in unexpected ways when trying to utilize shared resources between different threads.</db:para>
</db:section>
<db:section xml:id="resource-initialization-and-cleanup">
<db:title>Resource Initialization and Cleanup</db:title>
<db:para>The <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>'s associated OpenGL context is guaranteed to be current whenever <db:link xlink:href="qopenglwidget.xml#initializeGL">initializeGL</db:link>() and <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>() are invoked. Do not attempt to create OpenGL resources before <db:link xlink:href="qopenglwidget.xml#initializeGL">initializeGL</db:link>() is called. For example, attempting to compile shaders, initialize vertex buffer objects or upload texture data will fail when done in a subclass's constructor. These operations must be deferred to <db:link xlink:href="qopenglwidget.xml#initializeGL">initializeGL</db:link>(). Some of Qt's OpenGL helper classes, like <db:link xlink:href="qopenglbuffer.xml">QOpenGLBuffer</db:link> or <db:link xlink:href="qopenglvertexarrayobject.xml">QOpenGLVertexArrayObject</db:link>, have a matching deferred behavior: they can be instantiated without a context, but all initialization is deferred until a create(), or similar, call. This means that they can be used as normal (non-pointer) member variables in a <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> subclass, but the create() or similar function can only be called from <db:link xlink:href="qopenglwidget.xml#initializeGL">initializeGL</db:link>(). Be aware however that not all classes are designed like this. When in doubt, make the member variable a pointer and create and destroy the instance dynamically in <db:link xlink:href="qopenglwidget.xml#initializeGL">initializeGL</db:link>() and the destructor, respectively.</db:para>
<db:para>Releasing the resources also needs the context to be current. Therefore destructors that perform such cleanup are expected to call <db:link xlink:href="qopenglwidget.xml#makeCurrent">makeCurrent</db:link>() before moving on to destroy any OpenGL resources or wrappers. Avoid deferred deletion via <db:link xlink:href="qobject.xml#deleteLater">deleteLater</db:link>() or the parenting mechanism of <db:link xlink:href="qobject.xml">QObject</db:link>. There is no guarantee the correct context will be current at the time the instance in question is really destroyed.</db:para>
<db:para>A typical subclass will therefore often look like the following when it comes to resource initialization and destruction:</db:para>
<db:programlisting language="cpp">class MyGLWidget : public QOpenGLWidget
{
    ...

private:
    QOpenGLVertexArrayObject m_vao;
    QOpenGLBuffer m_vbo;
    QOpenGLShaderProgram *m_program;
    QOpenGLShader *m_shader;
    QOpenGLTexture *m_texture;
};

MyGLWidget::MyGLWidget()
    : m_program(0), m_shader(0), m_texture(0)
{
    // No OpenGL resource initialization is done here.
}

MyGLWidget::~MyGLWidget()
{
    // Make sure the context is current and then explicitly
    // destroy all underlying OpenGL resources.
    makeCurrent();

    delete m_texture;
    delete m_shader;
    delete m_program;

    m_vbo.destroy();
    m_vao.destroy();

    doneCurrent();
}

void MyGLWidget::initializeGL()
{
    m_vao.create();
    if (m_vao.isCreated())
        m_vao.bind();

    m_vbo.create();
    m_vbo.bind();
    m_vbo.allocate(...);

    m_texture = new QOpenGLTexture(QImage(...));

    m_shader = new QOpenGLShader(...);
    m_program = new QOpenGLShaderProgram(...);

    ...
}
</db:programlisting>
<db:para>This is naturally not the only possible solution. One alternative is to use the <db:link xlink:href="qopenglcontext.xml#aboutToBeDestroyed">aboutToBeDestroyed</db:link>() signal of <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link>. By connecting a slot, using direct connection, to this signal, it is possible to perform cleanup whenever the underlying native context handle, or the entire <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> instance, is going to be released. The following snippet is in principle equivalent to the previous one:</db:para>
<db:programlisting language="cpp">void MyGLWidget::initializeGL()
{
    // context() and QOpenGLContext::currentContext() are equivalent when called from initializeGL or paintGL.
    connect(context(), &amp;amp;QOpenGLContext::aboutToBeDestroyed, this, &amp;amp;MyGLWidget::cleanup);
}

void MyGLWidget::cleanup()
{
    makeCurrent();
    delete m_texture;
    m_texture = 0;
    ...
    doneCurrent();
}
</db:programlisting>
<db:note>
<db:para>For widgets that change their associated top-level window multiple times during their lifetime, a combined approach is essential. Whenever the widget or a parent of it gets reparented so that the top-level window becomes different, the widget's associated context is destroyed and a new one is created. This is then followed by a call to <db:link xlink:href="qopenglwidget.xml#initializeGL">initializeGL</db:link>() where all OpenGL resources must get reinitialized. Due to this the only option to perform proper cleanup is to connect to the context's aboutToBeDestroyed() signal. Note that the context in question may not be the current one when the signal gets emitted. Therefore it is good practice to call <db:link xlink:href="qopenglwidget.xml#makeCurrent">makeCurrent</db:link>() in the connected slot. Additionally, the same cleanup steps must be performed from the derived class' destructor, since the slot connected to the signal will not get invoked when the widget is being destroyed.</db:para>
</db:note>
<db:note>
<db:para>When <db:link xlink:href="qt.xml#ApplicationAttribute-enum">Qt::AA_ShareOpenGLContexts</db:link> is set, the widget's context never changes, not even when reparenting because the widget's associated texture is guaranteed to be accessible also from the new top-level's context.</db:para>
</db:note>
<db:para>Proper cleanup is especially important due to context sharing. Even though each <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>'s associated context is destroyed together with the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>, the sharable resources in that context, like textures, will stay valid until the top-level window, in which the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> lived, is destroyed. Additionally, settings like <db:link xlink:href="qt.xml#ApplicationAttribute-enum">Qt::AA_ShareOpenGLContexts</db:link> and some Qt modules may trigger an even wider scope for sharing contexts, potentially leading to keeping the resources in question alive for the entire lifetime of the application. Therefore the safest and most robust is always to perform explicit cleanup for all resources and resource wrappers used in the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>.</db:para>
</db:section>
<db:section xml:id="limitations">
<db:title>Limitations</db:title>
<db:para>Putting other widgets underneath and making the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> transparent will not lead to the expected results: The widgets underneath will not be visible. This is because in practice the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> is drawn before all other regular, non-OpenGL widgets, and so see-through type of solutions are not feasible. Other type of layouts, like having widgets on top of the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>, will function as expected.</db:para>
<db:para>When absolutely necessary, this limitation can be overcome by setting the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_AlwaysStackOnTop</db:link> attribute on the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>, so it should only be used in situations where a semi-transparent <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> with other widgets visible underneath is required.</db:para>
<db:para>Note that this does not apply when there are no other widgets underneath and the intention is to have a semi-transparent window. In that case the traditional approach of setting <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_TranslucentBackground</db:link> on the top-level window is sufficient. Note that if the transparent areas are only desired in the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>, then <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_NoSystemBackground</db:link> will need to be turned back to <db:code>false</db:code> after enabling <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_TranslucentBackground</db:link>. Additionally, requesting an alpha channel for the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>'s context via <db:link xlink:href="qopenglwidget.xml#setFormat">setFormat</db:link>() may be necessary too, depending on the system.</db:para>
<db:para><db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> supports multiple update behaviors, just like <db:link xlink:href="qopenglwindow.xml">QOpenGLWindow</db:link>. In preserved mode the rendered content from the previous <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>() call is available in the next one, allowing incremental rendering. In non-preserved mode the content is lost and <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>() implementations are expected to redraw everything in the view.</db:para>
<db:para>Before Qt 5.5 the default behavior of <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> was to preserve the rendered contents between <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>() calls. Since Qt 5.5 the default behavior is non-preserved because this provides better performance and the majority of applications have no need for the previous content. This also resembles the semantics of an OpenGL-based <db:link xlink:href="qwindow.xml">QWindow</db:link> and matches the default behavior of <db:link xlink:href="qopenglwindow.xml">QOpenGLWindow</db:link> in that the color and ancillary buffers are invalidated for each frame. To restore the preserved behavior, call <db:link xlink:href="qopenglwidget.xml#setUpdateBehavior">setUpdateBehavior</db:link>() with <db:code>PartialUpdate</db:code>.</db:para>
<db:note>
<db:para>Displaying a <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> requires an alpha channel in the associated top-level window's backing store due to the way composition with other QWidget-based content works. If there is no alpha channel, the content rendered by the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> will not be visible. This can become particularly relevant on Linux/X11 in remote display setups (such as, with Xvnc), when using a color depth lower than 24. For example, a color depth of 16 will typically map to using a backing store image with the format <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_RGB16</db:link> (RGB565), leaving no room for an alpha channel. Therefore, if experiencing problems with getting the contents of a <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> composited correctly with other the widgets in the window, make sure the server (such as, vncserver) is configured with a 24 or 32 bit depth instead of 16.</db:para>
</db:note>
</db:section>
<db:section xml:id="alternatives">
<db:title>Alternatives</db:title>
<db:para>Adding a <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> into a window turns on OpenGL-based compositing for the entire window. In some special cases this may not be ideal, and the old QGLWidget-style behavior with a separate, native child window is desired. Desktop applications that understand the limitations of this approach (for example when it comes to overlaps, transparency, scroll views and MDI areas), can use <db:link xlink:href="qopenglwindow.xml">QOpenGLWindow</db:link> with QWidget::createWindowContainer(). This is a modern alternative to QGLWidget and is faster than <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> due to the lack of the additional composition step. It is strongly recommended to limit the usage of this approach to cases where there is no other choice. Note that this option is not suitable for most embedded and mobile platforms, and it is known to have issues on certain desktop platforms (e.g. macOS) too. The stable, cross-platform solution is always <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>.</db:para>
<db:para><db:emphasis>OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other countries.</db:emphasis></db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link></db:member>
<db:member><db:link xlink:href="qopenglwindow.xml">QOpenGLWindow</db:link></db:member>
<db:member><db:link xlink:href="qt.xml#ApplicationAttribute-enum">Qt::AA_ShareOpenGLContexts</db:link></db:member>
<db:member><db:link xlink:href="qopenglwidget.xml#UpdateBehavior-enum">UpdateBehavior</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="UpdateBehavior-enum">
<db:title>[since 5.5] enum QOpenGLWidget::UpdateBehavior</db:title>
<db:enumsynopsis>
<db:enumname>UpdateBehavior</db:enumname>
<db:enumitem>
<db:enumidentifier>NoPartialUpdate</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PartialUpdate</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the update semantics of <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link></db:emphasis>::NoPartialUpdate</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> will discard the contents of the color buffer and the ancillary buffers after the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> is rendered to screen. This is the same behavior that can be expected by calling <db:link xlink:href="qopenglcontext.xml#swapBuffers">QOpenGLContext::swapBuffers</db:link> with a default opengl enabled <db:link xlink:href="qwindow.xml">QWindow</db:link> as the argument. NoPartialUpdate can have some performance benefits on certain hardware architectures common in the mobile and embedded space when a framebuffer object is used as the rendering target. The framebuffer object is invalidated between frames with glDiscardFramebufferEXT if supported or a glClear. Please see the documentation of EXT_discard_framebuffer for more information: https://www.khronos.org/registry/gles/extensions/EXT/EXT_discard_framebuffer.txt</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link></db:emphasis>::PartialUpdate</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The framebuffer objects color buffer and ancillary buffers are not invalidated between frames.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#updateBehavior">updateBehavior</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglwidget.xml#setUpdateBehavior">setUpdateBehavior</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QOpenGLWidget">
<db:title>[explicit] QOpenGLWidget::QOpenGLWidget(QWidget *<db:emphasis>parent</db:emphasis> = nullptr, Qt::WindowFlags <db:emphasis>f</db:emphasis> = Qt::WindowFlags())</db:title>
<db:constructorsynopsis>
<db:methodname>QOpenGLWidget</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>Qt::WindowFlags</db:type>
<db:parameter>f</db:parameter>
<db:initializer>Qt::WindowFlags()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLWidget(QWidget *parent, Qt::WindowFlags f)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a widget which is a child of <db:code role="parameter">parent</db:code>, with widget flags set to <db:code role="parameter">f</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QOpenGLWidget">
<db:title>[virtual] QOpenGLWidget::~QOpenGLWidget()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QOpenGLWidget</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QOpenGLWidget()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> instance, freeing its resources.</db:para>
<db:para>The <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>'s context is made current in the destructor, allowing for safe destruction of any child object that may need to release OpenGL resources belonging to the context provided by this widget.</db:para>
<db:warning>
<db:para>if you have objects wrapping OpenGL resources (such as <db:link xlink:href="qopenglbuffer.xml">QOpenGLBuffer</db:link>, <db:link xlink:href="qopenglshaderprogram.xml">QOpenGLShaderProgram</db:link>, etc.) as members of a OpenGLWidget subclass, you may need to add a call to <db:link xlink:href="qopenglwidget.xml#makeCurrent">makeCurrent</db:link>() in that subclass' destructor as well. Due to the rules of C++ object destruction, those objects will be destroyed <db:emphasis>before</db:emphasis> calling this function (but after that the destructor of the subclass has run), therefore making the OpenGL context current in this function happens too late for their safe disposal.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#makeCurrent">makeCurrent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="aboutToCompose">
<db:title>void QOpenGLWidget::aboutToCompose()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>aboutToCompose</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void aboutToCompose()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the widget's top-level window is about to begin composing the textures of its <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> children and the other widgets.</db:para>
</db:section>
<db:section xml:id="aboutToResize">
<db:title>void QOpenGLWidget::aboutToResize()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>aboutToResize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void aboutToResize()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the widget's size is changed and therefore the framebuffer object is going to be recreated.</db:para>
</db:section>
<db:section xml:id="context">
<db:title>QOpenGLContext *QOpenGLWidget::context() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QOpenGLContext *</db:type>
<db:methodname>context</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLContext * context() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns The <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> used by this widget or <db:code>0</db:code> if not yet initialized.</db:para>
<db:note>
<db:para>The context and the framebuffer object used by the widget changes when reparenting the widget via setParent().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#setShareContext">QOpenGLContext::setShareContext</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglwidget.xml#defaultFramebufferObject">defaultFramebufferObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="defaultFramebufferObject">
<db:title>GLuint QOpenGLWidget::defaultFramebufferObject() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>GLuint</db:type>
<db:methodname>defaultFramebufferObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">GLuint defaultFramebufferObject() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns The framebuffer object handle or <db:code>0</db:code> if not yet initialized.</db:para>
<db:note>
<db:para>The framebuffer object belongs to the context returned by <db:link xlink:href="qopenglwidget.xml#context">context</db:link>() and may not be accessible from other contexts.</db:para>
</db:note>
<db:note>
<db:para>The context and the framebuffer object used by the widget changes when reparenting the widget via setParent(). In addition, the framebuffer object changes on each resize.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#context">context</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="doneCurrent">
<db:title>void QOpenGLWidget::doneCurrent()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>doneCurrent</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void doneCurrent()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Releases the context.</db:para>
<db:para>It is not necessary to call this function in most cases, since the widget will make sure the context is bound and released properly when invoking <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>().</db:para>
</db:section>
<db:section xml:id="event">
<db:title>[override virtual protected] bool QOpenGLWidget::event(QEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>event</db:methodname>
<db:methodparam>
<db:type>QEvent *</db:type>
<db:parameter>e</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool event(QEvent *e) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
</db:section>
<db:section xml:id="format">
<db:title>QSurfaceFormat QOpenGLWidget::format() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSurfaceFormat</db:type>
<db:methodname>format</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSurfaceFormat format() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the context and surface format used by this widget and its toplevel window.</db:para>
<db:para>After the widget and its toplevel have both been created, resized and shown, this function will return the actual format of the context. This may differ from the requested format if the request could not be fulfilled by the platform. It is also possible to get larger color buffer sizes than requested.</db:para>
<db:para>When the widget's window and the related OpenGL resources are not yet initialized, the return value is the format that has been set via <db:link xlink:href="qopenglwidget.xml#setFormat">setFormat</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#setFormat">setFormat</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglwidget.xml#context">context</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="frameSwapped">
<db:title>void QOpenGLWidget::frameSwapped()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>frameSwapped</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void frameSwapped()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted after the widget's top-level window has finished composition and returned from its potentially blocking <db:link xlink:href="qopenglcontext.xml#swapBuffers">QOpenGLContext::swapBuffers</db:link>() call.</db:para>
</db:section>
<db:section xml:id="grabFramebuffer">
<db:title>QImage QOpenGLWidget::grabFramebuffer()</db:title>
<db:methodsynopsis>
<db:type>QImage</db:type>
<db:methodname>grabFramebuffer</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QImage grabFramebuffer()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Renders and returns a 32-bit RGB image of the framebuffer.</db:para>
<db:note>
<db:para>This is a potentially expensive operation because it relies on glReadPixels() to read back the pixels. This may be slow and can stall the GPU pipeline.</db:para>
</db:note>
</db:section>
<db:section xml:id="initializeGL">
<db:title>[virtual protected] void QOpenGLWidget::initializeGL()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>initializeGL</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void initializeGL()</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This virtual function is called once before the first call to <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>() or <db:link xlink:href="qopenglwidget.xml#resizeGL">resizeGL</db:link>(). Reimplement it in a subclass.</db:para>
<db:para>This function should set up any required OpenGL resources and state.</db:para>
<db:para>There is no need to call <db:link xlink:href="qopenglwidget.xml#makeCurrent">makeCurrent</db:link>() because this has already been done when this function is called. Note however that the framebuffer is not yet available at this stage, so avoid issuing draw calls from here. Defer such calls to <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglwidget.xml#resizeGL">resizeGL</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QOpenGLWidget::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:emphasis>true</db:emphasis> if the widget and OpenGL resources, like the context, have been successfully initialized. Note that the return value is always false until the widget is shown.</db:para>
</db:section>
<db:section xml:id="makeCurrent">
<db:title>void QOpenGLWidget::makeCurrent()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>makeCurrent</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void makeCurrent()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Prepares for rendering OpenGL content for this widget by making the corresponding context current and binding the framebuffer object in that context.</db:para>
<db:para>It is not necessary to call this function in most cases, because it is called automatically before invoking <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#context">context</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglwidget.xml#doneCurrent">doneCurrent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="metric">
<db:title>[override virtual protected] int QOpenGLWidget::metric(QPaintDevice::PaintDeviceMetric <db:emphasis>metric</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>metric</db:methodname>
<db:methodparam>
<db:type>QPaintDevice::PaintDeviceMetric</db:type>
<db:parameter>metric</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int metric(QPaintDevice::PaintDeviceMetric metric) const override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
</db:section>
<db:section xml:id="paintEngine">
<db:title>[override virtual protected] QPaintEngine *QOpenGLWidget::paintEngine() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QPaintEngine *</db:type>
<db:methodname>paintEngine</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPaintEngine * paintEngine() const override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
</db:section>
<db:section xml:id="paintEvent">
<db:title>[override virtual protected] void QOpenGLWidget::paintEvent(QPaintEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>paintEvent</db:methodname>
<db:methodparam>
<db:type>QPaintEvent *</db:type>
<db:parameter>e</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void paintEvent(QPaintEvent *e) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Handles paint events.</db:para>
<db:para>Calling QWidget::update() will lead to sending a paint event <db:code role="parameter">e</db:code>, and thus invoking this function. (NB this is asynchronous and will happen at some point after returning from update()). This function will then, after some preparation, call the virtual <db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>() to update the contents of the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>'s framebuffer. The widget's top-level window will then composite the framebuffer's texture with the rest of the window.</db:para>
</db:section>
<db:section xml:id="paintGL">
<db:title>[virtual protected] void QOpenGLWidget::paintGL()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>paintGL</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void paintGL()</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This virtual function is called whenever the widget needs to be painted. Reimplement it in a subclass.</db:para>
<db:para>There is no need to call <db:link xlink:href="qopenglwidget.xml#makeCurrent">makeCurrent</db:link>() because this has already been done when this function is called.</db:para>
<db:para>Before invoking this function, the context and the framebuffer are bound, and the viewport is set up by a call to glViewport(). No other state is set and no clearing or drawing is performed by the framework.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#initializeGL">initializeGL</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglwidget.xml#resizeGL">resizeGL</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="redirected">
<db:title>[override virtual protected] QPaintDevice *QOpenGLWidget::redirected(QPoint *<db:emphasis>p</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QPaintDevice *</db:type>
<db:methodname>redirected</db:methodname>
<db:methodparam>
<db:type>QPoint *</db:type>
<db:parameter>p</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPaintDevice * redirected(QPoint *p) const override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
</db:section>
<db:section xml:id="resizeEvent">
<db:title>[override virtual protected] void QOpenGLWidget::resizeEvent(QResizeEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>resizeEvent</db:methodname>
<db:methodparam>
<db:type>QResizeEvent *</db:type>
<db:parameter>e</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resizeEvent(QResizeEvent *e) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Handles resize events that are passed in the <db:code role="parameter">e</db:code> event parameter. Calls the virtual function <db:link xlink:href="qopenglwidget.xml#resizeGL">resizeGL</db:link>().</db:para>
<db:note>
<db:para>Avoid overriding this function in derived classes. If that is not feasible, make sure that <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>'s implementation is invoked too. Otherwise the underlying framebuffer object and related resources will not get resized properly and will lead to incorrect rendering.</db:para>
</db:note>
</db:section>
<db:section xml:id="resizeGL">
<db:title>[virtual protected] void QOpenGLWidget::resizeGL(int <db:emphasis>w</db:emphasis>, int <db:emphasis>h</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>resizeGL</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>w</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>h</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resizeGL(int w, int h)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This virtual function is called whenever the widget has been resized. Reimplement it in a subclass. The new size is passed in <db:code role="parameter">w</db:code> and <db:code role="parameter">h</db:code>.</db:para>
<db:para>There is no need to call <db:link xlink:href="qopenglwidget.xml#makeCurrent">makeCurrent</db:link>() because this has already been done when this function is called. Additionally, the framebuffer is also bound.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#initializeGL">initializeGL</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglwidget.xml#paintGL">paintGL</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resized">
<db:title>void QOpenGLWidget::resized()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resized</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resized()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted right after the framebuffer object has been recreated due to resizing the widget.</db:para>
</db:section>
<db:section xml:id="setFormat">
<db:title>void QOpenGLWidget::setFormat(const QSurfaceFormat &amp;<db:emphasis>format</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFormat</db:methodname>
<db:methodparam>
<db:type>const QSurfaceFormat &amp;</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFormat(const QSurfaceFormat &amp;format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the requested surface <db:code role="parameter">format</db:code>.</db:para>
<db:para>When the format is not explicitly set via this function, the format returned by <db:link xlink:href="qsurfaceformat.xml#defaultFormat">QSurfaceFormat::defaultFormat</db:link>() will be used. This means that when having multiple OpenGL widgets, individual calls to this function can be replaced by one single call to <db:link xlink:href="qsurfaceformat.xml#setDefaultFormat">QSurfaceFormat::setDefaultFormat</db:link>() before creating the first widget.</db:para>
<db:note>
<db:para>Requesting an alpha buffer via this function will not lead to the desired results when the intention is to make other widgets beneath visible. Instead, use <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_AlwaysStackOnTop</db:link> to enable semi-transparent <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> instances with other widgets visible underneath. Keep in mind however that this breaks the stacking order, so it will no longer be possible to have other widgets on top of the <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#format">format</db:link>()</db:member>
<db:member><db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_AlwaysStackOnTop</db:link></db:member>
<db:member><db:link xlink:href="qsurfaceformat.xml#setDefaultFormat">QSurfaceFormat::setDefaultFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setTextureFormat">
<db:title>[since 5.10] void QOpenGLWidget::setTextureFormat(GLenum <db:emphasis>texFormat</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setTextureFormat</db:methodname>
<db:methodparam>
<db:type>GLenum</db:type>
<db:parameter>texFormat</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setTextureFormat(GLenum texFormat)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets a custom internal texture format of <db:code role="parameter">texFormat</db:code>.</db:para>
<db:para>When working with sRGB framebuffers, it will be necessary to specify a format like <db:code>GL_SRGB8_ALPHA8</db:code>. This can be achieved by calling this function.</db:para>
<db:note>
<db:para>This function has no effect if called after the widget has already been shown and thus it performed initialization.</db:para>
</db:note>
<db:note>
<db:para>This function will typically have to be used in combination with a <db:link xlink:href="qsurfaceformat.xml#setDefaultFormat">QSurfaceFormat::setDefaultFormat</db:link>() call that sets the color space to <db:link xlink:href="qsurfaceformat.xml#ColorSpace-enum">QSurfaceFormat::sRGBColorSpace</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#textureFormat">textureFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setUpdateBehavior">
<db:title>[since 5.5] void QOpenGLWidget::setUpdateBehavior(QOpenGLWidget::UpdateBehavior <db:emphasis>updateBehavior</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setUpdateBehavior</db:methodname>
<db:methodparam>
<db:type>QOpenGLWidget::UpdateBehavior</db:type>
<db:parameter>updateBehavior</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setUpdateBehavior(QOpenGLWidget::UpdateBehavior updateBehavior)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets this widget's update behavior to <db:code role="parameter">updateBehavior</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#updateBehavior">updateBehavior</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="textureFormat">
<db:title>[since 5.10] GLenum QOpenGLWidget::textureFormat() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>GLenum</db:type>
<db:methodname>textureFormat</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">GLenum textureFormat() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the active internal texture format if the widget has already initialized, the requested format if one was set but the widget has not yet been made visible, or <db:code>nullptr</db:code> if <db:link xlink:href="qopenglwidget.xml#setTextureFormat">setTextureFormat</db:link>() was not called and the widget has not yet been made visible.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#setTextureFormat">setTextureFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="updateBehavior">
<db:title>[since 5.5] QOpenGLWidget::UpdateBehavior QOpenGLWidget::updateBehavior() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QOpenGLWidget::UpdateBehavior</db:type>
<db:methodname>updateBehavior</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLWidget::UpdateBehavior updateBehavior() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the update behavior of the widget.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglwidget.xml#setUpdateBehavior">setUpdateBehavior</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
