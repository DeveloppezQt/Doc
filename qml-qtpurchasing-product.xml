<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Product QML Type</db:title>
<db:productname>QtPurchasing</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Purchasing Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A product for in-app purchasing.</db:para>
<db:para>This type was introduced in QtPurchasing 1.0.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Import Statement</db:term>
<db:listitem>
<db:para>import QtPurchasing 1.12</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>QtPurchasing 1.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>Product is part of <db:simplelist><db:member>qtpurchasing</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Product contains information about a product in the external market place. Once the product's <db:link xlink:href="qml-qtpurchasing-product.xml#identifier-prop">identifier</db:link> and <db:link xlink:href="qml-qtpurchasing-product.xml#type-prop">type</db:link> are set, the product will be queried from the external market place. Properties such as <db:link xlink:href="qml-qtpurchasing-product.xml#price-prop">price</db:link> will then be set, and it will be possible to purchase the product. The <db:link xlink:href="qml-qtpurchasing-product.xml#status-prop">status</db:link> property holds information on the registration process.</db:para>
<db:note>
<db:para>It is not possible to change the identifier and type once they have both been set and the product has been registered.</db:para>
</db:note>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="description-prop">
<db:title>description : string</db:title>
<db:fieldsynopsis>
<db:type>string</db:type>
<db:varname>description</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the description of the product once it has been successfully queried from the external market place. The title is localized if the external market place has defined a description in the current users locale.</db:para>
</db:section>
<db:section xml:id="identifier-prop">
<db:title>identifier : string</db:title>
<db:fieldsynopsis>
<db:type>string</db:type>
<db:varname>identifier</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the identifier of the product in the external market place. It must match the identifier used to register the product externally before-hand.</db:para>
<db:para>When both the identifier and <db:link xlink:href="qml-qtpurchasing-product.xml#type-prop">type</db:link> is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</db:para>
<db:para>The following example queries an unlockable product named &quot;myUnlockableProduct&quot; from the external market place.</db:para>
<db:programlisting language="qml">Store {
    Product {
      identifier: &quot;myUnlockableProduct&quot;
      type: Product.Unlockable

      // ...
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="price-prop">
<db:title>price : string</db:title>
<db:fieldsynopsis>
<db:type>string</db:type>
<db:varname>price</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the price of the product once it has been successfully queried from the external market place. The price is a string consisting of both currency and value, and is usually localized to the current user.</db:para>
<db:para>For example, the following example displays the price of the unlockable product named &quot;myUnlockableProduct&quot;:</db:para>
<db:programlisting language="cpp">Store {
    Product {
        id: myUnlockableProduct
        identifier: &quot;myUnlockableProduct&quot;
        type: Product.Unlockable

        // ...
    }
}

Text {
    text: myUnlockableProduct.status === Product.Registered
          ? &quot;Price is &quot; + myUnlockableProduct.price
          : &quot;Price unknown at the moment&quot;
}
</db:programlisting>
<db:para>When run in a Norwegian locale, this code could for instance display &quot;Price is kr 6,00&quot; for a one-dollar product.</db:para>
</db:section>
<db:section xml:id="status-prop">
<db:title>status : enumeration</db:title>
<db:fieldsynopsis>
<db:type>enumeration</db:type>
<db:varname>status</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the current status of the product in the registration sequence.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Product.Uninitialized - This is initial status, before the identifier property has been set.</db:para>
</db:listitem>
<db:listitem>
<db:para>Product.PendingRegistration - Indicates that the product is currently being queried from the external market place. The product gets this status when its identifier is set.</db:para>
</db:listitem>
<db:listitem>
<db:para>Product.Registered - Indicates that the product was successfully found in the external market place. Its price can now be queried and the product can be purchased.</db:para>
</db:listitem>
<db:listitem>
<db:para>Product.Unknown - The product could not be found in the external market place. This could for example be due to misspelling the product identifier.</db:para>
</db:listitem>
</db:itemizedlist>
<db:programlisting language="qml">Store {
    Product {
        identifier: &quot;myConsumableProduct&quot;
        type: Product.Consumable
        onStatusChanged: {
            switch (status) {
            case Product.PendingRegistration: console.debug(&quot;Registering &quot; + identifier); break
            case Product.Registered: console.debug(identifier + &quot; registered with price &quot; + price); break
            case Product.Unknown: console.debug(identifier + &quot; was not found in the market place&quot;); break
            }
        }

        // ...
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="store-prop">
<db:title>store : object</db:title>
<db:fieldsynopsis>
<db:type>object</db:type>
<db:varname>store</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the store containing the product. When the product is created as a child of the store, this is set automatically to the parent, as in the following example:</db:para>
<db:programlisting language="qml">Store {
    Product {
      // No need to set the store explicitly here, as it will automatically be
      // bound to the parent
      identifier: &quot;myConsumableProduct&quot;
      type: Product.Consumable
    }
    Product {
      // No need to set the store explicitly here, as it will automatically be
      // bound to the parent
      identifier: &quot;myUnlockableProduct&quot;
      type: Product.Unlockable
    }
}
</db:programlisting>
<db:para>However, in some advanced use cases, for example when products are created based on a model, it's also possible to create the product anywhere in the QML document and set the store explicitly, like in the following example:</db:para>
<db:programlisting language="cpp">ListModel {
    id: productModel
    ListElement {
        productIdentifier: &quot;myConsumableProduct&quot;
        productType: Product.Consumable
    }
    ListElement {
        productIdentifier: &quot;myUnlockableProduct&quot;
        productType: Product.Unlockable
    }
}

Store {
    id: myStore
}

Instantiator {
    model: productModel
    delegate: Product {
                    identifier: productIdentifier
                    type: productType
                    store: myStore
              }
}
</db:programlisting>
</db:section>
<db:section xml:id="title-prop">
<db:title>title : string</db:title>
<db:fieldsynopsis>
<db:type>string</db:type>
<db:varname>title</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the title of the product once it has been successfully queried from the external market place. The title is localized if the external market place has defined a title in the current users locale.</db:para>
</db:section>
<db:section xml:id="type-prop">
<db:title>type : string</db:title>
<db:fieldsynopsis>
<db:type>string</db:type>
<db:varname>type</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the type of the product in the external market place.</db:para>
<db:para>It can hold one of the following values:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Product.Consumable The product is consumable and can be purchased more than once by the same user, granted that the transaction for the previous purchase has been finalized.</db:para>
</db:listitem>
<db:listitem>
<db:para>Product.Unlockable The product can only be purchased once per user. If the application is uninstalled and reinstalled on the device (or installed on a new device by the same user), purchases of unlockable products can be restored using the store's <db:link xlink:href="qml-qtpurchasing-store.xml#restorePurchases-method">restorePurchases</db:link>() method.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>When both the <db:link xlink:href="qml-qtpurchasing-product.xml#identifier-prop">identifier</db:link> and type is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</db:para>
<db:para>The following example queries an unlockable product named &quot;myUnlockableProduct&quot; from the external market place.</db:para>
<db:programlisting language="qml">Store {
    Product {
      identifier: &quot;myUnlockableProduct&quot;
      type: Product.Unlockable

      // ...
    }
}
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="signal-documentation">
<db:title>Signal Documentation</db:title>
<db:section xml:id="onPurchaseFailed-signal">
<db:title>onPurchaseFailed(object <db:emphasis>transaction</db:emphasis>)</db:title>
<db:para>This handler is called when a purchase was requested for a given product, but the purchase failed. This will typically happen if the application calls <db:link xlink:href="qml-qtpurchasing-product.xml#purchase-method">purchase</db:link>() on a product, and the user subsequently cancels the purchase. It could also happen under other circumstances, for example if there is no suitable network connection.</db:para>
<db:para>All products should have an <db:code>onPurchaseFailed</db:code> handler.</db:para>
<db:para>After a proper reaction is taken, the finalize() function should be called on the <db:code role="parameter">transaction</db:code> object. If this is not done, the handler may be called again the next time the product is registered.</db:para>
<db:para>The following example reacts to a failed purchase attempt by calling a custom function to display a message to the user.</db:para>
<db:programlisting language="qml">Store {
    Product {
        id: myConsumableProduct
        identifier: &quot;myConsumableProduct&quot;
        type: Product.Consumable

        onPurchaseFailed: {
            myDisplayHelper.message(&quot;Product was not purchased. You have not been charged.&quot;)
            transaction.finalize()
        }

        // ...
    }
}
</db:programlisting>
<db:note>
<db:para>The corresponding handler is <db:code>onOnPurchaseFailed</db:code>.</db:para>
</db:note>
</db:section>
<db:section xml:id="onPurchaseRestored-signal">
<db:title>onPurchaseRestored(object <db:emphasis>transaction</db:emphasis>)</db:title>
<db:para>This handler is called when a previously purchased unlockable product is restored. This can happen when the <db:link xlink:href="qml-qtpurchasing-store.xml#restorePurchases-method">restorePurchases</db:link>() function in the current <db:link xlink:href="qml-qtpurchasing-store.xml">Store</db:link> is called. The <db:code>onPurchaseRestored</db:code> handler will then be called for each unlockable product which has previously been purchased by the user.</db:para>
<db:para>Applications which uses the <db:link xlink:href="qml-qtpurchasing-store.xml#restorePurchases-method">restorePurchases</db:link>() function should include this handler in all unlockable products. In the handler, the application should make sure information about the purchase is stored and call <db:link xlink:href="qml-qtpurchasing-transaction.xml#finalize-method">finalize</db:link>() on the <db:code role="parameter">transaction</db:code> object if the information has been successfully stored (or has been verified to already be stored).</db:para>
<db:para>The following example calls a custom function which either saves the information about the purchase or verifies that it is already saved. When the data has been verified, it finalizes the transaction. If it could not be verified, it calls another custom function to display an error message to the user. If the transaction is not finalized, the handler will be called again for the same transaction the next time the product is registered (on application start-up).</db:para>
<db:programlisting language="qml">Store {
    Product {
        id: myUnlockableProduct
        identifier: &quot;myUnlockableProduct&quot;
        type: Product.Unlockable

        onPurchaseRestored: {
            if (myStorage.savePurchaseInformation(identifier)) {
                transaction.finalize()
            } else {
                myDisplayHelper.message(&quot;Failed to store purchase information. Is there available storage?&quot;)
            }
        }

        // ...
    }
}
</db:programlisting>
<db:note>
<db:para>The corresponding handler is <db:code>onOnPurchaseRestored</db:code>.</db:para>
</db:note>
</db:section>
<db:section xml:id="onPurchaseSucceeded-signal">
<db:title>onPurchaseSucceeded(object <db:emphasis>transaction</db:emphasis>)</db:title>
<db:para>This handler is called when a product has been purchased successfully. It is triggered when the application has called <db:link xlink:href="qml-qtpurchasing-product.xml#purchase-method">purchase</db:link>() on the product and the user has subsequently confirmed the purchase, for example by entering their password.</db:para>
<db:para>All products should have a handler for onPurchaseSucceeded. This handler should in turn save information about the purchased product and when the information has been stored and verified, it should call finalize() on the <db:code role="parameter">transaction</db:code> object.</db:para>
<db:para>The handler should support being called multiple times for the same purchase. For example, the application execution might by accident be interrupted after saving the purchase information, but before finalizing the transaction. In this case, the handler should verify that the information is already stored in the persistent storage and then finalize the transaction.</db:para>
<db:para>The following example attempts to store the purchase state of a consumable product using a custom made function. It only finalizes the transaction if saving the data was successful. Otherwise, it calls another custom function to display an error message to the user.</db:para>
<db:programlisting language="qml">Store {
    Product {
        id: myConsumableProduct
        identifier: &quot;myConsumableProduct&quot;
        type: Product.Consumable

        onPurchaseSucceeded: {
            if (myStorage.savePurchaseInformation(identifier)) {
                transaction.finalize()
            } else {
                myDisplayHelper.message(&quot;Failed to store purchase information. Is there available storage?&quot;)
            }
        }

        // ...
    }
}
</db:programlisting>
<db:para>If the transaction is not finalized, the onPurchaseSucceeded handler will be called again the next time the product is registered (on application startup.) This means that if saving the information failed, the user will have the opportunity of rectifying the problem (for example by deleting something else to make space for the data) and the transaction will be completed once they restart the application and the problem has been solved.</db:para>
<db:note>
<db:para>A purchased, consumable product can not be purchased again until its previous transaction is finalized.</db:para>
</db:note>
<db:note>
<db:para>The corresponding handler is <db:code>onOnPurchaseSucceeded</db:code>.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="method-documentation">
<db:title>Method Documentation</db:title>
<db:section xml:id="purchase-method">
<db:title>purchase()</db:title>
<db:para>Launches the purchasing process for this product. The purchasing process is asynchronous. When it completes, either the <db:link xlink:href="qml-qtpurchasing-product.xml#onPurchaseSucceeded-signal">onPurchaseSucceeded</db:link> or the <db:link xlink:href="qml-qtpurchasing-product.xml#onPurchaseFailed-signal">onPurchaseFailed</db:link> handler in the object will be called with the resulting transaction.</db:para>
</db:section>
<db:section xml:id="resetStatus-method">
<db:title>[since QtPurchasing 1.0.2] resetStatus()</db:title>
<db:para>Resets the <db:link xlink:href="qml-qtpurchasing-product.xml#status-prop">status</db:link> of this product and retries querying it from the external market place.</db:para>
<db:para>This method can be used when querying the product failed for some reason (such as network timeouts).</db:para>
<db:para>This method was introduced in QtPurchasing 1.0.2.</db:para>
</db:section>
</db:section>
</db:article>
