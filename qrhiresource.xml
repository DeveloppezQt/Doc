<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRhiResource Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Base class for classes encapsulating native resource objects.</db:para>
<db:para>This class was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>rhi/qrhi.h</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui-private</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qrhibuffer.xml" xlink:role="class">QRhiBuffer</db:link>, <db:link xlink:href="qrhicommandbuffer.xml" xlink:role="class">QRhiCommandBuffer</db:link>, <db:link xlink:href="qrhicomputepipeline.xml" xlink:role="class">QRhiComputePipeline</db:link>, <db:link xlink:href="qrhigraphicspipeline.xml" xlink:role="class">QRhiGraphicsPipeline</db:link>, <db:link xlink:href="qrhirenderbuffer.xml" xlink:role="class">QRhiRenderBuffer</db:link>, <db:link xlink:href="qrhirenderpassdescriptor.xml" xlink:role="class">QRhiRenderPassDescriptor</db:link>, <db:link xlink:href="qrhirendertarget.xml" xlink:role="class">QRhiRenderTarget</db:link>, <db:link xlink:href="qrhisampler.xml" xlink:role="class">QRhiSampler</db:link>, <db:link xlink:href="qrhishaderresourcebindings.xml" xlink:role="class">QRhiShaderResourceBindings</db:link>, <db:link xlink:href="qrhiswapchain.xml" xlink:role="class">QRhiSwapChain</db:link>, and <db:link xlink:href="qrhitexture.xml" xlink:role="class">QRhiTexture</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:note>
<db:para>This is a RHI API with limited compatibility guarantees, see <db:link xlink:href="qrhi.xml">QRhi</db:link> for details.</db:para>
</db:note>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Type-enum">
<db:title>enum QRhiResource::Type</db:title>
<db:para>Specifies type of the resource.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiresource.xml">QRhiResource</db:link></db:emphasis>::Buffer</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiresource.xml">QRhiResource</db:link></db:emphasis>::Texture</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiresource.xml">QRhiResource</db:link></db:emphasis>::Sampler</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiresource.xml">QRhiResource</db:link></db:emphasis>::RenderBuffer</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiresource.xml">QRhiResource</db:link></db:emphasis>::RenderPassDescriptor</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiresource.xml">QRhiResource</db:link></db:emphasis>::SwapChainRenderTarget</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiresource.xml">QRhiResource</db:link></db:emphasis>::TextureRenderTarget</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiresource.xml">QRhiResource</db:link></db:emphasis>::ShaderResourceBindings</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiresource.xml">QRhiResource</db:link></db:emphasis>::GraphicsPipeline</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiresource.xml">QRhiResource</db:link></db:emphasis>::SwapChain</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiresource.xml">QRhiResource</db:link></db:emphasis>::ComputePipeline</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiresource.xml">QRhiResource</db:link></db:emphasis>::CommandBuffer</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="dtor.QRhiResource">
<db:title>[virtual noexcept] QRhiResource::~QRhiResource()</db:title>
<db:para>Destructor.</db:para>
<db:para>Releases (or requests deferred releasing of) the underlying native graphics resources, if there are any.</db:para>
<db:note>
<db:para>Resources referenced by commands for the current frame should not be released until the frame is submitted by <db:link xlink:href="qrhi.xml#endFrame">QRhi::endFrame</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">destroy()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="deleteLater">
<db:title>void QRhiResource::deleteLater()</db:title>
<db:para>When called without a frame being recorded, this function is equivalent to deleting the object. Between a <db:link xlink:href="qrhi.xml#beginFrame">QRhi::beginFrame</db:link>() and <db:link xlink:href="qrhi.xml#endFrame">QRhi::endFrame</db:link>() however the behavior is different: the <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> will not be destroyed until the frame is submitted via <db:link xlink:href="qrhi.xml#endFrame">QRhi::endFrame</db:link>(), thus satisfying the <db:link xlink:href="qrhi.xml">QRhi</db:link> requirement of not altering <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> objects that are referenced by the frame being recorded.</db:para>
<db:para>If the <db:link xlink:href="qrhi.xml">QRhi</db:link> that created this object is already destroyed, the object is deleted immediately.</db:para>
<db:para>Using deleteLater() can be a useful convenience in many cases, and it complements the low-level guarantee (that the underlying native graphics objects are never destroyed until it is safe to do so and it is known for sure that they are not used by the GPU in an still in-flight frame), by offering a way to make sure the C++ object instances (of <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link>, <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>, etc.) themselves also stay valid until the end of the current frame.</db:para>
<db:para>The following example shows a convenient way of creating a throwaway buffer that is only used in one frame and gets automatically released in endFrame(). (when it comes to the underlying native buffer(s), the usual guarantee applies: the <db:link xlink:href="qrhi.xml">QRhi</db:link> backend defers the releasing of those until it is guaranteed that the frame in which the buffer is accessed by the GPU has completed)</db:para>
<db:programlisting language="cpp">rhi-&gt;beginFrame(swapchain);
QRhiBuffer *buf = rhi-&gt;newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, 256);
buf-&gt;deleteLater(); // !
u = rhi-&gt;nextResourceUpdateBatch();
u-&gt;uploadStaticBuffer(buf, data);
// ... draw with buf
rhi-&gt;endFrame();
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">destroy()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="globalResourceId">
<db:title>quint64 QRhiResource::globalResourceId() const</db:title>
<db:para>Returns the global, unique identifier of this <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link>.</db:para>
<db:para>User code rarely needs to deal with the value directly. It is used internally for tracking and bookkeeping purposes.</db:para>
</db:section>
<db:section xml:id="name">
<db:title>QByteArray QRhiResource::name() const</db:title>
<db:para>Returns the currently set object name. By default the name is empty.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiresource.xml#setName">setName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rhi">
<db:title>QRhi *QRhiResource::rhi() const</db:title>
<db:para>Returns the <db:link xlink:href="qrhi.xml">QRhi</db:link> that created this resource.</db:para>
<db:para>If the <db:link xlink:href="qrhi.xml">QRhi</db:link> that created this object is already destroyed, the result is <db:code>nullptr</db:code>.</db:para>
</db:section>
<db:section xml:id="setName">
<db:title>void QRhiResource::setName(const QByteArray &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:para>Sets a <db:code role="parameter">name</db:code> for the object.</db:para>
<db:para>This allows getting descriptive names for the native graphics resources visible in graphics debugging tools, such as <db:link xlink:href="https://renderdoc.org/">RenderDoc</db:link> and <db:link xlink:href="https://developer.apple.com/xcode/">XCode</db:link>.</db:para>
<db:para>When it comes to naming native objects by relaying the name via the appropriate graphics API, note that the name is ignored when <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::DebugMarkers</db:link> are not supported, and may, depending on the backend, also be ignored when <db:link xlink:href="qrhi.xml#Flag-enum">QRhi::EnableDebugMarkers</db:link> is not set.</db:para>
<db:note>
<db:para>The name may be ignored for objects other than buffers, renderbuffers, and textures, depending on the backend.</db:para>
</db:note>
<db:note>
<db:para>The name may be modified. For slotted resources, such as a <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> backed by multiple native buffers, <db:link xlink:href="qrhi.xml">QRhi</db:link> will append a suffix to make the underlying native buffers easily distinguishable from each other.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiresource.xml#name">name</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
