<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QIODevice Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qiodevice.xml">QIODevice</db:link> class is the base interface class of all I/O devices in Qt.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QIODevice</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qabstractsocket.xml" xlink:role="class">QAbstractSocket</db:link>, <db:link xlink:href="qbluetoothsocket.xml" xlink:role="class">QBluetoothSocket</db:link>, <db:link xlink:href="qbuffer.xml" xlink:role="class">QBuffer</db:link>, <db:link xlink:href="qfiledevice.xml" xlink:role="class">QFileDevice</db:link>, <db:link xlink:href="qlocalsocket.xml" xlink:role="class">QLocalSocket</db:link>, <db:link xlink:href="qnetworkreply.xml" xlink:role="class">QNetworkReply</db:link>, <db:link xlink:href="qprocess.xml" xlink:role="class">QProcess</db:link>, and <db:link xlink:href="qserialport.xml" xlink:role="class">QSerialPort</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QIODevice is part of <db:simplelist><db:member><db:link xlink:href="io.xml">Input/Output and Networking</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qiodevice.xml">QIODevice</db:link> provides both a common implementation and an abstract interface for devices that support reading and writing of blocks of data, such as <db:link xlink:href="qfile.xml">QFile</db:link>, <db:link xlink:href="qbuffer.xml">QBuffer</db:link> and <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>. <db:link xlink:href="qiodevice.xml">QIODevice</db:link> is abstract and can not be instantiated, but it is common to use the interface it defines to provide device-independent I/O features. For example, Qt's XML classes operate on a <db:link xlink:href="qiodevice.xml">QIODevice</db:link> pointer, allowing them to be used with various devices (such as files and buffers).</db:para>
<db:para>Before accessing the device, <db:link xlink:href="qiodevice.xml#open">open</db:link>() must be called to set the correct <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link> (such as <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">ReadOnly</db:link> or <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">ReadWrite</db:link>). You can then write to the device with <db:link xlink:href="qiodevice.xml#write">write</db:link>() or <db:link xlink:href="qiodevice.xml#putChar">putChar</db:link>(), and read by calling either <db:link xlink:href="qiodevice.xml#read">read</db:link>(), <db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>(), or <db:link xlink:href="qiodevice.xml#readAll">readAll</db:link>(). Call <db:link xlink:href="qiodevice.xml#close">close</db:link>() when you are done with the device.</db:para>
<db:para><db:link xlink:href="qiodevice.xml">QIODevice</db:link> distinguishes between two types of devices: random-access devices and sequential devices.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Random-access devices support seeking to arbitrary positions using <db:link xlink:href="qiodevice.xml#seek">seek</db:link>(). The current position in the file is available by calling <db:link xlink:href="qiodevice.xml#pos">pos</db:link>(). <db:link xlink:href="qfile.xml">QFile</db:link> and <db:link xlink:href="qbuffer.xml">QBuffer</db:link> are examples of random-access devices.</db:para>
</db:listitem>
<db:listitem>
<db:para>Sequential devices don't support seeking to arbitrary positions. The data must be read in one pass. The functions <db:link xlink:href="qiodevice.xml#pos">pos</db:link>() and <db:link xlink:href="qiodevice.xml#size">size</db:link>() don't work for sequential devices. <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> and <db:link xlink:href="qprocess.xml">QProcess</db:link> are examples of sequential devices.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>You can use <db:link xlink:href="qiodevice.xml#isSequential">isSequential</db:link>() to determine the type of device.</db:para>
<db:para><db:link xlink:href="qiodevice.xml">QIODevice</db:link> emits <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() when new data is available for reading; for example, if new data has arrived on the network or if additional data is appended to a file that you are reading from. You can call <db:link xlink:href="qiodevice.xml#bytesAvailable">bytesAvailable</db:link>() to determine the number of bytes that are currently available for reading. It's common to use <db:link xlink:href="qiodevice.xml#bytesAvailable">bytesAvailable</db:link>() together with the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal when programming with asynchronous devices such as <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>, where fragments of data can arrive at arbitrary points in time. <db:link xlink:href="qiodevice.xml">QIODevice</db:link> emits the <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>() signal every time a payload of data has been written to the device. Use <db:link xlink:href="qiodevice.xml#bytesToWrite">bytesToWrite</db:link>() to determine the current amount of data waiting to be written.</db:para>
<db:para>Certain subclasses of <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, such as <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> and <db:link xlink:href="qprocess.xml">QProcess</db:link>, are asynchronous. This means that I/O functions such as <db:link xlink:href="qiodevice.xml#write">write</db:link>() or <db:link xlink:href="qiodevice.xml#read">read</db:link>() always return immediately, while communication with the device itself may happen when control goes back to the event loop. <db:link xlink:href="qiodevice.xml">QIODevice</db:link> provides functions that allow you to force these operations to be performed immediately, while blocking the calling thread and without entering the event loop. This allows <db:link xlink:href="qiodevice.xml">QIODevice</db:link> subclasses to be used without an event loop, or in a separate thread:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qiodevice.xml#waitForReadyRead">waitForReadyRead</db:link>() - This function suspends operation in the calling thread until new data is available for reading.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qiodevice.xml#waitForBytesWritten">waitForBytesWritten</db:link>() - This function suspends operation in the calling thread until one payload of data has been written to the device.</db:para>
</db:listitem>
<db:listitem>
<db:para>waitFor....() - Subclasses of <db:link xlink:href="qiodevice.xml">QIODevice</db:link> implement blocking functions for device-specific operations. For example, <db:link xlink:href="qprocess.xml">QProcess</db:link> has a function called <db:link xlink:href="qprocess.xml#waitForStarted">waitForStarted</db:link>() which suspends operation in the calling thread until the process has started.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Calling these functions from the main, GUI thread, may cause your user interface to freeze. Example:</db:para>
<db:programlisting language="cpp">QProcess gzip;
gzip.start(&quot;gzip&quot;, QStringList() &lt;&lt; &quot;-c&quot;);
if (!gzip.waitForStarted())
    return false;

gzip.write(&quot;uncompressed data&quot;);

QByteArray compressed;
while (gzip.waitForReadyRead())
    compressed += gzip.readAll();
</db:programlisting>
<db:para>By subclassing <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, you can provide the same interface to your own I/O devices. Subclasses of <db:link xlink:href="qiodevice.xml">QIODevice</db:link> are only required to implement the protected <db:link xlink:href="qiodevice.xml#readData">readData</db:link>() and <db:link xlink:href="qiodevice.xml#writeData">writeData</db:link>() functions. <db:link xlink:href="qiodevice.xml">QIODevice</db:link> uses these functions to implement all its convenience functions, such as <db:link xlink:href="qiodevice.xml#getChar">getChar</db:link>(), <db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>() and <db:link xlink:href="qiodevice.xml#write">write</db:link>(). <db:link xlink:href="qiodevice.xml">QIODevice</db:link> also handles access control for you, so you can safely assume that the device is opened in write mode if <db:link xlink:href="qiodevice.xml#writeData">writeData</db:link>() is called.</db:para>
<db:para>Some subclasses, such as <db:link xlink:href="qfile.xml">QFile</db:link> and <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>, are implemented using a memory buffer for intermediate storing of data. This reduces the number of required device accessing calls, which are often very slow. Buffering makes functions like <db:link xlink:href="qiodevice.xml#getChar">getChar</db:link>() and <db:link xlink:href="qiodevice.xml#putChar">putChar</db:link>() fast, as they can operate on the memory buffer instead of directly on the device itself. Certain I/O operations, however, don't work well with a buffer. For example, if several users open the same device and read it character by character, they may end up reading the same data when they meant to read a separate chunk each. For this reason, <db:link xlink:href="qiodevice.xml">QIODevice</db:link> allows you to bypass any buffering by passing the Unbuffered flag to <db:link xlink:href="qiodevice.xml#open">open</db:link>(). When subclassing <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, remember to bypass any buffer you may use when the device is open in Unbuffered mode.</db:para>
<db:para>Usually, the incoming data stream from an asynchronous device is fragmented, and chunks of data can arrive at arbitrary points in time. To handle incomplete reads of data structures, use the transaction mechanism implemented by <db:link xlink:href="qiodevice.xml">QIODevice</db:link>. See <db:link xlink:href="qiodevice.xml#startTransaction">startTransaction</db:link>() and related functions for more details.</db:para>
<db:para>Some sequential devices support communicating via multiple channels. These channels represent separate streams of data that have the property of independently sequenced delivery. Once the device is opened, you can determine the number of channels by calling the <db:link xlink:href="qiodevice.xml#readChannelCount">readChannelCount</db:link>() and <db:link xlink:href="qiodevice.xml#writeChannelCount">writeChannelCount</db:link>() functions. To switch between channels, call <db:link xlink:href="qiodevice.xml#setCurrentReadChannel">setCurrentReadChannel</db:link>() and <db:link xlink:href="qiodevice.xml#setCurrentWriteChannel">setCurrentWriteChannel</db:link>(), respectively. <db:link xlink:href="qiodevice.xml">QIODevice</db:link> also provides additional signals to handle asynchronous communication on a per-channel basis.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbuffer.xml">QBuffer</db:link></db:member>
<db:member><db:link xlink:href="qfile.xml">QFile</db:link></db:member>
<db:member><db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="OpenModeFlag-enum">
<db:title>enum QIODevice::OpenModeFlag</db:title>
<db:bridgehead renderas="sect2">flags QIODevice::OpenMode</db:bridgehead>
<db:para>This enum is used with <db:link xlink:href="qiodevice.xml#open">open</db:link>() to describe the mode in which a device is opened. It is also returned by <db:link xlink:href="qiodevice.xml#openMode">openMode</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qiodevice.xml">QIODevice</db:link></db:emphasis>::NotOpen</db:code></db:para>
</db:td>
<db:td><db:code>0x0000</db:code></db:td>
<db:td>
<db:para>The device is not open.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qiodevice.xml">QIODevice</db:link></db:emphasis>::ReadOnly</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>The device is open for reading.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qiodevice.xml">QIODevice</db:link></db:emphasis>::WriteOnly</db:code></db:para>
</db:td>
<db:td><db:code>0x0002</db:code></db:td>
<db:td>
<db:para>The device is open for writing. Note that this mode implies Truncate.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qiodevice.xml">QIODevice</db:link></db:emphasis>::ReadWrite</db:code></db:para>
</db:td>
<db:td><db:code>ReadOnly | WriteOnly</db:code></db:td>
<db:td>
<db:para>The device is open for reading and writing.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qiodevice.xml">QIODevice</db:link></db:emphasis>::Append</db:code></db:para>
</db:td>
<db:td><db:code>0x0004</db:code></db:td>
<db:td>
<db:para>The device is opened in append mode so that all data is written to the end of the file.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qiodevice.xml">QIODevice</db:link></db:emphasis>::Truncate</db:code></db:para>
</db:td>
<db:td><db:code>0x0008</db:code></db:td>
<db:td>
<db:para>If possible, the device is truncated before it is opened. All earlier contents of the device are lost.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qiodevice.xml">QIODevice</db:link></db:emphasis>::Text</db:code></db:para>
</db:td>
<db:td><db:code>0x0010</db:code></db:td>
<db:td>
<db:para>When reading, the end-of-line terminators are translated to '\n'. When writing, the end-of-line terminators are translated to the local encoding, for example '\r\n' for Win32.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qiodevice.xml">QIODevice</db:link></db:emphasis>::Unbuffered</db:code></db:para>
</db:td>
<db:td><db:code>0x0020</db:code></db:td>
<db:td>
<db:para>Any buffer in the device is bypassed.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Certain flags, such as <db:code>Unbuffered</db:code> and <db:code>Truncate</db:code>, are meaningless when used with some subclasses. Some of these restrictions are implied by the type of device that is represented by a subclass. In other cases, the restriction may be due to the implementation, or may be imposed by the underlying platform; for example, <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> does not support <db:code>Unbuffered</db:code> mode, and limitations in the native API prevent <db:link xlink:href="qfile.xml">QFile</db:link> from supporting <db:code>Unbuffered</db:code> on Windows.</db:para>
<db:para>The <db:code>OpenMode</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;OpenModeFlag&gt;. </db:code>It stores an OR combination of <db:code>OpenModeFlag</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QIODevice">
<db:title>QIODevice::QIODevice()</db:title>
<db:para>Constructs a <db:link xlink:href="qiodevice.xml">QIODevice</db:link> object.</db:para>
</db:section>
<db:section xml:id="QIODevice-1">
<db:title>[explicit] QIODevice::QIODevice(QObject *<db:emphasis>parent</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qiodevice.xml">QIODevice</db:link> object with the given <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QIODevice">
<db:title>[virtual noexcept] QIODevice::~QIODevice()</db:title>
<db:para>The destructor is virtual, and <db:link xlink:href="qiodevice.xml">QIODevice</db:link> is an abstract base class. This destructor does not call <db:link xlink:href="qiodevice.xml#close">close</db:link>(), but the subclass destructor might. If you are in doubt, call <db:link xlink:href="qiodevice.xml#close">close</db:link>() before destroying the <db:link xlink:href="qiodevice.xml">QIODevice</db:link>.</db:para>
</db:section>
<db:section xml:id="aboutToClose">
<db:title>void QIODevice::aboutToClose()</db:title>
<db:para>This signal is emitted when the device is about to close. Connect this signal if you have operations that need to be performed before the device closes (e.g., if you have data in a separate buffer that needs to be written to the device).</db:para>
</db:section>
<db:section xml:id="atEnd">
<db:title>[virtual] bool QIODevice::atEnd() const</db:title>
<db:para>Returns <db:code>true</db:code> if the current read and write position is at the end of the device (i.e. there is no more data available for reading on the device); otherwise returns <db:code>false</db:code>.</db:para>
<db:para>For some devices, atEnd() can return true even though there is more data to read. This special case only applies to devices that generate data in direct response to you calling <db:link xlink:href="qiodevice.xml#read">read</db:link>() (e.g., <db:code>/dev</db:code> or <db:code>/proc</db:code> files on Unix and macOS, or console input / <db:code>stdin</db:code> on all platforms).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#bytesAvailable">bytesAvailable</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#isSequential">isSequential</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesAvailable">
<db:title>[virtual] qint64 QIODevice::bytesAvailable() const</db:title>
<db:para>Returns the number of bytes that are available for reading. This function is commonly used with sequential devices to determine the number of bytes to allocate in a buffer before reading.</db:para>
<db:para>Subclasses that reimplement this function must call the base implementation in order to include the size of the buffer of <db:link xlink:href="qiodevice.xml">QIODevice</db:link>. Example:</db:para>
<db:programlisting language="cpp">qint64 CustomDevice::bytesAvailable() const
{
    return buffer.size() + QIODevice::bytesAvailable();
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#bytesToWrite">bytesToWrite</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#isSequential">isSequential</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesToWrite">
<db:title>[virtual] qint64 QIODevice::bytesToWrite() const</db:title>
<db:para>For buffered devices, this function returns the number of bytes waiting to be written. For devices with no buffer, this function returns 0.</db:para>
<db:para>Subclasses that reimplement this function must call the base implementation in order to include the size of the buffer of <db:link xlink:href="qiodevice.xml">QIODevice</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#bytesAvailable">bytesAvailable</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#isSequential">isSequential</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesWritten">
<db:title>void QIODevice::bytesWritten(qint64 <db:emphasis>bytes</db:emphasis>)</db:title>
<db:para>This signal is emitted every time a payload of data has been written to the device's current write channel. The <db:code role="parameter">bytes</db:code> argument is set to the number of bytes that were written in this payload.</db:para>
<db:para>bytesWritten() is not emitted recursively; if you reenter the event loop or call <db:link xlink:href="qiodevice.xml#waitForBytesWritten">waitForBytesWritten</db:link>() inside a slot connected to the bytesWritten() signal, the signal will not be reemitted (although <db:link xlink:href="qiodevice.xml#waitForBytesWritten">waitForBytesWritten</db:link>() may still return true).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canReadLine">
<db:title>[virtual] bool QIODevice::canReadLine() const</db:title>
<db:para>Returns <db:code>true</db:code> if a complete line of data can be read from the device; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Note that unbuffered devices, which have no way of determining what can be read, always return false.</db:para>
<db:para>This function is often called in conjunction with the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal.</db:para>
<db:para>Subclasses that reimplement this function must call the base implementation in order to include the contents of the <db:link xlink:href="qiodevice.xml">QIODevice</db:link>'s buffer. Example:</db:para>
<db:programlisting language="cpp">bool CustomDevice::canReadLine() const
{
    return buffer.contains('\n') || QIODevice::canReadLine();
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="channelBytesWritten">
<db:title>[since 5.7] void QIODevice::channelBytesWritten(int <db:emphasis>channel</db:emphasis>, qint64 <db:emphasis>bytes</db:emphasis>)</db:title>
<db:para>This signal is emitted every time a payload of data has been written to the device. The <db:code role="parameter">bytes</db:code> argument is set to the number of bytes that were written in this payload, while <db:code role="parameter">channel</db:code> is the channel they were written to. Unlike <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>(), it is emitted regardless of the <db:link xlink:href="qiodevice.xml#currentWriteChannel">current write channel</db:link>.</db:para>
<db:para>channelBytesWritten() can be emitted recursively - even for the same channel.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#channelReadyRead">channelReadyRead</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="channelReadyRead">
<db:title>[since 5.7] void QIODevice::channelReadyRead(int <db:emphasis>channel</db:emphasis>)</db:title>
<db:para>This signal is emitted when new data is available for reading from the device. The <db:code role="parameter">channel</db:code> argument is set to the index of the read channel on which the data has arrived. Unlike <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>(), it is emitted regardless of the <db:link xlink:href="qiodevice.xml#currentReadChannel">current read channel</db:link>.</db:para>
<db:para>channelReadyRead() can be emitted recursively - even for the same channel.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#channelBytesWritten">channelBytesWritten</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="close">
<db:title>[virtual] void QIODevice::close()</db:title>
<db:para>First emits <db:link xlink:href="qiodevice.xml#aboutToClose">aboutToClose</db:link>(), then closes the device and sets its <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link> to <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">NotOpen</db:link>. The error string is also reset.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#setOpenMode">setOpenMode</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="commitTransaction">
<db:title>[since 5.7] void QIODevice::commitTransaction()</db:title>
<db:para>Completes a read transaction.</db:para>
<db:para>For sequential devices, all data recorded in the internal buffer during the transaction will be discarded.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#startTransaction">startTransaction</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#rollbackTransaction">rollbackTransaction</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentReadChannel">
<db:title>[since 5.7] int QIODevice::currentReadChannel() const</db:title>
<db:para>Returns the index of the current read channel.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#setCurrentReadChannel">setCurrentReadChannel</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#readChannelCount">readChannelCount</db:link>()</db:member>
<db:member><db:link xlink:href="qprocess.xml">QProcess</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentWriteChannel">
<db:title>[since 5.7] int QIODevice::currentWriteChannel() const</db:title>
<db:para>Returns the the index of the current write channel.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#setCurrentWriteChannel">setCurrentWriteChannel</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#writeChannelCount">writeChannelCount</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QIODevice::errorString() const</db:title>
<db:para>Returns a human-readable description of the last device error that occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#setErrorString">setErrorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="getChar">
<db:title>bool QIODevice::getChar(char *<db:emphasis>c</db:emphasis>)</db:title>
<db:para>Reads one character from the device and stores it in <db:code role="parameter">c</db:code>. If <db:code role="parameter">c</db:code> is 0, the character is discarded. Returns <db:code>true</db:code> on success; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#putChar">putChar</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#ungetChar">ungetChar</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isOpen">
<db:title>bool QIODevice::isOpen() const</db:title>
<db:para>Returns <db:code>true</db:code> if the device is open; otherwise returns <db:code>false</db:code>. A device is open if it can be read from and/or written to. By default, this function returns <db:code>false</db:code> if <db:link xlink:href="qiodevice.xml#openMode">openMode</db:link>() returns <db:code>NotOpen</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#openMode">openMode</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isReadable">
<db:title>bool QIODevice::isReadable() const</db:title>
<db:para>Returns <db:code>true</db:code> if data can be read from the device; otherwise returns false. Use <db:link xlink:href="qiodevice.xml#bytesAvailable">bytesAvailable</db:link>() to determine how many bytes can be read.</db:para>
<db:para>This is a convenience function which checks if the <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link> of the device contains the <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">ReadOnly</db:link> flag.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#openMode">openMode</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSequential">
<db:title>[virtual] bool QIODevice::isSequential() const</db:title>
<db:para>Returns <db:code>true</db:code> if this device is sequential; otherwise returns false.</db:para>
<db:para>Sequential devices, as opposed to a random-access devices, have no concept of a start, an end, a size, or a current position, and they do not support seeking. You can only read from the device when it reports that data is available. The most common example of a sequential device is a network socket. On Unix, special files such as /dev/zero and fifo pipes are sequential.</db:para>
<db:para>Regular files, on the other hand, do support random access. They have both a size and a current position, and they also support seeking backwards and forwards in the data stream. Regular files are non-sequential.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#bytesAvailable">bytesAvailable</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isTextModeEnabled">
<db:title>bool QIODevice::isTextModeEnabled() const</db:title>
<db:para>Returns <db:code>true</db:code> if the <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">Text</db:link> flag is enabled; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#setTextModeEnabled">setTextModeEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isTransactionStarted">
<db:title>[since 5.7] bool QIODevice::isTransactionStarted() const</db:title>
<db:para>Returns <db:code>true</db:code> if a transaction is in progress on the device, otherwise <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#startTransaction">startTransaction</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isWritable">
<db:title>bool QIODevice::isWritable() const</db:title>
<db:para>Returns <db:code>true</db:code> if data can be written to the device; otherwise returns false.</db:para>
<db:para>This is a convenience function which checks if the <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link> of the device contains the <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">WriteOnly</db:link> flag.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#openMode">openMode</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="open">
<db:title>[virtual] bool QIODevice::open(QIODevice::OpenMode <db:emphasis>mode</db:emphasis>)</db:title>
<db:para>Opens the device and sets its <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link> to <db:code role="parameter">mode</db:code>. Returns <db:code>true</db:code> if successful; otherwise returns <db:code>false</db:code>. This function should be called from any reimplementations of open() or other functions that open the device.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#openMode">openMode</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="openMode">
<db:title>QIODevice::OpenMode QIODevice::openMode() const</db:title>
<db:para>Returns the mode in which the device has been opened; i.e. <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">ReadOnly</db:link> or <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">WriteOnly</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#setOpenMode">setOpenMode</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peek">
<db:title>[since 4.1] qint64 QIODevice::peek(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>Reads at most <db:code role="parameter">maxSize</db:code> bytes from the device into <db:code role="parameter">data</db:code>, without side effects (i.e., if you call <db:link xlink:href="qiodevice.xml#read">read</db:link>() after peek(), you will get the same data). Returns the number of bytes read. If an error occurs, such as when attempting to peek a device opened in <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">WriteOnly</db:link> mode, this function returns -1.</db:para>
<db:para>0 is returned when no more data is available for reading.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">bool isExeFile(QFile *file)
{
    char buf[2];
    if (file-&gt;peek(buf, sizeof(buf)) == sizeof(buf))
        return (buf[0] == 'M' &amp;&amp; buf[1] == 'Z');
    return false;
}
</db:programlisting>
<db:para>This function was introduced in Qt 4.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peek-1">
<db:title>[since 4.1] QByteArray QIODevice::peek(qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Peeks at most <db:code role="parameter">maxSize</db:code> bytes from the device, returning the data peeked as a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">bool isExeFile(QFile *file)
{
    return file-&gt;peek(2) == &quot;MZ&quot;;
}
</db:programlisting>
<db:para>This function has no way of reporting errors; returning an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link> can mean either that no data was currently available for peeking, or that an error occurred.</db:para>
<db:para>This function was introduced in Qt 4.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pos">
<db:title>[virtual] qint64 QIODevice::pos() const</db:title>
<db:para>For random-access devices, this function returns the position that data is written to or read from. For sequential devices or closed devices, where there is no concept of a &quot;current position&quot;, 0 is returned.</db:para>
<db:para>The current read/write position of the device is maintained internally by <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, so reimplementing this function is not necessary. When subclassing <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, use <db:link xlink:href="qiodevice.xml#seek">QIODevice::seek</db:link>() to notify <db:link xlink:href="qiodevice.xml">QIODevice</db:link> about changes in the device position.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#isSequential">isSequential</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#seek">seek</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="putChar">
<db:title>bool QIODevice::putChar(char <db:emphasis>c</db:emphasis>)</db:title>
<db:para>Writes the character <db:code role="parameter">c</db:code> to the device. Returns <db:code>true</db:code> on success; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#write">write</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#getChar">getChar</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#ungetChar">ungetChar</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="read">
<db:title>qint64 QIODevice::read(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>Reads at most <db:code role="parameter">maxSize</db:code> bytes from the device into <db:code role="parameter">data</db:code>, and returns the number of bytes read. If an error occurs, such as when attempting to read from a device opened in <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">WriteOnly</db:link> mode, this function returns -1.</db:para>
<db:para>0 is returned when no more data is available for reading. However, reading past the end of the stream is considered an error, so this function returns -1 in those cases (that is, reading on a closed socket or after a process has died).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#readData">readData</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#write">write</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="read-1">
<db:title>QByteArray QIODevice::read(qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Reads at most <db:code role="parameter">maxSize</db:code> bytes from the device, and returns the data read as a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>This function has no way of reporting errors; returning an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link> can mean either that no data was currently available for reading, or that an error occurred.</db:para>
</db:section>
<db:section xml:id="readAll">
<db:title>QByteArray QIODevice::readAll()</db:title>
<db:para>Reads all remaining data from the device, and returns it as a byte array.</db:para>
<db:para>This function has no way of reporting errors; returning an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link> can mean either that no data was currently available for reading, or that an error occurred.</db:para>
</db:section>
<db:section xml:id="readChannelCount">
<db:title>[since 5.7] int QIODevice::readChannelCount() const</db:title>
<db:para>Returns the number of available read channels if the device is open; otherwise returns 0.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#writeChannelCount">writeChannelCount</db:link>()</db:member>
<db:member><db:link xlink:href="qprocess.xml">QProcess</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readChannelFinished">
<db:title>[since 4.4] void QIODevice::readChannelFinished()</db:title>
<db:para>This signal is emitted when the input (reading) stream is closed in this device. It is emitted as soon as the closing is detected, which means that there might still be data available for reading with <db:link xlink:href="qiodevice.xml#read">read</db:link>().</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#atEnd">atEnd</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readData">
<db:title>[pure virtual protected] qint64 QIODevice::readData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>Reads up to <db:code role="parameter">maxSize</db:code> bytes from the device into <db:code role="parameter">data</db:code>, and returns the number of bytes read or -1 if an error occurred.</db:para>
<db:para>If there are no bytes to be read and there can never be more bytes available (examples include socket closed, pipe closed, sub-process finished), this function returns -1.</db:para>
<db:para>This function is called by <db:link xlink:href="qiodevice.xml">QIODevice</db:link>. Reimplement this function when creating a subclass of <db:link xlink:href="qiodevice.xml">QIODevice</db:link>.</db:para>
<db:para>When reimplementing this function it is important that this function reads all the required data before returning. This is required in order for <db:link xlink:href="qdatastream.xml">QDataStream</db:link> to be able to operate on the class. <db:link xlink:href="qdatastream.xml">QDataStream</db:link> assumes all the requested information was read and therefore does not retry reading if there was a problem.</db:para>
<db:para>This function might be called with a maxSize of 0, which can be used to perform post-reading operations.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#writeData">writeData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readLine">
<db:title>qint64 QIODevice::readLine(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>This function reads a line of ASCII characters from the device, up to a maximum of <db:code role="parameter">maxSize</db:code> - 1 bytes, stores the characters in <db:code role="parameter">data</db:code>, and returns the number of bytes read. If a line could not be read but no error ocurred, this function returns 0. If an error occurs, this function returns the length of what could be read, or -1 if nothing was read.</db:para>
<db:para>A terminating '\0' byte is always appended to <db:code role="parameter">data</db:code>, so <db:code role="parameter">maxSize</db:code> must be larger than 1.</db:para>
<db:para>Data is read until either of the following conditions are met:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The first '\n' character is read.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code role="parameter">maxSize</db:code> - 1 bytes are read.</db:para>
</db:listitem>
<db:listitem>
<db:para>The end of the device data is detected.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For example, the following code reads a line of characters from a file:</db:para>
<db:programlisting language="cpp">QFile file(&quot;box.txt&quot;);
if (file.open(QFile::ReadOnly)) {
    char buf[1024];
    qint64 lineLength = file.readLine(buf, sizeof(buf));
    if (lineLength != -1) {
        // the line is available in buf
    }
}
</db:programlisting>
<db:para>The newline character ('\n') is included in the buffer. If a newline is not encountered before maxSize - 1 bytes are read, a newline will not be inserted into the buffer. On windows newline characters are replaced with '\n'.</db:para>
<db:para>This function calls <db:link xlink:href="qiodevice.xml#readLineData">readLineData</db:link>(), which is implemented using repeated calls to <db:link xlink:href="qiodevice.xml#getChar">getChar</db:link>(). You can provide a more efficient implementation by reimplementing <db:link xlink:href="qiodevice.xml#readLineData">readLineData</db:link>() in your own subclass.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#getChar">getChar</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#write">write</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readLine-1">
<db:title>QByteArray QIODevice::readLine(qint64 <db:emphasis>maxSize</db:emphasis> = 0)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Reads a line from the device, but no more than <db:code role="parameter">maxSize</db:code> characters, and returns the result as a byte array.</db:para>
<db:para>This function has no way of reporting errors; returning an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link> can mean either that no data was currently available for reading, or that an error occurred.</db:para>
</db:section>
<db:section xml:id="readLineData">
<db:title>[virtual protected] qint64 QIODevice::readLineData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>Reads up to <db:code role="parameter">maxSize</db:code> characters into <db:code role="parameter">data</db:code> and returns the number of characters read.</db:para>
<db:para>This function is called by <db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>(), and provides its base implementation, using <db:link xlink:href="qiodevice.xml#getChar">getChar</db:link>(). Buffered devices can improve the performance of <db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>() by reimplementing this function.</db:para>
<db:para><db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>() appends a '\0' byte to <db:code role="parameter">data</db:code>; readLineData() does not need to do this.</db:para>
<db:para>If you reimplement this function, be careful to return the correct value: it should return the number of bytes read in this line, including the terminating newline, or 0 if there is no line to be read at this point. If an error occurs, it should return -1 if and only if no bytes were read. Reading past EOF is considered an error.</db:para>
</db:section>
<db:section xml:id="readyRead">
<db:title>void QIODevice::readyRead()</db:title>
<db:para>This signal is emitted once every time new data is available for reading from the device's current read channel. It will only be emitted again once new data is available, such as when a new payload of network data has arrived on your network socket, or when a new block of data has been appended to your device.</db:para>
<db:para>readyRead() is not emitted recursively; if you reenter the event loop or call <db:link xlink:href="qiodevice.xml#waitForReadyRead">waitForReadyRead</db:link>() inside a slot connected to the readyRead() signal, the signal will not be reemitted (although <db:link xlink:href="qiodevice.xml#waitForReadyRead">waitForReadyRead</db:link>() may still return true).</db:para>
<db:para>Note for developers implementing classes derived from <db:link xlink:href="qiodevice.xml">QIODevice</db:link>: you should always emit readyRead() when new data has arrived (do not emit it only because there's data still to be read in your buffers). Do not emit readyRead() in other conditions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reset">
<db:title>[virtual] bool QIODevice::reset()</db:title>
<db:para>Seeks to the start of input for random-access devices. Returns true on success; otherwise returns <db:code>false</db:code> (for example, if the device is not open).</db:para>
<db:para>Note that when using a <db:link xlink:href="qtextstream.xml">QTextStream</db:link> on a <db:link xlink:href="qfile.xml">QFile</db:link>, calling reset() on the <db:link xlink:href="qfile.xml">QFile</db:link> will not have the expected result because <db:link xlink:href="qtextstream.xml">QTextStream</db:link> buffers the file. Use the <db:link xlink:href="qtextstream.xml#seek">QTextStream::seek</db:link>() function instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#seek">seek</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rollbackTransaction">
<db:title>[since 5.7] void QIODevice::rollbackTransaction()</db:title>
<db:para>Rolls back a read transaction.</db:para>
<db:para>Restores the input stream to the point of the <db:link xlink:href="qiodevice.xml#startTransaction">startTransaction</db:link>() call. This function is commonly used to rollback the transaction when an incomplete read was detected prior to committing the transaction.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#startTransaction">startTransaction</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#commitTransaction">commitTransaction</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="seek">
<db:title>[virtual] bool QIODevice::seek(qint64 <db:emphasis>pos</db:emphasis>)</db:title>
<db:para>For random-access devices, this function sets the current position to <db:code role="parameter">pos</db:code>, returning true on success, or false if an error occurred. For sequential devices, the default behavior is to produce a warning and return false.</db:para>
<db:para>When subclassing <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, you must call QIODevice::seek() at the start of your function to ensure integrity with <db:link xlink:href="qiodevice.xml">QIODevice</db:link>'s built-in buffer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#pos">pos</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#isSequential">isSequential</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCurrentReadChannel">
<db:title>[since 5.7] void QIODevice::setCurrentReadChannel(int <db:emphasis>channel</db:emphasis>)</db:title>
<db:para>Sets the current read channel of the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> to the given <db:code role="parameter">channel</db:code>. The current input channel is used by the functions <db:link xlink:href="qiodevice.xml#read">read</db:link>(), <db:link xlink:href="qiodevice.xml#readAll">readAll</db:link>(), <db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>(), and <db:link xlink:href="qiodevice.xml#getChar">getChar</db:link>(). It also determines which channel triggers <db:link xlink:href="qiodevice.xml">QIODevice</db:link> to emit <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#currentReadChannel">currentReadChannel</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#readChannelCount">readChannelCount</db:link>()</db:member>
<db:member><db:link xlink:href="qprocess.xml">QProcess</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCurrentWriteChannel">
<db:title>[since 5.7] void QIODevice::setCurrentWriteChannel(int <db:emphasis>channel</db:emphasis>)</db:title>
<db:para>Sets the current write channel of the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> to the given <db:code role="parameter">channel</db:code>. The current output channel is used by the functions <db:link xlink:href="qiodevice.xml#write">write</db:link>(), <db:link xlink:href="qiodevice.xml#putChar">putChar</db:link>(). It also determines which channel triggers <db:link xlink:href="qiodevice.xml">QIODevice</db:link> to emit <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#currentWriteChannel">currentWriteChannel</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#writeChannelCount">writeChannelCount</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setErrorString">
<db:title>[protected] void QIODevice::setErrorString(const QString &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:para>Sets the human readable description of the last device error that occurred to <db:code role="parameter">str</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setOpenMode">
<db:title>[protected] void QIODevice::setOpenMode(QIODevice::OpenMode <db:emphasis>openMode</db:emphasis>)</db:title>
<db:para>Sets the <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link> of the device to <db:code role="parameter">openMode</db:code>. Call this function to set the open mode if the flags change after the device has been opened.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#openMode">openMode</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">OpenMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setTextModeEnabled">
<db:title>void QIODevice::setTextModeEnabled(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:para>If <db:code role="parameter">enabled</db:code> is true, this function sets the <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">Text</db:link> flag on the device; otherwise the <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">Text</db:link> flag is removed. This feature is useful for classes that provide custom end-of-line handling on a <db:link xlink:href="qiodevice.xml">QIODevice</db:link>.</db:para>
<db:para>The IO device should be opened before calling this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#isTextModeEnabled">isTextModeEnabled</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#open">open</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#setOpenMode">setOpenMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>[virtual] qint64 QIODevice::size() const</db:title>
<db:para>For open random-access devices, this function returns the size of the device. For open sequential devices, <db:link xlink:href="qiodevice.xml#bytesAvailable">bytesAvailable</db:link>() is returned.</db:para>
<db:para>If the device is closed, the size returned will not reflect the actual size of the device.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#isSequential">isSequential</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#pos">pos</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startTransaction">
<db:title>[since 5.7] void QIODevice::startTransaction()</db:title>
<db:para>Starts a new read transaction on the device.</db:para>
<db:para>Defines a restorable point within the sequence of read operations. For sequential devices, read data will be duplicated internally to allow recovery in case of incomplete reads. For random-access devices, this function saves the current position. Call <db:link xlink:href="qiodevice.xml#commitTransaction">commitTransaction</db:link>() or <db:link xlink:href="qiodevice.xml#rollbackTransaction">rollbackTransaction</db:link>() to finish the transaction.</db:para>
<db:note>
<db:para>Nesting transactions is not supported.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#commitTransaction">commitTransaction</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#rollbackTransaction">rollbackTransaction</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ungetChar">
<db:title>void QIODevice::ungetChar(char <db:emphasis>c</db:emphasis>)</db:title>
<db:para>Puts the character <db:code role="parameter">c</db:code> back into the device, and decrements the current position unless the position is 0. This function is usually called to &quot;undo&quot; a <db:link xlink:href="qiodevice.xml#getChar">getChar</db:link>() operation, such as when writing a backtracking parser.</db:para>
<db:para>If <db:code role="parameter">c</db:code> was not previously read from the device, the behavior is undefined.</db:para>
<db:note>
<db:para>This function is not available while a transaction is in progress.</db:para>
</db:note>
</db:section>
<db:section xml:id="waitForBytesWritten">
<db:title>[virtual] bool QIODevice::waitForBytesWritten(int <db:emphasis>msecs</db:emphasis>)</db:title>
<db:para>For buffered devices, this function waits until a payload of buffered written data has been written to the device and the <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>() signal has been emitted, or until <db:code role="parameter">msecs</db:code> milliseconds have passed. If msecs is -1, this function will not time out. For unbuffered devices, it returns immediately.</db:para>
<db:para>Returns <db:code>true</db:code> if a payload of data was written to the device; otherwise returns <db:code>false</db:code> (i.e. if the operation timed out, or if an error occurred).</db:para>
<db:para>This function can operate without an event loop. It is useful when writing non-GUI applications and when performing I/O operations in a non-GUI thread.</db:para>
<db:para>If called from within a slot connected to the <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>() signal, <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>() will not be reemitted.</db:para>
<db:para>Reimplement this function to provide a blocking API for a custom device. The default implementation does nothing, and returns <db:code>false</db:code>.</db:para>
<db:warning>
<db:para>Calling this function from the main (GUI) thread might cause your user interface to freeze.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#waitForReadyRead">waitForReadyRead</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForReadyRead">
<db:title>[virtual] bool QIODevice::waitForReadyRead(int <db:emphasis>msecs</db:emphasis>)</db:title>
<db:para>Blocks until new data is available for reading and the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal has been emitted, or until <db:code role="parameter">msecs</db:code> milliseconds have passed. If msecs is -1, this function will not time out.</db:para>
<db:para>Returns <db:code>true</db:code> if new data is available for reading; otherwise returns false (if the operation timed out or if an error occurred).</db:para>
<db:para>This function can operate without an event loop. It is useful when writing non-GUI applications and when performing I/O operations in a non-GUI thread.</db:para>
<db:para>If called from within a slot connected to the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal, <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() will not be reemitted.</db:para>
<db:para>Reimplement this function to provide a blocking API for a custom device. The default implementation does nothing, and returns <db:code>false</db:code>.</db:para>
<db:warning>
<db:para>Calling this function from the main (GUI) thread might cause your user interface to freeze.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#waitForBytesWritten">waitForBytesWritten</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="write">
<db:title>qint64 QIODevice::write(const char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>Writes at most <db:code role="parameter">maxSize</db:code> bytes of data from <db:code role="parameter">data</db:code> to the device. Returns the number of bytes that were actually written, or -1 if an error occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#writeData">writeData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="write-1">
<db:title>qint64 QIODevice::write(const QByteArray &amp;<db:emphasis>byteArray</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Writes the content of <db:code role="parameter">byteArray</db:code> to the device. Returns the number of bytes that were actually written, or -1 if an error occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#writeData">writeData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="write-2">
<db:title>[since 4.5] qint64 QIODevice::write(const char *<db:emphasis>data</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Writes data from a zero-terminated string of 8-bit characters to the device. Returns the number of bytes that were actually written, or -1 if an error occurred. This is equivalent to</db:para>
<db:programlisting language="cpp">...
QIODevice::write(data, qstrlen(data));
...
</db:programlisting>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#writeData">writeData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="writeChannelCount">
<db:title>[since 5.7] int QIODevice::writeChannelCount() const</db:title>
<db:para>Returns the number of available write channels if the device is open; otherwise returns 0.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#readChannelCount">readChannelCount</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="writeData">
<db:title>[pure virtual protected] qint64 QIODevice::writeData(const char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>Writes up to <db:code role="parameter">maxSize</db:code> bytes from <db:code role="parameter">data</db:code> to the device. Returns the number of bytes written, or -1 if an error occurred.</db:para>
<db:para>This function is called by <db:link xlink:href="qiodevice.xml">QIODevice</db:link>. Reimplement this function when creating a subclass of <db:link xlink:href="qiodevice.xml">QIODevice</db:link>.</db:para>
<db:para>When reimplementing this function it is important that this function writes all the data available before returning. This is required in order for <db:link xlink:href="qdatastream.xml">QDataStream</db:link> to be able to operate on the class. <db:link xlink:href="qdatastream.xml">QDataStream</db:link> assumes all the information was written and therefore does not retry writing if there was a problem.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#write">write</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
