<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QIODevice Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.4.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qiodevice.xml">QIODevice</db:link> class is the base interface class of all I/O devices in Qt.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QIODevice</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QIODevice is part of <db:simplelist><db:member><db:link xlink:href="io.xml">Input/Output and Networking</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qiodevice.xml">QIODevice</db:link> provides both a common implementation and an abstract interface for devices that support reading and writing of blocks of data, such as <db:link xlink:href="qfile.xml">QFile</db:link>, <db:link xlink:href="qbuffer.xml">QBuffer</db:link> and QTcpSocket. <db:link xlink:href="qiodevice.xml">QIODevice</db:link> is abstract and can not be instantiated, but it is common to use the interface it defines to provide device-independent I/O features. For example, Qt's XML classes operate on a <db:link xlink:href="qiodevice.xml">QIODevice</db:link> pointer, allowing them to be used with various devices (such as files and buffers).</db:para>
<db:para>Before accessing the device, open() must be called to set the correct OpenMode (such as ReadOnly or ReadWrite). You can then write to the device with write() or putChar(), and read by calling either read(), readLine(), or readAll(). Call close() when you are done with the device.</db:para>
<db:para><db:link xlink:href="qiodevice.xml">QIODevice</db:link> distinguishes between two types of devices: random-access devices and sequential devices.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Random-access devices support seeking to arbitrary positions using seek(). The current position in the file is available by calling pos(). <db:link xlink:href="qfile.xml">QFile</db:link> and <db:link xlink:href="qbuffer.xml">QBuffer</db:link> are examples of random-access devices.</db:para>
</db:listitem>
<db:listitem>
<db:para>Sequential devices don't support seeking to arbitrary positions. The data must be read in one pass. The functions pos() and size() don't work for sequential devices. QTcpSocket and QProcess are examples of sequential devices.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>You can use isSequential() to determine the type of device.</db:para>
<db:para><db:link xlink:href="qiodevice.xml">QIODevice</db:link> emits readyRead() when new data is available for reading; for example, if new data has arrived on the network or if additional data is appended to a file that you are reading from. You can call bytesAvailable() to determine the number of bytes that are currently available for reading. It's common to use bytesAvailable() together with the readyRead() signal when programming with asynchronous devices such as QTcpSocket, where fragments of data can arrive at arbitrary points in time. <db:link xlink:href="qiodevice.xml">QIODevice</db:link> emits the bytesWritten() signal every time a payload of data has been written to the device. Use bytesToWrite() to determine the current amount of data waiting to be written.</db:para>
<db:para>Certain subclasses of <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, such as QTcpSocket and QProcess, are asynchronous. This means that I/O functions such as write() or read() always return immediately, while communication with the device itself may happen when control goes back to the event loop. <db:link xlink:href="qiodevice.xml">QIODevice</db:link> provides functions that allow you to force these operations to be performed immediately, while blocking the calling thread and without entering the event loop. This allows <db:link xlink:href="qiodevice.xml">QIODevice</db:link> subclasses to be used without an event loop, or in a separate thread:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>waitForReadyRead() - This function suspends operation in the calling thread until new data is available for reading.</db:para>
</db:listitem>
<db:listitem>
<db:para>waitForBytesWritten() - This function suspends operation in the calling thread until one payload of data has been written to the device.</db:para>
</db:listitem>
<db:listitem>
<db:para>waitFor....() - Subclasses of <db:link xlink:href="qiodevice.xml">QIODevice</db:link> implement blocking functions for device-specific operations. For example, QProcess has a function called <db:link xlink:href="">waitForStarted()</db:link> which suspends operation in the calling thread until the process has started.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Calling these functions from the main, GUI thread, may cause your user interface to freeze. Example:</db:para>
<db:programlisting language="cpp">QProcess gzip;
gzip.start(&quot;gzip&quot;, QStringList() &lt;&lt; &quot;-c&quot;);
if (!gzip.waitForStarted())
    return false;

gzip.write(&quot;uncompressed data&quot;);

QByteArray compressed;
while (gzip.waitForReadyRead())
    compressed += gzip.readAll();
</db:programlisting>
<db:para>By subclassing <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, you can provide the same interface to your own I/O devices. Subclasses of <db:link xlink:href="qiodevice.xml">QIODevice</db:link> are only required to implement the protected <db:link xlink:href="qiodevice.xml#readData">readData</db:link>() and <db:link xlink:href="qiodevice.xml#writeData">writeData</db:link>() functions. <db:link xlink:href="qiodevice.xml">QIODevice</db:link> uses these functions to implement all its convenience functions, such as getChar(), readLine() and write(). <db:link xlink:href="qiodevice.xml">QIODevice</db:link> also handles access control for you, so you can safely assume that the device is opened in write mode if <db:link xlink:href="qiodevice.xml#writeData">writeData</db:link>() is called.</db:para>
<db:para>Some subclasses, such as <db:link xlink:href="qfile.xml">QFile</db:link> and QTcpSocket, are implemented using a memory buffer for intermediate storing of data. This reduces the number of required device accessing calls, which are often very slow. Buffering makes functions like getChar() and putChar() fast, as they can operate on the memory buffer instead of directly on the device itself. Certain I/O operations, however, don't work well with a buffer. For example, if several users open the same device and read it character by character, they may end up reading the same data when they meant to read a separate chunk each. For this reason, <db:link xlink:href="qiodevice.xml">QIODevice</db:link> allows you to bypass any buffering by passing the Unbuffered flag to open(). When subclassing <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, remember to bypass any buffer you may use when the device is open in Unbuffered mode.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbuffer.xml">QBuffer</db:link></db:member>
<db:member><db:link xlink:href="qfile.xml">QFile</db:link></db:member>
<db:member>QTcpSocket</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="readData">
<db:title>[pure virtual protected] qint64 QIODevice::readData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>Reads up to <db:code role="parameter">maxSize</db:code> bytes from the device into <db:code role="parameter">data</db:code>, and returns the number of bytes read or -1 if an error occurred.</db:para>
<db:para>If there are no bytes to be read and there can never be more bytes available (examples include socket closed, pipe closed, sub-process finished), this function returns -1.</db:para>
<db:para>This function is called by <db:link xlink:href="qiodevice.xml">QIODevice</db:link>. Reimplement this function when creating a subclass of <db:link xlink:href="qiodevice.xml">QIODevice</db:link>.</db:para>
<db:para>When reimplementing this function it is important that this function reads all the required data before returning. This is required in order for <db:link xlink:href="qdatastream.xml">QDataStream</db:link> to be able to operate on the class. <db:link xlink:href="qdatastream.xml">QDataStream</db:link> assumes all the requested information was read and therefore does not retry reading if there was a problem.</db:para>
<db:para>This function might be called with a maxSize of 0, which can be used to perform post-reading operations.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>read()</db:member>
<db:member>readLine()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#writeData">writeData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readLineData">
<db:title>[virtual protected] qint64 QIODevice::readLineData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>Reads up to <db:code role="parameter">maxSize</db:code> characters into <db:code role="parameter">data</db:code> and returns the number of characters read.</db:para>
<db:para>This function is called by readLine(), and provides its base implementation, using getChar(). Buffered devices can improve the performance of readLine() by reimplementing this function.</db:para>
<db:para>readLine() appends a '\0' byte to <db:code role="parameter">data</db:code>; readLineData() does not need to do this.</db:para>
<db:para>If you reimplement this function, be careful to return the correct value: it should return the number of bytes read in this line, including the terminating newline, or 0 if there is no line to be read at this point. If an error occurs, it should return -1 if and only if no bytes were read. Reading past EOF is considered an error.</db:para>
</db:section>
<db:section xml:id="setErrorString">
<db:title>[protected] void QIODevice::setErrorString(const QString &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:para>Sets the human readable description of the last device error that occurred to <db:code role="parameter">str</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>errorString()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setOpenMode">
<db:title>[protected] void QIODevice::setOpenMode(QIODevice::OpenMode <db:emphasis>openMode</db:emphasis>)</db:title>
<db:para>Sets the OpenMode of the device to <db:code role="parameter">openMode</db:code>. Call this function to set the open mode if the flags change after the device has been opened.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>openMode()</db:member>
<db:member>OpenMode</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="writeData">
<db:title>[pure virtual protected] qint64 QIODevice::writeData(const char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>Writes up to <db:code role="parameter">maxSize</db:code> bytes from <db:code role="parameter">data</db:code> to the device. Returns the number of bytes written, or -1 if an error occurred.</db:para>
<db:para>This function is called by <db:link xlink:href="qiodevice.xml">QIODevice</db:link>. Reimplement this function when creating a subclass of <db:link xlink:href="qiodevice.xml">QIODevice</db:link>.</db:para>
<db:para>When reimplementing this function it is important that this function writes all the data available before returning. This is required in order for <db:link xlink:href="qdatastream.xml">QDataStream</db:link> to be able to operate on the class. <db:link xlink:href="qdatastream.xml">QDataStream</db:link> assumes all the information was written and therefore does not retry writing if there was a problem.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>read()</db:member>
<db:member>write()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
