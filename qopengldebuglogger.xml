<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QOpenGLDebugLogger Class</db:title>
<db:productname>QtOpenGL</db:productname>
<db:edition>Qt 6.3.2 Reference Documentation</db:edition>
<db:titleabbrev>QtOpenGL Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qopengldebuglogger.xml">QOpenGLDebugLogger</db:link> enables logging of OpenGL debugging messages.</db:para>
<db:para>This class was introduced in Qt 5.1.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QOpenGLDebugLogger</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.1</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS OpenGL)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::OpenGL)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += opengl</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QOpenGLDebugLogger is part of <db:simplelist><db:member>painting-3D</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:section xml:id="introduction">
<db:title>Introduction</db:title>
<db:para>OpenGL programming can be very error prone. Most of the time, a single failing call to OpenGL can cause an entire portion of an application to stop working, with nothing being drawn on the screen.</db:para>
<db:para>The only way to be sure that no errors are being returned from the OpenGL implementation is checking with <db:code>glGetError</db:code> after each and every API call. Moreover, OpenGL errors stack up, therefore glGetError should always be used in a loop like this:</db:para>
<db:programlisting language="cpp">GLenum error = GL_NO_ERROR;
do {
    error = glGetError();
    if (error != GL_NO_ERROR) {
        // handle the error
    }
} while (error != GL_NO_ERROR);
</db:programlisting>
<db:para>If you try to clear the error stack, make sure not just keep going until GL_NO_ERROR is returned but also break on GL_CONTEXT_LOST as that error value will keep repeating.</db:para>
<db:para>There are also many other information we are interested in (as application developers), for instance performance issues, or warnings about using deprecated APIs. Those kind of messages are not reported through the ordinary OpenGL error reporting mechanisms.</db:para>
<db:para><db:link xlink:href="qopengldebuglogger.xml">QOpenGLDebugLogger</db:link> aims at addressing these issues by providing access to the <db:emphasis>OpenGL debug log</db:emphasis>. If your OpenGL implementation supports it (by exposing the <db:code>GL_KHR_debug</db:code> extension), messages from the OpenGL server will be either logged in an internal OpenGL log, or passed in &quot;real-time&quot; to listeners as they're generated from OpenGL.</db:para>
<db:para><db:link xlink:href="qopengldebuglogger.xml">QOpenGLDebugLogger</db:link> supports both these modes of operation. Refer to the following sections to find out the differences between them.</db:para>
</db:section>
<db:section xml:id="creating-an-opengl-debug-context">
<db:title>Creating an OpenGL Debug Context</db:title>
<db:para>For efficiency reasons, OpenGL implementations are allowed not to create any debug output at all, unless the OpenGL context is a debug context. In order to create a debug context from Qt, you must set the <db:link xlink:href="qsurfaceformat.xml#FormatOption-enum">QSurfaceFormat::DebugContext</db:link> format option on the <db:link xlink:href="qsurfaceformat.xml">QSurfaceFormat</db:link> used to create the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> object:</db:para>
<db:programlisting language="cpp">QSurfaceFormat format;
// asks for a OpenGL 3.2 debug context using the Core profile
format.setMajorVersion(3);
format.setMinorVersion(2);
format.setProfile(QSurfaceFormat::CoreProfile);
format.setOption(QSurfaceFormat::DebugContext);

QOpenGLContext *context = new QOpenGLContext;
context-&amp;gt;setFormat(format);
context-&amp;gt;create();
</db:programlisting>
<db:para>Note that requesting a 3.2 OpenGL Core Profile is just for the example's purposes; this class is not tied to any specific OpenGL or OpenGL ES version, as it relies on the availability of the <db:code>GL_KHR_debug</db:code> extension (see below).</db:para>
</db:section>
<db:section xml:id="creating-and-initializing-a-qopengldebuglogger">
<db:title>Creating and Initializing a QOpenGLDebugLogger</db:title>
<db:para><db:link xlink:href="qopengldebuglogger.xml">QOpenGLDebugLogger</db:link> is a simple <db:link xlink:href="qobject.xml">QObject</db:link>-derived class. Just like all <db:link xlink:href="qobject.xml">QObject</db:link> subclasses, you create an instance (and optionally specify a parent object), and like the other OpenGL functions in Qt you <db:emphasis>must</db:emphasis> initialize it before usage by calling <db:link xlink:href="qopengldebuglogger.xml#initialize">initialize</db:link>() whilst there is a current OpenGL context:</db:para>
<db:programlisting language="cpp">QOpenGLContext *ctx = QOpenGLContext::currentContext();
QOpenGLDebugLogger *logger = new QOpenGLDebugLogger(this);

logger-&amp;gt;initialize(); // initializes in the current context, i.e. ctx
</db:programlisting>
<db:para>Note that the <db:code>GL_KHR_debug</db:code> extension <db:emphasis>must</db:emphasis> be available in the context in order to access the messages logged by OpenGL. You can check the presence of this extension by calling:</db:para>
<db:programlisting language="cpp">ctx-&amp;gt;hasExtension(QByteArrayLiteral(&quot;GL_KHR_debug&quot;));
</db:programlisting>
<db:para>where <db:code>ctx</db:code> is a valid <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link>. If the extension is not available, <db:link xlink:href="qopengldebuglogger.xml#initialize">initialize</db:link>() will return false.</db:para>
</db:section>
<db:section xml:id="reading-the-internal-opengl-debug-log">
<db:title>Reading the Internal OpenGL Debug Log</db:title>
<db:para>OpenGL implementations keep an internal log of debug messages. Messages stored in this log can be retrieved by using the <db:link xlink:href="qopengldebuglogger.xml#loggedMessages">loggedMessages</db:link>() function:</db:para>
<db:programlisting language="cpp">const QList&amp;lt;QOpenGLDebugMessage&amp;gt; messages = logger-&amp;gt;loggedMessages();
for (const QOpenGLDebugMessage &amp;amp;message : messages)
    qDebug() &amp;lt;&amp;lt; message;
</db:programlisting>
<db:para>The internal log has a limited size; when it fills up, older messages will get discarded to make room for the new incoming messages. When you call <db:link xlink:href="qopengldebuglogger.xml#loggedMessages">loggedMessages</db:link>(), the internal log will be emptied as well.</db:para>
<db:para>If you want to be sure not to lose any debug message, you must use real-time logging instead of calling this function. However, debug messages might still be generated in the timespan between context creation and activation of real-time logging (or, in general, when the real-time logging is disabled).</db:para>
</db:section>
<db:section xml:id="real-time-logging-of-messages">
<db:title>Real-time logging of messages</db:title>
<db:para>It is also possible to receive a stream of debug messages from the OpenGL server <db:emphasis>as they are generated</db:emphasis> by the implementation. In order to do so, you need to connect a suitable slot to the <db:link xlink:href="qopengldebuglogger.xml#messageLogged">messageLogged</db:link>() signal, and start logging by calling <db:link xlink:href="qopengldebuglogger.xml#startLogging">startLogging</db:link>():</db:para>
<db:programlisting language="cpp">connect(logger, &amp;amp;QOpenGLDebugLogger::messageLogged, receiver, &amp;amp;LogHandler::handleLoggedMessage);
logger-&amp;gt;startLogging();
</db:programlisting>
<db:para>Similarly, logging can be disabled at any time by calling the <db:link xlink:href="qopengldebuglogger.xml#stopLogging">stopLogging</db:link>() function.</db:para>
<db:para>Real-time logging can be either asynchronous or synchronous, depending on the parameter passed to <db:link xlink:href="qopengldebuglogger.xml#startLogging">startLogging</db:link>(). When logging in asynchronous mode (the default, as it has a very small overhead), the OpenGL implementation can generate messages at any time, and/or in an order which is different from the order of the OpenGL commands which caused those messages to be logged. The messages could also be generated from a thread that it's different from the thread the context is currently bound to. This is because OpenGL implementations are usually highly threaded and asynchronous, and therefore no warranties are made about the relative order and the timings of the debug messages.</db:para>
<db:para>On the other hand, logging in synchronous mode has a high overhead, but the OpenGL implementation guarantees that all the messages caused by a certain command are received in order, before the command returns, and from the same thread the OpenGL context is bound to.</db:para>
<db:para>This means that when logging in synchronous mode you will be able to run your OpenGL application in a debugger, put a breakpoint on a slot connected to the <db:link xlink:href="qopengldebuglogger.xml#messageLogged">messageLogged</db:link>() signal, and see in the backtrace the exact call that caused the logged message. This can be extremely useful to debug an OpenGL problem. Note that if OpenGL rendering is happening in another thread, you must force the signal/slot connection type to <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::DirectConnection</db:link> in order to be able to see the actual backtrace.</db:para>
<db:para>Refer to the <db:link xlink:href="qopengldebuglogger.xml#LoggingMode-enum">LoggingMode</db:link> enum documentation for more information about logging modes.</db:para>
<db:note>
<db:para>When real-time logging is enabled, debug messages will <db:emphasis>not</db:emphasis> be inserted in the internal OpenGL debug log any more; messages already present in the internal log will not be deleted, nor they will be emitted through the <db:link xlink:href="qopengldebuglogger.xml#messageLogged">messageLogged</db:link>() signal. Since some messages might be generated before real-time logging is started (and therefore be kept in the internal OpenGL log), it is important to always check if it contains any message after calling <db:link xlink:href="qopengldebuglogger.xml#startLogging">startLogging</db:link>().</db:para>
</db:note>
</db:section>
<db:section xml:id="inserting-messages-in-the-debug-log">
<db:title>Inserting Messages in the Debug Log</db:title>
<db:para>It is possible for applications and libraries to insert custom messages in the debug log, for instance for marking a group of related OpenGL commands and therefore being then able to identify eventual messages coming from them.</db:para>
<db:para>In order to do so, you can create a <db:link xlink:href="qopengldebugmessage.xml">QOpenGLDebugMessage</db:link> object by calling <db:link xlink:href="qopengldebugmessage.xml#createApplicationMessage">createApplicationMessage</db:link>() or <db:link xlink:href="qopengldebugmessage.xml#createThirdPartyMessage">createThirdPartyMessage</db:link>(), and then inserting it into the log by calling <db:link xlink:href="qopengldebuglogger.xml#logMessage">logMessage</db:link>():</db:para>
<db:programlisting language="cpp">QOpenGLDebugMessage message =
    QOpenGLDebugMessage::createApplicationMessage(QStringLiteral(&quot;Custom message&quot;));

logger-&amp;gt;logMessage(message);
</db:programlisting>
<db:para>Note that OpenGL implementations have a vendor-specific limit to the length of the messages that can be inserted in the debug log. You can retrieve this length by calling the <db:link xlink:href="qopengldebuglogger.xml#maximumMessageLength">maximumMessageLength</db:link>() method; messages longer than the limit will automatically get truncated.</db:para>
</db:section>
<db:section xml:id="controlling-the-debug-output">
<db:title>Controlling the Debug Output</db:title>
<db:para><db:link xlink:href="qopengldebugmessage.xml">QOpenGLDebugMessage</db:link> is also able to apply filters to the debug messages, and therefore limit the amount of messages logged. You can enable or disable logging of messages by calling <db:link xlink:href="qopengldebuglogger.xml#enableMessages">enableMessages</db:link>() and <db:link xlink:href="qopengldebuglogger.xml#disableMessages">disableMessages</db:link>() respectively. By default, all messages are logged.</db:para>
<db:para>It is possible to enable or disable messages by selecting them by:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>source, type and severity (and including all ids in the selection);</db:para>
</db:listitem>
<db:listitem>
<db:para>id, source and type (and including all severities in the selection).</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Note that the &quot;enabled&quot; status for a given message is a property of the (id, source, type, severity) tuple; the message attributes <db:emphasis>do not</db:emphasis> form a hierarchy of any kind. You should be careful about the order of the calls to <db:link xlink:href="qopengldebuglogger.xml#enableMessages">enableMessages</db:link>() and <db:link xlink:href="qopengldebuglogger.xml#disableMessages">disableMessages</db:link>(), as it will change which messages will are enabled / disabled.</db:para>
<db:para>It's not possible to filter by the message text itself; applications have to do that on their own (in slots connected to the <db:link xlink:href="qopengldebuglogger.xml#messageLogged">messageLogged</db:link>() signal, or after fetching the messages in the internal debug log through <db:link xlink:href="qopengldebuglogger.xml#loggedMessages">loggedMessages</db:link>()).</db:para>
<db:para>In order to simplify the management of the enabled / disabled statuses, <db:link xlink:href="qopengldebugmessage.xml">QOpenGLDebugMessage</db:link> also supports the concept of <db:code>debug groups</db:code>. A debug group contains the group of enabled / disabled configurations of debug messages. Moreover, debug groups are organized in a stack: it is possible to push and pop groups by calling <db:link xlink:href="qopengldebuglogger.xml#pushGroup">pushGroup</db:link>() and <db:link xlink:href="qopengldebuglogger.xml#popGroup">popGroup</db:link>() respectively. (When an OpenGL context is created, there is already a group in the stack).</db:para>
<db:para>The <db:link xlink:href="qopengldebuglogger.xml#enableMessages">enableMessages</db:link>() and <db:link xlink:href="qopengldebuglogger.xml#disableMessages">disableMessages</db:link>() functions will modify the configuration in the current debug group, that is, the one at the top of the debug groups stack.</db:para>
<db:para>When a new group is pushed onto the debug groups stack, it will inherit the configuration of the group that was previously on the top of the stack. Vice versa, popping a debug group will restore the configuration of the debug group that becomes the new top.</db:para>
<db:para>Pushing (respectively popping) debug groups will also automatically generate a debug message of type <db:link xlink:href="qopengldebugmessage.xml#Type-enum">QOpenGLDebugMessage::GroupPushType</db:link> (respectively <db:link xlink:href="qopengldebugmessage.xml#Type-enum">GroupPopType</db:link>).</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebugmessage.xml">QOpenGLDebugMessage</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="LoggingMode-enum">
<db:title>enum QOpenGLDebugLogger::LoggingMode</db:title>
<db:enumsynopsis>
<db:enumname>LoggingMode</db:enumname>
<db:enumitem>
<db:enumidentifier>AsynchronousLogging</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SynchronousLogging</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>The LoggingMode enum defines the logging mode of the logger object.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qopengldebuglogger.xml">QOpenGLDebugLogger</db:link></db:emphasis>::AsynchronousLogging</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Messages from the OpenGL server are logged asynchronously. This means that messages can be logged some time after the corresponding OpenGL actions that caused them, and even be received in an out-of-order fashion, depending on the OpenGL implementation. This mode has a very low performance penalty, as OpenGL implementations are heavily threaded and asynchronous by nature.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qopengldebuglogger.xml">QOpenGLDebugLogger</db:link></db:emphasis>::SynchronousLogging</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Messages from the OpenGL server are logged synchronously and sequentially. This has a severe performance hit, as OpenGL implementations are very asynchronous by nature; but it's very useful to debug OpenGL problems, as OpenGL guarantees that the messages generated by a OpenGL command will be logged before the corresponding command execution has returned. Therefore, you can install a breakpoint on the <db:link xlink:href="qopengldebuglogger.xml#messageLogged">messageLogged</db:link>() signal and see in the backtrace which OpenGL command caused it; the only caveat is that if you are using OpenGL from multiple threads you may need to force direct connection when connecting to the <db:link xlink:href="qopengldebuglogger.xml#messageLogged">messageLogged</db:link>() signal.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="loggingMode-prop">
<db:title>[read-only] loggingMode : const LoggingMode</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>LoggingMode</db:type>
<db:varname>loggingMode</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">loggingMode</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the logging mode passed to <db:link xlink:href="qopengldebuglogger.xml#startLogging">startLogging</db:link>().</db:para>
<db:para>Note that logging must have been started or the value of this property will be meaningless.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qopengldebuglogger.xml#LoggingMode-enum">QOpenGLDebugLogger::LoggingMode</db:link></db:type> <db:emphasis role="bold"><db:link xlink:href="qopengldebuglogger.xml#loggingMode">loggingMode</db:link></db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#startLogging">startLogging</db:link>()</db:member>
<db:member><db:link xlink:href="qopengldebuglogger.xml#isLogging">isLogging</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QOpenGLDebugLogger">
<db:title>[explicit] QOpenGLDebugLogger::QOpenGLDebugLogger(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QOpenGLDebugLogger</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLDebugLogger(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new logger object with the given <db:code role="parameter">parent</db:code>.</db:para>
<db:note>
<db:para>The object must be initialized before logging can happen.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#initialize">initialize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QOpenGLDebugLogger">
<db:title>[virtual] QOpenGLDebugLogger::~QOpenGLDebugLogger()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QOpenGLDebugLogger</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QOpenGLDebugLogger()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the logger object.</db:para>
</db:section>
<db:section xml:id="disableMessages">
<db:title>void QOpenGLDebugLogger::disableMessages(QOpenGLDebugMessage::Sources <db:emphasis>sources</db:emphasis> = QOpenGLDebugMessage::AnySource, QOpenGLDebugMessage::Types <db:emphasis>types</db:emphasis> = QOpenGLDebugMessage::AnyType, QOpenGLDebugMessage::Severities <db:emphasis>severities</db:emphasis> = QOpenGLDebugMessage::AnySeverity)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>disableMessages</db:methodname>
<db:methodparam>
<db:type>QOpenGLDebugMessage::Sources</db:type>
<db:parameter>sources</db:parameter>
<db:initializer>QOpenGLDebugMessage::AnySource</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QOpenGLDebugMessage::Types</db:type>
<db:parameter>types</db:parameter>
<db:initializer>QOpenGLDebugMessage::AnyType</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QOpenGLDebugMessage::Severities</db:type>
<db:parameter>severities</db:parameter>
<db:initializer>QOpenGLDebugMessage::AnySeverity</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void disableMessages(QOpenGLDebugMessage::Sources sources, QOpenGLDebugMessage::Types types, QOpenGLDebugMessage::Severities severities)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Disables the logging of messages with the given <db:code role="parameter">sources</db:code>, of the given <db:code role="parameter">types</db:code> and with the given <db:code role="parameter">severities</db:code> and any message id.</db:para>
<db:para>The logging will be disabled in the current control group.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#enableMessages">enableMessages</db:link>()</db:member>
<db:member><db:link xlink:href="qopengldebuglogger.xml#pushGroup">pushGroup</db:link>()</db:member>
<db:member><db:link xlink:href="qopengldebuglogger.xml#popGroup">popGroup</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="disableMessages-1">
<db:title>void QOpenGLDebugLogger::disableMessages(const QList&lt;GLuint&gt; &amp;<db:emphasis>ids</db:emphasis>, QOpenGLDebugMessage::Sources <db:emphasis>sources</db:emphasis> = QOpenGLDebugMessage::AnySource, QOpenGLDebugMessage::Types <db:emphasis>types</db:emphasis> = QOpenGLDebugMessage::AnyType)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>disableMessages</db:methodname>
<db:methodparam>
<db:type>const QList&lt;GLuint&gt; &amp;</db:type>
<db:parameter>ids</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QOpenGLDebugMessage::Sources</db:type>
<db:parameter>sources</db:parameter>
<db:initializer>QOpenGLDebugMessage::AnySource</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QOpenGLDebugMessage::Types</db:type>
<db:parameter>types</db:parameter>
<db:initializer>QOpenGLDebugMessage::AnyType</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void disableMessages(const QList&lt;GLuint&gt; &amp;ids, QOpenGLDebugMessage::Sources sources, QOpenGLDebugMessage::Types types)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Disables the logging of messages with the given <db:code role="parameter">ids</db:code>, from the given <db:code role="parameter">sources</db:code> and of the given <db:code role="parameter">types</db:code> and any severity.</db:para>
<db:para>The logging will be disabled in the current control group.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#enableMessages">enableMessages</db:link>()</db:member>
<db:member><db:link xlink:href="qopengldebuglogger.xml#pushGroup">pushGroup</db:link>()</db:member>
<db:member><db:link xlink:href="qopengldebuglogger.xml#popGroup">popGroup</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="enableMessages">
<db:title>void QOpenGLDebugLogger::enableMessages(QOpenGLDebugMessage::Sources <db:emphasis>sources</db:emphasis> = QOpenGLDebugMessage::AnySource, QOpenGLDebugMessage::Types <db:emphasis>types</db:emphasis> = QOpenGLDebugMessage::AnyType, QOpenGLDebugMessage::Severities <db:emphasis>severities</db:emphasis> = QOpenGLDebugMessage::AnySeverity)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>enableMessages</db:methodname>
<db:methodparam>
<db:type>QOpenGLDebugMessage::Sources</db:type>
<db:parameter>sources</db:parameter>
<db:initializer>QOpenGLDebugMessage::AnySource</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QOpenGLDebugMessage::Types</db:type>
<db:parameter>types</db:parameter>
<db:initializer>QOpenGLDebugMessage::AnyType</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QOpenGLDebugMessage::Severities</db:type>
<db:parameter>severities</db:parameter>
<db:initializer>QOpenGLDebugMessage::AnySeverity</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void enableMessages(QOpenGLDebugMessage::Sources sources, QOpenGLDebugMessage::Types types, QOpenGLDebugMessage::Severities severities)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Enables the logging of messages from the given <db:code role="parameter">sources</db:code>, of the given <db:code role="parameter">types</db:code> and with the given <db:code role="parameter">severities</db:code> and any message id.</db:para>
<db:para>The logging will be enabled in the current control group.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#disableMessages">disableMessages</db:link>()</db:member>
<db:member><db:link xlink:href="qopengldebuglogger.xml#pushGroup">pushGroup</db:link>()</db:member>
<db:member><db:link xlink:href="qopengldebuglogger.xml#popGroup">popGroup</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="enableMessages-1">
<db:title>void QOpenGLDebugLogger::enableMessages(const QList&lt;GLuint&gt; &amp;<db:emphasis>ids</db:emphasis>, QOpenGLDebugMessage::Sources <db:emphasis>sources</db:emphasis> = QOpenGLDebugMessage::AnySource, QOpenGLDebugMessage::Types <db:emphasis>types</db:emphasis> = QOpenGLDebugMessage::AnyType)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>enableMessages</db:methodname>
<db:methodparam>
<db:type>const QList&lt;GLuint&gt; &amp;</db:type>
<db:parameter>ids</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QOpenGLDebugMessage::Sources</db:type>
<db:parameter>sources</db:parameter>
<db:initializer>QOpenGLDebugMessage::AnySource</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QOpenGLDebugMessage::Types</db:type>
<db:parameter>types</db:parameter>
<db:initializer>QOpenGLDebugMessage::AnyType</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void enableMessages(const QList&lt;GLuint&gt; &amp;ids, QOpenGLDebugMessage::Sources sources, QOpenGLDebugMessage::Types types)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Enables the logging of messages with the given <db:code role="parameter">ids</db:code>, from the given <db:code role="parameter">sources</db:code> and of the given <db:code role="parameter">types</db:code> and any severity.</db:para>
<db:para>The logging will be enabled in the current control group.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#disableMessages">disableMessages</db:link>()</db:member>
<db:member><db:link xlink:href="qopengldebuglogger.xml#pushGroup">pushGroup</db:link>()</db:member>
<db:member><db:link xlink:href="qopengldebuglogger.xml#popGroup">popGroup</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="initialize">
<db:title>bool QOpenGLDebugLogger::initialize()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>initialize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool initialize()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Initializes the object in the current OpenGL context. The context must support the <db:code>GL_KHR_debug</db:code> extension for the initialization to succeed. The object must be initialized before any logging can happen.</db:para>
<db:para>It is safe to call this function multiple times from the same context.</db:para>
<db:para>This function can also be used to change the context of a previously initialized object; note that in this case the object must not be logging when you call this function.</db:para>
<db:para>Returns <db:code>true</db:code> if the logger is successfully initialized; false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isLogging">
<db:title>bool QOpenGLDebugLogger::isLogging() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isLogging</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isLogging() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this object is currently logging, false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#startLogging">startLogging</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="logMessage">
<db:title>void QOpenGLDebugLogger::logMessage(const QOpenGLDebugMessage &amp;<db:emphasis>debugMessage</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>logMessage</db:methodname>
<db:methodparam>
<db:type>const QOpenGLDebugMessage &amp;</db:type>
<db:parameter>debugMessage</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void logMessage(const QOpenGLDebugMessage &amp;debugMessage)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts the message <db:code role="parameter">debugMessage</db:code> into the OpenGL debug log. This provides a way for applications or libraries to insert custom messages that can ease the debugging of OpenGL applications.</db:para>
<db:note>
<db:para><db:code role="parameter">debugMessage</db:code> must have <db:link xlink:href="qopengldebugmessage.xml#Source-enum">QOpenGLDebugMessage::ApplicationSource</db:link> or <db:link xlink:href="qopengldebugmessage.xml#Source-enum">QOpenGLDebugMessage::ThirdPartySource</db:link> as its source, and a valid type and severity, otherwise it will not be inserted into the log.</db:para>
</db:note>
<db:note>
<db:para>The object must be initialized before logging can happen.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#initialize">initialize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="loggedMessages">
<db:title>QList&lt;QOpenGLDebugMessage&gt; QOpenGLDebugLogger::loggedMessages() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QOpenGLDebugMessage&gt;</db:type>
<db:methodname>loggedMessages</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QOpenGLDebugMessage&gt; loggedMessages() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads all the available messages in the OpenGL internal debug log and returns them. Moreover, this function will clear the internal debug log, so that subsequent invocations will not return messages that were already returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#startLogging">startLogging</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="loggingMode">
<db:title>QOpenGLDebugLogger::LoggingMode QOpenGLDebugLogger::loggingMode() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QOpenGLDebugLogger::LoggingMode</db:type>
<db:methodname>loggingMode</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">loggingMode</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLDebugLogger::LoggingMode loggingMode() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the logging mode of the object.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qopengldebuglogger.xml#loggingMode-prop">loggingMode</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#startLogging">startLogging</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="maximumMessageLength">
<db:title>qint64 QOpenGLDebugLogger::maximumMessageLength() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>maximumMessageLength</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 maximumMessageLength() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum supported length, in bytes, for the text of the messages passed to <db:link xlink:href="qopengldebuglogger.xml#logMessage">logMessage</db:link>(). This is also the maximum length of a debug group name, as pushing or popping groups will automatically log a message with the debug group name as the message text.</db:para>
<db:para>If a message text is too long, it will be automatically truncated by <db:link xlink:href="qopengldebuglogger.xml">QOpenGLDebugLogger</db:link>.</db:para>
<db:note>
<db:para>Message texts are encoded in UTF-8 when they get passed to OpenGL, so their size in bytes does not usually match the amount of UTF-16 code units, as returned, for instance, by <db:link xlink:href="qstring.xml#length">QString::length</db:link>(). (It does if the message contains 7-bit ASCII only data, which is typical for debug messages.)</db:para>
</db:note>
</db:section>
<db:section xml:id="messageLogged">
<db:title>void QOpenGLDebugLogger::messageLogged(const QOpenGLDebugMessage &amp;<db:emphasis>debugMessage</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>messageLogged</db:methodname>
<db:methodparam>
<db:type>const QOpenGLDebugMessage &amp;</db:type>
<db:parameter>debugMessage</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void messageLogged(const QOpenGLDebugMessage &amp;debugMessage)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when a debug message (wrapped by the <db:code role="parameter">debugMessage</db:code> argument) is logged from the OpenGL server.</db:para>
<db:para>Depending on the OpenGL implementation, this signal can be emitted from other threads than the one(s) the receiver(s) lives in, and even different from the thread the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> in which this object has been initialized lives in. Moreover, the signal could be emitted from multiple threads at the same time. This is normally not a problem, as Qt will utilize a queued connection for cross-thread signal emissions, but if you force the connection type to Direct then you must be aware of the potential races in the slots connected to this signal.</db:para>
<db:para>If logging have been started in <db:link xlink:href="qopengldebuglogger.xml#LoggingMode-enum">SynchronousLogging</db:link> mode, OpenGL guarantees that this signal will be emitted from the same thread the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> has been bound to, and no concurrent invocations will ever happen.</db:para>
<db:note>
<db:para>Logging must have been started, or this signal will not be emitted.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#startLogging">startLogging</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="popGroup">
<db:title>void QOpenGLDebugLogger::popGroup()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>popGroup</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void popGroup()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Pops the topmost debug group from the debug groups stack. If the group is successfully popped, OpenGL will automatically log a message with message, id and source matching those of the popped group, type <db:link xlink:href="qopengldebugmessage.xml#Type-enum">QOpenGLDebugMessage::GroupPopType</db:link> and severity <db:link xlink:href="qopengldebugmessage.xml#Severity-enum">QOpenGLDebugMessage::NotificationSeverity</db:link>.</db:para>
<db:para>Popping a debug group will restore the message filtering settings of the group that becomes the top of the debug groups stack.</db:para>
<db:note>
<db:para>The object must be initialized before managing debug groups.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#pushGroup">pushGroup</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pushGroup">
<db:title>void QOpenGLDebugLogger::pushGroup(const QString &amp;<db:emphasis>name</db:emphasis>, GLuint <db:emphasis>id</db:emphasis> = 0, QOpenGLDebugMessage::Source <db:emphasis>source</db:emphasis> = QOpenGLDebugMessage::ApplicationSource)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pushGroup</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>GLuint</db:type>
<db:parameter>id</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QOpenGLDebugMessage::Source</db:type>
<db:parameter>source</db:parameter>
<db:initializer>QOpenGLDebugMessage::ApplicationSource</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pushGroup(const QString &amp;name, GLuint id, QOpenGLDebugMessage::Source source)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Pushes a debug group with name <db:code role="parameter">name</db:code>, id <db:code role="parameter">id</db:code>, and source <db:code role="parameter">source</db:code> onto the debug groups stack. If the group is successfully pushed, OpenGL will automatically log a message with message <db:code role="parameter">name</db:code>, id <db:code role="parameter">id</db:code>, source <db:code role="parameter">source</db:code>, type <db:link xlink:href="qopengldebugmessage.xml#Type-enum">QOpenGLDebugMessage::GroupPushType</db:link> and severity <db:link xlink:href="qopengldebugmessage.xml#Severity-enum">QOpenGLDebugMessage::NotificationSeverity</db:link>.</db:para>
<db:para>The newly pushed group will inherit the same filtering settings of the group that was on the top of the stack; that is, the filtering will not be changed by pushing a new group.</db:para>
<db:note>
<db:para>The <db:code role="parameter">source</db:code> must either be <db:link xlink:href="qopengldebugmessage.xml#Source-enum">QOpenGLDebugMessage::ApplicationSource</db:link> or <db:link xlink:href="qopengldebugmessage.xml#Source-enum">QOpenGLDebugMessage::ThirdPartySource</db:link>, otherwise the group will not be pushed.</db:para>
</db:note>
<db:note>
<db:para>The object must be initialized before managing debug groups.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#popGroup">popGroup</db:link>()</db:member>
<db:member><db:link xlink:href="qopengldebuglogger.xml#enableMessages">enableMessages</db:link>()</db:member>
<db:member><db:link xlink:href="qopengldebuglogger.xml#disableMessages">disableMessages</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startLogging">
<db:title>void QOpenGLDebugLogger::startLogging(QOpenGLDebugLogger::LoggingMode <db:emphasis>loggingMode</db:emphasis> = AsynchronousLogging)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>startLogging</db:methodname>
<db:methodparam>
<db:type>QOpenGLDebugLogger::LoggingMode</db:type>
<db:parameter>loggingMode</db:parameter>
<db:initializer>AsynchronousLogging</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void startLogging(QOpenGLDebugLogger::LoggingMode loggingMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Starts logging messages coming from the OpenGL server. When a new message is received, the signal <db:link xlink:href="qopengldebuglogger.xml#messageLogged">messageLogged</db:link>() is emitted, carrying the logged message as argument.</db:para>
<db:para><db:code role="parameter">loggingMode</db:code> specifies whether the logging must be asynchronous (the default) or synchronous.</db:para>
<db:para><db:link xlink:href="qopengldebuglogger.xml">QOpenGLDebugLogger</db:link> will record the values of <db:code>GL_DEBUG_OUTPUT</db:code> and <db:code>GL_DEBUG_OUTPUT_SYNCHRONOUS</db:code> when logging is started, and set them back when logging is stopped. Moreover, any user-defined OpenGL debug callback installed when this function is invoked will be restored when logging is stopped; <db:link xlink:href="qopengldebuglogger.xml">QOpenGLDebugLogger</db:link> will ensure that the pre-existing callback will still be invoked when logging.</db:para>
<db:note>
<db:para>It's not possible to change the logging mode without stopping and starting logging again. This might change in a future version of Qt.</db:para>
</db:note>
<db:note>
<db:para>The object must be initialized before logging can happen.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#stopLogging">stopLogging</db:link>()</db:member>
<db:member><db:link xlink:href="qopengldebuglogger.xml#initialize">initialize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stopLogging">
<db:title>void QOpenGLDebugLogger::stopLogging()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>stopLogging</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void stopLogging()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Stops logging messages from the OpenGL server.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopengldebuglogger.xml#startLogging">startLogging</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
