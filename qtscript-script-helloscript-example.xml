<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Hello Script Example</db:title>
<db:productname>QtScript</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>QtScript Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>QtScript Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The Hello Script example shows the basic use of Qt Script: How to embed a script engine into the application, how to evaluate a script, and how to process the result of the evaluation. The example also shows how to apply internationalization to scripts.</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    Q_INIT_RESOURCE(helloscript);
</db:programlisting>
<db:para>The application will load the script file to evaluate from a resource, so we first make sure that the resource is initialized.</db:para>
<db:programlisting language="cpp">    QApplication app(argc, argv);

    QScriptEngine engine;

    QTranslator translator;
    translator.load(&quot;helloscript_la&quot;);
    app.installTranslator(&amp;translator);
    engine.installTranslatorFunctions();
</db:programlisting>
<db:para>We attempt to load a translation, and install translation functions in the script engine. How to produce a translation is explained later.</db:para>
<db:programlisting language="cpp">    QPushButton button;
    QScriptValue scriptButton = engine.newQObject(&amp;button);
    engine.globalObject().setProperty(&quot;button&quot;, scriptButton);
</db:programlisting>
<db:para>A push button is created and exported to the script environment as a global variable, <db:code>button</db:code>. Scripts will be able to access properties, signals and slots of the button as properties of the <db:code>button</db:code> script object; the script object acts as a proxy to the C++ button object.</db:para>
<db:programlisting language="cpp">    QString fileName(&quot;:/helloscript.js&quot;);
    QFile scriptFile(fileName);
    scriptFile.open(QIODevice::ReadOnly);
    QTextStream stream(&amp;scriptFile);
    QString contents = stream.readAll();
    scriptFile.close();
</db:programlisting>
<db:para>The contents of the script file are read.</db:para>
<db:programlisting language="cpp">button.text = qsTr('Hello World!');
button.styleSheet = 'font-style: italic';
button.show();
</db:programlisting>
<db:para>The script sets the <db:code>text</db:code> (note that the qTr() function is used to allow for translation) and <db:code>styleSheet</db:code> properties of the button, and calls the button's <db:code>show()</db:code> slot.</db:para>
<db:programlisting language="cpp">    QScriptValue result = engine.evaluate(contents, fileName);
</db:programlisting>
<db:para>The script is evaluated. Note that the file name is passed as the (optional) second parameter; this makes it possible for the script engine to produce a meaningful backtrace if something goes wrong, and makes the qTr() function be able to resolve the translations that are associated with this script.</db:para>
<db:programlisting language="cpp">    if (result.isError()) {
        QMessageBox::critical(0, &quot;Hello Script&quot;,
                              QString::fromLatin1(&quot;%0:%1: %2&quot;)
                              .arg(fileName)
                              .arg(result.property(&quot;lineNumber&quot;).toInt32())
                              .arg(result.toString()));
        return -1;
    }
</db:programlisting>
<db:para>If the result is an Error object (e.g. the script contained a syntax error, or tried to call a function that doesn't exist), we obtain the line number and string representation of the error and display it in a message box.</db:para>
<db:programlisting language="cpp">    return app.exec();
}
</db:programlisting>
<db:para>If the evaluation went well, the application event loop is entered.</db:para>
<db:section xml:id="translating-the-application">
<db:title>Translating the Application</db:title>
<db:para>The Qt Script internalization support builds on what Qt already provides for C++; see the <db:link xlink:href="qtlinguist-hellotr-example.xml">Hello tr() Example</db:link> for an introduction.</db:para>
<db:para>Since we haven't made the translation file <db:code>helloscript_la.qm</db:code>, the source text is shown when we run the application (&quot;Hello world!&quot;).</db:para>
<db:para>To generate the translation file, run <db:code>lupdate</db:code> as follows:</db:para>
<db:programlisting language="cpp">lupdate helloscript.js -ts helloscript_la.ts
</db:programlisting>
<db:para>You should now have a file <db:code>helloscript_la.ts</db:code> in the current directory. Run <db:code>linguist</db:code> to edit the translation:</db:para>
<db:programlisting language="cpp">linguist helloscript_la.ts
</db:programlisting>
<db:para>You should now see the text &quot;helloscript.js&quot; in the top left pane. Double-click it, then click on &quot;Hello world!&quot; and enter &quot;Orbis, te saluto!&quot; in the <db:emphasis role="bold">Translation</db:emphasis> pane (the middle right of the window). Don't forget the exclamation mark!</db:para>
<db:para>Click the <db:emphasis role="bold">Done</db:emphasis> checkbox and choose <db:emphasis role="bold">File|Save</db:emphasis> from the menu bar. The TS file will no longer contain</db:para>
<db:programlisting language="cpp">&lt;translation type='unfinished'&gt;&lt;/translation&gt;
</db:programlisting>
<db:para>but instead will have</db:para>
<db:programlisting language="cpp">&lt;translation&gt;Orbis, te saluto!&lt;/translation&gt;
</db:programlisting>
<db:para>To see the application running in Latin, we have to generate a QM file from the TS file. Generating a QM file can be achieved either from within <db:emphasis>Qt Linguist</db:emphasis> (for a single TS file), or by using the command line program <db:code>lrelease</db:code> which will produce one QM file for each of the TS files listed in the project file. Generate <db:code>hellotr_la.qm</db:code> from <db:code>hellotr_la.ts</db:code> by choosing <db:emphasis role="bold">File|Release</db:emphasis> from <db:emphasis>Qt Linguist</db:emphasis>'s menu bar and pressing <db:emphasis role="bold">Save</db:emphasis> in the file save dialog that pops up. Now run the <db:code>helloscript</db:code> program again. This time the button will be labelled &quot;Orbis, te saluto!&quot;.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="script/helloscript/helloscript.js">script/helloscript/helloscript.js</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="script/helloscript/helloscript.pro">script/helloscript/helloscript.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="script/helloscript/helloscript.qrc">script/helloscript/helloscript.qrc</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="script/helloscript/main.cpp">script/helloscript/main.cpp</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
