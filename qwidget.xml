<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QWidget Class</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 6.0.4 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qwidget.xml">QWidget</db:link> class is the base class of all user interface objects.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QWidget</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Widgets)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Widgets)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += widgets</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link> and <db:link xlink:href="qpaintdevice.xml" xlink:role="class">QPaintDevice</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qabstractbutton.xml" xlink:role="class">QAbstractButton</db:link>, <db:link xlink:href="qabstractslider.xml" xlink:role="class">QAbstractSlider</db:link>, <db:link xlink:href="qabstractspinbox.xml" xlink:role="class">QAbstractSpinBox</db:link>, <db:link xlink:href="qcalendarwidget.xml" xlink:role="class">QCalendarWidget</db:link>, <db:link xlink:href="qcombobox.xml" xlink:role="class">QComboBox</db:link>, <db:link xlink:href="qdesigneractioneditorinterface.xml" xlink:role="class">QDesignerActionEditorInterface</db:link>, <db:link xlink:href="qdesignerformwindowinterface.xml" xlink:role="class">QDesignerFormWindowInterface</db:link>, <db:link xlink:href="qdesignerobjectinspectorinterface.xml" xlink:role="class">QDesignerObjectInspectorInterface</db:link>, <db:link xlink:href="qdesignerpropertyeditorinterface.xml" xlink:role="class">QDesignerPropertyEditorInterface</db:link>, <db:link xlink:href="qdesignerwidgetboxinterface.xml" xlink:role="class">QDesignerWidgetBoxInterface</db:link>, <db:link xlink:href="qdialog.xml" xlink:role="class">QDialog</db:link>, <db:link xlink:href="qdialogbuttonbox.xml" xlink:role="class">QDialogButtonBox</db:link>, <db:link xlink:href="qdockwidget.xml" xlink:role="class">QDockWidget</db:link>, <db:link xlink:href="qfocusframe.xml" xlink:role="class">QFocusFrame</db:link>, <db:link xlink:href="qframe.xml" xlink:role="class">QFrame</db:link>, <db:link xlink:href="qgroupbox.xml" xlink:role="class">QGroupBox</db:link>, <db:link xlink:href="qhelpfiltersettingswidget.xml" xlink:role="class">QHelpFilterSettingsWidget</db:link>, <db:link xlink:href="qhelpsearchquerywidget.xml" xlink:role="class">QHelpSearchQueryWidget</db:link>, <db:link xlink:href="qhelpsearchresultwidget.xml" xlink:role="class">QHelpSearchResultWidget</db:link>, <db:link xlink:href="qkeysequenceedit.xml" xlink:role="class">QKeySequenceEdit</db:link>, <db:link xlink:href="qlineedit.xml" xlink:role="class">QLineEdit</db:link>, <db:link xlink:href="qmainwindow.xml" xlink:role="class">QMainWindow</db:link>, <db:link xlink:href="qmdisubwindow.xml" xlink:role="class">QMdiSubWindow</db:link>, <db:link xlink:href="qmenu.xml" xlink:role="class">QMenu</db:link>, <db:link xlink:href="qmenubar.xml" xlink:role="class">QMenuBar</db:link>, <db:link xlink:href="qopenglwidget.xml" xlink:role="class">QOpenGLWidget</db:link>, <db:link xlink:href="qprintpreviewwidget.xml" xlink:role="class">QPrintPreviewWidget</db:link>, <db:link xlink:href="qprogressbar.xml" xlink:role="class">QProgressBar</db:link>, <db:link xlink:href="qquickwidget.xml" xlink:role="class">QQuickWidget</db:link>, <db:link xlink:href="qrubberband.xml" xlink:role="class">QRubberBand</db:link>, <db:link xlink:href="qsizegrip.xml" xlink:role="class">QSizeGrip</db:link>, <db:link xlink:href="qsplashscreen.xml" xlink:role="class">QSplashScreen</db:link>, <db:link xlink:href="qsplitterhandle.xml" xlink:role="class">QSplitterHandle</db:link>, <db:link xlink:href="qstatusbar.xml" xlink:role="class">QStatusBar</db:link>, <db:link xlink:href="qsvgwidget.xml" xlink:role="class">QSvgWidget</db:link>, <db:link xlink:href="qtabbar.xml" xlink:role="class">QTabBar</db:link>, <db:link xlink:href="qtabwidget.xml" xlink:role="class">QTabWidget</db:link>, <db:link xlink:href="qtoolbar.xml" xlink:role="class">QToolBar</db:link>, and <db:link xlink:href="qwizardpage.xml" xlink:role="class">QWizardPage</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QWidget is part of <db:simplelist><db:member>basicwidgets</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The widget is the atom of the user interface: it receives mouse, keyboard and other events from the window system, and paints a representation of itself on the screen. Every widget is rectangular, and they are sorted in a Z-order. A widget is clipped by its parent and by the widgets in front of it.</db:para>
<db:para>A widget that is not embedded in a parent widget is called a window. Usually, windows have a frame and a title bar, although it is also possible to create windows without such decoration using suitable <db:link xlink:href="qt.xml#WindowType-enum">window flags</db:link>. In Qt, <db:link xlink:href="qmainwindow.xml">QMainWindow</db:link> and the various subclasses of <db:link xlink:href="qdialog.xml">QDialog</db:link> are the most common window types.</db:para>
<db:para>Every widget's constructor accepts one or two standard arguments:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para><db:code>QWidget *parent = nullptr</db:code> is the parent of the new widget. If it is <db:code>nullptr</db:code> (the default), the new widget will be a window. If not, it will be a child of <db:emphasis>parent</db:emphasis>, and be constrained by <db:emphasis>parent</db:emphasis>'s geometry (unless you specify <db:link xlink:href="qt.xml#WindowType-enum">Qt::Window</db:link> as window flag).</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>Qt::WindowFlags f = { }</db:code> (where available) sets the window flags; the default is suitable for almost all widgets, but to get, for example, a window without a window system frame, you must use special flags.</db:para>
</db:listitem>
</db:orderedlist>
<db:para><db:link xlink:href="qwidget.xml">QWidget</db:link> has many member functions, but some of them have little direct functionality; for example, <db:link xlink:href="qwidget.xml">QWidget</db:link> has a font property, but never uses this itself. There are many subclasses which provide real functionality, such as <db:link xlink:href="qlabel.xml">QLabel</db:link>, <db:link xlink:href="qpushbutton.xml">QPushButton</db:link>, <db:link xlink:href="qlistwidget.xml">QListWidget</db:link>, and <db:link xlink:href="qtabwidget.xml">QTabWidget</db:link>.</db:para>
<db:section xml:id="top-level-and-child-widgets">
<db:title>Top-Level and Child Widgets</db:title>
<db:para>A widget without a parent widget is always an independent window (top-level widget). For these widgets, <db:link xlink:href="qwidget.xml#windowTitle-prop">setWindowTitle</db:link>() and <db:link xlink:href="qwidget.xml#windowIcon-prop">setWindowIcon</db:link>() set the title bar and icon respectively.</db:para>
<db:para>Non-window widgets are child widgets, displayed within their parent widgets. Most widgets in Qt are mainly useful as child widgets. For example, it is possible to display a button as a top-level window, but most people prefer to put their buttons inside other widgets, such as <db:link xlink:href="qdialog.xml">QDialog</db:link>.</db:para>
<db:mediaobject>
<db:alt>A parent widget containing various child widgets.</db:alt>
<db:imageobject>
<db:imagedata fileref="images/parent-child-widgets.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The diagram above shows a <db:link xlink:href="qgroupbox.xml">QGroupBox</db:link> widget being used to hold various child widgets in a layout provided by <db:link xlink:href="qgridlayout.xml">QGridLayout</db:link>. The <db:link xlink:href="qlabel.xml">QLabel</db:link> child widgets have been outlined to indicate their full sizes.</db:para>
<db:para>If you want to use a <db:link xlink:href="qwidget.xml">QWidget</db:link> to hold child widgets you will usually want to add a layout to the parent <db:link xlink:href="qwidget.xml">QWidget</db:link>. See <db:link xlink:href="layout.xml">Layout Management</db:link> for more information.</db:para>
</db:section>
<db:section xml:id="composite-widgets">
<db:title>Composite Widgets</db:title>
<db:para>When a widget is used as a container to group a number of child widgets, it is known as a composite widget. These can be created by constructing a widget with the required visual properties - a <db:link xlink:href="qframe.xml">QFrame</db:link>, for example - and adding child widgets to it, usually managed by a layout. The above diagram shows such a composite widget that was created using Qt Designer.</db:para>
<db:para>Composite widgets can also be created by subclassing a standard widget, such as <db:link xlink:href="qwidget.xml">QWidget</db:link> or <db:link xlink:href="qframe.xml">QFrame</db:link>, and adding the necessary layout and child widgets in the constructor of the subclass. Many of the <db:link xlink:href="examples-widgets.xml">examples provided with Qt</db:link> use this approach, and it is also covered in the Qt <db:link xlink:href="qtwidgets-index.xml#tutorials">Tutorials</db:link>.</db:para>
</db:section>
<db:section xml:id="custom-widgets-and-painting">
<db:title>Custom Widgets and Painting</db:title>
<db:para>Since <db:link xlink:href="qwidget.xml">QWidget</db:link> is a subclass of <db:link xlink:href="qpaintdevice.xml">QPaintDevice</db:link>, subclasses can be used to display custom content that is composed using a series of painting operations with an instance of the <db:link xlink:href="qpainter.xml">QPainter</db:link> class. This approach contrasts with the canvas-style approach used by the <db:link xlink:href="graphicsview.xml">Graphics View Framework</db:link> where items are added to a scene by the application and are rendered by the framework itself.</db:para>
<db:para>Each widget performs all painting operations from within its <db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>() function. This is called whenever the widget needs to be redrawn, either as a result of some external change or when requested by the application.</db:para>
<db:para>The <db:link xlink:href="qtwidgets-widgets-analogclock-example.xml">Analog Clock example</db:link> shows how a simple widget can handle paint events.</db:para>
</db:section>
<db:section xml:id="size-hints-and-size-policies">
<db:title>Size Hints and Size Policies</db:title>
<db:para>When implementing a new widget, it is almost always useful to reimplement <db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>() to provide a reasonable default size for the widget and to set the correct size policy with <db:link xlink:href="qwidget.xml#sizePolicy-prop">setSizePolicy</db:link>().</db:para>
<db:para>By default, composite widgets which do not provide a size hint will be sized according to the space requirements of their child widgets.</db:para>
<db:para>The size policy lets you supply good default behavior for the layout management system, so that other widgets can contain and manage yours easily. The default size policy indicates that the size hint represents the preferred size of the widget, and this is often good enough for many widgets.</db:para>
<db:note>
<db:para>The size of top-level widgets are constrained to 2/3 of the desktop's height and width. You can <db:link xlink:href="qwidget.xml#size-prop">resize</db:link>() the widget manually if these bounds are inadequate.</db:para>
</db:note>
</db:section>
<db:section xml:id="events">
<db:title>Events</db:title>
<db:para>Widgets respond to events that are typically caused by user actions. Qt delivers events to widgets by calling specific event handler functions with instances of <db:link xlink:href="qevent.xml">QEvent</db:link> subclasses containing information about each event.</db:para>
<db:para>If your widget only contains child widgets, you probably do not need to implement any event handlers. If you want to detect a mouse click in a child widget call the child's <db:link xlink:href="qwidget.xml#underMouse">underMouse</db:link>() function inside the widget's <db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>().</db:para>
<db:para>The <db:link xlink:href="qtwidgets-widgets-scribble-example.xml">Scribble example</db:link> implements a wider set of events to handle mouse movement, button presses, and window resizing.</db:para>
<db:para>You will need to supply the behavior and content for your own widgets, but here is a brief overview of the events that are relevant to <db:link xlink:href="qwidget.xml">QWidget</db:link>, starting with the most common ones:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>() is called whenever the widget needs to be repainted. Every widget displaying custom content must implement it. Painting using a <db:link xlink:href="qpainter.xml">QPainter</db:link> can only take place in a <db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>() or a function called by a <db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#resizeEvent">resizeEvent</db:link>() is called when the widget has been resized.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>() is called when a mouse button is pressed while the mouse cursor is inside the widget, or when the widget has grabbed the mouse using <db:link xlink:href="qwidget.xml#grabMouse">grabMouse</db:link>(). Pressing the mouse without releasing it is effectively the same as calling <db:link xlink:href="qwidget.xml#grabMouse">grabMouse</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#mouseReleaseEvent">mouseReleaseEvent</db:link>() is called when a mouse button is released. A widget receives mouse release events when it has received the corresponding mouse press event. This means that if the user presses the mouse inside <db:emphasis>your</db:emphasis> widget, then drags the mouse somewhere else before releasing the mouse button, <db:emphasis>your</db:emphasis> widget receives the release event. There is one exception: if a popup menu appears while the mouse button is held down, this popup immediately steals the mouse events.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#mouseDoubleClickEvent">mouseDoubleClickEvent</db:link>() is called when the user double-clicks in the widget. If the user double-clicks, the widget receives a mouse press event, a mouse release event, (a mouse click event,) a second mouse press, this event and finally a second mouse release event. (Some mouse move events may also be received if the mouse is not held steady during this operation.) It is <db:emphasis>not possible</db:emphasis> to distinguish a click from a double-click until the second click arrives. (This is one reason why most GUI books recommend that double-clicks be an extension of single-clicks, rather than trigger a different action.)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Widgets that accept keyboard input need to reimplement a few more event handlers:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#keyPressEvent">keyPressEvent</db:link>() is called whenever a key is pressed, and again when a key has been held down long enough for it to auto-repeat. The <db:guilabel>Tab</db:guilabel> and <db:guilabel>Shift+Tab</db:guilabel> keys are only passed to the widget if they are not used by the focus-change mechanisms. To force those keys to be processed by your widget, you must reimplement <db:link xlink:href="qwidget.xml#event">QWidget::event</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#focusInEvent">focusInEvent</db:link>() is called when the widget gains keyboard focus (assuming you have called <db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>()). Well-behaved widgets indicate that they own the keyboard focus in a clear but discreet way.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#focusOutEvent">focusOutEvent</db:link>() is called when the widget loses keyboard focus.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>You may be required to also reimplement some of the less common event handlers:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#mouseMoveEvent">mouseMoveEvent</db:link>() is called whenever the mouse moves while a mouse button is held down. This can be useful during drag and drop operations. If you call <db:link xlink:href="qwidget.xml#mouseTracking-prop">setMouseTracking</db:link>(true), you get mouse move events even when no buttons are held down. (See also the <db:link xlink:href="graphicsview.xml#drag-and-drop">Drag and Drop</db:link> guide.)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#keyReleaseEvent">keyReleaseEvent</db:link>() is called whenever a key is released and while it is held down (if the key is auto-repeating). In that case, the widget will receive a pair of key release and key press event for every repeat. The <db:guilabel>Tab</db:guilabel> and <db:guilabel>Shift+Tab</db:guilabel> keys are only passed to the widget if they are not used by the focus-change mechanisms. To force those keys to be processed by your widget, you must reimplement <db:link xlink:href="qwidget.xml#event">QWidget::event</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#wheelEvent">wheelEvent</db:link>() is called whenever the user turns the mouse wheel while the widget has the focus.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#enterEvent">enterEvent</db:link>() is called when the mouse enters the widget's screen space. (This excludes screen space owned by any of the widget's children.)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#leaveEvent">leaveEvent</db:link>() is called when the mouse leaves the widget's screen space. If the mouse enters a child widget it will not cause a <db:link xlink:href="qwidget.xml#leaveEvent">leaveEvent</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#moveEvent">moveEvent</db:link>() is called when the widget has been moved relative to its parent.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#closeEvent">closeEvent</db:link>() is called when the user closes the widget (or when <db:link xlink:href="qwidget.xml#close">close</db:link>() is called).</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>There are also some rather obscure events described in the documentation for <db:link xlink:href="qevent.xml#Type-enum">QEvent::Type</db:link>. To handle these events, you need to reimplement <db:link xlink:href="qwidget.xml#event">event</db:link>() directly.</db:para>
<db:para>The default implementation of <db:link xlink:href="qwidget.xml#event">event</db:link>() handles <db:guilabel>Tab</db:guilabel> and <db:guilabel>Shift+Tab</db:guilabel> (to move the keyboard focus), and passes on most of the other events to one of the more specialized handlers above.</db:para>
<db:para>Events and the mechanism used to deliver them are covered in <db:link xlink:href="eventsandfilters.xml">The Event System</db:link>.</db:para>
</db:section>
<db:section xml:id="groups-of-functions-and-properties">
<db:title>Groups of Functions and Properties</db:title>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Context</db:para>
</db:th>
<db:th>
<db:para>Functions and Properties</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Window functions</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qwidget.xml#show">show</db:link>(), <db:link xlink:href="qwidget.xml#hide">hide</db:link>(), <db:link xlink:href="qwidget.xml#raise">raise</db:link>(), <db:link xlink:href="qwidget.xml#lower">lower</db:link>(), <db:link xlink:href="qwidget.xml#close">close</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Top-level windows</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qwidget.xml#windowModified-prop">windowModified</db:link>, <db:link xlink:href="qwidget.xml#windowTitle-prop">windowTitle</db:link>, <db:link xlink:href="qwidget.xml#windowIcon-prop">windowIcon</db:link>, <db:link xlink:href="qwidget.xml#isActiveWindow-prop">isActiveWindow</db:link>, <db:link xlink:href="qwidget.xml#activateWindow">activateWindow</db:link>(), <db:link xlink:href="qwidget.xml#minimized-prop">minimized</db:link>, <db:link xlink:href="qwidget.xml#showMinimized">showMinimized</db:link>(), <db:link xlink:href="qwidget.xml#maximized-prop">maximized</db:link>, <db:link xlink:href="qwidget.xml#showMaximized">showMaximized</db:link>(), <db:link xlink:href="qwidget.xml#fullScreen-prop">fullScreen</db:link>, <db:link xlink:href="qwidget.xml#showFullScreen">showFullScreen</db:link>(), <db:link xlink:href="qwidget.xml#showNormal">showNormal</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Window contents</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qwidget.xml#update">update</db:link>(), <db:link xlink:href="qwidget.xml#repaint">repaint</db:link>(), <db:link xlink:href="qwidget.xml#scroll">scroll</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Geometry</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qwidget.xml#pos-prop">pos</db:link>, <db:link xlink:href="qwidget.xml#x-prop">x</db:link>(), <db:link xlink:href="qwidget.xml#y-prop">y</db:link>(), <db:link xlink:href="qwidget.xml#rect-prop">rect</db:link>, <db:link xlink:href="qwidget.xml#size-prop">size</db:link>, <db:link xlink:href="qwidget.xml#width-prop">width</db:link>(), <db:link xlink:href="qwidget.xml#height-prop">height</db:link>(), <db:link xlink:href="qwidget.xml#pos-prop">move</db:link>(), <db:link xlink:href="qwidget.xml#size-prop">resize</db:link>(), <db:link xlink:href="qwidget.xml#sizePolicy-prop">sizePolicy</db:link>, <db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>(), <db:link xlink:href="qwidget.xml#minimumSizeHint-prop">minimumSizeHint</db:link>(), <db:link xlink:href="qwidget.xml#updateGeometry">updateGeometry</db:link>(), <db:link xlink:href="qwidget.xml#layout">layout</db:link>(), <db:link xlink:href="qwidget.xml#frameGeometry-prop">frameGeometry</db:link>, <db:link xlink:href="qwidget.xml#geometry-prop">geometry</db:link>, <db:link xlink:href="qwidget.xml#childrenRect-prop">childrenRect</db:link>, <db:link xlink:href="qwidget.xml#childrenRegion-prop">childrenRegion</db:link>, <db:link xlink:href="qwidget.xml#adjustSize">adjustSize</db:link>(), <db:link xlink:href="qwidget.xml#mapFromGlobal">mapFromGlobal</db:link>(), <db:link xlink:href="qwidget.xml#mapToGlobal">mapToGlobal</db:link>(), <db:link xlink:href="qwidget.xml#mapFromParent">mapFromParent</db:link>(), <db:link xlink:href="qwidget.xml#mapToParent">mapToParent</db:link>(), <db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link>, <db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link>, <db:link xlink:href="qwidget.xml#sizeIncrement-prop">sizeIncrement</db:link>, <db:link xlink:href="qwidget.xml#baseSize-prop">baseSize</db:link>, <db:link xlink:href="qwidget.xml#setFixedSize">setFixedSize</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Mode</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qwidget.xml#visible-prop">visible</db:link>, <db:link xlink:href="qwidget.xml#isVisibleTo">isVisibleTo</db:link>(), <db:link xlink:href="qwidget.xml#enabled-prop">enabled</db:link>, <db:link xlink:href="qwidget.xml#isEnabledTo">isEnabledTo</db:link>(), <db:link xlink:href="qwidget.xml#modal-prop">modal</db:link>, <db:link xlink:href="qwidget.xml#isWindow">isWindow</db:link>(), <db:link xlink:href="qwidget.xml#mouseTracking-prop">mouseTracking</db:link>, <db:link xlink:href="qwidget.xml#updatesEnabled-prop">updatesEnabled</db:link>, <db:link xlink:href="qwidget.xml#visibleRegion">visibleRegion</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Look and feel</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qwidget.xml#style">style</db:link>(), <db:link xlink:href="qwidget.xml#setStyle">setStyle</db:link>(), <db:link xlink:href="stylesheet.xml">styleSheet</db:link>, <db:link xlink:href="qwidget.xml#cursor-prop">cursor</db:link>, <db:link xlink:href="stylesheet-reference.xml#font">font</db:link>, <db:link xlink:href="qwidget.xml#palette-prop">palette</db:link>, <db:link xlink:href="qwidget.xml#backgroundRole">backgroundRole</db:link>(), <db:link xlink:href="qwidget.xml#setBackgroundRole">setBackgroundRole</db:link>(), <db:link xlink:href="qwidget.xml#fontInfo">fontInfo</db:link>(), <db:link xlink:href="qwidget.xml#fontMetrics">fontMetrics</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Keyboard focus functions</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qwidget.xml#focus-prop">focus</db:link>, <db:link xlink:href="qwidget.xml#focusPolicy-prop">focusPolicy</db:link>, <db:link xlink:href="qwidget.xml#setFocus-1">setFocus</db:link>(), <db:link xlink:href="qwidget.xml#clearFocus">clearFocus</db:link>(), <db:link xlink:href="qwidget.xml#setTabOrder">setTabOrder</db:link>(), <db:link xlink:href="qwidget.xml#setFocusProxy">setFocusProxy</db:link>(), <db:link xlink:href="qwidget.xml#focusNextChild">focusNextChild</db:link>(), <db:link xlink:href="qwidget.xml#focusPreviousChild">focusPreviousChild</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Mouse and keyboard grabbing</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qwidget.xml#grabMouse">grabMouse</db:link>(), <db:link xlink:href="qwidget.xml#releaseMouse">releaseMouse</db:link>(), <db:link xlink:href="qwidget.xml#grabKeyboard">grabKeyboard</db:link>(), <db:link xlink:href="qwidget.xml#releaseKeyboard">releaseKeyboard</db:link>(), <db:link xlink:href="qwidget.xml#mouseGrabber">mouseGrabber</db:link>(), <db:link xlink:href="qwidget.xml#keyboardGrabber">keyboardGrabber</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Event handlers</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qwidget.xml#event">event</db:link>(), <db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>(), <db:link xlink:href="qwidget.xml#mouseReleaseEvent">mouseReleaseEvent</db:link>(), <db:link xlink:href="qwidget.xml#mouseDoubleClickEvent">mouseDoubleClickEvent</db:link>(), <db:link xlink:href="qwidget.xml#mouseMoveEvent">mouseMoveEvent</db:link>(), <db:link xlink:href="qwidget.xml#keyPressEvent">keyPressEvent</db:link>(), <db:link xlink:href="qwidget.xml#keyReleaseEvent">keyReleaseEvent</db:link>(), <db:link xlink:href="qwidget.xml#focusInEvent">focusInEvent</db:link>(), <db:link xlink:href="qwidget.xml#focusOutEvent">focusOutEvent</db:link>(), <db:link xlink:href="qwidget.xml#wheelEvent">wheelEvent</db:link>(), <db:link xlink:href="qwidget.xml#enterEvent">enterEvent</db:link>(), <db:link xlink:href="qwidget.xml#leaveEvent">leaveEvent</db:link>(), <db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>(), <db:link xlink:href="qwidget.xml#moveEvent">moveEvent</db:link>(), <db:link xlink:href="qwidget.xml#resizeEvent">resizeEvent</db:link>(), <db:link xlink:href="qwidget.xml#closeEvent">closeEvent</db:link>(), <db:link xlink:href="qwidget.xml#dragEnterEvent">dragEnterEvent</db:link>(), <db:link xlink:href="qwidget.xml#dragMoveEvent">dragMoveEvent</db:link>(), <db:link xlink:href="qwidget.xml#dragLeaveEvent">dragLeaveEvent</db:link>(), <db:link xlink:href="qwidget.xml#dropEvent">dropEvent</db:link>(), <db:link xlink:href="qobject.xml#childEvent">childEvent</db:link>(), <db:link xlink:href="qwidget.xml#showEvent">showEvent</db:link>(), <db:link xlink:href="qwidget.xml#hideEvent">hideEvent</db:link>(), <db:link xlink:href="qobject.xml#customEvent">customEvent</db:link>(). <db:link xlink:href="qwidget.xml#changeEvent">changeEvent</db:link>(),</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>System functions</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qwidget.xml#parentWidget">parentWidget</db:link>(), <db:link xlink:href="qwidget.xml#window">window</db:link>(), <db:link xlink:href="qwidget.xml#setParent">setParent</db:link>(), <db:link xlink:href="qwidget.xml#winId">winId</db:link>(), <db:link xlink:href="qwidget.xml#find">find</db:link>(), <db:link xlink:href="qwidget.xml#metric">metric</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Context menu</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qwidget.xml#contextMenuPolicy-prop">contextMenuPolicy</db:link>, <db:link xlink:href="qwidget.xml#contextMenuEvent">contextMenuEvent</db:link>(), <db:link xlink:href="qwidget.xml#customContextMenuRequested">customContextMenuRequested</db:link>(), <db:link xlink:href="qwidget.xml#actions">actions</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Interactive help</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qwidget.xml#toolTip-prop">setToolTip</db:link>(), <db:link xlink:href="qwidget.xml#whatsThis-prop">setWhatsThis</db:link>()</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="widget-style-sheets">
<db:title>Widget Style Sheets</db:title>
<db:para>In addition to the standard widget styles for each platform, widgets can also be styled according to rules specified in a <db:link xlink:href="stylesheet.xml">style sheet</db:link>. This feature enables you to customize the appearance of specific widgets to provide visual cues to users about their purpose. For example, a button could be styled in a particular way to indicate that it performs a destructive action.</db:para>
<db:para>The use of widget style sheets is described in more detail in the <db:link xlink:href="stylesheet.xml">Qt Style Sheets</db:link> document.</db:para>
</db:section>
<db:section xml:id="transparency-and-double-buffering">
<db:title>Transparency and Double Buffering</db:title>
<db:para>Since Qt 4.0, <db:link xlink:href="qwidget.xml">QWidget</db:link> automatically double-buffers its painting, so there is no need to write double-buffering code in <db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>() to avoid flicker.</db:para>
<db:para>Since Qt 4.1, the contents of parent widgets are propagated by default to each of their children as long as <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_PaintOnScreen</db:link> is not set. Custom widgets can be written to take advantage of this feature by updating irregular regions (to create non-rectangular child widgets), or painting with colors that have less than full alpha component. The following diagram shows how attributes and properties of a custom widget can be fine-tuned to achieve different effects.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/propagation-custom.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>In the above diagram, a semi-transparent rectangular child widget with an area removed is constructed and added to a parent widget (a <db:link xlink:href="qlabel.xml">QLabel</db:link> showing a pixmap). Then, different properties and widget attributes are set to achieve different effects:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The left widget has no additional properties or widget attributes set. This default state suits most custom widgets using transparency, are irregularly-shaped, or do not paint over their entire area with an opaque brush.</db:para>
</db:listitem>
<db:listitem>
<db:para>The center widget has the <db:link xlink:href="qwidget.xml#autoFillBackground-prop">autoFillBackground</db:link> property set. This property is used with custom widgets that rely on the widget to supply a default background, and do not paint over their entire area with an opaque brush.</db:para>
</db:listitem>
<db:listitem>
<db:para>The right widget has the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</db:link> widget attribute set. This indicates that the widget will paint over its entire area with opaque colors. The widget's area will initially be <db:emphasis>uninitialized</db:emphasis>, represented in the diagram with a red diagonal grid pattern that shines through the overpainted area. The Qt::WA_OpaquePaintArea attribute is useful for widgets that need to paint their own specialized contents quickly and do not need a default filled background.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>To rapidly update custom widgets with simple background colors, such as real-time plotting or graphing widgets, it is better to define a suitable background color (using <db:link xlink:href="qwidget.xml#setBackgroundRole">setBackgroundRole</db:link>() with the <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::Window</db:link> role), set the <db:link xlink:href="qwidget.xml#autoFillBackground-prop">autoFillBackground</db:link> property, and only implement the necessary drawing functionality in the widget's <db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>().</db:para>
<db:para>To rapidly update custom widgets that constantly paint over their entire areas with opaque content, e.g., video streaming widgets, it is better to set the widget's <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</db:link>, avoiding any unnecessary overhead associated with repainting the widget's background.</db:para>
<db:para>If a widget has both the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</db:link> widget attribute <db:emphasis>and</db:emphasis> the <db:link xlink:href="qwidget.xml#autoFillBackground-prop">autoFillBackground</db:link> property set, the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</db:link> attribute takes precedence. Depending on your requirements, you should choose either one of them.</db:para>
<db:para>Since Qt 4.1, the contents of parent widgets are also propagated to standard Qt widgets. This can lead to some unexpected results if the parent widget is decorated in a non-standard way, as shown in the diagram below.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/propagation-standard.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The scope for customizing the painting behavior of standard Qt widgets, without resorting to subclassing, is slightly less than that possible for custom widgets. Usually, the desired appearance of a standard widget can be achieved by setting its <db:link xlink:href="qwidget.xml#autoFillBackground-prop">autoFillBackground</db:link> property.</db:para>
</db:section>
<db:section xml:id="creating-translucent-windows">
<db:title>Creating Translucent Windows</db:title>
<db:para>Since Qt 4.5, it has been possible to create windows with translucent regions on window systems that support compositing.</db:para>
<db:para>To enable this feature in a top-level widget, set its <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_TranslucentBackground</db:link> attribute with <db:link xlink:href="qwidget.xml#setAttribute">setAttribute</db:link>() and ensure that its background is painted with non-opaque colors in the regions you want to be partially transparent.</db:para>
<db:para>Platform notes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>X11: This feature relies on the use of an X server that supports ARGB visuals and a compositing window manager.</db:para>
</db:listitem>
<db:listitem>
<db:para>Windows: The widget needs to have the <db:link xlink:href="qt.xml#WindowType-enum">Qt::FramelessWindowHint</db:link> window flag set for the translucency to work.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="native-widgets-vs-alien-widgets">
<db:title>Native Widgets vs Alien Widgets</db:title>
<db:para>Introduced in Qt 4.4, alien widgets are widgets unknown to the windowing system. They do not have a native window handle associated with them. This feature significantly speeds up widget painting, resizing, and removes flicker.</db:para>
<db:para>Should you require the old behavior with native windows, you can choose one of the following options:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Use the <db:code>QT_USE_NATIVE_WINDOWS=1</db:code> in your environment.</db:para>
</db:listitem>
<db:listitem>
<db:para>Set the <db:link xlink:href="qt.xml#ApplicationAttribute-enum">Qt::AA_NativeWindows</db:link> attribute on your application. All widgets will be native widgets.</db:para>
</db:listitem>
<db:listitem>
<db:para>Set the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_NativeWindow</db:link> attribute on widgets: The widget itself and all of its ancestors will become native (unless <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_DontCreateNativeAncestors</db:link> is set).</db:para>
</db:listitem>
<db:listitem>
<db:para>Call <db:link xlink:href="qwidget.xml#winId">QWidget::winId</db:link> to enforce a native window (this implies 3).</db:para>
</db:listitem>
<db:listitem>
<db:para>Set the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_PaintOnScreen</db:link> attribute to enforce a native window (this implies 3).</db:para>
</db:listitem>
</db:orderedlist>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qevent.xml">QEvent</db:link></db:member>
<db:member><db:link xlink:href="qpainter.xml">QPainter</db:link></db:member>
<db:member><db:link xlink:href="qgridlayout.xml">QGridLayout</db:link></db:member>
<db:member><db:link xlink:href="qboxlayout.xml">QBoxLayout</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="RenderFlag-enum">
<db:title>enum QWidget::RenderFlag</db:title>
<db:bridgehead renderas="sect2">flags QWidget::RenderFlags</db:bridgehead>
<db:enumsynopsis>
<db:enumname>RenderFlag</db:enumname>
<db:enumitem>
<db:enumidentifier>DrawWindowBackground</db:enumidentifier>
<db:enumvalue>0x1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DrawChildren</db:enumidentifier>
<db:enumvalue>0x2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>IgnoreMask</db:enumidentifier>
<db:enumvalue>0x4</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QWidget::RenderFlags</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum describes how to render the widget when calling <db:link xlink:href="qwidget.xml#render">QWidget::render</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qwidget.xml">QWidget</db:link></db:emphasis>::DrawWindowBackground</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>If you enable this option, the widget's background is rendered into the target even if <db:link xlink:href="qwidget.xml#autoFillBackground-prop">autoFillBackground</db:link> is not set. By default, this option is enabled.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qwidget.xml">QWidget</db:link></db:emphasis>::DrawChildren</db:code></db:para>
</db:td>
<db:td><db:code>0x2</db:code></db:td>
<db:td>
<db:para>If you enable this option, the widget's children are rendered recursively into the target. By default, this option is enabled.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qwidget.xml">QWidget</db:link></db:emphasis>::IgnoreMask</db:code></db:para>
</db:td>
<db:td><db:code>0x4</db:code></db:td>
<db:td>
<db:para>If you enable this option, the widget's <db:link xlink:href="qwidget.xml#mask">QWidget::mask</db:link>() is ignored when rendering into the target. By default, this option is disabled.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>RenderFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;RenderFlag&gt;. </db:code>It stores an OR combination of <db:code>RenderFlag</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="acceptDrops-prop">
<db:title>acceptDrops : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>acceptDrops</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">acceptDrops</db:synopsisinfo>
<db:synopsisinfo role="setter">setAcceptDrops</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether drop events are enabled for this widget</db:para>
<db:para>Setting this property to true announces to the system that this widget <db:emphasis>may</db:emphasis> be able to accept drop events.</db:para>
<db:para>If the widget is the desktop (<db:link xlink:href="qwidget.xml#windowType">windowType</db:link>() == <db:link xlink:href="qt.xml#WindowType-enum">Qt::Desktop</db:link>), this may fail if another application is using the desktop; you can call acceptDrops() to test if this occurs.</db:para>
<db:warning>
<db:para>Do not modify this property in a drag and drop event handler.</db:para>
</db:warning>
<db:para>By default, this property is <db:code>false</db:code>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">acceptDrops</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setAcceptDrops</db:emphasis>(<db:type>bool</db:type> <db:emphasis>on</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="graphicsview.xml#drag-and-drop">Drag and Drop</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="accessibleDescription-prop">
<db:title>accessibleDescription : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>accessibleDescription</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">accessibleDescription</db:synopsisinfo>
<db:synopsisinfo role="setter">setAccessibleDescription</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's description as seen by assistive technologies</db:para>
<db:para>The accessible description of a widget should convey what a widget does. While the <db:link xlink:href="qwidget.xml#accessibleName-prop">accessibleName</db:link> should be a short and concise string (e.g. <db:emphasis role="bold">Save</db:emphasis>), the description should give more context, such as <db:emphasis role="bold">Saves the current document</db:emphasis>.</db:para>
<db:para>This property has to be <db:link xlink:href="internationalization.xml">localized</db:link>.</db:para>
<db:para>By default, this property contains an empty string and Qt falls back to using the tool tip to provide this information.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">accessibleDescription</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setAccessibleDescription</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>description</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#accessibleName-prop">QWidget::accessibleName</db:link></db:member>
<db:member><db:link xlink:href="qaccessibleinterface.xml#text">QAccessibleInterface::text</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="accessibleName-prop">
<db:title>accessibleName : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>accessibleName</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">accessibleName</db:synopsisinfo>
<db:synopsisinfo role="setter">setAccessibleName</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's name as seen by assistive technologies</db:para>
<db:para>This is the primary name by which assistive technology such as screen readers announce this widget. For most widgets setting this property is not required. For example for <db:link xlink:href="qpushbutton.xml">QPushButton</db:link> the button's text will be used.</db:para>
<db:para>It is important to set this property when the widget does not provide any text. For example a button that only contains an icon needs to set this property to work with screen readers. The name should be short and equivalent to the visual information conveyed by the widget.</db:para>
<db:para>This property has to be <db:link xlink:href="internationalization.xml">localized</db:link>.</db:para>
<db:para>By default, this property contains an empty string.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">accessibleName</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setAccessibleName</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>name</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#accessibleDescription-prop">QWidget::accessibleDescription</db:link></db:member>
<db:member><db:link xlink:href="qaccessibleinterface.xml#text">QAccessibleInterface::text</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="autoFillBackground-prop">
<db:title>autoFillBackground : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>autoFillBackground</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">autoFillBackground</db:synopsisinfo>
<db:synopsisinfo role="setter">setAutoFillBackground</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether the widget background is filled automatically</db:para>
<db:para>If enabled, this property will cause Qt to fill the background of the widget before invoking the paint event. The color used is defined by the <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::Window</db:link> color role from the widget's <db:link xlink:href="qpalette.xml">palette</db:link>.</db:para>
<db:para>In addition, Windows are always filled with <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::Window</db:link>, unless the WA_OpaquePaintEvent or WA_NoSystemBackground attributes are set.</db:para>
<db:para>This property cannot be turned off (i.e., set to false) if a widget's parent has a static gradient for its background.</db:para>
<db:warning>
<db:para>Use this property with caution in conjunction with <db:link xlink:href="stylesheet.xml">Qt Style Sheets</db:link>. When a widget has a style sheet with a valid background or a border-image, this property is automatically disabled.</db:para>
</db:warning>
<db:para>By default, this property is <db:code>false</db:code>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">autoFillBackground</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setAutoFillBackground</db:emphasis>(<db:type>bool</db:type> <db:emphasis>enabled</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</db:link></db:member>
<db:member><db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_NoSystemBackground</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#transparency-and-double-buffering">Transparency and Double Buffering</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="baseSize-prop">
<db:title>baseSize : QSize</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QSize</db:type>
<db:varname>baseSize</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">baseSize</db:synopsisinfo>
<db:synopsisinfo role="setter">setBaseSize</db:synopsisinfo>
<db:synopsisinfo role="setter">setBaseSize</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the base size of the widget</db:para>
<db:para>The base size is used to calculate a proper widget size if the widget defines <db:link xlink:href="qwidget.xml#sizeIncrement-prop">sizeIncrement</db:link>().</db:para>
<db:para>By default, for a newly-created widget, this property contains a size with zero width and height.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsize.xml">QSize</db:link></db:type> <db:emphasis role="bold">baseSize</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setBaseSize</db:emphasis>(<db:emphasis>const QSize &amp;</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwidget.xml#setBaseSize-1">setBaseSize</db:link></db:emphasis>(<db:type>int</db:type> <db:emphasis>basew</db:emphasis>, <db:type>int</db:type> <db:emphasis>baseh</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#sizeIncrement-prop">setSizeIncrement</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="childrenRect-prop">
<db:title>[read-only] childrenRect : const QRect</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QRect</db:type>
<db:varname>childrenRect</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">childrenRect</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the bounding rectangle of the widget's children</db:para>
<db:para>Hidden children are excluded.</db:para>
<db:para>By default, for a widget with no children, this property contains a rectangle with zero width and height located at the origin.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qrect.xml">QRect</db:link></db:type> <db:emphasis role="bold">childrenRect</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#childrenRegion-prop">childrenRegion</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#geometry-prop">geometry</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="childrenRegion-prop">
<db:title>[read-only] childrenRegion : const QRegion</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QRegion</db:type>
<db:varname>childrenRegion</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">childrenRegion</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the combined region occupied by the widget's children</db:para>
<db:para>Hidden children are excluded.</db:para>
<db:para>By default, for a widget with no children, this property contains an empty region.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qregion.xml">QRegion</db:link></db:type> <db:emphasis role="bold">childrenRegion</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#childrenRect-prop">childrenRect</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#geometry-prop">geometry</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mask">mask</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contextMenuPolicy-prop">
<db:title>contextMenuPolicy : Qt::ContextMenuPolicy</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>Qt::ContextMenuPolicy</db:type>
<db:varname>contextMenuPolicy</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">contextMenuPolicy</db:synopsisinfo>
<db:synopsisinfo role="setter">setContextMenuPolicy</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>how the widget shows a context menu</db:para>
<db:para>The default value of this property is <db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::DefaultContextMenu</db:link>, which means the <db:link xlink:href="qwidget.xml#contextMenuEvent">contextMenuEvent</db:link>() handler is called. Other values are <db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::NoContextMenu</db:link>, <db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::PreventContextMenu</db:link>, <db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::ActionsContextMenu</db:link>, and <db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::CustomContextMenu</db:link>. With <db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::CustomContextMenu</db:link>, the signal <db:link xlink:href="qwidget.xml#customContextMenuRequested">customContextMenuRequested</db:link>() is emitted.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::ContextMenuPolicy</db:link></db:type> <db:emphasis role="bold">contextMenuPolicy</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setContextMenuPolicy</db:emphasis>(<db:type><db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::ContextMenuPolicy</db:link></db:type> <db:emphasis>policy</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#contextMenuEvent">contextMenuEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#customContextMenuRequested">customContextMenuRequested</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#actions">actions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cursor-prop">
<db:title>cursor : QCursor</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QCursor</db:type>
<db:varname>cursor</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">cursor</db:synopsisinfo>
<db:synopsisinfo role="setter">setCursor</db:synopsisinfo>
<db:synopsisinfo role="resetter">unsetCursor</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the cursor shape for this widget</db:para>
<db:para>The mouse cursor will assume this shape when it's over this widget. See the <db:link xlink:href="qt.xml#CursorShape-enum">list of predefined cursor objects</db:link> for a range of useful shapes.</db:para>
<db:para>An editor widget might use an I-beam cursor:</db:para>
<db:programlisting language="cpp">setCursor(Qt::IBeamCursor);
</db:programlisting>
<db:para>If no cursor has been set, or after a call to unsetCursor(), the parent's cursor is used.</db:para>
<db:para>By default, this property contains a cursor with the <db:link xlink:href="qt.xml#CursorShape-enum">Qt::ArrowCursor</db:link> shape.</db:para>
<db:para>Some underlying window implementations will reset the cursor if it leaves a widget even if the mouse is grabbed. If you want to have a cursor set for all widgets, even when outside the window, consider <db:link xlink:href="qguiapplication.xml#setOverrideCursor">QGuiApplication::setOverrideCursor</db:link>().</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qcursor.xml">QCursor</db:link></db:type> <db:emphasis role="bold">cursor</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setCursor</db:emphasis>(<db:emphasis>const QCursor &amp;</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">unsetCursor</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qguiapplication.xml#setOverrideCursor">QGuiApplication::setOverrideCursor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="enabled-prop">
<db:title>enabled : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>enabled</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isEnabled</db:synopsisinfo>
<db:synopsisinfo role="setter">setEnabled</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether the widget is enabled</db:para>
<db:para>In general an enabled widget handles keyboard and mouse events; a disabled widget does not. An exception is made with <db:link xlink:href="qabstractbutton.xml">QAbstractButton</db:link>.</db:para>
<db:para>Some widgets display themselves differently when they are disabled. For example a button might draw its label grayed out. If your widget needs to know when it becomes enabled or disabled, you can use the <db:link xlink:href="qwidget.xml#changeEvent">changeEvent</db:link>() with type <db:link xlink:href="qevent.xml#Type-enum">QEvent::EnabledChange</db:link>.</db:para>
<db:para>Disabling a widget implicitly disables all its children. Enabling respectively enables all child widgets unless they have been explicitly disabled. It it not possible to explicitly enable a child widget which is not a window while its parent widget remains disabled.</db:para>
<db:para>By default, this property is <db:code>true</db:code>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isEnabled</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setEnabled</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#isEnabledTo">isEnabledTo</db:link>()</db:member>
<db:member><db:link xlink:href="qkeyevent.xml">QKeyEvent</db:link></db:member>
<db:member><db:link xlink:href="qmouseevent.xml">QMouseEvent</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#changeEvent">changeEvent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="focus-prop">
<db:title>[read-only] focus : const bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>focus</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">hasFocus</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether this widget (or its focus proxy) has the keyboard input focus</db:para>
<db:para>By default, this property is <db:code>false</db:code>.</db:para>
<db:note>
<db:para>Obtaining the value of this property for a widget is effectively equivalent to checking whether <db:link xlink:href="qapplication.xml#focusWidget">QApplication::focusWidget</db:link>() refers to the widget.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">hasFocus</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setFocus-1">setFocus</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#clearFocus">clearFocus</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>()</db:member>
<db:member><db:link xlink:href="qapplication.xml#focusWidget">QApplication::focusWidget</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="focusPolicy-prop">
<db:title>focusPolicy : Qt::FocusPolicy</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>Qt::FocusPolicy</db:type>
<db:varname>focusPolicy</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">focusPolicy</db:synopsisinfo>
<db:synopsisinfo role="setter">setFocusPolicy</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the way the widget accepts keyboard focus</db:para>
<db:para>The policy is <db:link xlink:href="qt.xml#FocusPolicy-enum">Qt::TabFocus</db:link> if the widget accepts keyboard focus by tabbing, <db:link xlink:href="qt.xml#FocusPolicy-enum">Qt::ClickFocus</db:link> if the widget accepts focus by clicking, <db:link xlink:href="qt.xml#FocusPolicy-enum">Qt::StrongFocus</db:link> if it accepts both, and <db:link xlink:href="qt.xml#FocusPolicy-enum">Qt::NoFocus</db:link> (the default) if it does not accept focus at all.</db:para>
<db:para>You must enable keyboard focus for a widget if it processes keyboard events. This is normally done from the widget's constructor. For instance, the <db:link xlink:href="qlineedit.xml">QLineEdit</db:link> constructor calls setFocusPolicy(<db:link xlink:href="qt.xml#FocusPolicy-enum">Qt::StrongFocus</db:link>).</db:para>
<db:para>If the widget has a focus proxy, then the focus policy will be propagated to it.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qt.xml#FocusPolicy-enum">Qt::FocusPolicy</db:link></db:type> <db:emphasis role="bold">focusPolicy</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setFocusPolicy</db:emphasis>(<db:type><db:link xlink:href="qt.xml#FocusPolicy-enum">Qt::FocusPolicy</db:link></db:type> <db:emphasis>policy</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#focusInEvent">focusInEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusOutEvent">focusOutEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#keyPressEvent">keyPressEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#keyReleaseEvent">keyReleaseEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#enabled-prop">enabled</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="font-prop">
<db:title>font : QFont</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QFont</db:type>
<db:varname>font</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">font</db:synopsisinfo>
<db:synopsisinfo role="setter">setFont</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the font currently set for the widget</db:para>
<db:para>This property describes the widget's requested font. The font is used by the widget's style when rendering standard components, and is available as a means to ensure that custom widgets can maintain consistency with the native platform's look and feel. It's common that different platforms, or different styles, define different fonts for an application.</db:para>
<db:para>When you assign a new font to a widget, the properties from this font are combined with the widget's default font to form the widget's final font. You can call <db:link xlink:href="qwidget.xml#fontInfo">fontInfo</db:link>() to get a copy of the widget's final font. The final font is also used to initialize <db:link xlink:href="qpainter.xml">QPainter</db:link>'s font.</db:para>
<db:para>The default depends on the system environment. <db:link xlink:href="qapplication.xml">QApplication</db:link> maintains a system/theme font which serves as a default for all widgets. There may also be special font defaults for certain types of widgets. You can also define default fonts for widgets yourself by passing a custom font and the name of a widget to <db:link xlink:href="qapplication.xml#setFont">QApplication::setFont</db:link>(). Finally, the font is matched against Qt's font database to find the best match.</db:para>
<db:para><db:link xlink:href="qwidget.xml">QWidget</db:link> propagates explicit font properties from parent to child. If you change a specific property on a font and assign that font to a widget, that property will propagate to all the widget's children, overriding any system defaults for that property. Note that fonts by default don't propagate to windows (see <db:link xlink:href="qwidget.xml#isWindow">isWindow</db:link>()) unless the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_WindowPropagation</db:link> attribute is enabled.</db:para>
<db:para><db:link xlink:href="qwidget.xml">QWidget</db:link>'s font propagation is similar to its palette propagation.</db:para>
<db:para>The current style, which is used to render the content of all standard Qt widgets, is free to choose to use the widget font, or in some cases, to ignore it (partially, or completely). In particular, certain styles like GTK style, Mac style, and Windows Vista style, apply special modifications to the widget font to match the platform's native look and feel. Because of this, assigning properties to a widget's font is not guaranteed to change the appearance of the widget. Instead, you may choose to apply a <db:link xlink:href="stylesheet.xml">styleSheet</db:link>.</db:para>
<db:note>
<db:para>If <db:link xlink:href="stylesheet.xml">Qt Style Sheets</db:link> are used on the same widget as setFont(), style sheets will take precedence if the settings conflict.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>const <db:type><db:link xlink:href="qfont.xml">QFont</db:link></db:type> &amp;<db:emphasis role="bold">font</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setFont</db:emphasis>(<db:emphasis>const QFont &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#fontInfo">fontInfo</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#fontMetrics">fontMetrics</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="frameGeometry-prop">
<db:title>[read-only] frameGeometry : const QRect</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QRect</db:type>
<db:varname>frameGeometry</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">frameGeometry</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>geometry of the widget relative to its parent including any window frame</db:para>
<db:para>See the <db:link xlink:href="application-windows.xml#window-geometry">Window Geometry</db:link> documentation for an overview of geometry issues with windows.</db:para>
<db:para>By default, this property contains a value that depends on the user's platform and screen geometry.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qrect.xml">QRect</db:link></db:type> <db:emphasis role="bold">frameGeometry</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#geometry-prop">geometry</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#x-prop">x</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#y-prop">y</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#pos-prop">pos</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="frameSize-prop">
<db:title>[read-only] frameSize : const QSize</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QSize</db:type>
<db:varname>frameSize</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">frameSize</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the size of the widget including any window frame</db:para>
<db:para>By default, this property contains a value that depends on the user's platform and screen geometry.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsize.xml">QSize</db:link></db:type> <db:emphasis role="bold">frameSize</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="fullScreen-prop">
<db:title>[read-only] fullScreen : const bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>fullScreen</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isFullScreen</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether the widget is shown in full screen mode</db:para>
<db:para>A widget in full screen mode occupies the whole screen area and does not display window decorations, such as a title bar.</db:para>
<db:para>By default, this property is <db:code>false</db:code>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isFullScreen</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowState">windowState</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#minimized-prop">minimized</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#maximized-prop">maximized</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="geometry-prop">
<db:title>geometry : QRect</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QRect</db:type>
<db:varname>geometry</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">geometry</db:synopsisinfo>
<db:synopsisinfo role="setter">setGeometry</db:synopsisinfo>
<db:synopsisinfo role="setter">setGeometry</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the geometry of the widget relative to its parent and excluding the window frame</db:para>
<db:para>When changing the geometry, the widget, if visible, receives a move event (<db:link xlink:href="qwidget.xml#moveEvent">moveEvent</db:link>()) and/or a resize event (<db:link xlink:href="qwidget.xml#resizeEvent">resizeEvent</db:link>()) immediately. If the widget is not currently visible, it is guaranteed to receive appropriate events before it is shown.</db:para>
<db:para>The size component is adjusted if it lies outside the range defined by <db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link>() and <db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link>().</db:para>
<db:warning>
<db:para>Calling setGeometry() inside <db:link xlink:href="qwidget.xml#resizeEvent">resizeEvent</db:link>() or <db:link xlink:href="qwidget.xml#moveEvent">moveEvent</db:link>() can lead to infinite recursion.</db:para>
</db:warning>
<db:para>See the <db:link xlink:href="application-windows.xml#window-geometry">Window Geometry</db:link> documentation for an overview of geometry issues with windows.</db:para>
<db:para>By default, this property contains a value that depends on the user's platform and screen geometry.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>const <db:type><db:link xlink:href="qrect.xml">QRect</db:link></db:type> &amp;<db:emphasis role="bold">geometry</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwidget.xml#setGeometry-1">setGeometry</db:link></db:emphasis>(<db:type>int</db:type> <db:emphasis>x</db:emphasis>, <db:type>int</db:type> <db:emphasis>y</db:emphasis>, <db:type>int</db:type> <db:emphasis>w</db:emphasis>, <db:type>int</db:type> <db:emphasis>h</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setGeometry</db:emphasis>(<db:emphasis>const QRect &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#frameGeometry-prop">frameGeometry</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#rect-prop">rect</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#pos-prop">move</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#size-prop">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#moveEvent">moveEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#resizeEvent">resizeEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="height-prop">
<db:title>[read-only] height : const int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>height</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">height</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the height of the widget excluding any window frame</db:para>
<db:para>See the <db:link xlink:href="application-windows.xml#window-geometry">Window Geometry</db:link> documentation for an overview of geometry issues with windows.</db:para>
<db:para>By default, this property contains a value that depends on the user's platform and <db:link xlink:href="qscreen.xml#geometry-prop">screen geometry</db:link>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">height</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#geometry-prop">geometry</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#width-prop">width</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#size-prop">size</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="inputMethodHints-prop">
<db:title>inputMethodHints : Qt::InputMethodHints</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>Qt::InputMethodHints</db:type>
<db:varname>inputMethodHints</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">inputMethodHints</db:synopsisinfo>
<db:synopsisinfo role="setter">setInputMethodHints</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>What input method specific hints the widget has.</db:para>
<db:para>This is only relevant for input widgets. It is used by the input method to retrieve hints as to how the input method should operate. For example, if the <db:link xlink:href="qt.xml#InputMethodHint-enum">Qt::ImhFormattedNumbersOnly</db:link> flag is set, the input method may change its visual components to reflect that only numbers can be entered.</db:para>
<db:warning>
<db:para>Some widgets require certain flags in order to work as intended. To set a flag, do <db:code>w-&gt;setInputMethodHints(w-&gt;inputMethodHints()|f)</db:code> instead of <db:code>w-&gt;setInputMethodHints(f)</db:code>.</db:para>
</db:warning>
<db:note>
<db:para>The flags are only hints, so the particular input method implementation is free to ignore them. If you want to be sure that a certain type of characters are entered, you should also set a <db:link xlink:href="qvalidator.xml">QValidator</db:link> on the widget.</db:para>
</db:note>
<db:para>The default value is <db:link xlink:href="qt.xml#InputMethodHint-enum">Qt::ImhNone</db:link>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qt.xml#InputMethodHint-enum">Qt::InputMethodHints</db:link></db:type> <db:emphasis role="bold">inputMethodHints</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setInputMethodHints</db:emphasis>(<db:type><db:link xlink:href="qt.xml#InputMethodHint-enum">Qt::InputMethodHints</db:link></db:type> <db:emphasis>hints</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#inputMethodQuery">inputMethodQuery</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isActiveWindow-prop">
<db:title>[read-only] isActiveWindow : const bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>isActiveWindow</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isActiveWindow</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether this widget's window is the active window</db:para>
<db:para>The active window is the window that contains the widget that has keyboard focus (The window may still have focus if it has no widgets or none of its widgets accepts keyboard focus).</db:para>
<db:para>When popup windows are visible, this property is <db:code>true</db:code> for both the active window <db:emphasis>and</db:emphasis> for the popup.</db:para>
<db:para>By default, this property is <db:code>false</db:code>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isActiveWindow</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#activateWindow">activateWindow</db:link>()</db:member>
<db:member><db:link xlink:href="qapplication.xml#activeWindow">QApplication::activeWindow</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="layoutDirection-prop">
<db:title>layoutDirection : Qt::LayoutDirection</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>Qt::LayoutDirection</db:type>
<db:varname>layoutDirection</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">layoutDirection</db:synopsisinfo>
<db:synopsisinfo role="setter">setLayoutDirection</db:synopsisinfo>
<db:synopsisinfo role="resetter">unsetLayoutDirection</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the layout direction for this widget</db:para>
<db:para>By default, this property is set to <db:link xlink:href="qt.xml#LayoutDirection-enum">Qt::LeftToRight</db:link>.</db:para>
<db:para>When the layout direction is set on a widget, it will propagate to the widget's children, but not to a child that is a window and not to a child for which setLayoutDirection() has been explicitly called. Also, child widgets added <db:emphasis>after</db:emphasis> setLayoutDirection() has been called for the parent do not inherit the parent's layout direction.</db:para>
<db:para>This method no longer affects text layout direction since Qt 4.7.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qt.xml#LayoutDirection-enum">Qt::LayoutDirection</db:link></db:type> <db:emphasis role="bold">layoutDirection</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setLayoutDirection</db:emphasis>(<db:type><db:link xlink:href="qt.xml#LayoutDirection-enum">Qt::LayoutDirection</db:link></db:type> <db:emphasis>direction</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">unsetLayoutDirection</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qguiapplication.xml#layoutDirection-prop">QApplication::layoutDirection</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="locale-prop">
<db:title>locale : QLocale</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QLocale</db:type>
<db:varname>locale</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">locale</db:synopsisinfo>
<db:synopsisinfo role="setter">setLocale</db:synopsisinfo>
<db:synopsisinfo role="resetter">unsetLocale</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's locale</db:para>
<db:para>As long as no special locale has been set, this is either the parent's locale or (if this widget is a top level widget), the default locale.</db:para>
<db:para>If the widget displays dates or numbers, these should be formatted using the widget's locale.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qlocale.xml">QLocale</db:link></db:type> <db:emphasis role="bold">locale</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setLocale</db:emphasis>(const <db:type><db:link xlink:href="qlocale.xml">QLocale</db:link></db:type> &amp;<db:emphasis>locale</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">unsetLocale</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlocale.xml">QLocale</db:link></db:member>
<db:member><db:link xlink:href="qlocale.xml#setDefault">QLocale::setDefault</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="maximized-prop">
<db:title>[read-only] maximized : const bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>maximized</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isMaximized</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether this widget is maximized</db:para>
<db:para>This property is only relevant for windows.</db:para>
<db:note>
<db:para>Due to limitations on some window systems, this does not always report the expected results (e.g., if the user on X11 maximizes the window via the window manager, Qt has no way of distinguishing this from any other resize). This is expected to improve as window manager protocols evolve.</db:para>
</db:note>
<db:para>By default, this property is <db:code>false</db:code>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isMaximized</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowState">windowState</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showMaximized">showMaximized</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#visible-prop">visible</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#show">show</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#hide">hide</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showNormal">showNormal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#minimized-prop">minimized</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="maximumHeight-prop">
<db:title>maximumHeight : int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>maximumHeight</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">maximumHeight</db:synopsisinfo>
<db:synopsisinfo role="setter">setMaximumHeight</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's maximum height in pixels</db:para>
<db:para>This property corresponds to the height held by the <db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link> property.</db:para>
<db:para>By default, this property contains a value of 16777215.</db:para>
<db:note>
<db:para>The definition of the <db:code>QWIDGETSIZE_MAX</db:code> macro limits the maximum size of widgets.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">maximumHeight</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setMaximumHeight</db:emphasis>(<db:type>int</db:type> <db:emphasis>maxh</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#maximumWidth-prop">maximumWidth</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="maximumSize-prop">
<db:title>maximumSize : QSize</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QSize</db:type>
<db:varname>maximumSize</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">maximumSize</db:synopsisinfo>
<db:synopsisinfo role="setter">setMaximumSize</db:synopsisinfo>
<db:synopsisinfo role="setter">setMaximumSize</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's maximum size in pixels</db:para>
<db:para>The widget cannot be resized to a larger size than the maximum widget size.</db:para>
<db:para>By default, this property contains a size in which both width and height have values of 16777215.</db:para>
<db:note>
<db:para>The definition of the <db:code>QWIDGETSIZE_MAX</db:code> macro limits the maximum size of widgets.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsize.xml">QSize</db:link></db:type> <db:emphasis role="bold">maximumSize</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setMaximumSize</db:emphasis>(<db:emphasis>const QSize &amp;</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwidget.xml#setMaximumSize-1">setMaximumSize</db:link></db:emphasis>(<db:type>int</db:type> <db:emphasis>maxw</db:emphasis>, <db:type>int</db:type> <db:emphasis>maxh</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#maximumWidth-prop">maximumWidth</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#maximumHeight-prop">maximumHeight</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#sizeIncrement-prop">sizeIncrement</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="maximumWidth-prop">
<db:title>maximumWidth : int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>maximumWidth</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">maximumWidth</db:synopsisinfo>
<db:synopsisinfo role="setter">setMaximumWidth</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's maximum width in pixels</db:para>
<db:para>This property corresponds to the width held by the <db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link> property.</db:para>
<db:para>By default, this property contains a value of 16777215.</db:para>
<db:note>
<db:para>The definition of the <db:code>QWIDGETSIZE_MAX</db:code> macro limits the maximum size of widgets.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">maximumWidth</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setMaximumWidth</db:emphasis>(<db:type>int</db:type> <db:emphasis>maxw</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#maximumHeight-prop">maximumHeight</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="minimized-prop">
<db:title>[read-only] minimized : const bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>minimized</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isMinimized</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether this widget is minimized (iconified)</db:para>
<db:para>This property is only relevant for windows.</db:para>
<db:para>By default, this property is <db:code>false</db:code>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isMinimized</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#showMinimized">showMinimized</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#visible-prop">visible</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#show">show</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#hide">hide</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showNormal">showNormal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#maximized-prop">maximized</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="minimumHeight-prop">
<db:title>minimumHeight : int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>minimumHeight</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">minimumHeight</db:synopsisinfo>
<db:synopsisinfo role="setter">setMinimumHeight</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's minimum height in pixels</db:para>
<db:para>This property corresponds to the height held by the <db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link> property.</db:para>
<db:para>By default, this property has a value of 0.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">minimumHeight</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setMinimumHeight</db:emphasis>(<db:type>int</db:type> <db:emphasis>minh</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumWidth-prop">minimumWidth</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="minimumSize-prop">
<db:title>minimumSize : QSize</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QSize</db:type>
<db:varname>minimumSize</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">minimumSize</db:synopsisinfo>
<db:synopsisinfo role="setter">setMinimumSize</db:synopsisinfo>
<db:synopsisinfo role="setter">setMinimumSize</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's minimum size</db:para>
<db:para>The widget cannot be resized to a smaller size than the minimum widget size. The widget's size is forced to the minimum size if the current size is smaller.</db:para>
<db:para>The minimum size set by this function will override the minimum size defined by <db:link xlink:href="qlayout.xml">QLayout</db:link>. In order to unset the minimum size, use a value of <db:code>QSize(0, 0)</db:code>.</db:para>
<db:para>By default, this property contains a size with zero width and height.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsize.xml">QSize</db:link></db:type> <db:emphasis role="bold">minimumSize</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setMinimumSize</db:emphasis>(<db:emphasis>const QSize &amp;</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwidget.xml#setMinimumSize-1">setMinimumSize</db:link></db:emphasis>(<db:type>int</db:type> <db:emphasis>minw</db:emphasis>, <db:type>int</db:type> <db:emphasis>minh</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#minimumWidth-prop">minimumWidth</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumHeight-prop">minimumHeight</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#sizeIncrement-prop">sizeIncrement</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="minimumSizeHint-prop">
<db:title>[read-only] minimumSizeHint : const QSize</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QSize</db:type>
<db:varname>minimumSizeHint</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">minimumSizeHint</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the recommended minimum size for the widget</db:para>
<db:para>If the value of this property is an invalid size, no minimum size is recommended.</db:para>
<db:para>The default implementation of minimumSizeHint() returns an invalid size if there is no layout for this widget, and returns the layout's minimum size otherwise. Most built-in widgets reimplement minimumSizeHint().</db:para>
<db:para><db:link xlink:href="qlayout.xml">QLayout</db:link> will never resize a widget to a size smaller than the minimum size hint unless <db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link>() is set or the size policy is set to QSizePolicy::Ignore. If <db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link>() is set, the minimum size hint will be ignored.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>virtual <db:type><db:link xlink:href="qsize.xml">QSize</db:link></db:type> <db:emphasis role="bold">minimumSizeHint</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsize.xml#isValid">QSize::isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#size-prop">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumSize-prop">setMinimumSize</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#sizePolicy-prop">sizePolicy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="minimumWidth-prop">
<db:title>minimumWidth : int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>minimumWidth</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">minimumWidth</db:synopsisinfo>
<db:synopsisinfo role="setter">setMinimumWidth</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's minimum width in pixels</db:para>
<db:para>This property corresponds to the width held by the <db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link> property.</db:para>
<db:para>By default, this property has a value of 0.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">minimumWidth</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setMinimumWidth</db:emphasis>(<db:type>int</db:type> <db:emphasis>minw</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumHeight-prop">minimumHeight</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="modal-prop">
<db:title>[read-only] modal : const bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>modal</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isModal</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether the widget is a modal widget</db:para>
<db:para>This property only makes sense for windows. A modal widget prevents widgets in all other windows from getting any input.</db:para>
<db:para>By default, this property is <db:code>false</db:code>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isModal</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#isWindow">isWindow</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#windowModality-prop">windowModality</db:link></db:member>
<db:member><db:link xlink:href="qdialog.xml">QDialog</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseTracking-prop">
<db:title>mouseTracking : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>mouseTracking</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">hasMouseTracking</db:synopsisinfo>
<db:synopsisinfo role="setter">setMouseTracking</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether mouse tracking is enabled for the widget</db:para>
<db:para>If mouse tracking is disabled (the default), the widget only receives mouse move events when at least one mouse button is pressed while the mouse is being moved.</db:para>
<db:para>If mouse tracking is enabled, the widget receives mouse move events even if no buttons are pressed.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">hasMouseTracking</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setMouseTracking</db:emphasis>(<db:type>bool</db:type> <db:emphasis>enable</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mouseMoveEvent">mouseMoveEvent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="normalGeometry-prop">
<db:title>[read-only] normalGeometry : const QRect</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QRect</db:type>
<db:varname>normalGeometry</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">normalGeometry</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the geometry of the widget as it will appear when shown as a normal (not maximized or full screen) top-level widget</db:para>
<db:para>For child widgets this property always holds an empty rectangle.</db:para>
<db:para>By default, this property contains an empty rectangle.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qrect.xml">QRect</db:link></db:type> <db:emphasis role="bold">normalGeometry</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowState">QWidget::windowState</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#geometry-prop">QWidget::geometry</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="palette-prop">
<db:title>palette : QPalette</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QPalette</db:type>
<db:varname>palette</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">palette</db:synopsisinfo>
<db:synopsisinfo role="setter">setPalette</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's palette</db:para>
<db:para>This property describes the widget's palette. The palette is used by the widget's style when rendering standard components, and is available as a means to ensure that custom widgets can maintain consistency with the native platform's look and feel. It's common that different platforms, or different styles, have different palettes.</db:para>
<db:para>When you assign a new palette to a widget, the color roles from this palette are combined with the widget's default palette to form the widget's final palette. The palette entry for the widget's background role is used to fill the widget's background (see <db:link xlink:href="qwidget.xml#autoFillBackground-prop">QWidget::autoFillBackground</db:link>), and the foreground role initializes <db:link xlink:href="qpainter.xml">QPainter</db:link>'s pen.</db:para>
<db:para>The default depends on the system environment. <db:link xlink:href="qapplication.xml">QApplication</db:link> maintains a system/theme palette which serves as a default for all widgets. There may also be special palette defaults for certain types of widgets (e.g., on Windows Vista, all classes that derive from <db:link xlink:href="qmenubar.xml">QMenuBar</db:link> have a special default palette). You can also define default palettes for widgets yourself by passing a custom palette and the name of a widget to <db:link xlink:href="qapplication.xml#setPalette">QApplication::setPalette</db:link>(). Finally, the style always has the option of polishing the palette as it's assigned (see <db:link xlink:href="qstyle.xml#polish">QStyle::polish</db:link>()).</db:para>
<db:para><db:link xlink:href="qwidget.xml">QWidget</db:link> propagates explicit palette roles from parent to child. If you assign a brush or color to a specific role on a palette and assign that palette to a widget, that role will propagate to all the widget's children, overriding any system defaults for that role. Note that palettes by default don't propagate to windows (see <db:link xlink:href="qwidget.xml#isWindow">isWindow</db:link>()) unless the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_WindowPropagation</db:link> attribute is enabled.</db:para>
<db:para><db:link xlink:href="qwidget.xml">QWidget</db:link>'s palette propagation is similar to its font propagation.</db:para>
<db:para>The current style, which is used to render the content of all standard Qt widgets, is free to choose colors and brushes from the widget palette, or in some cases, to ignore the palette (partially, or completely). In particular, certain styles like GTK style, Mac style, and Windows Vista style, depend on third party APIs to render the content of widgets, and these styles typically do not follow the palette. Because of this, assigning roles to a widget's palette is not guaranteed to change the appearance of the widget. Instead, you may choose to apply a <db:link xlink:href="stylesheet.xml">styleSheet</db:link>.</db:para>
<db:warning>
<db:para>Do not use this function in conjunction with <db:link xlink:href="stylesheet.xml">Qt Style Sheets</db:link>. When using style sheets, the palette of a widget can be customized using the &quot;color&quot;, &quot;background-color&quot;, &quot;selection-color&quot;, &quot;selection-background-color&quot; and &quot;alternate-background-color&quot;.</db:para>
</db:warning>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>const <db:type><db:link xlink:href="qpalette.xml">QPalette</db:link></db:type> &amp;<db:emphasis role="bold">palette</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setPalette</db:emphasis>(<db:emphasis>const QPalette &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qguiapplication.xml#palette">QGuiApplication::palette</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#font-prop">QWidget::font</db:link>()</db:member>
<db:member><db:link xlink:href="stylesheet.xml">Qt Style Sheets</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pos-prop">
<db:title>pos : QPoint</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QPoint</db:type>
<db:varname>pos</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">pos</db:synopsisinfo>
<db:synopsisinfo role="setter">move</db:synopsisinfo>
<db:synopsisinfo role="setter">move</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the position of the widget within its parent widget</db:para>
<db:para>If the widget is a window, the position is that of the widget on the desktop, including its frame.</db:para>
<db:para>When changing the position, the widget, if visible, receives a move event (<db:link xlink:href="qwidget.xml#moveEvent">moveEvent</db:link>()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.</db:para>
<db:para>By default, this property contains a position that refers to the origin.</db:para>
<db:warning>
<db:para>Calling move() or <db:link xlink:href="qwidget.xml#geometry-prop">setGeometry</db:link>() inside <db:link xlink:href="qwidget.xml#moveEvent">moveEvent</db:link>() can lead to infinite recursion.</db:para>
</db:warning>
<db:para>See the <db:link xlink:href="application-windows.xml#window-geometry">Window Geometry</db:link> documentation for an overview of geometry issues with windows.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qpoint.xml">QPoint</db:link></db:type> <db:emphasis role="bold">pos</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwidget.xml#move-1">move</db:link></db:emphasis>(<db:type>int</db:type> <db:emphasis>x</db:emphasis>, <db:type>int</db:type> <db:emphasis>y</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">move</db:emphasis>(<db:emphasis>const QPoint &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#frameGeometry-prop">frameGeometry</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#size-prop">size</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#x-prop">x</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#y-prop">y</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rect-prop">
<db:title>[read-only] rect : const QRect</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QRect</db:type>
<db:varname>rect</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">rect</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the internal geometry of the widget excluding any window frame</db:para>
<db:para>The rect property equals <db:link xlink:href="qrect.xml">QRect</db:link>(0, 0, <db:link xlink:href="qwidget.xml#width-prop">width</db:link>(), <db:link xlink:href="qwidget.xml#height-prop">height</db:link>()).</db:para>
<db:para>See the <db:link xlink:href="application-windows.xml#window-geometry">Window Geometry</db:link> documentation for an overview of geometry issues with windows.</db:para>
<db:para>By default, this property contains a value that depends on the user's platform and screen geometry.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qrect.xml">QRect</db:link></db:type> <db:emphasis role="bold">rect</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#size-prop">size</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size-prop">
<db:title>size : QSize</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QSize</db:type>
<db:varname>size</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">size</db:synopsisinfo>
<db:synopsisinfo role="setter">resize</db:synopsisinfo>
<db:synopsisinfo role="setter">resize</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the size of the widget excluding any window frame</db:para>
<db:para>If the widget is visible when it is being resized, it receives a resize event (<db:link xlink:href="qwidget.xml#resizeEvent">resizeEvent</db:link>()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.</db:para>
<db:para>The size is adjusted if it lies outside the range defined by <db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link>() and <db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link>().</db:para>
<db:para>By default, this property contains a value that depends on the user's platform and screen geometry.</db:para>
<db:warning>
<db:para>Calling resize() or <db:link xlink:href="qwidget.xml#geometry-prop">setGeometry</db:link>() inside <db:link xlink:href="qwidget.xml#resizeEvent">resizeEvent</db:link>() can lead to infinite recursion.</db:para>
</db:warning>
<db:note>
<db:para>Setting the size to <db:code>QSize(0, 0)</db:code> will cause the widget to not appear on screen. This also applies to windows.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsize.xml">QSize</db:link></db:type> <db:emphasis role="bold">size</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwidget.xml#resize-1">resize</db:link></db:emphasis>(<db:type>int</db:type> <db:emphasis>w</db:emphasis>, <db:type>int</db:type> <db:emphasis>h</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">resize</db:emphasis>(<db:emphasis>const QSize &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#pos-prop">pos</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#geometry-prop">geometry</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#resizeEvent">resizeEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#adjustSize">adjustSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sizeHint-prop">
<db:title>[read-only] sizeHint : const QSize</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QSize</db:type>
<db:varname>sizeHint</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">sizeHint</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the recommended size for the widget</db:para>
<db:para>If the value of this property is an invalid size, no size is recommended.</db:para>
<db:para>The default implementation of sizeHint() returns an invalid size if there is no layout for this widget, and returns the layout's preferred size otherwise.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>virtual <db:type><db:link xlink:href="qsize.xml">QSize</db:link></db:type> <db:emphasis role="bold">sizeHint</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsize.xml#isValid">QSize::isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumSizeHint-prop">minimumSizeHint</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#sizePolicy-prop">sizePolicy</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumSize-prop">setMinimumSize</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#updateGeometry">updateGeometry</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sizeIncrement-prop">
<db:title>sizeIncrement : QSize</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QSize</db:type>
<db:varname>sizeIncrement</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">sizeIncrement</db:synopsisinfo>
<db:synopsisinfo role="setter">setSizeIncrement</db:synopsisinfo>
<db:synopsisinfo role="setter">setSizeIncrement</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the size increment of the widget</db:para>
<db:para>When the user resizes the window, the size will move in steps of sizeIncrement().<db:link xlink:href="qwidget.xml#width-prop">width</db:link>() pixels horizontally and sizeIncrement.<db:link xlink:href="qwidget.xml#height-prop">height</db:link>() pixels vertically, with <db:link xlink:href="qwidget.xml#baseSize-prop">baseSize</db:link>() as the basis. Preferred widget sizes are for non-negative integers <db:emphasis>i</db:emphasis> and <db:emphasis>j</db:emphasis>:</db:para>
<db:programlisting language="cpp">width = baseSize().width() + i * sizeIncrement().width();
height = baseSize().height() + j * sizeIncrement().height();
</db:programlisting>
<db:para>Note that while you can set the size increment for all widgets, it only affects windows.</db:para>
<db:para>By default, this property contains a size with zero width and height.</db:para>
<db:warning>
<db:para>The size increment has no effect under Windows, and may be disregarded by the window manager on X11.</db:para>
</db:warning>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsize.xml">QSize</db:link></db:type> <db:emphasis role="bold">sizeIncrement</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setSizeIncrement</db:emphasis>(<db:emphasis>const QSize &amp;</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwidget.xml#setSizeIncrement-1">setSizeIncrement</db:link></db:emphasis>(<db:type>int</db:type> <db:emphasis>w</db:emphasis>, <db:type>int</db:type> <db:emphasis>h</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#size-prop">size</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sizePolicy-prop">
<db:title>sizePolicy : QSizePolicy</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QSizePolicy</db:type>
<db:varname>sizePolicy</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">sizePolicy</db:synopsisinfo>
<db:synopsisinfo role="setter">setSizePolicy</db:synopsisinfo>
<db:synopsisinfo role="setter">setSizePolicy</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the default layout behavior of the widget</db:para>
<db:para>If there is a <db:link xlink:href="qlayout.xml">QLayout</db:link> that manages this widget's children, the size policy specified by that layout is used. If there is no such <db:link xlink:href="qlayout.xml">QLayout</db:link>, the result of this function is used.</db:para>
<db:para>The default policy is Preferred/Preferred, which means that the widget can be freely resized, but prefers to be the size <db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>() returns. Button-like widgets set the size policy to specify that they may stretch horizontally, but are fixed vertically. The same applies to lineedit controls (such as <db:link xlink:href="qlineedit.xml">QLineEdit</db:link>, <db:link xlink:href="qspinbox.xml">QSpinBox</db:link> or an editable <db:link xlink:href="qcombobox.xml">QComboBox</db:link>) and other horizontally orientated widgets (such as <db:link xlink:href="qprogressbar.xml">QProgressBar</db:link>). <db:link xlink:href="qtoolbutton.xml">QToolButton</db:link>'s are normally square, so they allow growth in both directions. Widgets that support different directions (such as <db:link xlink:href="qslider.xml">QSlider</db:link>, <db:link xlink:href="qscrollbar.xml">QScrollBar</db:link> or QHeader) specify stretching in the respective direction only. Widgets that can provide scroll bars (usually subclasses of <db:link xlink:href="qscrollarea.xml">QScrollArea</db:link>) tend to specify that they can use additional space, and that they can make do with less than <db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>().</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsizepolicy.xml">QSizePolicy</db:link></db:type> <db:emphasis role="bold">sizePolicy</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setSizePolicy</db:emphasis>(<db:emphasis>QSizePolicy</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwidget.xml#setSizePolicy-1">setSizePolicy</db:link></db:emphasis>(<db:type><db:link xlink:href="qsizepolicy.xml#Policy-enum">QSizePolicy::Policy</db:link></db:type> <db:emphasis>horizontal</db:emphasis>, <db:type><db:link xlink:href="qsizepolicy.xml#Policy-enum">QSizePolicy::Policy</db:link></db:type> <db:emphasis>vertical</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>()</db:member>
<db:member><db:link xlink:href="qlayout.xml">QLayout</db:link></db:member>
<db:member><db:link xlink:href="qsizepolicy.xml">QSizePolicy</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#updateGeometry">updateGeometry</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="statusTip-prop">
<db:title>statusTip : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>statusTip</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">statusTip</db:synopsisinfo>
<db:synopsisinfo role="setter">setStatusTip</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's status tip</db:para>
<db:para>By default, this property contains an empty string.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">statusTip</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setStatusTip</db:emphasis>(<db:emphasis>const QString &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#toolTip-prop">toolTip</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#whatsThis-prop">whatsThis</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="styleSheet-prop">
<db:title>styleSheet : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>styleSheet</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">styleSheet</db:synopsisinfo>
<db:synopsisinfo role="setter">setStyleSheet</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's style sheet</db:para>
<db:para>The style sheet contains a textual description of customizations to the widget's style, as described in the <db:link xlink:href="stylesheet.xml">Qt Style Sheets</db:link> document.</db:para>
<db:para>Since Qt 4.5, Qt style sheets fully supports macOS.</db:para>
<db:warning>
<db:para>Qt style sheets are currently not supported for custom <db:link xlink:href="qstyle.xml">QStyle</db:link> subclasses. We plan to address this in some future release.</db:para>
</db:warning>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">styleSheet</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setStyleSheet</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>styleSheet</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setStyle">setStyle</db:link>()</db:member>
<db:member><db:link xlink:href="qapplication.xml#styleSheet-prop">QApplication::styleSheet</db:link></db:member>
<db:member><db:link xlink:href="stylesheet.xml">Qt Style Sheets</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="tabletTracking-prop">
<db:title>[since 5.9] tabletTracking : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>tabletTracking</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">hasTabletTracking</db:synopsisinfo>
<db:synopsisinfo role="setter">setTabletTracking</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether tablet tracking is enabled for the widget</db:para>
<db:para>If tablet tracking is disabled (the default), the widget only receives tablet move events when the stylus is in contact with the tablet, or at least one stylus button is pressed, while the stylus is being moved.</db:para>
<db:para>If tablet tracking is enabled, the widget receives tablet move events even while hovering in proximity. This is useful for monitoring position as well as the auxiliary properties such as rotation and tilt, and providing feedback in the UI.</db:para>
<db:para>This property was introduced in Qt 5.9.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">hasTabletTracking</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setTabletTracking</db:emphasis>(<db:type>bool</db:type> <db:emphasis>enable</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#tabletEvent">tabletEvent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toolTip-prop">
<db:title>toolTip : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>toolTip</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">toolTip</db:synopsisinfo>
<db:synopsisinfo role="setter">setToolTip</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's tooltip</db:para>
<db:para>Note that by default tooltips are only shown for widgets that are children of the active window. You can change this behavior by setting the attribute <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_AlwaysShowToolTips</db:link> on the <db:emphasis>window</db:emphasis>, not on the widget with the tooltip.</db:para>
<db:para>If you want to control a tooltip's behavior, you can intercept the <db:link xlink:href="qwidget.xml#event">event</db:link>() function and catch the <db:link xlink:href="qevent.xml#Type-enum">QEvent::ToolTip</db:link> event (e.g., if you want to customize the area for which the tooltip should be shown).</db:para>
<db:para>By default, this property contains an empty string.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">toolTip</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setToolTip</db:emphasis>(<db:emphasis>const QString &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtooltip.xml">QToolTip</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#statusTip-prop">statusTip</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#whatsThis-prop">whatsThis</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toolTipDuration-prop">
<db:title>[since 5.2] toolTipDuration : int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>toolTipDuration</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">toolTipDuration</db:synopsisinfo>
<db:synopsisinfo role="setter">setToolTipDuration</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's tooltip duration</db:para>
<db:para>Specifies how long time the tooltip will be displayed, in milliseconds. If the value is -1 (default) the duration is calculated depending on the length of the tooltip.</db:para>
<db:para>This property was introduced in Qt 5.2.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">toolTipDuration</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setToolTipDuration</db:emphasis>(<db:type>int</db:type> <db:emphasis>msec</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#toolTip-prop">toolTip</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="updatesEnabled-prop">
<db:title>updatesEnabled : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>updatesEnabled</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">updatesEnabled</db:synopsisinfo>
<db:synopsisinfo role="setter">setUpdatesEnabled</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether updates are enabled</db:para>
<db:para>An updates enabled widget receives paint events and has a system background; a disabled widget does not. This also implies that calling <db:link xlink:href="qwidget.xml#update">update</db:link>() and <db:link xlink:href="qwidget.xml#repaint">repaint</db:link>() has no effect if updates are disabled.</db:para>
<db:para>By default, this property is <db:code>true</db:code>.</db:para>
<db:para>setUpdatesEnabled() is normally used to disable updates for a short period of time, for instance to avoid screen flicker during large changes. In Qt, widgets normally do not generate screen flicker, but on X11 the server might erase regions on the screen when widgets get hidden before they can be replaced by other widgets. Disabling updates solves this.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">setUpdatesEnabled(false);
bigVisualChanges();
setUpdatesEnabled(true);
</db:programlisting>
<db:para>Disabling a widget implicitly disables all its children. Enabling a widget enables all child widgets <db:emphasis>except</db:emphasis> top-level widgets or those that have been explicitly disabled. Re-enabling updates implicitly calls <db:link xlink:href="qwidget.xml#update">update</db:link>() on the widget.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">updatesEnabled</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setUpdatesEnabled</db:emphasis>(<db:type>bool</db:type> <db:emphasis>enable</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="visible-prop">
<db:title>visible : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>visible</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isVisible</db:synopsisinfo>
<db:synopsisinfo role="setter">setVisible</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether the widget is visible</db:para>
<db:para>Calling setVisible(true) or <db:link xlink:href="qwidget.xml#show">show</db:link>() sets the widget to visible status if all its parent widgets up to the window are visible. If an ancestor is not visible, the widget won't become visible until all its ancestors are shown. If its size or position has changed, Qt guarantees that a widget gets move and resize events just before it is shown. If the widget has not been resized yet, Qt will adjust the widget's size to a useful default using <db:link xlink:href="qwidget.xml#adjustSize">adjustSize</db:link>().</db:para>
<db:para>Calling setVisible(false) or <db:link xlink:href="qwidget.xml#hide">hide</db:link>() hides a widget explicitly. An explicitly hidden widget will never become visible, even if all its ancestors become visible, unless you show it.</db:para>
<db:para>A widget receives show and hide events when its visibility status changes. Between a hide and a show event, there is no need to waste CPU cycles preparing or displaying information to the user. A video application, for example, might simply stop generating new frames.</db:para>
<db:para>A widget that happens to be obscured by other windows on the screen is considered to be visible. The same applies to iconified windows and windows that exist on another virtual desktop (on platforms that support this concept). A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g. a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again.</db:para>
<db:para>You almost never have to reimplement the setVisible() function. If you need to change some settings before a widget is shown, use <db:link xlink:href="qwidget.xml#showEvent">showEvent</db:link>() instead. If you need to do some delayed initialization use the Polish event delivered to the <db:link xlink:href="qwidget.xml#event">event</db:link>() function.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isVisible</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para>virtual <db:type>void</db:type> <db:emphasis role="bold">setVisible</db:emphasis>(<db:type>bool</db:type> <db:emphasis>visible</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#show">show</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#hide">hide</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#isHidden">isHidden</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#isVisibleTo">isVisibleTo</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#minimized-prop">isMinimized</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showEvent">showEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#hideEvent">hideEvent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="whatsThis-prop">
<db:title>whatsThis : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>whatsThis</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">whatsThis</db:synopsisinfo>
<db:synopsisinfo role="setter">setWhatsThis</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's What's This help text.</db:para>
<db:para>By default, this property contains an empty string.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">whatsThis</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setWhatsThis</db:emphasis>(<db:emphasis>const QString &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwhatsthis.xml">QWhatsThis</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#toolTip-prop">QWidget::toolTip</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#statusTip-prop">QWidget::statusTip</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="width-prop">
<db:title>[read-only] width : const int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>width</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">width</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the width of the widget excluding any window frame</db:para>
<db:para>See the <db:link xlink:href="application-windows.xml#window-geometry">Window Geometry</db:link> documentation for an overview of geometry issues with windows.</db:para>
<db:note>
<db:para>Do not use this function to find the width of a screen on a multi-screen desktop. See <db:link xlink:href="qscreen.xml">QScreen</db:link> for details.</db:para>
</db:note>
<db:para>By default, this property contains a value that depends on the user's platform and screen geometry.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">width</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#geometry-prop">geometry</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#height-prop">height</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#size-prop">size</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="windowFilePath-prop">
<db:title>windowFilePath : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>windowFilePath</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">windowFilePath</db:synopsisinfo>
<db:synopsisinfo role="setter">setWindowFilePath</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the file path associated with a widget</db:para>
<db:para>This property only makes sense for windows. It associates a file path with a window. If you set the file path, but have not set the window title, Qt sets the window title to the file name of the specified path, obtained using <db:link xlink:href="qfileinfo.xml#fileName">QFileInfo::fileName</db:link>().</db:para>
<db:para>If the window title is set at any point, then the window title takes precedence and will be shown instead of the file path string.</db:para>
<db:para>Additionally, on macOS, this has an added benefit that it sets the <db:link xlink:href="http://developer.apple.com/documentation/UserExperience/Conceptual/OSXHIGuidelines/XHIGWindows/chapter_17_section_3.html">proxy icon</db:link> for the window, assuming that the file path exists.</db:para>
<db:para>If no file path is set, this property contains an empty string.</db:para>
<db:para>By default, this property contains an empty string.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">windowFilePath</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setWindowFilePath</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>filePath</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowTitle-prop">windowTitle</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#windowIcon-prop">windowIcon</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="windowFlags-prop">
<db:title>windowFlags : Qt::WindowFlags</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>Qt::WindowFlags</db:type>
<db:varname>windowFlags</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">windowFlags</db:synopsisinfo>
<db:synopsisinfo role="setter">setWindowFlags</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Window flags are a combination of a type (e.g. <db:link xlink:href="qt.xml#WindowType-enum">Qt::Dialog</db:link>) and zero or more hints to the window system (e.g. <db:link xlink:href="qt.xml#WindowType-enum">Qt::FramelessWindowHint</db:link>).</db:para>
<db:para>If the widget had type <db:link xlink:href="qt.xml#WindowType-enum">Qt::Widget</db:link> or <db:link xlink:href="qt.xml#WindowType-enum">Qt::SubWindow</db:link> and becomes a window (<db:link xlink:href="qt.xml#WindowType-enum">Qt::Window</db:link>, <db:link xlink:href="qt.xml#WindowType-enum">Qt::Dialog</db:link>, etc.), it is put at position (0, 0) on the desktop. If the widget is a window and becomes a <db:link xlink:href="qt.xml#WindowType-enum">Qt::Widget</db:link> or <db:link xlink:href="qt.xml#WindowType-enum">Qt::SubWindow</db:link>, it is put at position (0, 0) relative to its parent widget.</db:para>
<db:note>
<db:para>This function calls <db:link xlink:href="qwidget.xml#setParent">setParent</db:link>() when changing the flags for a window, causing the widget to be hidden. You must call <db:link xlink:href="qwidget.xml#show">show</db:link>() to make the widget visible again..</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qt.xml#WindowType-enum">Qt::WindowFlags</db:link></db:type> <db:emphasis role="bold">windowFlags</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setWindowFlags</db:emphasis>(<db:type><db:link xlink:href="qt.xml#WindowType-enum">Qt::WindowFlags</db:link></db:type> <db:emphasis>type</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowType">windowType</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#setWindowFlag">setWindowFlag</db:link>()</db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-windowflags-example.xml">Window Flags Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="windowIcon-prop">
<db:title>windowIcon : QIcon</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QIcon</db:type>
<db:varname>windowIcon</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">windowIcon</db:synopsisinfo>
<db:synopsisinfo role="setter">setWindowIcon</db:synopsisinfo>
<db:synopsisinfo role="notifier">windowIconChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the widget's icon</db:para>
<db:para>This property only makes sense for windows. If no icon has been set, windowIcon() returns the application icon (<db:link xlink:href="qguiapplication.xml#windowIcon-prop">QApplication::windowIcon</db:link>()).</db:para>
<db:note>
<db:para>On macOS, window icons represent the active document, and will not be displayed unless a file path has also been set using <db:link xlink:href="qwidget.xml#windowFilePath-prop">setWindowFilePath</db:link>.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qicon.xml">QIcon</db:link></db:type> <db:emphasis role="bold">windowIcon</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setWindowIcon</db:emphasis>(const <db:type><db:link xlink:href="qicon.xml">QIcon</db:link></db:type> &amp;<db:emphasis>icon</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwidget.xml#windowIconChanged">windowIconChanged</db:link></db:emphasis>(const <db:type><db:link xlink:href="qicon.xml">QIcon</db:link></db:type> &amp;<db:emphasis>icon</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowTitle-prop">windowTitle</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#windowFilePath-prop">setWindowFilePath</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="windowModality-prop">
<db:title>windowModality : Qt::WindowModality</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>Qt::WindowModality</db:type>
<db:varname>windowModality</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">windowModality</db:synopsisinfo>
<db:synopsisinfo role="setter">setWindowModality</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds which windows are blocked by the modal widget</db:para>
<db:para>This property only makes sense for windows. A modal widget prevents widgets in other windows from getting input. The value of this property controls which windows are blocked when the widget is visible. Changing this property while the window is visible has no effect; you must <db:link xlink:href="qwidget.xml#hide">hide</db:link>() the widget first, then <db:link xlink:href="qwidget.xml#show">show</db:link>() it again.</db:para>
<db:para>By default, this property is <db:link xlink:href="qt.xml#WindowModality-enum">Qt::NonModal</db:link>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qt.xml#WindowModality-enum">Qt::WindowModality</db:link></db:type> <db:emphasis role="bold">windowModality</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setWindowModality</db:emphasis>(<db:type><db:link xlink:href="qt.xml#WindowModality-enum">Qt::WindowModality</db:link></db:type> <db:emphasis>windowModality</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#isWindow">isWindow</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#modal-prop">QWidget::modal</db:link></db:member>
<db:member><db:link xlink:href="qdialog.xml">QDialog</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="windowModified-prop">
<db:title>windowModified : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>windowModified</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isWindowModified</db:synopsisinfo>
<db:synopsisinfo role="setter">setWindowModified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether the document shown in the window has unsaved changes</db:para>
<db:para>A modified window is a window whose content has changed but has not been saved to disk. This flag will have different effects varied by the platform. On macOS the close button will have a modified look; on other platforms, the window title will have an '*' (asterisk).</db:para>
<db:para>The window title must contain a &quot;[*]&quot; placeholder, which indicates where the '*' should appear. Normally, it should appear right after the file name (e.g., &quot;document1.txt[*] - Text Editor&quot;). If the window isn't modified, the placeholder is simply removed.</db:para>
<db:para>Note that if a widget is set as modified, all its ancestors will also be set as modified. However, if you call <db:code>setWindowModified(false)</db:code> on a widget, this will not propagate to its parent because other children of the parent might have been modified.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isWindowModified</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setWindowModified</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowTitle-prop">windowTitle</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-mainwindows-application-example.xml">Qt Widgets - Application Example</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-mainwindows-sdi-example.xml">SDI Example</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-mainwindows-mdi-example.xml">MDI Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="windowOpacity-prop">
<db:title>windowOpacity : double</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>double</db:type>
<db:varname>windowOpacity</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">windowOpacity</db:synopsisinfo>
<db:synopsisinfo role="setter">setWindowOpacity</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the level of opacity for the window.</db:para>
<db:para>The valid range of opacity is from 1.0 (completely opaque) to 0.0 (completely transparent).</db:para>
<db:para>By default the value of this property is 1.0.</db:para>
<db:para>This feature is available on Embedded Linux, macOS, Windows, and X11 platforms that support the Composite extension.</db:para>
<db:note>
<db:para>On X11 you need to have a composite manager running, and the X11 specific _NET_WM_WINDOW_OPACITY atom needs to be supported by the window manager you are using.</db:para>
</db:note>
<db:warning>
<db:para>Changing this property from opaque to transparent might issue a paint event that needs to be processed before the window is displayed correctly. This affects mainly the use of <db:link xlink:href="qscreen.xml#grabWindow">QScreen::grabWindow</db:link>(). Also note that semi-transparent windows update and resize significantly slower than opaque windows.</db:para>
</db:warning>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qtglobal.xml#qreal-typedef">qreal</db:link></db:type> <db:emphasis role="bold">windowOpacity</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setWindowOpacity</db:emphasis>(<db:type><db:link xlink:href="qtglobal.xml#qreal-typedef">qreal</db:link></db:type> <db:emphasis>level</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setMask">setMask</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="windowTitle-prop">
<db:title>windowTitle : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>windowTitle</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">windowTitle</db:synopsisinfo>
<db:synopsisinfo role="setter">setWindowTitle</db:synopsisinfo>
<db:synopsisinfo role="notifier">windowTitleChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the window title (caption)</db:para>
<db:para>This property only makes sense for top-level widgets, such as windows and dialogs. If no caption has been set, the title is based of the <db:link xlink:href="qwidget.xml#windowFilePath-prop">windowFilePath</db:link>. If neither of these is set, then the title is an empty string.</db:para>
<db:para>If you use the <db:link xlink:href="qwidget.xml#windowModified-prop">windowModified</db:link> mechanism, the window title must contain a &quot;[*]&quot; placeholder, which indicates where the '*' should appear. Normally, it should appear right after the file name (e.g., &quot;document1.txt[*] - Text Editor&quot;). If the <db:link xlink:href="qwidget.xml#windowModified-prop">windowModified</db:link> property is <db:code>false</db:code> (the default), the placeholder is simply removed.</db:para>
<db:para>On some desktop platforms (including Windows and Unix), the application name (from <db:link xlink:href="qguiapplication.xml#applicationDisplayName-prop">QGuiApplication::applicationDisplayName</db:link>) is added at the end of the window title, if set. This is done by the QPA plugin, so it is shown to the user, but isn't part of the windowTitle string.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">windowTitle</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setWindowTitle</db:emphasis>(<db:emphasis>const QString &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwidget.xml#windowTitleChanged">windowTitleChanged</db:link></db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>title</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowIcon-prop">windowIcon</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#windowModified-prop">windowModified</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#windowFilePath-prop">windowFilePath</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="x-prop">
<db:title>[read-only] x : const int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>x</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">x</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the x coordinate of the widget relative to its parent including any window frame</db:para>
<db:para>See the <db:link xlink:href="application-windows.xml#window-geometry">Window Geometry</db:link> documentation for an overview of geometry issues with windows.</db:para>
<db:para>By default, this property has a value of 0.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">x</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#frameGeometry-prop">frameGeometry</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#y-prop">y</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#pos-prop">pos</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="y-prop">
<db:title>[read-only] y : const int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>y</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">y</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the y coordinate of the widget relative to its parent and including any window frame</db:para>
<db:para>See the <db:link xlink:href="application-windows.xml#window-geometry">Window Geometry</db:link> documentation for an overview of geometry issues with windows.</db:para>
<db:para>By default, this property has a value of 0.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">y</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#frameGeometry-prop">frameGeometry</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#x-prop">x</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#pos-prop">pos</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QWidget">
<db:title>[explicit] QWidget::QWidget(QWidget *<db:emphasis>parent</db:emphasis> = nullptr, Qt::WindowFlags <db:emphasis>f</db:emphasis> = Qt::WindowFlags())</db:title>
<db:constructorsynopsis>
<db:methodname>QWidget</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>Qt::WindowFlags</db:type>
<db:parameter>f</db:parameter>
<db:initializer>Qt::WindowFlags()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget(QWidget *parent, Qt::WindowFlags f)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a widget which is a child of <db:code role="parameter">parent</db:code>, with widget flags set to <db:code role="parameter">f</db:code>.</db:para>
<db:para>If <db:code role="parameter">parent</db:code> is <db:code>nullptr</db:code>, the new widget becomes a window. If <db:code role="parameter">parent</db:code> is another widget, this widget becomes a child window inside <db:code role="parameter">parent</db:code>. The new widget is deleted when its <db:code role="parameter">parent</db:code> is deleted.</db:para>
<db:para>The widget flags argument, <db:code role="parameter">f</db:code>, is normally 0, but it can be set to customize the frame of a window (i.e. <db:code role="parameter">parent</db:code> must be <db:code>nullptr</db:code>). To customize the frame, use a value composed from the bitwise OR of any of the <db:link xlink:href="qt.xml#WindowType-enum">window flags</db:link>.</db:para>
<db:para>If you add a child widget to an already visible widget you must explicitly show the child to make it visible.</db:para>
<db:para>Note that the X11 version of Qt may not be able to deliver all combinations of style flags on all systems. This is because on X11, Qt can only ask the window manager, and the window manager can override the application's settings. On Windows, Qt can set whatever flags you want.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowFlags-prop">windowFlags</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QWidget">
<db:title>[virtual] QWidget::~QWidget()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QWidget</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QWidget()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the widget.</db:para>
<db:para>All this widget's children are deleted first. The application exits if this widget is the main widget.</db:para>
</db:section>
<db:section xml:id="actionEvent">
<db:title>[virtual protected] void QWidget::actionEvent(QActionEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>actionEvent</db:methodname>
<db:methodparam>
<db:type>QActionEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void actionEvent(QActionEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler is called with the given <db:code role="parameter">event</db:code> whenever the widget's actions are changed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#addAction">addAction</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#insertAction">insertAction</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#removeAction">removeAction</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#actions">actions</db:link>()</db:member>
<db:member><db:link xlink:href="qactionevent.xml">QActionEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="actions">
<db:title>QList&lt;QAction *&gt; QWidget::actions() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QAction *&gt;</db:type>
<db:methodname>actions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QAction *&gt; actions() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the (possibly empty) list of this widget's actions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#contextMenuPolicy-prop">contextMenuPolicy</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#insertAction">insertAction</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#removeAction">removeAction</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="activateWindow">
<db:title>void QWidget::activateWindow()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>activateWindow</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void activateWindow()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the top-level widget containing this widget to be the active window.</db:para>
<db:para>An active window is a visible top-level window that has the keyboard input focus.</db:para>
<db:para>This function performs the same operation as clicking the mouse on the title bar of a top-level window. On X11, the result depends on the Window Manager. If you want to ensure that the window is stacked on top as well you should also call <db:link xlink:href="qwidget.xml#raise">raise</db:link>(). Note that the window must be visible, otherwise activateWindow() has no effect.</db:para>
<db:para>On Windows, if you are calling this when the application is not currently the active one then it will not make it the active window. It will change the color of the taskbar entry to indicate that the window has changed in some way. This is because Microsoft does not allow an application to interrupt what the user is currently doing in another application.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#isActiveWindow-prop">isActiveWindow</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#window">window</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#show">show</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addAction">
<db:title>void QWidget::addAction(QAction *<db:emphasis>action</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addAction</db:methodname>
<db:methodparam>
<db:type>QAction *</db:type>
<db:parameter>action</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addAction(QAction *action)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends the action <db:code role="parameter">action</db:code> to this widget's list of actions.</db:para>
<db:para>All QWidgets have a list of <db:link xlink:href="qaction.xml">QAction</db:link>s, however they can be represented graphically in many different ways. The default use of the <db:link xlink:href="qaction.xml">QAction</db:link> list (as returned by <db:link xlink:href="qwidget.xml#actions">actions</db:link>()) is to create a context <db:link xlink:href="qmenu.xml">QMenu</db:link>.</db:para>
<db:para>A <db:link xlink:href="qwidget.xml">QWidget</db:link> should only have one of each action and adding an action it already has will not cause the same action to be in the widget twice.</db:para>
<db:para>The ownership of <db:code role="parameter">action</db:code> is not transferred to this <db:link xlink:href="qwidget.xml">QWidget</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#removeAction">removeAction</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#insertAction">insertAction</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#actions">actions</db:link>()</db:member>
<db:member><db:link xlink:href="qmenu.xml">QMenu</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addActions">
<db:title>void QWidget::addActions(const QList&lt;QAction *&gt; &amp;<db:emphasis>actions</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addActions</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QAction *&gt; &amp;</db:type>
<db:parameter>actions</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addActions(const QList&lt;QAction *&gt; &amp;actions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends the actions <db:code role="parameter">actions</db:code> to this widget's list of actions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#removeAction">removeAction</db:link>()</db:member>
<db:member><db:link xlink:href="qmenu.xml">QMenu</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#addAction">addAction</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="adjustSize">
<db:title>void QWidget::adjustSize()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>adjustSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void adjustSize()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adjusts the size of the widget to fit its contents.</db:para>
<db:para>This function uses <db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>() if it is valid, i.e., the size hint's width and height are &gt;= 0. Otherwise, it sets the size to the children rectangle that covers all child widgets (the union of all child widget rectangles).</db:para>
<db:para>For windows, the screen size is also taken into account. If the <db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>() is less than (200, 100) and the size policy is <db:link xlink:href="qsizepolicy.xml#Policy-enum">expanding</db:link>, the window will be at least (200, 100). The maximum size of a window is 2/3 of the screen's width and height.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#childrenRect-prop">childrenRect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="backgroundRole">
<db:title>QPalette::ColorRole QWidget::backgroundRole() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPalette::ColorRole</db:type>
<db:methodname>backgroundRole</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPalette::ColorRole backgroundRole() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the background role of the widget.</db:para>
<db:para>The background role defines the brush from the widget's <db:link xlink:href="qwidget.xml#palette-prop">palette</db:link> that is used to render the background.</db:para>
<db:para>If no explicit background role is set, the widget inherts its parent widget's background role.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setBackgroundRole">setBackgroundRole</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#foregroundRole">foregroundRole</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="backingStore">
<db:title>[since 5.0] QBackingStore *QWidget::backingStore() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QBackingStore *</db:type>
<db:methodname>backingStore</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QBackingStore * backingStore() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qbackingstore.xml">QBackingStore</db:link> this widget will be drawn into.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="changeEvent">
<db:title>[virtual protected] void QWidget::changeEvent(QEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>changeEvent</db:methodname>
<db:methodparam>
<db:type>QEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void changeEvent(QEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented to handle state changes.</db:para>
<db:para>The state being changed in this event can be retrieved through the <db:code role="parameter">event</db:code> supplied.</db:para>
<db:para>Change events include: <db:link xlink:href="qevent.xml#Type-enum">QEvent::ToolBarChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::ActivationChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::EnabledChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::FontChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::StyleChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::PaletteChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::WindowTitleChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::IconTextChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::ModifiedChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::MouseTrackingChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::ParentChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::WindowStateChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::LanguageChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::LocaleChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::LayoutDirectionChange</db:link>, <db:link xlink:href="qevent.xml#Type-enum">QEvent::ReadOnlyChange</db:link>.</db:para>
</db:section>
<db:section xml:id="childAt">
<db:title>QWidget *QWidget::childAt(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>childAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * childAt(int x, int y) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the visible child widget at the position (<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>) in the widget's coordinate system. If there is no visible child widget at the specified position, the function returns <db:code>nullptr</db:code>.</db:para>
</db:section>
<db:section xml:id="childAt-1">
<db:title>QWidget *QWidget::childAt(const QPoint &amp;<db:emphasis>p</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>childAt</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>p</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * childAt(const QPoint &amp;p) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the visible child widget at point <db:code role="parameter">p</db:code> in the widget's own coordinate system.</db:para>
</db:section>
<db:section xml:id="clearFocus">
<db:title>void QWidget::clearFocus()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clearFocus</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clearFocus()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Takes keyboard input focus from the widget.</db:para>
<db:para>If the widget has active focus, a <db:link xlink:href="qwidget.xml#focusOutEvent">focus out event</db:link> is sent to this widget to tell it that it has lost the focus.</db:para>
<db:para>This widget must enable focus setting in order to get the keyboard input focus, i.e. it must call <db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#focus-prop">hasFocus</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#setFocus-1">setFocus</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusInEvent">focusInEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusOutEvent">focusOutEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>()</db:member>
<db:member><db:link xlink:href="qapplication.xml#focusWidget">QApplication::focusWidget</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clearMask">
<db:title>void QWidget::clearMask()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clearMask</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clearMask()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes any mask set by <db:link xlink:href="qwidget.xml#setMask">setMask</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setMask">setMask</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="close">
<db:title>bool QWidget::close()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>close</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool close()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Closes this widget. Returns <db:code>true</db:code> if the widget was closed; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>First it sends the widget a <db:link xlink:href="qcloseevent.xml">QCloseEvent</db:link>. The widget is <db:link xlink:href="qwidget.xml#hide">hidden</db:link> if it <db:link xlink:href="qevent.xml#accept">accepts</db:link> the close event. If it <db:link xlink:href="qevent.xml#ignore">ignores</db:link> the event, nothing happens. The default implementation of <db:link xlink:href="qwidget.xml#closeEvent">QWidget::closeEvent</db:link>() accepts the close event.</db:para>
<db:para>If the widget has the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_DeleteOnClose</db:link> flag, the widget is also deleted. A close events is delivered to the widget no matter if the widget is visible or not.</db:para>
<db:para>The <db:link xlink:href="qguiapplication.xml#lastWindowClosed">QApplication::lastWindowClosed</db:link>() signal is emitted when the last visible primary window (i.e. window with no parent) with the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_QuitOnClose</db:link> attribute set is closed. By default this attribute is set for all widgets except transient windows such as splash screens, tool windows, and popup menus.</db:para>
</db:section>
<db:section xml:id="closeEvent">
<db:title>[virtual protected] void QWidget::closeEvent(QCloseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>closeEvent</db:methodname>
<db:methodparam>
<db:type>QCloseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void closeEvent(QCloseEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler is called with the given <db:code role="parameter">event</db:code> when Qt receives a window close request for a top-level widget from the window system.</db:para>
<db:para>By default, the event is accepted and the widget is closed. You can reimplement this function to change the way the widget responds to window close requests. For example, you can prevent the window from closing by calling <db:link xlink:href="qevent.xml#ignore">ignore</db:link>() on all events.</db:para>
<db:para>Main window applications typically use reimplementations of this function to check whether the user's work has been saved and ask for permission before closing. For example, the <db:link xlink:href="qtwidgets-mainwindows-application-example.xml">Qt Widgets - Application Example</db:link> uses a helper function to determine whether or not to close the window:</db:para>
<db:programlisting language="cpp">void MainWindow::closeEvent(QCloseEvent *event)
{
    if (maybeSave()) {
        writeSettings();
        event-&amp;gt;accept();
    } else {
        event-&amp;gt;ignore();
    }
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#hide">hide</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#close">close</db:link>()</db:member>
<db:member><db:link xlink:href="qcloseevent.xml">QCloseEvent</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-mainwindows-application-example.xml">Qt Widgets - Application Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contentsMargins">
<db:title>QMargins QWidget::contentsMargins() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMargins</db:type>
<db:methodname>contentsMargins</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMargins contentsMargins() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The contentsMargins function returns the widget's contents margins.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setContentsMargins">setContentsMargins</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#contentsRect">contentsRect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contentsRect">
<db:title>QRect QWidget::contentsRect() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRect</db:type>
<db:methodname>contentsRect</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRect contentsRect() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the area inside the widget's margins.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setContentsMargins">setContentsMargins</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#contentsMargins">contentsMargins</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contextMenuEvent">
<db:title>[virtual protected] void QWidget::contextMenuEvent(QContextMenuEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>contextMenuEvent</db:methodname>
<db:methodparam>
<db:type>QContextMenuEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void contextMenuEvent(QContextMenuEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler, for event <db:code role="parameter">event</db:code>, can be reimplemented in a subclass to receive widget context menu events.</db:para>
<db:para>The handler is called when the widget's <db:link xlink:href="qwidget.xml#contextMenuPolicy-prop">contextMenuPolicy</db:link> is <db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::DefaultContextMenu</db:link>.</db:para>
<db:para>The default implementation ignores the context event. See the <db:link xlink:href="qcontextmenuevent.xml">QContextMenuEvent</db:link> documentation for more details.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qcontextmenuevent.xml">QContextMenuEvent</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#customContextMenuRequested">customContextMenuRequested</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="create">
<db:title>[protected] void QWidget::create(WId <db:emphasis>window</db:emphasis> = 0, bool <db:emphasis>initializeWindow</db:emphasis> = true, bool <db:emphasis>destroyOldWindow</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>create</db:methodname>
<db:methodparam>
<db:type>WId</db:type>
<db:parameter>window</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>initializeWindow</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>destroyOldWindow</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void create(WId window, bool initializeWindow, bool destroyOldWindow)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a new widget window.</db:para>
<db:para>The parameters <db:code role="parameter">window</db:code>, <db:code role="parameter">initializeWindow</db:code>, and <db:code role="parameter">destroyOldWindow</db:code> are ignored in Qt 5. Please use <db:link xlink:href="qwindow.xml#fromWinId">QWindow::fromWinId</db:link>() to create a <db:link xlink:href="qwindow.xml">QWindow</db:link> wrapping a foreign window and pass it to <db:link xlink:href="qwidget.xml#createWindowContainer">QWidget::createWindowContainer</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#createWindowContainer">createWindowContainer</db:link>()</db:member>
<db:member><db:link xlink:href="qwindow.xml#fromWinId">QWindow::fromWinId</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createWindowContainer">
<db:title>[static] QWidget *QWidget::createWindowContainer(QWindow *<db:emphasis>window</db:emphasis>, QWidget *<db:emphasis>parent</db:emphasis> = nullptr, Qt::WindowFlags <db:emphasis>flags</db:emphasis> = Qt::WindowFlags())</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>createWindowContainer</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>Qt::WindowFlags</db:type>
<db:parameter>flags</db:parameter>
<db:initializer>Qt::WindowFlags()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * createWindowContainer(QWindow *window, QWidget *parent, Qt::WindowFlags flags)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a <db:link xlink:href="qwidget.xml">QWidget</db:link> that makes it possible to embed <db:code role="parameter">window</db:code> into a <db:link xlink:href="qwidget.xml">QWidget</db:link>-based application.</db:para>
<db:para>The window container is created as a child of <db:code role="parameter">parent</db:code> and with window flags <db:code role="parameter">flags</db:code>.</db:para>
<db:para>Once the window has been embedded into the container, the container will control the window's geometry and visibility. Explicit calls to <db:link xlink:href="qwindow.xml#setGeometry">QWindow::setGeometry</db:link>(), <db:link xlink:href="qwindow.xml#show">QWindow::show</db:link>() or <db:link xlink:href="qwindow.xml#hide">QWindow::hide</db:link>() on an embedded window is not recommended.</db:para>
<db:para>The container takes over ownership of <db:code role="parameter">window</db:code>. The window can be removed from the window container with a call to <db:link xlink:href="qwindow.xml#setParent">QWindow::setParent</db:link>().</db:para>
<db:para>The window container is attached as a native child window to the toplevel window it is a child of. When a window container is used as a child of a <db:link xlink:href="qabstractscrollarea.xml">QAbstractScrollArea</db:link> or <db:link xlink:href="qmdiarea.xml">QMdiArea</db:link>, it will create a <db:link xlink:href="qwidget.xml#native-widgets-vs-alien-widgets">native window</db:link> for every widget in its parent chain to allow for proper stacking and clipping in this use case. Creating a native window for the window container also allows for proper stacking and clipping. This must be done before showing the window container. Applications with many native child windows may suffer from performance issues.</db:para>
<db:para>The window container has a number of known limitations:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Stacking order; The embedded window will stack on top of the widget hierarchy as an opaque box. The stacking order of multiple overlapping window container instances is undefined.</db:para>
</db:listitem>
<db:listitem>
<db:para>Rendering Integration; The window container does not interoperate with <db:link xlink:href="qgraphicsproxywidget.xml">QGraphicsProxyWidget</db:link>, <db:link xlink:href="qwidget.xml#render">QWidget::render</db:link>() or similar functionality.</db:para>
</db:listitem>
<db:listitem>
<db:para>Focus Handling; It is possible to let the window container instance have any focus policy and it will delegate focus to the window via a call to <db:link xlink:href="qwindow.xml#requestActivate">QWindow::requestActivate</db:link>(). However, returning to the normal focus chain from the <db:link xlink:href="qwindow.xml">QWindow</db:link> instance will be up to the <db:link xlink:href="qwindow.xml">QWindow</db:link> instance implementation itself. For instance, when entering a Qt Quick based window with tab focus, it is quite likely that further tab presses will only cycle inside the QML application. Also, whether <db:link xlink:href="qwindow.xml#requestActivate">QWindow::requestActivate</db:link>() actually gives the window focus, is platform dependent.</db:para>
</db:listitem>
<db:listitem>
<db:para>Using many window container instances in a <db:link xlink:href="qwidget.xml">QWidget</db:link>-based application can greatly hurt the overall performance of the application.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="customContextMenuRequested">
<db:title>void QWidget::customContextMenuRequested(const QPoint &amp;<db:emphasis>pos</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>customContextMenuRequested</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void customContextMenuRequested(const QPoint &amp;pos)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the widget's <db:link xlink:href="qwidget.xml#contextMenuPolicy-prop">contextMenuPolicy</db:link> is <db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::CustomContextMenu</db:link>, and the user has requested a context menu on the widget. The position <db:code role="parameter">pos</db:code> is the position of the context menu event that the widget receives. Normally this is in widget coordinates. The exception to this rule is <db:link xlink:href="qabstractscrollarea.xml">QAbstractScrollArea</db:link> and its subclasses that map the context menu event to coordinates of the <db:link xlink:href="qabstractscrollarea.xml#viewport">viewport</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mapToGlobal">mapToGlobal</db:link>()</db:member>
<db:member><db:link xlink:href="qmenu.xml">QMenu</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#contextMenuPolicy-prop">contextMenuPolicy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="destroy">
<db:title>[protected] void QWidget::destroy(bool <db:emphasis>destroyWindow</db:emphasis> = true, bool <db:emphasis>destroySubWindows</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>destroy</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>destroyWindow</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>destroySubWindows</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void destroy(bool destroyWindow, bool destroySubWindows)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Frees up window system resources. Destroys the widget window if <db:code role="parameter">destroyWindow</db:code> is true.</db:para>
<db:para>destroy() calls itself recursively for all the child widgets, passing <db:code role="parameter">destroySubWindows</db:code> for the <db:code role="parameter">destroyWindow</db:code> parameter. To have more control over destruction of subwidgets, destroy subwidgets selectively first.</db:para>
<db:para>This function is usually called from the <db:link xlink:href="qwidget.xml">QWidget</db:link> destructor.</db:para>
</db:section>
<db:section xml:id="dragEnterEvent">
<db:title>[virtual protected] void QWidget::dragEnterEvent(QDragEnterEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>dragEnterEvent</db:methodname>
<db:methodparam>
<db:type>QDragEnterEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void dragEnterEvent(QDragEnterEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler is called when a drag is in progress and the mouse enters this widget. The event is passed in the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>If the event is ignored, the widget won't receive any <db:link xlink:href="qwidget.xml#dragMoveEvent">drag move events</db:link>.</db:para>
<db:para>See the <db:link xlink:href="dnd.xml">Drag-and-drop documentation</db:link> for an overview of how to provide drag-and-drop in your application.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdrag.xml">QDrag</db:link></db:member>
<db:member><db:link xlink:href="qdragenterevent.xml">QDragEnterEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dragLeaveEvent">
<db:title>[virtual protected] void QWidget::dragLeaveEvent(QDragLeaveEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>dragLeaveEvent</db:methodname>
<db:methodparam>
<db:type>QDragLeaveEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void dragLeaveEvent(QDragLeaveEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler is called when a drag is in progress and the mouse leaves this widget. The event is passed in the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>See the <db:link xlink:href="dnd.xml">Drag-and-drop documentation</db:link> for an overview of how to provide drag-and-drop in your application.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdrag.xml">QDrag</db:link></db:member>
<db:member><db:link xlink:href="qdragleaveevent.xml">QDragLeaveEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dragMoveEvent">
<db:title>[virtual protected] void QWidget::dragMoveEvent(QDragMoveEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>dragMoveEvent</db:methodname>
<db:methodparam>
<db:type>QDragMoveEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void dragMoveEvent(QDragMoveEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler is called if a drag is in progress, and when any of the following conditions occur: the cursor enters this widget, the cursor moves within this widget, or a modifier key is pressed on the keyboard while this widget has the focus. The event is passed in the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>See the <db:link xlink:href="dnd.xml">Drag-and-drop documentation</db:link> for an overview of how to provide drag-and-drop in your application.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdrag.xml">QDrag</db:link></db:member>
<db:member><db:link xlink:href="qdragmoveevent.xml">QDragMoveEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dropEvent">
<db:title>[virtual protected] void QWidget::dropEvent(QDropEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>dropEvent</db:methodname>
<db:methodparam>
<db:type>QDropEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void dropEvent(QDropEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler is called when the drag is dropped on this widget. The event is passed in the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>See the <db:link xlink:href="dnd.xml">Drag-and-drop documentation</db:link> for an overview of how to provide drag-and-drop in your application.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdrag.xml">QDrag</db:link></db:member>
<db:member><db:link xlink:href="qdropevent.xml">QDropEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="effectiveWinId">
<db:title>WId QWidget::effectiveWinId() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>WId</db:type>
<db:methodname>effectiveWinId</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">WId effectiveWinId() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the effective window system identifier of the widget, i.e. the native parent's window system identifier.</db:para>
<db:para>If the widget is native, this function returns the native widget ID. Otherwise, the window ID of the first native parent widget, i.e., the top-level widget that contains this widget, is returned.</db:para>
<db:note>
<db:para>We recommend that you do not store this value as it is likely to change at run-time.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#nativeParentWidget">nativeParentWidget</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ensurePolished">
<db:title>void QWidget::ensurePolished() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>ensurePolished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void ensurePolished() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Ensures that the widget and its children have been polished by <db:link xlink:href="qstyle.xml">QStyle</db:link> (i.e., have a proper font and palette).</db:para>
<db:para><db:link xlink:href="qwidget.xml">QWidget</db:link> calls this function after it has been fully constructed but before it is shown the very first time. You can call this function if you want to ensure that the widget is polished before doing an operation, e.g., the correct font size might be needed in the widget's <db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>() reimplementation. Note that this function <db:emphasis>is</db:emphasis> called from the default implementation of <db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>().</db:para>
<db:para>Polishing is useful for final initialization that must happen after all constructors (from base classes as well as from subclasses) have been called.</db:para>
<db:para>If you need to change some settings when a widget is polished, reimplement <db:link xlink:href="qwidget.xml#event">event</db:link>() and handle the <db:link xlink:href="qevent.xml#Type-enum">QEvent::Polish</db:link> event type.</db:para>
<db:para><db:emphasis role="bold">Note:</db:emphasis> The function is declared const so that it can be called from other const functions (e.g., <db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="enterEvent">
<db:title>[virtual protected] void QWidget::enterEvent(QEnterEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>enterEvent</db:methodname>
<db:methodparam>
<db:type>QEnterEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void enterEvent(QEnterEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive widget enter events which are passed in the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>An event is sent to the widget when the mouse cursor enters the widget.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#leaveEvent">leaveEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseMoveEvent">mouseMoveEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="event">
<db:title>[override virtual protected] bool QWidget::event(QEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>event</db:methodname>
<db:methodparam>
<db:type>QEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool event(QEvent *event) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qobject.xml#event" role="function">QObject::event(QEvent *e)</db:link>.</db:para>
<db:para>This is the main event handler; it handles event <db:code role="parameter">event</db:code>. You can reimplement this function in a subclass, but we recommend using one of the specialized event handlers instead.</db:para>
<db:para>Key press and release events are treated differently from other events. event() checks for Tab and Shift+Tab and tries to move the focus appropriately. If there is no widget to move the focus to (or the key press is not Tab or Shift+Tab), event() calls <db:link xlink:href="qwidget.xml#keyPressEvent">keyPressEvent</db:link>().</db:para>
<db:para>Mouse and tablet event handling is also slightly special: only when the widget is <db:link xlink:href="qwidget.xml#enabled-prop">enabled</db:link>, event() will call the specialized handlers such as <db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>(); otherwise it will discard the event.</db:para>
<db:para>This function returns <db:code>true</db:code> if the event was recognized, otherwise it returns <db:code>false</db:code>. If the recognized event was accepted (see <db:link xlink:href="qevent.xml#accepted-prop">QEvent::accepted</db:link>), any further processing such as event propagation to the parent widget stops.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#closeEvent">closeEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusInEvent">focusInEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusOutEvent">focusOutEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#enterEvent">enterEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#keyPressEvent">keyPressEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#keyReleaseEvent">keyReleaseEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#leaveEvent">leaveEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseDoubleClickEvent">mouseDoubleClickEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseMoveEvent">mouseMoveEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseReleaseEvent">mouseReleaseEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#moveEvent">moveEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#resizeEvent">resizeEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qobject.xml#event">QObject::event</db:link>()</db:member>
<db:member><db:link xlink:href="qobject.xml#timerEvent">QObject::timerEvent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find">
<db:title>[static] QWidget *QWidget::find(WId <db:emphasis>id</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>find</db:methodname>
<db:methodparam>
<db:type>WId</db:type>
<db:parameter>id</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * find(WId id)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the widget with window identifer/handle <db:code role="parameter">id</db:code>.</db:para>
<db:para>The window identifier type depends on the underlying window system, see <db:code>qwindowdefs.h</db:code> for the actual definition. If there is no widget with this identifier, <db:code>nullptr</db:code> is returned.</db:para>
</db:section>
<db:section xml:id="focusInEvent">
<db:title>[virtual protected] void QWidget::focusInEvent(QFocusEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>focusInEvent</db:methodname>
<db:methodparam>
<db:type>QFocusEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void focusInEvent(QFocusEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive keyboard focus events (focus received) for the widget. The event is passed in the <db:code role="parameter">event</db:code> parameter</db:para>
<db:para>A widget normally must <db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>() to something other than <db:link xlink:href="qt.xml#FocusPolicy-enum">Qt::NoFocus</db:link> in order to receive focus events. (Note that the application programmer can call <db:link xlink:href="qwidget.xml#setFocus-1">setFocus</db:link>() on any widget, even those that do not normally accept focus.)</db:para>
<db:para>The default implementation updates the widget (except for windows that do not specify a <db:link xlink:href="qwidget.xml#focusPolicy-prop">focusPolicy</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#focusOutEvent">focusOutEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#keyPressEvent">keyPressEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#keyReleaseEvent">keyReleaseEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qfocusevent.xml">QFocusEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="focusNextChild">
<db:title>[protected] bool QWidget::focusNextChild()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>focusNextChild</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool focusNextChild()</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Finds a new widget to give the keyboard focus to, as appropriate for <db:guilabel>Tab</db:guilabel>, and returns <db:code>true</db:code> if it can find a new widget, or false if it can't.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#focusPreviousChild">focusPreviousChild</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="focusNextPrevChild">
<db:title>[virtual protected] bool QWidget::focusNextPrevChild(bool <db:emphasis>next</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>focusNextPrevChild</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>next</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool focusNextPrevChild(bool next)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Finds a new widget to give the keyboard focus to, as appropriate for Tab and Shift+Tab, and returns <db:code>true</db:code> if it can find a new widget, or false if it can't.</db:para>
<db:para>If <db:code role="parameter">next</db:code> is true, this function searches forward, if <db:code role="parameter">next</db:code> is false, it searches backward.</db:para>
<db:para>Sometimes, you will want to reimplement this function. For example, a web browser might reimplement it to move its &quot;current active link&quot; forward or backward, and call focusNextPrevChild() only when it reaches the last or first link on the &quot;page&quot;.</db:para>
<db:para>Child widgets call focusNextPrevChild() on their parent widgets, but only the window that contains the child widgets decides where to redirect focus. By reimplementing this function for an object, you thus gain control of focus traversal for all child widgets.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#focusNextChild">focusNextChild</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusPreviousChild">focusPreviousChild</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="focusOutEvent">
<db:title>[virtual protected] void QWidget::focusOutEvent(QFocusEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>focusOutEvent</db:methodname>
<db:methodparam>
<db:type>QFocusEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void focusOutEvent(QFocusEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive keyboard focus events (focus lost) for the widget. The events is passed in the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>A widget normally must <db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>() to something other than <db:link xlink:href="qt.xml#FocusPolicy-enum">Qt::NoFocus</db:link> in order to receive focus events. (Note that the application programmer can call <db:link xlink:href="qwidget.xml#setFocus-1">setFocus</db:link>() on any widget, even those that do not normally accept focus.)</db:para>
<db:para>The default implementation updates the widget (except for windows that do not specify a <db:link xlink:href="qwidget.xml#focusPolicy-prop">focusPolicy</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#focusInEvent">focusInEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#keyPressEvent">keyPressEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#keyReleaseEvent">keyReleaseEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qfocusevent.xml">QFocusEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="focusPreviousChild">
<db:title>[protected] bool QWidget::focusPreviousChild()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>focusPreviousChild</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool focusPreviousChild()</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Finds a new widget to give the keyboard focus to, as appropriate for <db:guilabel>Shift+Tab</db:guilabel>, and returns <db:code>true</db:code> if it can find a new widget, or false if it can't.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#focusNextChild">focusNextChild</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="focusProxy">
<db:title>QWidget *QWidget::focusProxy() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>focusProxy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * focusProxy() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the focus proxy, or <db:code>nullptr</db:code> if there is no focus proxy.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setFocusProxy">setFocusProxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="focusWidget">
<db:title>QWidget *QWidget::focusWidget() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>focusWidget</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * focusWidget() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the last child of this widget that <db:link xlink:href="qwidget.xml#setFocus">setFocus</db:link> had been called on. For top level widgets this is the widget that will get focus in case this window gets activated</db:para>
<db:para>This is not the same as <db:link xlink:href="qapplication.xml#focusWidget">QApplication::focusWidget</db:link>(), which returns the focus widget in the currently active window.</db:para>
</db:section>
<db:section xml:id="fontInfo">
<db:title>QFontInfo QWidget::fontInfo() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFontInfo</db:type>
<db:methodname>fontInfo</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFontInfo fontInfo() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the font info for the widget's current font. Equivalent to <db:code>QFontInfo(widget-&gt;font())</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#font-prop">font</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#fontMetrics">fontMetrics</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#font-prop">setFont</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fontMetrics">
<db:title>QFontMetrics QWidget::fontMetrics() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFontMetrics</db:type>
<db:methodname>fontMetrics</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFontMetrics fontMetrics() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the font metrics for the widget's current font. Equivalent to <db:code>QFontMetrics(widget-&gt;font())</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#font-prop">font</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#fontInfo">fontInfo</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#font-prop">setFont</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="foregroundRole">
<db:title>QPalette::ColorRole QWidget::foregroundRole() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPalette::ColorRole</db:type>
<db:methodname>foregroundRole</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPalette::ColorRole foregroundRole() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the foreground role.</db:para>
<db:para>The foreground role defines the color from the widget's <db:link xlink:href="qwidget.xml#palette-prop">palette</db:link> that is used to draw the foreground.</db:para>
<db:para>If no explicit foreground role is set, the function returns a role that contrasts with the background role.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setForegroundRole">setForegroundRole</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#backgroundRole">backgroundRole</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="grab">
<db:title>[since 5.0] QPixmap QWidget::grab(const QRect &amp;<db:emphasis>rectangle</db:emphasis> = QRect(QPoint(0, 0), QSize(-1, -1)))</db:title>
<db:methodsynopsis>
<db:type>QPixmap</db:type>
<db:methodname>grab</db:methodname>
<db:methodparam>
<db:type>const QRect &amp;</db:type>
<db:parameter>rectangle</db:parameter>
<db:initializer>QRect(QPoint(0, 0), QSize(-1, -1))</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPixmap grab(const QRect &amp;rectangle)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Renders the widget into a pixmap restricted by the given <db:code role="parameter">rectangle</db:code>. If the widget has any children, then they are also painted in the appropriate positions.</db:para>
<db:para>If a rectangle with an invalid size is specified (the default), the entire widget is painted.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#render">render</db:link>()</db:member>
<db:member><db:link xlink:href="qpixmap.xml">QPixmap</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="grabGesture">
<db:title>void QWidget::grabGesture(Qt::GestureType <db:emphasis>gesture</db:emphasis>, Qt::GestureFlags <db:emphasis>flags</db:emphasis> = Qt::GestureFlags())</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>grabGesture</db:methodname>
<db:methodparam>
<db:type>Qt::GestureType</db:type>
<db:parameter>gesture</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::GestureFlags</db:type>
<db:parameter>flags</db:parameter>
<db:initializer>Qt::GestureFlags()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void grabGesture(Qt::GestureType gesture, Qt::GestureFlags flags)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Subscribes the widget to a given <db:code role="parameter">gesture</db:code> with specific <db:code role="parameter">flags</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#ungrabGesture">ungrabGesture</db:link>()</db:member>
<db:member><db:link xlink:href="qgestureevent.xml">QGestureEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="grabKeyboard">
<db:title>void QWidget::grabKeyboard()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>grabKeyboard</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void grabKeyboard()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Grabs the keyboard input.</db:para>
<db:para>This widget receives all keyboard events until <db:link xlink:href="qwidget.xml#releaseKeyboard">releaseKeyboard</db:link>() is called; other widgets get no keyboard events at all. Mouse events are not affected. Use <db:link xlink:href="qwidget.xml#grabMouse">grabMouse</db:link>() if you want to grab that.</db:para>
<db:para>The focus widget is not affected, except that it doesn't receive any keyboard events. <db:link xlink:href="qwidget.xml#setFocus-1">setFocus</db:link>() moves the focus as usual, but the new focus widget receives keyboard events only after <db:link xlink:href="qwidget.xml#releaseKeyboard">releaseKeyboard</db:link>() is called.</db:para>
<db:para>If a different widget is currently grabbing keyboard input, that widget's grab is released first.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#releaseKeyboard">releaseKeyboard</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#grabMouse">grabMouse</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#releaseMouse">releaseMouse</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusWidget">focusWidget</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="grabMouse">
<db:title>void QWidget::grabMouse()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>grabMouse</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void grabMouse()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Grabs the mouse input.</db:para>
<db:para>This widget receives all mouse events until <db:link xlink:href="qwidget.xml#releaseMouse">releaseMouse</db:link>() is called; other widgets get no mouse events at all. Keyboard events are not affected. Use <db:link xlink:href="qwidget.xml#grabKeyboard">grabKeyboard</db:link>() if you want to grab that.</db:para>
<db:warning>
<db:para>Bugs in mouse-grabbing applications very often lock the terminal. Use this function with extreme caution, and consider using the <db:code>-nograb</db:code> command line option while debugging.</db:para>
</db:warning>
<db:para>It is almost never necessary to grab the mouse when using Qt, as Qt grabs and releases it sensibly. In particular, Qt grabs the mouse when a mouse button is pressed and keeps it until the last button is released.</db:para>
<db:note>
<db:para>Only visible widgets can grab mouse input. If <db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>() returns <db:code>false</db:code> for a widget, that widget cannot call grabMouse().</db:para>
</db:note>
<db:note>
<db:para>On Windows, grabMouse() only works when the mouse is inside a window owned by the process. On macOS, grabMouse() only works when the mouse is inside the frame of that widget.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#releaseMouse">releaseMouse</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#grabKeyboard">grabKeyboard</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#releaseKeyboard">releaseKeyboard</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="grabMouse-1">
<db:title>void QWidget::grabMouse(const QCursor &amp;<db:emphasis>cursor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>grabMouse</db:methodname>
<db:methodparam>
<db:type>const QCursor &amp;</db:type>
<db:parameter>cursor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void grabMouse(const QCursor &amp;cursor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads <db:link xlink:href="qwidget.xml#grabMouse">grabMouse</db:link>().</db:para>
<db:para>Grabs the mouse input and changes the cursor shape.</db:para>
<db:para>The cursor will assume shape <db:code role="parameter">cursor</db:code> (for as long as the mouse focus is grabbed) and this widget will be the only one to receive mouse events until <db:link xlink:href="qwidget.xml#releaseMouse">releaseMouse</db:link>() is called().</db:para>
<db:warning>
<db:para>Grabbing the mouse might lock the terminal.</db:para>
</db:warning>
<db:note>
<db:para>See the note in <db:link xlink:href="qwidget.xml#grabMouse">QWidget::grabMouse</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#releaseMouse">releaseMouse</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#grabKeyboard">grabKeyboard</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#releaseKeyboard">releaseKeyboard</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#cursor-prop">setCursor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="grabShortcut">
<db:title>int QWidget::grabShortcut(const QKeySequence &amp;<db:emphasis>key</db:emphasis>, Qt::ShortcutContext <db:emphasis>context</db:emphasis> = Qt::WindowShortcut)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>grabShortcut</db:methodname>
<db:methodparam>
<db:type>const QKeySequence &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ShortcutContext</db:type>
<db:parameter>context</db:parameter>
<db:initializer>Qt::WindowShortcut</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int grabShortcut(const QKeySequence &amp;key, Qt::ShortcutContext context)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds a shortcut to Qt's shortcut system that watches for the given <db:code role="parameter">key</db:code> sequence in the given <db:code role="parameter">context</db:code>. If the <db:code role="parameter">context</db:code> is <db:link xlink:href="qt.xml#ShortcutContext-enum">Qt::ApplicationShortcut</db:link>, the shortcut applies to the application as a whole. Otherwise, it is either local to this widget, <db:link xlink:href="qt.xml#ShortcutContext-enum">Qt::WidgetShortcut</db:link>, or to the window itself, <db:link xlink:href="qt.xml#ShortcutContext-enum">Qt::WindowShortcut</db:link>.</db:para>
<db:para>If the same <db:code role="parameter">key</db:code> sequence has been grabbed by several widgets, when the <db:code role="parameter">key</db:code> sequence occurs a <db:link xlink:href="qevent.xml#Type-enum">QEvent::Shortcut</db:link> event is sent to all the widgets to which it applies in a non-deterministic order, but with the ``ambiguous'' flag set to true.</db:para>
<db:warning>
<db:para>You should not normally need to use this function; instead create <db:link xlink:href="qaction.xml">QAction</db:link>s with the shortcut key sequences you require (if you also want equivalent menu options and toolbar buttons), or create <db:link xlink:href="qshortcut.xml">QShortcut</db:link>s if you just need key sequences. Both <db:link xlink:href="qaction.xml">QAction</db:link> and <db:link xlink:href="qshortcut.xml">QShortcut</db:link> handle all the event filtering for you, and provide signals which are triggered when the user triggers the key sequence, so are much easier to use than this low-level function.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#releaseShortcut">releaseShortcut</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#setShortcutEnabled">setShortcutEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="graphicsEffect">
<db:title>QGraphicsEffect *QWidget::graphicsEffect() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QGraphicsEffect *</db:type>
<db:methodname>graphicsEffect</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QGraphicsEffect * graphicsEffect() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The graphicsEffect function returns a pointer to the widget's graphics effect.</db:para>
<db:para>If the widget has no graphics effect, <db:code>nullptr</db:code> is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setGraphicsEffect">setGraphicsEffect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="graphicsProxyWidget">
<db:title>QGraphicsProxyWidget *QWidget::graphicsProxyWidget() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QGraphicsProxyWidget *</db:type>
<db:methodname>graphicsProxyWidget</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QGraphicsProxyWidget * graphicsProxyWidget() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the proxy widget for the corresponding embedded widget in a graphics view; otherwise returns <db:code>nullptr</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qgraphicsproxywidget.xml#createProxyForChildWidget">QGraphicsProxyWidget::createProxyForChildWidget</db:link>()</db:member>
<db:member><db:link xlink:href="qgraphicsscene.xml#addWidget">QGraphicsScene::addWidget</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasEditFocus">
<db:title>bool QWidget::hasEditFocus() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasEditFocus</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasEditFocus() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this widget currently has edit focus; otherwise false.</db:para>
<db:para>This feature is only available in Qt for Embedded Linux.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setEditFocus">setEditFocus</db:link>()</db:member>
<db:member><db:link xlink:href="qapplication.xml#navigationMode">QApplication::navigationMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasHeightForWidth">
<db:title>[virtual, since 5.0] bool QWidget::hasHeightForWidth() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasHeightForWidth</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasHeightForWidth() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the widget's preferred height depends on its width; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="heightForWidth">
<db:title>[virtual] int QWidget::heightForWidth(int <db:emphasis>w</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>heightForWidth</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>w</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int heightForWidth(int w) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the preferred height for this widget, given the width <db:code role="parameter">w</db:code>.</db:para>
<db:para>If this widget has a layout, the default implementation returns the layout's preferred height. if there is no layout, the default implementation returns -1 indicating that the preferred height does not depend on the width.</db:para>
</db:section>
<db:section xml:id="hide">
<db:title>void QWidget::hide()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>hide</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void hide()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Hides the widget. This function is equivalent to <db:link xlink:href="qwidget.xml#visible-prop">setVisible</db:link>(false).</db:para>
<db:note>
<db:para>If you are working with <db:link xlink:href="qdialog.xml">QDialog</db:link> or its subclasses and you invoke the <db:link xlink:href="qwidget.xml#show">show</db:link>() function after this function, the dialog will be displayed in its original position.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#hideEvent">hideEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#isHidden">isHidden</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#show">show</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#visible-prop">setVisible</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hideEvent">
<db:title>[virtual protected] void QWidget::hideEvent(QHideEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>hideEvent</db:methodname>
<db:methodparam>
<db:type>QHideEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void hideEvent(QHideEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive widget hide events. The event is passed in the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>Hide events are sent to widgets immediately after they have been hidden.</db:para>
<db:para>Note: A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g. a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again. After receiving a spontaneous hide event, a widget is still considered visible in the sense of <db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#visible-prop">visible</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qhideevent.xml">QHideEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="initPainter">
<db:title>[override virtual protected] void QWidget::initPainter(QPainter *<db:emphasis>painter</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>initPainter</db:methodname>
<db:methodparam>
<db:type>QPainter *</db:type>
<db:parameter>painter</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void initPainter(QPainter *painter) const override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Initializes the <db:code role="parameter">painter</db:code> pen, background and font to the same as the given widget's. This function is called automatically when the painter is opened on a <db:link xlink:href="qwidget.xml">QWidget</db:link>.</db:para>
</db:section>
<db:section xml:id="inputMethodEvent">
<db:title>[virtual protected] void QWidget::inputMethodEvent(QInputMethodEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>inputMethodEvent</db:methodname>
<db:methodparam>
<db:type>QInputMethodEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void inputMethodEvent(QInputMethodEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler, for event <db:code role="parameter">event</db:code>, can be reimplemented in a subclass to receive Input Method composition events. This handler is called when the state of the input method changes.</db:para>
<db:para>Note that when creating custom text editing widgets, the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_InputMethodEnabled</db:link> window attribute must be set explicitly (using the <db:link xlink:href="qwidget.xml#setAttribute">setAttribute</db:link>() function) in order to receive input method events.</db:para>
<db:para>The default implementation calls event-&gt;ignore(), which rejects the Input Method event. See the <db:link xlink:href="qinputmethodevent.xml">QInputMethodEvent</db:link> documentation for more details.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qinputmethodevent.xml">QInputMethodEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="inputMethodQuery">
<db:title>[virtual] QVariant QWidget::inputMethodQuery(Qt::InputMethodQuery <db:emphasis>query</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>inputMethodQuery</db:methodname>
<db:methodparam>
<db:type>Qt::InputMethodQuery</db:type>
<db:parameter>query</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant inputMethodQuery(Qt::InputMethodQuery query) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This method is only relevant for input widgets. It is used by the input method to query a set of properties of the widget to be able to support complex input method operations as support for surrounding text and reconversions.</db:para>
<db:para><db:code role="parameter">query</db:code> specifies which property is queried.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#inputMethodEvent">inputMethodEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qinputmethodevent.xml">QInputMethodEvent</db:link></db:member>
<db:member><db:link xlink:href="qinputmethodqueryevent.xml">QInputMethodQueryEvent</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#inputMethodHints-prop">inputMethodHints</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insertAction">
<db:title>void QWidget::insertAction(QAction *<db:emphasis>before</db:emphasis>, QAction *<db:emphasis>action</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>insertAction</db:methodname>
<db:methodparam>
<db:type>QAction *</db:type>
<db:parameter>before</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QAction *</db:type>
<db:parameter>action</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void insertAction(QAction *before, QAction *action)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts the action <db:code role="parameter">action</db:code> to this widget's list of actions, before the action <db:code role="parameter">before</db:code>. It appends the action if <db:code role="parameter">before</db:code> is <db:code>nullptr</db:code> or <db:code role="parameter">before</db:code> is not a valid action for this widget.</db:para>
<db:para>A <db:link xlink:href="qwidget.xml">QWidget</db:link> should only have one of each action.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#removeAction">removeAction</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#addAction">addAction</db:link>()</db:member>
<db:member><db:link xlink:href="qmenu.xml">QMenu</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#contextMenuPolicy-prop">contextMenuPolicy</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#actions">actions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insertActions">
<db:title>void QWidget::insertActions(QAction *<db:emphasis>before</db:emphasis>, const QList&lt;QAction *&gt; &amp;<db:emphasis>actions</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>insertActions</db:methodname>
<db:methodparam>
<db:type>QAction *</db:type>
<db:parameter>before</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QList&lt;QAction *&gt; &amp;</db:type>
<db:parameter>actions</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void insertActions(QAction *before, const QList&lt;QAction *&gt; &amp;actions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts the actions <db:code role="parameter">actions</db:code> to this widget's list of actions, before the action <db:code role="parameter">before</db:code>. It appends the action if <db:code role="parameter">before</db:code> is <db:code>nullptr</db:code> or <db:code role="parameter">before</db:code> is not a valid action for this widget.</db:para>
<db:para>A <db:link xlink:href="qwidget.xml">QWidget</db:link> can have at most one of each action.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#removeAction">removeAction</db:link>()</db:member>
<db:member><db:link xlink:href="qmenu.xml">QMenu</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#insertAction">insertAction</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#contextMenuPolicy-prop">contextMenuPolicy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isAncestorOf">
<db:title>bool QWidget::isAncestorOf(const QWidget *<db:emphasis>child</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isAncestorOf</db:methodname>
<db:methodparam>
<db:type>const QWidget *</db:type>
<db:parameter>child</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isAncestorOf(const QWidget *child) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this widget is a parent, (or grandparent and so on to any level), of the given <db:code role="parameter">child</db:code>, and both widgets are within the same window; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="isEnabledTo">
<db:title>bool QWidget::isEnabledTo(const QWidget *<db:emphasis>ancestor</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isEnabledTo</db:methodname>
<db:methodparam>
<db:type>const QWidget *</db:type>
<db:parameter>ancestor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isEnabledTo(const QWidget *ancestor) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this widget would become enabled if <db:code role="parameter">ancestor</db:code> is enabled; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This is the case if neither the widget itself nor every parent up to but excluding <db:code role="parameter">ancestor</db:code> has been explicitly disabled.</db:para>
<db:para>isEnabledTo(0) returns false if this widget or any if its ancestors was explicitly disabled.</db:para>
<db:para>The word ancestor here means a parent widget within the same window.</db:para>
<db:para>Therefore isEnabledTo(0) stops at this widget's window, unlike <db:link xlink:href="qwidget.xml#enabled-prop">isEnabled</db:link>() which also takes parent windows into considerations.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#enabled-prop">setEnabled</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#enabled-prop">enabled</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isHidden">
<db:title>bool QWidget::isHidden() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isHidden</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isHidden() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the widget is hidden, otherwise returns <db:code>false</db:code>.</db:para>
<db:para>A hidden widget will only become visible when <db:link xlink:href="qwidget.xml#show">show</db:link>() is called on it. It will not be automatically shown when the parent is shown.</db:para>
<db:para>To check visibility, use !<db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>() instead (notice the exclamation mark).</db:para>
<db:para>isHidden() implies !<db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>(), but a widget can be not visible and not hidden at the same time. This is the case for widgets that are children of widgets that are not visible.</db:para>
<db:para>Widgets are hidden if:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>they were created as independent windows,</db:para>
</db:listitem>
<db:listitem>
<db:para>they were created as children of visible widgets,</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#hide">hide</db:link>() or <db:link xlink:href="qwidget.xml#visible-prop">setVisible</db:link>(false) was called.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="isVisibleTo">
<db:title>bool QWidget::isVisibleTo(const QWidget *<db:emphasis>ancestor</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isVisibleTo</db:methodname>
<db:methodparam>
<db:type>const QWidget *</db:type>
<db:parameter>ancestor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isVisibleTo(const QWidget *ancestor) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this widget would become visible if <db:code role="parameter">ancestor</db:code> is shown; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The true case occurs if neither the widget itself nor any parent up to but excluding <db:code role="parameter">ancestor</db:code> has been explicitly hidden.</db:para>
<db:para>This function will still return true if the widget is obscured by other windows on the screen, but could be physically visible if it or they were to be moved.</db:para>
<db:para>isVisibleTo(0) is identical to <db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#show">show</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#hide">hide</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isWindow">
<db:title>bool QWidget::isWindow() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isWindow</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isWindow() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the widget is an independent window, otherwise returns <db:code>false</db:code>.</db:para>
<db:para>A window is a widget that isn't visually the child of any other widget and that usually has a frame and a <db:link xlink:href="qwidget.xml#windowTitle-prop">window title</db:link>.</db:para>
<db:para>A window can have a <db:link xlink:href="qwidget.xml#parentWidget">parent widget</db:link>. It will then be grouped with its parent and deleted when the parent is deleted, minimized when the parent is minimized etc. If supported by the window manager, it will also have a common taskbar entry with its parent.</db:para>
<db:para><db:link xlink:href="qdialog.xml">QDialog</db:link> and <db:link xlink:href="qmainwindow.xml">QMainWindow</db:link> widgets are by default windows, even if a parent widget is specified in the constructor. This behavior is specified by the <db:link xlink:href="qt.xml#WindowType-enum">Qt::Window</db:link> flag.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#window">window</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#modal-prop">isModal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#parentWidget">parentWidget</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyPressEvent">
<db:title>[virtual protected] void QWidget::keyPressEvent(QKeyEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>keyPressEvent</db:methodname>
<db:methodparam>
<db:type>QKeyEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyPressEvent(QKeyEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler, for event <db:code role="parameter">event</db:code>, can be reimplemented in a subclass to receive key press events for the widget.</db:para>
<db:para>A widget must call <db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>() to accept focus initially and have focus in order to receive a key press event.</db:para>
<db:para>If you reimplement this handler, it is very important that you call the base class implementation if you do not act upon the key.</db:para>
<db:para>The default implementation closes popup widgets if the user presses the key sequence for <db:link xlink:href="qkeysequence.xml#StandardKey-enum">QKeySequence::Cancel</db:link> (typically the Escape key). Otherwise the event is ignored, so that the widget's parent can interpret it.</db:para>
<db:para>Note that <db:link xlink:href="qkeyevent.xml">QKeyEvent</db:link> starts with isAccepted() == true, so you do not need to call <db:link xlink:href="qevent.xml#accept">QKeyEvent::accept</db:link>() - just do not call the base class implementation if you act upon the key.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#keyReleaseEvent">keyReleaseEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusInEvent">focusInEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusOutEvent">focusOutEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qkeyevent.xml">QKeyEvent</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-tetrix-example.xml">Tetrix Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyReleaseEvent">
<db:title>[virtual protected] void QWidget::keyReleaseEvent(QKeyEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>keyReleaseEvent</db:methodname>
<db:methodparam>
<db:type>QKeyEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyReleaseEvent(QKeyEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler, for event <db:code role="parameter">event</db:code>, can be reimplemented in a subclass to receive key release events for the widget.</db:para>
<db:para>A widget must <db:link xlink:href="qwidget.xml#focusPolicy-prop">accept focus</db:link> initially and <db:link xlink:href="qwidget.xml#focus-prop">have focus</db:link> in order to receive a key release event.</db:para>
<db:para>If you reimplement this handler, it is very important that you call the base class implementation if you do not act upon the key.</db:para>
<db:para>The default implementation ignores the event, so that the widget's parent can interpret it.</db:para>
<db:para>Note that <db:link xlink:href="qkeyevent.xml">QKeyEvent</db:link> starts with isAccepted() == true, so you do not need to call <db:link xlink:href="qevent.xml#accept">QKeyEvent::accept</db:link>() - just do not call the base class implementation if you act upon the key.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#keyPressEvent">keyPressEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qevent.xml#ignore">QEvent::ignore</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusInEvent">focusInEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusOutEvent">focusOutEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qkeyevent.xml">QKeyEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyboardGrabber">
<db:title>[static] QWidget *QWidget::keyboardGrabber()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>keyboardGrabber</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * keyboardGrabber()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the widget that is currently grabbing the keyboard input.</db:para>
<db:para>If no widget in this application is currently grabbing the keyboard, <db:code>nullptr</db:code> is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#grabMouse">grabMouse</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseGrabber">mouseGrabber</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="layout">
<db:title>QLayout *QWidget::layout() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QLayout *</db:type>
<db:methodname>layout</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QLayout * layout() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the layout manager that is installed on this widget, or <db:code>nullptr</db:code> if no layout manager is installed.</db:para>
<db:para>The layout manager sets the geometry of the widget's children that have been added to the layout.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setLayout">setLayout</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#sizePolicy-prop">sizePolicy</db:link>()</db:member>
<db:member><db:link xlink:href="layout.xml">Layout Management</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="leaveEvent">
<db:title>[virtual protected] void QWidget::leaveEvent(QEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>leaveEvent</db:methodname>
<db:methodparam>
<db:type>QEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void leaveEvent(QEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive widget leave events which are passed in the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>A leave event is sent to the widget when the mouse cursor leaves the widget.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#enterEvent">enterEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseMoveEvent">mouseMoveEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lower">
<db:title>void QWidget::lower()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>lower</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void lower()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Lowers the widget to the bottom of the parent widget's stack.</db:para>
<db:para>After this call the widget will be visually behind (and therefore obscured by) any overlapping sibling widgets.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#raise">raise</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#stackUnder">stackUnder</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapFrom">
<db:title>[since 6.0] QPointF QWidget::mapFrom(const QWidget *<db:emphasis>parent</db:emphasis>, const QPointF &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>mapFrom</db:methodname>
<db:methodparam>
<db:type>const QWidget *</db:type>
<db:parameter>parent</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF mapFrom(const QWidget *parent, const QPointF &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Translates the widget coordinate <db:code role="parameter">pos</db:code> from the coordinate system of <db:code role="parameter">parent</db:code> to this widget's coordinate system. The <db:code role="parameter">parent</db:code> must not be <db:code>nullptr</db:code> and must be a parent of the calling widget.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mapTo">mapTo</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mapFromParent">mapFromParent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mapFromGlobal">mapFromGlobal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#underMouse">underMouse</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapFrom-1">
<db:title>QPoint QWidget::mapFrom(const QWidget *<db:emphasis>parent</db:emphasis>, const QPoint &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPoint</db:type>
<db:methodname>mapFrom</db:methodname>
<db:methodparam>
<db:type>const QWidget *</db:type>
<db:parameter>parent</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QPoint mapFrom(const QWidget *parent, const QPoint &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="mapFromGlobal">
<db:title>[since 6.0] QPointF QWidget::mapFromGlobal(const QPointF &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>mapFromGlobal</db:methodname>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF mapFromGlobal(const QPointF &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Translates the global screen coordinate <db:code role="parameter">pos</db:code> to widget coordinates.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mapToGlobal">mapToGlobal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mapFrom">mapFrom</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mapFromParent">mapFromParent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapFromGlobal-1">
<db:title>QPoint QWidget::mapFromGlobal(const QPoint &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPoint</db:type>
<db:methodname>mapFromGlobal</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QPoint mapFromGlobal(const QPoint &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="mapFromParent">
<db:title>[since 6.0] QPointF QWidget::mapFromParent(const QPointF &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>mapFromParent</db:methodname>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF mapFromParent(const QPointF &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Translates the parent widget coordinate <db:code role="parameter">pos</db:code> to widget coordinates.</db:para>
<db:para>Same as <db:link xlink:href="qwidget.xml#mapFromGlobal">mapFromGlobal</db:link>() if the widget has no parent.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mapToParent">mapToParent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mapFrom">mapFrom</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mapFromGlobal">mapFromGlobal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#underMouse">underMouse</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapFromParent-1">
<db:title>QPoint QWidget::mapFromParent(const QPoint &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPoint</db:type>
<db:methodname>mapFromParent</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QPoint mapFromParent(const QPoint &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="mapTo">
<db:title>[since 6.0] QPointF QWidget::mapTo(const QWidget *<db:emphasis>parent</db:emphasis>, const QPointF &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>mapTo</db:methodname>
<db:methodparam>
<db:type>const QWidget *</db:type>
<db:parameter>parent</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF mapTo(const QWidget *parent, const QPointF &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Translates the widget coordinate <db:code role="parameter">pos</db:code> to the coordinate system of <db:code role="parameter">parent</db:code>. The <db:code role="parameter">parent</db:code> must not be <db:code>nullptr</db:code> and must be a parent of the calling widget.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mapFrom">mapFrom</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mapToParent">mapToParent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mapToGlobal">mapToGlobal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#underMouse">underMouse</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapTo-1">
<db:title>QPoint QWidget::mapTo(const QWidget *<db:emphasis>parent</db:emphasis>, const QPoint &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPoint</db:type>
<db:methodname>mapTo</db:methodname>
<db:methodparam>
<db:type>const QWidget *</db:type>
<db:parameter>parent</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QPoint mapTo(const QWidget *parent, const QPoint &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="mapToGlobal">
<db:title>[since 6.0] QPointF QWidget::mapToGlobal(const QPointF &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>mapToGlobal</db:methodname>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF mapToGlobal(const QPointF &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Translates the widget coordinate <db:code role="parameter">pos</db:code> to global screen coordinates. For example, <db:code>mapToGlobal(QPointF(0,0))</db:code> would give the global coordinates of the top-left pixel of the widget.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mapFromGlobal">mapFromGlobal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mapTo">mapTo</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mapToParent">mapToParent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapToGlobal-1">
<db:title>QPoint QWidget::mapToGlobal(const QPoint &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPoint</db:type>
<db:methodname>mapToGlobal</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QPoint mapToGlobal(const QPoint &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="mapToParent">
<db:title>[since 6.0] QPointF QWidget::mapToParent(const QPointF &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>mapToParent</db:methodname>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF mapToParent(const QPointF &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Translates the widget coordinate <db:code role="parameter">pos</db:code> to a coordinate in the parent widget.</db:para>
<db:para>Same as <db:link xlink:href="qwidget.xml#mapToGlobal">mapToGlobal</db:link>() if the widget has no parent.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mapFromParent">mapFromParent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mapTo">mapTo</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mapToGlobal">mapToGlobal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#underMouse">underMouse</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapToParent-1">
<db:title>QPoint QWidget::mapToParent(const QPoint &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPoint</db:type>
<db:methodname>mapToParent</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QPoint mapToParent(const QPoint &amp;pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="mask">
<db:title>QRegion QWidget::mask() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRegion</db:type>
<db:methodname>mask</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegion mask() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the mask currently set on a widget. If no mask is set the return value will be an empty region.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setMask">setMask</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#clearMask">clearMask</db:link>()</db:member>
<db:member><db:link xlink:href="qregion.xml#isEmpty">QRegion::isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-shapedclock-example.xml">Shaped Clock Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="metric">
<db:title>[override virtual protected] int QWidget::metric(QPaintDevice::PaintDeviceMetric <db:emphasis>m</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>metric</db:methodname>
<db:methodparam>
<db:type>QPaintDevice::PaintDeviceMetric</db:type>
<db:parameter>m</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int metric(QPaintDevice::PaintDeviceMetric m) const override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qpaintdevice.xml#metric" role="function">QPaintDevice::metric(QPaintDevice::PaintDeviceMetric metric) const</db:link>.</db:para>
<db:para>Internal implementation of the virtual <db:link xlink:href="qpaintdevice.xml#metric">QPaintDevice::metric</db:link>() function.</db:para>
<db:para><db:code role="parameter">m</db:code> is the metric to get.</db:para>
</db:section>
<db:section xml:id="mouseDoubleClickEvent">
<db:title>[virtual protected] void QWidget::mouseDoubleClickEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mouseDoubleClickEvent</db:methodname>
<db:methodparam>
<db:type>QMouseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseDoubleClickEvent(QMouseEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler, for event <db:code role="parameter">event</db:code>, can be reimplemented in a subclass to receive mouse double click events for the widget.</db:para>
<db:para>The default implementation calls <db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>().</db:para>
<db:note>
<db:para>The widget will also receive mouse press and mouse release events in addition to the double click event. And if another widget that overlaps this widget disappears in response to press or release events, then this widget will only receive the double click event. It is up to the developer to ensure that the application interprets these events correctly.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseReleaseEvent">mouseReleaseEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseMoveEvent">mouseMoveEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qmouseevent.xml">QMouseEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseGrabber">
<db:title>[static] QWidget *QWidget::mouseGrabber()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>mouseGrabber</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * mouseGrabber()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the widget that is currently grabbing the mouse input.</db:para>
<db:para>If no widget in this application is currently grabbing the mouse, <db:code>nullptr</db:code> is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#grabMouse">grabMouse</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#keyboardGrabber">keyboardGrabber</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseMoveEvent">
<db:title>[virtual protected] void QWidget::mouseMoveEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mouseMoveEvent</db:methodname>
<db:methodparam>
<db:type>QMouseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseMoveEvent(QMouseEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler, for event <db:code role="parameter">event</db:code>, can be reimplemented in a subclass to receive mouse move events for the widget.</db:para>
<db:para>If mouse tracking is switched off, mouse move events only occur if a mouse button is pressed while the mouse is being moved. If mouse tracking is switched on, mouse move events occur even if no mouse button is pressed.</db:para>
<db:para><db:link xlink:href="qmouseevent.xml#pos">QMouseEvent::pos</db:link>() reports the position of the mouse cursor, relative to this widget. For press and release events, the position is usually the same as the position of the last mouse move event, but it might be different if the user's hand shakes. This is a feature of the underlying window system, not Qt.</db:para>
<db:para>If you want to show a tooltip immediately, while the mouse is moving (e.g., to get the mouse coordinates with <db:link xlink:href="qmouseevent.xml#pos">QMouseEvent::pos</db:link>() and show them as a tooltip), you must first enable mouse tracking as described above. Then, to ensure that the tooltip is updated immediately, you must call <db:link xlink:href="qtooltip.xml#showText">QToolTip::showText</db:link>() instead of <db:link xlink:href="qwidget.xml#toolTip-prop">setToolTip</db:link>() in your implementation of mouseMoveEvent().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mouseTracking-prop">setMouseTracking</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseReleaseEvent">mouseReleaseEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseDoubleClickEvent">mouseDoubleClickEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qmouseevent.xml">QMouseEvent</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-scribble-example.xml">Scribble Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mousePressEvent">
<db:title>[virtual protected] void QWidget::mousePressEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mousePressEvent</db:methodname>
<db:methodparam>
<db:type>QMouseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mousePressEvent(QMouseEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler, for event <db:code role="parameter">event</db:code>, can be reimplemented in a subclass to receive mouse press events for the widget.</db:para>
<db:para>If you create new widgets in the mousePressEvent() the <db:link xlink:href="qwidget.xml#mouseReleaseEvent">mouseReleaseEvent</db:link>() may not end up where you expect, depending on the underlying window system (or X11 window manager), the widgets' location and maybe more.</db:para>
<db:para>The default implementation implements the closing of popup widgets when you click outside the window. For other widget types it does nothing.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mouseReleaseEvent">mouseReleaseEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseDoubleClickEvent">mouseDoubleClickEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseMoveEvent">mouseMoveEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qmouseevent.xml">QMouseEvent</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-scribble-example.xml">Scribble Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseReleaseEvent">
<db:title>[virtual protected] void QWidget::mouseReleaseEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mouseReleaseEvent</db:methodname>
<db:methodparam>
<db:type>QMouseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseReleaseEvent(QMouseEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler, for event <db:code role="parameter">event</db:code>, can be reimplemented in a subclass to receive mouse release events for the widget.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mousePressEvent">mousePressEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseDoubleClickEvent">mouseDoubleClickEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#mouseMoveEvent">mouseMoveEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qmouseevent.xml">QMouseEvent</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-scribble-example.xml">Scribble Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="move-1">
<db:title>void QWidget::move(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>move</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="associated-property">pos</db:synopsisinfo>
<db:synopsisinfo role="signature">void move(int x, int y)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This corresponds to move(<db:link xlink:href="qpoint.xml">QPoint</db:link>(<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>)).</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qwidget.xml#pos-prop">pos</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="moveEvent">
<db:title>[virtual protected] void QWidget::moveEvent(QMoveEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>moveEvent</db:methodname>
<db:methodparam>
<db:type>QMoveEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void moveEvent(QMoveEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive widget move events which are passed in the <db:code role="parameter">event</db:code> parameter. When the widget receives this event, it is already at the new position.</db:para>
<db:para>The old position is accessible through <db:link xlink:href="qmoveevent.xml#oldPos">QMoveEvent::oldPos</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#resizeEvent">resizeEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#pos-prop">move</db:link>()</db:member>
<db:member><db:link xlink:href="qmoveevent.xml">QMoveEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nativeEvent">
<db:title>[virtual protected] bool QWidget::nativeEvent(const QByteArray &amp;<db:emphasis>eventType</db:emphasis>, void *<db:emphasis>message</db:emphasis>, qintptr *<db:emphasis>result</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>nativeEvent</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>eventType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>void *</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qintptr *</db:type>
<db:parameter>result</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool nativeEvent(const QByteArray &amp;eventType, void *message, qintptr *result)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This special event handler can be reimplemented in a subclass to receive native platform events identified by <db:code role="parameter">eventType</db:code> which are passed in the <db:code role="parameter">message</db:code> parameter.</db:para>
<db:para>In your reimplementation of this function, if you want to stop the event being handled by Qt, return true and set <db:code role="parameter">result</db:code>. The <db:code role="parameter">result</db:code> parameter has meaning only on Windows. If you return false, this native event is passed back to Qt, which translates the event into a Qt event and sends it to the widget.</db:para>
<db:note>
<db:para>Events are only delivered to this event handler if the widget has a native window handle.</db:para>
</db:note>
<db:note>
<db:para>This function superseedes the event filter functions x11Event(), winEvent() and macEvent() of Qt 4.</db:para>
</db:note>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Platform</db:para>
</db:th>
<db:th>
<db:para>Event Type Identifier</db:para>
</db:th>
<db:th>
<db:para>Message Type</db:para>
</db:th>
<db:th>
<db:para>Result Type</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Windows</db:para>
</db:td>
<db:td>
<db:para>&quot;windows_generic_MSG&quot;</db:para>
</db:td>
<db:td>
<db:para>MSG *</db:para>
</db:td>
<db:td>
<db:para>LRESULT</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>macOS</db:para>
</db:td>
<db:td>
<db:para>&quot;NSEvent&quot;</db:para>
</db:td>
<db:td>
<db:para>NSEvent *</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>XCB</db:para>
</db:td>
<db:td>
<db:para>&quot;xcb_generic_event_t&quot;</db:para>
</db:td>
<db:td>
<db:para>xcb_generic_event_t *</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractnativeeventfilter.xml">QAbstractNativeEventFilter</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nativeParentWidget">
<db:title>QWidget *QWidget::nativeParentWidget() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>nativeParentWidget</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * nativeParentWidget() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the native parent for this widget, i.e. the next ancestor widget that has a system identifier, or <db:code>nullptr</db:code> if it does not have any native parent.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#effectiveWinId">effectiveWinId</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nextInFocusChain">
<db:title>QWidget *QWidget::nextInFocusChain() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>nextInFocusChain</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * nextInFocusChain() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the next widget in this widget's focus chain.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#previousInFocusChain">previousInFocusChain</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="overrideWindowFlags">
<db:title>void QWidget::overrideWindowFlags(Qt::WindowFlags <db:emphasis>flags</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>overrideWindowFlags</db:methodname>
<db:methodparam>
<db:type>Qt::WindowFlags</db:type>
<db:parameter>flags</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void overrideWindowFlags(Qt::WindowFlags flags)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the window flags for the widget to <db:code role="parameter">flags</db:code>, <db:emphasis>without</db:emphasis> telling the window system.</db:para>
<db:warning>
<db:para>Do not call this function unless you really know what you're doing.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowFlags-prop">setWindowFlags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="paintEngine">
<db:title>[override virtual] QPaintEngine *QWidget::paintEngine() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QPaintEngine *</db:type>
<db:methodname>paintEngine</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPaintEngine * paintEngine() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qpaintdevice.xml#paintEngine" role="function">QPaintDevice::paintEngine() const</db:link>.</db:para>
<db:para>Returns the widget's paint engine.</db:para>
<db:para>Note that this function should not be called explicitly by the user, since it's meant for reimplementation purposes only. The function is called by Qt internally, and the default implementation may not always return a valid pointer.</db:para>
</db:section>
<db:section xml:id="paintEvent">
<db:title>[virtual protected] void QWidget::paintEvent(QPaintEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>paintEvent</db:methodname>
<db:methodparam>
<db:type>QPaintEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void paintEvent(QPaintEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive paint events passed in <db:code role="parameter">event</db:code>.</db:para>
<db:para>A paint event is a request to repaint all or part of a widget. It can happen for one of the following reasons:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#repaint">repaint</db:link>() or <db:link xlink:href="qwidget.xml#update">update</db:link>() was invoked,</db:para>
</db:listitem>
<db:listitem>
<db:para>the widget was obscured and has now been uncovered, or</db:para>
</db:listitem>
<db:listitem>
<db:para>many other reasons.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Many widgets can simply repaint their entire surface when asked to, but some slow widgets need to optimize by painting only the requested region: <db:link xlink:href="qpaintevent.xml#region">QPaintEvent::region</db:link>(). This speed optimization does not change the result, as painting is clipped to that region during event processing. <db:link xlink:href="qlistview.xml">QListView</db:link> and <db:link xlink:href="qtableview.xml">QTableView</db:link> do this, for example.</db:para>
<db:para>Qt also tries to speed up painting by merging multiple paint events into one. When <db:link xlink:href="qwidget.xml#update">update</db:link>() is called several times or the window system sends several paint events, Qt merges these events into one event with a larger region (see <db:link xlink:href="qregion.xml#united">QRegion::united</db:link>()). The <db:link xlink:href="qwidget.xml#repaint">repaint</db:link>() function does not permit this optimization, so we suggest using <db:link xlink:href="qwidget.xml#update">update</db:link>() whenever possible.</db:para>
<db:para>When the paint event occurs, the update region has normally been erased, so you are painting on the widget's background.</db:para>
<db:para>The background can be set using <db:link xlink:href="qwidget.xml#setBackgroundRole">setBackgroundRole</db:link>() and <db:link xlink:href="qwidget.xml#palette-prop">setPalette</db:link>().</db:para>
<db:para>Since Qt 4.0, <db:link xlink:href="qwidget.xml">QWidget</db:link> automatically double-buffers its painting, so there is no need to write double-buffering code in paintEvent() to avoid flicker.</db:para>
<db:note>
<db:para>Generally, you should refrain from calling <db:link xlink:href="qwidget.xml#update">update</db:link>() or <db:link xlink:href="qwidget.xml#repaint">repaint</db:link>() <db:emphasis role="bold">inside</db:emphasis> a paintEvent(). For example, calling <db:link xlink:href="qwidget.xml#update">update</db:link>() or <db:link xlink:href="qwidget.xml#repaint">repaint</db:link>() on children inside a paintEvent() results in undefined behavior; the child may or may not get a paint event.</db:para>
</db:note>
<db:warning>
<db:para>If you are using a custom paint engine without Qt's backingstore, <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_PaintOnScreen</db:link> must be set. Otherwise, <db:link xlink:href="qwidget.xml#paintEngine">QWidget::paintEngine</db:link>() will never be called; the backingstore will be used instead.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#repaint">repaint</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#update">update</db:link>()</db:member>
<db:member><db:link xlink:href="qpainter.xml">QPainter</db:link></db:member>
<db:member><db:link xlink:href="qpixmap.xml">QPixmap</db:link></db:member>
<db:member><db:link xlink:href="qpaintevent.xml">QPaintEvent</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-analogclock-example.xml">Analog Clock Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="parentWidget">
<db:title>QWidget *QWidget::parentWidget() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>parentWidget</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * parentWidget() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the parent of this widget, or <db:code>nullptr</db:code> if it does not have any parent widget.</db:para>
</db:section>
<db:section xml:id="previousInFocusChain">
<db:title>QWidget *QWidget::previousInFocusChain() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>previousInFocusChain</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * previousInFocusChain() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The previousInFocusChain function returns the previous widget in this widget's focus chain.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#nextInFocusChain">nextInFocusChain</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="raise">
<db:title>void QWidget::raise()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>raise</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void raise()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Raises this widget to the top of the parent widget's stack.</db:para>
<db:para>After this call the widget will be visually in front of any overlapping sibling widgets.</db:para>
<db:note>
<db:para>When using <db:link xlink:href="qwidget.xml#activateWindow">activateWindow</db:link>(), you can call this function to ensure that the window is stacked on top.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#lower">lower</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#stackUnder">stackUnder</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="releaseKeyboard">
<db:title>void QWidget::releaseKeyboard()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>releaseKeyboard</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void releaseKeyboard()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Releases the keyboard grab.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#grabKeyboard">grabKeyboard</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#grabMouse">grabMouse</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#releaseMouse">releaseMouse</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="releaseMouse">
<db:title>void QWidget::releaseMouse()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>releaseMouse</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void releaseMouse()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Releases the mouse grab.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#grabMouse">grabMouse</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#grabKeyboard">grabKeyboard</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#releaseKeyboard">releaseKeyboard</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="releaseShortcut">
<db:title>void QWidget::releaseShortcut(int <db:emphasis>id</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>releaseShortcut</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>id</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void releaseShortcut(int id)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the shortcut with the given <db:code role="parameter">id</db:code> from Qt's shortcut system. The widget will no longer receive <db:link xlink:href="qevent.xml#Type-enum">QEvent::Shortcut</db:link> events for the shortcut's key sequence (unless it has other shortcuts with the same key sequence).</db:para>
<db:warning>
<db:para>You should not normally need to use this function since Qt's shortcut system removes shortcuts automatically when their parent widget is destroyed. It is best to use <db:link xlink:href="qaction.xml">QAction</db:link> or <db:link xlink:href="qshortcut.xml">QShortcut</db:link> to handle shortcuts, since they are easier to use than this low-level function. Note also that this is an expensive operation.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#grabShortcut">grabShortcut</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#setShortcutEnabled">setShortcutEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeAction">
<db:title>void QWidget::removeAction(QAction *<db:emphasis>action</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeAction</db:methodname>
<db:methodparam>
<db:type>QAction *</db:type>
<db:parameter>action</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeAction(QAction *action)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the action <db:code role="parameter">action</db:code> from this widget's list of actions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#insertAction">insertAction</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#actions">actions</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#insertAction">insertAction</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="render">
<db:title>void QWidget::render(QPaintDevice *<db:emphasis>target</db:emphasis>, const QPoint &amp;<db:emphasis>targetOffset</db:emphasis> = QPoint(), const QRegion &amp;<db:emphasis>sourceRegion</db:emphasis> = QRegion(), QWidget::RenderFlags <db:emphasis>renderFlags</db:emphasis> = RenderFlags(DrawWindowBackground | DrawChildren))</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>render</db:methodname>
<db:methodparam>
<db:type>QPaintDevice *</db:type>
<db:parameter>target</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>targetOffset</db:parameter>
<db:initializer>QPoint()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QRegion &amp;</db:type>
<db:parameter>sourceRegion</db:parameter>
<db:initializer>QRegion()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QWidget::RenderFlags</db:type>
<db:parameter>renderFlags</db:parameter>
<db:initializer>RenderFlags(DrawWindowBackground | DrawChildren)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void render(QPaintDevice *target, const QPoint &amp;targetOffset, const QRegion &amp;sourceRegion, QWidget::RenderFlags renderFlags)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Renders the <db:code role="parameter">sourceRegion</db:code> of this widget into the <db:code role="parameter">target</db:code> using <db:code role="parameter">renderFlags</db:code> to determine how to render. Rendering starts at <db:code role="parameter">targetOffset</db:code> in the <db:code role="parameter">target</db:code>. For example:</db:para>
<db:programlisting language="cpp">QPixmap pixmap(widget-&amp;gt;size());
widget-&amp;gt;render(&amp;amp;pixmap);
</db:programlisting>
<db:para>If <db:code role="parameter">sourceRegion</db:code> is a null region, this function will use <db:link xlink:href="qwidget.xml#rect-prop">QWidget::rect</db:link>() as the region, i.e. the entire widget.</db:para>
<db:para>Ensure that you call <db:link xlink:href="qpainter.xml#end">QPainter::end</db:link>() for the <db:code role="parameter">target</db:code> device's active painter (if any) before rendering. For example:</db:para>
<db:programlisting language="cpp">QPainter painter(this);
...
painter.end();
myWidget-&amp;gt;render(this);
</db:programlisting>
<db:note>
<db:para>To obtain the contents of a <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>, use <db:link xlink:href="qopenglwidget.xml#grabFramebuffer">QOpenGLWidget::grabFramebuffer</db:link>() instead.</db:para>
</db:note>
</db:section>
<db:section xml:id="render-1">
<db:title>void QWidget::render(QPainter *<db:emphasis>painter</db:emphasis>, const QPoint &amp;<db:emphasis>targetOffset</db:emphasis> = QPoint(), const QRegion &amp;<db:emphasis>sourceRegion</db:emphasis> = QRegion(), QWidget::RenderFlags <db:emphasis>renderFlags</db:emphasis> = RenderFlags(DrawWindowBackground | DrawChildren))</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>render</db:methodname>
<db:methodparam>
<db:type>QPainter *</db:type>
<db:parameter>painter</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>targetOffset</db:parameter>
<db:initializer>QPoint()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QRegion &amp;</db:type>
<db:parameter>sourceRegion</db:parameter>
<db:initializer>QRegion()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QWidget::RenderFlags</db:type>
<db:parameter>renderFlags</db:parameter>
<db:initializer>RenderFlags(DrawWindowBackground | DrawChildren)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void render(QPainter *painter, const QPoint &amp;targetOffset, const QRegion &amp;sourceRegion, QWidget::RenderFlags renderFlags)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Renders the widget into the <db:code role="parameter">painter</db:code>'s <db:link xlink:href="qpainter.xml#device">QPainter::device</db:link>().</db:para>
<db:para>Transformations and settings applied to the <db:code role="parameter">painter</db:code> will be used when rendering.</db:para>
<db:note>
<db:para>The <db:code role="parameter">painter</db:code> must be active. On macOS the widget will be rendered into a <db:link xlink:href="qpixmap.xml">QPixmap</db:link> and then drawn by the <db:code role="parameter">painter</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qpainter.xml#device">QPainter::device</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="repaint">
<db:title>void QWidget::repaint()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>repaint</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void repaint()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Repaints the widget directly by calling <db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>() immediately, unless updates are disabled or the widget is hidden.</db:para>
<db:para>We suggest only using repaint() if you need an immediate repaint, for example during animation. In almost all circumstances <db:link xlink:href="qwidget.xml#update">update</db:link>() is better, as it permits Qt to optimize for speed and minimize flicker.</db:para>
<db:warning>
<db:para>If you call repaint() in a function which may itself be called from <db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>(), you may get infinite recursion. The <db:link xlink:href="qwidget.xml#update">update</db:link>() function never causes recursion.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#update">update</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#updatesEnabled-prop">setUpdatesEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="repaint-1">
<db:title>void QWidget::repaint(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>, int <db:emphasis>w</db:emphasis>, int <db:emphasis>h</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>repaint</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>w</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>h</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void repaint(int x, int y, int w, int h)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This version repaints a rectangle (<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>, <db:code role="parameter">w</db:code>, <db:code role="parameter">h</db:code>) inside the widget.</db:para>
<db:para>If <db:code role="parameter">w</db:code> is negative, it is replaced with <db:code>width() - x</db:code>, and if <db:code role="parameter">h</db:code> is negative, it is replaced width <db:code>height() - y</db:code>.</db:para>
</db:section>
<db:section xml:id="repaint-2">
<db:title>void QWidget::repaint(const QRect &amp;<db:emphasis>rect</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>repaint</db:methodname>
<db:methodparam>
<db:type>const QRect &amp;</db:type>
<db:parameter>rect</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void repaint(const QRect &amp;rect)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This version repaints a rectangle <db:code role="parameter">rect</db:code> inside the widget.</db:para>
</db:section>
<db:section xml:id="repaint-3">
<db:title>void QWidget::repaint(const QRegion &amp;<db:emphasis>rgn</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>repaint</db:methodname>
<db:methodparam>
<db:type>const QRegion &amp;</db:type>
<db:parameter>rgn</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void repaint(const QRegion &amp;rgn)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This version repaints a region <db:code role="parameter">rgn</db:code> inside the widget.</db:para>
</db:section>
<db:section xml:id="resize-1">
<db:title>void QWidget::resize(int <db:emphasis>w</db:emphasis>, int <db:emphasis>h</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resize</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>w</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>h</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="associated-property">size</db:synopsisinfo>
<db:synopsisinfo role="signature">void resize(int w, int h)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This corresponds to resize(<db:link xlink:href="qsize.xml">QSize</db:link>(<db:code role="parameter">w</db:code>, <db:code role="parameter">h</db:code>)).</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qwidget.xml#size-prop">size</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="resizeEvent">
<db:title>[virtual protected] void QWidget::resizeEvent(QResizeEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>resizeEvent</db:methodname>
<db:methodparam>
<db:type>QResizeEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resizeEvent(QResizeEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive widget resize events which are passed in the <db:code role="parameter">event</db:code> parameter. When resizeEvent() is called, the widget already has its new geometry. The old size is accessible through <db:link xlink:href="qresizeevent.xml#oldSize">QResizeEvent::oldSize</db:link>().</db:para>
<db:para>The widget will be erased and receive a paint event immediately after processing the resize event. No drawing need be (or should be) done inside this handler.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#moveEvent">moveEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#size-prop">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qresizeevent.xml">QResizeEvent</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-scribble-example.xml">Scribble Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="restoreGeometry">
<db:title>bool QWidget::restoreGeometry(const QByteArray &amp;<db:emphasis>geometry</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>restoreGeometry</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>geometry</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool restoreGeometry(const QByteArray &amp;geometry)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Restores the geometry and state of top-level widgets stored in the byte array <db:code role="parameter">geometry</db:code>. Returns <db:code>true</db:code> on success; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>If the restored geometry is off-screen, it will be modified to be inside the available screen geometry.</db:para>
<db:para>To restore geometry saved using <db:link xlink:href="qsettings.xml">QSettings</db:link>, you can use code like this:</db:para>
<db:programlisting language="cpp">QSettings settings(&quot;MyCompany&quot;, &quot;MyApp&quot;);
myWidget-&amp;gt;restoreGeometry(settings.value(&quot;myWidget/geometry&quot;).toByteArray());
</db:programlisting>
<db:para>See the <db:link xlink:href="application-windows.xml#window-geometry">Window Geometry</db:link> documentation for an overview of geometry issues with windows.</db:para>
<db:para>Use <db:link xlink:href="qmainwindow.xml#restoreState">QMainWindow::restoreState</db:link>() to restore the geometry and the state of toolbars and dock widgets.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#saveGeometry">saveGeometry</db:link>()</db:member>
<db:member><db:link xlink:href="qsettings.xml">QSettings</db:link></db:member>
<db:member><db:link xlink:href="qmainwindow.xml#saveState">QMainWindow::saveState</db:link>()</db:member>
<db:member><db:link xlink:href="qmainwindow.xml#restoreState">QMainWindow::restoreState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="saveGeometry">
<db:title>QByteArray QWidget::saveGeometry() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>saveGeometry</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray saveGeometry() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Saves the current geometry and state for top-level widgets.</db:para>
<db:para>To save the geometry when the window closes, you can implement a close event like this:</db:para>
<db:programlisting language="cpp">void MyWidget::closeEvent(QCloseEvent *event)
{
    QSettings settings(&quot;MyCompany&quot;, &quot;MyApp&quot;);
    settings.setValue(&quot;geometry&quot;, saveGeometry());
    QWidget::closeEvent(event);
}
</db:programlisting>
<db:para>See the <db:link xlink:href="application-windows.xml#window-geometry">Window Geometry</db:link> documentation for an overview of geometry issues with windows.</db:para>
<db:para>Use <db:link xlink:href="qmainwindow.xml#saveState">QMainWindow::saveState</db:link>() to save the geometry and the state of toolbars and dock widgets.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#restoreGeometry">restoreGeometry</db:link>()</db:member>
<db:member><db:link xlink:href="qmainwindow.xml#saveState">QMainWindow::saveState</db:link>()</db:member>
<db:member><db:link xlink:href="qmainwindow.xml#restoreState">QMainWindow::restoreState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="screen">
<db:title>[since 5.14] QScreen *QWidget::screen() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QScreen *</db:type>
<db:methodname>screen</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QScreen * screen() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the screen the widget is on.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setScreen">setScreen</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#windowHandle">windowHandle</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="scroll">
<db:title>void QWidget::scroll(int <db:emphasis>dx</db:emphasis>, int <db:emphasis>dy</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>scroll</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>dx</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>dy</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void scroll(int dx, int dy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Scrolls the widget including its children <db:code role="parameter">dx</db:code> pixels to the right and <db:code role="parameter">dy</db:code> downward. Both <db:code role="parameter">dx</db:code> and <db:code role="parameter">dy</db:code> may be negative.</db:para>
<db:para>After scrolling, the widgets will receive paint events for the areas that need to be repainted. For widgets that Qt knows to be opaque, this is only the newly exposed parts. For example, if an opaque widget is scrolled 8 pixels to the left, only an 8-pixel wide stripe at the right edge needs updating.</db:para>
<db:para>Since widgets propagate the contents of their parents by default, you need to set the <db:link xlink:href="qwidget.xml#autoFillBackground-prop">autoFillBackground</db:link> property, or use <db:link xlink:href="qwidget.xml#setAttribute">setAttribute</db:link>() to set the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</db:link> attribute, to make a widget opaque.</db:para>
<db:para>For widgets that use contents propagation, a scroll will cause an update of the entire scroll area.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#transparency-and-double-buffering">Transparency and Double Buffering</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="scroll-1">
<db:title>void QWidget::scroll(int <db:emphasis>dx</db:emphasis>, int <db:emphasis>dy</db:emphasis>, const QRect &amp;<db:emphasis>r</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>scroll</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>dx</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>dy</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRect &amp;</db:type>
<db:parameter>r</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void scroll(int dx, int dy, const QRect &amp;r)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This version only scrolls <db:code role="parameter">r</db:code> and does not move the children of the widget.</db:para>
<db:para>If <db:code role="parameter">r</db:code> is empty or invalid, the result is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qscrollarea.xml">QScrollArea</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAttribute">
<db:title>void QWidget::setAttribute(Qt::WidgetAttribute <db:emphasis>attribute</db:emphasis>, bool <db:emphasis>on</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setAttribute</db:methodname>
<db:methodparam>
<db:type>Qt::WidgetAttribute</db:type>
<db:parameter>attribute</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>on</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setAttribute(Qt::WidgetAttribute attribute, bool on)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the attribute <db:code role="parameter">attribute</db:code> on this widget if <db:code role="parameter">on</db:code> is true; otherwise clears the attribute.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#testAttribute">testAttribute</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setBackgroundRole">
<db:title>void QWidget::setBackgroundRole(QPalette::ColorRole <db:emphasis>role</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setBackgroundRole</db:methodname>
<db:methodparam>
<db:type>QPalette::ColorRole</db:type>
<db:parameter>role</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setBackgroundRole(QPalette::ColorRole role)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the background role of the widget to <db:code role="parameter">role</db:code>.</db:para>
<db:para>The background role defines the brush from the widget's <db:link xlink:href="qwidget.xml#palette-prop">palette</db:link> that is used to render the background.</db:para>
<db:para>If <db:code role="parameter">role</db:code> is <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::NoRole</db:link>, then the widget inherits its parent's background role.</db:para>
<db:para>Note that styles are free to choose any color from the palette. You can modify the palette or set a style sheet if you don't achieve the result you want with setBackgroundRole().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#backgroundRole">backgroundRole</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#foregroundRole">foregroundRole</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setBaseSize-1">
<db:title>void QWidget::setBaseSize(int <db:emphasis>basew</db:emphasis>, int <db:emphasis>baseh</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setBaseSize</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>basew</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>baseh</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="associated-property">baseSize</db:synopsisinfo>
<db:synopsisinfo role="signature">void setBaseSize(int basew, int baseh)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This corresponds to <db:link xlink:href="qwidget.xml#baseSize-prop">setBaseSize</db:link>(<db:link xlink:href="qsize.xml">QSize</db:link>(<db:code role="parameter">basew</db:code>, <db:code role="parameter">baseh</db:code>)). Sets the widgets base size to width <db:code role="parameter">basew</db:code> and height <db:code role="parameter">baseh</db:code>.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qwidget.xml#baseSize-prop">baseSize</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="setContentsMargins">
<db:title>void QWidget::setContentsMargins(int <db:emphasis>left</db:emphasis>, int <db:emphasis>top</db:emphasis>, int <db:emphasis>right</db:emphasis>, int <db:emphasis>bottom</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setContentsMargins</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>top</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>bottom</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setContentsMargins(int left, int top, int right, int bottom)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the margins around the contents of the widget to have the sizes <db:code role="parameter">left</db:code>, <db:code role="parameter">top</db:code>, <db:code role="parameter">right</db:code>, and <db:code role="parameter">bottom</db:code>. The margins are used by the layout system, and may be used by subclasses to specify the area to draw in (e.g. excluding the frame).</db:para>
<db:para>Changing the margins will trigger a <db:link xlink:href="qwidget.xml#resizeEvent">resizeEvent</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#contentsRect">contentsRect</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#contentsMargins">contentsMargins</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setContentsMargins-1">
<db:title>void QWidget::setContentsMargins(const QMargins &amp;<db:emphasis>margins</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setContentsMargins</db:methodname>
<db:methodparam>
<db:type>const QMargins &amp;</db:type>
<db:parameter>margins</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setContentsMargins(const QMargins &amp;margins)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:link xlink:href="qwidget.xml#setContentsMargins">setContentsMargins</db:link> function sets the margins around the widget's contents.</db:para>
<db:para>Sets the margins around the contents of the widget to have the sizes determined by <db:code role="parameter">margins</db:code>. The margins are used by the layout system, and may be used by subclasses to specify the area to draw in (e.g. excluding the frame).</db:para>
<db:para>Changing the margins will trigger a <db:link xlink:href="qwidget.xml#resizeEvent">resizeEvent</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#contentsRect">contentsRect</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#contentsMargins">contentsMargins</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDisabled">
<db:title>void QWidget::setDisabled(bool <db:emphasis>disable</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDisabled</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>disable</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDisabled(bool disable)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Disables widget input events if <db:code role="parameter">disable</db:code> is true; otherwise enables input events.</db:para>
<db:para>See the <db:link xlink:href="qwidget.xml#enabled-prop">enabled</db:link> documentation for more information.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#isEnabledTo">isEnabledTo</db:link>()</db:member>
<db:member><db:link xlink:href="qkeyevent.xml">QKeyEvent</db:link></db:member>
<db:member><db:link xlink:href="qmouseevent.xml">QMouseEvent</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#changeEvent">changeEvent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setEditFocus">
<db:title>void QWidget::setEditFocus(bool <db:emphasis>enable</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setEditFocus</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enable</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setEditFocus(bool enable)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">enable</db:code> is true, make this widget have edit focus, in which case <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Up</db:link> and <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Down</db:link> will be delivered to the widget normally; otherwise, <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Up</db:link> and <db:link xlink:href="qt.xml#Key-enum">Qt::Key_Down</db:link> are used to change focus.</db:para>
<db:para>This feature is only available in Qt for Embedded Linux.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#hasEditFocus">hasEditFocus</db:link>()</db:member>
<db:member><db:link xlink:href="qapplication.xml#navigationMode">QApplication::navigationMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFixedHeight">
<db:title>void QWidget::setFixedHeight(int <db:emphasis>h</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFixedHeight</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>h</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFixedHeight(int h)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets both the minimum and maximum heights of the widget to <db:code role="parameter">h</db:code> without changing the widths. Provided for convenience.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#setFixedSize">setFixedSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFixedSize">
<db:title>void QWidget::setFixedSize(const QSize &amp;<db:emphasis>s</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFixedSize</db:methodname>
<db:methodparam>
<db:type>const QSize &amp;</db:type>
<db:parameter>s</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFixedSize(const QSize &amp;s)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets both the minimum and maximum sizes of the widget to <db:code role="parameter">s</db:code>, thereby preventing it from ever growing or shrinking.</db:para>
<db:para>This will override the default size constraints set by <db:link xlink:href="qlayout.xml">QLayout</db:link>.</db:para>
<db:para>To remove constraints, set the size to <db:link xlink:href="qwidget.xml#QWIDGETSIZE_MAX">QWIDGETSIZE_MAX</db:link>.</db:para>
<db:para>Alternatively, if you want the widget to have a fixed size based on its contents, you can call <db:link xlink:href="qlayout.xml#sizeConstraint-prop">QLayout::setSizeConstraint</db:link>(<db:link xlink:href="qlayout.xml#SizeConstraint-enum">QLayout::SetFixedSize</db:link>);</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFixedSize-1">
<db:title>void QWidget::setFixedSize(int <db:emphasis>w</db:emphasis>, int <db:emphasis>h</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFixedSize</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>w</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>h</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFixedSize(int w, int h)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the width of the widget to <db:code role="parameter">w</db:code> and the height to <db:code role="parameter">h</db:code>.</db:para>
</db:section>
<db:section xml:id="setFixedWidth">
<db:title>void QWidget::setFixedWidth(int <db:emphasis>w</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFixedWidth</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>w</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFixedWidth(int w)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets both the minimum and maximum width of the widget to <db:code role="parameter">w</db:code> without changing the heights. Provided for convenience.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#setFixedSize">setFixedSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFocus">
<db:title>void QWidget::setFocus(Qt::FocusReason <db:emphasis>reason</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFocus</db:methodname>
<db:methodparam>
<db:type>Qt::FocusReason</db:type>
<db:parameter>reason</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFocus(Qt::FocusReason reason)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Gives the keyboard input focus to this widget (or its focus proxy) if this widget or one of its parents is the <db:link xlink:href="qwidget.xml#isActiveWindow-prop">active window</db:link>. The <db:code role="parameter">reason</db:code> argument will be passed into any focus event sent from this function, it is used to give an explanation of what caused the widget to get focus. If the window is not active, the widget will be given the focus when the window becomes active.</db:para>
<db:para>First, a focus about to change event is sent to the focus widget (if any) to tell it that it is about to lose the focus. Then focus is changed, a focus out event is sent to the previous focus item and a focus in event is sent to the new item to tell it that it just received the focus. (Nothing happens if the focus in and focus out widgets are the same.)</db:para>
<db:note>
<db:para>On embedded platforms, <db:link xlink:href="qwidget.xml#setFocus-1">setFocus</db:link>() will not cause an input panel to be opened by the input method. If you want this to happen, you have to send a <db:link xlink:href="qevent.xml#Type-enum">QEvent::RequestSoftwareInputPanel</db:link> event to the widget yourself.</db:para>
</db:note>
<db:para><db:link xlink:href="qwidget.xml#setFocus-1">setFocus</db:link>() gives focus to a widget regardless of its focus policy, but does not clear any keyboard grab (see <db:link xlink:href="qwidget.xml#grabKeyboard">grabKeyboard</db:link>()).</db:para>
<db:para>Be aware that if the widget is hidden, it will not accept focus until it is shown.</db:para>
<db:warning>
<db:para>If you call <db:link xlink:href="qwidget.xml#setFocus-1">setFocus</db:link>() in a function which may itself be called from <db:link xlink:href="qwidget.xml#focusOutEvent">focusOutEvent</db:link>() or <db:link xlink:href="qwidget.xml#focusInEvent">focusInEvent</db:link>(), you may get an infinite recursion.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#focus-prop">hasFocus</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#clearFocus">clearFocus</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusInEvent">focusInEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusOutEvent">focusOutEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#focusWidget">focusWidget</db:link>()</db:member>
<db:member><db:link xlink:href="qapplication.xml#focusWidget">QApplication::focusWidget</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#grabKeyboard">grabKeyboard</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#grabMouse">grabMouse</db:link>()</db:member>
<db:member><db:link xlink:href="focus.xml">Keyboard Focus in Widgets</db:link></db:member>
<db:member><db:link xlink:href="qevent.xml#Type-enum">QEvent::RequestSoftwareInputPanel</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFocus-1">
<db:title>void QWidget::setFocus()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFocus</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFocus()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Gives the keyboard input focus to this widget (or its focus proxy) if this widget or one of its parents is the <db:link xlink:href="qwidget.xml#isActiveWindow-prop">active window</db:link>.</db:para>
</db:section>
<db:section xml:id="setFocusProxy">
<db:title>void QWidget::setFocusProxy(QWidget *<db:emphasis>w</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFocusProxy</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>w</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFocusProxy(QWidget *w)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the widget's focus proxy to widget <db:code role="parameter">w</db:code>. If <db:code role="parameter">w</db:code> is <db:code>nullptr</db:code>, the function resets this widget to have no focus proxy.</db:para>
<db:para>Some widgets can &quot;have focus&quot;, but create a child widget, such as <db:link xlink:href="qlineedit.xml">QLineEdit</db:link>, to actually handle the focus. In this case, the widget can set the line edit to be its focus proxy.</db:para>
<db:para>setFocusProxy() sets the widget which will actually get focus when &quot;this widget&quot; gets it. If there is a focus proxy, <db:link xlink:href="qwidget.xml#setFocus-1">setFocus</db:link>() and <db:link xlink:href="qwidget.xml#focus-prop">hasFocus</db:link>() operate on the focus proxy. If &quot;this widget&quot; is the focus widget, then setFocusProxy() moves focus to the new focus proxy.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#focusProxy">focusProxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setForegroundRole">
<db:title>void QWidget::setForegroundRole(QPalette::ColorRole <db:emphasis>role</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setForegroundRole</db:methodname>
<db:methodparam>
<db:type>QPalette::ColorRole</db:type>
<db:parameter>role</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setForegroundRole(QPalette::ColorRole role)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the foreground role of the widget to <db:code role="parameter">role</db:code>.</db:para>
<db:para>The foreground role defines the color from the widget's <db:link xlink:href="qwidget.xml#palette-prop">palette</db:link> that is used to draw the foreground.</db:para>
<db:para>If <db:code role="parameter">role</db:code> is <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::NoRole</db:link>, the widget uses a foreground role that contrasts with the background role.</db:para>
<db:para>Note that styles are free to choose any color from the palette. You can modify the palette or set a style sheet if you don't achieve the result you want with setForegroundRole().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#foregroundRole">foregroundRole</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#backgroundRole">backgroundRole</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setGeometry-1">
<db:title>void QWidget::setGeometry(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>, int <db:emphasis>w</db:emphasis>, int <db:emphasis>h</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setGeometry</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>w</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>h</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="associated-property">geometry</db:synopsisinfo>
<db:synopsisinfo role="signature">void setGeometry(int x, int y, int w, int h)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This corresponds to <db:link xlink:href="qwidget.xml#geometry-prop">setGeometry</db:link>(<db:link xlink:href="qrect.xml">QRect</db:link>(<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>, <db:code role="parameter">w</db:code>, <db:code role="parameter">h</db:code>)).</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qwidget.xml#geometry-prop">geometry</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="setGraphicsEffect">
<db:title>void QWidget::setGraphicsEffect(QGraphicsEffect *<db:emphasis>effect</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setGraphicsEffect</db:methodname>
<db:methodparam>
<db:type>QGraphicsEffect *</db:type>
<db:parameter>effect</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setGraphicsEffect(QGraphicsEffect *effect)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The setGraphicsEffect function is for setting the widget's graphics effect.</db:para>
<db:para>Sets <db:code role="parameter">effect</db:code> as the widget's effect. If there already is an effect installed on this widget, <db:link xlink:href="qwidget.xml">QWidget</db:link> will delete the existing effect before installing the new <db:code role="parameter">effect</db:code>.</db:para>
<db:para>If <db:code role="parameter">effect</db:code> is the installed effect on a different widget, setGraphicsEffect() will remove the effect from the widget and install it on this widget.</db:para>
<db:para><db:link xlink:href="qwidget.xml">QWidget</db:link> takes ownership of <db:code role="parameter">effect</db:code>.</db:para>
<db:note>
<db:para>This function will apply the effect on itself and all its children.</db:para>
</db:note>
<db:note>
<db:para>Graphics effects are not supported for OpenGL-based widgets, such as QGLWidget, <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> and <db:link xlink:href="qquickwidget.xml">QQuickWidget</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#graphicsEffect">graphicsEffect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setHidden">
<db:title>void QWidget::setHidden(bool <db:emphasis>hidden</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setHidden</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>hidden</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setHidden(bool hidden)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Convenience function, equivalent to <db:link xlink:href="qwidget.xml#visible-prop">setVisible</db:link>(!<db:code role="parameter">hidden</db:code>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#isHidden">isHidden</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setLayout">
<db:title>void QWidget::setLayout(QLayout *<db:emphasis>layout</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setLayout</db:methodname>
<db:methodparam>
<db:type>QLayout *</db:type>
<db:parameter>layout</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setLayout(QLayout *layout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the layout manager for this widget to <db:code role="parameter">layout</db:code>.</db:para>
<db:para>If there already is a layout manager installed on this widget, <db:link xlink:href="qwidget.xml">QWidget</db:link> won't let you install another. You must first delete the existing layout manager (returned by <db:link xlink:href="qwidget.xml#layout">layout</db:link>()) before you can call setLayout() with the new layout.</db:para>
<db:para>If <db:code role="parameter">layout</db:code> is the layout manager on a different widget, setLayout() will reparent the layout and make it the layout manager for this widget.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">    QVBoxLayout *layout = new QVBoxLayout;
    layout-&amp;gt;addWidget(formWidget);
    setLayout(layout);
</db:programlisting>
<db:para>An alternative to calling this function is to pass this widget to the layout's constructor.</db:para>
<db:para>The <db:link xlink:href="qwidget.xml">QWidget</db:link> will take ownership of <db:code role="parameter">layout</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#layout">layout</db:link>()</db:member>
<db:member><db:link xlink:href="layout.xml">Layout Management</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMask">
<db:title>void QWidget::setMask(const QBitmap &amp;<db:emphasis>bitmap</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setMask</db:methodname>
<db:methodparam>
<db:type>const QBitmap &amp;</db:type>
<db:parameter>bitmap</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setMask(const QBitmap &amp;bitmap)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Causes only the pixels of the widget for which <db:code role="parameter">bitmap</db:code> has a corresponding 1 bit to be visible. If the region includes pixels outside the <db:link xlink:href="qwidget.xml#rect-prop">rect</db:link>() of the widget, window system controls in that area may or may not be visible, depending on the platform.</db:para>
<db:para>Note that this effect can be slow if the region is particularly complex.</db:para>
<db:para>The following code shows how an image with an alpha channel can be used to generate a mask for a widget:</db:para>
<db:programlisting language="cpp">    QLabel topLevelLabel;
    QPixmap pixmap(&quot;:/images/tux.png&quot;);
    topLevelLabel.setPixmap(pixmap);
    topLevelLabel.setMask(pixmap.mask());
</db:programlisting>
<db:para>The label shown by this code is masked using the image it contains, giving the appearance that an irregularly-shaped image is being drawn directly onto the screen.</db:para>
<db:para>Masked widgets receive mouse events only on their visible portions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#mask">mask</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#clearMask">clearMask</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#windowOpacity-prop">windowOpacity</db:link>()</db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-shapedclock-example.xml">Shaped Clock Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMask-1">
<db:title>void QWidget::setMask(const QRegion &amp;<db:emphasis>region</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setMask</db:methodname>
<db:methodparam>
<db:type>const QRegion &amp;</db:type>
<db:parameter>region</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setMask(const QRegion &amp;region)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Causes only the parts of the widget which overlap <db:code role="parameter">region</db:code> to be visible. If the region includes pixels outside the <db:link xlink:href="qwidget.xml#rect-prop">rect</db:link>() of the widget, window system controls in that area may or may not be visible, depending on the platform.</db:para>
<db:para>Note that this effect can be slow if the region is particularly complex.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowOpacity-prop">windowOpacity</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMaximumSize-1">
<db:title>void QWidget::setMaximumSize(int <db:emphasis>maxw</db:emphasis>, int <db:emphasis>maxh</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setMaximumSize</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>maxw</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>maxh</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="associated-property">maximumSize</db:synopsisinfo>
<db:synopsisinfo role="signature">void setMaximumSize(int maxw, int maxh)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function corresponds to <db:link xlink:href="qwidget.xml#maximumSize-prop">setMaximumSize</db:link>(<db:link xlink:href="qsize.xml">QSize</db:link>(<db:code role="parameter">maxw</db:code>, <db:code role="parameter">maxh</db:code>)). Sets the maximum width to <db:code role="parameter">maxw</db:code> and the maximum height to <db:code role="parameter">maxh</db:code>.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qwidget.xml#maximumSize-prop">maximumSize</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="setMinimumSize-1">
<db:title>void QWidget::setMinimumSize(int <db:emphasis>minw</db:emphasis>, int <db:emphasis>minh</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setMinimumSize</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>minw</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>minh</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="associated-property">minimumSize</db:synopsisinfo>
<db:synopsisinfo role="signature">void setMinimumSize(int minw, int minh)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function corresponds to <db:link xlink:href="qwidget.xml#minimumSize-prop">setMinimumSize</db:link>(<db:link xlink:href="qsize.xml">QSize</db:link>(minw, minh)). Sets the minimum width to <db:code role="parameter">minw</db:code> and the minimum height to <db:code role="parameter">minh</db:code>.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qwidget.xml#minimumSize-prop">minimumSize</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="setParent">
<db:title>void QWidget::setParent(QWidget *<db:emphasis>parent</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setParent</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>parent</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setParent(QWidget *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the parent of the widget to <db:code role="parameter">parent</db:code>, and resets the window flags. The widget is moved to position (0, 0) in its new parent.</db:para>
<db:para>If the new parent widget is in a different window, the reparented widget and its children are appended to the end of the <db:link xlink:href="qwidget.xml#focusPolicy-prop">tab chain</db:link> of the new parent widget, in the same internal order as before. If one of the moved widgets had keyboard focus, setParent() calls <db:link xlink:href="qwidget.xml#clearFocus">clearFocus</db:link>() for that widget.</db:para>
<db:para>If the new parent widget is in the same window as the old parent, setting the parent doesn't change the tab order or keyboard focus.</db:para>
<db:para>If the &quot;new&quot; parent widget is the old parent widget, this function does nothing.</db:para>
<db:note>
<db:para>The widget becomes invisible as part of changing its parent, even if it was previously visible. You must call <db:link xlink:href="qwidget.xml#show">show</db:link>() to make the widget visible again.</db:para>
</db:note>
<db:warning>
<db:para>It is very unlikely that you will ever need this function. If you have a widget that changes its content dynamically, it is far easier to use <db:link xlink:href="qstackedwidget.xml">QStackedWidget</db:link>.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowFlags-prop">setWindowFlags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setParent-1">
<db:title>void QWidget::setParent(QWidget *<db:emphasis>parent</db:emphasis>, Qt::WindowFlags <db:emphasis>f</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setParent</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>parent</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::WindowFlags</db:type>
<db:parameter>f</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setParent(QWidget *parent, Qt::WindowFlags f)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function also takes widget flags, <db:code role="parameter">f</db:code> as an argument.</db:para>
</db:section>
<db:section xml:id="setScreen">
<db:title>void QWidget::setScreen(QScreen *<db:emphasis>screen</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setScreen</db:methodname>
<db:methodparam>
<db:type>QScreen *</db:type>
<db:parameter>screen</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setScreen(QScreen *screen)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the screen on which the widget should be shown to <db:code role="parameter">screen</db:code>.</db:para>
<db:para>Setting the screen only makes sense for windows. If necessary, the widget's window will get recreated on <db:code role="parameter">screen</db:code>.</db:para>
<db:note>
<db:para>If the screen is part of a virtual desktop of multiple screens, the window will not move automatically to <db:code role="parameter">screen</db:code>. To place the window relative to the screen, use the screen's topLeft() position.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#screen">screen</db:link>()</db:member>
<db:member><db:link xlink:href="qwindow.xml#setScreen">QWindow::setScreen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setShortcutAutoRepeat">
<db:title>void QWidget::setShortcutAutoRepeat(int <db:emphasis>id</db:emphasis>, bool <db:emphasis>enable</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setShortcutAutoRepeat</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>id</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enable</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setShortcutAutoRepeat(int id, bool enable)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">enable</db:code> is true, auto repeat of the shortcut with the given <db:code role="parameter">id</db:code> is enabled; otherwise it is disabled.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#grabShortcut">grabShortcut</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#releaseShortcut">releaseShortcut</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setShortcutEnabled">
<db:title>void QWidget::setShortcutEnabled(int <db:emphasis>id</db:emphasis>, bool <db:emphasis>enable</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setShortcutEnabled</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>id</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enable</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setShortcutEnabled(int id, bool enable)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">enable</db:code> is true, the shortcut with the given <db:code role="parameter">id</db:code> is enabled; otherwise the shortcut is disabled.</db:para>
<db:warning>
<db:para>You should not normally need to use this function since Qt's shortcut system enables/disables shortcuts automatically as widgets become hidden/visible and gain or lose focus. It is best to use <db:link xlink:href="qaction.xml">QAction</db:link> or <db:link xlink:href="qshortcut.xml">QShortcut</db:link> to handle shortcuts, since they are easier to use than this low-level function.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#grabShortcut">grabShortcut</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#releaseShortcut">releaseShortcut</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSizeIncrement-1">
<db:title>void QWidget::setSizeIncrement(int <db:emphasis>w</db:emphasis>, int <db:emphasis>h</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSizeIncrement</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>w</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>h</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="associated-property">sizeIncrement</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSizeIncrement(int w, int h)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the x (width) size increment to <db:code role="parameter">w</db:code> and the y (height) size increment to <db:code role="parameter">h</db:code>.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qwidget.xml#sizeIncrement-prop">sizeIncrement</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="setSizePolicy-1">
<db:title>void QWidget::setSizePolicy(QSizePolicy::Policy <db:emphasis>horizontal</db:emphasis>, QSizePolicy::Policy <db:emphasis>vertical</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSizePolicy</db:methodname>
<db:methodparam>
<db:type>QSizePolicy::Policy</db:type>
<db:parameter>horizontal</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSizePolicy::Policy</db:type>
<db:parameter>vertical</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="associated-property">sizePolicy</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSizePolicy(QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the size policy of the widget to <db:code role="parameter">horizontal</db:code> and <db:code role="parameter">vertical</db:code>, with standard stretch and no height-for-width.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qwidget.xml#sizePolicy-prop">sizePolicy</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsizepolicy.xml#QSizePolicy">QSizePolicy::QSizePolicy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setStyle">
<db:title>void QWidget::setStyle(QStyle *<db:emphasis>style</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setStyle</db:methodname>
<db:methodparam>
<db:type>QStyle *</db:type>
<db:parameter>style</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setStyle(QStyle *style)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the widget's GUI style to <db:code role="parameter">style</db:code>. The ownership of the style object is not transferred.</db:para>
<db:para>If no style is set, the widget uses the application's style, <db:link xlink:href="qapplication.xml#style">QApplication::style</db:link>() instead.</db:para>
<db:para>Setting a widget's style has no effect on existing or future child widgets.</db:para>
<db:warning>
<db:para>This function is particularly useful for demonstration purposes, where you want to show Qt's styling capabilities. Real applications should avoid it and use one consistent GUI style instead.</db:para>
</db:warning>
<db:warning>
<db:para>Qt style sheets are currently not supported for custom <db:link xlink:href="qstyle.xml">QStyle</db:link> subclasses. We plan to address this in some future release.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#style">style</db:link>()</db:member>
<db:member><db:link xlink:href="qstyle.xml">QStyle</db:link></db:member>
<db:member><db:link xlink:href="qapplication.xml#style">QApplication::style</db:link>()</db:member>
<db:member><db:link xlink:href="qapplication.xml#setStyle">QApplication::setStyle</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setTabOrder">
<db:title>[static] void QWidget::setTabOrder(QWidget *<db:emphasis>first</db:emphasis>, QWidget *<db:emphasis>second</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>setTabOrder</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>first</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>second</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setTabOrder(QWidget *first, QWidget *second)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Puts the <db:code role="parameter">second</db:code> widget after the <db:code role="parameter">first</db:code> widget in the focus order.</db:para>
<db:para>It effectively removes the <db:code role="parameter">second</db:code> widget from its focus chain and inserts it after the <db:code role="parameter">first</db:code> widget.</db:para>
<db:para>Note that since the tab order of the <db:code role="parameter">second</db:code> widget is changed, you should order a chain like this:</db:para>
<db:programlisting language="cpp">setTabOrder(a, b); // a to b
setTabOrder(b, c); // a to b to c
setTabOrder(c, d); // a to b to c to d
</db:programlisting>
<db:para><db:emphasis>not</db:emphasis> like this:</db:para>
<db:programlisting language="cpp">// WRONG
setTabOrder(c, d); // c to d
setTabOrder(a, b); // a to b AND c to d
setTabOrder(b, c); // a to b to c, but not c to d
</db:programlisting>
<db:para>If <db:code role="parameter">first</db:code> or <db:code role="parameter">second</db:code> has a focus proxy, setTabOrder() correctly substitutes the proxy.</db:para>
<db:note>
<db:para>Since Qt 5.10: A widget that has a child as focus proxy is understood as a compound widget. When setting a tab order between one or two compound widgets, the local tab order inside each will be preserved. This means that if both widgets are compound widgets, the resulting tab order will be from the last child inside <db:code role="parameter">first</db:code>, to the first child inside <db:code role="parameter">second</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#focusPolicy-prop">setFocusPolicy</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#setFocusProxy">setFocusProxy</db:link>()</db:member>
<db:member><db:link xlink:href="focus.xml">Keyboard Focus in Widgets</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setWindowFlag">
<db:title>[since 5.9] void QWidget::setWindowFlag(Qt::WindowType <db:emphasis>flag</db:emphasis>, bool <db:emphasis>on</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setWindowFlag</db:methodname>
<db:methodparam>
<db:type>Qt::WindowType</db:type>
<db:parameter>flag</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>on</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setWindowFlag(Qt::WindowType flag, bool on)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the window flag <db:code role="parameter">flag</db:code> on this widget if <db:code role="parameter">on</db:code> is true; otherwise clears the flag.</db:para>
<db:para>This function was introduced in Qt 5.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowFlags-prop">setWindowFlags</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#windowFlags-prop">windowFlags</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#windowType">windowType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setWindowRole">
<db:title>void QWidget::setWindowRole(const QString &amp;<db:emphasis>role</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setWindowRole</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>role</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setWindowRole(const QString &amp;role)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the window's role to <db:code role="parameter">role</db:code>. This only makes sense for windows on X11.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowRole">windowRole</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setWindowState">
<db:title>void QWidget::setWindowState(Qt::WindowStates <db:emphasis>windowState</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setWindowState</db:methodname>
<db:methodparam>
<db:type>Qt::WindowStates</db:type>
<db:parameter>windowState</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setWindowState(Qt::WindowStates windowState)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the window state to <db:code role="parameter">windowState</db:code>. The window state is a OR'ed combination of <db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowState</db:link>: <db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowMinimized</db:link>, <db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowMaximized</db:link>, <db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowFullScreen</db:link>, and <db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowActive</db:link>.</db:para>
<db:para>If the window is not visible (i.e. <db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>() returns <db:code>false</db:code>), the window state will take effect when <db:link xlink:href="qwidget.xml#show">show</db:link>() is called. For visible windows, the change is immediate. For example, to toggle between full-screen and normal mode, use the following code:</db:para>
<db:programlisting language="cpp">w-&amp;gt;setWindowState(w-&amp;gt;windowState() ^ Qt::WindowFullScreen);
</db:programlisting>
<db:para>In order to restore and activate a minimized window (while preserving its maximized and/or full-screen state), use the following:</db:para>
<db:programlisting language="cpp">w-&amp;gt;setWindowState((w-&amp;gt;windowState() &amp;amp; ~Qt::WindowMinimized) | Qt::WindowActive);
</db:programlisting>
<db:para>Calling this function will hide the widget. You must call <db:link xlink:href="qwidget.xml#show">show</db:link>() to make the widget visible again.</db:para>
<db:note>
<db:para>On some window systems <db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowActive</db:link> is not immediate, and may be ignored in certain cases.</db:para>
</db:note>
<db:para>When the window state changes, the widget receives a <db:link xlink:href="qwidget.xml#changeEvent">changeEvent</db:link>() of type <db:link xlink:href="qevent.xml#Type-enum">QEvent::WindowStateChange</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowState</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#windowState">windowState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setupUi">
<db:title>void QWidget::setupUi(QWidget *<db:emphasis>widget</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setupUi</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setupUi(QWidget *widget)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets up the user interface for the specified <db:code role="parameter">widget</db:code>.</db:para>
<db:note>
<db:para>This function is available with widgets that derive from user interface descriptions created using <db:link xlink:href="uic.xml">uic</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="designer-using-a-ui-file.xml">Using a Designer UI File in Your Application</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="show">
<db:title>void QWidget::show()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>show</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void show()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Shows the widget and its child widgets.</db:para>
<db:para>This is equivalent to calling <db:link xlink:href="qwidget.xml#showFullScreen">showFullScreen</db:link>(), <db:link xlink:href="qwidget.xml#showMaximized">showMaximized</db:link>(), or <db:link xlink:href="qwidget.xml#visible-prop">setVisible</db:link>(true), depending on the platform's default behavior for the window flags.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#raise">raise</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showEvent">showEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#hide">hide</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#visible-prop">setVisible</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showMinimized">showMinimized</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showMaximized">showMaximized</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showNormal">showNormal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#windowFlags-prop">windowFlags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="showEvent">
<db:title>[virtual protected] void QWidget::showEvent(QShowEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>showEvent</db:methodname>
<db:methodparam>
<db:type>QShowEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void showEvent(QShowEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive widget show events which are passed in the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>Non-spontaneous show events are sent to widgets immediately before they are shown. The spontaneous show events of windows are delivered afterwards.</db:para>
<db:para>Note: A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g. a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again. After receiving a spontaneous hide event, a widget is still considered visible in the sense of <db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#visible-prop">visible</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qshowevent.xml">QShowEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="showFullScreen">
<db:title>void QWidget::showFullScreen()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>showFullScreen</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void showFullScreen()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Shows the widget in full-screen mode.</db:para>
<db:para>Calling this function only affects <db:link xlink:href="qwidget.xml#isWindow">windows</db:link>.</db:para>
<db:para>To return from full-screen mode, call <db:link xlink:href="qwidget.xml#showNormal">showNormal</db:link>().</db:para>
<db:para>Full-screen mode works fine under Windows, but has certain problems under X. These problems are due to limitations of the ICCCM protocol that specifies the communication between X11 clients and the window manager. ICCCM simply does not understand the concept of non-decorated full-screen windows. Therefore, the best we can do is to request a borderless window and place and resize it to fill the entire screen. Depending on the window manager, this may or may not work. The borderless window is requested using MOTIF hints, which are at least partially supported by virtually all modern window managers.</db:para>
<db:para>An alternative would be to bypass the window manager entirely and create a window with the <db:link xlink:href="qt.xml#WindowType-enum">Qt::X11BypassWindowManagerHint</db:link> flag. This has other severe problems though, like totally broken keyboard focus and very strange effects on desktop changes or when the user raises other windows.</db:para>
<db:para>X11 window managers that follow modern post-ICCCM specifications support full-screen mode properly.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#showNormal">showNormal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showMaximized">showMaximized</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#show">show</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#hide">hide</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="showMaximized">
<db:title>void QWidget::showMaximized()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>showMaximized</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void showMaximized()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Shows the widget maximized.</db:para>
<db:para>Calling this function only affects <db:link xlink:href="qwidget.xml#isWindow">windows</db:link>.</db:para>
<db:para>On X11, this function may not work properly with certain window managers. See the <db:link xlink:href="application-windows.xml#window-geometry">Window Geometry</db:link> documentation for an explanation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setWindowState">setWindowState</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showNormal">showNormal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showMinimized">showMinimized</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#show">show</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#hide">hide</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="showMinimized">
<db:title>void QWidget::showMinimized()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>showMinimized</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void showMinimized()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Shows the widget minimized, as an icon.</db:para>
<db:para>Calling this function only affects <db:link xlink:href="qwidget.xml#isWindow">windows</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#showNormal">showNormal</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showMaximized">showMaximized</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#show">show</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#hide">hide</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#minimized-prop">isMinimized</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="showNormal">
<db:title>void QWidget::showNormal()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>showNormal</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void showNormal()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Restores the widget after it has been maximized or minimized.</db:para>
<db:para>Calling this function only affects <db:link xlink:href="qwidget.xml#isWindow">windows</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setWindowState">setWindowState</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showMinimized">showMinimized</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#showMaximized">showMaximized</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#show">show</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#hide">hide</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#visible-prop">isVisible</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stackUnder">
<db:title>void QWidget::stackUnder(QWidget *<db:emphasis>w</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>stackUnder</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>w</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void stackUnder(QWidget *w)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Places the widget under <db:code role="parameter">w</db:code> in the parent widget's stack.</db:para>
<db:para>To make this work, the widget itself and <db:code role="parameter">w</db:code> must be siblings.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#raise">raise</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#lower">lower</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="style">
<db:title>QStyle *QWidget::style() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStyle *</db:type>
<db:methodname>style</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStyle * style() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setStyle">QWidget::setStyle</db:link>()</db:member>
<db:member><db:link xlink:href="qapplication.xml#setStyle">QApplication::setStyle</db:link>()</db:member>
<db:member><db:link xlink:href="qapplication.xml#style">QApplication::style</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="tabletEvent">
<db:title>[virtual protected] void QWidget::tabletEvent(QTabletEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>tabletEvent</db:methodname>
<db:methodparam>
<db:type>QTabletEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void tabletEvent(QTabletEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler, for event <db:code role="parameter">event</db:code>, can be reimplemented in a subclass to receive tablet events for the widget.</db:para>
<db:para>If you reimplement this handler, it is very important that you <db:link xlink:href="qevent.xml">ignore()</db:link> the event if you do not handle it, so that the widget's parent can interpret it.</db:para>
<db:para>The default implementation ignores the event.</db:para>
<db:para>If tablet tracking is switched off, tablet move events only occur if the stylus is in contact with the tablet, or at least one stylus button is pressed, while the stylus is being moved. If tablet tracking is switched on, tablet move events occur even while the stylus is hovering in proximity of the tablet, with no buttons pressed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qevent.xml#ignore">QEvent::ignore</db:link>()</db:member>
<db:member><db:link xlink:href="qevent.xml#accept">QEvent::accept</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#tabletTracking-prop">setTabletTracking</db:link>()</db:member>
<db:member><db:link xlink:href="qtabletevent.xml">QTabletEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="testAttribute">
<db:title>bool QWidget::testAttribute(Qt::WidgetAttribute <db:emphasis>attribute</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>testAttribute</db:methodname>
<db:methodparam>
<db:type>Qt::WidgetAttribute</db:type>
<db:parameter>attribute</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool testAttribute(Qt::WidgetAttribute attribute) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if attribute <db:code role="parameter">attribute</db:code> is set on this widget; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setAttribute">setAttribute</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="underMouse">
<db:title>bool QWidget::underMouse() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>underMouse</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool underMouse() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the widget is under the mouse cursor; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This value is not updated properly during drag and drop operations.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#enterEvent">enterEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#leaveEvent">leaveEvent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ungrabGesture">
<db:title>void QWidget::ungrabGesture(Qt::GestureType <db:emphasis>gesture</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>ungrabGesture</db:methodname>
<db:methodparam>
<db:type>Qt::GestureType</db:type>
<db:parameter>gesture</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void ungrabGesture(Qt::GestureType gesture)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Unsubscribes the widget from a given <db:code role="parameter">gesture</db:code> type</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#grabGesture">grabGesture</db:link>()</db:member>
<db:member><db:link xlink:href="qgestureevent.xml">QGestureEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="update">
<db:title>void QWidget::update()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>update</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void update()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Updates the widget unless updates are disabled or the widget is hidden.</db:para>
<db:para>This function does not cause an immediate repaint; instead it schedules a paint event for processing when Qt returns to the main event loop. This permits Qt to optimize for more speed and less flicker than a call to <db:link xlink:href="qwidget.xml#repaint">repaint</db:link>() does.</db:para>
<db:para>Calling update() several times normally results in just one <db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>() call.</db:para>
<db:para>Qt normally erases the widget's area before the <db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>() call. If the <db:link xlink:href="qt.xml#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</db:link> widget attribute is set, the widget is responsible for painting all its pixels with an opaque color.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#repaint">repaint</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#updatesEnabled-prop">setUpdatesEnabled</db:link>()</db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-analogclock-example.xml">Analog Clock Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="update-1">
<db:title>void QWidget::update(int <db:emphasis>x</db:emphasis>, int <db:emphasis>y</db:emphasis>, int <db:emphasis>w</db:emphasis>, int <db:emphasis>h</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>update</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>w</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>h</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void update(int x, int y, int w, int h)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This version updates a rectangle (<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>, <db:code role="parameter">w</db:code>, <db:code role="parameter">h</db:code>) inside the widget.</db:para>
</db:section>
<db:section xml:id="update-2">
<db:title>void QWidget::update(const QRect &amp;<db:emphasis>rect</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>update</db:methodname>
<db:methodparam>
<db:type>const QRect &amp;</db:type>
<db:parameter>rect</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void update(const QRect &amp;rect)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This version updates a rectangle <db:code role="parameter">rect</db:code> inside the widget.</db:para>
</db:section>
<db:section xml:id="update-3">
<db:title>void QWidget::update(const QRegion &amp;<db:emphasis>rgn</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>update</db:methodname>
<db:methodparam>
<db:type>const QRegion &amp;</db:type>
<db:parameter>rgn</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void update(const QRegion &amp;rgn)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This version repaints a region <db:code role="parameter">rgn</db:code> inside the widget.</db:para>
</db:section>
<db:section xml:id="updateGeometry">
<db:title>void QWidget::updateGeometry()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>updateGeometry</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void updateGeometry()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Notifies the layout system that this widget has changed and may need to change geometry.</db:para>
<db:para>Call this function if the <db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>() or <db:link xlink:href="qwidget.xml#sizePolicy-prop">sizePolicy</db:link>() have changed.</db:para>
<db:para>For explicitly hidden widgets, updateGeometry() is a no-op. The layout system will be notified as soon as the widget is shown.</db:para>
</db:section>
<db:section xml:id="updateMicroFocus">
<db:title>[protected] void QWidget::updateMicroFocus(Qt::InputMethodQuery <db:emphasis>query</db:emphasis> = Qt::ImQueryAll)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>updateMicroFocus</db:methodname>
<db:methodparam>
<db:type>Qt::InputMethodQuery</db:type>
<db:parameter>query</db:parameter>
<db:initializer>Qt::ImQueryAll</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void updateMicroFocus(Qt::InputMethodQuery query)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Updates the widget's micro focus and informs input methods that the state specified by <db:code role="parameter">query</db:code> has changed.</db:para>
</db:section>
<db:section xml:id="visibleRegion">
<db:title>QRegion QWidget::visibleRegion() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRegion</db:type>
<db:methodname>visibleRegion</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegion visibleRegion() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the unobscured region where paint events can occur.</db:para>
<db:para>For visible widgets, this is an approximation of the area not covered by other widgets; otherwise, this is an empty region.</db:para>
<db:para>The <db:link xlink:href="qwidget.xml#repaint">repaint</db:link>() function calls this function if necessary, so in general you do not need to call it.</db:para>
</db:section>
<db:section xml:id="wheelEvent">
<db:title>[virtual protected] void QWidget::wheelEvent(QWheelEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>wheelEvent</db:methodname>
<db:methodparam>
<db:type>QWheelEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void wheelEvent(QWheelEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler, for event <db:code role="parameter">event</db:code>, can be reimplemented in a subclass to receive wheel events for the widget.</db:para>
<db:para>If you reimplement this handler, it is very important that you <db:link xlink:href="qevent.xml">ignore()</db:link> the event if you do not handle it, so that the widget's parent can interpret it.</db:para>
<db:para>The default implementation ignores the event.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qevent.xml#ignore">QEvent::ignore</db:link>()</db:member>
<db:member><db:link xlink:href="qevent.xml#accept">QEvent::accept</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#event">event</db:link>()</db:member>
<db:member><db:link xlink:href="qwheelevent.xml">QWheelEvent</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="winId">
<db:title>WId QWidget::winId() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>WId</db:type>
<db:methodname>winId</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">WId winId() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the window system identifier of the widget.</db:para>
<db:para>Portable in principle, but if you use it you are probably about to do something non-portable. Be careful.</db:para>
<db:para>If a widget is non-native (alien) and winId() is invoked on it, that widget will be provided a native handle.</db:para>
<db:para>This value may change at run-time. An event with type <db:link xlink:href="qevent.xml#Type-enum">QEvent::WinIdChange</db:link> will be sent to the widget following a change in window system identifier.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#find">find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="window">
<db:title>QWidget *QWidget::window() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>window</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * window() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the window for this widget, i.e. the next ancestor widget that has (or could have) a window-system frame.</db:para>
<db:para>If the widget is a window, the widget itself is returned.</db:para>
<db:para>Typical usage is changing the window title:</db:para>
<db:programlisting language="cpp">aWidget-&amp;gt;window()-&amp;gt;setWindowTitle(&quot;New Window Title&quot;);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#isWindow">isWindow</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="windowHandle">
<db:title>[since 5.0] QWindow *QWidget::windowHandle() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWindow *</db:type>
<db:methodname>windowHandle</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWindow * windowHandle() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If this is a native widget, return the associated <db:link xlink:href="qwindow.xml">QWindow</db:link>. Otherwise return null.</db:para>
<db:para>Native widgets include toplevel widgets, QGLWidget, and child widgets on which <db:link xlink:href="qwidget.xml#winId">winId</db:link>() was called.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#winId">winId</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#screen">screen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="windowIconChanged">
<db:title>[since 5.2] void QWidget::windowIconChanged(const QIcon &amp;<db:emphasis>icon</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>windowIconChanged</db:methodname>
<db:methodparam>
<db:type>const QIcon &amp;</db:type>
<db:parameter>icon</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">windowIcon</db:synopsisinfo>
<db:synopsisinfo role="signature">void windowIconChanged(const QIcon &amp;icon)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the window's icon has changed, with the new <db:code role="parameter">icon</db:code> as an argument.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qwidget.xml#windowIcon-prop">windowIcon</db:link>. </db:para>
</db:note>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="windowRole">
<db:title>QString QWidget::windowRole() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>windowRole</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString windowRole() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the window's role, or an empty string.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#setWindowRole">setWindowRole</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#windowIcon-prop">windowIcon</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#windowTitle-prop">windowTitle</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="windowState">
<db:title>Qt::WindowStates QWidget::windowState() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>Qt::WindowStates</db:type>
<db:methodname>windowState</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">Qt::WindowStates windowState() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current window state. The window state is a OR'ed combination of <db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowState</db:link>: <db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowMinimized</db:link>, <db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowMaximized</db:link>, <db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowFullScreen</db:link>, and <db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowActive</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qt.xml#WindowState-enum">Qt::WindowState</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#setWindowState">setWindowState</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="windowTitleChanged">
<db:title>[since 5.2] void QWidget::windowTitleChanged(const QString &amp;<db:emphasis>title</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>windowTitleChanged</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>title</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">windowTitle</db:synopsisinfo>
<db:synopsisinfo role="signature">void windowTitleChanged(const QString &amp;title)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the window's title has changed, with the new <db:code role="parameter">title</db:code> as an argument.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qwidget.xml#windowTitle-prop">windowTitle</db:link>. </db:para>
</db:note>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="windowType">
<db:title>Qt::WindowType QWidget::windowType() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>Qt::WindowType</db:type>
<db:methodname>windowType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">Qt::WindowType windowType() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the window type of this widget. This is identical to <db:link xlink:href="qwidget.xml#windowFlags-prop">windowFlags</db:link>() &amp; <db:link xlink:href="qt.xml#WindowType-enum">Qt::WindowType_Mask</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowFlags-prop">windowFlags</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QWIDGETSIZE_MAX">
<db:title>QWIDGETSIZE_MAX</db:title>
<db:methodsynopsis>
<db:methodname>QWIDGETSIZE_MAX</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QWIDGETSIZE_MAX</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Defines the maximum size for a <db:link xlink:href="qwidget.xml">QWidget</db:link> object.</db:para>
<db:para>The largest allowed size for a widget is <db:link xlink:href="qsize.xml">QSize</db:link>(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX), i.e. <db:link xlink:href="qsize.xml">QSize</db:link> (16777215,16777215).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#maximumSize-prop">QWidget::setMaximumSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QWidget</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qwidget.xml">QWidget</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-property-documentation">
<db:title>Obsolete Property Documentation</db:title>
<db:section xml:id="windowIconText-prop">
<db:title>windowIconText : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>windowIconText</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">windowIconText</db:synopsisinfo>
<db:synopsisinfo role="setter">setWindowIconText</db:synopsisinfo>
<db:synopsisinfo role="notifier">windowIconTextChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This property holds the text to be displayed on the icon of a minimized window</db:para>
<db:para>This property only makes sense for windows. If no icon text has been set, this accessor returns an empty string. It is only implemented on the X11 platform, and only certain window managers use this window property.</db:para>
<db:para>This property is deprecated.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">windowIconText</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setWindowIconText</db:emphasis>(<db:emphasis>const QString &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qwidget.xml#windowIconTextChanged">windowIconTextChanged</db:link></db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>iconText</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#windowIcon-prop">windowIcon</db:link></db:member>
<db:member><db:link xlink:href="qwidget.xml#windowTitle-prop">windowTitle</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="isTopLevel">
<db:title>bool QWidget::isTopLevel() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isTopLevel</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isTopLevel() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qwidget.xml#isWindow">isWindow</db:link>() instead.</db:para>
</db:section>
<db:section xml:id="topLevelWidget">
<db:title>QWidget *QWidget::topLevelWidget() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QWidget *</db:type>
<db:methodname>topLevelWidget</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QWidget * topLevelWidget() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qwidget.xml#window">window</db:link>() instead.</db:para>
</db:section>
<db:section xml:id="windowIconTextChanged">
<db:title>[since 5.2] void QWidget::windowIconTextChanged(const QString &amp;<db:emphasis>iconText</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>windowIconTextChanged</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>iconText</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">windowIconText</db:synopsisinfo>
<db:synopsisinfo role="signature">void windowIconTextChanged(const QString &amp;iconText)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This signal is emitted when the window's icon text has changed, with the new <db:code role="parameter">iconText</db:code> as an argument.</db:para>
<db:para>This signal is deprecated.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qwidget.xml#windowIconText-prop">windowIconText</db:link>. </db:para>
</db:note>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
