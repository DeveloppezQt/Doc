<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>WebEngine Demo Browser Example</db:title>
<db:productname>QtWebEngine</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt WebEngine Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A demo browser based on Qt <db:link xlink:href="qml-qtwebengine-webengine.xml">WebEngine</db:link> Widgets.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the demonstration applications of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;urllineedit.h&quot;

#include &quot;browserapplication.h&quot;
#include &quot;searchlineedit.h&quot;
#include &quot;webview.h&quot;

#include &lt;QtCore/QEvent&gt;
#include &lt;QtCore/QMimeData&gt;

#include &lt;QtWidgets/QApplication&gt;
#include &lt;QtWidgets/QCompleter&gt;
#include &lt;QtGui/QFocusEvent&gt;
#include &lt;QtWidgets/QHBoxLayout&gt;
#include &lt;QtWidgets/QLabel&gt;
#include &lt;QtWidgets/QLineEdit&gt;
#include &lt;QtGui/QDrag&gt;
#include &lt;QtGui/QPainter&gt;
#include &lt;QtWidgets/QStyle&gt;
#include &lt;QtWidgets/QStyleOptionFrame&gt;

#include &lt;QtCore/QDebug&gt;

ExLineEdit::ExLineEdit(QWidget *parent)
    : QWidget(parent)
    , m_leftWidget(0)
    , m_lineEdit(new QLineEdit(this))
    , m_clearButton(0)
{
    setFocusPolicy(m_lineEdit-&gt;focusPolicy());
    setAttribute(Qt::WA_InputMethodEnabled);
    setSizePolicy(m_lineEdit-&gt;sizePolicy());
    setBackgroundRole(m_lineEdit-&gt;backgroundRole());
    setMouseTracking(true);
    setAcceptDrops(true);
    setAttribute(Qt::WA_MacShowFocusRect, true);
    QPalette p = m_lineEdit-&gt;palette();
    setPalette(p);

    // line edit
    m_lineEdit-&gt;setFrame(false);
    m_lineEdit-&gt;setFocusProxy(this);
    m_lineEdit-&gt;setAttribute(Qt::WA_MacShowFocusRect, false);
    QPalette clearPalette = m_lineEdit-&gt;palette();
    clearPalette.setBrush(QPalette::Base, QBrush(Qt::transparent));
    m_lineEdit-&gt;setPalette(clearPalette);

    // clearButton
    m_clearButton = new ClearButton(this);
    connect(m_clearButton, SIGNAL(clicked()),
            m_lineEdit, SLOT(clear()));
    connect(m_lineEdit, SIGNAL(textChanged(QString)),
            m_clearButton, SLOT(textChanged(QString)));
}

void ExLineEdit::setLeftWidget(QWidget *widget)
{
    m_leftWidget = widget;
}

QWidget *ExLineEdit::leftWidget() const
{
    return m_leftWidget;
}

void ExLineEdit::resizeEvent(QResizeEvent *event)
{
    Q_ASSERT(m_leftWidget);
    updateGeometries();
    QWidget::resizeEvent(event);
}

void ExLineEdit::updateGeometries()
{
    QStyleOptionFrame panel;
    initStyleOption(&amp;panel);
    QRect rect = style()-&gt;subElementRect(QStyle::SE_LineEditContents, &amp;panel, this);

    int height = rect.height();
    int width = rect.width();

    int m_leftWidgetHeight = m_leftWidget-&gt;height();
    m_leftWidget-&gt;setGeometry(rect.x() + 2,          rect.y() + (height - m_leftWidgetHeight)/2,
                              m_leftWidget-&gt;width(), m_leftWidget-&gt;height());

    int clearButtonWidth = this-&gt;height();
    m_lineEdit-&gt;setGeometry(m_leftWidget-&gt;x() + m_leftWidget-&gt;width(),        0,
                            width - clearButtonWidth - m_leftWidget-&gt;width(), this-&gt;height());

    m_clearButton-&gt;setGeometry(this-&gt;width() - clearButtonWidth, 0,
                               clearButtonWidth, this-&gt;height());
}

void ExLineEdit::initStyleOption(QStyleOptionFrame *option) const
{
    option-&gt;initFrom(this);
    option-&gt;rect = contentsRect();
    option-&gt;lineWidth = style()-&gt;pixelMetric(QStyle::PM_DefaultFrameWidth, option, this);
    option-&gt;midLineWidth = 0;
    option-&gt;state |= QStyle::State_Sunken;
    if (m_lineEdit-&gt;isReadOnly())
        option-&gt;state |= QStyle::State_ReadOnly;
#ifdef QT_KEYPAD_NAVIGATION
    if (hasEditFocus())
        option-&gt;state |= QStyle::State_HasEditFocus;
#endif
    option-&gt;features = QStyleOptionFrame::None;
}

QSize ExLineEdit::sizeHint() const
{
    m_lineEdit-&gt;setFrame(true);
    QSize size = m_lineEdit-&gt;sizeHint();
    m_lineEdit-&gt;setFrame(false);
    return size;
}

void ExLineEdit::focusInEvent(QFocusEvent *event)
{
    m_lineEdit-&gt;event(event);
    QWidget::focusInEvent(event);
}

void ExLineEdit::focusOutEvent(QFocusEvent *event)
{
    m_lineEdit-&gt;event(event);

    if (m_lineEdit-&gt;completer()) {
        connect(m_lineEdit-&gt;completer(), SIGNAL(activated(QString)),
                         m_lineEdit, SLOT(setText(QString)));
        connect(m_lineEdit-&gt;completer(), SIGNAL(highlighted(QString)),
                         m_lineEdit, SLOT(_q_completionHighlighted(QString)));
    }
    QWidget::focusOutEvent(event);
}

void ExLineEdit::keyPressEvent(QKeyEvent *event)
{
    m_lineEdit-&gt;event(event);
}

bool ExLineEdit::event(QEvent *event)
{
    if (event-&gt;type() == QEvent::ShortcutOverride)
        return m_lineEdit-&gt;event(event);
    return QWidget::event(event);
}

void ExLineEdit::paintEvent(QPaintEvent *)
{
    QPainter p(this);
    QStyleOptionFrame panel;
    initStyleOption(&amp;panel);
    style()-&gt;drawPrimitive(QStyle::PE_PanelLineEdit, &amp;panel, &amp;p, this);
}

QVariant ExLineEdit::inputMethodQuery(Qt::InputMethodQuery property) const
{
    return m_lineEdit-&gt;inputMethodQuery(property);
}

void ExLineEdit::inputMethodEvent(QInputMethodEvent *e)
{
    m_lineEdit-&gt;event(e);
}

class UrlIconLabel : public QLabel
{

public:
    UrlIconLabel(QWidget *parent);

    WebView *m_webView;

protected:
    void mousePressEvent(QMouseEvent *event);
    void mouseMoveEvent(QMouseEvent *event);

private:
    QPoint m_dragStartPos;

};

UrlIconLabel::UrlIconLabel(QWidget *parent)
    : QLabel(parent)
    , m_webView(0)
{
    setMinimumWidth(16);
    setMinimumHeight(16);
}

void UrlIconLabel::mousePressEvent(QMouseEvent *event)
{
    if (event-&gt;button() == Qt::LeftButton)
        m_dragStartPos = event-&gt;pos();
    QLabel::mousePressEvent(event);
}

void UrlIconLabel::mouseMoveEvent(QMouseEvent *event)
{
    if (event-&gt;buttons() == Qt::LeftButton
        &amp;&amp; (event-&gt;pos() - m_dragStartPos).manhattanLength() &gt; QApplication::startDragDistance()
         &amp;&amp; m_webView) {
        QDrag *drag = new QDrag(this);
        QMimeData *mimeData = new QMimeData;
        mimeData-&gt;setText(QString::fromUtf8(m_webView-&gt;url().toEncoded()));
        QList&lt;QUrl&gt; urls;
        urls.append(m_webView-&gt;url());
        mimeData-&gt;setUrls(urls);
        drag-&gt;setMimeData(mimeData);
        drag-&gt;exec();
    }
}

UrlLineEdit::UrlLineEdit(QWidget *parent)
    : ExLineEdit(parent)
    , m_webView(0)
    , m_iconLabel(0)
{
    // icon
    m_iconLabel = new UrlIconLabel(this);
    m_iconLabel-&gt;resize(16, 16);
    setLeftWidget(m_iconLabel);
    m_defaultBaseColor = palette().color(QPalette::Base);
}

void UrlLineEdit::setWebView(WebView *webView)
{
    Q_ASSERT(!m_webView);
    m_webView = webView;
    m_iconLabel-&gt;m_webView = webView;
    connect(webView, SIGNAL(urlChanged(QUrl)),
        this, SLOT(webViewUrlChanged(QUrl)));
    connect(webView, SIGNAL(iconChanged(QIcon)),
        this, SLOT(webViewIconChanged(QIcon)));
    connect(webView, SIGNAL(loadProgress(int)),
        this, SLOT(update()));
}

void UrlLineEdit::webViewUrlChanged(const QUrl &amp;url)
{
    m_lineEdit-&gt;setText(QString::fromUtf8(url.toEncoded()));
    m_lineEdit-&gt;setCursorPosition(0);
}

void UrlLineEdit::webViewIconChanged(const QIcon &amp;icon)
{
    Q_ASSERT(m_webView);
    m_iconLabel-&gt;setPixmap(icon.pixmap(16, 16));
}

QLinearGradient UrlLineEdit::generateGradient(const QColor &amp;color) const
{
    QLinearGradient gradient(0, 0, 0, height());
    gradient.setColorAt(0, m_defaultBaseColor);
    gradient.setColorAt(0.15, color.lighter(120));
    gradient.setColorAt(0.5, color);
    gradient.setColorAt(0.85, color.lighter(120));
    gradient.setColorAt(1, m_defaultBaseColor);
    return gradient;
}

void UrlLineEdit::focusOutEvent(QFocusEvent *event)
{
    if (m_lineEdit-&gt;text().isEmpty() &amp;&amp; m_webView)
        m_lineEdit-&gt;setText(QString::fromUtf8(m_webView-&gt;url().toEncoded()));
    ExLineEdit::focusOutEvent(event);
}

void UrlLineEdit::paintEvent(QPaintEvent *event)
{
    QPalette p = palette();
    if (m_webView &amp;&amp; m_webView-&gt;url().scheme() == QLatin1String(&quot;https&quot;)) {
        QColor lightYellow(248, 248, 210);
        p.setBrush(QPalette::Base, generateGradient(lightYellow));
    } else {
        p.setBrush(QPalette::Base, m_defaultBaseColor);
    }
    setPalette(p);
    ExLineEdit::paintEvent(event);

    QPainter painter(this);
    QStyleOptionFrame panel;
    initStyleOption(&amp;panel);
    QRect backgroundRect = style()-&gt;subElementRect(QStyle::SE_LineEditContents, &amp;panel, this);
    if (m_webView &amp;&amp; !hasFocus()) {
        int progress = m_webView-&gt;progress();
        QColor loadingColor = QColor(116, 192, 250);
        painter.setBrush(generateGradient(loadingColor));
        painter.setPen(Qt::transparent);
        int mid = backgroundRect.width() / 100.0f * progress;
        QRect progressRect(backgroundRect.x(), backgroundRect.y(), mid, backgroundRect.height());
        painter.drawRect(progressRect);
    }
}

</db:programlisting>
</db:article>
