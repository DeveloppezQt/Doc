<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Audiolevels Example</db:title>
<db:productname>QtDataVisualization</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Simple application showing real time audio data.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the Qt Data Visualization module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:GPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3 or (at your option) any later version
** approved by the KDE Free Qt Foundation. The licenses are as published by
** the Free Software Foundation and appearing in the file LICENSE.GPL3
** included in the packaging of this file. Please review the following
** information to ensure the GNU General Public License requirements will
** be met: https://www.gnu.org/licenses/gpl-3.0.html.
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;audiolevelsiodevice.h&quot;
#include &lt;QtCore/QDebug&gt;

using namespace QtDataVisualization;

static const int resolution = 8;
static const int rowSize = 800;
static const int rowCount = 7; // Must be odd number
static const int middleRow = rowCount / 2;

AudioLevelsIODevice::AudioLevelsIODevice(QBarDataProxy *proxy, QObject *parent)
    : QIODevice(parent),
      m_proxy(proxy),
      m_array(new QBarDataArray)
{
    // We reuse the existing array for maximum performance, so construct the array here
    m_array-&gt;reserve(rowCount);
    for (int i = 0; i &lt; rowCount; i++)
        m_array-&gt;append(new QBarDataRow(rowSize));

    qDebug() &lt;&lt; &quot;Total of&quot; &lt;&lt; (rowSize * rowCount) &lt;&lt; &quot;items in the array.&quot;;
}

// Implementation required for this pure virtual function
qint64 AudioLevelsIODevice::readData(char *data, qint64 maxSize)
{
    Q_UNUSED(data)
    Q_UNUSED(maxSize)
    return -1;
}

qint64 AudioLevelsIODevice::writeData(const char *data, qint64 maxSize)
{
    // The amount of new data available.
    int newDataSize = maxSize / resolution;

    // If we get more data than array size, we need to adjust the start index for new data.
    int newDataStartIndex = qMax(0, (newDataSize - rowSize));

    // Move the old data ahead in the rows (only do first half of rows + middle one now).
    // If the amount of new data was larger than row size, skip copying.
    if (!newDataStartIndex) {
        for (int i = 0; i &lt;= middleRow; i++) {
            QBarDataItem *srcPos = m_array-&gt;at(i)-&gt;data();
            QBarDataItem *dstPos = srcPos + newDataSize;
            memmove((void *)dstPos, (void *)srcPos, (rowSize - newDataSize) * sizeof(QBarDataItem));
        }
    }

    // Insert data in reverse order, so that newest data is always at the front of the row.
    int index = 0;
    for (int i = newDataSize - 1; i &gt;= newDataStartIndex; i--) {
        // Add 0.01 to the value to avoid gaps in the graph (i.e. zero height bars).
        // Also, scale to 0...100
        float value = float(quint8(data[resolution * i]) - 128) / 1.28f + 0.01f;
        (*m_array-&gt;at(middleRow))[index].setValue(value);
        // Insert a fractional value into front half of the rows.
        for (int j = 1; j &lt;= middleRow; j++) {
            float fractionalValue = value / float(j + 1);
            (*m_array-&gt;at(middleRow - j))[index].setValue(fractionalValue);
        }
        index++;
    }

    // Copy the front half of rows to the back half for symmetry.
    index = 0;
    for (int i = rowCount - 1; i &gt; middleRow; i--) {
        QBarDataItem *srcPos = m_array-&gt;at(index++)-&gt;data();
        QBarDataItem *dstPos = m_array-&gt;at(i)-&gt;data();
        memcpy((void *)dstPos, (void *)srcPos, rowSize * sizeof(QBarDataItem));
    }

    // Reset the proxy array now that data has been updated to trigger a redraw.
    m_proxy-&gt;resetArray(m_array);

    return maxSize;
}

</db:programlisting>
</db:article>
