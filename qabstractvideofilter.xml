<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QAbstractVideoFilter Class</db:title>
<db:productname>QtMultimedia</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Multimedia Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> class represents a filter that is applied to the video frames received by a <db:link xlink:href="qml-qtmultimedia-videooutput.xml">VideoOutput</db:link> type.</db:para>
<db:para>This class was introduced in Qt 5.5.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QAbstractVideoFilter</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.5</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += multimedia</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QAbstractVideoFilter is part of <db:simplelist><db:member>multimedia</db:member><db:member>multimedia_video</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> provides a convenient way for applications to run image processing, computer vision algorithms or any generic transformation or calculation on the output of a <db:link xlink:href="qml-qtmultimedia-videooutput.xml">VideoOutput</db:link> type, regardless of the source (video or camera). By providing a simple interface it allows applications and third parties to easily develop QML types that provide image processing algorithms using popular frameworks like <db:link xlink:href="http://opencv.org">OpenCV</db:link>. Due to the close integration with the final stages of the Qt Multimedia video pipeline, accelerated and possibly zero-copy solutions are feasible too: for instance, a plugin providing OpenCL-based algorithms can use OpenCL's OpenGL interop to use the OpenGL textures created by a hardware accelerated video decoder, without additional readbacks and copies.</db:para>
<db:note>
<db:para><db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> is not always the best choice. To apply effects or transformations using OpenGL shaders to the image shown on screen, the standard Qt Quick approach of using <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link> items in combination with <db:link xlink:href="qml-qtmultimedia-videooutput.xml">VideoOutput</db:link> should be used. VideoFilter is not a replacement for this. It is rather targeted for performing computations (that do not necessarily change the image shown on screen) and computer vision algorithms provided by external frameworks.</db:para>
</db:note>
<db:para><db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> is meant to be subclassed. The subclasses are then registered to the QML engine, so they can be used as a QML type. The list of filters are assigned to a <db:link xlink:href="qml-qtmultimedia-videooutput.xml">VideoOutput</db:link> type via its <db:link xlink:href="qml-qtmultimedia-videooutput.xml#filters-prop">filters</db:link> property.</db:para>
<db:para>A single filter represents one transformation or processing step on a video frame. The output is a modified video frame, some arbitrary data or both. For example, image transformations will result in a different image, whereas an algorithm for detecting objects on an image will likely provide a list of rectangles.</db:para>
<db:para>Arbitrary data can be represented as properties on the <db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> subclass and on the <db:link xlink:href="qobject.xml">QObject</db:link> or <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> instances passed to its signals. What exactly these properties and signals are, is up to the individual video filters. Completion of the operations can be indicated by signals. Computations that do not result in a modified image will pass the input image through so that subsequent filters can be placed after them.</db:para>
<db:para>Properties set on <db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> serve as input to the computation, similarly to how uniform values are specified in <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link> types. The changed property values are taken into use when the next video frame is processed.</db:para>
<db:para>The typical usage is to subclass <db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> and <db:link xlink:href="qvideofilterrunnable.xml">QVideoFilterRunnable</db:link>:</db:para>
<db:programlisting language="cpp" role="bad">class MyFilterRunnable : public QVideoFilterRunnable {
public:
    QVideoFrame run(QVideoFrame *input, const QVideoSurfaceFormat &amp;surfaceFormat, RunFlags flags) { ... }
};

class MyFilter : public QAbstractVideoFilter {
public:
    QVideoFilterRunnable *createFilterRunnable() { return new MyFilterRunnable; }
signals:
    void finished(QObject *result);
};

int main(int argc, char **argv) {
    ...
    qmlRegisterType&lt;MyFilter&gt;(&quot;my.uri&quot;, 1, 0, &quot;MyFilter&quot;);
    ...
}
</db:programlisting>
<db:para>MyFilter is thus accessible from QML:</db:para>
<db:programlisting language="cpp" role="bad">import my.uri 1.0

Camera {
    id: camera
}
MyFilter {
    id: filter
    // set properties, they can also be animated
    onFinished: console.log(&quot;results of the computation: &quot; + result)
}
VideoOutput {
    source: camera
    filters: [ filter ]
    anchors.fill: parent
}
</db:programlisting>
<db:para>This also allows providing filters in QML plugins, separately from the application.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtmultimedia-videooutput.xml">VideoOutput</db:link></db:member>
<db:member><db:link xlink:href="qml-qtmultimedia-camera.xml">Camera</db:link></db:member>
<db:member><db:link xlink:href="qml-qtmultimedia-mediaplayer.xml">MediaPlayer</db:link></db:member>
<db:member><db:link xlink:href="qvideofilterrunnable.xml">QVideoFilterRunnable</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="active-prop">
<db:title>active : bool</db:title>
<db:para>This property holds the active status of the filter.</db:para>
<db:para>This is true if the filter is active, false otherwise.</db:para>
<db:para>By default filters are active. When set to <db:code>false</db:code>, the filter will be ignored by the <db:link xlink:href="qml-qtmultimedia-videooutput.xml">VideoOutput</db:link> type.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isActive</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setActive</db:emphasis>(<db:type>bool</db:type> <db:emphasis>v</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">activeChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QAbstractVideoFilter">
<db:title>[explicit] QAbstractVideoFilter::QAbstractVideoFilter(QObject *<db:emphasis>parent</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Constructs a new <db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> instance with parent object <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="createFilterRunnable">
<db:title>[pure virtual] QVideoFilterRunnable *QAbstractVideoFilter::createFilterRunnable()</db:title>
<db:para>Factory function to create a new instance of a <db:link xlink:href="qvideofilterrunnable.xml">QVideoFilterRunnable</db:link> subclass corresponding to this filter.</db:para>
<db:para>This function is called on the thread on which the Qt Quick scene graph performs rendering, with the OpenGL context bound. Ownership of the returned instance is transferred: the returned instance will live on the render thread and will be destroyed automatically when necessary.</db:para>
<db:para>Typically, implementations of the function will simply construct a new <db:link xlink:href="qvideofilterrunnable.xml">QVideoFilterRunnable</db:link> instance, passing <db:code>this</db:code> to the constructor as the filter runnables must know their associated <db:link xlink:href="qabstractvideofilter.xml">QAbstractVideoFilter</db:link> instance to access dynamic properties and optionally emit signals.</db:para>
</db:section>
</db:section>
</db:article>
