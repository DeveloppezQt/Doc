<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QQuickItem Class</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> class provides the most basic of all visual items in <db:link xlink:href="qtquick-index.xml">Qt Quick</db:link>.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QQuickItem</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Quick)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Quick)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += quick</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qquickframebufferobject.xml" xlink:role="class">QQuickFramebufferObject</db:link> and <db:link xlink:href="qquickpainteditem.xml" xlink:role="class">QQuickPaintedItem</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Instantiated By</db:term>
<db:listitem>
<db:para>qml-qtquick-item.xml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link> and <db:link xlink:href="qqmlparserstatus.xml" xlink:role="class">QQmlParserStatus</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qquickframebufferobject.xml" xlink:role="class">QQuickFramebufferObject</db:link> and <db:link xlink:href="qquickpainteditem.xml" xlink:role="class">QQuickPaintedItem</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>All visual items in Qt Quick inherit from <db:link xlink:href="qquickitem.xml">QQuickItem</db:link>. Although a <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> instance has no visual appearance, it defines all the attributes that are common across visual items, such as x and y position, width and height, <db:link xlink:href="qtquick-positioning-anchors.xml">anchoring</db:link> and key handling support.</db:para>
<db:para>You can subclass <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> to provide your own custom visual item that inherits these features.</db:para>
<db:section xml:id="custom-scene-graph-items">
<db:title>Custom Scene Graph Items</db:title>
<db:para>All visual QML items are rendered using the scene graph, the default implementation of which is a low-level, high-performance rendering stack, closely tied to accelerated graphics APIs, such as OpenGL, Vulkan, Metal, or Direct 3D. It is possible for subclasses of <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> to add their own custom content into the scene graph by setting the <db:link xlink:href="qquickitem.xml#Flag-enum">QQuickItem::ItemHasContents</db:link> flag and reimplementing the <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>() function.</db:para>
<db:warning>
<db:para>It is crucial that graphics operations and interaction with the scene graph happens exclusively on the rendering thread, primarily during the <db:link xlink:href="qquickitem.xml#updatePaintNode">updatePaintNode</db:link>() call. The best rule of thumb is to only use classes with the &quot;QSG&quot; prefix inside the <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>() function.</db:para>
</db:warning>
<db:note>
<db:para>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <db:link xlink:href="qtquick-visualcanvas-scenegraph.xml#scene-graph-and-rendering">Scene Graph and Rendering</db:link> for more information.</db:para>
</db:note>
<db:section xml:id="graphics-resource-handling">
<db:title>Graphics Resource Handling</db:title>
<db:para>The preferred way to handle cleanup of graphics resources used in the scene graph, is to rely on the automatic cleanup of nodes. A <db:link xlink:href="qsgnode.xml">QSGNode</db:link> returned from <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>() is automatically deleted on the right thread at the right time. Trees of <db:link xlink:href="qsgnode.xml">QSGNode</db:link> instances are managed through the use of <db:link xlink:href="qsgnode.xml#Flag-enum">QSGNode::OwnedByParent</db:link>, which is set by default. So, for the majority of custom scene graph items, no extra work will be required.</db:para>
<db:para>Implementations that store graphics resources outside the node tree, such as an item implementing <db:link xlink:href="qquickitem.xml#textureProvider">QQuickItem::textureProvider</db:link>(), will need to take care in cleaning it up correctly depending on how the item is used in QML. The situations to handle are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The scene graph is invalidated; This can happen, depending on the platform and <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> configuration, when the window is hidden using <db:link xlink:href="qwindow.xml#hide">QQuickWindow::hide</db:link>(), or when it is closed. If the item class implements a <db:code>slot</db:code> named <db:code>invalidateSceneGraph()</db:code>, this slot will be called on the rendering thread while the GUI thread is blocked. This is equivalent to connecting to <db:link xlink:href="qquickwindow.xml#sceneGraphInvalidated">QQuickWindow::sceneGraphInvalidated</db:link>(). When rendering through OpenGL, the OpenGL context of this item's window will be bound when this slot is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through <db:code>EGL_CONTEXT_LOST</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>The item is removed from the scene; If an item is taken out of the scene, for instance because it's parent was set to <db:code>null</db:code> or an item in another window, the <db:link xlink:href="qquickitem.xml#releaseResources">QQuickItem::releaseResources</db:link>() will be called on the GUI thread. <db:link xlink:href="qquickwindow.xml#scheduleRenderJob">QQuickWindow::scheduleRenderJob</db:link>() should be used to schedule cleanup of rendering resources.</db:para>
</db:listitem>
<db:listitem>
<db:para>The item is deleted; When the destructor if an item runs, it should delete any graphics resources it has. If neither of the two conditions above were already met, the item will be part of a window and it is possible to use <db:link xlink:href="qquickwindow.xml#scheduleRenderJob">QQuickWindow::scheduleRenderJob</db:link>() to have them cleaned up. If an implementation ignores the call to <db:link xlink:href="qquickitem.xml#releaseResources">QQuickItem::releaseResources</db:link>(), the item will in many cases no longer have access to a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> and thus no means of scheduling cleanup.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>When scheduling cleanup of graphics resources using <db:link xlink:href="qquickwindow.xml#scheduleRenderJob">QQuickWindow::scheduleRenderJob</db:link>(), one should use either <db:link xlink:href="qquickwindow.xml#RenderStage-enum">QQuickWindow::BeforeSynchronizingStage</db:link> or <db:link xlink:href="qquickwindow.xml#RenderStage-enum">QQuickWindow::AfterSynchronizingStage</db:link>. The <db:link xlink:href="qtquick-visualcanvas-scenegraph.xml#scene-graph-and-rendering">synchronization stage</db:link> is where the scene graph is changed as a result of changes to the QML tree. If cleanup is scheduled at any other time, it may result in other parts of the scene graph referencing the newly deleted objects as these parts have not been updated.</db:para>
<db:note>
<db:para>Use of <db:link xlink:href="qobject.xml#deleteLater">QObject::deleteLater</db:link>() to clean up graphics resources is strongly discouraged as this will make the <db:code>delete</db:code> operation run at an arbitrary time and it is unknown if there will be an OpenGL context bound when the deletion takes place.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="custom-qpainter-items">
<db:title>Custom QPainter Items</db:title>
<db:para>The <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> provides a subclass, <db:link xlink:href="qquickpainteditem.xml">QQuickPaintedItem</db:link>, which allows the users to render content using <db:link xlink:href="qpainter.xml">QPainter</db:link>.</db:para>
<db:warning>
<db:para>Using <db:link xlink:href="qquickpainteditem.xml">QQuickPaintedItem</db:link> uses an indirect 2D surface to render its content, using software rasterization, so the rendering is a two-step operation. First rasterize the surface, then draw the surface. Using scene graph API directly is always significantly faster.</db:para>
</db:warning>
</db:section>
<db:section xml:id="behavior-animations">
<db:title>Behavior Animations</db:title>
<db:para>If your Item uses the <db:link xlink:href="qml-qtquick-behavior.xml">Behavior</db:link> type to define animations for property changes, you should always use either <db:link xlink:href="qobject.xml#setProperty">QObject::setProperty</db:link>(), QQmlProperty(), or <db:link xlink:href="qmetaproperty.xml#write">QMetaProperty::write</db:link>() when you need to modify those properties from C++. This ensures that the QML engine knows about the property change. Otherwise, the engine won't be able to carry out your requested animation. Note that these functions incur a slight performance penalty. For more details, see <db:link xlink:href="qtqml-cppintegration-interactqmlfromcpp.xml#accessing-members-of-a-qml-object-type-from-c">Accessing Members of a QML Object Type from C++</db:link>.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link></db:member>
<db:member><db:link xlink:href="qquickpainteditem.xml">QQuickPaintedItem</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Flag-enum">
<db:title>enum QQuickItem::Flag</db:title>
<db:bridgehead renderas="sect2">flags QQuickItem::Flags</db:bridgehead>
<db:enumsynopsis>
<db:enumname>Flag</db:enumname>
<db:enumitem>
<db:enumidentifier>ItemClipsChildrenToShape</db:enumidentifier>
<db:enumvalue>0x01</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemAcceptsInputMethod</db:enumidentifier>
<db:enumvalue>0x02</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemIsFocusScope</db:enumidentifier>
<db:enumvalue>0x04</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemHasContents</db:enumidentifier>
<db:enumvalue>0x08</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemAcceptsDrops</db:enumidentifier>
<db:enumvalue>0x10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemIsViewport</db:enumidentifier>
<db:enumvalue>0x20</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemObservesViewport</db:enumidentifier>
<db:enumvalue>0x40</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QQuickItem::Flags</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum type is used to specify various item properties.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemClipsChildrenToShape</db:code></db:para>
</db:td>
<db:td><db:code>0x01</db:code></db:td>
<db:td>
<db:para>Indicates this item should visually clip its children so that they are rendered only within the boundaries of this item.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemAcceptsInputMethod</db:code></db:para>
</db:td>
<db:td><db:code>0x02</db:code></db:td>
<db:td>
<db:para>Indicates the item supports text input methods.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemIsFocusScope</db:code></db:para>
</db:td>
<db:td><db:code>0x04</db:code></db:td>
<db:td>
<db:para>Indicates the item is a focus scope. See <db:link xlink:href="qtquick-input-focus.xml">Keyboard Focus in Qt Quick</db:link> for more information.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemHasContents</db:code></db:para>
</db:td>
<db:td><db:code>0x08</db:code></db:td>
<db:td>
<db:para>Indicates the item has visual content and should be rendered by the scene graph.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemAcceptsDrops</db:code></db:para>
</db:td>
<db:td><db:code>0x10</db:code></db:td>
<db:td>
<db:para>Indicates the item accepts drag and drop events.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemIsViewport</db:code></db:para>
</db:td>
<db:td><db:code>0x20</db:code></db:td>
<db:td>
<db:para>Indicates that the item defines a viewport for its children.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemObservesViewport</db:code></db:para>
</db:td>
<db:td><db:code>0x40</db:code></db:td>
<db:td>
<db:para>Indicates that the item wishes to know the viewport bounds when any ancestor has the ItemIsViewport flag set.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>Flags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Flag&gt;. </db:code>It stores an OR combination of <db:code>Flag</db:code> values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#setFlag">setFlag</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#setFlags">setFlags</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#flags">flags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ItemChange-enum">
<db:title>enum QQuickItem::ItemChange</db:title>
<db:enumsynopsis>
<db:enumname>ItemChange</db:enumname>
<db:enumitem>
<db:enumidentifier>ItemChildAddedChange</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemChildRemovedChange</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemSceneChange</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemVisibleHasChanged</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemParentHasChanged</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemOpacityHasChanged</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemActiveFocusHasChanged</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemRotationHasChanged</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemAntialiasingHasChanged</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemDevicePixelRatioHasChanged</db:enumidentifier>
<db:enumvalue>9</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ItemEnabledHasChanged</db:enumidentifier>
<db:enumvalue>10</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Used in conjunction with <db:link xlink:href="qquickitem.xml#itemChange">QQuickItem::itemChange</db:link>() to notify the item about certain types of changes.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemChildAddedChange</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>A child was added. <db:link xlink:href="qquickitem-itemchangedata.xml#item-var">ItemChangeData::item</db:link> contains the added child.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemChildRemovedChange</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>A child was removed. <db:link xlink:href="qquickitem-itemchangedata.xml#item-var">ItemChangeData::item</db:link> contains the removed child.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemSceneChange</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The item was added to or removed from a scene. The <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> rendering the scene is specified in using <db:link xlink:href="qquickitem-itemchangedata.xml#window-var">ItemChangeData::window</db:link>. The window parameter is null when the item is removed from a scene.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemVisibleHasChanged</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The item's visibility has changed. <db:link xlink:href="qquickitem-itemchangedata.xml#boolValue-var">ItemChangeData::boolValue</db:link> contains the new visibility.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemParentHasChanged</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The item's parent has changed. <db:link xlink:href="qquickitem-itemchangedata.xml#item-var">ItemChangeData::item</db:link> contains the new parent.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemOpacityHasChanged</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The item's opacity has changed. <db:link xlink:href="qquickitem-itemchangedata.xml#realValue-var">ItemChangeData::realValue</db:link> contains the new opacity.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemActiveFocusHasChanged</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The item's focus has changed. <db:link xlink:href="qquickitem-itemchangedata.xml#boolValue-var">ItemChangeData::boolValue</db:link> contains whether the item has focus or not.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemRotationHasChanged</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>The item's rotation has changed. <db:link xlink:href="qquickitem-itemchangedata.xml#realValue-var">ItemChangeData::realValue</db:link> contains the new rotation.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemDevicePixelRatioHasChanged</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>The device pixel ratio of the screen the item is on has changed. ItemChangedData::realValue contains the new device pixel ratio.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemAntialiasingHasChanged</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>The antialiasing has changed. The current (boolean) value can be found in <db:link xlink:href="qquickitem.xml#antialiasing-prop">QQuickItem::antialiasing</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::ItemEnabledHasChanged</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>The item's enabled state has changed. <db:link xlink:href="qquickitem-itemchangedata.xml#boolValue-var">ItemChangeData::boolValue</db:link> contains the new enabled state. (since Qt 5.10)</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="TransformOrigin-enum">
<db:title>enum QQuickItem::TransformOrigin</db:title>
<db:enumsynopsis>
<db:enumname>TransformOrigin</db:enumname>
<db:enumitem>
<db:enumidentifier>TopLeft</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Top</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TopRight</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Left</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Center</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Right</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BottomLeft</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Bottom</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BottomRight</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Controls the point about which simple transforms like scale apply.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::TopLeft</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The top-left corner of the item.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::Top</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The center point of the top of the item.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::TopRight</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The top-right corner of the item.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::Left</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The left most point of the vertical middle.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::Center</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The center of the item.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::Right</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The right most point of the vertical middle.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::BottomLeft</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The bottom-left corner of the item.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::Bottom</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>The center point of the bottom of the item.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qquickitem.xml">QQuickItem</db:link></db:emphasis>::BottomRight</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>The bottom-right corner of the item.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#transformOrigin-prop">setTransformOrigin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="implicitHeight-prop">
<db:title>implicitHeight : qreal</db:title>
<db:bridgehead renderas="sect2" xml:id="implicitWidth-prop">implicitWidth : qreal</db:bridgehead>
<db:para>Defines the preferred width or height of the Item.</db:para>
<db:para>If <db:link xlink:href="qquickitem.xml#width-prop">width</db:link> or <db:link xlink:href="qquickitem.xml#height-prop">height</db:link> is not specified, an item's effective size will be determined by its <db:link xlink:href="qquickitem.xml#implicitWidth">implicitWidth</db:link> or <db:link xlink:href="qquickitem.xml#implicitHeight-prop">implicitHeight</db:link>.</db:para>
<db:para>However, if an item is the child of a <db:link xlink:href="qtquicklayouts-index.xml">layout</db:link>, the layout will determine the item's preferred size using its implicit size. In such a scenario, the explicit <db:link xlink:href="qquickitem.xml#width-prop">width</db:link> or <db:link xlink:href="qquickitem.xml#height-prop">height</db:link> will be ignored.</db:para>
<db:para>The default implicit size for most items is 0x0, however some items have an inherent implicit size which cannot be overridden, for example, <db:link xlink:href="qml-qtquick-image.xml">Image</db:link> and <db:link xlink:href="qml-qtquick-text.xml">Text</db:link>.</db:para>
<db:para>Setting the implicit size is useful for defining components that have a preferred size based on their content, for example:</db:para>
<db:programlisting language="qml">// Label.qml
import QtQuick 2.0

Item {
    property alias icon: image.source
    property alias label: text.text
    implicitWidth: text.implicitWidth + image.implicitWidth
    implicitHeight: Math.max(text.implicitHeight, image.implicitHeight)
    Image { id: image }
    Text {
        id: text
        wrapMode: Text.Wrap
        anchors.left: image.right; anchors.right: parent.right
        anchors.verticalCenter: parent.verticalCenter
    }
}
</db:programlisting>
<db:note>
<db:para>Using <db:link xlink:href="qquickitem.xml#implicitWidth">implicitWidth</db:link> of <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> or <db:link xlink:href="qml-qtquick-textedit.xml">TextEdit</db:link> and setting the width explicitly incurs a performance penalty as the text must be laid out twice.</db:para>
</db:note>
</db:section>
<db:section xml:id="activeFocus-prop">
<db:title>[read-only] activeFocus : const bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>activeFocus</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">hasActiveFocus</db:synopsisinfo>
<db:synopsisinfo role="notifier">activeFocusChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This read-only property indicates whether the item has active focus.</db:para>
<db:para>If activeFocus is true, either this item is the one that currently receives keyboard input, or it is a <db:link xlink:href="qml-qtquick-focusscope.xml">FocusScope</db:link> ancestor of the item that currently receives keyboard input.</db:para>
<db:para>Usually, activeFocus is gained by setting <db:link xlink:href="qquickitem.xml#focus-prop">focus</db:link> on an item and its enclosing <db:link xlink:href="qml-qtquick-focusscope.xml">FocusScope</db:link> objects. In the following example, the <db:code>input</db:code> and <db:code>focusScope</db:code> objects will have active focus, while the root rectangle object will not.</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Rectangle {
    width: 100; height: 100

    FocusScope {
        focus: true

        TextInput {
            id: input
            focus: true
        }
    }
}
</db:programlisting>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">hasActiveFocus</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">activeFocusChanged</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#focus-prop">focus</db:link></db:member>
<db:member><db:link xlink:href="qtquick-input-focus.xml">Keyboard Focus in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="activeFocusOnTab-prop">
<db:title>activeFocusOnTab : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>activeFocusOnTab</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">activeFocusOnTab</db:synopsisinfo>
<db:synopsisinfo role="setter">setActiveFocusOnTab</db:synopsisinfo>
<db:synopsisinfo role="notifier">activeFocusOnTabChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether the item wants to be in the tab focus chain. By default, this is set to <db:code>false</db:code>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">activeFocusOnTab</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setActiveFocusOnTab</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">activeFocusOnTabChanged</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="antialiasing-prop">
<db:title>antialiasing : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>antialiasing</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">antialiasing</db:synopsisinfo>
<db:synopsisinfo role="setter">setAntialiasing</db:synopsisinfo>
<db:synopsisinfo role="resetter">resetAntialiasing</db:synopsisinfo>
<db:synopsisinfo role="notifier">antialiasingChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Specifies whether the item is antialiased or not</db:para>
<db:para>Used by visual elements to decide if the item should use antialiasing or not. In some cases items with antialiasing require more memory and are potentially slower to render (see <db:link xlink:href="qtquick-visualcanvas-scenegraph-renderer.xml#antialiasing">Antialiasing</db:link> for more details).</db:para>
<db:para>The default is false, but may be overridden by derived elements.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">antialiasing</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setAntialiasing</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">resetAntialiasing</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">antialiasingChanged</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="baselineOffset-prop">
<db:title>baselineOffset : qreal</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>qreal</db:type>
<db:varname>baselineOffset</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">baselineOffset</db:synopsisinfo>
<db:synopsisinfo role="setter">setBaselineOffset</db:synopsisinfo>
<db:synopsisinfo role="notifier">baselineOffsetChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Specifies the position of the item's baseline in local coordinates.</db:para>
<db:para>The baseline of a <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> item is the imaginary line on which the text sits. Controls containing text usually set their baseline to the baseline of their text.</db:para>
<db:para>For non-text items, a default baseline offset of 0 is used.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qttypes.xml#qreal-typedef">qreal</db:link></db:type> <db:emphasis role="bold">baselineOffset</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setBaselineOffset</db:emphasis>(<db:emphasis>qreal</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">baselineOffsetChanged</db:emphasis>(<db:emphasis>qreal</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="childrenRect-prop">
<db:title>[read-only] childrenRect : const QRectF</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QRectF</db:type>
<db:varname>childrenRect</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">childrenRect</db:synopsisinfo>
<db:synopsisinfo role="notifier">childrenRectChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the collective position and size of the item's children.</db:para>
<db:para>This property is useful if you need to access the collective geometry of an item's children in order to correctly size the item.</db:para>
<db:para>The geometry that is returned is local to the item. For example:</db:para>
<db:programlisting language="qml">Item {
    x: 50
    y: 100

    // prints: QRectF(-10, -20, 30, 40)
    Component.onCompleted: print(childrenRect)

    Item {
        x: -10
        y: -20
        width: 30
        height: 40
    }
}
</db:programlisting>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qrectf.xml">QRectF</db:link></db:type> <db:emphasis role="bold">childrenRect</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">childrenRectChanged</db:emphasis>(<db:emphasis>const QRectF &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="clip-prop">
<db:title>clip : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>clip</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">clip</db:synopsisinfo>
<db:synopsisinfo role="setter">setClip</db:synopsisinfo>
<db:synopsisinfo role="notifier">clipChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether clipping is enabled. The default clip value is <db:code>false</db:code>.</db:para>
<db:para>If clipping is enabled, an item will clip its own painting, as well as the painting of its children, to its bounding rectangle. If you set clipping during an item's paint operation, remember to re-set it to prevent clipping the rest of your scene.</db:para>
<db:note>
<db:para>Clipping can affect rendering performance. See <db:link xlink:href="qtquick-visualcanvas-scenegraph-renderer.xml#clipping">Clipping</db:link> for more information.</db:para>
</db:note>
<db:note>
<db:para>For the sake of QML, setting clip to <db:code>true</db:code> also sets the <db:link xlink:href="qquickitem.xml#Flag-enum">ItemIsViewport</db:link> flag, which sometimes acts as an optimization: child items that have the <db:link xlink:href="qquickitem.xml#Flag-enum">ItemObservesViewport</db:link> flag may forego creating scene graph nodes that fall outside the viewport. But the <db:code>ItemIsViewport</db:code> flag can also be set independently.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">clip</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setClip</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">clipChanged</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="containmentMask-prop">
<db:title>containmentMask : QObject*</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QObject*</db:type>
<db:varname>containmentMask</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">containmentMask</db:synopsisinfo>
<db:synopsisinfo role="setter">setContainmentMask</db:synopsisinfo>
<db:synopsisinfo role="notifier">containmentMaskChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds an optional mask to be used in the <db:link xlink:href="qquickitem.xml#contains">contains</db:link>() method, which is mainly used for hit-testing each <db:link xlink:href="qpointerevent.xml">QPointerEvent</db:link>.</db:para>
<db:para>By default, <db:link xlink:href="qquickitem.xml#contains">contains</db:link>() will return <db:code>true</db:code> for any point within the Item's bounding box. But any <db:link xlink:href="qquickitem.xml">QQuickItem</db:link>, or any <db:link xlink:href="qobject.xml">QObject</db:link> that implements a function of the form</db:para>
<db:programlisting language="cpp">Q_INVOKABLE bool contains(const QPointF &amp;amp;point) const;
</db:programlisting>
<db:para>can be used as a mask, to defer hit-testing to that object.</db:para>
<db:note>
<db:para><db:link xlink:href="qquickitem.xml#contains">contains</db:link>() is called frequently during event delivery. Deferring hit-testing to another object slows it down somewhat. containmentMask() can cause performance problems if that object's <db:link xlink:href="qquickitem.xml#contains">contains</db:link>() method is not efficient. If you implement a custom <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> subclass, you can alternatively override <db:link xlink:href="qquickitem.xml#contains">contains</db:link>().</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qobject.xml#QObject">QObject</db:link></db:type> *<db:emphasis role="bold">containmentMask</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setContainmentMask</db:emphasis>(<db:type><db:link xlink:href="qobject.xml#QObject">QObject</db:link></db:type> *<db:emphasis>mask</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">containmentMaskChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="enabled-prop">
<db:title>enabled : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>enabled</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isEnabled</db:synopsisinfo>
<db:synopsisinfo role="setter">setEnabled</db:synopsisinfo>
<db:synopsisinfo role="notifier">enabledChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether the item receives mouse and keyboard events. By default this is true.</db:para>
<db:para>Setting this property directly affects the <db:code>enabled</db:code> value of child items. When set to <db:code>false</db:code>, the <db:code>enabled</db:code> values of all child items also become <db:code>false</db:code>. When set to <db:code>true</db:code>, the <db:code>enabled</db:code> values of child items are returned to <db:code>true</db:code>, unless they have explicitly been set to <db:code>false</db:code>.</db:para>
<db:para>Setting this property to <db:code>false</db:code> automatically causes <db:link xlink:href="qquickitem.xml#activeFocus-prop">activeFocus</db:link> to be set to <db:code>false</db:code>, and this item will longer receive keyboard events.</db:para>
<db:note>
<db:para>Hover events are enabled separately by <db:link xlink:href="qquickitem.xml#setAcceptHoverEvents">setAcceptHoverEvents</db:link>(). Thus, a disabled item can continue to receive hover events, even when this property is <db:code>false</db:code>. This makes it possible to show informational feedback (such as <db:link xlink:href="qml-qtquick-controls-tooltip.xml">ToolTip</db:link>) even when an interactive item is disabled. The same is also true for any <db:link xlink:href="qml-qtquick-hoverhandler.xml">HoverHandlers</db:link> added as children of the item. A <db:link xlink:href="qml-qtquick-hoverhandler.xml">HoverHandler</db:link> can, however, be <db:link xlink:href="qml-qtquick-pointerhandler.xml#enabled-prop">disabled</db:link> explicitly, or for example be bound to the <db:code>enabled</db:code> state of the item.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isEnabled</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setEnabled</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">enabledChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#visible-prop">visible</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="focus-prop">
<db:title>focus : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>focus</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">hasFocus</db:synopsisinfo>
<db:synopsisinfo role="setter">setFocus</db:synopsisinfo>
<db:synopsisinfo role="setter">setFocus</db:synopsisinfo>
<db:synopsisinfo role="notifier">focusChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether the item has focus within the enclosing <db:link xlink:href="qml-qtquick-focusscope.xml">FocusScope</db:link>. If true, this item will gain active focus when the enclosing <db:link xlink:href="qml-qtquick-focusscope.xml">FocusScope</db:link> gains active focus.</db:para>
<db:para>In the following example, <db:code>input</db:code> will be given active focus when <db:code>scope</db:code> gains active focus:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Rectangle {
    width: 100; height: 100

    FocusScope {
        id: scope

        TextInput {
            id: input
            focus: true
        }
    }
}
</db:programlisting>
<db:para>For the purposes of this property, the scene as a whole is assumed to act like a focus scope. On a practical level, that means the following QML will give active focus to <db:code>input</db:code> on startup.</db:para>
<db:programlisting language="qml">Rectangle {
    width: 100; height: 100

    TextInput {
          id: input
          focus: true
    }
}
</db:programlisting>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">hasFocus</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setFocus</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setFocus</db:emphasis>(<db:type>bool</db:type> <db:emphasis>focus</db:emphasis>, <db:type><db:link xlink:href="qt.xml#FocusReason-enum">Qt::FocusReason</db:link></db:type> <db:emphasis>reason</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">focusChanged</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#activeFocus-prop">activeFocus</db:link></db:member>
<db:member><db:link xlink:href="qtquick-input-focus.xml">Keyboard Focus in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="height-prop">
<db:title>[bindable] height : qreal</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>qreal</db:type>
<db:varname>height</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">height</db:synopsisinfo>
<db:synopsisinfo role="setter">setHeight</db:synopsisinfo>
<db:synopsisinfo role="resetter">resetHeight</db:synopsisinfo>
<db:synopsisinfo role="notifier">heightChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>This property holds the height of this item.</db:para>
</db:section>
<db:section xml:id="opacity-prop">
<db:title>opacity : qreal</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>qreal</db:type>
<db:varname>opacity</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">opacity</db:synopsisinfo>
<db:synopsisinfo role="setter">setOpacity</db:synopsisinfo>
<db:synopsisinfo role="notifier">opacityChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the opacity of the item. Opacity is specified as a number between 0.0 (fully transparent) and 1.0 (fully opaque). The default value is 1.0.</db:para>
<db:para>When this property is set, the specified opacity is also applied individually to child items. This may have an unintended effect in some circumstances. For example in the second set of rectangles below, the red rectangle has specified an opacity of 0.5, which affects the opacity of its blue child rectangle even though the child has not specified an opacity.</db:para>
<db:para>Values outside the range of 0 to 1 will be clamped.</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/declarative-item_opacity1.png"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:programlisting language="qml">Item {
    Rectangle {
        color: &quot;red&quot;
        width: 100; height: 100
        Rectangle {
            color: &quot;blue&quot;
            x: 50; y: 50; width: 100; height: 100
        }
    }
}
</db:programlisting>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/declarative-item_opacity2.png"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:programlisting language="qml">Item {
    Rectangle {
        opacity: 0.5
        color: &quot;red&quot;
        width: 100; height: 100
        Rectangle {
            color: &quot;blue&quot;
            x: 50; y: 50; width: 100; height: 100
        }
    }
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Changing an item's opacity does not affect whether the item receives user input events. (In contrast, setting <db:link xlink:href="qquickitem.xml#visible-prop">visible</db:link> property to <db:code>false</db:code> stops mouse events, and setting the <db:link xlink:href="qquickitem.xml#enabled-prop">enabled</db:link> property to <db:code>false</db:code> stops mouse and keyboard events, and also removes active focus from the item.)</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qttypes.xml#qreal-typedef">qreal</db:link></db:type> <db:emphasis role="bold">opacity</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setOpacity</db:emphasis>(<db:emphasis>qreal</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">opacityChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#visible-prop">visible</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="parent-prop">
<db:title>parent : QQuickItem*</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QQuickItem*</db:type>
<db:varname>parent</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">parentItem</db:synopsisinfo>
<db:synopsisinfo role="setter">setParentItem</db:synopsisinfo>
<db:synopsisinfo role="notifier">parentChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the visual parent of the item.</db:para>
<db:note>
<db:para>The concept of the <db:emphasis>visual parent</db:emphasis> differs from that of the <db:emphasis><db:link xlink:href="qobject.xml">QObject</db:link> parent</db:emphasis>. An item's visual parent may not necessarily be the same as its object parent. See <db:link xlink:href="qtquick-visualcanvas-visualparent.xml">Concepts - Visual Parent in Qt Quick</db:link> for more details.</db:para>
</db:note>
<db:note>
<db:para>The notification signal for this property gets emitted during destruction of the visual parent. C++ signal handlers cannot assume that items in the visual parent hierarchy are still fully constructed. Use <db:link xlink:href="qobject.xml#qobject_cast">qobject_cast</db:link> to verify that items in the parent hierarchy can be used safely as the expected type.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qquickitem.xml#QQuickItem">QQuickItem</db:link></db:type> *<db:emphasis role="bold">parentItem</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setParentItem</db:emphasis>(<db:type><db:link xlink:href="qquickitem.xml#QQuickItem">QQuickItem</db:link></db:type> *<db:emphasis>parent</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">parentChanged</db:emphasis>(<db:emphasis>QQuickItem *</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="rotation-prop">
<db:title>rotation : qreal</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>qreal</db:type>
<db:varname>rotation</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">rotation</db:synopsisinfo>
<db:synopsisinfo role="setter">setRotation</db:synopsisinfo>
<db:synopsisinfo role="notifier">rotationChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the rotation of the item in degrees clockwise around its <db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>.</db:para>
<db:para>The default value is 0 degrees (that is, no rotation).</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/declarative-rotation.png"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:programlisting language="qml">Rectangle {
    color: &quot;blue&quot;
    width: 100; height: 100
    Rectangle {
        color: &quot;red&quot;
        x: 25; y: 25; width: 50; height: 50
        rotation: 30
    }
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qttypes.xml#qreal-typedef">qreal</db:link></db:type> <db:emphasis role="bold">rotation</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setRotation</db:emphasis>(<db:emphasis>qreal</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">rotationChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-transform.xml">Transform</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-rotation.xml">Rotation</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="scale-prop">
<db:title>scale : qreal</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>qreal</db:type>
<db:varname>scale</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">scale</db:synopsisinfo>
<db:synopsisinfo role="setter">setScale</db:synopsisinfo>
<db:synopsisinfo role="notifier">scaleChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the scale factor for this item.</db:para>
<db:para>A scale of less than 1.0 causes the item to be rendered at a smaller size, and a scale greater than 1.0 renders the item at a larger size. A negative scale causes the item to be mirrored when rendered.</db:para>
<db:para>The default value is 1.0.</db:para>
<db:para>Scaling is applied from the <db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>.</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/declarative-scale.png"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:programlisting language="qml">import QtQuick 2.0

Rectangle {
    color: &quot;blue&quot;
    width: 100; height: 100

    Rectangle {
        color: &quot;green&quot;
        width: 25; height: 25
    }

    Rectangle {
        color: &quot;red&quot;
        x: 25; y: 25; width: 50; height: 50
        scale: 1.4
    }
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qttypes.xml#qreal-typedef">qreal</db:link></db:type> <db:emphasis role="bold">scale</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setScale</db:emphasis>(<db:emphasis>qreal</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">scaleChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-transform.xml">Transform</db:link></db:member>
<db:member><db:link xlink:href="qml-qtquick-scale.xml">Scale</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="smooth-prop">
<db:title>smooth : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>smooth</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">smooth</db:synopsisinfo>
<db:synopsisinfo role="setter">setSmooth</db:synopsisinfo>
<db:synopsisinfo role="notifier">smoothChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Specifies whether the item is smoothed or not</db:para>
<db:para>Primarily used in image based items to decide if the item should use smooth sampling or not. Smooth sampling is performed using linear interpolation, while non-smooth is performed using nearest neighbor.</db:para>
<db:para>In Qt Quick 2.0, this property has minimal impact on performance.</db:para>
<db:para>By default, this property is set to <db:code>true</db:code>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">smooth</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setSmooth</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">smoothChanged</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="state-prop">
<db:title>state : QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>state</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">state</db:synopsisinfo>
<db:synopsisinfo role="setter">setState</db:synopsisinfo>
<db:synopsisinfo role="notifier">stateChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the name of the current state of the item.</db:para>
<db:para>If the item is in its default state, that is, no explicit state has been set, then this property holds an empty string. Likewise, you can return an item to its default state by setting this property to an empty string.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">state</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setState</db:emphasis>(<db:emphasis>const QString &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">stateChanged</db:emphasis>(<db:emphasis>const QString &amp;</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-statesanimations-states.xml">Qt Quick States</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="transformOrigin-prop">
<db:title>transformOrigin : TransformOrigin</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>TransformOrigin</db:type>
<db:varname>transformOrigin</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">transformOrigin</db:synopsisinfo>
<db:synopsisinfo role="setter">setTransformOrigin</db:synopsisinfo>
<db:synopsisinfo role="notifier">transformOriginChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the origin point around which scale and rotation transform.</db:para>
<db:para>Nine transform origins are available, as shown in the image below. The default transform origin is <db:code>Item.Center</db:code>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/declarative-transformorigin.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qquickitem.xml#TransformOrigin-enum">QQuickItem::TransformOrigin</db:link></db:type> <db:emphasis role="bold">transformOrigin</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setTransformOrigin</db:emphasis>(<db:emphasis>QQuickItem::TransformOrigin</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">transformOriginChanged</db:emphasis>(<db:emphasis>QQuickItem::TransformOrigin</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="visible-prop">
<db:title>visible : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>visible</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isVisible</db:synopsisinfo>
<db:synopsisinfo role="setter">setVisible</db:synopsisinfo>
<db:synopsisinfo role="notifier">visibleChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether the item is visible. By default this is true.</db:para>
<db:para>Setting this property directly affects the <db:code>visible</db:code> value of child items. When set to <db:code>false</db:code>, the <db:code>visible</db:code> values of all child items also become <db:code>false</db:code>. When set to <db:code>true</db:code>, the <db:code>visible</db:code> values of child items are returned to <db:code>true</db:code>, unless they have explicitly been set to <db:code>false</db:code>.</db:para>
<db:para>(Because of this flow-on behavior, using the <db:code>visible</db:code> property may not have the intended effect if a property binding should only respond to explicit property changes. In such cases it may be better to use the <db:link xlink:href="qquickitem.xml#opacity">opacity</db:link> property instead.)</db:para>
<db:para>If this property is set to <db:code>false</db:code>, the item will no longer receive mouse events, but will continue to receive key events and will retain the keyboard <db:link xlink:href="qquickitem.xml#focus-prop">focus</db:link> if it has been set. (In contrast, setting the <db:link xlink:href="qquickitem.xml#enabled-prop">enabled</db:link> property to <db:code>false</db:code> stops both mouse and keyboard events, and also removes focus from the item.)</db:para>
<db:note>
<db:para>This property's value is only affected by changes to this property or the parent's <db:code>visible</db:code> property. It does not change, for example, if this item moves off-screen, or if the <db:link xlink:href="qquickitem.xml#opacity">opacity</db:link> changes to 0. However, for historical reasons, this property is true after the item's construction, even if the item hasn't been added to a scene yet. Changing or reading this property of an item that has not been added to a scene might not produce the expected results.</db:para>
</db:note>
<db:note>
<db:para>The notification signal for this property gets emitted during destruction of the visual parent. C++ signal handlers cannot assume that items in the visual parent hierarchy are still fully constructed. Use <db:link xlink:href="qobject.xml#qobject_cast">qobject_cast</db:link> to verify that items in the parent hierarchy can be used safely as the expected type.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isVisible</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setVisible</db:emphasis>(<db:emphasis>bool</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">visibleChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#opacity">opacity</db:link></db:member>
<db:member><db:link xlink:href="qquickitem.xml#enabled-prop">enabled</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="width-prop">
<db:title>[bindable] width : qreal</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>qreal</db:type>
<db:varname>width</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">width</db:synopsisinfo>
<db:synopsisinfo role="setter">setWidth</db:synopsisinfo>
<db:synopsisinfo role="resetter">resetWidth</db:synopsisinfo>
<db:synopsisinfo role="notifier">widthChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>This property holds the width of this item.</db:para>
</db:section>
<db:section xml:id="x-prop">
<db:title>[bindable] x : qreal</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>qreal</db:type>
<db:varname>x</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">x</db:synopsisinfo>
<db:synopsisinfo role="setter">setX</db:synopsisinfo>
<db:synopsisinfo role="notifier">xChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>Defines the item's x position relative to its parent.</db:para>
</db:section>
<db:section xml:id="y-prop">
<db:title>[bindable] y : qreal</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>qreal</db:type>
<db:varname>y</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">y</db:synopsisinfo>
<db:synopsisinfo role="setter">setY</db:synopsisinfo>
<db:synopsisinfo role="notifier">yChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property supports <db:link xlink:href="qproperty.xml">QProperty</db:link> bindings.</db:para>
<db:para>Defines the item's y position relative to its parent.</db:para>
</db:section>
<db:section xml:id="z-prop">
<db:title>z : qreal</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>qreal</db:type>
<db:varname>z</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">z</db:synopsisinfo>
<db:synopsisinfo role="setter">setZ</db:synopsisinfo>
<db:synopsisinfo role="notifier">zChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Sets the stacking order of sibling items. By default the stacking order is 0.</db:para>
<db:para>Items with a higher stacking value are drawn on top of siblings with a lower stacking order. Items with the same stacking value are drawn bottom up in the order they appear. Items with a negative stacking value are drawn under their parent's content.</db:para>
<db:para>The following example shows the various effects of stacking order.</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/declarative-item_stacking1.png"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:para>Same <db:code>z</db:code> - later children above earlier children:</db:para>
<db:programlisting language="qml">Item {
    Rectangle {
        color: &quot;red&quot;
        width: 100; height: 100
    }
    Rectangle {
        color: &quot;blue&quot;
        x: 50; y: 50; width: 100; height: 100
    }
}
</db:programlisting>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/declarative-item_stacking2.png"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:para>Higher <db:code>z</db:code> on top:</db:para>
<db:programlisting language="qml">Item {
    Rectangle {
        z: 1
        color: &quot;red&quot;
        width: 100; height: 100
    }
    Rectangle {
        color: &quot;blue&quot;
        x: 50; y: 50; width: 100; height: 100
    }
}
</db:programlisting>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/declarative-item_stacking3.png"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:para>Same <db:code>z</db:code> - children above parents:</db:para>
<db:programlisting language="qml">Item {
    Rectangle {
        color: &quot;red&quot;
        width: 100; height: 100
        Rectangle {
            color: &quot;blue&quot;
            x: 50; y: 50; width: 100; height: 100
        }
    }
}
</db:programlisting>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/declarative-item_stacking4.png"/>
</db:imageobject>
</db:mediaobject>
</db:td>
<db:td>
<db:para>Lower <db:code>z</db:code> below:</db:para>
<db:programlisting language="qml">Item {
    Rectangle {
        color: &quot;red&quot;
        width: 100; height: 100
        Rectangle {
            z: -1
            color: &quot;blue&quot;
            x: 50; y: 50; width: 100; height: 100
        }
    }
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qttypes.xml#qreal-typedef">qreal</db:link></db:type> <db:emphasis role="bold">z</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setZ</db:emphasis>(<db:emphasis>qreal</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">zChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QQuickItem">
<db:title>[explicit] QQuickItem::QQuickItem(QQuickItem *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QQuickItem</db:methodname>
<db:methodparam>
<db:type>QQuickItem *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickItem(QQuickItem *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> with the given <db:code role="parameter">parent</db:code>.</db:para>
<db:para>The <db:code>parent</db:code> will be used as both the <db:link xlink:href="qquickitem.xml#parent-prop">visual parent</db:link> and the <db:link xlink:href="qobject.xml">QObject</db:link> parent.</db:para>
</db:section>
<db:section xml:id="dtor.QQuickItem">
<db:title>[override virtual] QQuickItem::~QQuickItem()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QQuickItem</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QQuickItem() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qquickitem.xml">QQuickItem</db:link>.</db:para>
</db:section>
<db:section xml:id="acceptHoverEvents">
<db:title>bool QQuickItem::acceptHoverEvents() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>acceptHoverEvents</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool acceptHoverEvents() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns whether hover events are accepted by this item.</db:para>
<db:para>The default value is false.</db:para>
<db:para>If this is false, then the item will not receive any hover events through the <db:link xlink:href="qquickitem.xml#hoverEnterEvent">hoverEnterEvent</db:link>(), <db:link xlink:href="qquickitem.xml#hoverMoveEvent">hoverMoveEvent</db:link>() and <db:link xlink:href="qquickitem.xml#hoverLeaveEvent">hoverLeaveEvent</db:link>() functions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#setAcceptHoverEvents">setAcceptHoverEvents</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="acceptTouchEvents">
<db:title>bool QQuickItem::acceptTouchEvents() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>acceptTouchEvents</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool acceptTouchEvents() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns whether touch events are accepted by this item.</db:para>
<db:para>The default value is <db:code>false</db:code>.</db:para>
<db:para>If this is <db:code>false</db:code>, then the item will not receive any touch events through the <db:link xlink:href="qquickitem.xml#touchEvent">touchEvent</db:link>() function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#setAcceptTouchEvents">setAcceptTouchEvents</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="acceptedMouseButtons">
<db:title>Qt::MouseButtons QQuickItem::acceptedMouseButtons() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>Qt::MouseButtons</db:type>
<db:methodname>acceptedMouseButtons</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">Qt::MouseButtons acceptedMouseButtons() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the mouse buttons accepted by this item.</db:para>
<db:para>The default value is <db:link xlink:href="qt.xml#MouseButton-enum">Qt::NoButton</db:link>; that is, no mouse buttons are accepted.</db:para>
<db:para>If an item does not accept the mouse button for a particular mouse event, the mouse event will not be delivered to the item and will be delivered to the next item in the item hierarchy instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#setAcceptedMouseButtons">setAcceptedMouseButtons</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#acceptTouchEvents">acceptTouchEvents</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="boundingRect">
<db:title>[virtual] QRectF QQuickItem::boundingRect() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QRectF</db:type>
<db:methodname>boundingRect</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRectF boundingRect() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the extents of the item in its own coordinate system: a rectangle from <db:code>0, 0</db:code> to <db:link xlink:href="qquickitem.xml#width-prop">width</db:link>() and <db:link xlink:href="qquickitem.xml#height-prop">height</db:link>().</db:para>
</db:section>
<db:section xml:id="childAt">
<db:title>QQuickItem *QQuickItem::childAt(qreal <db:emphasis>x</db:emphasis>, qreal <db:emphasis>y</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQuickItem *</db:type>
<db:methodname>childAt</db:methodname>
<db:methodparam>
<db:type>qreal</db:type>
<db:parameter>x</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qreal</db:type>
<db:parameter>y</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickItem * childAt(qreal x, qreal y) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the first visible child item found at point (<db:code role="parameter">x</db:code>, <db:code role="parameter">y</db:code>) within the coordinate system of this item.</db:para>
<db:para>Returns <db:code>nullptr</db:code> if there is no such item.</db:para>
</db:section>
<db:section xml:id="childItems">
<db:title>QList&lt;QQuickItem *&gt; QQuickItem::childItems() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QQuickItem *&gt;</db:type>
<db:methodname>childItems</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QQuickItem *&gt; childItems() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the children of this item.</db:para>
</db:section>
<db:section xml:id="childMouseEventFilter">
<db:title>[virtual protected] bool QQuickItem::childMouseEventFilter(QQuickItem *<db:emphasis>item</db:emphasis>, QEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>childMouseEventFilter</db:methodname>
<db:methodparam>
<db:type>QQuickItem *</db:type>
<db:parameter>item</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool childMouseEventFilter(QQuickItem *item, QEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this method to filter the pointer events that are received by this item's children.</db:para>
<db:para>This method will only be called if <db:link xlink:href="qquickitem.xml#filtersChildMouseEvents">filtersChildMouseEvents</db:link>() is <db:code>true</db:code>.</db:para>
<db:para>Return <db:code>true</db:code> if the specified <db:code role="parameter">event</db:code> should not be passed on to the specified child <db:code role="parameter">item</db:code>, and <db:code>false</db:code> otherwise. If you return <db:code>true</db:code>, you should also <db:link xlink:href="qevent.xml#accept">accept</db:link> or <db:link xlink:href="qevent.xml#ignore">ignore</db:link> the <db:code role="parameter">event</db:code>, to signal if event propagation should stop or continue. The <db:code role="parameter">event</db:code> will, however, always be sent to all childMouseEventFilters up the parent chain.</db:para>
<db:note>
<db:para>Despite the name, this function filters all <db:link xlink:href="qpointerevent.xml">QPointerEvent</db:link> instances during delivery to all children (typically mouse, touch, and tablet events). When overriding this function in a subclass, we suggest writing generic event-handling code using only the accessors found in <db:link xlink:href="qpointerevent.xml">QPointerEvent</db:link>. Alternatively you can switch on <db:code>event-&gt;type()</db:code> and/or <db:code>event-&gt;device()-&gt;type()</db:code> to handle different event types in different ways.</db:para>
</db:note>
<db:note>
<db:para>Filtering is just one way to share responsibility in case of gestural ambiguity (for example on press, you don't know whether the user will tap or drag). Another way is to call <db:link xlink:href="qpointerevent.xml#addPassiveGrabber">QPointerEvent::addPassiveGrabber</db:link>() on press, so as to non-exclusively monitor the progress of the <db:link xlink:href="qeventpoint.xml">QEventPoint</db:link>. In either case, the item or pointer handler that is monitoring can steal the exclusive grab later on, when it becomes clear that the gesture fits the pattern that it is expecting.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#setFiltersChildMouseEvents">setFiltersChildMouseEvents</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="classBegin">
<db:title>[override virtual protected] void QQuickItem::classBegin()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>classBegin</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void classBegin() override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qqmlparserstatus.xml#classBegin" role="function">QQmlParserStatus::classBegin()</db:link>.</db:para>
<db:para>Derived classes should call the base class method before adding their own action to perform at classBegin.</db:para>
</db:section>
<db:section xml:id="clipRect">
<db:title>[virtual] QRectF QQuickItem::clipRect() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QRectF</db:type>
<db:methodname>clipRect</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRectF clipRect() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the rectangular area within this item that is currently visible in <db:link xlink:href="qquickitem.xml#viewportItem">viewportItem</db:link>(), if there is a viewport and the <db:link xlink:href="qquickitem.xml#Flag-enum">ItemObservesViewport</db:link> flag is set; otherwise, the extents of this item in its own coordinate system: a rectangle from <db:code>0, 0</db:code> to <db:link xlink:href="qquickitem.xml#width-prop">width</db:link>() and <db:link xlink:href="qquickitem.xml#height-prop">height</db:link>(). This is the region intended to remain visible if <db:link xlink:href="qquickitem.xml#clip-prop">clip</db:link> is <db:code>true</db:code>. It can also be used in <db:link xlink:href="qquickitem.xml#updatePaintNode">updatePaintNode</db:link>() to limit the graphics added to the scene graph.</db:para>
<db:para>For example, a large drawing or a large text document might be shown in a Flickable that occupies only part of the application's Window: in that case, Flickable is the viewport item, and a custom content-rendering item may choose to omit scene graph nodes that fall outside the area that is currently visible. If the <db:link xlink:href="qquickitem.xml#Flag-enum">ItemObservesViewport</db:link> flag is set, this area will change each time the user scrolls the content in the Flickable.</db:para>
<db:para>In case of nested viewport items, clipRect() is the intersection of the <db:code>boundingRect</db:code>s of all ancestors that have the <db:link xlink:href="qquickitem.xml#Flag-enum">ItemIsViewport</db:link> flag set, mapped to the coordinate system of <db:emphasis>this</db:emphasis> item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#boundingRect">boundingRect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="componentComplete">
<db:title>[override virtual protected] void QQuickItem::componentComplete()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>componentComplete</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void componentComplete() override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qqmlparserstatus.xml#componentComplete" role="function">QQmlParserStatus::componentComplete()</db:link>.</db:para>
<db:para>Derived classes should call the base class method before adding their own actions to perform at componentComplete.</db:para>
</db:section>
<db:section xml:id="contains">
<db:title>[virtual] bool QQuickItem::contains(const QPointF &amp;<db:emphasis>point</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>point</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(const QPointF &amp;point) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this item contains <db:code role="parameter">point</db:code>, which is in local coordinates; returns <db:code>false</db:code> otherwise.</db:para>
<db:para>This function can be overridden in order to handle point collisions in items with custom shapes. The default implementation checks whether the point is inside <db:link xlink:href="qquickitem.xml#containmentMask-prop">containmentMask</db:link>() if it is set, or inside the bounding box otherwise.</db:para>
<db:note>
<db:para>This method is used for hit-testing each <db:link xlink:href="qeventpoint.xml">QEventPoint</db:link> during event delivery, so the implementation should be kept as lightweight as possible.</db:para>
</db:note>
</db:section>
<db:section xml:id="cursor">
<db:title>QCursor QQuickItem::cursor() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCursor</db:type>
<db:methodname>cursor</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCursor cursor() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the cursor shape for this item.</db:para>
<db:para>The mouse cursor will assume this shape when it is over this item, unless an override cursor is set. See the <db:link xlink:href="qt.xml#CursorShape-enum">list of predefined cursor objects</db:link> for a range of useful shapes.</db:para>
<db:para>If no cursor shape has been set this returns a cursor with the <db:link xlink:href="qt.xml#CursorShape-enum">Qt::ArrowCursor</db:link> shape, however another cursor shape may be displayed if an overlapping item has a valid cursor.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#setCursor">setCursor</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#unsetCursor">unsetCursor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dragEnterEvent">
<db:title>[virtual protected] void QQuickItem::dragEnterEvent(QDragEnterEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>dragEnterEvent</db:methodname>
<db:methodparam>
<db:type>QDragEnterEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void dragEnterEvent(QDragEnterEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive drag-enter events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>Drag and drop events are only provided if the <db:link xlink:href="qquickitem.xml#Flag-enum">ItemAcceptsDrops</db:link> flag has been set for this item.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-drag.xml">Drag</db:link></db:member>
<db:member><db:link xlink:href="dnd.xml">Drag and Drop</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dragLeaveEvent">
<db:title>[virtual protected] void QQuickItem::dragLeaveEvent(QDragLeaveEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>dragLeaveEvent</db:methodname>
<db:methodparam>
<db:type>QDragLeaveEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void dragLeaveEvent(QDragLeaveEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive drag-leave events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>Drag and drop events are only provided if the <db:link xlink:href="qquickitem.xml#Flag-enum">ItemAcceptsDrops</db:link> flag has been set for this item.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-drag.xml">Drag</db:link></db:member>
<db:member><db:link xlink:href="dnd.xml">Drag and Drop</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dragMoveEvent">
<db:title>[virtual protected] void QQuickItem::dragMoveEvent(QDragMoveEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>dragMoveEvent</db:methodname>
<db:methodparam>
<db:type>QDragMoveEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void dragMoveEvent(QDragMoveEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive drag-move events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>Drag and drop events are only provided if the <db:link xlink:href="qquickitem.xml#Flag-enum">ItemAcceptsDrops</db:link> flag has been set for this item.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-drag.xml">Drag</db:link></db:member>
<db:member><db:link xlink:href="dnd.xml">Drag and Drop</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dropEvent">
<db:title>[virtual protected] void QQuickItem::dropEvent(QDropEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>dropEvent</db:methodname>
<db:methodparam>
<db:type>QDropEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void dropEvent(QDropEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive drop events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>Drag and drop events are only provided if the <db:link xlink:href="qquickitem.xml#Flag-enum">ItemAcceptsDrops</db:link> flag has been set for this item.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick-drag.xml">Drag</db:link></db:member>
<db:member><db:link xlink:href="dnd.xml">Drag and Drop</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dumpItemTree">
<db:title>[since 6.3] void QQuickItem::dumpItemTree() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>dumpItemTree</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void dumpItemTree() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Dumps some details about the <db:link xlink:href="qtquick-visualcanvas-visualparent.xml">visual tree of Items</db:link> starting with this item, recursively.</db:para>
<db:note>
<db:para><db:link xlink:href="qobject.xml#dumpObjectTree">QObject::dumpObjectTree</db:link>() dumps a similar tree; but, as explained in <db:link xlink:href="qtquick-visualcanvas-visualparent.xml">Concepts - Visual Parent in Qt Quick</db:link>, an item's <db:link xlink:href="qobject.xml#parent">QObject::parent</db:link>() sometimes differs from its <db:link xlink:href="qquickitem.xml#parent-prop">QQuickItem::parentItem</db:link>(). You can dump both trees to see the difference.</db:para>
</db:note>
<db:note>
<db:para>The exact output format may change in future versions of Qt.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="debug.xml">Debugging Techniques</db:link></db:member>
<db:member><db:link xlink:href="https://doc.qt.io/GammaRay/gammaray-qtquick2-inspector.html">GammaRay's Qt Quick Inspector</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ensurePolished">
<db:title>[since 6.3] void QQuickItem::ensurePolished()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>ensurePolished</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void ensurePolished()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:link xlink:href="qquickitem.xml#updatePolish">updatePolish</db:link>()</db:para>
<db:para>This can be useful for items such as Layouts (or Positioners) which delay calculation of their <db:link xlink:href="qquickitem.xml#implicitWidth">implicitWidth</db:link> and <db:link xlink:href="qquickitem.xml#implicitHeight-prop">implicitHeight</db:link> until they receive a PolishEvent.</db:para>
<db:para>Normally, if e.g. a child item is added or removed to a Layout, the implicit size is not immediately calculated (this is an optimization). In some cases it might be desirable to query the implicit size of the layout right after a child item has been added. If this is the case, use this function right before querying the implicit size.</db:para>
<db:para>This function was introduced in Qt 6.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#updatePolish">updatePolish</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#polish">polish</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="event">
<db:title>[override virtual protected] bool QQuickItem::event(QEvent *<db:emphasis>ev</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>event</db:methodname>
<db:methodparam>
<db:type>QEvent *</db:type>
<db:parameter>ev</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool event(QEvent *ev) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qobject.xml#event" role="function">QObject::event(QEvent *e)</db:link>.</db:para>
</db:section>
<db:section xml:id="filtersChildMouseEvents">
<db:title>bool QQuickItem::filtersChildMouseEvents() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>filtersChildMouseEvents</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool filtersChildMouseEvents() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns whether pointer events intended for this item's children should be filtered through this item.</db:para>
<db:para>If both this item and a child item have <db:link xlink:href="qquickitem.xml#acceptTouchEvents">acceptTouchEvents</db:link>() <db:code>true</db:code>, then when a touch interaction occurs, this item will filter the touch event. But if either this item or the child cannot handle touch events, <db:link xlink:href="qquickitem.xml#childMouseEventFilter">childMouseEventFilter</db:link>() will be called with a synthesized mouse event.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#setFiltersChildMouseEvents">setFiltersChildMouseEvents</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#childMouseEventFilter">childMouseEventFilter</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="flags">
<db:title>QQuickItem::Flags QQuickItem::flags() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQuickItem::Flags</db:type>
<db:methodname>flags</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickItem::Flags flags() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the item flags for this item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#setFlags">setFlags</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#setFlag">setFlag</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="focusInEvent">
<db:title>[virtual protected] void QQuickItem::focusInEvent(<db:emphasis>QFocusEvent *</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>focusInEvent</db:methodname>
<db:methodparam>
<db:type>QFocusEvent *</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void focusInEvent(QFocusEvent *)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive focus-in events for an item. The event information is provided by the <db:code>event</db:code> parameter.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
<db:para>If you do reimplement this function, you should call the base class implementation.</db:para>
</db:section>
<db:section xml:id="focusOutEvent">
<db:title>[virtual protected] void QQuickItem::focusOutEvent(<db:emphasis>QFocusEvent *</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>focusOutEvent</db:methodname>
<db:methodparam>
<db:type>QFocusEvent *</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void focusOutEvent(QFocusEvent *)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive focus-out events for an item. The event information is provided by the <db:code>event</db:code> parameter.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="forceActiveFocus">
<db:title>void QQuickItem::forceActiveFocus()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>forceActiveFocus</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void forceActiveFocus()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Forces active focus on the item.</db:para>
<db:para>This method sets focus on the item and ensures that all ancestor <db:link xlink:href="qml-qtquick-focusscope.xml">FocusScope</db:link> objects in the object hierarchy are also given <db:link xlink:href="qquickitem.xml#focus-prop">focus</db:link>.</db:para>
<db:para>The reason for the focus change will be <db:link xlink:href="qt.xml#FocusReason-enum">Qt::OtherFocusReason</db:link>. Use the overloaded method to specify the focus reason to enable better handling of the focus change.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#activeFocus-prop">activeFocus</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="forceActiveFocus-1">
<db:title>void QQuickItem::forceActiveFocus(Qt::FocusReason <db:emphasis>reason</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>forceActiveFocus</db:methodname>
<db:methodparam>
<db:type>Qt::FocusReason</db:type>
<db:parameter>reason</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void forceActiveFocus(Qt::FocusReason reason)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Forces active focus on the item with the given <db:code role="parameter">reason</db:code>.</db:para>
<db:para>This method sets focus on the item and ensures that all ancestor <db:link xlink:href="qml-qtquick-focusscope.xml">FocusScope</db:link> objects in the object hierarchy are also given <db:link xlink:href="qquickitem.xml#focus-prop">focus</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#activeFocus-prop">activeFocus</db:link></db:member>
<db:member><db:link xlink:href="qt.xml#FocusReason-enum">Qt::FocusReason</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="geometryChange">
<db:title>[virtual protected, since 6.0] void QQuickItem::geometryChange(const QRectF &amp;<db:emphasis>newGeometry</db:emphasis>, const QRectF &amp;<db:emphasis>oldGeometry</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>geometryChange</db:methodname>
<db:methodparam>
<db:type>const QRectF &amp;</db:type>
<db:parameter>newGeometry</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRectF &amp;</db:type>
<db:parameter>oldGeometry</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void geometryChange(const QRectF &amp;newGeometry, const QRectF &amp;oldGeometry)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is called to handle this item's changes in geometry from <db:code role="parameter">oldGeometry</db:code> to <db:code role="parameter">newGeometry</db:code>. If the two geometries are the same, it doesn't do anything.</db:para>
<db:para>Derived classes must call the base class method within their implementation.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="grabToImage-1">
<db:title>QSharedPointer&lt;QQuickItemGrabResult&gt; QQuickItem::grabToImage(const QSize &amp;<db:emphasis>targetSize</db:emphasis> = QSize())</db:title>
<db:methodsynopsis>
<db:type>QSharedPointer&lt;QQuickItemGrabResult&gt;</db:type>
<db:methodname>grabToImage</db:methodname>
<db:methodparam>
<db:type>const QSize &amp;</db:type>
<db:parameter>targetSize</db:parameter>
<db:initializer>QSize()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSharedPointer&lt;QQuickItemGrabResult&gt; grabToImage(const QSize &amp;targetSize)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Grabs the item into an in-memory image.</db:para>
<db:para>The grab happens asynchronously and the signal <db:link xlink:href="qquickitemgrabresult.xml#ready">QQuickItemGrabResult::ready</db:link>() is emitted when the grab has been completed.</db:para>
<db:para>Use <db:code role="parameter">targetSize</db:code> to specify the size of the target image. By default, the result will have the same size as item.</db:para>
<db:para>If the grab could not be initiated, the function returns <db:code>null</db:code>.</db:para>
<db:note>
<db:para>This function will render the item to an offscreen surface and copy that surface from the GPU's memory into the CPU's memory, which can be quite costly. For &quot;live&quot; preview, use <db:link xlink:href="qml-qtquick-item.xml#layer.enabled-prop">layers</db:link> or <db:link xlink:href="qml-qtquick-shadereffectsource.xml">ShaderEffectSource</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickwindow.xml#grabWindow">QQuickWindow::grabWindow</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="heightValid">
<db:title>[protected] bool QQuickItem::heightValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>heightValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool heightValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns whether the height property has been set explicitly.</db:para>
</db:section>
<db:section xml:id="hoverEnterEvent">
<db:title>[virtual protected] void QQuickItem::hoverEnterEvent(QHoverEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>hoverEnterEvent</db:methodname>
<db:methodparam>
<db:type>QHoverEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void hoverEnterEvent(QHoverEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive hover-enter events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>Hover events are only provided if <db:link xlink:href="qquickitem.xml#acceptHoverEvents">acceptHoverEvents</db:link>() is true.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="hoverLeaveEvent">
<db:title>[virtual protected] void QQuickItem::hoverLeaveEvent(QHoverEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>hoverLeaveEvent</db:methodname>
<db:methodparam>
<db:type>QHoverEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void hoverLeaveEvent(QHoverEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive hover-leave events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>Hover events are only provided if <db:link xlink:href="qquickitem.xml#acceptHoverEvents">acceptHoverEvents</db:link>() is true.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="hoverMoveEvent">
<db:title>[virtual protected] void QQuickItem::hoverMoveEvent(QHoverEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>hoverMoveEvent</db:methodname>
<db:methodparam>
<db:type>QHoverEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void hoverMoveEvent(QHoverEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive hover-move events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>Hover events are only provided if <db:link xlink:href="qquickitem.xml#acceptHoverEvents">acceptHoverEvents</db:link>() is true.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="implicitWidth">
<db:title>qreal QQuickItem::implicitWidth() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qreal</db:type>
<db:methodname>implicitWidth</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">implicitWidth</db:synopsisinfo>
<db:synopsisinfo role="signature">qreal implicitWidth() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the width of the item that is implied by other properties that determine the content.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qquickitem.xml#implicitWidth-prop">implicitWidth</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#implicitWidth-prop">setImplicitWidth</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="inputMethodEvent">
<db:title>[virtual protected] void QQuickItem::inputMethodEvent(QInputMethodEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>inputMethodEvent</db:methodname>
<db:methodparam>
<db:type>QInputMethodEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void inputMethodEvent(QInputMethodEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive input method events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="inputMethodQuery">
<db:title>[virtual] QVariant QQuickItem::inputMethodQuery(Qt::InputMethodQuery <db:emphasis>query</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>inputMethodQuery</db:methodname>
<db:methodparam>
<db:type>Qt::InputMethodQuery</db:type>
<db:parameter>query</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant inputMethodQuery(Qt::InputMethodQuery query) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This method is only relevant for input items.</db:para>
<db:para>If this item is an input item, this method should be reimplemented to return the relevant input method flags for the given <db:code role="parameter">query</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qwidget.xml#inputMethodQuery">QWidget::inputMethodQuery</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isAncestorOf">
<db:title>bool QQuickItem::isAncestorOf(const QQuickItem *<db:emphasis>child</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isAncestorOf</db:methodname>
<db:methodparam>
<db:type>const QQuickItem *</db:type>
<db:parameter>child</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isAncestorOf(const QQuickItem *child) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this item is an ancestor of <db:code role="parameter">child</db:code> (i.e., if this item is <db:code role="parameter">child</db:code>'s parent, or one of <db:code role="parameter">child</db:code>'s parent's ancestors).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#parent-prop">parentItem</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isComponentComplete">
<db:title>[protected] bool QQuickItem::isComponentComplete() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isComponentComplete</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isComponentComplete() const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if construction of the QML component is complete; otherwise returns false.</db:para>
<db:para>It is often desirable to delay some processing until the component is completed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#componentComplete">componentComplete</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isFocusScope">
<db:title>bool QQuickItem::isFocusScope() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFocusScope</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFocusScope() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this item is a focus scope, and false otherwise.</db:para>
</db:section>
<db:section xml:id="isTextureProvider">
<db:title>[virtual] bool QQuickItem::isTextureProvider() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isTextureProvider</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isTextureProvider() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this item is a texture provider. The default implementation returns false.</db:para>
<db:para>This function can be called from any thread.</db:para>
</db:section>
<db:section xml:id="itemChange">
<db:title>[virtual protected] void QQuickItem::itemChange(QQuickItem::ItemChange <db:emphasis>change</db:emphasis>, const QQuickItem::ItemChangeData &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>itemChange</db:methodname>
<db:methodparam>
<db:type>QQuickItem::ItemChange</db:type>
<db:parameter>change</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QQuickItem::ItemChangeData &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void itemChange(QQuickItem::ItemChange change, const QQuickItem::ItemChangeData &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Called when <db:code role="parameter">change</db:code> occurs for this item.</db:para>
<db:para><db:code role="parameter">value</db:code> contains extra information relating to the change, when applicable.</db:para>
<db:para>If you re-implement this method in a subclass, be sure to call</db:para>
<db:programlisting language="cpp">QQuickItem::itemChange(change, value);
</db:programlisting>
<db:para>typically at the end of your implementation, to ensure the <db:link xlink:href="qquickitem.xml#windowChanged">windowChanged</db:link>() signal will be emitted.</db:para>
</db:section>
<db:section xml:id="keepMouseGrab">
<db:title>bool QQuickItem::keepMouseGrab() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>keepMouseGrab</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool keepMouseGrab() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns whether mouse input should exclusively remain with this item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#setKeepMouseGrab">setKeepMouseGrab</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keepTouchGrab">
<db:title>bool QQuickItem::keepTouchGrab() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>keepTouchGrab</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool keepTouchGrab() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns whether the touch points grabbed by this item should exclusively remain with this item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#setKeepTouchGrab">setKeepTouchGrab</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#keepMouseGrab">keepMouseGrab</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyPressEvent">
<db:title>[virtual protected] void QQuickItem::keyPressEvent(QKeyEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>keyPressEvent</db:methodname>
<db:methodparam>
<db:type>QKeyEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyPressEvent(QKeyEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive key press events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="keyReleaseEvent">
<db:title>[virtual protected] void QQuickItem::keyReleaseEvent(QKeyEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>keyReleaseEvent</db:methodname>
<db:methodparam>
<db:type>QKeyEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyReleaseEvent(QKeyEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive key release events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="mapFromGlobal-2">
<db:title>QPointF QQuickItem::mapFromGlobal(const QPointF &amp;<db:emphasis>point</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>mapFromGlobal</db:methodname>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>point</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF mapFromGlobal(const QPointF &amp;point) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Maps the given <db:code role="parameter">point</db:code> in the global screen coordinate system to the equivalent point within this item's coordinate system, and returns the mapped coordinate.</db:para>
<db:para>The following properties of the item are used in the mapping: <db:link xlink:href="qquickitem.xml#x-prop">x</db:link>, <db:link xlink:href="qquickitem.xml#y-prop">y</db:link>, <db:link xlink:href="qquickitem.xml#scale-prop">scale</db:link>, <db:link xlink:href="qquickitem.xml#rotation-prop">rotation</db:link>, <db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>, and <db:link xlink:href="qml-qtquick-item.xml#transform-prop">transform</db:link>.</db:para>
<db:para>For example, this may be helpful to add a popup to a Qt Quick component.</db:para>
<db:note>
<db:para>Window positioning is done by the window manager and this value is treated only as a hint. So, the resulting window position may differ from what is expected.</db:para>
</db:note>
<db:note>
<db:para>If this item is in a subscene, e.g. mapped onto a 3D <db:link xlink:href="qtquickcontrols-chattutorial-example.xml#model">Model</db:link> object, the UV mapping is incorporated into this transformation, so that it really goes from screen coordinates to this item's coordinates, as long as <db:code role="parameter">point</db:code> is actually within this item's bounds. The other mapping functions do not yet work that way.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-coordinates.xml">Concepts - Visual Coordinates in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapFromItem-1">
<db:title>QPointF QQuickItem::mapFromItem(const QQuickItem *<db:emphasis>item</db:emphasis>, const QPointF &amp;<db:emphasis>point</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>mapFromItem</db:methodname>
<db:methodparam>
<db:type>const QQuickItem *</db:type>
<db:parameter>item</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>point</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF mapFromItem(const QQuickItem *item, const QPointF &amp;point) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Maps the given <db:code role="parameter">point</db:code> in <db:code role="parameter">item</db:code>'s coordinate system to the equivalent point within this item's coordinate system, and returns the mapped coordinate.</db:para>
<db:para>The following properties of the item are used in the mapping: <db:link xlink:href="qquickitem.xml#x-prop">x</db:link>, <db:link xlink:href="qquickitem.xml#y-prop">y</db:link>, <db:link xlink:href="qquickitem.xml#scale-prop">scale</db:link>, <db:link xlink:href="qquickitem.xml#rotation-prop">rotation</db:link>, <db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>, and <db:link xlink:href="qml-qtquick-item.xml#transform-prop">transform</db:link>.</db:para>
<db:para>If <db:code role="parameter">item</db:code> is <db:code>nullptr</db:code>, this maps <db:code role="parameter">point</db:code> from the coordinate system of the scene.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-coordinates.xml">Concepts - Visual Coordinates in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapFromScene">
<db:title>QPointF QQuickItem::mapFromScene(const QPointF &amp;<db:emphasis>point</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>mapFromScene</db:methodname>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>point</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF mapFromScene(const QPointF &amp;point) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Maps the given <db:code role="parameter">point</db:code> in the scene's coordinate system to the equivalent point within this item's coordinate system, and returns the mapped coordinate.</db:para>
<db:para>The following properties of the item are used in the mapping: <db:link xlink:href="qquickitem.xml#x-prop">x</db:link>, <db:link xlink:href="qquickitem.xml#y-prop">y</db:link>, <db:link xlink:href="qquickitem.xml#scale-prop">scale</db:link>, <db:link xlink:href="qquickitem.xml#rotation-prop">rotation</db:link>, <db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>, and <db:link xlink:href="qml-qtquick-item.xml#transform-prop">transform</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-coordinates.xml">Concepts - Visual Coordinates in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapRectFromItem">
<db:title>QRectF QQuickItem::mapRectFromItem(const QQuickItem *<db:emphasis>item</db:emphasis>, const QRectF &amp;<db:emphasis>rect</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRectF</db:type>
<db:methodname>mapRectFromItem</db:methodname>
<db:methodparam>
<db:type>const QQuickItem *</db:type>
<db:parameter>item</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRectF &amp;</db:type>
<db:parameter>rect</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRectF mapRectFromItem(const QQuickItem *item, const QRectF &amp;rect) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Maps the given <db:code role="parameter">rect</db:code> in <db:code role="parameter">item</db:code>'s coordinate system to the equivalent rectangular area within this item's coordinate system, and returns the mapped rectangle value.</db:para>
<db:para>The following properties of the item are used in the mapping: <db:link xlink:href="qquickitem.xml#x-prop">x</db:link>, <db:link xlink:href="qquickitem.xml#y-prop">y</db:link>, <db:link xlink:href="qquickitem.xml#scale-prop">scale</db:link>, <db:link xlink:href="qquickitem.xml#rotation-prop">rotation</db:link>, <db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>, and <db:link xlink:href="qml-qtquick-item.xml#transform-prop">transform</db:link>.</db:para>
<db:para>If <db:code role="parameter">item</db:code> is <db:code>nullptr</db:code>, this maps <db:code role="parameter">rect</db:code> from the coordinate system of the scene.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-coordinates.xml">Concepts - Visual Coordinates in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapRectFromScene">
<db:title>QRectF QQuickItem::mapRectFromScene(const QRectF &amp;<db:emphasis>rect</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRectF</db:type>
<db:methodname>mapRectFromScene</db:methodname>
<db:methodparam>
<db:type>const QRectF &amp;</db:type>
<db:parameter>rect</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRectF mapRectFromScene(const QRectF &amp;rect) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Maps the given <db:code role="parameter">rect</db:code> in the scene's coordinate system to the equivalent rectangular area within this item's coordinate system, and returns the mapped rectangle value.</db:para>
<db:para>The following properties of the item are used in the mapping: <db:link xlink:href="qquickitem.xml#x-prop">x</db:link>, <db:link xlink:href="qquickitem.xml#y-prop">y</db:link>, <db:link xlink:href="qquickitem.xml#scale-prop">scale</db:link>, <db:link xlink:href="qquickitem.xml#rotation-prop">rotation</db:link>, <db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>, and <db:link xlink:href="qml-qtquick-item.xml#transform-prop">transform</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-coordinates.xml">Concepts - Visual Coordinates in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapRectToItem">
<db:title>QRectF QQuickItem::mapRectToItem(const QQuickItem *<db:emphasis>item</db:emphasis>, const QRectF &amp;<db:emphasis>rect</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRectF</db:type>
<db:methodname>mapRectToItem</db:methodname>
<db:methodparam>
<db:type>const QQuickItem *</db:type>
<db:parameter>item</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRectF &amp;</db:type>
<db:parameter>rect</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRectF mapRectToItem(const QQuickItem *item, const QRectF &amp;rect) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Maps the given <db:code role="parameter">rect</db:code> in this item's coordinate system to the equivalent rectangular area within <db:code role="parameter">item</db:code>'s coordinate system, and returns the mapped rectangle value.</db:para>
<db:para>The following properties of the item are used in the mapping: <db:link xlink:href="qquickitem.xml#x-prop">x</db:link>, <db:link xlink:href="qquickitem.xml#y-prop">y</db:link>, <db:link xlink:href="qquickitem.xml#scale-prop">scale</db:link>, <db:link xlink:href="qquickitem.xml#rotation-prop">rotation</db:link>, <db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>, and <db:link xlink:href="qml-qtquick-item.xml#transform-prop">transform</db:link>.</db:para>
<db:para>If <db:code role="parameter">item</db:code> is <db:code>nullptr</db:code>, this maps <db:code role="parameter">rect</db:code> to the coordinate system of the scene.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-coordinates.xml">Concepts - Visual Coordinates in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapRectToScene">
<db:title>QRectF QQuickItem::mapRectToScene(const QRectF &amp;<db:emphasis>rect</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRectF</db:type>
<db:methodname>mapRectToScene</db:methodname>
<db:methodparam>
<db:type>const QRectF &amp;</db:type>
<db:parameter>rect</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRectF mapRectToScene(const QRectF &amp;rect) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Maps the given <db:code role="parameter">rect</db:code> in this item's coordinate system to the equivalent rectangular area within the scene's coordinate system, and returns the mapped rectangle value.</db:para>
<db:para>The following properties of the item are used in the mapping: <db:link xlink:href="qquickitem.xml#x-prop">x</db:link>, <db:link xlink:href="qquickitem.xml#y-prop">y</db:link>, <db:link xlink:href="qquickitem.xml#scale-prop">scale</db:link>, <db:link xlink:href="qquickitem.xml#rotation-prop">rotation</db:link>, <db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>, and <db:link xlink:href="qml-qtquick-item.xml#transform-prop">transform</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-coordinates.xml">Concepts - Visual Coordinates in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapToGlobal-2">
<db:title>QPointF QQuickItem::mapToGlobal(const QPointF &amp;<db:emphasis>point</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>mapToGlobal</db:methodname>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>point</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF mapToGlobal(const QPointF &amp;point) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Maps the given <db:code role="parameter">point</db:code> in this item's coordinate system to the equivalent point within global screen coordinate system, and returns the mapped coordinate.</db:para>
<db:para>The following properties of the item are used in the mapping: <db:link xlink:href="qquickitem.xml#x-prop">x</db:link>, <db:link xlink:href="qquickitem.xml#y-prop">y</db:link>, <db:link xlink:href="qquickitem.xml#scale-prop">scale</db:link>, <db:link xlink:href="qquickitem.xml#rotation-prop">rotation</db:link>, <db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>, and <db:link xlink:href="qml-qtquick-item.xml#transform-prop">transform</db:link>.</db:para>
<db:para>For example, this may be helpful to add a popup to a Qt Quick component.</db:para>
<db:note>
<db:para>Window positioning is done by the window manager and this value is treated only as a hint. So, the resulting window position may differ from what is expected.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-coordinates.xml">Concepts - Visual Coordinates in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapToItem-1">
<db:title>QPointF QQuickItem::mapToItem(const QQuickItem *<db:emphasis>item</db:emphasis>, const QPointF &amp;<db:emphasis>point</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>mapToItem</db:methodname>
<db:methodparam>
<db:type>const QQuickItem *</db:type>
<db:parameter>item</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>point</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF mapToItem(const QQuickItem *item, const QPointF &amp;point) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Maps the given <db:code role="parameter">point</db:code> in this item's coordinate system to the equivalent point within <db:code role="parameter">item</db:code>'s coordinate system, and returns the mapped coordinate.</db:para>
<db:para>The following properties of the item are used in the mapping: <db:link xlink:href="qquickitem.xml#x-prop">x</db:link>, <db:link xlink:href="qquickitem.xml#y-prop">y</db:link>, <db:link xlink:href="qquickitem.xml#scale-prop">scale</db:link>, <db:link xlink:href="qquickitem.xml#rotation-prop">rotation</db:link>, <db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>, and <db:link xlink:href="qml-qtquick-item.xml#transform-prop">transform</db:link>.</db:para>
<db:para>If <db:code role="parameter">item</db:code> is <db:code>nullptr</db:code>, this maps <db:code role="parameter">point</db:code> to the coordinate system of the scene.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-coordinates.xml">Concepts - Visual Coordinates in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapToScene">
<db:title>QPointF QQuickItem::mapToScene(const QPointF &amp;<db:emphasis>point</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QPointF</db:type>
<db:methodname>mapToScene</db:methodname>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>point</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointF mapToScene(const QPointF &amp;point) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Maps the given <db:code role="parameter">point</db:code> in this item's coordinate system to the equivalent point within the scene's coordinate system, and returns the mapped coordinate.</db:para>
<db:para>The following properties of the item are used in the mapping: <db:link xlink:href="qquickitem.xml#x-prop">x</db:link>, <db:link xlink:href="qquickitem.xml#y-prop">y</db:link>, <db:link xlink:href="qquickitem.xml#scale-prop">scale</db:link>, <db:link xlink:href="qquickitem.xml#rotation-prop">rotation</db:link>, <db:link xlink:href="qquickitem.xml#transformOrigin-prop">transformOrigin</db:link>, and <db:link xlink:href="qml-qtquick-item.xml#transform-prop">transform</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-coordinates.xml">Concepts - Visual Coordinates in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseDoubleClickEvent">
<db:title>[virtual protected] void QQuickItem::mouseDoubleClickEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mouseDoubleClickEvent</db:methodname>
<db:methodparam>
<db:type>QMouseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseDoubleClickEvent(QMouseEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive mouse double-click events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="mouseMoveEvent">
<db:title>[virtual protected] void QQuickItem::mouseMoveEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mouseMoveEvent</db:methodname>
<db:methodparam>
<db:type>QMouseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseMoveEvent(QMouseEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive mouse move events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>In order to receive mouse movement events, the preceding mouse press event must be accepted (by overriding <db:link xlink:href="qquickitem.xml#mousePressEvent">mousePressEvent</db:link>(), for example) and <db:link xlink:href="qquickitem.xml#acceptedMouseButtons">acceptedMouseButtons</db:link>() must return the relevant mouse button.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="mousePressEvent">
<db:title>[virtual protected] void QQuickItem::mousePressEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mousePressEvent</db:methodname>
<db:methodparam>
<db:type>QMouseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mousePressEvent(QMouseEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive mouse press events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>In order to receive mouse press events, <db:link xlink:href="qquickitem.xml#acceptedMouseButtons">acceptedMouseButtons</db:link>() must return the relevant mouse button.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="mouseReleaseEvent">
<db:title>[virtual protected] void QQuickItem::mouseReleaseEvent(QMouseEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mouseReleaseEvent</db:methodname>
<db:methodparam>
<db:type>QMouseEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseReleaseEvent(QMouseEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive mouse release events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>In order to receive mouse release events, the preceding mouse press event must be accepted (by overriding <db:link xlink:href="qquickitem.xml#mousePressEvent">mousePressEvent</db:link>(), for example) and <db:link xlink:href="qquickitem.xml#acceptedMouseButtons">acceptedMouseButtons</db:link>() must return the relevant mouse button.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="mouseUngrabEvent">
<db:title>[virtual protected] void QQuickItem::mouseUngrabEvent()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>mouseUngrabEvent</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseUngrabEvent()</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to be notified when a mouse ungrab event has occurred on this item.</db:para>
</db:section>
<db:section xml:id="nextItemInFocusChain">
<db:title>QQuickItem *QQuickItem::nextItemInFocusChain(bool <db:emphasis>forward</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:type>QQuickItem *</db:type>
<db:methodname>nextItemInFocusChain</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>forward</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickItem * nextItemInFocusChain(bool forward)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the item in the focus chain which is next to this item. If <db:code role="parameter">forward</db:code> is <db:code>true</db:code>, or not supplied, it is the next item in the forwards direction. If <db:code role="parameter">forward</db:code> is <db:code>false</db:code>, it is the next item in the backwards direction.</db:para>
</db:section>
<db:section xml:id="polish">
<db:title>void QQuickItem::polish()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>polish</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void polish()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Schedules a polish event for this item.</db:para>
<db:para>When the scene graph processes the request, it will call <db:link xlink:href="qquickitem.xml#updatePolish">updatePolish</db:link>() on this item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#updatePolish">updatePolish</db:link>()</db:member>
<db:member><db:link xlink:href="qquicktest.xml#qIsPolishScheduled">QQuickTest::qIsPolishScheduled</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#ensurePolished">ensurePolished</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="releaseResources">
<db:title>[virtual protected] void QQuickItem::releaseResources()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>releaseResources</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void releaseResources()</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is called when an item should release graphics resources which are not already managed by the nodes returned from <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>().</db:para>
<db:para>This happens when the item is about to be removed from the window it was previously rendering to. The item is guaranteed to have a <db:link xlink:href="qquickitem.xml#window">window</db:link> when the function is called.</db:para>
<db:para>The function is called on the GUI thread and the state of the rendering thread, when it is used, is unknown. Objects should not be deleted directly, but instead scheduled for cleanup using <db:link xlink:href="qquickwindow.xml#scheduleRenderJob">QQuickWindow::scheduleRenderJob</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#graphics-resource-handling">Graphics Resource Handling</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="scopedFocusItem">
<db:title>QQuickItem *QQuickItem::scopedFocusItem() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQuickItem *</db:type>
<db:methodname>scopedFocusItem</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickItem * scopedFocusItem() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If this item is a focus scope, this returns the item in its focus chain that currently has focus.</db:para>
<db:para>Returns <db:code>nullptr</db:code> if this item is not a focus scope.</db:para>
</db:section>
<db:section xml:id="setAcceptHoverEvents">
<db:title>void QQuickItem::setAcceptHoverEvents(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setAcceptHoverEvents</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enabled</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setAcceptHoverEvents(bool enabled)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">enabled</db:code> is true, this sets the item to accept hover events; otherwise, hover events are not accepted by this item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#acceptHoverEvents">acceptHoverEvents</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAcceptTouchEvents">
<db:title>void QQuickItem::setAcceptTouchEvents(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setAcceptTouchEvents</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enabled</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setAcceptTouchEvents(bool enabled)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">enabled</db:code> is true, this sets the item to accept touch events; otherwise, touch events are not accepted by this item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#acceptTouchEvents">acceptTouchEvents</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAcceptedMouseButtons">
<db:title>void QQuickItem::setAcceptedMouseButtons(Qt::MouseButtons <db:emphasis>buttons</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setAcceptedMouseButtons</db:methodname>
<db:methodparam>
<db:type>Qt::MouseButtons</db:type>
<db:parameter>buttons</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setAcceptedMouseButtons(Qt::MouseButtons buttons)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the mouse buttons accepted by this item to <db:code role="parameter">buttons</db:code>.</db:para>
<db:note>
<db:para>In Qt 5, calling setAcceptedMouseButtons() implicitly caused an item to receive touch events as well as mouse events; but it was recommended to call <db:link xlink:href="qquickitem.xml#setAcceptTouchEvents">setAcceptTouchEvents</db:link>() to subscribe for them. In Qt 6, it is necessary to call <db:link xlink:href="qquickitem.xml#setAcceptTouchEvents">setAcceptTouchEvents</db:link>() to continue to receive them.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#acceptedMouseButtons">acceptedMouseButtons</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCursor">
<db:title>void QQuickItem::setCursor(const QCursor &amp;<db:emphasis>cursor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setCursor</db:methodname>
<db:methodparam>
<db:type>const QCursor &amp;</db:type>
<db:parameter>cursor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setCursor(const QCursor &amp;cursor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the <db:code role="parameter">cursor</db:code> shape for this item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#cursor">cursor</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#unsetCursor">unsetCursor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFiltersChildMouseEvents">
<db:title>void QQuickItem::setFiltersChildMouseEvents(bool <db:emphasis>filter</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFiltersChildMouseEvents</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>filter</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFiltersChildMouseEvents(bool filter)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets whether pointer events intended for this item's children should be filtered through this item.</db:para>
<db:para>If <db:code role="parameter">filter</db:code> is true, <db:link xlink:href="qquickitem.xml#childMouseEventFilter">childMouseEventFilter</db:link>() will be called when a pointer event is triggered for a child item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#filtersChildMouseEvents">filtersChildMouseEvents</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFlag">
<db:title>void QQuickItem::setFlag(QQuickItem::Flag <db:emphasis>flag</db:emphasis>, bool <db:emphasis>enabled</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFlag</db:methodname>
<db:methodparam>
<db:type>QQuickItem::Flag</db:type>
<db:parameter>flag</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enabled</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFlag(QQuickItem::Flag flag, bool enabled)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Enables the specified <db:code role="parameter">flag</db:code> for this item if <db:code role="parameter">enabled</db:code> is true; if <db:code role="parameter">enabled</db:code> is false, the flag is disabled.</db:para>
<db:para>These provide various hints for the item; for example, the <db:link xlink:href="qquickitem.xml#Flag-enum">ItemClipsChildrenToShape</db:link> flag indicates that all children of this item should be clipped to fit within the item area.</db:para>
</db:section>
<db:section xml:id="setFlags">
<db:title>void QQuickItem::setFlags(QQuickItem::Flags <db:emphasis>flags</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFlags</db:methodname>
<db:methodparam>
<db:type>QQuickItem::Flags</db:type>
<db:parameter>flags</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFlags(QQuickItem::Flags flags)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Enables the specified <db:code role="parameter">flags</db:code> for this item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#flags">flags</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#setFlag">setFlag</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setKeepMouseGrab">
<db:title>void QQuickItem::setKeepMouseGrab(bool <db:emphasis>keep</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setKeepMouseGrab</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>keep</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setKeepMouseGrab(bool keep)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets whether the mouse input should remain exclusively with this item.</db:para>
<db:para>This is useful for items that wish to grab and keep mouse interaction following a predefined gesture. For example, an item that is interested in horizontal mouse movement may set <db:link xlink:href="qquickitem.xml#keepMouseGrab">keepMouseGrab</db:link> to true once a threshold has been exceeded. Once <db:link xlink:href="qquickitem.xml#keepMouseGrab">keepMouseGrab</db:link> has been set to true, filtering items will not react to mouse events.</db:para>
<db:para>If <db:code role="parameter">keep</db:code> is false, a filtering item may steal the grab. For example, <db:link xlink:href="qml-qtquick-flickable.xml">Flickable</db:link> may attempt to steal a mouse grab if it detects that the user has begun to move the viewport.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#keepMouseGrab">keepMouseGrab</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setKeepTouchGrab">
<db:title>void QQuickItem::setKeepTouchGrab(bool <db:emphasis>keep</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setKeepTouchGrab</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>keep</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setKeepTouchGrab(bool keep)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets whether the touch points grabbed by this item should remain exclusively with this item.</db:para>
<db:para>This is useful for items that wish to grab and keep specific touch points following a predefined gesture. For example, an item that is interested in horizontal touch point movement may set setKeepTouchGrab to true once a threshold has been exceeded. Once setKeepTouchGrab has been set to true, filtering items will not react to the relevant touch points.</db:para>
<db:para>If <db:code role="parameter">keep</db:code> is false, a filtering item may steal the grab. For example, <db:link xlink:href="qml-qtquick-flickable.xml">Flickable</db:link> may attempt to steal a touch point grab if it detects that the user has begun to move the viewport.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#keepTouchGrab">keepTouchGrab</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#setKeepMouseGrab">setKeepMouseGrab</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSize">
<db:title>void QQuickItem::setSize(const QSizeF &amp;<db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSize</db:methodname>
<db:methodparam>
<db:type>const QSizeF &amp;</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSize(const QSizeF &amp;size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the size of the item to <db:code role="parameter">size</db:code>. This methods preserves any existing binding on width and height; thus any change that triggers the binding to execute again will override the set values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#size">size</db:link></db:member>
<db:member><db:link xlink:href="qquickitem.xml#width-prop">setWidth</db:link></db:member>
<db:member><db:link xlink:href="qquickitem.xml#height-prop">setHeight</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>QSizeF QQuickItem::size() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSizeF</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSizeF size() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size of the item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#setSize">setSize</db:link></db:member>
<db:member><db:link xlink:href="qquickitem.xml#width-prop">width</db:link></db:member>
<db:member><db:link xlink:href="qquickitem.xml#height-prop">height</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stackAfter">
<db:title>void QQuickItem::stackAfter(const QQuickItem *<db:emphasis>sibling</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>stackAfter</db:methodname>
<db:methodparam>
<db:type>const QQuickItem *</db:type>
<db:parameter>sibling</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void stackAfter(const QQuickItem *sibling)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Moves the specified <db:code role="parameter">sibling</db:code> item to the index after this item within the list of children. The order of children affects both the visual stacking order and tab focus navigation order.</db:para>
<db:para>Assuming the z values of both items are the same, this will cause <db:code role="parameter">sibling</db:code> to be rendered below this item.</db:para>
<db:para>If both items have <db:link xlink:href="qquickitem.xml#activeFocusOnTab-prop">activeFocusOnTab</db:link> set to <db:code>true</db:code>, this will also cause the tab focus order to change, with <db:code role="parameter">sibling</db:code> receiving focus before this item.</db:para>
<db:para>The given <db:code role="parameter">sibling</db:code> must be a sibling of this item; that is, they must have the same immediate <db:link xlink:href="qquickitem.xml#parent-prop">parent</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-visualparent.xml">Concepts - Visual Parent in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stackBefore">
<db:title>void QQuickItem::stackBefore(const QQuickItem *<db:emphasis>sibling</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>stackBefore</db:methodname>
<db:methodparam>
<db:type>const QQuickItem *</db:type>
<db:parameter>sibling</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void stackBefore(const QQuickItem *sibling)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Moves the specified <db:code role="parameter">sibling</db:code> item to the index before this item within the list of children. The order of children affects both the visual stacking order and tab focus navigation order.</db:para>
<db:para>Assuming the z values of both items are the same, this will cause <db:code role="parameter">sibling</db:code> to be rendered above this item.</db:para>
<db:para>If both items have <db:link xlink:href="qquickitem.xml#activeFocusOnTab-prop">activeFocusOnTab</db:link> set to <db:code>true</db:code>, this will also cause the tab focus order to change, with <db:code role="parameter">sibling</db:code> receiving focus after this item.</db:para>
<db:para>The given <db:code role="parameter">sibling</db:code> must be a sibling of this item; that is, they must have the same immediate <db:link xlink:href="qquickitem.xml#parent-prop">parent</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-visualcanvas-visualparent.xml">Concepts - Visual Parent in Qt Quick</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="textureProvider">
<db:title>[virtual] QSGTextureProvider *QQuickItem::textureProvider() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QSGTextureProvider *</db:type>
<db:methodname>textureProvider</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSGTextureProvider * textureProvider() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the texture provider for an item. The default implementation returns <db:code>nullptr</db:code>.</db:para>
<db:para>This function may only be called on the rendering thread.</db:para>
</db:section>
<db:section xml:id="touchEvent">
<db:title>[virtual protected] void QQuickItem::touchEvent(QTouchEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>touchEvent</db:methodname>
<db:methodparam>
<db:type>QTouchEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void touchEvent(QTouchEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive touch events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="touchUngrabEvent">
<db:title>[virtual protected] void QQuickItem::touchUngrabEvent()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>touchUngrabEvent</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void touchUngrabEvent()</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to be notified when a touch ungrab event has occurred on this item.</db:para>
</db:section>
<db:section xml:id="unsetCursor">
<db:title>void QQuickItem::unsetCursor()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>unsetCursor</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void unsetCursor()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Clears the cursor shape for this item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#cursor">cursor</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#setCursor">setCursor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="update">
<db:title>void QQuickItem::update()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>update</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void update()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Schedules a call to <db:link xlink:href="qquickitem.xml#updatePaintNode">updatePaintNode</db:link>() for this item.</db:para>
<db:para>The call to <db:link xlink:href="qquickitem.xml#updatePaintNode">QQuickItem::updatePaintNode</db:link>() will always happen if the item is showing in a <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>.</db:para>
<db:para>Only items which specify <db:link xlink:href="qquickitem.xml#Flag-enum">QQuickItem::ItemHasContents</db:link> are allowed to call QQuickItem::update().</db:para>
</db:section>
<db:section xml:id="updateInputMethod">
<db:title>[protected] void QQuickItem::updateInputMethod(Qt::InputMethodQueries <db:emphasis>queries</db:emphasis> = Qt::ImQueryInput)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>updateInputMethod</db:methodname>
<db:methodparam>
<db:type>Qt::InputMethodQueries</db:type>
<db:parameter>queries</db:parameter>
<db:initializer>Qt::ImQueryInput</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void updateInputMethod(Qt::InputMethodQueries queries)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Notify input method on updated query values if needed. <db:code role="parameter">queries</db:code> indicates the changed attributes.</db:para>
</db:section>
<db:section xml:id="updatePaintNode">
<db:title>[virtual protected] QSGNode *QQuickItem::updatePaintNode(QSGNode *<db:emphasis>oldNode</db:emphasis>, QQuickItem::UpdatePaintNodeData *<db:emphasis>updatePaintNodeData</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QSGNode *</db:type>
<db:methodname>updatePaintNode</db:methodname>
<db:methodparam>
<db:type>QSGNode *</db:type>
<db:parameter>oldNode</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QQuickItem::UpdatePaintNodeData *</db:type>
<db:parameter>updatePaintNodeData</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSGNode * updatePaintNode(QSGNode *oldNode, QQuickItem::UpdatePaintNodeData *updatePaintNodeData)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Called on the render thread when it is time to sync the state of the item with the scene graph.</db:para>
<db:para>The function is called as a result of <db:link xlink:href="qquickitem.xml#update">QQuickItem::update</db:link>(), if the user has set the <db:link xlink:href="qquickitem.xml#Flag-enum">QQuickItem::ItemHasContents</db:link> flag on the item.</db:para>
<db:para>The function should return the root of the scene graph subtree for this item. Most implementations will return a single <db:link xlink:href="qsggeometrynode.xml">QSGGeometryNode</db:link> containing the visual representation of this item. <db:code role="parameter">oldNode</db:code> is the node that was returned the last time the function was called. <db:code role="parameter">updatePaintNodeData</db:code> provides a pointer to the <db:link xlink:href="qsgtransformnode.xml">QSGTransformNode</db:link> associated with this <db:link xlink:href="qquickitem.xml">QQuickItem</db:link>.</db:para>
<db:programlisting language="cpp">QSGNode *MyItem::updatePaintNode(QSGNode *node, UpdatePaintNodeData *)
{
    QSGSimpleRectNode *n = static_cast&amp;lt;QSGSimpleRectNode *&amp;gt;(node);
    if (!n) {
        n = new QSGSimpleRectNode();
        n-&amp;gt;setColor(Qt::red);
    }
    n-&amp;gt;setRect(boundingRect());
    return n;
}
</db:programlisting>
<db:para>The main thread is blocked while this function is executed so it is safe to read values from the <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> instance and other objects in the main thread.</db:para>
<db:para>If no call to QQuickItem::updatePaintNode() result in actual scene graph changes, like <db:link xlink:href="qsgnode.xml#markDirty">QSGNode::markDirty</db:link>() or adding and removing nodes, then the underlying implementation may decide to not render the scene again as the visual outcome is identical.</db:para>
<db:warning>
<db:para>It is crucial that graphics operations and interaction with the scene graph happens exclusively on the render thread, primarily during the QQuickItem::updatePaintNode() call. The best rule of thumb is to only use classes with the &quot;QSG&quot; prefix inside the QQuickItem::updatePaintNode() function.</db:para>
</db:warning>
<db:warning>
<db:para>This function is called on the render thread. This means any QObjects or thread local storage that is created will have affinity to the render thread, so apply caution when doing anything other than rendering in this function. Similarly for signals, these will be emitted on the render thread and will thus often be delivered via queued connections.</db:para>
</db:warning>
<db:note>
<db:para>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <db:link xlink:href="qtquick-visualcanvas-scenegraph.xml#scene-graph-and-rendering">Scene Graph and Rendering</db:link> for more information.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link></db:member>
<db:member><db:link xlink:href="qsggeometrynode.xml">QSGGeometryNode</db:link></db:member>
<db:member><db:link xlink:href="qsggeometry.xml">QSGGeometry</db:link></db:member>
<db:member><db:link xlink:href="qsgflatcolormaterial.xml">QSGFlatColorMaterial</db:link></db:member>
<db:member><db:link xlink:href="qsgtexturematerial.xml">QSGTextureMaterial</db:link></db:member>
<db:member><db:link xlink:href="qsgnode.xml#markDirty">QSGNode::markDirty</db:link>()</db:member>
<db:member><db:link xlink:href="qquickitem.xml#graphics-resource-handling">Graphics Resource Handling</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="updatePolish">
<db:title>[virtual protected] void QQuickItem::updatePolish()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>updatePolish</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void updatePolish()</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function should perform any layout as required for this item.</db:para>
<db:para>When <db:link xlink:href="qquickitem.xml#polish">polish</db:link>() is called, the scene graph schedules a polish event for this item. When the scene graph is ready to render this item, it calls updatePolish() to do any item layout as required before it renders the next frame.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#ensurePolished">ensurePolished</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="viewportItem">
<db:title>QQuickItem *QQuickItem::viewportItem() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQuickItem *</db:type>
<db:methodname>viewportItem</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickItem * viewportItem() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If the <db:link xlink:href="qquickitem.xml#Flag-enum">ItemObservesViewport</db:link> flag is set, returns the nearest parent with the <db:link xlink:href="qquickitem.xml#Flag-enum">ItemIsViewport</db:link> flag. Returns the window's contentItem if the flag is not set, or if no other viewport item is found.</db:para>
<db:para>Returns <db:code>nullptr</db:code> only if there is no viewport item and this item is not shown in a window.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickitem.xml#clipRect">clipRect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="wheelEvent">
<db:title>[virtual protected] void QQuickItem::wheelEvent(QWheelEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>wheelEvent</db:methodname>
<db:methodparam>
<db:type>QWheelEvent *</db:type>
<db:parameter>event</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void wheelEvent(QWheelEvent *event)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This event handler can be reimplemented in a subclass to receive wheel events for an item. The event information is provided by the <db:code role="parameter">event</db:code> parameter.</db:para>
<db:para>The event is accepted by default, so it is not necessary to explicitly accept the event if you reimplement this function. If you don't accept the event, call <db:code>event-&gt;ignore()</db:code>.</db:para>
</db:section>
<db:section xml:id="widthValid">
<db:title>[protected] bool QQuickItem::widthValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>widthValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool widthValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns whether the width property has been set explicitly.</db:para>
</db:section>
<db:section xml:id="window">
<db:title>QQuickWindow *QQuickItem::window() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QQuickWindow *</db:type>
<db:methodname>window</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QQuickWindow * window() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the window in which this item is rendered.</db:para>
<db:para>The item does not have a window until it has been assigned into a scene. The <db:link xlink:href="qquickitem.xml#windowChanged">windowChanged</db:link>() signal provides a notification both when the item is entered into a scene and when it is removed from a scene.</db:para>
</db:section>
<db:section xml:id="windowChanged">
<db:title>void QQuickItem::windowChanged(QQuickWindow *<db:emphasis>window</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>windowChanged</db:methodname>
<db:methodparam>
<db:type>QQuickWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void windowChanged(QQuickWindow *window)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the item's <db:code role="parameter">window</db:code> changes.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QQuickItem</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="grabMouse">
<db:title>void QQuickItem::grabMouse()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>grabMouse</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void grabMouse()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qpointerevent.xml#setExclusiveGrabber">QPointerEvent::setExclusiveGrabber</db:link>().</db:para>
<db:para>Grabs the mouse input.</db:para>
<db:para>This item will receive all mouse events until <db:link xlink:href="qquickitem.xml#ungrabMouse">ungrabMouse</db:link>() is called. Usually this function should not be called, since accepting for example a mouse press event makes sure that the following events are delivered to the item. If an item wants to take over mouse events from the current receiver, it needs to call this function.</db:para>
<db:warning>
<db:para>This function should be used with caution.</db:para>
</db:warning>
</db:section>
<db:section xml:id="grabTouchPoints">
<db:title>void QQuickItem::grabTouchPoints(const QList&lt;int&gt; &amp;<db:emphasis>ids</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>grabTouchPoints</db:methodname>
<db:methodparam>
<db:type>const QList&lt;int&gt; &amp;</db:type>
<db:parameter>ids</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void grabTouchPoints(const QList&lt;int&gt; &amp;ids)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qpointerevent.xml#setExclusiveGrabber">QPointerEvent::setExclusiveGrabber</db:link>(). Grabs the touch points specified by <db:code role="parameter">ids</db:code>.</db:para>
<db:para>These touch points will be owned by the item until they are released. Alternatively, the grab can be stolen by a filtering item like Flickable. Use <db:link xlink:href="qquickitem.xml#setKeepTouchGrab">setKeepTouchGrab</db:link>() to prevent the grab from being stolen.</db:para>
</db:section>
<db:section xml:id="ungrabMouse">
<db:title>void QQuickItem::ungrabMouse()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>ungrabMouse</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void ungrabMouse()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qpointerevent.xml#setExclusiveGrabber">QPointerEvent::setExclusiveGrabber</db:link>().</db:para>
<db:para>Releases the mouse grab following a call to <db:link xlink:href="qquickitem.xml#grabMouse">grabMouse</db:link>().</db:para>
<db:para>Note that this function should only be called when the item wants to stop handling further events. There is no need to call this function after a release or cancel event since no future events will be received in any case. No move or release events will be delivered after this function was called.</db:para>
</db:section>
<db:section xml:id="ungrabTouchPoints">
<db:title>void QQuickItem::ungrabTouchPoints()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>ungrabTouchPoints</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void ungrabTouchPoints()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use QEventPoint::setExclusiveGrabber() instead. Ungrabs the touch points owned by this item.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
