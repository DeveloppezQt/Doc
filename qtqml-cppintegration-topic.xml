<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Integrating QML and C++</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt QML Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Provides instruction to integrate QML and C++.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>QML applications often need to handle more advanced and performance-intensive tasks in C++. The most common and quickest way to do this is to expose the C++ class to the QML runtime, provided the C++ implementation is derived from <db:link xlink:href="qobject.xml">QObject</db:link>. Assuming that you have Qt 5.7 or later installed, the following step-by-step instructions guide you through the process of using the C++ class, BackEnd, in a QML application:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Create a new project using the &quot;Qt Quick Application&quot; template in Qt Creator</db:para>
<db:note>
<db:para>Uncheck the <db:guilabel>With ui.qml file</db:guilabel> option in the <db:guilabel>Define Project Details</db:guilabel> section of <db:guilabel>New Project Wizard</db:guilabel>.</db:para>
</db:note>
</db:listitem>
<db:listitem>
<db:para>Add a new C++ class called <db:code>BackEnd</db:code> to the project and replace its header file contents with:</db:para>
<db:programlisting language="cpp">#ifndef BACKEND_H
#define BACKEND_H

#include &amp;lt;QObject&amp;gt;
#include &amp;lt;QString&amp;gt;

class BackEnd : public QObject
{
    Q_OBJECT
    Q_PROPERTY(QString userName READ userName WRITE setUserName NOTIFY userNameChanged)

public:
    explicit BackEnd(QObject *parent = nullptr);

    QString userName();
    void setUserName(const QString &amp;amp;userName);

signals:
    void userNameChanged();

private:
    QString m_userName;
};

#endif // BACKEND_H
</db:programlisting>
<db:para>The <db:code>Q_PROPERTY</db:code> macro declares a property that could be accessed from QML.</db:para>
</db:listitem>
<db:listitem>
<db:para>Replace its C++ file contents with:</db:para>
<db:programlisting language="cpp">#include &quot;backend.h&quot;

BackEnd::BackEnd(QObject *parent) :
    QObject(parent)
{
}

QString BackEnd::userName()
{
    return m_userName;
}

void BackEnd::setUserName(const QString &amp;amp;userName)
{
    if (userName == m_userName)
        return;

    m_userName = userName;
    emit userNameChanged();
}
</db:programlisting>
<db:para>The <db:code>setUserName</db:code> function emits the <db:code>userNameChanged</db:code> signal every time <db:code>m_userName</db:code> value changes. The signal can be handled from QML using the <db:code>onUserNameChanged</db:code> handler.</db:para>
</db:listitem>
<db:listitem>
<db:para>Include <db:code>&quot;backend.h&quot;</db:code> in <db:code>main.cpp</db:code> and register the class as a QML type under a import URL as shown below:</db:para>
<db:programlisting language="cpp">#include &amp;lt;QGuiApplication&amp;gt;
#include &amp;lt;QQmlApplicationEngine&amp;gt;

#include &quot;backend.h&quot;

int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);

    qmlRegisterType&amp;lt;BackEnd&amp;gt;(&quot;io.qt.examples.backend&quot;, 1, 0, &quot;BackEnd&quot;);

    QQmlApplicationEngine engine;
    engine.load(QUrl(QStringLiteral(&quot;qrc:/main.qml&quot;)));

    return app.exec();
}
</db:programlisting>
<db:para>The BackEnd class is registered as a type, which is accessible from QML by importing the URL, &quot;<db:code>io.qt.examples.backend 1.0</db:code>&quot;.</db:para>
</db:listitem>
<db:listitem>
<db:para>Replace the contents of <db:code>main.qml</db:code> with the following code:</db:para>
<db:programlisting language="qml">import QtQuick 2.6
import QtQuick.Controls 2.0
import io.qt.examples.backend 1.0

ApplicationWindow {
    id: root
    width: 300
    height: 480
    visible: true

    BackEnd {
        id: backend
    }

    TextField {
        text: backend.userName
        placeholderText: qsTr(&quot;User name&quot;)
        anchors.centerIn: parent

        onEditingFinished: backend.userName = text
    }
}
</db:programlisting>
<db:para>The <db:code>BackEnd</db:code> instance lets you access the <db:code>userName</db:code> property, which is updated when the <db:link xlink:href="qml-qtquick-controls2-textfield.xml">TextField</db:link>'s <db:code>text</db:code> property changes.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>Now the application can be run.</db:para>
<db:figure>
<db:title>Application running on Ubuntu</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/cppintegration-ex.png"/>
</db:imageobject>
</db:mediaobject>
</db:figure>
<db:para>Qt offers several methods to integrate C++ with QML, and the method discussed in this tutorial is just one of them. For more details about these methods, refer to <db:link xlink:href="qtqml-cppintegration-overview.xml">Overview - QML and C++ Integration</db:link>.</db:para>
</db:article>
