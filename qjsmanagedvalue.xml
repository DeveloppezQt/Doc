<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QJSManagedValue Class</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt QML Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> represents a value on the JavaScript heap belonging to a <db:link xlink:href="qjsengine.xml">QJSEngine</db:link>.</db:para>
<db:para>This class was introduced in Qt 6.1.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QJSManagedValue</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.1</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Qml)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Qml)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += qml</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> class allows interaction with JavaScript values in most ways you can interact with them from JavaScript itself. You can get and set properties and prototypes, and you can access arrays. Additionally, you can transform the value into the Qt counterparts of JavaScript objects. For example, a Url object may be transformed into a <db:link xlink:href="qurl.xml">QUrl</db:link>.</db:para>
<db:para>A <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is always bound to a particular <db:link xlink:href="qjsengine.xml">QJSEngine</db:link>. You cannot use it independently. This means that you cannot have a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from one engine be a property or a proptotype of a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from a different engine.</db:para>
<db:para>In contrast to <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>, almost all values held by <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> live on the JavaScript heap. There is no inline or unmanaged storage. Therefore, you can get the prototype of a primitive value, and you can get the <db:code>length</db:code> property of a string.</db:para>
<db:para>Only default-constructed or moved-from QJSManagedValues do not hold a value on the JavaScript heap. They represent <db:code>undefined</db:code>, which doesn't have any properties or prototypes.</db:para>
<db:para>Also in contrast to <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>, <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> does not catch any JavaScript exceptions. If an operation on a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> causes an error, it will generally return an <db:code>undefined</db:code> value and <db:link xlink:href="qjsengine.xml#hasError">QJSEngine::hasError</db:link>() will return <db:code>true</db:code> afterwards. You can then catch the exception using <db:link xlink:href="qjsengine.xml#catchError">QJSEngine::catchError</db:link>(), or pass it up the stack, at your own discretion.</db:para>
<db:note>
<db:para>As the reference to the value on the JavaScript heap has to be freed on destruction, you cannot move a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> to a different thread. The destruction would take place in the new thread, which would create a race condition with the garbage collector on the original thread. This also means that you cannot hold a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> beyond the lifespan of its engine.</db:para>
</db:note>
<db:para>The recommended way of working with a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is creating it on the stack, possibly by moving a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> and adding an engine, then performing the necessary operations on it, and finally moving it back into a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> for storage. Moving between <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> and <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> is fast.</db:para>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Type-enum">
<db:title>enum QJSManagedValue::Type</db:title>
<db:enumsynopsis>
<db:enumname>Type</db:enumname>
<db:enumitem>
<db:enumidentifier>Undefined</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Boolean</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Number</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>String</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Object</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Symbol</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Function</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum represents the JavaScript native types, as specified by <db:link xlink:href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">ECMA-262</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::Undefined</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The <db:code>undefined</db:code> type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::Boolean</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The <db:code>boolean</db:code> type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::Number</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The <db:code>number</db:code> type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::String</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The <db:code>string</db:code> type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::Object</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The <db:code>object</db:code> type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::Symbol</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The <db:code>symbol</db:code> type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::Function</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The <db:code>function</db:code> type</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Note that the <db:code>null</db:code> value is not a type of itself but rather a special kind of object. You can query a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> for this condition using the <db:link xlink:href="qjsmanagedvalue.xml#isNull">isNull</db:link>() method. Furthermore, JavaScript has no integer type, but it knows a special treatment of numbers in preparation for integer only operations. You can query a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> to find out whether it holds the result of such a treatment by using the <db:link xlink:href="qjsmanagedvalue.xml#isInteger">isInteger</db:link>() method.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QJSManagedValue-1">
<db:title>QJSManagedValue::QJSManagedValue()</db:title>
<db:constructorsynopsis>
<db:methodname>QJSManagedValue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSManagedValue()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> that represents the JavaScript <db:code>undefined</db:code> value. This is the only value not stored on the JavaScript heap. Calling <db:link xlink:href="qjsmanagedvalue.xml#engine">engine</db:link>() on a default-constructed <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> will return nullptr.</db:para>
</db:section>
<db:section xml:id="QJSManagedValue-2">
<db:title>QJSManagedValue::QJSManagedValue(QJSValue <db:emphasis>value</db:emphasis>, QJSEngine *<db:emphasis>engine</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QJSManagedValue</db:methodname>
<db:methodparam>
<db:type>QJSValue</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QJSEngine *</db:type>
<db:parameter>engine</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSManagedValue(QJSValue value, QJSEngine *engine)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from <db:code role="parameter">value</db:code>, using the heap of <db:code role="parameter">engine</db:code>. If <db:code role="parameter">value</db:code> is itself managed and the engine it belongs to is not <db:code role="parameter">engine</db:code>, the result is an <db:code>undefined</db:code> value, and a warning is generated.</db:para>
</db:section>
<db:section xml:id="QJSManagedValue-3">
<db:title>QJSManagedValue::QJSManagedValue(const QJSPrimitiveValue &amp;<db:emphasis>value</db:emphasis>, QJSEngine *<db:emphasis>engine</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QJSManagedValue</db:methodname>
<db:methodparam>
<db:type>const QJSPrimitiveValue &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QJSEngine *</db:type>
<db:parameter>engine</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSManagedValue(const QJSPrimitiveValue &amp;value, QJSEngine *engine)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from <db:code role="parameter">value</db:code> using the heap of <db:code role="parameter">engine</db:code>.</db:para>
</db:section>
<db:section xml:id="QJSManagedValue-4">
<db:title>QJSManagedValue::QJSManagedValue(const QVariant &amp;<db:emphasis>variant</db:emphasis>, QJSEngine *<db:emphasis>engine</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QJSManagedValue</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>variant</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QJSEngine *</db:type>
<db:parameter>engine</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSManagedValue(const QVariant &amp;variant, QJSEngine *engine)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from <db:code role="parameter">variant</db:code> using the heap of <db:code role="parameter">engine</db:code>.</db:para>
</db:section>
<db:section xml:id="QJSManagedValue-5">
<db:title>QJSManagedValue::QJSManagedValue(const QString &amp;<db:emphasis>string</db:emphasis>, QJSEngine *<db:emphasis>engine</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QJSManagedValue</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>string</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QJSEngine *</db:type>
<db:parameter>engine</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSManagedValue(const QString &amp;string, QJSEngine *engine)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from <db:code role="parameter">string</db:code> using the heap of <db:code role="parameter">engine</db:code>.</db:para>
</db:section>
<db:section xml:id="QJSManagedValue-6">
<db:title>QJSManagedValue::QJSManagedValue(QJSManagedValue &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QJSManagedValue</db:methodname>
<db:methodparam>
<db:type>QJSManagedValue &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSManagedValue(QJSManagedValue &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Move-constructs a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from <db:code role="parameter">other</db:code>. This leaves <db:code role="parameter">other</db:code> in the default-constructed state where it represents undefined and does not belong to any engine.</db:para>
</db:section>
<db:section xml:id="dtor.QJSManagedValue">
<db:title>QJSManagedValue::~QJSManagedValue()</db:title>
<db:destructorsynopsis>
<db:methodname>~QJSManagedValue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QJSManagedValue()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>.</db:para>
<db:note>
<db:para>This frees the memory slot it holds on the JavaScript heap. You must not destroy a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from a different thread than the one where the <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> it belongs to lives.</db:para>
</db:note>
</db:section>
<db:section xml:id="call">
<db:title>QJSValue QJSManagedValue::call(const QJSValueList &amp;<db:emphasis>arguments</db:emphasis> = {}) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJSValue</db:type>
<db:methodname>call</db:methodname>
<db:methodparam>
<db:type>const QJSValueList &amp;</db:type>
<db:parameter>arguments</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue call(const QJSValueList &amp;arguments) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> represents a JavaScript FunctionObject, calls it with the given <db:code role="parameter">arguments</db:code>, and returns the result. Otherwise returns a JavaScript <db:code>undefined</db:code> value.</db:para>
<db:para>The <db:code role="parameter">arguments</db:code> have to be either primitive values or belong to the same <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> as this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. Otherwise the call is not carried out and a JavaScript <db:code>undefined</db:code> value is returned.</db:para>
</db:section>
<db:section xml:id="callAsConstructor">
<db:title>QJSValue QJSManagedValue::callAsConstructor(const QJSValueList &amp;<db:emphasis>arguments</db:emphasis> = {}) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJSValue</db:type>
<db:methodname>callAsConstructor</db:methodname>
<db:methodparam>
<db:type>const QJSValueList &amp;</db:type>
<db:parameter>arguments</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue callAsConstructor(const QJSValueList &amp;arguments) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> represents a JavaScript FunctionObject, calls it as constructor with the given <db:code role="parameter">arguments</db:code>, and returns the result. Otherwise returns a JavaScript <db:code>undefined</db:code> value.</db:para>
<db:para>The <db:code role="parameter">arguments</db:code> have to be either primitive values or belong to the same <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> as this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. Otherwise the call is not carried out and a JavaScript <db:code>undefined</db:code> value is returned.</db:para>
</db:section>
<db:section xml:id="callWithInstance">
<db:title>QJSValue QJSManagedValue::callWithInstance(const QJSValue &amp;<db:emphasis>instance</db:emphasis>, const QJSValueList &amp;<db:emphasis>arguments</db:emphasis> = {}) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJSValue</db:type>
<db:methodname>callWithInstance</db:methodname>
<db:methodparam>
<db:type>const QJSValue &amp;</db:type>
<db:parameter>instance</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QJSValueList &amp;</db:type>
<db:parameter>arguments</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue callWithInstance(const QJSValue &amp;instance, const QJSValueList &amp;arguments) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> represents a JavaScript FunctionObject, calls it on <db:code role="parameter">instance</db:code> with the given <db:code role="parameter">arguments</db:code>, and returns the result. Otherwise returns a JavaScript <db:code>undefined</db:code> value.</db:para>
<db:para>The <db:code role="parameter">arguments</db:code> and the <db:code role="parameter">instance</db:code> have to be either primitive values or belong to the same <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> as this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. Otherwise the call is not carried out and a JavaScript <db:code>undefined</db:code> value is returned.</db:para>
</db:section>
<db:section xml:id="deleteProperty">
<db:title>bool QJSManagedValue::deleteProperty(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>deleteProperty</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool deleteProperty(const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Deletes the property <db:code role="parameter">name</db:code> from this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. Returns <db:code>true</db:code> if the deletion succeeded, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="deleteProperty-1">
<db:title>bool QJSManagedValue::deleteProperty(quint32 <db:emphasis>arrayIndex</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>deleteProperty</db:methodname>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>arrayIndex</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool deleteProperty(quint32 arrayIndex)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Deletes the value stored at <db:code role="parameter">arrayIndex</db:code> from this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. Returns <db:code>true</db:code> if the deletion succeeded, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="engine">
<db:title>QJSEngine *QJSManagedValue::engine() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJSEngine *</db:type>
<db:methodname>engine</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSEngine * engine() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> belongs to. Mind that the engine is always valid, unless the <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is default-constructed or moved from. In the latter case a nullptr is returned.</db:para>
</db:section>
<db:section xml:id="equals">
<db:title>bool QJSManagedValue::equals(const QJSManagedValue &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>equals</db:methodname>
<db:methodparam>
<db:type>const QJSManagedValue &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool equals(const QJSManagedValue &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Invokes the JavaScript '==' operator on this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> and <db:code role="parameter">other</db:code>, and returns the result.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsmanagedvalue.xml#strictlyEquals">strictlyEquals</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasOwnProperty">
<db:title>bool QJSManagedValue::hasOwnProperty(const QString &amp;<db:emphasis>name</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasOwnProperty</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasOwnProperty(const QString &amp;name) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> has a property <db:code role="parameter">name</db:code>, otherwise returns <db:code>false</db:code>. The properties of the prototype chain are not considered.</db:para>
</db:section>
<db:section xml:id="hasOwnProperty-1">
<db:title>bool QJSManagedValue::hasOwnProperty(quint32 <db:emphasis>arrayIndex</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasOwnProperty</db:methodname>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>arrayIndex</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasOwnProperty(quint32 arrayIndex) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> has an array index <db:code role="parameter">arrayIndex</db:code>, otherwise returns <db:code>false</db:code>. The properties of the prototype chain are not considered.</db:para>
</db:section>
<db:section xml:id="hasProperty">
<db:title>bool QJSManagedValue::hasProperty(const QString &amp;<db:emphasis>name</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasProperty</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasProperty(const QString &amp;name) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> has a property <db:code role="parameter">name</db:code>, otherwise returns <db:code>false</db:code>. The properties of the prototype chain are considered.</db:para>
</db:section>
<db:section xml:id="hasProperty-1">
<db:title>bool QJSManagedValue::hasProperty(quint32 <db:emphasis>arrayIndex</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasProperty</db:methodname>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>arrayIndex</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasProperty(quint32 arrayIndex) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> has an array index <db:code role="parameter">arrayIndex</db:code>, otherwise returns <db:code>false</db:code>. The properties of the prototype chain are considered.</db:para>
</db:section>
<db:section xml:id="isArray">
<db:title>bool QJSManagedValue::isArray() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isArray() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this value represents a JavaScript Array object, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isBoolean">
<db:title>bool QJSManagedValue::isBoolean() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isBoolean</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isBoolean() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>boolean</db:code>, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isDate">
<db:title>bool QJSManagedValue::isDate() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isDate</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isDate() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this value represents a JavaScript Date object, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isError">
<db:title>bool QJSManagedValue::isError() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isError</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isError() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this value represents a JavaScript Error object, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isFunction">
<db:title>bool QJSManagedValue::isFunction() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFunction</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFunction() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>function</db:code>, <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isInteger">
<db:title>bool QJSManagedValue::isInteger() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isInteger</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isInteger() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds an integer value, or <db:code>false</db:code> otherwise. The storage format of a number does not affect the result of any operations performed on it, but if an integer is stored, many operations are faster.</db:para>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QJSManagedValue::isNull() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isNull</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isNull() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds the JavaScript <db:code>null</db:code> value, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isNumber">
<db:title>bool QJSManagedValue::isNumber() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isNumber</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isNumber() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>number</db:code>, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isObject">
<db:title>bool QJSManagedValue::isObject() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isObject() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>object</db:code>, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isQMetaObject">
<db:title>bool QJSManagedValue::isQMetaObject() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isQMetaObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isQMetaObject() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this value represents a <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> pointer managed on the JavaScript heap, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isQObject">
<db:title>bool QJSManagedValue::isQObject() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isQObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isQObject() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this value represents a <db:link xlink:href="qobject.xml">QObject</db:link> pointer managed on the JavaScript heap, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isRegularExpression">
<db:title>bool QJSManagedValue::isRegularExpression() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isRegularExpression</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isRegularExpression() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this value represents a JavaScript regular expression object, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isString">
<db:title>bool QJSManagedValue::isString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>string</db:code>, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isSymbol">
<db:title>bool QJSManagedValue::isSymbol() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSymbol</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSymbol() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>symbol</db:code>, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isUndefined">
<db:title>bool QJSManagedValue::isUndefined() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isUndefined</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isUndefined() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>undefined</db:code>, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isUrl">
<db:title>bool QJSManagedValue::isUrl() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isUrl</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isUrl() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this value represents a JavaScript Url object, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isVariant">
<db:title>bool QJSManagedValue::isVariant() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isVariant</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isVariant() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this value represents a <db:link xlink:href="qvariant.xml">QVariant</db:link> managed on the JavaScript heap, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="property">
<db:title>QJSValue QJSManagedValue::property(const QString &amp;<db:emphasis>name</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJSValue</db:type>
<db:methodname>property</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue property(const QString &amp;name) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the property <db:code role="parameter">name</db:code> of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. The prototype chain is searched if the property is not found on the actual object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsmanagedvalue.xml#setProperty">setProperty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-1">
<db:title>QJSValue QJSManagedValue::property(quint32 <db:emphasis>arrayIndex</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJSValue</db:type>
<db:methodname>property</db:methodname>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>arrayIndex</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue property(quint32 arrayIndex) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the property stored at <db:code role="parameter">arrayIndex</db:code> of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. The prototype chain is searched if the property is not found on the actual object.</db:para>
</db:section>
<db:section xml:id="prototype">
<db:title>QJSManagedValue QJSManagedValue::prototype() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJSManagedValue</db:type>
<db:methodname>prototype</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSManagedValue prototype() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the prototype for this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. This works on any value. You can, for example retrieve the JavaScript <db:code>boolean</db:code> prototype from a <db:code>boolean</db:code> value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsmanagedvalue.xml#setPrototype">setPrototype</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProperty">
<db:title>void QJSManagedValue::setProperty(const QString &amp;<db:emphasis>name</db:emphasis>, const QJSValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setProperty</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QJSValue &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setProperty(const QString &amp;name, const QJSValue &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the property <db:code role="parameter">name</db:code> to <db:code role="parameter">value</db:code> on this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. This can only be done on JavaScript values of type <db:code>object</db:code>. Furhermore, <db:code role="parameter">value</db:code> has to be either a primitive or belong to the same engine as this value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsmanagedvalue.xml#property">property</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProperty-1">
<db:title>void QJSManagedValue::setProperty(quint32 <db:emphasis>arrayIndex</db:emphasis>, const QJSValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setProperty</db:methodname>
<db:methodparam>
<db:type>quint32</db:type>
<db:parameter>arrayIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QJSValue &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setProperty(quint32 arrayIndex, const QJSValue &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Stores the <db:code role="parameter">value</db:code> at <db:code role="parameter">arrayIndex</db:code> in this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. This can only be done on JavaScript values of type <db:code>object</db:code>, and it's not recommended if the value is not an array. Furhermore, <db:code role="parameter">value</db:code> has to be either a primitive or belong to the same engine as this value.</db:para>
</db:section>
<db:section xml:id="setPrototype">
<db:title>void QJSManagedValue::setPrototype(const QJSManagedValue &amp;<db:emphasis>prototype</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPrototype</db:methodname>
<db:methodparam>
<db:type>const QJSManagedValue &amp;</db:type>
<db:parameter>prototype</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPrototype(const QJSManagedValue &amp;prototype)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the prototype of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> to <db:code role="parameter">prototype</db:code>. A precondition is that <db:code role="parameter">prototype</db:code> belongs to the same <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> as this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> and is an object (including null). Furthermore, this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> has to be an object (excluding null), too, and you cannot create prototype cycles.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsmanagedvalue.xml#prototype">prototype</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="strictlyEquals">
<db:title>bool QJSManagedValue::strictlyEquals(const QJSManagedValue &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>strictlyEquals</db:methodname>
<db:methodparam>
<db:type>const QJSManagedValue &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool strictlyEquals(const QJSManagedValue &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Invokes the JavaScript '===' operator on this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> and <db:code role="parameter">other</db:code>, and returns the result.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsmanagedvalue.xml#equals">equals</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toBoolean">
<db:title>bool QJSManagedValue::toBoolean() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>toBoolean</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool toBoolean() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the manged value to a boolean. If the managed value holds a boolean, that one is returned. Otherwise a boolean coercion by JavaScript rules is performed.</db:para>
</db:section>
<db:section xml:id="toDateTime">
<db:title>QDateTime QJSManagedValue::toDateTime() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDateTime</db:type>
<db:methodname>toDateTime</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDateTime toDateTime() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds a JavaScript Date object, returns an equivalent <db:link xlink:href="qdatetime.xml">QDateTime</db:link>. Otherwise returns an invalid one.</db:para>
</db:section>
<db:section xml:id="toInteger">
<db:title>int QJSManagedValue::toInteger() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>toInteger</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int toInteger() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the manged value to an integer. This first converts the value to a number by the rules of <db:link xlink:href="qjsmanagedvalue.xml#toNumber">toNumber</db:link>(), and then clamps it into the integer range by the rules given for coercing the arguments to JavaScript bit shift operators into 32bit integers.</db:para>
<db:para>Internally, the value may already be stored as an integer, in which case a fast path is taken.</db:para>
<db:note>
<db:para>Conversion of a managed value to a number can throw an exception. In particular, symbols cannot be coerced into numbers, or a custom valueOf() method may throw. In this case the result is 0 and the engine carries an error after the conversion.</db:para>
</db:note>
<db:note>
<db:para>The JavaScript rules for coercing numbers into 32bit integers are unintuitive.</db:para>
</db:note>
</db:section>
<db:section xml:id="toJSValue">
<db:title>QJSValue QJSManagedValue::toJSValue() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJSValue</db:type>
<db:methodname>toJSValue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSValue toJSValue() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Copies this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> into a new <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>. This is less efficient than move-constructing a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> from a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>, but retains the <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>.</db:para>
</db:section>
<db:section xml:id="toNumber">
<db:title>double QJSManagedValue::toNumber() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>double</db:type>
<db:methodname>toNumber</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">double toNumber() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the manged value to a number. If the managed value holds a number, that one is returned. Otherwise a number coercion by JavaScript rules is performed.</db:para>
<db:note>
<db:para>Conversion of a managed value to a number can throw an exception. In particular, symbols cannot be coerced into numbers, or a custom valueOf() method may throw. In this case the result is 0 and the engine carries an error after the conversion.</db:para>
</db:note>
</db:section>
<db:section xml:id="toPrimitive">
<db:title>QJSPrimitiveValue QJSManagedValue::toPrimitive() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJSPrimitiveValue</db:type>
<db:methodname>toPrimitive</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSPrimitiveValue toPrimitive() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the manged value to a <db:link xlink:href="qjsprimitivevalue.xml">QJSPrimitiveValue</db:link>. If the managed value holds a type supported by <db:link xlink:href="qjsprimitivevalue.xml">QJSPrimitiveValue</db:link>, the value is copied. Otherwise the value is converted to a string, and the string is stored in <db:link xlink:href="qjsprimitivevalue.xml">QJSPrimitiveValue</db:link>.</db:para>
<db:note>
<db:para>Conversion of a managed value to a string can throw an exception. In particular, symbols cannot be coerced into strings, or a custom <db:link xlink:href="qjsmanagedvalue.xml#toString">toString</db:link>() method may throw. In this case the result is the undefined value and the engine carries an error after the conversion.</db:para>
</db:note>
</db:section>
<db:section xml:id="toQMetaObject">
<db:title>const QMetaObject *QJSManagedValue::toQMetaObject() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QMetaObject *</db:type>
<db:methodname>toQMetaObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QMetaObject * toQMetaObject() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds a <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> pointer, returns it. Otherwise returns nullptr.</db:para>
</db:section>
<db:section xml:id="toQObject">
<db:title>QObject *QJSManagedValue::toQObject() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QObject *</db:type>
<db:methodname>toQObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QObject * toQObject() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds a <db:link xlink:href="qobject.xml">QObject</db:link> pointer, returns it. Otherwise returns nullptr.</db:para>
</db:section>
<db:section xml:id="toRegularExpression">
<db:title>QRegularExpression QJSManagedValue::toRegularExpression() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRegularExpression</db:type>
<db:methodname>toRegularExpression</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpression toRegularExpression() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds a JavaScript regular expression object, returns an equivalent <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>. Otherwise returns an invalid one.</db:para>
</db:section>
<db:section xml:id="toString">
<db:title>QString QJSManagedValue::toString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>toString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString toString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the manged value to a string. If the managed value holds a string, that one is returned. Otherwise a string coercion by JavaScript rules is performed.</db:para>
<db:note>
<db:para>Conversion of a managed value to a string can throw an exception. In particular, symbols cannot be coerced into strings, or a custom toString() method may throw. In this case the result is an empty string and the engine carries an error after the conversion.</db:para>
</db:note>
</db:section>
<db:section xml:id="toUrl">
<db:title>QUrl QJSManagedValue::toUrl() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>toUrl</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl toUrl() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds a JavaScript Url object, returns an equivalent <db:link xlink:href="qurl.xml">QUrl</db:link>. Otherwise returns an invalid one.</db:para>
</db:section>
<db:section xml:id="toVariant">
<db:title>QVariant QJSManagedValue::toVariant() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>toVariant</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant toVariant() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Copies this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> into a new <db:link xlink:href="qvariant.xml">QVariant</db:link>. This also creates a useful <db:link xlink:href="qvariant.xml">QVariant</db:link> if <db:link xlink:href="qjsmanagedvalue.xml#isVariant">QJSManagedValue::isVariant</db:link>() returns false. <db:link xlink:href="qvariant.xml">QVariant</db:link> can hold all types supported by <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>.</db:para>
</db:section>
<db:section xml:id="type">
<db:title>QJSManagedValue::Type QJSManagedValue::type() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJSManagedValue::Type</db:type>
<db:methodname>type</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSManagedValue::Type type() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the JavaScript type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QJSManagedValue &amp;QJSManagedValue::operator=(QJSManagedValue &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QJSManagedValue &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QJSManagedValue &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QJSManagedValue &amp; operator=(QJSManagedValue &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Move-assigns a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from <db:code role="parameter">other</db:code>. This leaves <db:code role="parameter">other</db:code> in the default-constructed state where it represents undefined and does not belong to any engine.</db:para>
<db:note>
<db:para>This frees the memory slot this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds on the JavaScript heap. You must not move-assign a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> on a different thread than the one where the <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> it belongs to lives.</db:para>
</db:note>
</db:section>
</db:section>
</db:article>
