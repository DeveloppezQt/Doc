<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QJSManagedValue Class</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Qml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> represents a value on the JavaScript heap belonging to a <db:link xlink:href="qjsengine.xml">QJSEngine</db:link>.</db:para>
<db:para>This class was introduced in Qt 6.1.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QJSManagedValue</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.1</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Qml)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Qml)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += qml</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> class allows interaction with JavaScript values in most ways you can interact with them from JavaScript itself. You can get and set properties and prototypes, and you can access arrays. Additionally, you can transform the value into the Qt counterparts of JavaScript objects. For example, a Url object may be transformed into a <db:link xlink:href="qurl.xml">QUrl</db:link>.</db:para>
<db:para>A <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is always bound to a particular <db:link xlink:href="qjsengine.xml">QJSEngine</db:link>. You cannot use it independently. This means that you cannot have a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from one engine be a property or a proptotype of a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from a different engine.</db:para>
<db:para>In contrast to <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>, almost all values held by <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> live on the JavaScript heap. There is no inline or unmanaged storage. Therefore, you can get the prototype of a primitive value, and you can get the <db:code>length</db:code> property of a string.</db:para>
<db:para>Only default-constructed or moved-from QJSManagedValues do not hold a value on the JavaScript heap. They represent <db:code>undefined</db:code>, which doesn't have any properties or prototypes.</db:para>
<db:para>Also in contrast to <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>, <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> does not catch any JavaScript exceptions. If an operation on a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> causes an error, it will generally return an <db:code>undefined</db:code> value and <db:link xlink:href="qjsengine.xml#hasError">QJSEngine::hasError</db:link>() will return <db:code>true</db:code> afterwards. You can then catch the exception using <db:link xlink:href="qjsengine.xml#catchError">QJSEngine::catchError</db:link>(), or pass it up the stack, at your own discretion.</db:para>
<db:note>
<db:para>As the reference to the value on the JavaScript heap has to be freed on destruction, you cannot move a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> to a different thread. The destruction would take place in the new thread, which would create a race condition with the garbage collector on the original thread. This also means that you cannot hold a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> beyond the lifespan of its engine.</db:para>
</db:note>
<db:para>The recommended way of working with a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is creating it on the stack, possibly by moving a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> and adding an engine, then performing the necessary operations on it, and finally moving it back into a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> for storage. Moving between <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> and <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> is fast.</db:para>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Type-enum">
<db:title>enum QJSManagedValue::Type</db:title>
<db:para>This enum represents the JavaScript native types, as specified by <db:link xlink:href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">ECMA-262</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::Undefined</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The <db:code>undefined</db:code> type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::Boolean</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The <db:code>boolean</db:code> type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::Number</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The <db:code>number</db:code> type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::String</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The <db:code>string</db:code> type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::Object</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The <db:code>object</db:code> type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::Symbol</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The <db:code>symbol</db:code> type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link></db:emphasis>::Function</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The <db:code>function</db:code> type</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Note that the <db:code>null</db:code> value is not a type of itself but rather a special kind of object. You can query a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> for this condition using the <db:link xlink:href="qjsmanagedvalue.xml#isNull">isNull</db:link>() method. Furthermore, JavaScript has no integer type, but it knows a special treatment of numbers in preparation for integer only operations. You can query a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> to find out whether it holds the result of such a treatment by using the <db:link xlink:href="qjsmanagedvalue.xml#isInteger">isInteger</db:link>() method.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QJSManagedValue">
<db:title>[constexpr noexcept] QJSManagedValue::QJSManagedValue()</db:title>
<db:para>Creates a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> that represents the JavaScript <db:code>undefined</db:code> value. This is the only value not stored on the JavaScript heap. Calling <db:link xlink:href="qjsmanagedvalue.xml#engine">engine</db:link>() on a default-constructed <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> will return nullptr.</db:para>
</db:section>
<db:section xml:id="QJSManagedValue-2">
<db:title>QJSManagedValue::QJSManagedValue(QJSValue <db:emphasis>value</db:emphasis>, QJSEngine *<db:emphasis>engine</db:emphasis>)</db:title>
<db:para>Creates a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from <db:code role="parameter">value</db:code>, using the heap of <db:code role="parameter">engine</db:code>. If <db:code role="parameter">value</db:code> is itself managed and the engine it belongs to is not <db:code role="parameter">engine</db:code>, the result is an <db:code>undefined</db:code> value, and a warning is generated.</db:para>
</db:section>
<db:section xml:id="QJSManagedValue-3">
<db:title>QJSManagedValue::QJSManagedValue(const QJSPrimitiveValue &amp;<db:emphasis>value</db:emphasis>, QJSEngine *<db:emphasis>engine</db:emphasis>)</db:title>
<db:para>Creates a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from <db:code role="parameter">value</db:code> using the heap of <db:code role="parameter">engine</db:code>.</db:para>
</db:section>
<db:section xml:id="QJSManagedValue-4">
<db:title>QJSManagedValue::QJSManagedValue(const QString &amp;<db:emphasis>string</db:emphasis>, QJSEngine *<db:emphasis>engine</db:emphasis>)</db:title>
<db:para>Creates a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from <db:code role="parameter">string</db:code> using the heap of <db:code role="parameter">engine</db:code>.</db:para>
</db:section>
<db:section xml:id="QJSManagedValue-5">
<db:title>QJSManagedValue::QJSManagedValue(const QVariant &amp;<db:emphasis>variant</db:emphasis>, QJSEngine *<db:emphasis>engine</db:emphasis>)</db:title>
<db:para>Creates a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from <db:code role="parameter">variant</db:code> using the heap of <db:code role="parameter">engine</db:code>.</db:para>
</db:section>
<db:section xml:id="QJSManagedValue-1">
<db:title>QJSManagedValue::QJSManagedValue(QJSManagedValue &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-constructs a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from <db:code role="parameter">other</db:code>. This leaves <db:code role="parameter">other</db:code> in the default-constructed state where it represents undefined and does not belong to any engine.</db:para>
</db:section>
<db:section xml:id="dtor.QJSManagedValue">
<db:title>[noexcept] QJSManagedValue::~QJSManagedValue()</db:title>
<db:para>Destroys the <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>.</db:para>
<db:note>
<db:para>This frees the memory slot it holds on the JavaScript heap. You must not destroy a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from a different thread than the one where the <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> it belongs to lives.</db:para>
</db:note>
</db:section>
<db:section xml:id="call">
<db:title>QJSValue QJSManagedValue::call(const QJSValueList &amp;<db:emphasis>arguments</db:emphasis> = {}) const</db:title>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> represents a JavaScript FunctionObject, calls it with the given <db:code role="parameter">arguments</db:code>, and returns the result. Otherwise returns a JavaScript <db:code>undefined</db:code> value.</db:para>
<db:para>The <db:code role="parameter">arguments</db:code> have to be either primitive values or belong to the same <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> as this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. Otherwise the call is not carried out and a JavaScript <db:code>undefined</db:code> value is returned.</db:para>
</db:section>
<db:section xml:id="callAsConstructor">
<db:title>QJSValue QJSManagedValue::callAsConstructor(const QJSValueList &amp;<db:emphasis>arguments</db:emphasis> = {}) const</db:title>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> represents a JavaScript FunctionObject, calls it as constructor with the given <db:code role="parameter">arguments</db:code>, and returns the result. Otherwise returns a JavaScript <db:code>undefined</db:code> value.</db:para>
<db:para>The <db:code role="parameter">arguments</db:code> have to be either primitive values or belong to the same <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> as this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. Otherwise the call is not carried out and a JavaScript <db:code>undefined</db:code> value is returned.</db:para>
</db:section>
<db:section xml:id="callWithInstance">
<db:title>QJSValue QJSManagedValue::callWithInstance(const QJSValue &amp;<db:emphasis>instance</db:emphasis>, const QJSValueList &amp;<db:emphasis>arguments</db:emphasis> = {}) const</db:title>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> represents a JavaScript FunctionObject, calls it on <db:code role="parameter">instance</db:code> with the given <db:code role="parameter">arguments</db:code>, and returns the result. Otherwise returns a JavaScript <db:code>undefined</db:code> value.</db:para>
<db:para>The <db:code role="parameter">arguments</db:code> and the <db:code role="parameter">instance</db:code> have to be either primitive values or belong to the same <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> as this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. Otherwise the call is not carried out and a JavaScript <db:code>undefined</db:code> value is returned.</db:para>
</db:section>
<db:section xml:id="deleteProperty">
<db:title>bool QJSManagedValue::deleteProperty(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:para>Deletes the property <db:code role="parameter">name</db:code> from this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. Returns <db:code>true</db:code> if the deletion succeeded, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="deleteProperty-1">
<db:title>bool QJSManagedValue::deleteProperty(quint32 <db:emphasis>arrayIndex</db:emphasis>)</db:title>
<db:para>Deletes the value stored at <db:code role="parameter">arrayIndex</db:code> from this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. Returns <db:code>true</db:code> if the deletion succeeded, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="engine">
<db:title>QJSEngine *QJSManagedValue::engine() const</db:title>
<db:para>Returns the <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> belongs to. Mind that the engine is always valid, unless the <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is default-constructed or moved from. In the latter case a nullptr is returned.</db:para>
</db:section>
<db:section xml:id="equals">
<db:title>bool QJSManagedValue::equals(const QJSManagedValue &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Invokes the JavaScript '==' operator on this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> and <db:code role="parameter">other</db:code>, and returns the result.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsmanagedvalue.xml#strictlyEquals">strictlyEquals</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasOwnProperty">
<db:title>bool QJSManagedValue::hasOwnProperty(const QString &amp;<db:emphasis>name</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> has a property <db:code role="parameter">name</db:code>, otherwise returns <db:code>false</db:code>. The properties of the prototype chain are not considered.</db:para>
</db:section>
<db:section xml:id="hasOwnProperty-1">
<db:title>bool QJSManagedValue::hasOwnProperty(quint32 <db:emphasis>arrayIndex</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> has an array index <db:code role="parameter">arrayIndex</db:code>, otherwise returns <db:code>false</db:code>. The properties of the prototype chain are not considered.</db:para>
</db:section>
<db:section xml:id="hasProperty">
<db:title>bool QJSManagedValue::hasProperty(const QString &amp;<db:emphasis>name</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> has a property <db:code role="parameter">name</db:code>, otherwise returns <db:code>false</db:code>. The properties of the prototype chain are considered.</db:para>
</db:section>
<db:section xml:id="hasProperty-1">
<db:title>bool QJSManagedValue::hasProperty(quint32 <db:emphasis>arrayIndex</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> has an array index <db:code role="parameter">arrayIndex</db:code>, otherwise returns <db:code>false</db:code>. The properties of the prototype chain are considered.</db:para>
</db:section>
<db:section xml:id="isArray">
<db:title>bool QJSManagedValue::isArray() const</db:title>
<db:para>Returns <db:code>true</db:code> if this value represents a JavaScript Array object, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isBoolean">
<db:title>bool QJSManagedValue::isBoolean() const</db:title>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>boolean</db:code>, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isDate">
<db:title>bool QJSManagedValue::isDate() const</db:title>
<db:para>Returns <db:code>true</db:code> if this value represents a JavaScript Date object, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isError">
<db:title>bool QJSManagedValue::isError() const</db:title>
<db:para>Returns <db:code>true</db:code> if this value represents a JavaScript Error object, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isFunction">
<db:title>bool QJSManagedValue::isFunction() const</db:title>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>function</db:code>, <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isInteger">
<db:title>bool QJSManagedValue::isInteger() const</db:title>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds an integer value, or <db:code>false</db:code> otherwise. The storage format of a number does not affect the result of any operations performed on it, but if an integer is stored, many operations are faster.</db:para>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QJSManagedValue::isNull() const</db:title>
<db:para>Returns <db:code>true</db:code> if this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds the JavaScript <db:code>null</db:code> value, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isNumber">
<db:title>bool QJSManagedValue::isNumber() const</db:title>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>number</db:code>, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isObject">
<db:title>bool QJSManagedValue::isObject() const</db:title>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>object</db:code>, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isQMetaObject">
<db:title>bool QJSManagedValue::isQMetaObject() const</db:title>
<db:para>Returns <db:code>true</db:code> if this value represents a <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> pointer managed on the JavaScript heap, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isQObject">
<db:title>bool QJSManagedValue::isQObject() const</db:title>
<db:para>Returns <db:code>true</db:code> if this value represents a <db:link xlink:href="qobject.xml">QObject</db:link> pointer managed on the JavaScript heap, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isRegularExpression">
<db:title>bool QJSManagedValue::isRegularExpression() const</db:title>
<db:para>Returns <db:code>true</db:code> if this value represents a JavaScript regular expression object, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isString">
<db:title>bool QJSManagedValue::isString() const</db:title>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>string</db:code>, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isSymbol">
<db:title>bool QJSManagedValue::isSymbol() const</db:title>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>symbol</db:code>, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isUndefined">
<db:title>bool QJSManagedValue::isUndefined() const</db:title>
<db:para>Returns <db:code>true</db:code> if the type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> is <db:code>undefined</db:code>, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isUrl">
<db:title>bool QJSManagedValue::isUrl() const</db:title>
<db:para>Returns <db:code>true</db:code> if this value represents a JavaScript Url object, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="isVariant">
<db:title>bool QJSManagedValue::isVariant() const</db:title>
<db:para>Returns <db:code>true</db:code> if this value represents a <db:link xlink:href="qvariant.xml">QVariant</db:link> managed on the JavaScript heap, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
<db:section xml:id="property">
<db:title>QJSValue QJSManagedValue::property(const QString &amp;<db:emphasis>name</db:emphasis>) const</db:title>
<db:para>Returns the property <db:code role="parameter">name</db:code> of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. The prototype chain is searched if the property is not found on the actual object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsmanagedvalue.xml#setProperty">setProperty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-1">
<db:title>QJSValue QJSManagedValue::property(quint32 <db:emphasis>arrayIndex</db:emphasis>) const</db:title>
<db:para>Returns the property stored at <db:code role="parameter">arrayIndex</db:code> of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. The prototype chain is searched if the property is not found on the actual object.</db:para>
</db:section>
<db:section xml:id="prototype">
<db:title>QJSManagedValue QJSManagedValue::prototype() const</db:title>
<db:para>Returns the prototype for this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. This works on any value. You can, for example retrieve the JavaScript <db:code>boolean</db:code> prototype from a <db:code>boolean</db:code> value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsmanagedvalue.xml#setPrototype">setPrototype</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProperty">
<db:title>void QJSManagedValue::setProperty(const QString &amp;<db:emphasis>name</db:emphasis>, const QJSValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Sets the property <db:code role="parameter">name</db:code> to <db:code role="parameter">value</db:code> on this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. This can only be done on JavaScript values of type <db:code>object</db:code>. Furhermore, <db:code role="parameter">value</db:code> has to be either a primitive or belong to the same engine as this value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsmanagedvalue.xml#property">property</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProperty-1">
<db:title>void QJSManagedValue::setProperty(quint32 <db:emphasis>arrayIndex</db:emphasis>, const QJSValue &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Stores the <db:code role="parameter">value</db:code> at <db:code role="parameter">arrayIndex</db:code> in this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>. This can only be done on JavaScript values of type <db:code>object</db:code>, and it's not recommended if the value is not an array. Furhermore, <db:code role="parameter">value</db:code> has to be either a primitive or belong to the same engine as this value.</db:para>
</db:section>
<db:section xml:id="setPrototype">
<db:title>void QJSManagedValue::setPrototype(const QJSManagedValue &amp;<db:emphasis>prototype</db:emphasis>)</db:title>
<db:para>Sets the prototype of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> to <db:code role="parameter">prototype</db:code>. A precondition is that <db:code role="parameter">prototype</db:code> belongs to the same <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> as this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> and is an object (including null). Furthermore, this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> has to be an object (excluding null), too, and you cannot create prototype cycles.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsmanagedvalue.xml#prototype">prototype</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="strictlyEquals">
<db:title>bool QJSManagedValue::strictlyEquals(const QJSManagedValue &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Invokes the JavaScript '===' operator on this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> and <db:code role="parameter">other</db:code>, and returns the result.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsmanagedvalue.xml#equals">equals</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toBoolean">
<db:title>bool QJSManagedValue::toBoolean() const</db:title>
<db:para>Converts the manged value to a boolean. If the managed value holds a boolean, that one is returned. Otherwise a boolean coercion by JavaScript rules is performed.</db:para>
</db:section>
<db:section xml:id="toDateTime">
<db:title>QDateTime QJSManagedValue::toDateTime() const</db:title>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds a JavaScript Date object, returns an equivalent <db:link xlink:href="qdatetime.xml">QDateTime</db:link>. Otherwise returns an invalid one.</db:para>
</db:section>
<db:section xml:id="toInteger">
<db:title>int QJSManagedValue::toInteger() const</db:title>
<db:para>Converts the manged value to an integer. This first converts the value to a number by the rules of <db:link xlink:href="qjsmanagedvalue.xml#toNumber">toNumber</db:link>(), and then clamps it into the integer range by the rules given for coercing the arguments to JavaScript bit shift operators into 32bit integers.</db:para>
<db:para>Internally, the value may already be stored as an integer, in which case a fast path is taken.</db:para>
<db:note>
<db:para>Conversion of a managed value to a number can throw an exception. In particular, symbols cannot be coerced into numbers, or a custom valueOf() method may throw. In this case the result is 0 and the engine carries an error after the conversion.</db:para>
</db:note>
<db:note>
<db:para>The JavaScript rules for coercing numbers into 32bit integers are unintuitive.</db:para>
</db:note>
</db:section>
<db:section xml:id="toJSValue">
<db:title>QJSValue QJSManagedValue::toJSValue() const</db:title>
<db:para>Copies this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> into a new <db:link xlink:href="qjsvalue.xml">QJSValue</db:link>. This is less efficient than move-constructing a <db:link xlink:href="qjsvalue.xml">QJSValue</db:link> from a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>, but retains the <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>.</db:para>
</db:section>
<db:section xml:id="toNumber">
<db:title>double QJSManagedValue::toNumber() const</db:title>
<db:para>Converts the manged value to a number. If the managed value holds a number, that one is returned. Otherwise a number coercion by JavaScript rules is performed.</db:para>
<db:note>
<db:para>Conversion of a managed value to a number can throw an exception. In particular, symbols cannot be coerced into numbers, or a custom valueOf() method may throw. In this case the result is 0 and the engine carries an error after the conversion.</db:para>
</db:note>
</db:section>
<db:section xml:id="toPrimitive">
<db:title>QJSPrimitiveValue QJSManagedValue::toPrimitive() const</db:title>
<db:para>Converts the manged value to a <db:link xlink:href="qjsprimitivevalue.xml">QJSPrimitiveValue</db:link>. If the managed value holds a type supported by <db:link xlink:href="qjsprimitivevalue.xml">QJSPrimitiveValue</db:link>, the value is copied. Otherwise the value is converted to a string, and the string is stored in <db:link xlink:href="qjsprimitivevalue.xml">QJSPrimitiveValue</db:link>.</db:para>
<db:note>
<db:para>Conversion of a managed value to a string can throw an exception. In particular, symbols cannot be coerced into strings, or a custom <db:link xlink:href="qjsmanagedvalue.xml#toString">toString</db:link>() method may throw. In this case the result is the undefined value and the engine carries an error after the conversion.</db:para>
</db:note>
</db:section>
<db:section xml:id="toQMetaObject">
<db:title>const QMetaObject *QJSManagedValue::toQMetaObject() const</db:title>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds a <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> pointer, returns it. Otherwise returns nullptr.</db:para>
</db:section>
<db:section xml:id="toQObject">
<db:title>QObject *QJSManagedValue::toQObject() const</db:title>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds a <db:link xlink:href="qobject.xml">QObject</db:link> pointer, returns it. Otherwise returns nullptr.</db:para>
</db:section>
<db:section xml:id="toRegularExpression">
<db:title>QRegularExpression QJSManagedValue::toRegularExpression() const</db:title>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds a JavaScript regular expression object, returns an equivalent <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>. Otherwise returns an invalid one.</db:para>
</db:section>
<db:section xml:id="toString">
<db:title>QString QJSManagedValue::toString() const</db:title>
<db:para>Converts the manged value to a string. If the managed value holds a string, that one is returned. Otherwise a string coercion by JavaScript rules is performed.</db:para>
<db:note>
<db:para>Conversion of a managed value to a string can throw an exception. In particular, symbols cannot be coerced into strings, or a custom toString() method may throw. In this case the result is an empty string and the engine carries an error after the conversion.</db:para>
</db:note>
</db:section>
<db:section xml:id="toUrl">
<db:title>QUrl QJSManagedValue::toUrl() const</db:title>
<db:para>If this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds a JavaScript Url object, returns an equivalent <db:link xlink:href="qurl.xml">QUrl</db:link>. Otherwise returns an invalid one.</db:para>
</db:section>
<db:section xml:id="toVariant">
<db:title>QVariant QJSManagedValue::toVariant() const</db:title>
<db:para>Copies this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> into a new <db:link xlink:href="qvariant.xml">QVariant</db:link>. This also creates a useful <db:link xlink:href="qvariant.xml">QVariant</db:link> if <db:link xlink:href="qjsmanagedvalue.xml#isVariant">QJSManagedValue::isVariant</db:link>() returns false. <db:link xlink:href="qvariant.xml">QVariant</db:link> can hold all types supported by <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>.</db:para>
</db:section>
<db:section xml:id="type">
<db:title>QJSManagedValue::Type QJSManagedValue::type() const</db:title>
<db:para>Returns the JavaScript type of this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link>.</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QJSManagedValue &amp;QJSManagedValue::operator=(QJSManagedValue &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-assigns a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> from <db:code role="parameter">other</db:code>. This leaves <db:code role="parameter">other</db:code> in the default-constructed state where it represents undefined and does not belong to any engine.</db:para>
<db:note>
<db:para>This frees the memory slot this <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> holds on the JavaScript heap. You must not move-assign a <db:link xlink:href="qjsmanagedvalue.xml">QJSManagedValue</db:link> on a different thread than the one where the <db:link xlink:href="qjsengine.xml">QJSEngine</db:link> it belongs to lives.</db:para>
</db:note>
</db:section>
</db:section>
</db:article>
