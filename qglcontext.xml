<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QGLContext Class</db:title>
<db:productname>qtopengl</db:productname>
<db:titleabbrev>qtopengl Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qglcontext.xml">QGLContext</db:link> class encapsulates an OpenGL rendering context.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QGLContext</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>An OpenGL rendering context is a complete set of OpenGL state variables. The rendering context's <db:link xlink:href="qgl.xml#FormatOption-enum">format</db:link> is set in the constructor, but it can also be set later with <db:link xlink:href="qglcontext.xml#setFormat">setFormat</db:link>(). The format options that are actually set are returned by format(); the options you asked for are returned by requestedFormat(). Note that after a <db:link xlink:href="qglcontext.xml">QGLContext</db:link> object has been constructed, the actual OpenGL context must be created by explicitly calling the <db:link xlink:href="qglcontext.xml#create">create</db:link>() function. The makeCurrent() function makes this context the current rendering context. You can make <db:emphasis>no</db:emphasis> context current using doneCurrent(). The <db:link xlink:href="qtextstream.xml#reset-1">reset</db:link>() function will reset the context and make it invalid.</db:para>
<db:para>You can examine properties of the context with, e.g. isValid(), isSharing(), initialized(), windowCreated() and overlayTransparentColor().</db:para>
<db:para>If you're using double buffering you can swap the screen contents with the off-screen buffer using swapBuffers().</db:para>
<db:para>Please note that <db:link xlink:href="qglcontext.xml">QGLContext</db:link> is not thread safe.</db:para>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="BindOption-enum">
<db:title>[since 4.6] enum QGLContext::BindOption</db:title>
<db:bridgehead renderas="sect2">flags QGLContext::BindOptions</db:bridgehead>
<db:para>A set of options to decide how to bind a texture using <db:link xlink:href="qglcontext.xml#bindTexture">bindTexture</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qglcontext.xml">QGLContext</db:link></db:emphasis>::NoBindOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0000</db:code></db:td>
<db:td>
<db:para>Don't do anything, pass the texture straight through.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qglcontext.xml">QGLContext</db:link></db:emphasis>::InvertedYBindOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>Specifies that the texture should be flipped over the X axis so that the texture coordinate 0,0 corresponds to the top left corner. Inverting the texture implies a deep copy prior to upload.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qglcontext.xml">QGLContext</db:link></db:emphasis>::MipmapBindOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0002</db:code></db:td>
<db:td>
<db:para>Specifies that <db:link xlink:href="qglcontext.xml#bindTexture">bindTexture</db:link>() should try to generate mipmaps. If the GL implementation supports the <db:code>GL_SGIS_generate_mipmap</db:code> extension, mipmaps will be automatically generated for the texture. Mipmap generation is only supported for the <db:code>GL_TEXTURE_2D</db:code> target.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qglcontext.xml">QGLContext</db:link></db:emphasis>::PremultipliedAlphaBindOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0004</db:code></db:td>
<db:td>
<db:para>Specifies that the image should be uploaded with premultiplied alpha and does a conversion accordingly.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qglcontext.xml">QGLContext</db:link></db:emphasis>::LinearFilteringBindOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0008</db:code></db:td>
<db:td>
<db:para>Specifies that the texture filtering should be set to GL_LINEAR. Default is GL_NEAREST. If mipmap is also enabled, filtering will be set to GL_LINEAR_MIPMAP_LINEAR.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qglcontext.xml">QGLContext</db:link></db:emphasis>::DefaultBindOption</db:code></db:para>
</db:td>
<db:td><db:code>LinearFilteringBindOption
                                                  | InvertedYBindOption
                                                  | MipmapBindOption</db:code></db:td>
<db:td>
<db:para>In Qt 4.5 and earlier, <db:link xlink:href="qglcontext.xml#bindTexture">bindTexture</db:link>() would mirror the image and automatically generate mipmaps. This option helps preserve this default behavior.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced in Qt 4.6.</db:para>
<db:para>The <db:code>BindOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;BindOption&gt;. </db:code>It stores an OR combination of <db:code>BindOption</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QGLContext">
<db:title>QGLContext::QGLContext(const QGLFormat &amp;<db:emphasis>format</db:emphasis>)</db:title>
<db:para>Constructs an OpenGL context with the given <db:code role="parameter">format</db:code> which specifies several display options for the context.</db:para>
<db:para>If the underlying OpenGL/Window system cannot satisfy all the features requested in <db:code role="parameter">format</db:code>, the nearest subset of features will be used. After creation, the format() method will return the actual format obtained.</db:para>
<db:para>Note that after a <db:link xlink:href="qglcontext.xml">QGLContext</db:link> object has been constructed, <db:link xlink:href="qglcontext.xml#create">create</db:link>() must be called explicitly to create the actual OpenGL context. The context will be invalid if it was not possible to obtain a GL context at all.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">format()</db:link></db:member>
<db:member><db:link xlink:href="">isValid()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QGLContext">
<db:title>[virtual noexcept] QGLContext::~QGLContext()</db:title>
<db:para>Destroys the OpenGL context and frees its resources.</db:para>
</db:section>
<db:section xml:id="areSharing">
<db:title>[static, since 4.6] bool QGLContext::areSharing(const QGLContext *<db:emphasis>context1</db:emphasis>, const QGLContext *<db:emphasis>context2</db:emphasis>)</db:title>
<db:para>Returns true if <db:code role="parameter">context1</db:code> and <db:code role="parameter">context2</db:code> are sharing their GL resources such as textures, shader programs, etc; otherwise returns false.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
</db:section>
<db:section xml:id="bindTexture">
<db:title>[since 4.6] GLuint QGLContext::bindTexture(const QImage &amp;<db:emphasis>image</db:emphasis>, GLenum <db:emphasis>target</db:emphasis>, GLint <db:emphasis>format</db:emphasis>, QGLContext::BindOptions <db:emphasis>options</db:emphasis>)</db:title>
<db:para>Generates and binds a 2D GL texture to the current context, based on <db:code role="parameter">image</db:code>. The generated texture id is returned and can be used in later <db:code>glBindTexture()</db:code> calls.</db:para>
<db:para>The <db:code role="parameter">target</db:code> parameter specifies the texture target. The default target is <db:code>GL_TEXTURE_2D</db:code>.</db:para>
<db:para>The <db:code role="parameter">format</db:code> parameter sets the internal format for the texture. The default format is <db:code>GL_RGBA</db:code>.</db:para>
<db:para>The binding <db:code role="parameter">options</db:code> are a set of options used to decide how to bind the texture to the context.</db:para>
<db:para>The texture that is generated is cached, so multiple calls to bindTexture() with the same <db:link xlink:href="qimage.xml">QImage</db:link> will return the same texture id.</db:para>
<db:para>Note that we assume default values for the glPixelStore() and glPixelTransfer() parameters.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglcontext.xml#deleteTexture">deleteTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindTexture-1">
<db:title>GLuint QGLContext::bindTexture(const QString &amp;<db:emphasis>fileName</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Reads the compressed texture file <db:code role="parameter">fileName</db:code> and generates a 2D GL texture from it.</db:para>
<db:para>This function can load DirectDrawSurface (DDS) textures in the DXT1, DXT3 and DXT5 DDS formats if the <db:code>GL_ARB_texture_compression</db:code> and <db:code>GL_EXT_texture_compression_s3tc</db:code> extensions are supported.</db:para>
<db:para>Since 4.6.1, textures in the ETC1 format can be loaded if the <db:code>GL_OES_compressed_ETC1_RGB8_texture</db:code> extension is supported and the ETC1 texture has been encapsulated in the PVR container format. Also, textures in the PVRTC2 and PVRTC4 formats can be loaded if the <db:code>GL_IMG_texture_compression_pvrtc</db:code> extension is supported.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglcontext.xml#deleteTexture">deleteTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bindTexture-2">
<db:title>GLuint QGLContext::bindTexture(const QImage &amp;<db:emphasis>image</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D, GLint <db:emphasis>format</db:emphasis> = GL_RGBA)</db:title>
<db:para>Generates and binds a 2D GL texture to the current context, based on <db:code role="parameter">image</db:code>. The generated texture id is returned and can be used in later <db:code>glBindTexture()</db:code> calls.</db:para>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="bindTexture-3">
<db:title>GLuint QGLContext::bindTexture(const QPixmap &amp;<db:emphasis>pixmap</db:emphasis>, GLenum <db:emphasis>target</db:emphasis> = GL_TEXTURE_2D, GLint <db:emphasis>format</db:emphasis> = GL_RGBA)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Generates and binds a 2D GL texture based on <db:code role="parameter">pixmap</db:code>.</db:para>
</db:section>
<db:section xml:id="bindTexture-4">
<db:title>[since 4.6] GLuint QGLContext::bindTexture(const QPixmap &amp;<db:emphasis>pixmap</db:emphasis>, GLenum <db:emphasis>target</db:emphasis>, GLint <db:emphasis>format</db:emphasis>, QGLContext::BindOptions <db:emphasis>options</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Generates and binds a 2D GL texture to the current context, based on <db:code role="parameter">pixmap</db:code>.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
</db:section>
<db:section xml:id="create">
<db:title>[virtual] bool QGLContext::create(const QGLContext *<db:emphasis>shareContext</db:emphasis> = 0)</db:title>
<db:para>Creates the GL context. Returns true if it was successful in creating a valid GL rendering context on the paint device specified in the constructor; otherwise returns false (i.e. the context is invalid).</db:para>
<db:para>If the OpenGL implementation on your system does not support the requested version of OpenGL context, then <db:link xlink:href="qglcontext.xml">QGLContext</db:link> will try to create the closest matching version. The actual created context properties can be queried using the <db:link xlink:href="qglformat.xml">QGLFormat</db:link> returned by the format() function. For example, if you request a context that supports OpenGL 4.3 Core profile but the driver and/or hardware only supports version 3.2 Core profile contexts then you will get a 3.2 Core profile context.</db:para>
<db:para>After successful creation, format() returns the set of features of the created GL rendering context.</db:para>
<db:para>If <db:code role="parameter">shareContext</db:code> points to a valid <db:link xlink:href="qglcontext.xml">QGLContext</db:link>, this method will try to establish OpenGL display list and texture object sharing between this context and the <db:code role="parameter">shareContext</db:code>. Note that this may fail if the two contexts have different formats. Use isSharing() to see if sharing is in effect.</db:para>
<db:warning>
<db:para>Implementation note: initialization of C++ class members usually takes place in the class constructor. <db:link xlink:href="qglcontext.xml">QGLContext</db:link> is an exception because it must be simple to customize. The virtual functions chooseContext() (and chooseVisual() for X11) can be reimplemented in a subclass to select a particular context. The problem is that virtual functions are not properly called during construction (even though this is correct C++) because C++ constructs class hierarchies from the bottom up. For this reason we need a create() function.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">chooseContext()</db:link></db:member>
<db:member><db:link xlink:href="">format()</db:link></db:member>
<db:member><db:link xlink:href="">isValid()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="deleteTexture">
<db:title>void QGLContext::deleteTexture(GLuint <db:emphasis>id</db:emphasis>)</db:title>
<db:para>Removes the texture identified by <db:code role="parameter">id</db:code> from the texture cache, and calls glDeleteTextures() to delete the texture from the context.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglcontext.xml#bindTexture">bindTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="drawTexture">
<db:title>[since 4.4] void QGLContext::drawTexture(const QPointF &amp;<db:emphasis>point</db:emphasis>, GLuint <db:emphasis>textureId</db:emphasis>, GLenum <db:emphasis>textureTarget</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>This function supports the following use cases:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>By default it draws the given texture, <db:code role="parameter">textureId</db:code>, at the given <db:code role="parameter">point</db:code> in OpenGL model space. The <db:code role="parameter">textureTarget</db:code> should be a 2D texture target.</db:para>
</db:listitem>
<db:listitem>
<db:para>If a painter is active, not inside a beginNativePainting / endNativePainting block, and uses the engine with type <db:link xlink:href="qpaintengine.xml#Type-enum">QPaintEngine::OpenGL2</db:link>, the function will draw the given texture, <db:code role="parameter">textureId</db:code>, at the given <db:code role="parameter">point</db:code>, respecting the current painter state. This will let you draw a texture with the clip, transform, render hints, and composition mode set by the painter. Note that the texture target needs to be GL_TEXTURE_2D for this use case.</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para>This function is not supported under any version of OpenGL ES.</db:para>
</db:note>
<db:para>This function was introduced in Qt 4.4.</db:para>
</db:section>
<db:section xml:id="drawTexture-1">
<db:title>[since 4.4] void QGLContext::drawTexture(const QRectF &amp;<db:emphasis>target</db:emphasis>, GLuint <db:emphasis>textureId</db:emphasis>, GLenum <db:emphasis>textureTarget</db:emphasis> = GL_TEXTURE_2D)</db:title>
<db:para>This function supports the following use cases:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>On OpenGL and OpenGL ES 1.x it draws the given texture, <db:code role="parameter">textureId</db:code>, to the given target rectangle, <db:code role="parameter">target</db:code>, in OpenGL model space. The <db:code role="parameter">textureTarget</db:code> should be a 2D texture target.</db:para>
</db:listitem>
<db:listitem>
<db:para>On OpenGL and OpenGL ES 2.x, if a painter is active, not inside a beginNativePainting / endNativePainting block, and uses the engine with type <db:link xlink:href="qpaintengine.xml#Type-enum">QPaintEngine::OpenGL2</db:link>, the function will draw the given texture, <db:code role="parameter">textureId</db:code>, to the given target rectangle, <db:code role="parameter">target</db:code>, respecting the current painter state. This will let you draw a texture with the clip, transform, render hints, and composition mode set by the painter. Note that the texture target needs to be GL_TEXTURE_2D for this use case, and that this is the only supported use case under OpenGL ES 2.x.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>This function was introduced in Qt 4.4.</db:para>
</db:section>
<db:section xml:id="fromOpenGLContext">
<db:title>[static] QGLContext *QGLContext::fromOpenGLContext(QOpenGLContext *<db:emphasis>context</db:emphasis>)</db:title>
<db:para>Returns a OpenGL context for the window context specified by the <db:code role="parameter">context</db:code> parameter.</db:para>
</db:section>
<db:section xml:id="functions">
<db:title>QGLFunctions *QGLContext::functions() const</db:title>
<db:para>Returns a QGLFunctions object that is initialized for this context.</db:para>
</db:section>
<db:section xml:id="moveToThread">
<db:title>void QGLContext::moveToThread(QThread *<db:emphasis>thread</db:emphasis>)</db:title>
<db:para>Moves the <db:link xlink:href="qglcontext.xml">QGLContext</db:link> to the given <db:code role="parameter">thread</db:code>.</db:para>
<db:para>Enables calling swapBuffers() and makeCurrent() on the context in the given thread.</db:para>
</db:section>
<db:section xml:id="setFormat">
<db:title>void QGLContext::setFormat(const QGLFormat &amp;<db:emphasis>format</db:emphasis>)</db:title>
<db:para>Sets a <db:code role="parameter">format</db:code> for this context. The context is <db:link xlink:href="qtextstream.xml#reset-1">reset</db:link>.</db:para>
<db:para>Call <db:link xlink:href="qglcontext.xml#create">create</db:link>() to create a new GL context that tries to match the new format.</db:para>
<db:programlisting language="cpp">QGLContext *cx;
//  ...
QGLFormat f;
f.setStereo(true);
cx-&gt;setFormat(f);
if (!cx-&gt;create())
    exit(); // no OpenGL support, or cannot render on the specified paintdevice
if (!cx-&gt;format().stereo())
    exit(); // could not create stereo context
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">format()</db:link></db:member>
<db:member><db:link xlink:href="qtextstream.xml#reset-1">reset</db:link>()</db:member>
<db:member><db:link xlink:href="qglcontext.xml#create">create</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setTextureCacheLimit">
<db:title>[static] void QGLContext::setTextureCacheLimit(int <db:emphasis>size</db:emphasis>)</db:title>
<db:para>This function sets the limit for the texture cache to <db:code role="parameter">size</db:code>, expressed in kilobytes.</db:para>
<db:para>By default, the cache limit is approximately 64 MB.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglcontext.xml#textureCacheLimit">textureCacheLimit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="textureCacheLimit">
<db:title>[static] int QGLContext::textureCacheLimit()</db:title>
<db:para>Returns the current texture cache limit in kilobytes.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qglcontext.xml#setTextureCacheLimit">setTextureCacheLimit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QGLContext</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qglcontext.xml">QGLContext</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="QGLContext-1">
<db:title>[deprecated] QGLContext::QGLContext(const QGLFormat &amp;<db:emphasis>format</db:emphasis>, QPaintDevice *<db:emphasis>device</db:emphasis>)</db:title>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Constructs an OpenGL context for the given paint <db:code role="parameter">device</db:code>, which can be a widget or a pixmap. The <db:code role="parameter">format</db:code> specifies several display options for the context.</db:para>
<db:para>If the underlying OpenGL/Window system cannot satisfy all the features requested in <db:code role="parameter">format</db:code>, the nearest subset of features will be used. After creation, the format() method will return the actual format obtained.</db:para>
<db:para>Note that after a <db:link xlink:href="qglcontext.xml">QGLContext</db:link> object has been constructed, <db:link xlink:href="qglcontext.xml#create">create</db:link>() must be called explicitly to create the actual OpenGL context. The context will be invalid if it was not possible to obtain a GL context at all.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
