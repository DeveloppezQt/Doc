<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSslConfiguration Class</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> class holds the configuration and state of an SSL connection.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSslConfiguration</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Network)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Network)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += network</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QSslConfiguration is part of <db:simplelist><db:member><db:link xlink:href="network.xml">Network Programming API</db:link></db:member><db:member>ssl</db:member><db:member>shared</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> is used by Qt networking classes to relay information about an open SSL connection and to allow the application to control certain features of that connection.</db:para>
<db:para>The settings that <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> currently supports are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The SSL/TLS protocol to be used</db:para>
</db:listitem>
<db:listitem>
<db:para>The certificate to be presented to the peer during connection and its associated private key</db:para>
</db:listitem>
<db:listitem>
<db:para>The ciphers allowed to be used for encrypting the connection</db:para>
</db:listitem>
<db:listitem>
<db:para>The list of Certificate Authorities certificates that are used to validate the peer's certificate</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>These settings are applied only during the connection handshake. Setting them after the connection has been established has no effect.</db:para>
<db:para>The state that <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> supports are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The certificate the peer presented during handshake, along with the chain leading to a CA certificate</db:para>
</db:listitem>
<db:listitem>
<db:para>The cipher used to encrypt this session</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The state can only be obtained once the SSL connection starts, but not necessarily before it's done. Some settings may change during the course of the SSL connection without need to restart it (for instance, the cipher can be changed over time).</db:para>
<db:para>State in <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> objects cannot be changed.</db:para>
<db:para><db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> can be used with <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> and the Network Access API.</db:para>
<db:para>Note that changing settings in <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> is not enough to change the settings in the related SSL connection. You must call setSslConfiguration on a modified <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> object to achieve that. The following example illustrates how to change the protocol to TLSv1_0 in a <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> object:</db:para>
<db:programlisting language="cpp">QSslConfiguration config = sslSocket.sslConfiguration();
config.setProtocol(QSsl::TlsV1_0);
sslSocket.setSslConfiguration(config);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qssl.xml#SslProtocol-enum">QSsl::SslProtocol</db:link></db:member>
<db:member><db:link xlink:href="qsslcertificate.xml">QSslCertificate</db:link></db:member>
<db:member><db:link xlink:href="qsslcipher.xml">QSslCipher</db:link></db:member>
<db:member><db:link xlink:href="qsslkey.xml">QSslKey</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml#sslConfiguration">QSslSocket::sslConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#setSslConfiguration">QSslSocket::setSslConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="NextProtocolNegotiationStatus-enum">
<db:title>enum QSslConfiguration::NextProtocolNegotiationStatus</db:title>
<db:enumsynopsis>
<db:enumname>NextProtocolNegotiationStatus</db:enumname>
<db:enumitem>
<db:enumidentifier>NextProtocolNegotiationNone</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NextProtocolNegotiationNegotiated</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NextProtocolNegotiationUnsupported</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Describes the status of the Next Protocol Negotiation (NPN) or Application-Layer Protocol Negotiation (ALPN).</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link></db:emphasis>::NextProtocolNegotiationNone</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>No application protocol has been negotiated (yet).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link></db:emphasis>::NextProtocolNegotiationNegotiated</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>A next protocol has been negotiated (see <db:link xlink:href="qsslconfiguration.xml#nextNegotiatedProtocol">nextNegotiatedProtocol</db:link>()).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link></db:emphasis>::NextProtocolNegotiationUnsupported</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The client and server could not agree on a common next application protocol.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QSslConfiguration">
<db:title>QSslConfiguration::QSslConfiguration()</db:title>
<db:constructorsynopsis>
<db:methodname>QSslConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslConfiguration()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty SSL configuration. This configuration contains no valid settings and the state will be empty. <db:link xlink:href="qsslconfiguration.xml#isNull">isNull</db:link>() will return true after this constructor is called.</db:para>
<db:para>Once any setter methods are called, <db:link xlink:href="qsslconfiguration.xml#isNull">isNull</db:link>() will return false.</db:para>
</db:section>
<db:section xml:id="QSslConfiguration-1">
<db:title>QSslConfiguration::QSslConfiguration(const QSslConfiguration &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QSslConfiguration</db:methodname>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslConfiguration(const QSslConfiguration &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Copies the configuration and state of <db:code role="parameter">other</db:code>. If <db:code role="parameter">other</db:code> is null, this object will be null too.</db:para>
</db:section>
<db:section xml:id="dtor.QSslConfiguration">
<db:title>QSslConfiguration::~QSslConfiguration()</db:title>
<db:destructorsynopsis>
<db:methodname>~QSslConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QSslConfiguration()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Releases any resources held by <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link>.</db:para>
</db:section>
<db:section xml:id="addCaCertificate">
<db:title>[since 5.15] void QSslConfiguration::addCaCertificate(const QSslCertificate &amp;<db:emphasis>certificate</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addCaCertificate</db:methodname>
<db:methodparam>
<db:type>const QSslCertificate &amp;</db:type>
<db:parameter>certificate</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addCaCertificate(const QSslCertificate &amp;certificate)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds <db:code role="parameter">certificate</db:code> to this configuration's CA certificate database. The certificate database must be set prior to the SSL handshake. The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate.</db:para>
<db:note>
<db:para>The default configuration uses the system CA certificate database. If that is not available (as is commonly the case on iOS), the default database is empty.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.15.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#caCertificates">caCertificates</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setCaCertificates">setCaCertificates</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#addCaCertificates">addCaCertificates</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addCaCertificates">
<db:title>[since 5.15] bool QSslConfiguration::addCaCertificates(const QString &amp;<db:emphasis>path</db:emphasis>, QSsl::EncodingFormat <db:emphasis>format</db:emphasis> = QSsl::Pem, QSslCertificate::PatternSyntax <db:emphasis>syntax</db:emphasis> = QSslCertificate::PatternSyntax::FixedString)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>addCaCertificates</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>path</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSsl::EncodingFormat</db:type>
<db:parameter>format</db:parameter>
<db:initializer>QSsl::Pem</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QSslCertificate::PatternSyntax</db:type>
<db:parameter>syntax</db:parameter>
<db:initializer>QSslCertificate::PatternSyntax::FixedString</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool addCaCertificates(const QString &amp;path, QSsl::EncodingFormat format, QSslCertificate::PatternSyntax syntax)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Searches all files in the <db:code role="parameter">path</db:code> for certificates encoded in the specified <db:code role="parameter">format</db:code> and adds them to this socket's CA certificate database. <db:code role="parameter">path</db:code> must be a file or a pattern matching one or more files, as specified by <db:code role="parameter">syntax</db:code>. Returns true if one or more certificates are added to the socket's CA certificate database; otherwise returns false.</db:para>
<db:para>The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate.</db:para>
<db:para>For more precise control, use <db:link xlink:href="qsslconfiguration.xml#addCaCertificate">addCaCertificate</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.15.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#addCaCertificate">addCaCertificate</db:link>()</db:member>
<db:member><db:link xlink:href="qsslcertificate.xml#fromPath">QSslCertificate::fromPath</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addCaCertificates-1">
<db:title>[since 5.15] void QSslConfiguration::addCaCertificates(const QList&lt;QSslCertificate&gt; &amp;<db:emphasis>certificates</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addCaCertificates</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QSslCertificate&gt; &amp;</db:type>
<db:parameter>certificates</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void addCaCertificates(const QList&lt;QSslCertificate&gt; &amp;certificates)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds <db:code role="parameter">certificates</db:code> to this configuration's CA certificate database. The certificate database must be set prior to the SSL handshake. The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate.</db:para>
<db:note>
<db:para>The default configuration uses the system CA certificate database. If that is not available (as is commonly the case on iOS), the default database is empty.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.15.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#caCertificates">caCertificates</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setCaCertificates">setCaCertificates</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#addCaCertificate">addCaCertificate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="allowedNextProtocols">
<db:title>[since 5.3] QList&lt;QByteArray&gt; QSslConfiguration::allowedNextProtocols() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QByteArray&gt;</db:type>
<db:methodname>allowedNextProtocols</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QByteArray&gt; allowedNextProtocols() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function returns the allowed protocols to be negotiated with the server through the Next Protocol Negotiation (NPN) or Application-Layer Protocol Negotiation (ALPN) TLS extension, as set by <db:link xlink:href="qsslconfiguration.xml#setAllowedNextProtocols">setAllowedNextProtocols</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#nextNegotiatedProtocol">nextNegotiatedProtocol</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#nextProtocolNegotiationStatus">nextProtocolNegotiationStatus</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setAllowedNextProtocols">setAllowedNextProtocols</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#NextProtocolHttp1_1-var">QSslConfiguration::NextProtocolHttp1_1</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="backendConfiguration">
<db:title>[since 5.11] QMap&lt;QByteArray, QVariant&gt; QSslConfiguration::backendConfiguration() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QMap&lt;QByteArray, QVariant&gt;</db:type>
<db:methodname>backendConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMap&lt;QByteArray, QVariant&gt; backendConfiguration() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the backend-specific configuration.</db:para>
<db:para>Only options set by <db:link xlink:href="qsslconfiguration.xml#setBackendConfigurationOption">setBackendConfigurationOption</db:link>() or <db:link xlink:href="qsslconfiguration.xml#setBackendConfiguration">setBackendConfiguration</db:link>() will be returned. The internal standard configuration of the backend is not reported.</db:para>
<db:para>This function was introduced in Qt 5.11.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setBackendConfigurationOption">setBackendConfigurationOption</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setBackendConfiguration">setBackendConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="caCertificates">
<db:title>QList&lt;QSslCertificate&gt; QSslConfiguration::caCertificates() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QSslCertificate&gt;</db:type>
<db:methodname>caCertificates</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QSslCertificate&gt; caCertificates() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns this connection's CA certificate database. The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate. It can be modified prior to the handshake with <db:link xlink:href="qsslconfiguration.xml#setCaCertificates">setCaCertificates</db:link>(), or with <db:link xlink:href="qsslconfiguration.xml#addCaCertificate">addCaCertificate</db:link>() and <db:link xlink:href="qsslconfiguration.xml#addCaCertificates">addCaCertificates</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setCaCertificates">setCaCertificates</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#addCaCertificate">addCaCertificate</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#addCaCertificates">addCaCertificates</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ciphers">
<db:title>QList&lt;QSslCipher&gt; QSslConfiguration::ciphers() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QSslCipher&gt;</db:type>
<db:methodname>ciphers</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QSslCipher&gt; ciphers() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns this connection's current cryptographic cipher suite. This list is used during the handshake phase for choosing a session cipher. The returned list of ciphers is ordered by descending preference. (i.e., the first cipher in the list is the most preferred cipher). The session cipher will be the first one in the list that is also supported by the peer.</db:para>
<db:para>By default, the handshake phase can choose any of the ciphers supported by this system's SSL libraries, which may vary from system to system. The list of ciphers supported by this system's SSL libraries is returned by <db:link xlink:href="qsslconfiguration.xml#supportedCiphers">supportedCiphers</db:link>(). You can restrict the list of ciphers used for choosing the session cipher for this socket by calling <db:link xlink:href="qsslconfiguration.xml#setCiphers">setCiphers</db:link>() with a subset of the supported ciphers. You can revert to using the entire set by calling <db:link xlink:href="qsslconfiguration.xml#setCiphers">setCiphers</db:link>() with the list returned by <db:link xlink:href="qsslconfiguration.xml#supportedCiphers">supportedCiphers</db:link>().</db:para>
<db:note>
<db:para>This is not currently supported in the Schannel backend.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setCiphers">setCiphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#supportedCiphers">supportedCiphers</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="defaultConfiguration">
<db:title>[static] QSslConfiguration QSslConfiguration::defaultConfiguration()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QSslConfiguration</db:type>
<db:methodname>defaultConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslConfiguration defaultConfiguration()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the default SSL configuration to be used in new SSL connections.</db:para>
<db:para>The default SSL configuration consists of:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>no local certificate and no private key</db:para>
</db:listitem>
<db:listitem>
<db:para>protocol <db:link xlink:href="qssl.xml#SslProtocol-enum">SecureProtocols</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>the system's default CA certificate list</db:para>
</db:listitem>
<db:listitem>
<db:para>the cipher list equal to the list of the SSL libraries' supported SSL ciphers that are 128 bits or more</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#supportedCiphers">supportedCiphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setDefaultConfiguration">setDefaultConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="defaultDtlsConfiguration">
<db:title>[static] QSslConfiguration QSslConfiguration::defaultDtlsConfiguration()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QSslConfiguration</db:type>
<db:methodname>defaultDtlsConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslConfiguration defaultDtlsConfiguration()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the default DTLS configuration to be used in new DTLS connections.</db:para>
<db:para>The default DTLS configuration consists of:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>no local certificate and no private key</db:para>
</db:listitem>
<db:listitem>
<db:para>protocol DtlsV1_2OrLater</db:para>
</db:listitem>
<db:listitem>
<db:para>the system's default CA certificate list</db:para>
</db:listitem>
<db:listitem>
<db:para>the cipher list equal to the list of the SSL libraries' supported TLS 1.2 ciphers that use 128 or more secret bits for the cipher.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setDefaultDtlsConfiguration">setDefaultDtlsConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="diffieHellmanParameters">
<db:title>[since 5.8] QSslDiffieHellmanParameters QSslConfiguration::diffieHellmanParameters() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslDiffieHellmanParameters</db:type>
<db:methodname>diffieHellmanParameters</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslDiffieHellmanParameters diffieHellmanParameters() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Retrieves the current set of Diffie-Hellman parameters.</db:para>
<db:para>If no Diffie-Hellman parameters have been set, the <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> object defaults to using the 1024-bit MODP group from RFC 2409.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setDiffieHellmanParameters">setDiffieHellmanParameters</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtlsCookieVerificationEnabled">
<db:title>bool QSslConfiguration::dtlsCookieVerificationEnabled() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>dtlsCookieVerificationEnabled</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool dtlsCookieVerificationEnabled() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function returns true if DTLS cookie verification was enabled on a server-side socket.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setDtlsCookieVerificationEnabled">setDtlsCookieVerificationEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ellipticCurves">
<db:title>[since 5.5] QList&lt;QSslEllipticCurve&gt; QSslConfiguration::ellipticCurves() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QSslEllipticCurve&gt;</db:type>
<db:methodname>ellipticCurves</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QSslEllipticCurve&gt; ellipticCurves() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns this connection's current list of elliptic curves. This list is used during the handshake phase for choosing an elliptic curve (when using an elliptic curve cipher). The returned list of curves is ordered by descending preference (i.e., the first curve in the list is the most preferred one).</db:para>
<db:para>By default, the handshake phase can choose any of the curves supported by this system's SSL libraries, which may vary from system to system. The list of curves supported by this system's SSL libraries is returned by QSslSocket::supportedEllipticCurves().</db:para>
<db:para>You can restrict the list of curves used for choosing the session cipher for this socket by calling <db:link xlink:href="qsslconfiguration.xml#setEllipticCurves">setEllipticCurves</db:link>() with a subset of the supported ciphers. You can revert to using the entire set by calling <db:link xlink:href="qsslconfiguration.xml#setEllipticCurves">setEllipticCurves</db:link>() with the list returned by QSslSocket::supportedEllipticCurves().</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setEllipticCurves">setEllipticCurves</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ephemeralServerKey">
<db:title>[since 5.7] QSslKey QSslConfiguration::ephemeralServerKey() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslKey</db:type>
<db:methodname>ephemeralServerKey</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslKey ephemeralServerKey() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the ephemeral server key used for cipher algorithms with forward secrecy, e.g. DHE-RSA-AES128-SHA.</db:para>
<db:para>The ephemeral key is only available when running in client mode, i.e. <db:link xlink:href="qsslsocket.xml#SslMode-enum">QSslSocket::SslClientMode</db:link>. When running in server mode or using a cipher algorithm without forward secrecy a null key is returned. The ephemeral server key will be set before emitting the encrypted() signal.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="handshakeMustInterruptOnError">
<db:title>[since 6.0] bool QSslConfiguration::handshakeMustInterruptOnError() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>handshakeMustInterruptOnError</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool handshakeMustInterruptOnError() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if a verification callback will emit <db:link xlink:href="qsslsocket.xml#handshakeInterruptedOnError">QSslSocket::handshakeInterruptedOnError</db:link>() early, before concluding the handshake.</db:para>
<db:note>
<db:para>This function always returns false for all backends but OpenSSL.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setHandshakeMustInterruptOnError">setHandshakeMustInterruptOnError</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#handshakeInterruptedOnError">QSslSocket::handshakeInterruptedOnError</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#continueInterruptedHandshake">QSslSocket::continueInterruptedHandshake</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QSslConfiguration::isNull() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isNull</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isNull() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this is a null <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> object.</db:para>
<db:para>A <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> object is null if it has been default-constructed and no setter methods have been called.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setProtocol">setProtocol</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setLocalCertificate">setLocalCertificate</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setPrivateKey">setPrivateKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setCiphers">setCiphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setCaCertificates">setCaCertificates</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="localCertificate">
<db:title>QSslCertificate QSslConfiguration::localCertificate() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslCertificate</db:type>
<db:methodname>localCertificate</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslCertificate localCertificate() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the certificate to be presented to the peer during the SSL handshake process.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setLocalCertificate">setLocalCertificate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="localCertificateChain">
<db:title>[since 5.1] QList&lt;QSslCertificate&gt; QSslConfiguration::localCertificateChain() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QSslCertificate&gt;</db:type>
<db:methodname>localCertificateChain</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QSslCertificate&gt; localCertificateChain() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the certificate chain to be presented to the peer during the SSL handshake process.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setLocalCertificateChain">setLocalCertificateChain</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#localCertificate">localCertificate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="missingCertificateIsFatal">
<db:title>[since 6.0] bool QSslConfiguration::missingCertificateIsFatal() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>missingCertificateIsFatal</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool missingCertificateIsFatal() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if errors with code <db:link xlink:href="qsslerror.xml#SslError-enum">QSslError::NoPeerCertificate</db:link> cannot be ignored.</db:para>
<db:note>
<db:para>Always returns false for all TLS backends but OpenSSL.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#ignoreSslErrors">QSslSocket::ignoreSslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setMissingCertificateIsFatal">setMissingCertificateIsFatal</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nextNegotiatedProtocol">
<db:title>[since 5.3] QByteArray QSslConfiguration::nextNegotiatedProtocol() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>nextNegotiatedProtocol</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray nextNegotiatedProtocol() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function returns the protocol negotiated with the server if the Next Protocol Negotiation (NPN) or Application-Layer Protocol Negotiation (ALPN) TLS extension was enabled. In order for the NPN/ALPN extension to be enabled, <db:link xlink:href="qsslconfiguration.xml#setAllowedNextProtocols">setAllowedNextProtocols</db:link>() needs to be called explicitly before connecting to the server.</db:para>
<db:para>If no protocol could be negotiated or the extension was not enabled, this function returns a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> which is null.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setAllowedNextProtocols">setAllowedNextProtocols</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#nextProtocolNegotiationStatus">nextProtocolNegotiationStatus</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nextProtocolNegotiationStatus">
<db:title>[since 5.3] QSslConfiguration::NextProtocolNegotiationStatus QSslConfiguration::nextProtocolNegotiationStatus() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslConfiguration::NextProtocolNegotiationStatus</db:type>
<db:methodname>nextProtocolNegotiationStatus</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslConfiguration::NextProtocolNegotiationStatus nextProtocolNegotiationStatus() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function returns the status of the Next Protocol Negotiation (NPN) or Application-Layer Protocol Negotiation (ALPN). If the feature has not been enabled through <db:link xlink:href="qsslconfiguration.xml#setAllowedNextProtocols">setAllowedNextProtocols</db:link>(), this function returns <db:link xlink:href="qsslconfiguration.xml#NextProtocolNegotiationStatus-enum">NextProtocolNegotiationNone</db:link>. The status will be set before emitting the encrypted() signal.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setAllowedNextProtocols">setAllowedNextProtocols</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#allowedNextProtocols">allowedNextProtocols</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#nextNegotiatedProtocol">nextNegotiatedProtocol</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#NextProtocolNegotiationStatus-enum">QSslConfiguration::NextProtocolNegotiationStatus</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ocspStaplingEnabled">
<db:title>[since 5.13] bool QSslConfiguration::ocspStaplingEnabled() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>ocspStaplingEnabled</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool ocspStaplingEnabled() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if OCSP stapling was enabled by setOCSPStaplingEnabled(), otherwise false (which is the default value).</db:para>
<db:para>This function was introduced in Qt 5.13.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setOcspStaplingEnabled">setOcspStaplingEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerCertificate">
<db:title>QSslCertificate QSslConfiguration::peerCertificate() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslCertificate</db:type>
<db:methodname>peerCertificate</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslCertificate peerCertificate() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the peer's digital certificate (i.e., the immediate certificate of the host you are connected to), or a null certificate, if the peer has not assigned a certificate.</db:para>
<db:para>The peer certificate is checked automatically during the handshake phase, so this function is normally used to fetch the certificate for display or for connection diagnostic purposes. It contains information about the peer, including its host name, the certificate issuer, and the peer's public key.</db:para>
<db:para>Because the peer certificate is set during the handshake phase, it is safe to access the peer certificate from a slot connected to the <db:link xlink:href="qsslsocket.xml#sslErrors">QSslSocket::sslErrors</db:link>() signal, <db:link xlink:href="qnetworkreply.xml#sslErrors">QNetworkReply::sslErrors</db:link>() signal, or the <db:link xlink:href="qsslsocket.xml#encrypted">QSslSocket::encrypted</db:link>() signal.</db:para>
<db:para>If a null certificate is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</db:para>
<db:para>If you want to check the peer's complete chain of certificates, use <db:link xlink:href="qsslconfiguration.xml#peerCertificateChain">peerCertificateChain</db:link>() to get them all at once.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#peerCertificateChain">peerCertificateChain</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#sslErrors">QSslSocket::sslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#ignoreSslErrors">QSslSocket::ignoreSslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkreply.xml#sslErrors">QNetworkReply::sslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkreply.xml#ignoreSslErrors">QNetworkReply::ignoreSslErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerCertificateChain">
<db:title>QList&lt;QSslCertificate&gt; QSslConfiguration::peerCertificateChain() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QSslCertificate&gt;</db:type>
<db:methodname>peerCertificateChain</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QSslCertificate&gt; peerCertificateChain() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the peer's chain of digital certificates, starting with the peer's immediate certificate and ending with the CA's certificate.</db:para>
<db:para>Peer certificates are checked automatically during the handshake phase. This function is normally used to fetch certificates for display, or for performing connection diagnostics. Certificates contain information about the peer and the certificate issuers, including host name, issuer names, and issuer public keys.</db:para>
<db:para>Because the peer certificate is set during the handshake phase, it is safe to access the peer certificate from a slot connected to the <db:link xlink:href="qsslsocket.xml#sslErrors">QSslSocket::sslErrors</db:link>() signal, <db:link xlink:href="qnetworkreply.xml#sslErrors">QNetworkReply::sslErrors</db:link>() signal, or the <db:link xlink:href="qsslsocket.xml#encrypted">QSslSocket::encrypted</db:link>() signal.</db:para>
<db:para>If an empty list is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</db:para>
<db:para>If you want to get only the peer's immediate certificate, use <db:link xlink:href="qsslconfiguration.xml#peerCertificate">peerCertificate</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#peerCertificate">peerCertificate</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#sslErrors">QSslSocket::sslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#ignoreSslErrors">QSslSocket::ignoreSslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkreply.xml#sslErrors">QNetworkReply::sslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkreply.xml#ignoreSslErrors">QNetworkReply::ignoreSslErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerVerifyDepth">
<db:title>int QSslConfiguration::peerVerifyDepth() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>peerVerifyDepth</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int peerVerifyDepth() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, or 0 (the default) if no maximum depth has been set, indicating that the whole certificate chain should be checked.</db:para>
<db:para>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setPeerVerifyDepth">setPeerVerifyDepth</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#peerVerifyMode">peerVerifyMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerVerifyMode">
<db:title>QSslSocket::PeerVerifyMode QSslConfiguration::peerVerifyMode() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslSocket::PeerVerifyMode</db:type>
<db:methodname>peerVerifyMode</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslSocket::PeerVerifyMode peerVerifyMode() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the verify mode. This mode decides whether <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</db:para>
<db:para>The default mode is AutoVerifyPeer, which tells <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> to use VerifyPeer for clients, QueryPeer for servers.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setPeerVerifyMode">setPeerVerifyMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="preSharedKeyIdentityHint">
<db:title>[since 5.8] QByteArray QSslConfiguration::preSharedKeyIdentityHint() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>preSharedKeyIdentityHint</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray preSharedKeyIdentityHint() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the identity hint.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setPreSharedKeyIdentityHint">setPreSharedKeyIdentityHint</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="privateKey">
<db:title>QSslKey QSslConfiguration::privateKey() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslKey</db:type>
<db:methodname>privateKey</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslKey privateKey() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qsslkey.xml">SSL key</db:link> assigned to this connection or a null key if none has been assigned yet.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setPrivateKey">setPrivateKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#localCertificate">localCertificate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="protocol">
<db:title>QSsl::SslProtocol QSslConfiguration::protocol() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSsl::SslProtocol</db:type>
<db:methodname>protocol</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSsl::SslProtocol protocol() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the protocol setting for this SSL configuration.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setProtocol">setProtocol</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sessionCipher">
<db:title>QSslCipher QSslConfiguration::sessionCipher() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSslCipher</db:type>
<db:methodname>sessionCipher</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslCipher sessionCipher() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the socket's cryptographic <db:link xlink:href="qsslcipher.xml">cipher</db:link>, or a null cipher if the connection isn't encrypted. The socket's cipher for the session is set during the handshake phase. The cipher is used to encrypt and decrypt data transmitted through the socket.</db:para>
<db:para>The SSL infrastructure also provides functions for setting the ordered list of ciphers from which the handshake phase will eventually select the session cipher. This ordered list must be in place before the handshake phase begins.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#ciphers">ciphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setCiphers">setCiphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#supportedCiphers">supportedCiphers</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sessionProtocol">
<db:title>[since 5.4] QSsl::SslProtocol QSslConfiguration::sessionProtocol() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSsl::SslProtocol</db:type>
<db:methodname>sessionProtocol</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSsl::SslProtocol sessionProtocol() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the socket's SSL/TLS protocol or UnknownProtocol if the connection isn't encrypted. The socket's protocol for the session is set during the handshake phase.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#protocol">protocol</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setProtocol">setProtocol</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sessionTicket">
<db:title>[since 5.2] QByteArray QSslConfiguration::sessionTicket() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>sessionTicket</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray sessionTicket() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:link xlink:href="qssl.xml#SslOption-enum">QSsl::SslOptionDisableSessionPersistence</db:link> was turned off, this function returns the session ticket used in the SSL handshake in ASN.1 format, suitable to e.g. be persisted to disk. If no session ticket was used or <db:link xlink:href="qssl.xml#SslOption-enum">QSsl::SslOptionDisableSessionPersistence</db:link> was not turned off, this function returns an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:note>
<db:para>When persisting the session ticket to disk or similar, be careful not to expose the session to a potential attacker, as knowledge of the session allows for eavesdropping on data encrypted with the session parameters.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setSessionTicket">setSessionTicket</db:link>()</db:member>
<db:member><db:link xlink:href="qssl.xml#SslOption-enum">QSsl::SslOptionDisableSessionPersistence</db:link></db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setSslOption">setSslOption</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#newSessionTicketReceived">QSslSocket::newSessionTicketReceived</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sessionTicketLifeTimeHint">
<db:title>[since 5.2] int QSslConfiguration::sessionTicketLifeTimeHint() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>sessionTicketLifeTimeHint</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int sessionTicketLifeTimeHint() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:link xlink:href="qssl.xml#SslOption-enum">QSsl::SslOptionDisableSessionPersistence</db:link> was turned off, this function returns the session ticket life time hint sent by the server (which might be 0). If the server did not send a session ticket (e.g. when resuming a session or when the server does not support it) or <db:link xlink:href="qssl.xml#SslOption-enum">QSsl::SslOptionDisableSessionPersistence</db:link> was not turned off, this function returns -1.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#sessionTicket">sessionTicket</db:link>()</db:member>
<db:member><db:link xlink:href="qssl.xml#SslOption-enum">QSsl::SslOptionDisableSessionPersistence</db:link></db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setSslOption">setSslOption</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#newSessionTicketReceived">QSslSocket::newSessionTicketReceived</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAllowedNextProtocols">
<db:title>[since 5.3] void QSslConfiguration::setAllowedNextProtocols(const QList&lt;QByteArray&gt; &amp;<db:emphasis>protocols</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setAllowedNextProtocols</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QByteArray&gt; &amp;</db:type>
<db:parameter>protocols</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setAllowedNextProtocols(const QList&lt;QByteArray&gt; &amp;protocols)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function sets the allowed <db:code role="parameter">protocols</db:code> to be negotiated with the server through the Next Protocol Negotiation (NPN) or Application-Layer Protocol Negotiation (ALPN) TLS extension; each element in <db:code role="parameter">protocols</db:code> must define one allowed protocol. The function must be called explicitly before connecting to send the NPN/ALPN extension in the SSL handshake. Whether or not the negotiation succeeded can be queried through <db:link xlink:href="qsslconfiguration.xml#nextProtocolNegotiationStatus">nextProtocolNegotiationStatus</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#nextNegotiatedProtocol">nextNegotiatedProtocol</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#nextProtocolNegotiationStatus">nextProtocolNegotiationStatus</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#allowedNextProtocols">allowedNextProtocols</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#NextProtocolHttp1_1-var">QSslConfiguration::NextProtocolHttp1_1</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setBackendConfiguration">
<db:title>[since 5.11] void QSslConfiguration::setBackendConfiguration(const QMap&lt;QByteArray, QVariant&gt; &amp;<db:emphasis>backendConfiguration</db:emphasis> = QMap&lt;QByteArray, QVariant&gt;())</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setBackendConfiguration</db:methodname>
<db:methodparam>
<db:type>const QMap&lt;QByteArray, QVariant&gt; &amp;</db:type>
<db:parameter>backendConfiguration</db:parameter>
<db:initializer>QMap&lt;QByteArray, QVariant&gt;()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setBackendConfiguration(const QMap&lt;QByteArray, QVariant&gt; &amp;backendConfiguration)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets or clears the backend-specific configuration.</db:para>
<db:para>Without a <db:code role="parameter">backendConfiguration</db:code> parameter this function will clear the backend-specific configuration. More information about the supported options is available in the documentation of <db:link xlink:href="qsslconfiguration.xml#setBackendConfigurationOption">setBackendConfigurationOption</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.11.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#backendConfiguration">backendConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setBackendConfigurationOption">setBackendConfigurationOption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setBackendConfigurationOption">
<db:title>[since 5.11] void QSslConfiguration::setBackendConfigurationOption(const QByteArray &amp;<db:emphasis>name</db:emphasis>, const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setBackendConfigurationOption</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setBackendConfigurationOption(const QByteArray &amp;name, const QVariant &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the option <db:code role="parameter">name</db:code> in the backend-specific configuration to <db:code role="parameter">value</db:code>.</db:para>
<db:para>Options supported by the OpenSSL (&gt;= 1.0.2) backend are available in the <db:link xlink:href="https://www.openssl.org/docs/manmaster/man3/SSL_CONF_cmd.html#SUPPORTED-CONFIGURATION-FILE-COMMANDS">supported configuration file commands</db:link> documentation. The expected type for the <db:code role="parameter">value</db:code> parameter is a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> for all options. The <db:link xlink:href="https://www.openssl.org/docs/manmaster/man3/SSL_CONF_cmd.html#EXAMPLES">examples</db:link> show how to use some of the options.</db:para>
<db:note>
<db:para>The backend-specific configuration will be applied after the general configuration. Using the backend-specific configuration to set a general configuration option again will overwrite the general configuration option.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.11.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#backendConfiguration">backendConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setBackendConfiguration">setBackendConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCaCertificates">
<db:title>void QSslConfiguration::setCaCertificates(const QList&lt;QSslCertificate&gt; &amp;<db:emphasis>certificates</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setCaCertificates</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QSslCertificate&gt; &amp;</db:type>
<db:parameter>certificates</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setCaCertificates(const QList&lt;QSslCertificate&gt; &amp;certificates)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets this socket's CA certificate database to be <db:code role="parameter">certificates</db:code>. The certificate database must be set prior to the SSL handshake. The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate.</db:para>
<db:note>
<db:para>The default configuration uses the system CA certificate database. If that is not available (as is commonly the case on iOS), the default database is empty.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#caCertificates">caCertificates</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#addCaCertificates">addCaCertificates</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#addCaCertificate">addCaCertificate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCiphers">
<db:title>void QSslConfiguration::setCiphers(const QList&lt;QSslCipher&gt; &amp;<db:emphasis>ciphers</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setCiphers</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QSslCipher&gt; &amp;</db:type>
<db:parameter>ciphers</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setCiphers(const QList&lt;QSslCipher&gt; &amp;ciphers)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the cryptographic cipher suite for this socket to <db:code role="parameter">ciphers</db:code>, which must contain a subset of the ciphers in the list returned by <db:link xlink:href="qsslconfiguration.xml#supportedCiphers">supportedCiphers</db:link>().</db:para>
<db:para>Restricting the cipher suite must be done before the handshake phase, where the session cipher is chosen.</db:para>
<db:note>
<db:para>This is not currently supported in the Schannel backend.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#ciphers">ciphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#supportedCiphers">supportedCiphers</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCiphers-1">
<db:title>[since 6.0] void QSslConfiguration::setCiphers(const QString &amp;<db:emphasis>ciphers</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setCiphers</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>ciphers</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setCiphers(const QString &amp;ciphers)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the cryptographic cipher suite for this configuration to <db:code role="parameter">ciphers</db:code>, which is a colon-separated list of cipher suite names. The ciphers are listed in order of preference, starting with the most preferred cipher. For example:</db:para>
<db:programlisting language="cpp">QSslConfiguration tlsConfig = QSslConfiguration::defaultConfiguration();
tlsConfig.setCiphers(QStringLiteral(&quot;DHE-RSA-AES256-SHA:DHE-DSS-AES256-SHA:AES256-SHA&quot;));
</db:programlisting>
<db:para>Each cipher name in <db:code role="parameter">ciphers</db:code> must be the name of a cipher in the list returned by <db:link xlink:href="qsslconfiguration.xml#supportedCiphers">supportedCiphers</db:link>(). Restricting the cipher suite must be done before the handshake phase, where the session cipher is chosen.</db:para>
<db:note>
<db:para>This is not currently supported in the Schannel backend.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#ciphers">ciphers</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDefaultConfiguration">
<db:title>[static] void QSslConfiguration::setDefaultConfiguration(const QSslConfiguration &amp;<db:emphasis>configuration</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>setDefaultConfiguration</db:methodname>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>configuration</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDefaultConfiguration(const QSslConfiguration &amp;configuration)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the default SSL configuration to be used in new SSL connections to be <db:code role="parameter">configuration</db:code>. Existing connections are not affected by this call.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#supportedCiphers">supportedCiphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#defaultConfiguration">defaultConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDefaultDtlsConfiguration">
<db:title>[static] void QSslConfiguration::setDefaultDtlsConfiguration(const QSslConfiguration &amp;<db:emphasis>configuration</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>setDefaultDtlsConfiguration</db:methodname>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>configuration</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDefaultDtlsConfiguration(const QSslConfiguration &amp;configuration)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the default DTLS configuration to be used in new DTLS connections to be <db:code role="parameter">configuration</db:code>. Existing connections are not affected by this call.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#defaultDtlsConfiguration">defaultDtlsConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDiffieHellmanParameters">
<db:title>[since 5.8] void QSslConfiguration::setDiffieHellmanParameters(const QSslDiffieHellmanParameters &amp;<db:emphasis>dhparams</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDiffieHellmanParameters</db:methodname>
<db:methodparam>
<db:type>const QSslDiffieHellmanParameters &amp;</db:type>
<db:parameter>dhparams</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDiffieHellmanParameters(const QSslDiffieHellmanParameters &amp;dhparams)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets a custom set of Diffie-Hellman parameters to be used by this socket when functioning as a server to <db:code role="parameter">dhparams</db:code>.</db:para>
<db:para>If no Diffie-Hellman parameters have been set, the <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> object defaults to using the 1024-bit MODP group from RFC 2409.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#diffieHellmanParameters">diffieHellmanParameters</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDtlsCookieVerificationEnabled">
<db:title>void QSslConfiguration::setDtlsCookieVerificationEnabled(bool <db:emphasis>enable</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDtlsCookieVerificationEnabled</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enable</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDtlsCookieVerificationEnabled(bool enable)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function enables DTLS cookie verification when <db:code role="parameter">enable</db:code> is true.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#dtlsCookieVerificationEnabled">dtlsCookieVerificationEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setEllipticCurves">
<db:title>[since 5.5] void QSslConfiguration::setEllipticCurves(const QList&lt;QSslEllipticCurve&gt; &amp;<db:emphasis>curves</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setEllipticCurves</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QSslEllipticCurve&gt; &amp;</db:type>
<db:parameter>curves</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setEllipticCurves(const QList&lt;QSslEllipticCurve&gt; &amp;curves)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the list of elliptic curves to be used by this socket to <db:code role="parameter">curves</db:code>, which must contain a subset of the curves in the list returned by <db:link xlink:href="qsslconfiguration.xml#supportedEllipticCurves">supportedEllipticCurves</db:link>().</db:para>
<db:para>Restricting the elliptic curves must be done before the handshake phase, where the session cipher is chosen.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#ellipticCurves">ellipticCurves</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setHandshakeMustInterruptOnError">
<db:title>[since 6.0] void QSslConfiguration::setHandshakeMustInterruptOnError(bool <db:emphasis>interrupt</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setHandshakeMustInterruptOnError</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>interrupt</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setHandshakeMustInterruptOnError(bool interrupt)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">interrupt</db:code> is true and the underlying backend supports this option, errors found during certificate verification are reported immediately by emitting <db:link xlink:href="qsslsocket.xml#handshakeInterruptedOnError">QSslSocket::handshakeInterruptedOnError</db:link>(). This allows to stop the unfinished handshake and send a proper alert message to a peer. No special action is required from the application in this case. <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> will close the connection after sending the alert message. If the application after inspecting the error wants to continue the handshake, it must call <db:link xlink:href="qsslsocket.xml#continueInterruptedHandshake">QSslSocket::continueInterruptedHandshake</db:link>() from its slot function. The signal-slot connection must be direct.</db:para>
<db:note>
<db:para>When interrupting handshake is enabled, errors that would otherwise be reported by <db:link xlink:href="qsslsocket.xml#peerVerifyError">QSslSocket::peerVerifyError</db:link>() are instead only reported by <db:link xlink:href="qsslsocket.xml#handshakeInterruptedOnError">QSslSocket::handshakeInterruptedOnError</db:link>().</db:para>
</db:note>
<db:note>
<db:para>Even if the handshake was continued, these errors will be reported when emitting <db:link xlink:href="qsslsocket.xml#sslErrors">QSslSocket::sslErrors</db:link>() signal (and thus must be ignored in the corresponding function slot).</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#handshakeMustInterruptOnError">handshakeMustInterruptOnError</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#handshakeInterruptedOnError">QSslSocket::handshakeInterruptedOnError</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#continueInterruptedHandshake">QSslSocket::continueInterruptedHandshake</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setLocalCertificate">
<db:title>void QSslConfiguration::setLocalCertificate(const QSslCertificate &amp;<db:emphasis>certificate</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setLocalCertificate</db:methodname>
<db:methodparam>
<db:type>const QSslCertificate &amp;</db:type>
<db:parameter>certificate</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setLocalCertificate(const QSslCertificate &amp;certificate)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the certificate to be presented to the peer during SSL handshake to be <db:code role="parameter">certificate</db:code>.</db:para>
<db:para>Setting the certificate once the connection has been established has no effect.</db:para>
<db:para>A certificate is the means of identification used in the SSL process. The local certificate is used by the remote end to verify the local user's identity against its list of Certification Authorities. In most cases, such as in HTTP web browsing, only servers identify to the clients, so the client does not send a certificate.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#localCertificate">localCertificate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setLocalCertificateChain">
<db:title>[since 5.1] void QSslConfiguration::setLocalCertificateChain(const QList&lt;QSslCertificate&gt; &amp;<db:emphasis>localChain</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setLocalCertificateChain</db:methodname>
<db:methodparam>
<db:type>const QList&lt;QSslCertificate&gt; &amp;</db:type>
<db:parameter>localChain</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setLocalCertificateChain(const QList&lt;QSslCertificate&gt; &amp;localChain)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the certificate chain to be presented to the peer during the SSL handshake to be <db:code role="parameter">localChain</db:code>.</db:para>
<db:para>Setting the certificate chain once the connection has been established has no effect.</db:para>
<db:para>A certificate is the means of identification used in the SSL process. The local certificate is used by the remote end to verify the local user's identity against its list of Certification Authorities. In most cases, such as in HTTP web browsing, only servers identify to the clients, so the client does not send a certificate.</db:para>
<db:para>Unlike <db:link xlink:href="qsslconfiguration.xml#setLocalCertificate">QSslConfiguration::setLocalCertificate</db:link>() this method allows you to specify any intermediate certificates required in order to validate your certificate. The first item in the list must be the leaf certificate.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#localCertificateChain">localCertificateChain</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMissingCertificateIsFatal">
<db:title>[since 6.0] void QSslConfiguration::setMissingCertificateIsFatal(bool <db:emphasis>cannotRecover</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setMissingCertificateIsFatal</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>cannotRecover</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setMissingCertificateIsFatal(bool cannotRecover)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">cannotRecover</db:code> is true, and verification mode in use is <db:link xlink:href="qsslsocket.xml#PeerVerifyMode-enum">QSslSocket::VerifyPeer</db:link> or <db:link xlink:href="qsslsocket.xml#PeerVerifyMode-enum">QSslSocket::AutoVerifyPeer</db:link> (for a client-side socket), the missing peer's certificate would be treated as an unrecoverable error that cannot be ignored. A proper alert message will be sent to the peer before closing the connection.</db:para>
<db:note>
<db:para>Only available if Qt was configured and built with OpenSSL backend.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#ignoreSslErrors">QSslSocket::ignoreSslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#PeerVerifyMode-enum">QSslSocket::PeerVerifyMode</db:link></db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#missingCertificateIsFatal">missingCertificateIsFatal</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setOcspStaplingEnabled">
<db:title>[since 5.13] void QSslConfiguration::setOcspStaplingEnabled(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setOcspStaplingEnabled</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enabled</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setOcspStaplingEnabled(bool enabled)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">enabled</db:code> is true, client <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> will send a certificate status request to its peer when initiating a handshake. During the handshake <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> will verify the server's response. This value must be set before the handshake starts.</db:para>
<db:para>This function was introduced in Qt 5.13.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#ocspStaplingEnabled">ocspStaplingEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPeerVerifyDepth">
<db:title>void QSslConfiguration::setPeerVerifyDepth(int <db:emphasis>depth</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPeerVerifyDepth</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>depth</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPeerVerifyDepth(int depth)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, to <db:code role="parameter">depth</db:code>. Setting a depth of 0 means that no maximum depth is set, indicating that the whole certificate chain should be checked.</db:para>
<db:para>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#peerVerifyDepth">peerVerifyDepth</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setPeerVerifyMode">setPeerVerifyMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPeerVerifyMode">
<db:title>void QSslConfiguration::setPeerVerifyMode(QSslSocket::PeerVerifyMode <db:emphasis>mode</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPeerVerifyMode</db:methodname>
<db:methodparam>
<db:type>QSslSocket::PeerVerifyMode</db:type>
<db:parameter>mode</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPeerVerifyMode(QSslSocket::PeerVerifyMode mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the verify mode to <db:code role="parameter">mode</db:code>. This mode decides whether <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</db:para>
<db:para>The default mode is AutoVerifyPeer, which tells <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> to use VerifyPeer for clients, QueryPeer for servers.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#peerVerifyMode">peerVerifyMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPreSharedKeyIdentityHint">
<db:title>[since 5.8] void QSslConfiguration::setPreSharedKeyIdentityHint(const QByteArray &amp;<db:emphasis>hint</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPreSharedKeyIdentityHint</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>hint</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPreSharedKeyIdentityHint(const QByteArray &amp;hint)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the identity hint for a preshared key authentication to <db:code role="parameter">hint</db:code>. This will affect the next initiated handshake; calling this function on an already-encrypted socket will not affect the socket's identity hint.</db:para>
<db:para>The identity hint is used in <db:link xlink:href="qsslsocket.xml#SslMode-enum">QSslSocket::SslServerMode</db:link> only!</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#preSharedKeyIdentityHint">preSharedKeyIdentityHint</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPrivateKey">
<db:title>void QSslConfiguration::setPrivateKey(const QSslKey &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPrivateKey</db:methodname>
<db:methodparam>
<db:type>const QSslKey &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPrivateKey(const QSslKey &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the connection's private <db:link xlink:href="qsslkey.xml">key</db:link> to <db:code role="parameter">key</db:code>. The private key and the local <db:link xlink:href="qsslcertificate.xml">certificate</db:link> are used by clients and servers that must prove their identity to SSL peers.</db:para>
<db:para>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#privateKey">privateKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setLocalCertificate">setLocalCertificate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProtocol">
<db:title>void QSslConfiguration::setProtocol(QSsl::SslProtocol <db:emphasis>protocol</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setProtocol</db:methodname>
<db:methodparam>
<db:type>QSsl::SslProtocol</db:type>
<db:parameter>protocol</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setProtocol(QSsl::SslProtocol protocol)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the protocol setting for this configuration to be <db:code role="parameter">protocol</db:code>.</db:para>
<db:para>Setting the protocol once the connection has already been established has no effect.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#protocol">protocol</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSessionTicket">
<db:title>[since 5.2] void QSslConfiguration::setSessionTicket(const QByteArray &amp;<db:emphasis>sessionTicket</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSessionTicket</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>sessionTicket</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSessionTicket(const QByteArray &amp;sessionTicket)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the session ticket to be used in an SSL handshake. <db:link xlink:href="qssl.xml#SslOption-enum">QSsl::SslOptionDisableSessionPersistence</db:link> must be turned off for this to work, and <db:code role="parameter">sessionTicket</db:code> must be in ASN.1 format as returned by <db:link xlink:href="qsslconfiguration.xml#sessionTicket">sessionTicket</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#sessionTicket">sessionTicket</db:link>()</db:member>
<db:member><db:link xlink:href="qssl.xml#SslOption-enum">QSsl::SslOptionDisableSessionPersistence</db:link></db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setSslOption">setSslOption</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#newSessionTicketReceived">QSslSocket::newSessionTicketReceived</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSslOption">
<db:title>void QSslConfiguration::setSslOption(QSsl::SslOption <db:emphasis>option</db:emphasis>, bool <db:emphasis>on</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSslOption</db:methodname>
<db:methodparam>
<db:type>QSsl::SslOption</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>on</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSslOption(QSsl::SslOption option, bool on)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Enables or disables an SSL compatibility <db:code role="parameter">option</db:code>. If <db:code role="parameter">on</db:code> is true, the <db:code role="parameter">option</db:code> is enabled. If <db:code role="parameter">on</db:code> is false, the <db:code role="parameter">option</db:code> is disabled.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#testSslOption">testSslOption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportedCiphers">
<db:title>[static, since 5.5] QList&lt;QSslCipher&gt; QSslConfiguration::supportedCiphers()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QList&lt;QSslCipher&gt;</db:type>
<db:methodname>supportedCiphers</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QSslCipher&gt; supportedCiphers()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of cryptographic ciphers supported by this system. This list is set by the system's SSL libraries and may vary from system to system.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#ciphers">ciphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setCiphers">setCiphers</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportedEllipticCurves">
<db:title>[static, since 5.5] QList&lt;QSslEllipticCurve&gt; QSslConfiguration::supportedEllipticCurves()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QList&lt;QSslEllipticCurve&gt;</db:type>
<db:methodname>supportedEllipticCurves</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QSslEllipticCurve&gt; supportedEllipticCurves()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of elliptic curves supported by this system. This list is set by the system's SSL libraries and may vary from system to system.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#ellipticCurves">ellipticCurves</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setEllipticCurves">setEllipticCurves</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>[since 5.0] void QSslConfiguration::swap(QSslConfiguration &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QSslConfiguration &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QSslConfiguration &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps this SSL configuration instance with <db:code role="parameter">other</db:code>. This function is very fast and never fails.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="systemCaCertificates">
<db:title>[static, since 5.5] QList&lt;QSslCertificate&gt; QSslConfiguration::systemCaCertificates()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QList&lt;QSslCertificate&gt;</db:type>
<db:methodname>systemCaCertificates</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QSslCertificate&gt; systemCaCertificates()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function provides the CA certificate database provided by the operating system. The CA certificate database returned by this function is used to initialize the database returned by <db:link xlink:href="qsslconfiguration.xml#caCertificates">caCertificates</db:link>() on the default <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#caCertificates">caCertificates</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setCaCertificates">setCaCertificates</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#defaultConfiguration">defaultConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#addCaCertificate">addCaCertificate</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#addCaCertificates">addCaCertificates</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="testSslOption">
<db:title>bool QSslConfiguration::testSslOption(QSsl::SslOption <db:emphasis>option</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>testSslOption</db:methodname>
<db:methodparam>
<db:type>QSsl::SslOption</db:type>
<db:parameter>option</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool testSslOption(QSsl::SslOption option) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the specified SSL compatibility <db:code role="parameter">option</db:code> is enabled.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setSslOption">setSslOption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QSslConfiguration::operator!=(const QSslConfiguration &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QSslConfiguration &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> differs from <db:code role="parameter">other</db:code>. Two <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> objects are considered different if any state or setting is different.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QSslConfiguration &amp;QSslConfiguration::operator=(const QSslConfiguration &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSslConfiguration &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSslConfiguration &amp; operator=(const QSslConfiguration &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Copies the configuration and state of <db:code role="parameter">other</db:code>. If <db:code role="parameter">other</db:code> is null, this object will be null too.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QSslConfiguration::operator==(const QSslConfiguration &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QSslConfiguration &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> object is equal to <db:code role="parameter">other</db:code>.</db:para>
<db:para>Two <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link> objects are considered equal if they have the exact same settings and state.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-variable-documentation">
<db:title>Member Variable Documentation</db:title>
<db:section xml:id="NextProtocolHttp1_1-var">
<db:title>const char[] QSslConfiguration::NextProtocolHttp1_1</db:title>
<db:fieldsynopsis>
<db:modifier>static</db:modifier>
<db:type>const char[]</db:type>
<db:varname>NextProtocolHttp1_1</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This variable holds the value used for negotiating HTTP 1.1 during the Next Protocol Negotiation.</db:para>
</db:section>
</db:section>
</db:article>
