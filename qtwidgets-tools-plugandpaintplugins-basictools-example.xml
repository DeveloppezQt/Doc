<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Plug &amp; Paint Basic Tools Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.3.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Widgets Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The Basic Tools example is a static plugin for the <db:link xlink:href="qtwidgets-tools-plugandpaint-example.xml">Plug &amp; Paint</db:link> example. It provides a set of basic brushes, shapes, and filters. Through the Basic Tools example, we will review the four steps involved in writing a Qt plugin:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Declare a plugin class.</db:para>
</db:listitem>
<db:listitem>
<db:para>Implement the interfaces provided by the plugin.</db:para>
</db:listitem>
<db:listitem>
<db:para>Export the plugin using the <db:link xlink:href="qtplugin.xml#Q_PLUGIN_METADATA">Q_PLUGIN_METADATA</db:link>() macro.</db:para>
</db:listitem>
<db:listitem>
<db:para>Build the plugin using an adequate <db:code>.pro</db:code> file.</db:para>
</db:listitem>
</db:orderedlist>
<db:section xml:id="declaration-of-the-plugin-class">
<db:title>Declaration of the Plugin Class</db:title>
<db:programlisting language="cpp">#include &lt;plugandpaint/interfaces.h&gt;

class BasicToolsPlugin : public QObject,
                         public BrushInterface,
                         public ShapeInterface,
                         public FilterInterface
{
    Q_OBJECT
    Q_PLUGIN_METADATA(IID &quot;org.qt-project.Qt.Examples.PlugAndPaint.BrushInterface&quot; FILE &quot;basictools.json&quot;)
    Q_INTERFACES(BrushInterface ShapeInterface FilterInterface)
</db:programlisting>
<db:para>We start by including <db:code>interfaces.h</db:code>, which defines the plugin interfaces for the <db:link xlink:href="qtwidgets-tools-plugandpaint-example.xml">Plug &amp; Paint</db:link> application. For the <db:code>#include</db:code> to work, we need to add an <db:code>INCLUDEPATH</db:code> entry to the <db:code>.pro</db:code> file with the path to Qt's <db:code>examples/tools</db:code> directory.</db:para>
<db:para>The <db:code>BasicToolsPlugin</db:code> class is a <db:link xlink:href="qobject.xml">QObject</db:link> subclass that implements the <db:code>BrushInterface</db:code>, the <db:code>ShapeInterface</db:code>, and the <db:code>FilterInterface</db:code>. This is done through multiple inheritance. The <db:code>Q_INTERFACES()</db:code> macro is necessary to tell moc, Qt's meta-object compiler, that the base classes are plugin interfaces. Without the <db:code>Q_INTERFACES()</db:code> macro, we couldn't use <db:link xlink:href="">qobject_cast()</db:link> in the <db:link xlink:href="qtwidgets-tools-plugandpaint-example.xml">Plug &amp; Paint</db:link> application to detect interfaces. For an explanation for the <db:code>Q_PLUGIN_METADATA()</db:code> macro see <db:link xlink:href="qtwidgets-tools-plugandpaintplugins-basictools-example.xml#exporting-the-plugin">Exporting the Plugin</db:link>.</db:para>
<db:programlisting language="cpp">public:
    // BrushInterface
    QStringList brushes() const;
    QRect mousePress(const QString &amp;brush, QPainter &amp;painter,
                     const QPoint &amp;pos);
    QRect mouseMove(const QString &amp;brush, QPainter &amp;painter,
                    const QPoint &amp;oldPos, const QPoint &amp;newPos);
    QRect mouseRelease(const QString &amp;brush, QPainter &amp;painter,
                       const QPoint &amp;pos);

    // ShapeInterface
    QStringList shapes() const;
    QPainterPath generateShape(const QString &amp;shape, QWidget *parent);

    // FilterInterface
    QStringList filters() const;
    QImage filterImage(const QString &amp;filter, const QImage &amp;image,
                       QWidget *parent);
};
</db:programlisting>
<db:para>In the <db:code>public</db:code> section of the class, we declare all the functions from the three interfaces.</db:para>
</db:section>
<db:section xml:id="implementation-of-the-brush-interface">
<db:title>Implementation of the Brush Interface</db:title>
<db:para>Let's now review the implementation of the <db:code>BasicToolsPlugin</db:code> member functions inherited from <db:code>BrushInterface</db:code>.</db:para>
<db:programlisting language="cpp">QStringList BasicToolsPlugin::brushes() const
{
    return QStringList() &lt;&lt; tr(&quot;Pencil&quot;) &lt;&lt; tr(&quot;Air Brush&quot;)
                         &lt;&lt; tr(&quot;Random Letters&quot;);
}
</db:programlisting>
<db:para>The <db:code>brushes()</db:code> function returns a list of brushes provided by this plugin. We provide three brushes: <db:guilabel>Pencil</db:guilabel>, <db:guilabel>Air Brush</db:guilabel>, and <db:guilabel>Random Letters</db:guilabel>.</db:para>
<db:programlisting language="cpp">QRect BasicToolsPlugin::mousePress(const QString &amp;brush, QPainter &amp;painter,
                                   const QPoint &amp;pos)
{
    return mouseMove(brush, painter, pos, pos);
}
</db:programlisting>
<db:para>On a mouse press event, we just call <db:code>mouseMove()</db:code> to draw the spot where the event occurred.</db:para>
<db:programlisting language="cpp">QRect BasicToolsPlugin::mouseMove(const QString &amp;brush, QPainter &amp;painter,
                                  const QPoint &amp;oldPos, const QPoint &amp;newPos)
{
    painter.save();

    int rad = painter.pen().width() / 2;
    QRect boundingRect = QRect(oldPos, newPos).normalized()
                                              .adjusted(-rad, -rad, +rad, +rad);
    QColor color = painter.pen().color();
    int thickness = painter.pen().width();
    QColor transparentColor(color.red(), color.green(), color.blue(), 0);
</db:programlisting>
<db:para>In <db:code>mouseMove()</db:code>, we start by saving the state of the <db:link xlink:href="qpainter.xml">QPainter</db:link> and we compute a few variables that we'll need later.</db:para>
<db:programlisting language="cpp">    if (brush == tr(&quot;Pencil&quot;)) {
        painter.drawLine(oldPos, newPos);
    } else if (brush == tr(&quot;Air Brush&quot;)) {
        int numSteps = 2 + (newPos - oldPos).manhattanLength() / 2;

        painter.setBrush(QBrush(color, Qt::Dense6Pattern));
        painter.setPen(Qt::NoPen);

        for (int i = 0; i &lt; numSteps; ++i) {
            int x = oldPos.x() + i * (newPos.x() - oldPos.x()) / (numSteps - 1);
            int y = oldPos.y() + i * (newPos.y() - oldPos.y()) / (numSteps - 1);

            painter.drawEllipse(x - (thickness / 2), y - (thickness / 2),
                                thickness, thickness);
        }
    } else if (brush == tr(&quot;Random Letters&quot;)) {
        QChar ch('A' + (qrand() % 26));

        QFont biggerFont = painter.font();
        biggerFont.setBold(true);
        biggerFont.setPointSize(biggerFont.pointSize() + thickness);
        painter.setFont(biggerFont);

        painter.drawText(newPos, QString(ch));

        QFontMetrics metrics(painter.font());
        boundingRect = metrics.boundingRect(ch);
        boundingRect.translate(newPos);
        boundingRect.adjust(-10, -10, +10, +10);
    }
    painter.restore();
    return boundingRect;
}
</db:programlisting>
<db:para>Then comes the brush-dependent part of the code:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If the brush is <db:guilabel>Pencil</db:guilabel>, we just call <db:link xlink:href="qpainter.xml#drawLine">QPainter::drawLine</db:link>() with the current <db:link xlink:href="qpen.xml">QPen</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the brush is <db:guilabel>Air Brush</db:guilabel>, we start by setting the painter's <db:link xlink:href="qbrush.xml">QBrush</db:link> to <db:link xlink:href="qt.xml#BrushStyle-enum">Qt::Dense6Pattern</db:link> to obtain a dotted pattern. Then we draw a circle filled with that <db:link xlink:href="qbrush.xml">QBrush</db:link> several times, resulting in a thick line.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the brush is <db:guilabel>Random Letters</db:guilabel>, we draw a random letter at the new cursor position. Most of the code is for setting the font to be bold and larger than the default font and for computing an appropriate bounding rect.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>At the end, we restore the painter state to what it was upon entering the function and we return the bounding rectangle.</db:para>
<db:programlisting language="cpp">QRect BasicToolsPlugin::mouseRelease(const QString &amp; /* brush */,
                                     QPainter &amp; /* painter */,
                                     const QPoint &amp; /* pos */)
{
    return QRect(0, 0, 0, 0);
}
</db:programlisting>
<db:para>When the user releases the mouse, we do nothing and return an empty <db:link xlink:href="qrect.xml">QRect</db:link>.</db:para>
</db:section>
<db:section xml:id="implementation-of-the-shape-interface">
<db:title>Implementation of the Shape Interface</db:title>
<db:programlisting language="cpp">QStringList BasicToolsPlugin::shapes() const
{
    return QStringList() &lt;&lt; tr(&quot;Circle&quot;) &lt;&lt; tr(&quot;Star&quot;) &lt;&lt; tr(&quot;Text...&quot;);
}
</db:programlisting>
<db:para>The plugin provides three shapes: <db:guilabel>Circle</db:guilabel>, <db:guilabel>Star</db:guilabel>, and <db:guilabel>Text...</db:guilabel>. The three dots after <db:guilabel>Text</db:guilabel> are there because the shape pops up a dialog asking for more information. We know that the shape names will end up in a menu, so we include the three dots in the shape name.</db:para>
<db:para>A cleaner but more complicated design would have been to distinguish between the internal shape name and the name used in the user interface.</db:para>
<db:programlisting language="cpp">QPainterPath BasicToolsPlugin::generateShape(const QString &amp;shape,
                                             QWidget *parent)
{
    QPainterPath path;

    if (shape == tr(&quot;Circle&quot;)) {
        path.addEllipse(0, 0, 50, 50);
    } else if (shape == tr(&quot;Star&quot;)) {
        path.moveTo(90, 50);
        for (int i = 1; i &lt; 5; ++i) {
            path.lineTo(50 + 40 * cos(0.8 * i * Pi),
                        50 + 40 * sin(0.8 * i * Pi));
        }
        path.closeSubpath();
    } else if (shape == tr(&quot;Text...&quot;)) {
        QString text = QInputDialog::getText(parent, tr(&quot;Text Shape&quot;),
                                             tr(&quot;Enter text:&quot;),
                                             QLineEdit::Normal, tr(&quot;Qt&quot;));
        if (!text.isEmpty()) {
            QFont timesFont(&quot;Times&quot;, 50);
            timesFont.setStyleStrategy(QFont::ForceOutline);
            path.addText(0, 0, timesFont, text);
        }
    }

    return path;
}
</db:programlisting>
<db:para>The <db:code>generateShape()</db:code> creates a <db:link xlink:href="qpainterpath.xml">QPainterPath</db:link> for the specified shape. If the shape is <db:guilabel>Text</db:guilabel>, we pop up a <db:link xlink:href="qinputdialog.xml">QInputDialog</db:link> to let the user enter some text.</db:para>
</db:section>
<db:section xml:id="implementation-of-the-filter-interface">
<db:title>Implementation of the Filter Interface</db:title>
<db:programlisting language="cpp">QStringList BasicToolsPlugin::filters() const
{
    return QStringList() &lt;&lt; tr(&quot;Invert Pixels&quot;) &lt;&lt; tr(&quot;Swap RGB&quot;)
                         &lt;&lt; tr(&quot;Grayscale&quot;);
}
</db:programlisting>
<db:para>The plugin provides three filters: <db:guilabel>Invert Pixels</db:guilabel>, <db:guilabel>Swap RGB</db:guilabel>, and <db:guilabel>Grayscale</db:guilabel>.</db:para>
<db:programlisting language="cpp">QImage BasicToolsPlugin::filterImage(const QString &amp;filter, const QImage &amp;image,
                                     QWidget * /* parent */)
{
    QImage result = image.convertToFormat(QImage::Format_RGB32);

    if (filter == tr(&quot;Invert Pixels&quot;)) {
        result.invertPixels();
    } else if (filter == tr(&quot;Swap RGB&quot;)) {
        result = result.rgbSwapped();
    } else if (filter == tr(&quot;Grayscale&quot;)) {
        for (int y = 0; y &lt; result.height(); ++y) {
            for (int x = 0; x &lt; result.width(); ++x) {
                int pixel = result.pixel(x, y);
                int gray = qGray(pixel);
                int alpha = qAlpha(pixel);
                result.setPixel(x, y, qRgba(gray, gray, gray, alpha));
            }
        }
    }
    return result;
}
</db:programlisting>
<db:para>The <db:code>filterImage()</db:code> function takes a filter name and a <db:link xlink:href="qimage.xml">QImage</db:link> as parameters and returns an altered <db:link xlink:href="qimage.xml">QImage</db:link>. The first thing we do is to convert the image to a 32-bit RGB format, to ensure that the algorithms will work as expected. For example, <db:link xlink:href="qimage.xml#invertPixels">QImage::invertPixels</db:link>(), which is used to implement the <db:guilabel>Invert Pixels</db:guilabel> filter, gives counterintuitive results for 8-bit images, because they invert the indices into the color table instead of inverting the color table's entries.</db:para>
</db:section>
<db:section xml:id="exporting-the-plugin">
<db:title>Exporting the Plugin</db:title>
<db:para>To finally export your plugin you just have to add the <db:code>Q_PLUGIN_METADATA()</db:code> macro right next to the <db:code>Q_OBJECT()</db:code> macro into the header file of the plugin. It must contain the plugins IID and optionally a filename pointing to a json file containing the metadata for the plugin.</db:para>
<db:programlisting language="cpp">    Q_PLUGIN_METADATA(IID &quot;org.qt-project.Qt.Examples.PlugAndPaint.BrushInterface&quot; FILE &quot;basictools.json&quot;)
</db:programlisting>
<db:para>Within this example the json file does not need to export any metadata, so it just contains an empty json object.</db:para>
<db:programlisting language="cpp">{}
</db:programlisting>
</db:section>
<db:section xml:id="the-pro-file">
<db:title>The .pro File</db:title>
<db:para>Here's the project file for building the Basic Tools plugin:</db:para>
<db:programlisting language="cpp">TEMPLATE      = lib
CONFIG       += plugin static
QT           += widgets
INCLUDEPATH  += ../..
HEADERS       = basictoolsplugin.h
SOURCES       = basictoolsplugin.cpp
TARGET        = $$qtLibraryTarget(pnp_basictools)
DESTDIR       = ../../plugandpaint/plugins
</db:programlisting>
<db:para>The <db:code>.pro</db:code> file differs from typical <db:code>.pro</db:code> files in many respects. First, it starts with a <db:code>TEMPLATE</db:code> entry specifying <db:code>lib</db:code>. (The default template is <db:code>app</db:code>.) It also adds <db:code>plugin</db:code> to the <db:code>CONFIG</db:code> variable. This is necessary on some platforms to avoid generating symbolic links with version numbers in the file name, which is appropriate for most dynamic libraries but not for plugins.</db:para>
<db:para>To make the plugin a static plugin, all that is required is to specify <db:code>static</db:code> in addition to <db:code>plugin</db:code>. The <db:link xlink:href="qtwidgets-tools-plugandpaintplugins-extrafilters-example.xml">Extra Filters</db:link> plugin, which is compiled as a dynamic plugin, doesn't specify <db:code>static</db:code> in its <db:code>.pro</db:code> file.</db:para>
<db:para>The <db:code>INCLUDEPATH</db:code> variable sets the search paths for global headers (i.e., header files included using <db:code>#include &lt;...&gt;</db:code>). We add Qt's <db:code>examples/tools</db:code> directory (strictly speaking, <db:code>examples/tools/plugandpaintplugins/basictools/../..</db:code>) to the list, so that we can include <db:code>&lt;plugandpaint/interfaces.h&gt;</db:code>.</db:para>
<db:para>The <db:code>TARGET</db:code> variable specifies which name we want to give the target library. We use <db:code>pnp_</db:code> as the prefix to show that the plugin is designed to work with Plug &amp; Paint. On Unix, <db:code>lib</db:code> is also prepended to that name. On all platforms, a platform-specific suffix is appended (e.g., <db:code>.dll</db:code> on Windows, <db:code>.a</db:code> on Linux).</db:para>
<db:para>The <db:code>CONFIG()</db:code> code at the end is necessary for this example because the example is part of the Qt distribution and Qt can be configured to be built simultaneously in debug and in release modes. You don't need to for your own plugins.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="tools/plugandpaintplugins/basictools/basictools.pro">tools/plugandpaintplugins/basictools/basictools.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tools/plugandpaintplugins/basictools/basictoolsplugin.cpp">tools/plugandpaintplugins/basictools/basictoolsplugin.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tools/plugandpaintplugins/basictools/basictoolsplugin.h">tools/plugandpaintplugins/basictools/basictoolsplugin.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
