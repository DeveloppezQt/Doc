<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRhiRenderBuffer Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Renderbuffer resource.</db:para>
<db:para>This class was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>rhi/qrhi.h</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui-private</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qrhiresource.xml" xlink:role="class">QRhiResource</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Renderbuffers cannot be sampled or read but have some benefits over textures in some cases:</db:para>
<db:para>A <db:link xlink:href="qrhirenderbuffer.xml#Type-enum">DepthStencil</db:link> renderbuffer may be lazily allocated and be backed by transient memory with some APIs. On some platforms this may mean the depth/stencil buffer uses no physical backing at all.</db:para>
<db:para><db:link xlink:href="qrhirenderbuffer.xml#Type-enum">Color</db:link> renderbuffers are useful since <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::MultisampleRenderBuffer</db:link> may be supported even when <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::MultisampleTexture</db:link> is not.</db:para>
<db:para>How the renderbuffer is implemented by a backend is not exposed to the applications. In some cases it may be backed by ordinary textures, while in others there may be a different kind of native resource used.</db:para>
<db:para>Renderbuffers that are used as (and are only used as) depth-stencil buffers in combination with a <db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link>'s color buffers should have the <db:link xlink:href="qrhirenderbuffer.xml#Flag-enum">UsedWithSwapChainOnly</db:link> flag set. This serves a double purpose: such buffers, depending on the backend and the underlying APIs, be more efficient, and <db:link xlink:href="qrhi.xml">QRhi</db:link> provides automatic sizing behavior to match the color buffers, which means calling setPixelSize() and create() are not necessary for such renderbuffers.</db:para>
<db:note>
<db:para>This is a RHI API with limited compatibility guarantees, see <db:link xlink:href="qrhi.xml">QRhi</db:link> for details.</db:para>
</db:note>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Flag-enum">
<db:title>enum QRhiRenderBuffer::Flag</db:title>
<db:bridgehead renderas="sect2">flags QRhiRenderBuffer::Flags</db:bridgehead>
<db:para>Flag values for flags() and setFlags()</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link></db:emphasis>::UsedWithSwapChainOnly</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 0</db:code></db:td>
<db:td>
<db:para>For <db:link xlink:href="qrhirenderbuffer.xml#Type-enum">DepthStencil</db:link> renderbuffers this indicates that the renderbuffer is only used in combination with a <db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link>, and never in any other way. This provides automatic sizing and resource rebuilding, so calling setPixelSize() or create() is not needed whenever this flag is set. This flag value may also trigger backend-specific behavior, for example with OpenGL, where a separate windowing system interface API is in use (EGL, GLX, etc.), the flag is especially important as it avoids creating any actual renderbuffer resource as there is already a windowing system provided depth/stencil buffer as requested by <db:link xlink:href="qsurfaceformat.xml">QSurfaceFormat</db:link>.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>Flags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Flag&gt;. </db:code>It stores an OR combination of <db:code>Flag</db:code> values.</db:para>
</db:section>
<db:section xml:id="Type-enum">
<db:title>enum QRhiRenderBuffer::Type</db:title>
<db:para>Specifies the type of the renderbuffer</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link></db:emphasis>::DepthStencil</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Combined depth/stencil</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link></db:emphasis>::Color</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Color</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="createFrom">
<db:title>[virtual] bool QRhiRenderBuffer::createFrom(QRhiRenderBuffer::NativeRenderBuffer <db:emphasis>src</db:emphasis>)</db:title>
<db:para>Similar to create() except that no new native renderbuffer objects are created. Instead, the native renderbuffer object specified by <db:code role="parameter">src</db:code> is used.</db:para>
<db:para>This allows importing an existing renderbuffer object (which must belong to the same device or sharing context, depending on the graphics API) from an external graphics engine.</db:para>
<db:note>
<db:para>This is currently applicable to OpenGL only. This function exists solely to allow importing a renderbuffer object that is bound to some special, external object, such as an EGLImageKHR. Once the application performed the glEGLImageTargetRenderbufferStorageOES call, the renderbuffer object can be passed to this function to create a wrapping <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link>, which in turn can be passed in as a color attachment to a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> to enable rendering to the EGLImage.</db:para>
</db:note>
<db:note>
<db:para>pixelSize(), sampleCount(), and flags() must still be set correctly. Passing incorrect sizes and other values to <db:link xlink:href="qrhi.xml#newRenderBuffer">QRhi::newRenderBuffer</db:link>() and then following it with a createFrom() expecting that the native renderbuffer object alone is sufficient to deduce such values is <db:emphasis role="bold">wrong</db:emphasis> and will lead to problems.</db:para>
</db:note>
<db:note>
<db:para><db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> does not take ownership of the native object, and destroy() will not release that object.</db:para>
</db:note>
<db:note>
<db:para>This function is only implemented when the <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::RenderBufferImport</db:link> feature is reported as <db:link xlink:href="qrhi.xml#isFeatureSupported">supported</db:link>. Otherwise, the function does nothing and the return value is <db:code>false</db:code>.</db:para>
</db:note>
<db:para>Returns <db:code>true</db:code> when successful, <db:code>false</db:code> when not supported.</db:para>
</db:section>
<db:section xml:id="resourceType">
<db:title>[override virtual] QRhiResource::Type QRhiRenderBuffer::resourceType() const</db:title>
<db:para>Returns the resource type.</db:para>
</db:section>
</db:section>
</db:article>
