<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRhi Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Accelerated 2D/3D graphics API abstraction.</db:para>
<db:para>This class was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>rhi/qrhi.h</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui-private</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QRhi is part of <db:simplelist><db:member><db:link xlink:href="painting-3d.xml">Rendering in 3D</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The Qt Rendering Hardware Interface is an abstraction for hardware accelerated graphics APIs, such as, <db:link xlink:href="https://www.khronos.org/opengl/">OpenGL</db:link>, <db:link xlink:href="https://www.khronos.org/opengles/">OpenGL ES</db:link>, <db:link xlink:href="https://docs.microsoft.com/en-us/windows/desktop/direct3d">Direct3D</db:link>, <db:link xlink:href="https://developer.apple.com/metal/">Metal</db:link>, and <db:link xlink:href="https://www.khronos.org/vulkan/">Vulkan</db:link>.</db:para>
<db:warning>
<db:para>The <db:link xlink:href="qrhi.xml">QRhi</db:link> family of classes in the Qt Gui module, including <db:link xlink:href="qshader.xml">QShader</db:link> and <db:link xlink:href="qshaderdescription.xml">QShaderDescription</db:link>, offer limited compatibility guarantees. There are no source or binary compatibility guarantees for these classes, meaning the API is only guaranteed to work with the Qt version the application was developed against. Source incompatible changes are however aimed to be kept at a minimum and will only be made in minor releases (6.7, 6.8, and so on). To use these classes in an application, link to <db:code>Qt::GuiPrivate</db:code> (if using CMake), and include the headers with the <db:code>rhi</db:code> prefix, for example <db:code>#include &lt;rhi/qrhi.h&gt;</db:code>.</db:para>
</db:warning>
<db:para>Each <db:link xlink:href="qrhi.xml">QRhi</db:link> instance is backed by a backend for a specific graphics API. The selection of the backend is a run time choice and is up to the application or library that creates the <db:link xlink:href="qrhi.xml">QRhi</db:link> instance. Some backends are available on multiple platforms (OpenGL, Vulkan, Null), while APIs specific to a given platform are only available when running on the platform in question (Metal on macOS/iOS, Direct3D on Windows).</db:para>
<db:para>The available backends currently are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>OpenGL 2.1 / OpenGL ES 2.0 or newer. Some extensions and newer core specification features are utilized when present, for example to enable multisample framebuffers or compute shaders. Operating in core profile contexts is supported as well. If necessary, applications can query the <db:link xlink:href="qrhi.xml#Feature-enum">feature flags</db:link> at runtime to check for features that are not supported in the OpenGL context backing the <db:link xlink:href="qrhi.xml">QRhi</db:link>. The OpenGL backend builds on <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link>, <db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link>, and the related cross-platform infrastructure of the Qt GUI module.</db:para>
</db:listitem>
<db:listitem>
<db:para>Direct3D 11.2 and newer (with DXGI 1.3 and newer), using Shader Model 5.0 or newer. When the D3D runtime has no support for 11.2 features or Shader Model 5.0, initialization using an accelerated graphics device will fail, but using the <db:link xlink:href="https://learn.microsoft.com/en-us/windows/win32/direct3darticles/directx-warp">software adapter</db:link> is still an option.</db:para>
</db:listitem>
<db:listitem>
<db:para>Direct3D 12 on Windows 10 version 1703 and newer, with Shader Model 5.0 or newer. Qt requires ID3D12Device2 to be present, hence the requirement for at least version 1703 of Windows 10. The D3D12 device is by default created with specifying a minimum feature level of <db:code>D3D_FEATURE_LEVEL_11_0</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Metal 1.2 or newer.</db:para>
</db:listitem>
<db:listitem>
<db:para>Vulkan 1.0 or newer, optionally utilizing some Vulkan 1.1 level features.</db:para>
</db:listitem>
<db:listitem>
<db:para>Null, a &quot;dummy&quot; backend that issues no graphics calls at all.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In order to allow shader code to be written once in Qt applications and libraries, all shaders are expected to be written in a single language which is then compiled into SPIR-V. Versions for various shading language are then generated from that, together with reflection information (inputs, outputs, shader resources). This is then packed into easily and efficiently serializable <db:link xlink:href="qshader.xml">QShader</db:link> instances. The compilers and tools to generate such shaders are not part of <db:link xlink:href="qrhi.xml">QRhi</db:link> and the Qt GUI module, but the core classes for using such shaders, <db:link xlink:href="qshader.xml">QShader</db:link> and <db:link xlink:href="qshaderdescription.xml">QShaderDescription</db:link>, are. The APIs and tools for performing compilation and translation are part of the Qt Shader Tools module.</db:para>
<db:para>See the <db:link xlink:href="qtgui-rhiwindow-example.xml">RHI Window Example</db:link> for an introductory example of creating a portable, cross-platform application that performs accelerated 3D rendering onto a <db:link xlink:href="qwindow.xml">QWindow</db:link> using <db:link xlink:href="qrhi.xml">QRhi</db:link>.</db:para>
<db:section xml:id="an-impression-of-the-api">
<db:title>An Impression of the API</db:title>
<db:para>To provide a quick look at the API with a short yet complete example that does not involve window-related setup, the following is a complete, runnable cross-platform application that renders 20 frames off-screen, and then saves the generated images to files after reading back the texture contents from the GPU. For an example that renders on-screen, which then involves setting up a <db:link xlink:href="qwindow.xml">QWindow</db:link> and a swapchain, refer to the <db:link xlink:href="qtgui-rhiwindow-example.xml">RHI Window Example</db:link>.</db:para>
<db:para>For brevity, the initialization of the <db:link xlink:href="qrhi.xml">QRhi</db:link> is done based on the platform: the sample code here chooses Direct 3D 12 on Windows, Metal on macOS and iOS, and Vulkan otherwise. OpenGL and Direct 3D 11 are never used by this application, but support for those could be introduced with a few additional lines.</db:para>
<db:programlisting language="cpp">#include &lt;QGuiApplication&gt;
#include &lt;QImage&gt;
#include &lt;QFile&gt;
#include &lt;rhi/qrhi.h&gt;

int main(int argc, char **argv)
{
    QGuiApplication app(argc, argv);

#if QT_CONFIG(vulkan)
    QVulkanInstance inst;
#endif
    std::unique_ptr&lt;QRhi&gt; rhi;
#if defined(Q_OS_WIN)
    QRhiD3D12InitParams params;
    rhi.reset(QRhi::create(QRhi::D3D12, &amp;params));
#elif QT_CONFIG(metal)
    QRhiMetalInitParams params;
    rhi.reset(QRhi::create(QRhi::Metal, &amp;params));
#elif QT_CONFIG(vulkan)
    inst.setExtensions(QRhiVulkanInitParams::preferredInstanceExtensions());
    if (inst.create()) {
        QRhiVulkanInitParams params;
        params.inst = &amp;inst;
        rhi.reset(QRhi::create(QRhi::Vulkan, &amp;params));
    } else {
        qFatal(&quot;Failed to create Vulkan instance&quot;);
    }
#endif
    if (rhi)
        qDebug() &lt;&lt; rhi-&gt;backendName() &lt;&lt; rhi-&gt;driverInfo();
    else
        qFatal(&quot;Failed to initialize RHI&quot;);

    float rotation = 0.0f;
    float opacity = 1.0f;
    int opacityDir = 1;

    std::unique_ptr&lt;QRhiTexture&gt; tex(rhi-&gt;newTexture(QRhiTexture::RGBA8,
                                                     QSize(1280, 720),
                                                     1,
                                                     QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
    tex-&gt;create();
    std::unique_ptr&lt;QRhiTextureRenderTarget&gt; rt(rhi-&gt;newTextureRenderTarget({ tex.get() }));
    std::unique_ptr&lt;QRhiRenderPassDescriptor&gt; rp(rt-&gt;newCompatibleRenderPassDescriptor());
    rt-&gt;setRenderPassDescriptor(rp.get());
    rt-&gt;create();

    QMatrix4x4 viewProjection = rhi-&gt;clipSpaceCorrMatrix();
    viewProjection.perspective(45.0f, 1280 / 720.f, 0.01f, 1000.0f);
    viewProjection.translate(0, 0, -4);

    static float vertexData[] = { // Y up, CCW
        0.0f,   0.5f,     1.0f, 0.0f, 0.0f,
        -0.5f, -0.5f,     0.0f, 1.0f, 0.0f,
        0.5f,  -0.5f,     0.0f, 0.0f, 1.0f,
    };

    std::unique_ptr&lt;QRhiBuffer&gt; vbuf(rhi-&gt;newBuffer(QRhiBuffer::Immutable,
                                                    QRhiBuffer::VertexBuffer,
                                                    sizeof(vertexData)));
    vbuf-&gt;create();

    std::unique_ptr&lt;QRhiBuffer&gt; ubuf(rhi-&gt;newBuffer(QRhiBuffer::Dynamic,
                                                    QRhiBuffer::UniformBuffer,
                                                    64 + 4));
    ubuf-&gt;create();

    std::unique_ptr&lt;QRhiShaderResourceBindings&gt; srb(rhi-&gt;newShaderResourceBindings());
    srb-&gt;setBindings({
        QRhiShaderResourceBinding::uniformBuffer(0,
                                                 QRhiShaderResourceBinding::VertexStage | QRhiShaderResourceBinding::FragmentStage,
                                                 ubuf.get())
    });
    srb-&gt;create();

    std::unique_ptr&lt;QRhiGraphicsPipeline&gt; ps(rhi-&gt;newGraphicsPipeline());
    QRhiGraphicsPipeline::TargetBlend premulAlphaBlend;
    premulAlphaBlend.enable = true;
    ps-&gt;setTargetBlends({ premulAlphaBlend });
    static auto getShader = [](const QString &amp;name) {
        QFile f(name);
        return f.open(QIODevice::ReadOnly) ? QShader::fromSerialized(f.readAll()) : QShader();
    };
    ps-&gt;setShaderStages({
        { QRhiShaderStage::Vertex, getShader(QLatin1String(&quot;color.vert.qsb&quot;)) },
        { QRhiShaderStage::Fragment, getShader(QLatin1String(&quot;color.frag.qsb&quot;)) }
    });
    QRhiVertexInputLayout inputLayout;
    inputLayout.setBindings({
        { 5 * sizeof(float) }
    });
    inputLayout.setAttributes({
        { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
        { 0, 1, QRhiVertexInputAttribute::Float3, 2 * sizeof(float) }
    });
    ps-&gt;setVertexInputLayout(inputLayout);
    ps-&gt;setShaderResourceBindings(srb.get());
    ps-&gt;setRenderPassDescriptor(rp.get());
    ps-&gt;create();

    QRhiCommandBuffer *cb;
    for (int frame = 0; frame &lt; 20; ++frame) {
        rhi-&gt;beginOffscreenFrame(&amp;cb);

        QRhiResourceUpdateBatch *u = rhi-&gt;nextResourceUpdateBatch();
        if (frame == 0)
            u-&gt;uploadStaticBuffer(vbuf.get(), vertexData);

        QMatrix4x4 mvp = viewProjection;
        mvp.rotate(rotation, 0, 1, 0);
        u-&gt;updateDynamicBuffer(ubuf.get(), 0, 64, mvp.constData());
        rotation += 5.0f;

        u-&gt;updateDynamicBuffer(ubuf.get(), 64, 4, &amp;opacity);
        opacity += opacityDir * 0.2f;
        if (opacity &lt; 0.0f || opacity &gt; 1.0f) {
            opacityDir *= -1;
            opacity = qBound(0.0f, opacity, 1.0f);
        }

        cb-&gt;beginPass(rt.get(), Qt::green, { 1.0f, 0 }, u);
        cb-&gt;setGraphicsPipeline(ps.get());
        cb-&gt;setViewport({ 0, 0, 1280, 720 });
        cb-&gt;setShaderResources();
        const QRhiCommandBuffer::VertexInput vbufBinding(vbuf.get(), 0);
        cb-&gt;setVertexInput(0, 1, &amp;vbufBinding);
        cb-&gt;draw(3);
        QRhiReadbackResult readbackResult;
        u = rhi-&gt;nextResourceUpdateBatch();
        u-&gt;readBackTexture({ tex.get() }, &amp;readbackResult);
        cb-&gt;endPass(u);

        rhi-&gt;endOffscreenFrame();

        QImage image(reinterpret_cast&lt;const uchar *&gt;(readbackResult.data.constData()),
                     readbackResult.pixelSize.width(),
                     readbackResult.pixelSize.height(),
                     QImage::Format_RGBA8888_Premultiplied);
        if (rhi-&gt;isYUpInFramebuffer())
            image = image.mirrored();
        image.save(QString::asprintf(&quot;frame%d.png&quot;, frame));
    }

    return 0;
}
</db:programlisting>
<db:para>The result of the application is 20 <db:code>PNG</db:code> images (frame0.png - frame19.png). These contain a rotating triangle with varying opacity over a green background.</db:para>
<db:para>The vertex and fragment shaders are expected to be processed and packaged into <db:code>.qsb</db:code> files. The Vulkan-compatible GLSL source code is the following:</db:para>
<db:para><db:emphasis>color.vert</db:emphasis></db:para>
<db:programlisting language="cpp">#version 440

layout(location = 0) in vec4 position;
layout(location = 1) in vec3 color;
layout(location = 0) out vec3 v_color;

layout(std140, binding = 0) uniform buf {
    mat4 mvp;
    float opacity;
};

void main()
{
    v_color = color;
    gl_Position = mvp * position;
}
</db:programlisting>
<db:para><db:emphasis>color.frag</db:emphasis></db:para>
<db:programlisting language="cpp">#version 440

layout(location = 0) in vec3 v_color;
layout(location = 0) out vec4 fragColor;

layout(std140, binding = 0) uniform buf {
    mat4 mvp;
    float opacity;
};

void main()
{
    fragColor = vec4(v_color * opacity, opacity);
}
</db:programlisting>
<db:para>To manually compile and transpile these shaders to a number of targets (SPIR-V, HLSL, MSL, GLSL) and generate the <db:code>.qsb</db:code> files the application loads at run time, run <db:code>qsb --qt6 color.vert -o color.vert.qsb</db:code> and <db:code>qsb --qt6 color.frag -o color.frag.qsb</db:code>. Alternatively, the Qt Shader Tools module offers build system integration for CMake, the <db:code>qt_add_shaders()</db:code> CMake function, that can achieve the same at build time.</db:para>
</db:section>
<db:section xml:id="design-fundamentals">
<db:title>Design Fundamentals</db:title>
<db:para>A <db:link xlink:href="qrhi.xml">QRhi</db:link> cannot be instantiated directly. Instead, use the <db:link xlink:href="qrhi.xml#create">create</db:link>() function. Delete the <db:link xlink:href="qrhi.xml">QRhi</db:link> instance normally to release the graphics device.</db:para>
<db:section xml:id="resources">
<db:title>Resources</db:title>
<db:para>Instances of classes deriving from <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link>, such as, <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link>, <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>, etc., encapsulate zero, one, or more native graphics resources. Instances of such classes are always created via the <db:code>new</db:code> functions of the <db:link xlink:href="qrhi.xml">QRhi</db:link>, such as, <db:link xlink:href="qrhi.xml#newBuffer">newBuffer</db:link>(), <db:link xlink:href="qrhi.xml#newTexture">newTexture</db:link>(), <db:link xlink:href="qrhi.xml#newTextureRenderTarget">newTextureRenderTarget</db:link>(), <db:link xlink:href="qrhi.xml#newSwapChain">newSwapChain</db:link>().</db:para>
<db:programlisting language="cpp">QRhiBuffer *vbuf = rhi-&gt;newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertexData));
if (!vbuf-&gt;create()) { error(); }
// ...
delete vbuf;
</db:programlisting>
<db:itemizedlist>
<db:listitem>
<db:para>The returned value from functions like <db:link xlink:href="qrhi.xml#newBuffer">newBuffer</db:link>() is always owned by the caller.</db:para>
</db:listitem>
<db:listitem>
<db:para>Just creating an instance of a <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> subclass never allocates or initializes any native resources. That is only done when calling the <db:code>create()</db:code> function of a subclass, for example, QRhiBuffer::create() or QRhiTexture::create().</db:para>
</db:listitem>
<db:listitem>
<db:para>The exceptions are QRhiTextureRenderTarget::newCompatibleRenderPassDescriptor(), QRhiSwapChain::newCompatibleRenderPassDescriptor(), and QRhiRenderPassDescriptor::newCompatibleRenderPassDescriptor(). There is no <db:code>create()</db:code> operation for these and the returned object is immediately active.</db:para>
</db:listitem>
<db:listitem>
<db:para>The resource objects themselves are treated as immutable: once a resource has <db:link xlink:href="qrhi.xml#create">create</db:link>() called, changing any parameters via the setters, such as, QRhiTexture::setPixelSize(), has no effect, unless the underlying native resource is released and <db:code>create()</db:code> is called again. See more about resource reuse in the sections below.</db:para>
</db:listitem>
<db:listitem>
<db:para>The underlying native resources are scheduled for releasing by the <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> destructor, or by calling QRhiResource::destroy(). Backends often queue release requests and defer executing them to an unspecified time, this is hidden from the applications. This way applications do not have to worry about releasing native resources that may still be in use by an in-flight frame.</db:para>
</db:listitem>
<db:listitem>
<db:para>Note that this does not mean that a <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> can freely be destroy()'ed or deleted within a frame (that is, in a <db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>() - <db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>() section). As a general rule, all referenced <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> objects must stay unchanged until the frame is submitted by calling <db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>(). To ease this, <db:link xlink:href="qrhiresource.xml#deleteLater">QRhiResource::deleteLater</db:link>() is provided as a convenience.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="command-buffers-and-deferred-command-execution">
<db:title>Command buffers and deferred command execution</db:title>
<db:para>Regardless of the design and capabilities of the underlying graphics API, all <db:link xlink:href="qrhi.xml">QRhi</db:link> backends implement some level of command buffers. No <db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link> function issues any native bind or draw command (such as, <db:code>glDrawElements</db:code>) directly. Commands are always recorded in a queue, either native or provided by the <db:link xlink:href="qrhi.xml">QRhi</db:link> backend. The command buffer is submitted, and so execution starts only upon <db:link xlink:href="qrhi.xml#endFrame">QRhi::endFrame</db:link>() or <db:link xlink:href="qrhi.xml#finish">QRhi::finish</db:link>().</db:para>
<db:para>The deferred nature has consequences for some types of objects. For example, writing to a dynamic buffer multiple times within a frame, in case such buffers are backed by host-visible memory, will result in making the results of all writes are visible to all draw calls in the command buffer of the frame, regardless of when the dynamic buffer update was recorded relative to a draw call.</db:para>
<db:para>Furthermore, instances of <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> subclasses must be treated immutable within a frame in which they are referenced in any way. Create all resources upfront, before starting to record commands for the next frame. Reusing a <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> instance within a frame (by calling <db:code>create()</db:code> then referencing it again in the same <db:code>beginFrame - endFrame</db:code> section) should be avoided as it may lead to unexpected results, depending on the backend.</db:para>
<db:para>As a general rule, all referenced <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> objects must stay valid and unmodified until the frame is submitted by calling <db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>(). On the other hand, calling <db:link xlink:href="">destroy()</db:link> or deleting the <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> are always safe once the frame is submitted, regardless of the status of the underlying native resources (which may still be in use by the GPU - but that is taken care of internally).</db:para>
<db:para>Unlike APIs like OpenGL, upload and copy type of commands cannot be mixed with draw commands. The typical renderer will involve a sequence similar to the following:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>(re)create resources</db:para>
</db:listitem>
<db:listitem>
<db:para>begin frame</db:para>
</db:listitem>
<db:listitem>
<db:para>record/issue uploads and copies</db:para>
</db:listitem>
<db:listitem>
<db:para>start recording a render pass</db:para>
</db:listitem>
<db:listitem>
<db:para>record draw calls</db:para>
</db:listitem>
<db:listitem>
<db:para>end render pass</db:para>
</db:listitem>
<db:listitem>
<db:para>end frame</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Recording copy type of operations happens via <db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link>. Such operations are committed typically on <db:link xlink:href="qrhicommandbuffer.xml#beginPass">beginPass</db:link>().</db:para>
<db:para>When working with legacy rendering engines designed for OpenGL, the migration to <db:link xlink:href="qrhi.xml">QRhi</db:link> often involves redesigning from having a single <db:code>render</db:code> step (that performs copies and uploads, clears buffers, and issues draw calls, all mixed together) to a clearly separated, two phase <db:code>prepare</db:code> - <db:code>render</db:code> setup where the <db:code>render</db:code> step only starts a renderpass and records draw calls, while all resource creation and queuing of updates, uploads and copies happens beforehand, in the <db:code>prepare</db:code> step.</db:para>
<db:para><db:link xlink:href="qrhi.xml">QRhi</db:link> does not at the moment allow freely creating and submitting command buffers. This may be lifted in the future to some extent, in particular if compute support is introduced, but the model of well defined <db:code>frame-start</db:code> and <db:code>frame-end</db:code> points, combined with a dedicated, &quot;frame&quot; command buffer, where <db:code>frame-end</db:code> implies presenting, is going to remain the primary way of operating since this is what fits Qt's various UI technologies best.</db:para>
</db:section>
<db:section xml:id="threading">
<db:title>Threading</db:title>
<db:para>A <db:link xlink:href="qrhi.xml">QRhi</db:link> instance and the associated resources can be created and used on any thread but all usage must be limited to that one single thread. When rendering to multiple QWindows in an application, having a dedicated thread and <db:link xlink:href="qrhi.xml">QRhi</db:link> instance for each window is often advisable, as this can eliminate issues with unexpected throttling caused by presenting to multiple windows. Conceptually that is then the same as how Qt Quick scene graph's threaded render loop operates when working directly with OpenGL: one thread for each window, one <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> for each thread. When moving onto <db:link xlink:href="qrhi.xml">QRhi</db:link>, <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> is replaced by <db:link xlink:href="qrhi.xml">QRhi</db:link>, making the migration straightforward.</db:para>
<db:para>When it comes to externally created native objects, such as OpenGL contexts passed in via <db:link xlink:href="qrhigles2nativehandles.xml">QRhiGles2NativeHandles</db:link>, it is up to the application to ensure they are not misused by other threads.</db:para>
<db:para>Resources are not shareable between <db:link xlink:href="qrhi.xml">QRhi</db:link> instances. This is an intentional choice since <db:link xlink:href="qrhi.xml">QRhi</db:link> hides most queue, command buffer, and resource synchronization related tasks, and provides no API for them. Safe and efficient concurrent use of graphics resources from multiple threads is tied to those concepts, however, and is thus a topic that is currently out of scope, but may be introduced in the future.</db:para>
<db:note>
<db:para>The Metal backend requires that an autorelease pool is available on the rendering thread, ideally wrapping each iteration of the render loop. This needs no action from the users of <db:link xlink:href="qrhi.xml">QRhi</db:link> when rendering on the main (gui) thread, but becomes important when a separate, dedicated render thread is used.</db:para>
</db:note>
</db:section>
<db:section xml:id="resource-synchronization">
<db:title>Resource synchronization</db:title>
<db:para><db:link xlink:href="qrhi.xml">QRhi</db:link> does not expose APIs for resource barriers or image layout transitions. Such synchronization is done implicitly by the backends, where applicable (for example, Vulkan), by tracking resource usage as necessary. Buffer and image barriers are inserted before render or compute passes transparently to the application.</db:para>
<db:note>
<db:para>Resources within a render or compute pass are expected to be bound to a single usage during that pass. For example, a buffer can be used as vertex, index, uniform, or storage buffer, but not a combination of them within a single pass. However, it is perfectly fine to use a buffer as a storage buffer in a compute pass, and then as a vertex buffer in a render pass, for example, assuming the buffer declared both usages upon creation.</db:para>
</db:note>
<db:note>
<db:para>Textures have this rule relaxed in certain cases, because using two subresources (typically two different mip levels) of the same texture for different access (one for load, one for store) is supported even within the same pass.</db:para>
</db:note>
</db:section>
<db:section xml:id="resource-reuse">
<db:title>Resource reuse</db:title>
<db:para>From the user's point of view a <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> is reusable immediately after calling QRhiResource::destroy(). With the exception of swapchains, calling <db:code>create()</db:code> on an already created object does an implicit <db:code>destroy()</db:code>. This provides a handy shortcut to reuse a <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> instance with different parameters, with a new native graphics object underneath.</db:para>
<db:para>The importance of reusing the same object lies in the fact that some objects reference other objects: for example, a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> can reference <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link>, <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>, and <db:link xlink:href="qrhisampler.xml">QRhiSampler</db:link> instances. If in a later frame one of these buffers need to be resized or a sampler parameter needs changing, destroying and creating a whole new <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> or <db:link xlink:href="qrhisampler.xml">QRhiSampler</db:link> would invalidate all references to the old instance. By just changing the appropriate parameters via QRhiBuffer::setSize() or similar and then calling QRhiBuffer::create(), everything works as expected and there is no need to touch the <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> at all, even though there is a good chance that under the hood the <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> is now backed by a whole new native buffer.</db:para>
<db:programlisting language="cpp">QRhiBuffer *ubuf = rhi-&gt;newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, 256);
ubuf-&gt;create();

QRhiShaderResourceBindings *srb = rhi-&gt;newShaderResourceBindings()
srb-&gt;setBindings({
    QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage | QRhiShaderResourceBinding::FragmentStage, ubuf)
});
srb-&gt;create();

// ...

// now in a later frame we need to grow the buffer to a larger size
ubuf-&gt;setSize(512);
ubuf-&gt;create(); // same as ubuf-&gt;destroy(); ubuf-&gt;create();

// srb needs no changes whatsoever, any references in it to ubuf
// stay valid. When it comes to internal details, such as that
// ubuf may now be backed by a completely different native buffer
// resource, that is is recognized and handled automatically by the
// next setShaderResources().
</db:programlisting>
<db:para><db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> offers the same contract: calling <db:link xlink:href="qrhicommandbuffer.xml#beginPass">QRhiCommandBuffer::beginPass</db:link>() is safe even when one of the render target's associated textures or renderbuffers has been rebuilt (by calling <db:code>create()</db:code> on it) since the creation of the render target object. This allows the application to resize a texture by setting a new pixel size on the <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> and calling <db:link xlink:href="qrhi.xml#create">create</db:link>(), thus creating a whole new native texture resource underneath, without having to update the <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> as that will be done implicitly in beginPass().</db:para>
</db:section>
<db:section xml:id="pooled-objects">
<db:title>Pooled objects</db:title>
<db:para>In addition to resources, there are pooled objects as well, such as, <db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link>. An instance is retrieved via a <db:code>next</db:code> function, such as, <db:link xlink:href="qrhi.xml#nextResourceUpdateBatch">nextResourceUpdateBatch</db:link>(). The caller does not own the returned instance in this case. The only valid way of operating here is calling functions on the <db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link> and then passing it to <db:link xlink:href="qrhicommandbuffer.xml#beginPass">QRhiCommandBuffer::beginPass</db:link>() or <db:link xlink:href="qrhicommandbuffer.xml#endPass">QRhiCommandBuffer::endPass</db:link>(). These functions take care of returning the batch to the pool. Alternatively, a batch can be &quot;canceled&quot; and returned to the pool without processing by calling <db:link xlink:href="qrhiresourceupdatebatch.xml#release">QRhiResourceUpdateBatch::release</db:link>().</db:para>
<db:para>A typical pattern is thus:</db:para>
<db:programlisting language="cpp">QRhiResourceUpdateBatch *resUpdates = rhi-&gt;nextResourceUpdateBatch();
// ...
resUpdates-&gt;updateDynamicBuffer(ubuf, 0, 64, mvp.constData());
if (!image.isNull()) {
    resUpdates-&gt;uploadTexture(texture, image);
    image = QImage();
}
// ...
QRhiCommandBuffer *cb = m_sc-&gt;currentFrameCommandBuffer();
// note the last argument
cb-&gt;beginPass(swapchain-&gt;currentFrameRenderTarget(), clearCol, clearDs, resUpdates);
</db:programlisting>
</db:section>
<db:section xml:id="swapchain-specifics">
<db:title>Swapchain specifics</db:title>
<db:para><db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link> features some special semantics due to the peculiar nature of swapchains.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>It has no <db:code>create()</db:code> but rather a QRhiSwapChain::createOrResize(). Repeatedly calling this function is <db:emphasis role="bold">not</db:emphasis> the same as calling QRhiSwapChain::destroy() followed by QRhiSwapChain::createOrResize(). This is because swapchains often have ways to handle the case where buffers need to be resized in a manner that is more efficient than a brute force destroying and recreating from scratch.</db:para>
</db:listitem>
<db:listitem>
<db:para>An active <db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link> must be released by calling <db:link xlink:href="">destroy()</db:link>, or by destroying the object, before the <db:link xlink:href="qwindow.xml">QWindow</db:link>'s underlying QPlatformWindow, and so the associated native window object, is destroyed. It should not be postponed because releasing the swapchain may become problematic (and with some APIs, like Vulkan, is explicitly disallowed) when the native window is not around anymore, for example because the QPlatformWindow got destroyed upon getting a <db:link xlink:href="qwindow.xml#close">QWindow::close</db:link>(). Therefore, releasing the swapchain must happen whenever the targeted <db:link xlink:href="qwindow.xml">QWindow</db:link> sends the <db:link xlink:href="qplatformsurfaceevent.xml#SurfaceEventType-enum">QPlatformSurfaceEvent::SurfaceAboutToBeDestroyed</db:link> event. If the event does not arrive before the destruction of the <db:link xlink:href="qwindow.xml">QWindow</db:link> - this can happen when using <db:link xlink:href="qcoreapplication.xml#quit">QCoreApplication::quit</db:link>() -, then check QWindow::handle() after the event loop exits and invoke the swapchain release when non-null (meaning the underlying native window is still around).</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="ownership">
<db:title>Ownership</db:title>
<db:para>The general rule is no ownership transfer. Creating a <db:link xlink:href="qrhi.xml">QRhi</db:link> with an already existing graphics device does not mean the <db:link xlink:href="qrhi.xml">QRhi</db:link> takes ownership of the device object. Similarly, ownership is not given away when a device or texture object is &quot;exported&quot; via <db:link xlink:href="qrhi.xml#nativeHandles">QRhi::nativeHandles</db:link>() or <db:link xlink:href="qrhitexture.xml#nativeTexture">QRhiTexture::nativeTexture</db:link>(). Most importantly, passing pointers in structs and via setters does not transfer ownership.</db:para>
</db:section>
</db:section>
<db:section xml:id="troubleshooting-and-profiling">
<db:title>Troubleshooting and Profiling</db:title>
<db:section xml:id="error-reporting">
<db:title>Error reporting</db:title>
<db:para>Functions such as <db:link xlink:href="qrhi.xml#create">QRhi::create</db:link>() and the resource classes' <db:code>create()</db:code> member functions (e.g., <db:link xlink:href="">QRhiBuffer::create()</db:link>) indicate failure with the return value (<db:code>nullptr</db:code> or <db:code>false</db:code>, respectively). When working with <db:link xlink:href="qshader.xml">QShader</db:link>, <db:link xlink:href="qshader.xml#fromSerialized">QShader::fromSerialized</db:link>() returns an invalid <db:link xlink:href="qshader.xml">QShader</db:link> (for which <db:link xlink:href="qshader.xml#isValid">isValid</db:link>() returns <db:code>false</db:code>) when the data passed to the function cannot be successfully deserialized. Some functions, <db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>() in particular, may also sometimes report &quot;soft failures&quot;, such as <db:link xlink:href="qrhi.xml#FrameOpResult-enum">FrameOpSwapChainOutOfDate</db:link>, which do not indicate an unrecoverable error, but rather should be seen as a &quot;try again later&quot; response.</db:para>
<db:para>Warnings and errors may get printed at any time to the debug output via <db:link xlink:href="qtlogging.xml#qWarning">qWarning</db:link>(). It is therefore always advisable to inspect the output of the application.</db:para>
<db:para>Additional debug messages can be enabled via the following logging categories. Messages from these categories are not printed by default unless explicitly enabled via <db:link xlink:href="qloggingcategory.xml">QLoggingCategory</db:link> or the <db:code>QT_LOGGING_RULES</db:code> environment variable. For better interoperation with Qt Quick, the environment variable <db:code>QSG_INFO</db:code> also enables these debug prints.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>qt.rhi.general</db:code></db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Additionally, applications can query the <db:link xlink:href="qrhi.xml#backendName">QRhi backend name</db:link> and <db:link xlink:href="qrhi.xml#driverInfo">graphics device information</db:link> from a successfully initialized <db:link xlink:href="qrhi.xml">QRhi</db:link>. This can then be printed to the user or stored in the application logs even in production builds, if desired.</db:para>
</db:section>
<db:section xml:id="investigating-rendering-problems">
<db:title>Investigating rendering problems</db:title>
<db:para>When the rendering results are not as expected, or the application is experiencing problems, always consider checking with the the native 3D APIs' debug and validation facilities. <db:link xlink:href="qrhi.xml">QRhi</db:link> itself features limited error checking since replicating the already existing, vast amount of functionality in the underlying layers is not reasonable.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>For Vulkan, controlling the <db:link xlink:href="https://github.com/KhronosGroup/Vulkan-ValidationLayers">Vulkan Validation Layers</db:link> is not in the scope of the <db:link xlink:href="qrhi.xml">QRhi</db:link>, but rather can be achieved by configuring the <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> with the appropriate layers. For example, call <db:code>instance.setLayers({ &quot;VK_LAYER_KHRONOS_validation&quot; });</db:code> before invoking <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() on the <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link>. (note that this assumes that the validation layers are actually installed and available, e.g. from the Vulkan SDK) By default, <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> conveniently redirects the Vulkan debug messages to <db:link xlink:href="qtlogging.xml#qDebug">qDebug</db:link>, meaning the validation messages get printed just like other Qt warnings.</db:para>
</db:listitem>
<db:listitem>
<db:para>With Direct 3D 11 and 12, a graphics device with the debug layer enabled can be requested by toggling the <db:code>enableDebugLayer</db:code> flag in the appropriate <db:link xlink:href="qrhid3d11initparams.xml">init params struct</db:link>. The messages appear on the debug output, which is visible in Qt Creator's messages panel or via a tool such as <db:link xlink:href="https://learn.microsoft.com/en-us/sysinternals/downloads/debugview">DebugView</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>For Metal, controlling Metal Validation is outside of <db:link xlink:href="qrhi.xml">QRhi</db:link>'s scope. Rather, to enable validation, run the application with the environment variable <db:code>METAL_DEVICE_WRAPPER_TYPE=1</db:code> set, or run the application within XCode. There may also be further settings and environment variable in modern XCode and macOS versions. See for instance <db:link xlink:href="https://developer.apple.com/documentation/metal/diagnosing_metal_programming_issues_early">this page</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="frame-captures-and-performance-profiling">
<db:title>Frame captures and performance profiling</db:title>
<db:para>A Qt application rendering with <db:link xlink:href="qrhi.xml">QRhi</db:link> to a window while relying on a 3D API under the hood, is, from the windowing and graphics pipeline perspective at least, no different from any other (non-Qt) applications using the same 3D API. This means that tools and practices for debugging and profiling applications involving 3D graphics, such as games, all apply to such a Qt application as well.</db:para>
<db:para>A few examples of tools that can provide insights into the rendering internals of Qt applications that use <db:link xlink:href="qrhi.xml">QRhi</db:link>, which includes Qt Quick and Qt Quick 3D based projects as well:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="https://renderdoc.org/">RenderDoc</db:link> allows taking frame captures and introspecting the recorded commands and pipeline state on Windows and Linux for applications using OpenGL, Vulkan, D3D11, or D3D12. When trying to figure out why some parts of the 3D scene do not show up as expected, RenderDoc is often a fast and efficient way to check the pipeline stages and the related state and discover the missing or incorrect value. It is also a tool that is actively used when developing Qt itself.</db:para>
</db:listitem>
<db:listitem>
<db:para>For NVIDIA-based systems, <db:link xlink:href="https://developer.nvidia.com/nsight-graphics">Nsight Graphics</db:link> provides a graphics debugger tool on Windows and Linux. In addition to investigating the commands in the frame and the pipeline, the vendor-specific tools allow looking at timings and hardware performance information, which is not something simple frame captures can provide.</db:para>
</db:listitem>
<db:listitem>
<db:para>For AMD-based systems, the <db:link xlink:href="https://gpuopen.com/rgp/">Radeon GPU Profiler</db:link> can be used to gain deeper insights into the application's rendering and its performance.</db:para>
</db:listitem>
<db:listitem>
<db:para>As <db:link xlink:href="qrhi.xml">QRhi</db:link> supports Direct 3D 12, using <db:link xlink:href="https://devblogs.microsoft.com/pix/download/">PIX</db:link>, a performance tuning and debugging tool for DirectX 12 games on Windows is an option as well.</db:para>
</db:listitem>
<db:listitem>
<db:para>On macOS, <db:link xlink:href="https://developer.apple.com/documentation/metal/debugging_tools/viewing_your_gpu_workload_with_the_metal_debugger">the XCode Metal debugger</db:link> can be used to take and introspect frame captures, to investigate performance details, and debug shaders. In macOS 13 it is also possible to enable an overlay that displays frame rate and other information for any Metal-based window by setting the environment variable <db:code>MTL_HUD_ENABLED=1</db:code>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>On mobile and embedded platforms, there may be vendor and platform-specific tools, provided by the GPU or SoC vendor, available to perform performance profiling of application using OpenGL ES or Vulkan.</db:para>
<db:para>When capturing frames, remember that objects and groups of commands can be named via debug markers, as long as <db:link xlink:href="qrhi.xml#Flag-enum">debug markers were enabled</db:link> for the <db:link xlink:href="qrhi.xml">QRhi</db:link>, and the graphics API in use supports this. To annotate the command stream, call <db:link xlink:href="qrhicommandbuffer.xml#debugMarkBegin">debugMarkBegin</db:link>(), <db:link xlink:href="qrhicommandbuffer.xml#debugMarkEnd">debugMarkEnd</db:link>() and/or <db:link xlink:href="qrhicommandbuffer.xml#debugMarkMsg">debugMarkMsg</db:link>(). This can be particularly useful in larger frames with multiple render passes. Resources are named by calling <db:link xlink:href="qrhiresource.xml#setName">setName</db:link>() before <db:link xlink:href="qrhi.xml#create">create</db:link>().</db:para>
<db:para>To perform basic timing measurements on the CPU and GPU side within the application, <db:link xlink:href="qelapsedtimer.xml">QElapsedTimer</db:link> and <db:link xlink:href="qrhicommandbuffer.xml#lastCompletedGpuTime">QRhiCommandBuffer::lastCompletedGpuTime</db:link>() can be used. The latter is only available with select graphics APIs at the moment and requires opting in via the <db:link xlink:href="qrhi.xml#Flag-enum">QRhi::EnableTimestamps</db:link> flag.</db:para>
</db:section>
<db:section xml:id="resource-leak-checking">
<db:title>Resource leak checking</db:title>
<db:para>When destroying a <db:link xlink:href="qrhi.xml">QRhi</db:link> object without properly destroying all buffers, textures, and other resources created from it, warnings about this are printed to the debug output whenever the application is a debug build, or when the <db:code>QT_RHI_LEAK_CHECK</db:code> environment variable is set to a non-zero value. This is a simple way to discover design issues around resource handling within the application rendering logic. Note however that some platforms and underlying graphics APIs may perform their own allocation and resource leak detection as well, over which Qt will have no direct control. For example, when using Vulkan, the memory allocator may raise failing assertions in debug builds when resources that own graphics memory allocations are not destroyed before the <db:link xlink:href="qrhi.xml">QRhi</db:link>. In addition, the Vulkan validation layer, when enabled, will issue warnings about native graphics resources that were not released. Similarly, with Direct 3D warnings may get printed about unreleased COM objects when the application does not destroy the <db:link xlink:href="qrhi.xml">QRhi</db:link> and its resources in the correct order.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtgui-rhiwindow-example.xml">RHI Window Example</db:link></db:member>
<db:member><db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link></db:member>
<db:member><db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link></db:member>
<db:member><db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link></db:member>
<db:member><db:link xlink:href="qshader.xml">QShader</db:link></db:member>
<db:member><db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link></db:member>
<db:member><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:member>
<db:member><db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link></db:member>
<db:member><db:link xlink:href="qrhisampler.xml">QRhiSampler</db:link></db:member>
<db:member><db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link></db:member>
<db:member><db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link></db:member>
<db:member><db:link xlink:href="qrhicomputepipeline.xml">QRhiComputePipeline</db:link></db:member>
<db:member><db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="BeginFrameFlag-enum">
<db:title>enum QRhi::BeginFrameFlag</db:title>
<db:bridgehead renderas="sect2">flags QRhi::BeginFrameFlags</db:bridgehead>
<db:para>Flag values for <db:link xlink:href="qrhi.xml#beginFrame">QRhi::beginFrame</db:link>()</db:para>
<db:para>The <db:code>BeginFrameFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;BeginFrameFlag&gt;. </db:code>It stores an OR combination of <db:code>BeginFrameFlag</db:code> values.</db:para>
</db:section>
<db:section xml:id="EndFrameFlag-enum">
<db:title>enum QRhi::EndFrameFlag</db:title>
<db:bridgehead renderas="sect2">flags QRhi::EndFrameFlags</db:bridgehead>
<db:para>Flag values for <db:link xlink:href="qrhi.xml#endFrame">QRhi::endFrame</db:link>()</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::SkipPresent</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 0</db:code></db:td>
<db:td>
<db:para>Specifies that no present command is to be queued or no swapBuffers call is to be made. This way no image is presented. Generating multiple frames with all having this flag set is not recommended (except, for example, for benchmarking purposes - but keep in mind that backends may behave differently when it comes to waiting for command completion without presenting so the results are not comparable between them)</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>EndFrameFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;EndFrameFlag&gt;. </db:code>It stores an OR combination of <db:code>EndFrameFlag</db:code> values.</db:para>
</db:section>
<db:section xml:id="Feature-enum">
<db:title>enum QRhi::Feature</db:title>
<db:para>Flag values to indicate what features are supported by the backend currently in use.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MultisampleTexture</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Indicates that textures with a sample count larger than 1 are supported. In practice this feature will be unsupported with OpenGL ES versions older than 3.1, and OpenGL older than 3.0.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MultisampleRenderBuffer</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Indicates that renderbuffers with a sample count larger than 1 are supported. In practice this feature will be unsupported with OpenGL ES 2.0, and may also be unsupported with OpenGL 2.x unless the relevant extensions are present.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::DebugMarkers</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>Indicates that debug marker groups (and so <db:link xlink:href="qrhicommandbuffer.xml#debugMarkBegin">QRhiCommandBuffer::debugMarkBegin</db:link>()) are supported.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::Timestamps</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>Indicates that command buffer timestamps are supported. Relevant for <db:link xlink:href="qrhicommandbuffer.xml#lastCompletedGpuTime">QRhiCommandBuffer::lastCompletedGpuTime</db:link>(). This can be expected to be supported on Metal, Vulkan, Direct 3D 11 and 12, and OpenGL contexts of version 3.3 or newer. However, with some of these APIs support for timestamp queries is technically optional, and therefore it cannot be guaranteed that this feature is always supported with every implementation of them.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::Instancing</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>Indicates that instanced drawing is supported. In practice this feature will be unsupported with OpenGL ES 2.0 and OpenGL 3.2 or older.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::CustomInstanceStepRate</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>Indicates that instance step rates other than 1 are supported. In practice this feature will always be unsupported with OpenGL. In addition, running with Vulkan 1.0 without VK_EXT_vertex_attribute_divisor will also lead to reporting false for this feature.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::PrimitiveRestart</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>Indicates that restarting the assembly of primitives when encountering an index value of 0xFFFF (<db:link xlink:href="qrhicommandbuffer.xml#IndexFormat-enum">IndexUInt16</db:link>) or 0xFFFFFFFF (<db:link xlink:href="qrhicommandbuffer.xml#IndexFormat-enum">IndexUInt32</db:link>) is enabled, for certain primitive topologies at least. <db:link xlink:href="qrhi.xml">QRhi</db:link> will try to enable this with all backends, but in some cases it will not be supported. Dynamically controlling primitive restart is not possible since with some APIs primitive restart with a fixed index is always on. Applications must assume that whenever this feature is reported as supported, the above mentioned index values <db:code>may</db:code> be treated specially, depending on the topology. The only two topologies where primitive restart is guaranteed to behave identically across backends, as long as this feature is reported as supported, are <db:link xlink:href="qrhigraphicspipeline.xml#Topology-enum">LineStrip</db:link> and <db:link xlink:href="qrhigraphicspipeline.xml#Topology-enum">TriangleStrip</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::NonDynamicUniformBuffers</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>Indicates that creating buffers with the usage <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">UniformBuffer</db:link> and the types <db:link xlink:href="qrhibuffer.xml#Type-enum">Immutable</db:link> or <db:link xlink:href="qrhibuffer.xml#Type-enum">Static</db:link> is supported. When reported as unsupported, uniform (constant) buffers must be created as <db:link xlink:href="qrhibuffer.xml#Type-enum">Dynamic</db:link>. (which is recommended regardless)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::NonFourAlignedEffectiveIndexBufferOffset</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>Indicates that effective index buffer offsets (<db:code>indexOffset + firstIndex * indexComponentSize</db:code>) that are not 4 byte aligned are supported. When not supported, attempting to issue a <db:link xlink:href="qrhicommandbuffer.xml#drawIndexed">drawIndexed</db:link>() with a non-aligned effective offset may lead to unspecified behavior. Relevant in particular for Metal, where this will be reported as unsupported.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::NPOTTextureRepeat</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>Indicates that the <db:link xlink:href="qrhisampler.xml#AddressMode-enum">Repeat</db:link> wrap mode and mipmap filtering modes are supported for textures with a non-power-of-two size. In practice this can only be false with OpenGL ES 2.0 implementations without <db:code>GL_OES_texture_npot</db:code>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::RedOrAlpha8IsRed</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>Indicates that the <db:link xlink:href="qrhitexture.xml#Format-enum">RED_OR_ALPHA8</db:link> format maps to a one component 8-bit <db:code>red</db:code> format. This is the case for all backends except OpenGL when using either OpenGL ES or a non-core profile context. There <db:code>GL_ALPHA</db:code>, a one component 8-bit <db:code>alpha</db:code> format, is used instead. Using the special texture format allows having a single code path for creating textures, leaving it up to the backend to decide the actual format, while the feature flag can be used to pick the appropriate shader variant for sampling the texture.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::ElementIndexUint</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>Indicates that 32-bit unsigned integer elements are supported in the index buffer. In practice this is true everywhere except when running on plain OpenGL ES 2.0 implementations without the necessary extension. When false, only 16-bit unsigned elements are supported in the index buffer.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::Compute</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>Indicates that compute shaders, image load/store, and storage buffers are supported. OpenGL older than 4.3 and OpenGL ES older than 3.1 have no compute support.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::WideLines</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>Indicates that lines with a width other than 1 are supported. When reported as not supported, the line width set on the graphics pipeline state is ignored. This can always be false with some backends (D3D11, D3D12, Metal). With Vulkan, the value depends on the implementation. With OpenGL, wide lines are not supported in core profile contexts.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::VertexShaderPointSize</db:code></db:para>
</db:td>
<db:td><db:code>15</db:code></db:td>
<db:td>
<db:para>Indicates that the size of rasterized points set via <db:code>gl_PointSize</db:code> in the vertex shader is taken into account. When reported as not supported, drawing points with a size other than 1 is not supported. Setting <db:code>gl_PointSize</db:code> in the shader is still valid then, but is ignored. (for example, when generating HLSL, the assignment is silently dropped from the generated code) Note that some APIs (Metal, Vulkan) require the point size to be set in the shader explicitly whenever drawing points, even when the size is 1, as they do not automatically default to 1.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::BaseVertex</db:code></db:para>
</db:td>
<db:td><db:code>16</db:code></db:td>
<db:td>
<db:para>Indicates that <db:link xlink:href="qrhicommandbuffer.xml#drawIndexed">drawIndexed</db:link>() supports the <db:code>vertexOffset</db:code> argument. When reported as not supported, the vertexOffset value in an indexed draw is ignored. In practice this feature will be unsupported with OpenGL and OpenGL ES versions lower than 3.2, and with Metal on older iOS devices, including the iOS Simulator.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::BaseInstance</db:code></db:para>
</db:td>
<db:td><db:code>17</db:code></db:td>
<db:td>
<db:para>Indicates that instanced draw commands support the <db:code>firstInstance</db:code> argument. When reported as not supported, the firstInstance value is ignored and the instance ID starts from 0. In practice this feature will be unsupported with OpenGL, and with Metal on older iOS devices, including the iOS Simulator.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::TriangleFanTopology</db:code></db:para>
</db:td>
<db:td><db:code>18</db:code></db:td>
<db:td>
<db:para>Indicates that QRhiGraphicsPipeline::setTopology() supports <db:link xlink:href="qrhigraphicspipeline.xml#Topology-enum">QRhiGraphicsPipeline::TriangleFan</db:link>. In practice this feature will be unsupported with Metal and Direct 3D 11/12.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::ReadBackNonUniformBuffer</db:code></db:para>
</db:td>
<db:td><db:code>19</db:code></db:td>
<db:td>
<db:para>Indicates that <db:link xlink:href="qrhiresourceupdatebatch.xml#readBackBuffer">reading buffer contents</db:link> is supported for <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> instances with a usage different than UniformBuffer. In practice this feature will be unsupported with OpenGL ES 2.0.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::ReadBackNonBaseMipLevel</db:code></db:para>
</db:td>
<db:td><db:code>20</db:code></db:td>
<db:td>
<db:para>Indicates that specifying a mip level other than 0 is supported when reading back texture contents. When not supported, specifying a non-zero level in <db:link xlink:href="qrhireadbackdescription.xml">QRhiReadbackDescription</db:link> leads to returning an all-zero image. In practice this feature will be unsupported with OpenGL ES 2.0.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::TexelFetch</db:code></db:para>
</db:td>
<db:td><db:code>21</db:code></db:td>
<db:td>
<db:para>Indicates that texelFetch() and textureLod() are available in shaders. In practice this will be reported as unsupported with OpenGL ES 2.0 and OpenGL 2.x contexts, because GLSL 100 es and versions before 130 do not support these functions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::RenderToNonBaseMipLevel</db:code></db:para>
</db:td>
<db:td><db:code>22</db:code></db:td>
<db:td>
<db:para>Indicates that specifying a mip level other than 0 is supported when creating a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> with a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> as its color attachment. When not supported, <db:link xlink:href="qrhi.xml#create">create</db:link>() will fail whenever the target mip level is not zero. In practice this feature will be unsupported with OpenGL ES 2.0.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::IntAttributes</db:code></db:para>
</db:td>
<db:td><db:code>23</db:code></db:td>
<db:td>
<db:para>Indicates that specifying input attributes with signed and unsigned integer types for a shader pipeline is supported. When not supported, build() will succeed but just show a warning message and the values of the target attributes will be broken. In practice this feature will be unsupported with OpenGL ES 2.0 and OpenGL 2.x.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::ScreenSpaceDerivatives</db:code></db:para>
</db:td>
<db:td><db:code>24</db:code></db:td>
<db:td>
<db:para>Indicates that functions such as dFdx(), dFdy(), and fwidth() are supported in shaders. In practice this feature will be unsupported with OpenGL ES 2.0 without the GL_OES_standard_derivatives extension.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::ReadBackAnyTextureFormat</db:code></db:para>
</db:td>
<db:td><db:code>25</db:code></db:td>
<db:td>
<db:para>Indicates that reading back texture contents can be expected to work for any <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::Format</db:link>. Backends other than OpenGL can be expected to return true for this feature. When reported as false, which will typically happen with OpenGL, only the formats <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::RGBA8</db:link> and <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::BGRA8</db:link> are guaranteed to be supported for readbacks. In addition, with OpenGL, but not OpenGL ES, reading back the 1 byte per component formats <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::R8</db:link> and <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::RED_OR_ALPHA8</db:link> are supported as well. Reading back floating point formats <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::RGBA16F</db:link> and RGBA32F may work too with OpenGL, as long as the implementation provides support for these, but <db:link xlink:href="qrhi.xml">QRhi</db:link> can give no guarantees, as indicated by this flag.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::PipelineCacheDataLoadSave</db:code></db:para>
</db:td>
<db:td><db:code>26</db:code></db:td>
<db:td>
<db:para>Indicates that the <db:link xlink:href="qrhi.xml#pipelineCacheData">pipelineCacheData</db:link>() and <db:link xlink:href="qrhi.xml#setPipelineCacheData">setPipelineCacheData</db:link>() functions are functional. When not supported, the functions will not perform any action, the retrieved blob is always empty, and thus no benefits can be expected from retrieving and, during a subsequent run of the application, reloading the pipeline cache content.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::ImageDataStride</db:code></db:para>
</db:td>
<db:td><db:code>27</db:code></db:td>
<db:td>
<db:para>Indicates that specifying a custom stride (row length) for raw image data in texture uploads is supported. When not supported (which can happen when the underlying API is OpenGL ES 2.0 without support for GL_UNPACK_ROW_LENGTH), QRhiTextureSubresourceUploadDescription::setDataStride() must not be used.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::RenderBufferImport</db:code></db:para>
</db:td>
<db:td><db:code>28</db:code></db:td>
<db:td>
<db:para>Indicates that <db:link xlink:href="qrhirenderbuffer.xml#createFrom">QRhiRenderBuffer::createFrom</db:link>() is supported. For most graphics APIs this is not sensible because <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> encapsulates texture objects internally, just like <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>. With OpenGL however, renderbuffer object exist as a separate object type in the API, and in certain environments (for example, where one may want to associated a renderbuffer object with an EGLImage object) it is important to allow wrapping an existing OpenGL renderbuffer object with a <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::ThreeDimensionalTextures</db:code></db:para>
</db:td>
<db:td><db:code>29</db:code></db:td>
<db:td>
<db:para>Indicates that 3D textures are supported. In practice this feature will be unsupported with OpenGL and OpenGL ES versions lower than 3.0.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::RenderTo3DTextureSlice</db:code></db:para>
</db:td>
<db:td><db:code>30</db:code></db:td>
<db:td>
<db:para>Indicates that rendering to a slice in a 3D texture is supported. This can be unsupported with Vulkan 1.0 due to relying on VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT which is a Vulkan 1.1 feature.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::TextureArrays</db:code></db:para>
</db:td>
<db:td><db:code>31</db:code></db:td>
<db:td>
<db:para>Indicates that texture arrays are supported and <db:link xlink:href="qrhi.xml#newTextureArray">QRhi::newTextureArray</db:link>() is functional. Note that even when texture arrays are not supported, arrays of textures are still available as those are two independent features.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::Tessellation</db:code></db:para>
</db:td>
<db:td><db:code>32</db:code></db:td>
<db:td>
<db:para>Indicates that the tessellation control and evaluation stages are supported. When reported as supported, the topology of a <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> can be set to <db:link xlink:href="qrhigraphicspipeline.xml#Topology-enum">Patches</db:link>, the number of control points can be set via <db:link xlink:href="">setPatchControlPointCount()</db:link>, and shaders for tessellation control and evaluation can be specified in the <db:link xlink:href="qrhishaderstage.xml">QRhiShaderStage</db:link> list. Tessellation shaders have portability issues between APIs (for example, translating GLSL/SPIR-V to HLSL is problematic due to the way hull shaders are structured, whereas Metal uses a somewhat different tessellation pipeline than others), and therefore unexpected issues may still arise, even though basic functionality is implemented across all the underlying APIs. For Direct 3D in particular, handwritten HLSL hull and domain shaders must be injected into each <db:link xlink:href="qshader.xml">QShader</db:link> for the tessellation control and evaluation stages, respectively, since qsb cannot generate these from SPIR-V. Note that isoline tessellation should be avoided as it will not be supported by all backends. The maximum patch control point count portable between backends is 32.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::GeometryShader</db:code></db:para>
</db:td>
<db:td><db:code>33</db:code></db:td>
<db:td>
<db:para>Indicates that the geometry shader stage is supported. When supported, a geometry shader can be specified in the <db:link xlink:href="qrhishaderstage.xml">QRhiShaderStage</db:link> list. Geometry Shaders are considered an experimental feature in <db:link xlink:href="qrhi.xml">QRhi</db:link> and can only be expected to be supported with Vulkan, Direct 3D, OpenGL (3.2+) and OpenGL ES (3.2+), assuming the implementation reports it as supported at run time. Geometry shaders have portability issues between APIs, and therefore no guarantees can be given for a universal solution. They will never be supported with Metal. Whereas with Direct 3D a handwritten HLSL geometry shader must be injected into each <db:link xlink:href="qshader.xml">QShader</db:link> for the geometry stage since qsb cannot generate this from SPIR-V.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::TextureArrayRange</db:code></db:para>
</db:td>
<db:td><db:code>34</db:code></db:td>
<db:td>
<db:para>Indicates that for <db:link xlink:href="qrhi.xml#newTextureArray">texture arrays</db:link> it is possible to specify a range that is exposed to the shaders. Normally all array layers are exposed and it is up to the shader to select the layer (via the third coordinate passed to texture() when sampling the <db:code>sampler2DArray</db:code>). When supported, calling QRhiTexture::setArrayRangeStart() and QRhiTexture::setArrayRangeLength() before building or <db:link xlink:href="qrhitexture.xml#createFrom">importing</db:link> the native texture has an effect, and leads to selecting only the specified range from the array. This will be necessary in special cases, such as when working with accelerated video decoding and Direct 3D 11, because a texture array with both <db:code>D3D11_BIND_DECODER</db:code> and <db:code>D3D11_BIND_SHADER_RESOURCE</db:code> on it is only usable as a shader resource if a single array layer is selected. Note that all this is applicable only when the texture is used as a <db:link xlink:href="qrhishaderresourcebinding.xml#Type-enum">QRhiShaderResourceBinding::SampledTexture</db:link> or <db:link xlink:href="qrhishaderresourcebinding.xml#Type-enum">QRhiShaderResourceBinding::Texture</db:link> shader resource, and is not compatible with image load/store. This feature is only available with some backends as it does not map well to all graphics APIs, and it is only meant to provide support for special cases anyhow. In practice the feature can be expected to be supported with Direct3D 11/12 and Vulkan.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::NonFillPolygonMode</db:code></db:para>
</db:td>
<db:td><db:code>35</db:code></db:td>
<db:td>
<db:para>Indicates that setting a PolygonMode other than the default Fill is supported for <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link>. A common use case for changing the mode to Line is to get wireframe rendering. This however is not available as a core OpenGL ES feature, and is optional with Vulkan as well as some mobile GPUs may not offer the feature.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::OneDimensionalTextures</db:code></db:para>
</db:td>
<db:td><db:code>36</db:code></db:td>
<db:td>
<db:para>Indicates that 1D textures are supported. In practice this feature will be unsupported on OpenGL ES.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::OneDimensionalTextureMipmaps</db:code></db:para>
</db:td>
<db:td><db:code>37</db:code></db:td>
<db:td>
<db:para>Indicates that generating 1D texture mipmaps are supported. In practice this feature will be unsupported on backends that do not report support for OneDimensionalTextures, Metal, and Direct 3D 12.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::HalfAttributes</db:code></db:para>
</db:td>
<db:td><db:code>38</db:code></db:td>
<db:td>
<db:para>Indicates that specifying input attributes with half precision (16bit) floating point types for a shader pipeline is supported. When not supported, build() will succeed but just show a warning message and the values of the target attributes will be broken. In practice this feature will be unsupported in some OpenGL ES 2.0 and OpenGL 2.x implementations. Note that while Direct3D 11/12 does support half precision input attributes, it does not support the half3 type. The D3D backends pass half3 attributes as half4. To ensure cross platform compatibility, half3 inputs should be padded to 8 bytes.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::RenderToOneDimensionalTexture</db:code></db:para>
</db:td>
<db:td><db:code>39</db:code></db:td>
<db:td>
<db:para>Indicates that 1D texture render targets are supported. In practice this feature will be unsupported on backends that do not report support for OneDimensionalTextures, and Metal.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::ThreeDimensionalTextureMipmaps</db:code></db:para>
</db:td>
<db:td><db:code>40</db:code></db:td>
<db:td>
<db:para>Indicates that generating 3D texture mipmaps are supported. In practice this feature will be unsupported with Direct 3D 12.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MultiView</db:code></db:para>
</db:td>
<db:td><db:code>41</db:code></db:td>
<db:td>
<db:para>Indicates that multiview, see e.g. <db:link xlink:href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_multiview.html">VK_KHR_multiview</db:link> is supported. With OpenGL ES 2.0, Direct 3D 11, and OpenGL (ES) implementations without <db:code>GL_OVR_multiview2</db:code> this feature will not be supported. With Vulkan 1.1 and newer, and Direct 3D 12 multiview is typically supported. When reported as supported, creating a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> with a <db:link xlink:href="qrhicolorattachment.xml">QRhiColorAttachment</db:link> that references a texture array and has multiViewCount set enables recording a render pass that uses multiview rendering. In addition, any <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> used in that render pass must have <db:link xlink:href="">the same view count set</db:link>. Note that multiview is only available in combination with 2D texture arrays. It cannot be used to optimize the rendering into individual textures (e.g. two, for the left and right eyes). Rather, the target of a multiview render pass is always a texture array, automatically rendering to the layer (array element) corresponding to each view. Therefore this feature implies TextureArrays as well. Multiview rendering is not supported in combination with tessellation or geometry shaders. See QRhiColorAttachment::setMultiViewCount() for further details on multiview rendering. This enum value has been introduced in Qt 6.7.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::TextureViewFormat</db:code></db:para>
</db:td>
<db:td><db:code>42</db:code></db:td>
<db:td>
<db:para>Indicates that setting a <db:link xlink:href="">view format</db:link> on a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> is effective. When reported as supported, setting the read (sampling) or write (render target / image load-store) view mode changes the texture's viewing format. When unsupported, setting a view format has no effect. Note that Qt has no knowledge or control over format compatibility or resource view rules in the underlying 3D API and its implementation. Passing in unsuitable, incompatible formats may lead to errors and unspecified behavior. This is provided mainly to allow &quot;casting&quot; rendering into a texture created with an sRGB format to non-sRGB to avoid the unwanted linear-&gt;sRGB conversion on shader writes. Other types of casting may or may not be functional, depending on the underlying API. Currently implemented for Vulkan and Direct 3D 12. With D3D12 the feature is available only if <db:code>CastingFullyTypedFormatSupported</db:code> is supported, see <db:link xlink:href="https://microsoft.github.io/DirectX-Specs/d3d/RelaxedCasting.html">https://microsoft.github.io/DirectX-Specs/d3d/RelaxedCasting.html</db:link> (and note that <db:link xlink:href="qrhi.xml">QRhi</db:link> always uses fully typed formats for textures.) This enum value has been introduced in Qt 6.8.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::ResolveDepthStencil</db:code></db:para>
</db:td>
<db:td><db:code>43</db:code></db:td>
<db:td>
<db:para>Indicates that resolving a multisample depth or depth-stencil texture is supported. Otherwise, <db:link xlink:href="">setting a depth resolve texture</db:link> is not functional and must be avoided. Direct 3D 11 and 12 have no support for resolving depth/depth-stencil formats, and therefore this feature will never be supported with those. Vulkan 1.0 has no API to request resolving a depth-stencil attachment. Therefore, with Vulkan this feature will only be supported with Vulkan 1.2 and up, and on 1.1 implementations with the appropriate extensions present. This feature is provided for the rare case when resolving into a non-multisample depth texture becomes necessary, for example when rendering into an OpenXR-provided depth texture (XR_KHR_composition_layer_depth). This enum value has been introduced in Qt 6.8.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="Flag-enum">
<db:title>enum QRhi::Flag</db:title>
<db:bridgehead renderas="sect2">flags QRhi::Flags</db:bridgehead>
<db:para>Describes what special features to enable.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::EnableDebugMarkers</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 0</db:code></db:td>
<db:td>
<db:para>Enables debug marker groups. Without this frame debugging features like making debug groups and custom resource name visible in external GPU debugging tools will not be available and functions like <db:link xlink:href="qrhicommandbuffer.xml#debugMarkBegin">QRhiCommandBuffer::debugMarkBegin</db:link>() will become no-ops. Avoid enabling in production builds as it may involve a small performance impact. Has no effect when the <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::DebugMarkers</db:link> feature is not reported as supported.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::EnableTimestamps</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 3</db:code></db:td>
<db:td>
<db:para>Enables GPU timestamp collection. When not set, <db:link xlink:href="qrhicommandbuffer.xml#lastCompletedGpuTime">QRhiCommandBuffer::lastCompletedGpuTime</db:link>() always returns 0. Enable this only when needed since there may be a small amount of extra work involved (e.g. timestamp queries), depending on the underlying graphics API. Has no effect when the <db:link xlink:href="qrhi.xml#Feature-enum">QRhi::Timestamps</db:link> feature is not reported as supported.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::PreferSoftwareRenderer</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 1</db:code></db:td>
<db:td>
<db:para>Indicates that backends should prefer choosing an adapter or physical device that renders in software on the CPU. For example, with Direct3D there is typically a &quot;Basic Render Driver&quot; adapter available with <db:code>DXGI_ADAPTER_FLAG_SOFTWARE</db:code>. Setting this flag requests the backend to choose that adapter over any other, as long as no specific adapter was forced by other backend-specific means. With Vulkan this maps to preferring physical devices with <db:code>VK_PHYSICAL_DEVICE_TYPE_CPU</db:code>. When not available, or when it is not possible to decide if an adapter/device is software-based, this flag is ignored. It may also be ignored with graphics APIs that have no concept and means of enumerating adapters/devices.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::EnablePipelineCacheDataSave</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 2</db:code></db:td>
<db:td>
<db:para>Enables retrieving the pipeline cache contents, where applicable. When not set, <db:link xlink:href="qrhi.xml#pipelineCacheData">pipelineCacheData</db:link>() will return an empty blob always. With backends where retrieving and restoring the pipeline cache contents is not supported, the flag has no effect and the serialized cache data is always empty. The flag provides an opt-in mechanism because the cost of maintaining the related data structures is not insignificant with some backends. With Vulkan this feature maps directly to VkPipelineCache, vkGetPipelineCacheData and VkPipelineCacheCreateInfo::pInitialData. With Direct3D 11 there is no real pipline cache, but the results of HLSL-&gt;DXBC compilations are stored and can be serialized/deserialized via this mechanism. This allows skipping the time consuming D3DCompile() in future runs of the applications for shaders that come with HLSL source instead of offline pre-compiled bytecode. This can provide a huge boost in startup and load times, if there is a lot of HLSL source compilation happening. With OpenGL the &quot;pipeline cache&quot; is simulated by retrieving and loading shader program binaries (if supported by the driver). With OpenGL there are additional, disk-based caching mechanisms for shader/program binaries provided by Qt. Writing to those may get disabled whenever this flag is set since storing program binaries to multiple caches is not sensible.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::SuppressSmokeTestWarnings</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 4</db:code></db:td>
<db:td>
<db:para>Indicates that, with backends where this is relevant, certain, non-fatal <db:link xlink:href="qrhi.xml#create">QRhi::create</db:link>() failures should not produce <db:link xlink:href="qtlogging.xml#qWarning">qWarning</db:link>() calls. For example, with D3D11, passing this flag makes a number of warning messages (that appear due to <db:link xlink:href="qrhi.xml#create">QRhi::create</db:link>() failing) to become categorized debug prints instead under the commonly used <db:code>qt.rhi.general</db:code> logging category. This can be used by engines, such as Qt Quick, that feature fallback logic, i.e. they retry calling <db:link xlink:href="qrhi.xml#create">create</db:link>() with a different set of flags (such as, PreferSoftwareRenderer), in order to hide the unconditional warnings from the output that would be printed when the first <db:link xlink:href="qrhi.xml#create">create</db:link>() attempt had failed.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>Flags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Flag&gt;. </db:code>It stores an OR combination of <db:code>Flag</db:code> values.</db:para>
</db:section>
<db:section xml:id="FrameOpResult-enum">
<db:title>enum QRhi::FrameOpResult</db:title>
<db:para>Describes the result of operations that can have a soft failure.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::FrameOpSuccess</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Success</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::FrameOpError</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Unspecified error</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::FrameOpSwapChainOutOfDate</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The swapchain is in an inconsistent state internally. This can be recoverable by attempting to repeat the operation (such as, <db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>()) later.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::FrameOpDeviceLost</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The graphics device was lost. This can be recoverable by attempting to repeat the operation (such as, <db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>()) after releasing and reinitializing all objects backed by native graphics resources. See <db:link xlink:href="qrhi.xml#isDeviceLost">isDeviceLost</db:link>().</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="Implementation-enum">
<db:title>enum QRhi::Implementation</db:title>
<db:para>Describes which graphics API-specific backend gets used by a <db:link xlink:href="qrhi.xml">QRhi</db:link> instance.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::Null</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::Vulkan</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::OpenGLES2</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::D3D11</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::D3D12</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::Metal</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="ResourceLimit-enum">
<db:title>enum QRhi::ResourceLimit</db:title>
<db:para>Describes the resource limit to query.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::TextureSizeMin</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Minimum texture width and height. This is typically 1. The minimum texture size is handled gracefully, meaning attempting to create a texture with an empty size will instead create a texture with the minimum size.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::TextureSizeMax</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Maximum texture width and height. This depends on the graphics API and sometimes the platform or implementation as well. Typically the value is in the range 4096 - 16384. Attempting to create textures larger than this is expected to fail.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MaxColorAttachments</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The maximum number of color attachments for a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link>, in case multiple render targets are supported. When MRT is not supported, the value is 1. Otherwise this is typically 8, but watch out for the fact that OpenGL only mandates 4 as the minimum, and that is what some OpenGL ES implementations provide.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::FramesInFlight</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The number of frames the backend may keep &quot;in flight&quot;: with backends like Vulkan or Metal, it is the responsibility of <db:link xlink:href="qrhi.xml">QRhi</db:link> to block whenever starting a new frame and finding the CPU is already <db:code>N - 1</db:code> frames ahead of the GPU (because the command buffer submitted in frame no. <db:code>current</db:code> - <db:code>N</db:code> has not yet completed). The value N is what is returned from here, and is typically 2. This can be relevant to applications that integrate rendering done directly with the graphics API, as such rendering code may want to perform double (if the value is 2) buffering for resources, such as, buffers, similarly to the <db:link xlink:href="qrhi.xml">QRhi</db:link> backends themselves. The current frame slot index (a value running 0, 1, .., N-1, then wrapping around) is retrievable from <db:link xlink:href="qrhi.xml#currentFrameSlot">QRhi::currentFrameSlot</db:link>(). The value is 1 for backends where the graphics API offers no such low level control over the command submission process. Note that pipelining may still happen even when this value is 1 (some backends, such as D3D11, are designed to attempt to enable this, for instance, by using an update strategy for uniform buffers that does not stall the pipeline), but that is then not controlled by <db:link xlink:href="qrhi.xml">QRhi</db:link> and so not reflected here in the API.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MaxAsyncReadbackFrames</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The number of <db:link xlink:href="qrhi.xml#endFrame">submitted</db:link> frames (including the one that contains the readback) after which an asynchronous texture or buffer readback is guaranteed to complete upon <db:link xlink:href="qrhi.xml#beginFrame">starting a new frame</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MaxThreadGroupsPerDimension</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The maximum number of compute work/thread groups that can be dispatched. Effectively the maximum value for the arguments of <db:link xlink:href="qrhicommandbuffer.xml#dispatch">QRhiCommandBuffer::dispatch</db:link>(). Typically 65535.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MaxThreadsPerThreadGroup</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>The maximum number of invocations in a single local work group, or in other terminology, the maximum number of threads in a thread group. Effectively the maximum value for the product of <db:code>local_size_x</db:code>, <db:code>local_size_y</db:code>, and <db:code>local_size_z</db:code> in the compute shader. Typical values are 128, 256, 512, 1024, or 1536. Watch out that both OpenGL ES and Vulkan specify only 128 as the minimum required limit for implementations. While uncommon for Vulkan, some OpenGL ES 3.1 implementations for mobile/embedded devices only support the spec-mandated minimum value.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MaxThreadGroupX</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>The maximum size of a work/thread group in the X dimension. Effectively the maximum value of <db:code>local_size_x</db:code> in the compute shader. Typically 256 or 1024.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MaxThreadGroupY</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>The maximum size of a work/thread group in the Y dimension. Effectively the maximum value of <db:code>local_size_y</db:code> in the compute shader. Typically 256 or 1024.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MaxThreadGroupZ</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>The maximum size of a work/thread group in the Z dimension. Effectively the maximum value of <db:code>local_size_z</db:code> in the compute shader. Typically 64 or 256.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::TextureArraySizeMax</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>Maximum texture array size. Typically in range 256 - 2048. Attempting to <db:link xlink:href="qrhi.xml#newTextureArray">create a texture array</db:link> with more elements will likely fail.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MaxUniformBufferRange</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>The number of bytes that can be exposed from a uniform buffer to the shaders at once. On OpenGL ES 2.0 and 3.0 implementations this may be as low as 3584 bytes (224 four component, 32 bits per component vectors). Elsewhere the value is typically 16384 (1024 vec4s) or 65536 (4096 vec4s).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MaxVertexInputs</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>The number of input attributes to the vertex shader. The location in a <db:link xlink:href="qrhivertexinputattribute.xml">QRhiVertexInputAttribute</db:link> must be in range <db:code>[0, MaxVertexInputs-1]</db:code>. The value may be as low as 8 with OpenGL ES 2.0. Elsewhere, typical values are 16, 31, or 32.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhi.xml">QRhi</db:link></db:emphasis>::MaxVertexOutputs</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>The maximum number of outputs (4 component vector <db:code>out</db:code> variables) from the vertex shader. The value may be as low as 8 with OpenGL ES 2.0, and 15 with OpenGL ES 3.0 and some Metal devices. Elsewhere, a typical value is 32.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="dtor.QRhi">
<db:title>[noexcept] QRhi::~QRhi()</db:title>
<db:para>Destructor. Destroys the backend and releases resources.</db:para>
</db:section>
<db:section xml:id="addCleanupCallback">
<db:title>void QRhi::addCleanupCallback(const QRhi::CleanupCallback &amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>Registers a <db:code role="parameter">callback</db:code> that is invoked either when the <db:link xlink:href="qrhi.xml">QRhi</db:link> is destroyed, or when <db:link xlink:href="qrhi.xml#runCleanup">runCleanup</db:link>() is called.</db:para>
<db:para>The callback will run with the graphics resource still available, so this provides an opportunity for the application to cleanly release <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> instances belonging to the <db:link xlink:href="qrhi.xml">QRhi</db:link>. This is particularly useful for managing the lifetime of resources stored in <db:code>cache</db:code> type of objects, where the cache holds QRhiResources or objects containing QRhiResources.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#runCleanup">runCleanup</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#dtor.QRhi">~QRhi</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addCleanupCallback-1">
<db:title>void QRhi::addCleanupCallback(const void *<db:emphasis>key</db:emphasis>, const QRhi::CleanupCallback &amp;<db:emphasis>callback</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Registers <db:code role="parameter">callback</db:code> to be invoked either when the <db:link xlink:href="qrhi.xml">QRhi</db:link> is destroyed or when <db:link xlink:href="qrhi.xml#runCleanup">runCleanup</db:link>() is called. This overload takes an opaque pointer, <db:code role="parameter">key</db:code>, that is used to ensure that a given callback is registered (and so called) only once.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#removeCleanupCallback">removeCleanupCallback</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="backend">
<db:title>QRhi::Implementation QRhi::backend() const</db:title>
<db:para>Returns the backend type for this <db:link xlink:href="qrhi.xml">QRhi</db:link>.</db:para>
</db:section>
<db:section xml:id="backendName">
<db:title>const char *QRhi::backendName() const</db:title>
<db:para>Returns the backend type as string for this <db:link xlink:href="qrhi.xml">QRhi</db:link>.</db:para>
</db:section>
<db:section xml:id="backendName-1">
<db:title>[static] const char *QRhi::backendName(QRhi::Implementation <db:emphasis>impl</db:emphasis>)</db:title>
<db:para>Returns a friendly name for the backend <db:code role="parameter">impl</db:code>, usually the name of the 3D API in use.</db:para>
</db:section>
<db:section xml:id="beginFrame">
<db:title>QRhi::FrameOpResult QRhi::beginFrame(QRhiSwapChain *<db:emphasis>swapChain</db:emphasis>, QRhi::BeginFrameFlags <db:emphasis>flags</db:emphasis> = {})</db:title>
<db:para>Starts a new frame targeting the next available buffer of <db:code role="parameter">swapChain</db:code>.</db:para>
<db:para>A frame consists of resource updates and one or more render and compute passes.</db:para>
<db:para><db:code role="parameter">flags</db:code> can indicate certain special cases.</db:para>
<db:para>The high level pattern of rendering into a <db:link xlink:href="qwindow.xml">QWindow</db:link> using a swapchain:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Create a swapchain.</db:para>
</db:listitem>
<db:listitem>
<db:para>Call QRhiSwapChain::createOrResize() whenever the surface size is different than before.</db:para>
</db:listitem>
<db:listitem>
<db:para>Call QRhiSwapChain::destroy() on <db:link xlink:href="qplatformsurfaceevent.xml#SurfaceEventType-enum">QPlatformSurfaceEvent::SurfaceAboutToBeDestroyed</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Then on every frame:</db:para>
<db:programlisting language="cpp" role="bad">beginFrame(sc);
updates = nextResourceUpdateBatch();
updates-&gt;...
QRhiCommandBuffer *cb = sc-&gt;currentFrameCommandBuffer();
cb-&gt;beginPass(sc-&gt;currentFrameRenderTarget(), colorClear, dsClear, updates);
...
cb-&gt;endPass();
... // more passes as necessary
endFrame(sc);
</db:programlisting>
</db:listitem>
</db:itemizedlist>
<db:para>Returns <db:link xlink:href="qrhi.xml#FrameOpResult-enum">QRhi::FrameOpSuccess</db:link> on success, or another <db:link xlink:href="qrhi.xml#FrameOpResult-enum">QRhi::FrameOpResult</db:link> value on failure. Some of these should be treated as soft, &quot;try again later&quot; type of errors: When <db:link xlink:href="qrhi.xml#FrameOpResult-enum">QRhi::FrameOpSwapChainOutOfDate</db:link> is returned, the swapchain is to be resized or updated by calling QRhiSwapChain::createOrResize(). The application should then attempt to generate a new frame. <db:link xlink:href="qrhi.xml#FrameOpResult-enum">QRhi::FrameOpDeviceLost</db:link> means the graphics device is lost but this may also be recoverable by releasing all resources, including the <db:link xlink:href="qrhi.xml">QRhi</db:link> itself, and then recreating all resources. See <db:link xlink:href="qrhi.xml#isDeviceLost">isDeviceLost</db:link>() for further discussion.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#beginOffscreenFrame">beginOffscreenFrame</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#isDeviceLost">isDeviceLost</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="beginOffscreenFrame">
<db:title>QRhi::FrameOpResult QRhi::beginOffscreenFrame(QRhiCommandBuffer **<db:emphasis>cb</db:emphasis>, QRhi::BeginFrameFlags <db:emphasis>flags</db:emphasis> = {})</db:title>
<db:para>Starts a new offscreen frame. Provides a command buffer suitable for recording rendering commands in <db:code role="parameter">cb</db:code>. <db:code role="parameter">flags</db:code> is used to indicate certain special cases, just like with <db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>().</db:para>
<db:note>
<db:para>The <db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link> stored to *cb is not owned by the caller.</db:para>
</db:note>
<db:para>Rendering without a swapchain is possible as well. The typical use case is to use it in completely offscreen applications, e.g. to generate image sequences by rendering and reading back without ever showing a window.</db:para>
<db:para>Usage in on-screen applications (so <db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>, <db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>, beginOffscreenFrame, <db:link xlink:href="qrhi.xml#endOffscreenFrame">endOffscreenFrame</db:link>, <db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>, ...) is possible too but it does reduce parallelism so it should be done only infrequently.</db:para>
<db:para>Offscreen frames do not let the CPU potentially generate another frame while the GPU is still processing the previous one. This has the side effect that if readbacks are scheduled, the results are guaranteed to be available once <db:link xlink:href="qrhi.xml#endOffscreenFrame">endOffscreenFrame</db:link>() returns. That is not the case with frames targeting a swapchain: there the GPU is potentially better utilized, but working with readback operations needs more care from the application because <db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>(), unlike <db:link xlink:href="qrhi.xml#endOffscreenFrame">endOffscreenFrame</db:link>(), does not guarantee that the results from the readback are available at that point.</db:para>
<db:para>The skeleton of rendering a frame without a swapchain and then reading the frame contents back could look like the following:</db:para>
<db:programlisting language="cpp">QRhiReadbackResult rbResult;
QRhiCommandBuffer *cb;
rhi-&gt;beginOffscreenFrame(&amp;cb);
cb-&gt;beginPass(rt, colorClear, dsClear);
// ...
u = nextResourceUpdateBatch();
u-&gt;readBackTexture(rb, &amp;rbResult);
cb-&gt;endPass(u);
rhi-&gt;endOffscreenFrame();
// image data available in rbResult
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#endOffscreenFrame">endOffscreenFrame</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clipSpaceCorrMatrix">
<db:title>QMatrix4x4 QRhi::clipSpaceCorrMatrix() const</db:title>
<db:para>Returns a matrix that can be used to allow applications keep using OpenGL-targeted vertex data and perspective projection matrices (such as, the ones generated by <db:link xlink:href="qmatrix4x4.xml#perspective">QMatrix4x4::perspective</db:link>()), regardless of the active <db:link xlink:href="qrhi.xml">QRhi</db:link> backend.</db:para>
<db:para>In a typical renderer, once <db:code>this_matrix * mvp</db:code> is used instead of just <db:code>mvp</db:code>, vertex data with Y up and viewports with depth range 0 - 1 can be used without considering what backend (and so graphics API) is going to be used at run time. This way branching based on <db:link xlink:href="qrhi.xml#isYUpInNDC">isYUpInNDC</db:link>() and <db:link xlink:href="qrhi.xml#isClipDepthZeroToOne">isClipDepthZeroToOne</db:link>() can be avoided (although such logic may still become required when implementing certain advanced graphics techniques).</db:para>
<db:para>See <db:link xlink:href="https://matthewwellings.com/blog/the-new-vulkan-coordinate-system/">this page</db:link> for a discussion of the topic from Vulkan perspective.</db:para>
</db:section>
<db:section xml:id="create">
<db:title>[static] QRhi *QRhi::create(QRhi::Implementation <db:emphasis>impl</db:emphasis>, QRhiInitParams *<db:emphasis>params</db:emphasis>, QRhi::Flags <db:emphasis>flags</db:emphasis> = {}, QRhiNativeHandles *<db:emphasis>importDevice</db:emphasis> = nullptr)</db:title>
<db:para>Returns a new <db:link xlink:href="qrhi.xml">QRhi</db:link> instance with a backend for the graphics API specified by <db:code role="parameter">impl</db:code> with the specified <db:code role="parameter">flags</db:code>. Returns <db:code>nullptr</db:code> if the function fails.</db:para>
<db:para><db:code role="parameter">params</db:code> must point to an instance of one of the backend-specific subclasses of <db:link xlink:href="qrhiinitparams.xml">QRhiInitParams</db:link>, such as, <db:link xlink:href="qrhivulkaninitparams.xml">QRhiVulkanInitParams</db:link>, <db:link xlink:href="qrhimetalinitparams.xml">QRhiMetalInitParams</db:link>, <db:link xlink:href="qrhid3d11initparams.xml">QRhiD3D11InitParams</db:link>, <db:link xlink:href="qrhid3d12initparams.xml">QRhiD3D12InitParams</db:link>, <db:link xlink:href="qrhigles2initparams.xml">QRhiGles2InitParams</db:link>. See these classes for examples on creating a <db:link xlink:href="qrhi.xml">QRhi</db:link>.</db:para>
<db:para><db:link xlink:href="qrhi.xml">QRhi</db:link> by design does not implement any fallback logic: if the specified API cannot be initialized, create() will fail, with warnings printed on the debug output by the backends. The clients of <db:link xlink:href="qrhi.xml">QRhi</db:link>, for example Qt Quick, may however provide additional logic that allow falling back to an API different than what was requested, depending on the platform. If the intention is just to test if initialization would succeed when calling create() at later point, it is preferable to use <db:link xlink:href="qrhi.xml#probe">probe</db:link>() instead of create(), because with some backends probing can be implemented in a more lightweight manner as opposed to create(), which performs full initialization of the infrastructure and is wasteful if that <db:link xlink:href="qrhi.xml">QRhi</db:link> instance is then thrown immediately away.</db:para>
<db:para><db:code role="parameter">importDevice</db:code> allows using an already existing graphics device, without <db:link xlink:href="qrhi.xml">QRhi</db:link> creating its own. When not null, this parameter must point to an instance of one of the subclasses of <db:link xlink:href="qrhinativehandles.xml">QRhiNativeHandles</db:link>: <db:link xlink:href="qrhivulkannativehandles.xml">QRhiVulkanNativeHandles</db:link>, <db:link xlink:href="qrhid3d11nativehandles.xml">QRhiD3D11NativeHandles</db:link>, <db:link xlink:href="qrhid3d12nativehandles.xml">QRhiD3D12NativeHandles</db:link>, <db:link xlink:href="qrhimetalnativehandles.xml">QRhiMetalNativeHandles</db:link>, <db:link xlink:href="qrhigles2nativehandles.xml">QRhiGles2NativeHandles</db:link>. The exact details and semantics depend on the backand and the underlying graphics API.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#probe">probe</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentFrameSlot">
<db:title>int QRhi::currentFrameSlot() const</db:title>
<db:para>Returns the current frame slot index while recording a frame. Unspecified when called outside an active frame (that is, when <db:link xlink:href="qrhi.xml#isRecordingFrame">isRecordingFrame</db:link>() is <db:code>false</db:code>).</db:para>
<db:para>With backends like Vulkan or Metal, it is the responsibility of the <db:link xlink:href="qrhi.xml">QRhi</db:link> backend to block whenever starting a new frame and finding the CPU is already <db:code>FramesInFlight - 1</db:code> frames ahead of the GPU (because the command buffer submitted in frame no. <db:code>current</db:code> - <db:code>FramesInFlight</db:code> has not yet completed).</db:para>
<db:para>Resources that tend to change between frames (such as, the native buffer object backing a <db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link> with type <db:link xlink:href="qrhibuffer.xml#Type-enum">QRhiBuffer::Dynamic</db:link>) exist in multiple versions, so that each frame, that can be submitted while a previous one is still being processed, works with its own copy, thus avoiding the need to stall the pipeline when preparing the frame. (The contents of a resource that may still be in use in the GPU should not be touched, but simply always waiting for the previous frame to finish would reduce GPU utilization and ultimately, performance and efficiency.)</db:para>
<db:para>Conceptually this is somewhat similar to copy-on-write schemes used by some C++ containers and other types. It may also be similar to what an OpenGL or Direct 3D 11 implementation performs internally for certain type of objects.</db:para>
<db:para>In practice, such double (or triple) buffering resources is realized in the Vulkan, Metal, and similar <db:link xlink:href="qrhi.xml">QRhi</db:link> backends by having a fixed number of native resource (such as, VkBuffer) <db:code>slots</db:code> behind a <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link>. That can then be indexed by a frame slot index running 0, 1, .., <db:link xlink:href="qrhi.xml#ResourceLimit-enum">FramesInFlight</db:link>-1, and then wrapping around.</db:para>
<db:para>All this is managed transparently to the users of <db:link xlink:href="qrhi.xml">QRhi</db:link>. However, applications that integrate rendering done directly with the graphics API may want to perform a similar double or triple buffering of their own graphics resources. That is then most easily achieved by knowing the values of the maximum number of in-flight frames (retrievable via <db:link xlink:href="qrhi.xml#resourceLimit">resourceLimit</db:link>()) and the current frame (slot) index (returned by this function).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#isRecordingFrame">isRecordingFrame</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="driverInfo">
<db:title>QRhiDriverInfo QRhi::driverInfo() const</db:title>
<db:para>Returns metadata for the graphics device used by this successfully initialized <db:link xlink:href="qrhi.xml">QRhi</db:link> instance.</db:para>
</db:section>
<db:section xml:id="endFrame">
<db:title>QRhi::FrameOpResult QRhi::endFrame(QRhiSwapChain *<db:emphasis>swapChain</db:emphasis>, QRhi::EndFrameFlags <db:emphasis>flags</db:emphasis> = {})</db:title>
<db:para>Ends, commits, and presents a frame that was started in the last <db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>() on <db:code role="parameter">swapChain</db:code>.</db:para>
<db:para>Double (or triple) buffering is managed internally by the <db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link> and <db:link xlink:href="qrhi.xml">QRhi</db:link>.</db:para>
<db:para><db:code role="parameter">flags</db:code> can optionally be used to change the behavior in certain ways. Passing <db:link xlink:href="qrhi.xml#EndFrameFlag-enum">QRhi::SkipPresent</db:link> skips queuing the Present command or calling swapBuffers.</db:para>
<db:para>Returns <db:link xlink:href="qrhi.xml#FrameOpResult-enum">QRhi::FrameOpSuccess</db:link> on success, or another <db:link xlink:href="qrhi.xml#FrameOpResult-enum">QRhi::FrameOpResult</db:link> value on failure. Some of these should be treated as soft, &quot;try again later&quot; type of errors: When <db:link xlink:href="qrhi.xml#FrameOpResult-enum">QRhi::FrameOpSwapChainOutOfDate</db:link> is returned, the swapchain is to be resized or updated by calling QRhiSwapChain::createOrResize(). The application should then attempt to generate a new frame. <db:link xlink:href="qrhi.xml#FrameOpResult-enum">QRhi::FrameOpDeviceLost</db:link> means the graphics device is lost but this may also be recoverable by releasing all resources, including the <db:link xlink:href="qrhi.xml">QRhi</db:link> itself, and then recreating all resources. See <db:link xlink:href="qrhi.xml#isDeviceLost">isDeviceLost</db:link>() for further discussion.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#isDeviceLost">isDeviceLost</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="endOffscreenFrame">
<db:title>QRhi::FrameOpResult QRhi::endOffscreenFrame(QRhi::EndFrameFlags <db:emphasis>flags</db:emphasis> = {})</db:title>
<db:para>Ends, submits, and waits for the offscreen frame.</db:para>
<db:para><db:code role="parameter">flags</db:code> is not currently used.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#beginOffscreenFrame">beginOffscreenFrame</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="finish">
<db:title>QRhi::FrameOpResult QRhi::finish()</db:title>
<db:para>Waits for any work on the graphics queue (where applicable) to complete, then executes all deferred operations, like completing readbacks and resource releases. Can be called inside and outside of a frame, but not inside a pass. Inside a frame it implies submitting any work on the command buffer.</db:para>
<db:note>
<db:para>Avoid this function. One case where it may be needed is when the results of an enqueued readback in a swapchain-based frame are needed at a fixed given point and so waiting for the results is desired.</db:para>
</db:note>
</db:section>
<db:section xml:id="isClipDepthZeroToOne">
<db:title>bool QRhi::isClipDepthZeroToOne() const</db:title>
<db:para>Returns <db:code>true</db:code> if the underlying graphics API uses depth range [0, 1] in clip space.</db:para>
<db:para>In practice this is <db:code>false</db:code> for OpenGL only, because OpenGL uses a post-projection depth range of [-1, 1]. (not to be confused with the NDC-to-window mapping controlled by glDepthRange(), which uses a range of [0, 1], unless overridden by the <db:link xlink:href="qrhiviewport.xml">QRhiViewport</db:link>) In some OpenGL versions glClipControl() could be used to change this, but the OpenGL backend of <db:link xlink:href="qrhi.xml">QRhi</db:link> does not use that function as it is not available in OpenGL ES or OpenGL versions lower than 4.5.</db:para>
<db:note>
<db:para><db:link xlink:href="qrhi.xml#clipSpaceCorrMatrix">clipSpaceCorrMatrix</db:link>() includes the corresponding adjustment in its returned matrix. Therefore, many users of <db:link xlink:href="qrhi.xml">QRhi</db:link> do not need to take any further measures apart from pre-multiplying their projection matrices with <db:link xlink:href="qrhi.xml#clipSpaceCorrMatrix">clipSpaceCorrMatrix</db:link>(). However, some graphics techniques, such as, some types of shadow mapping, involve working with and outputting depth values in the shaders. These will need to query and take the value of this function into account as appropriate.</db:para>
</db:note>
</db:section>
<db:section xml:id="isDeviceLost">
<db:title>bool QRhi::isDeviceLost() const</db:title>
<db:para>Returns true if the graphics device was lost.</db:para>
<db:para>The loss of the device is typically detected in <db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>(), <db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>() or QRhiSwapChain::createOrResize(), depending on the backend and the underlying native APIs. The most common is <db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>() because that is where presenting happens. With some backends QRhiSwapChain::createOrResize() can also fail due to a device loss. Therefore this function is provided as a generic way to check if a device loss was detected by a previous operation.</db:para>
<db:para>When the device is lost, no further operations should be done via the <db:link xlink:href="qrhi.xml">QRhi</db:link>. Rather, all <db:link xlink:href="qrhi.xml">QRhi</db:link> resources should be released, followed by destroying the <db:link xlink:href="qrhi.xml">QRhi</db:link>. A new <db:link xlink:href="qrhi.xml">QRhi</db:link> can then be attempted to be created. If successful, all graphics resources must be reinitialized. If not, try again later, repeatedly.</db:para>
<db:para>While simple applications may decide to not care about device loss, on the commonly used desktop platforms a device loss can happen due to a variety of reasons, including physically disconnecting the graphics adapter, disabling the device or driver, uninstalling or upgrading the graphics driver, or due to errors that lead to a graphics device reset. Some of these can happen under perfectly normal circumstances as well, for example the upgrade of the graphics driver to a newer version is a common task that can happen at any time while a Qt application is running. Users may very well expect applications to be able to survive this, even when the application is actively using an API like OpenGL or Direct3D.</db:para>
<db:para>Qt's own frameworks built on top of <db:link xlink:href="qrhi.xml">QRhi</db:link>, such as, Qt Quick, can be expected to handle and take appropriate measures when a device loss occurs. If the data for graphics resources, such as textures and buffers, are still available on the CPU side, such an event may not be noticeable on the application level at all since graphics resources can seamlessly be reinitialized then. However, applications and libraries working directly with <db:link xlink:href="qrhi.xml">QRhi</db:link> are expected to be prepared to check and handle device loss situations themselves.</db:para>
<db:note>
<db:para>With OpenGL, applications may need to opt-in to context reset notifications by setting <db:link xlink:href="qsurfaceformat.xml#FormatOption-enum">QSurfaceFormat::ResetNotification</db:link> on the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link>. This is typically done by enabling the flag in <db:link xlink:href="qrhigles2initparams.xml#format-var">QRhiGles2InitParams::format</db:link>. Keep in mind however that some systems may generate context resets situations even when this flag is not set.</db:para>
</db:note>
</db:section>
<db:section xml:id="isFeatureSupported">
<db:title>bool QRhi::isFeatureSupported(QRhi::Feature <db:emphasis>feature</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if the specified <db:code role="parameter">feature</db:code> is supported</db:para>
</db:section>
<db:section xml:id="isRecordingFrame">
<db:title>bool QRhi::isRecordingFrame() const</db:title>
<db:para>Returns true when there is an active frame, meaning there was a <db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>() (or <db:link xlink:href="qrhi.xml#beginOffscreenFrame">beginOffscreenFrame</db:link>()) with no corresponding <db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>() (or <db:link xlink:href="qrhi.xml#endOffscreenFrame">endOffscreenFrame</db:link>()) yet.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#currentFrameSlot">currentFrameSlot</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isTextureFormatSupported">
<db:title>bool QRhi::isTextureFormatSupported(QRhiTexture::Format <db:emphasis>format</db:emphasis>, QRhiTexture::Flags <db:emphasis>flags</db:emphasis> = {}) const</db:title>
<db:para>Returns <db:code>true</db:code> if the specified texture <db:code role="parameter">format</db:code> modified by <db:code role="parameter">flags</db:code> is supported.</db:para>
<db:para>The query is supported both for uncompressed and compressed formats.</db:para>
</db:section>
<db:section xml:id="isYUpInFramebuffer">
<db:title>bool QRhi::isYUpInFramebuffer() const</db:title>
<db:para>Returns <db:code>true</db:code> if the underlying graphics API has the Y axis pointing up in framebuffers and images.</db:para>
<db:para>In practice this is <db:code>true</db:code> for OpenGL only.</db:para>
</db:section>
<db:section xml:id="isYUpInNDC">
<db:title>bool QRhi::isYUpInNDC() const</db:title>
<db:para>Returns <db:code>true</db:code> if the underlying graphics API has the Y axis pointing up in its normalized device coordinate system.</db:para>
<db:para>In practice this is <db:code>false</db:code> for Vulkan only.</db:para>
<db:note>
<db:para><db:link xlink:href="qrhi.xml#clipSpaceCorrMatrix">clipSpaceCorrMatrix</db:link>() includes the corresponding adjustment (to make Y point up) in its returned matrix.</db:para>
</db:note>
</db:section>
<db:section xml:id="makeThreadLocalNativeContextCurrent">
<db:title>bool QRhi::makeThreadLocalNativeContextCurrent()</db:title>
<db:para>With OpenGL this makes the OpenGL context current on the current thread. The function has no effect with other backends.</db:para>
<db:para>Calling this function is relevant typically in Qt framework code, when one has to ensure external OpenGL code provided by the application can still run like it did before with direct usage of OpenGL, as long as the <db:link xlink:href="qrhi.xml">QRhi</db:link> is using the OpenGL backend.</db:para>
<db:para>Returns false when failed, similarly to <db:link xlink:href="qopenglcontext.xml#makeCurrent">QOpenGLContext::makeCurrent</db:link>(). When the operation failed, <db:link xlink:href="qrhi.xml#isDeviceLost">isDeviceLost</db:link>() can be called to determine if there was a loss of context situation. Such a check is equivalent to checking via <db:link xlink:href="qopenglcontext.xml#isValid">QOpenGLContext::isValid</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#makeCurrent">QOpenGLContext::makeCurrent</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglcontext.xml#isValid">QOpenGLContext::isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mipLevelsForSize">
<db:title>[static] int QRhi::mipLevelsForSize(const QSize &amp;<db:emphasis>size</db:emphasis>)</db:title>
<db:para>Returns the number of mip levels for a given <db:code role="parameter">size</db:code>.</db:para>
</db:section>
<db:section xml:id="nativeHandles">
<db:title>const QRhiNativeHandles *QRhi::nativeHandles()</db:title>
<db:para>Returns a pointer to the backend-specific collection of native objects for the device, context, and similar concepts used by the backend.</db:para>
<db:para>Cast to <db:link xlink:href="qrhivulkannativehandles.xml">QRhiVulkanNativeHandles</db:link>, <db:link xlink:href="qrhid3d11nativehandles.xml">QRhiD3D11NativeHandles</db:link>, <db:link xlink:href="qrhid3d12nativehandles.xml">QRhiD3D12NativeHandles</db:link>, <db:link xlink:href="qrhigles2nativehandles.xml">QRhiGles2NativeHandles</db:link>, or <db:link xlink:href="qrhimetalnativehandles.xml">QRhiMetalNativeHandles</db:link> as appropriate.</db:para>
<db:note>
<db:para>No ownership is transferred, neither for the returned pointer nor for any native objects.</db:para>
</db:note>
</db:section>
<db:section xml:id="newBuffer">
<db:title>QRhiBuffer *QRhi::newBuffer(QRhiBuffer::Type <db:emphasis>type</db:emphasis>, QRhiBuffer::UsageFlags <db:emphasis>usage</db:emphasis>, quint32 <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Returns a new buffer with the specified <db:code role="parameter">type</db:code>, <db:code role="parameter">usage</db:code>, and <db:code role="parameter">size</db:code>.</db:para>
<db:note>
<db:para>Some <db:code role="parameter">usage</db:code> and <db:code role="parameter">type</db:code> combinations may not be supported by all backends. See <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">UsageFlags</db:link> and <db:link xlink:href="qrhi.xml#Feature-enum">the feature flags</db:link>.</db:para>
</db:note>
<db:note>
<db:para>Backends may choose to allocate buffers bigger than <db:code role="parameter">size</db:code>. This is done transparently to applications, so there are no special restrictions on the value of <db:code role="parameter">size</db:code>. QRhiBuffer::size() will always report back the value that was requested in <db:code role="parameter">size</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QRhiResource::destroy()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newComputePipeline">
<db:title>QRhiComputePipeline *QRhi::newComputePipeline()</db:title>
<db:para>Returns a new compute pipeline resource.</db:para>
<db:note>
<db:para>Compute is only available when the <db:link xlink:href="qrhi.xml#Feature-enum">Compute</db:link> feature is reported as supported.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QRhiResource::destroy()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newGraphicsPipeline">
<db:title>QRhiGraphicsPipeline *QRhi::newGraphicsPipeline()</db:title>
<db:para>Returns a new graphics pipeline resource.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QRhiResource::destroy()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newRenderBuffer">
<db:title>QRhiRenderBuffer *QRhi::newRenderBuffer(QRhiRenderBuffer::Type <db:emphasis>type</db:emphasis>, const QSize &amp;<db:emphasis>pixelSize</db:emphasis>, int <db:emphasis>sampleCount</db:emphasis> = 1, QRhiRenderBuffer::Flags <db:emphasis>flags</db:emphasis> = {}, QRhiTexture::Format <db:emphasis>backingFormatHint</db:emphasis> = QRhiTexture::UnknownFormat)</db:title>
<db:para>Returns a new renderbuffer with the specified <db:code role="parameter">type</db:code>, <db:code role="parameter">pixelSize</db:code>, <db:code role="parameter">sampleCount</db:code>, and <db:code role="parameter">flags</db:code>.</db:para>
<db:para>When <db:code role="parameter">backingFormatHint</db:code> is set to a texture format other than <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::UnknownFormat</db:link>, it may be used by the backend to decide what format to use for the storage backing the renderbuffer.</db:para>
<db:note>
<db:para><db:code role="parameter">backingFormatHint</db:code> becomes relevant typically when multisampling and floating point texture formats are involved: rendering into a multisample <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> and then resolving into a non-RGBA8 <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> implies (with some graphics APIs) that the storage backing the <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> uses the matching non-RGBA8 format. That means that passing a format like <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::RGBA32F</db:link> is important, because backends will typically opt for <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::RGBA8</db:link> by default, which would then break later on due to attempting to set up RGBA8-&gt;RGBA32F multisample resolve in the color attachment(s) of the <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QRhiResource::destroy()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newSampler">
<db:title>QRhiSampler *QRhi::newSampler(QRhiSampler::Filter <db:emphasis>magFilter</db:emphasis>, QRhiSampler::Filter <db:emphasis>minFilter</db:emphasis>, QRhiSampler::Filter <db:emphasis>mipmapMode</db:emphasis>, QRhiSampler::AddressMode <db:emphasis>addressU</db:emphasis>, QRhiSampler::AddressMode <db:emphasis>addressV</db:emphasis>, QRhiSampler::AddressMode <db:emphasis>addressW</db:emphasis> = QRhiSampler::Repeat)</db:title>
<db:para>Returns a new sampler with the specified magnification filter <db:code role="parameter">magFilter</db:code>, minification filter <db:code role="parameter">minFilter</db:code>, mipmapping mode <db:code role="parameter">mipmapMode</db:code>, and the addressing (wrap) modes <db:code role="parameter">addressU</db:code>, <db:code role="parameter">addressV</db:code>, and <db:code role="parameter">addressW</db:code>.</db:para>
<db:note>
<db:para>Setting <db:code role="parameter">mipmapMode</db:code> to a value other than <db:code>None</db:code> implies that images for all relevant mip levels will be provided either via <db:link xlink:href="qrhiresourceupdatebatch.xml#uploadTexture">texture uploads</db:link> or by calling <db:link xlink:href="qrhiresourceupdatebatch.xml#generateMips">generateMips</db:link>() on the texture that is used with this sampler. Attempting to use the sampler with a texture that has no data for all relevant mip levels will lead to rendering errors, with the exact behavior dependent on the underlying graphics API.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QRhiResource::destroy()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newShaderResourceBindings">
<db:title>QRhiShaderResourceBindings *QRhi::newShaderResourceBindings()</db:title>
<db:para>Returns a new shader resource binding collection resource.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QRhiResource::destroy()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newSwapChain">
<db:title>QRhiSwapChain *QRhi::newSwapChain()</db:title>
<db:para>Returns a new swapchain.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QRhiResource::destroy()</db:link></db:member>
<db:member><db:link xlink:href="">QRhiSwapChain::createOrResize()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newTexture">
<db:title>QRhiTexture *QRhi::newTexture(QRhiTexture::Format <db:emphasis>format</db:emphasis>, const QSize &amp;<db:emphasis>pixelSize</db:emphasis>, int <db:emphasis>sampleCount</db:emphasis> = 1, QRhiTexture::Flags <db:emphasis>flags</db:emphasis> = {})</db:title>
<db:para>Returns a new 1D or 2D texture with the specified <db:code role="parameter">format</db:code>, <db:code role="parameter">pixelSize</db:code>, <db:code role="parameter">sampleCount</db:code>, and <db:code role="parameter">flags</db:code>.</db:para>
<db:para>A 1D texture array must have <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::OneDimensional</db:link> set in <db:code role="parameter">flags</db:code>. This function will implicitly set this flag if the <db:code role="parameter">pixelSize</db:code> height is 0.</db:para>
<db:note>
<db:para><db:code role="parameter">format</db:code> specifies the requested internal and external format, meaning the data to be uploaded to the texture will need to be in a compatible format, while the native texture may (but is not guaranteed to, in case of OpenGL at least) use this format internally.</db:para>
</db:note>
<db:note>
<db:para>1D textures are only functional when the <db:link xlink:href="qrhi.xml#Feature-enum">OneDimensionalTextures</db:link> feature is reported as supported at run time. Further, mipmaps on 1D textures are only functional when the <db:link xlink:href="qrhi.xml#Feature-enum">OneDimensionalTextureMipmaps</db:link> feature is reported at run time.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QRhiResource::destroy()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newTexture-1">
<db:title>QRhiTexture *QRhi::newTexture(QRhiTexture::Format <db:emphasis>format</db:emphasis>, int <db:emphasis>width</db:emphasis>, int <db:emphasis>height</db:emphasis>, int <db:emphasis>depth</db:emphasis>, int <db:emphasis>sampleCount</db:emphasis> = 1, QRhiTexture::Flags <db:emphasis>flags</db:emphasis> = {})</db:title>
<db:para>Returns a new 1D, 2D or 3D texture with the specified <db:code role="parameter">format</db:code>, <db:code role="parameter">width</db:code>, <db:code role="parameter">height</db:code>, <db:code role="parameter">depth</db:code>, <db:code role="parameter">sampleCount</db:code>, and <db:code role="parameter">flags</db:code>.</db:para>
<db:para>This overload is suitable for 3D textures because it allows specifying <db:code role="parameter">depth</db:code>. A 3D texture must have <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::ThreeDimensional</db:link> set in <db:code role="parameter">flags</db:code>, but using this overload that can be omitted because the flag is set implicitly whenever <db:code role="parameter">depth</db:code> is greater than 0. For 1D, 2D and cube textures <db:code role="parameter">depth</db:code> should be set to 0.</db:para>
<db:para>A 1D texture must have <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::OneDimensional</db:link> set in <db:code role="parameter">flags</db:code>. This overload will implicitly set this flag if both <db:code role="parameter">height</db:code> and <db:code role="parameter">depth</db:code> are 0.</db:para>
<db:note>
<db:para>3D textures are only functional when the <db:link xlink:href="qrhi.xml#Feature-enum">ThreeDimensionalTextures</db:link> feature is reported as supported at run time.</db:para>
</db:note>
<db:note>
<db:para>1D textures are only functional when the <db:link xlink:href="qrhi.xml#Feature-enum">OneDimensionalTextures</db:link> feature is reported as supported at run time. Further, mipmaps on 1D textures are only functional when the <db:link xlink:href="qrhi.xml#Feature-enum">OneDimensionalTextureMipmaps</db:link> feature is reported at run time.</db:para>
</db:note>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="newTextureArray">
<db:title>QRhiTexture *QRhi::newTextureArray(QRhiTexture::Format <db:emphasis>format</db:emphasis>, int <db:emphasis>arraySize</db:emphasis>, const QSize &amp;<db:emphasis>pixelSize</db:emphasis>, int <db:emphasis>sampleCount</db:emphasis> = 1, QRhiTexture::Flags <db:emphasis>flags</db:emphasis> = {})</db:title>
<db:para>Returns a new 1D or 2D texture array with the specified <db:code role="parameter">format</db:code>, <db:code role="parameter">arraySize</db:code>, <db:code role="parameter">pixelSize</db:code>, <db:code role="parameter">sampleCount</db:code>, and <db:code role="parameter">flags</db:code>.</db:para>
<db:para>This function implicitly sets <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::TextureArray</db:link> in <db:code role="parameter">flags</db:code>.</db:para>
<db:para>A 1D texture array must have <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::OneDimensional</db:link> set in <db:code role="parameter">flags</db:code>. This function will implicitly set this flag if the <db:code role="parameter">pixelSize</db:code> height is 0.</db:para>
<db:note>
<db:para>Do not confuse texture arrays with arrays of textures. A <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> created by this function is usable with 1D or 2D array samplers in the shader, for example: <db:code>layout(binding = 1) uniform sampler2DArray texArr;</db:code>. Arrays of textures refers to a list of textures that are exposed to the shader via <db:link xlink:href="qrhishaderresourcebinding.xml#sampledTextures">QRhiShaderResourceBinding::sampledTextures</db:link>() and a count &gt; 1, and declared in the shader for example like this: <db:code>layout(binding = 1) uniform sampler2D textures[4];</db:code></db:para>
</db:note>
<db:note>
<db:para>This is only functional when the <db:link xlink:href="qrhi.xml#Feature-enum">TextureArrays</db:link> feature is reported as supported at run time.</db:para>
</db:note>
<db:note>
<db:para>1D textures are only functional when the <db:link xlink:href="qrhi.xml#Feature-enum">OneDimensionalTextures</db:link> feature is reported as supported at run time. Further, mipmaps on 1D textures are only functional when the <db:link xlink:href="qrhi.xml#Feature-enum">OneDimensionalTextureMipmaps</db:link> feature is reported at run time.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#newTexture">newTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newTextureRenderTarget">
<db:title>QRhiTextureRenderTarget *QRhi::newTextureRenderTarget(const QRhiTextureRenderTargetDescription &amp;<db:emphasis>desc</db:emphasis>, QRhiTextureRenderTarget::Flags <db:emphasis>flags</db:emphasis> = {})</db:title>
<db:para>Returns a new texture render target with color and depth/stencil attachments given in <db:code role="parameter">desc</db:code>, and with the specified <db:code role="parameter">flags</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QRhiResource::destroy()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nextResourceUpdateBatch">
<db:title>QRhiResourceUpdateBatch *QRhi::nextResourceUpdateBatch()</db:title>
<db:para>Returns an available, empty batch to which copy type of operations can be recorded.</db:para>
<db:note>
<db:para>the return value is not owned by the caller and must never be destroyed. Instead, the batch is returned the pool for reuse by passing it to <db:link xlink:href="qrhicommandbuffer.xml#beginPass">QRhiCommandBuffer::beginPass</db:link>(), <db:link xlink:href="qrhicommandbuffer.xml#endPass">QRhiCommandBuffer::endPass</db:link>(), or <db:link xlink:href="qrhicommandbuffer.xml#resourceUpdate">QRhiCommandBuffer::resourceUpdate</db:link>(), or by calling <db:link xlink:href="qrhiresourceupdatebatch.xml#release">QRhiResourceUpdateBatch::release</db:link>() on it.</db:para>
</db:note>
<db:note>
<db:para>Can be called outside <db:link xlink:href="qrhi.xml#beginFrame">beginFrame</db:link>() - <db:link xlink:href="qrhi.xml#endFrame">endFrame</db:link>() as well since a batch instance just collects data on its own, it does not perform any operations.</db:para>
</db:note>
<db:para>Due to not being tied to a frame being recorded, the following sequence is valid for example:</db:para>
<db:programlisting language="cpp">rhi-&gt;beginFrame(swapchain);
QRhiResourceUpdateBatch *u = rhi-&gt;nextResourceUpdateBatch();
u-&gt;uploadStaticBuffer(buf, data);
// ... do not commit the batch
rhi-&gt;endFrame();
// u stays valid (assuming buf stays valid as well)
rhi-&gt;beginFrame(swapchain);
swapchain-&gt;currentFrameCommandBuffer()-&gt;resourceUpdate(u);
// ... draw with buf
rhi-&gt;endFrame();
</db:programlisting>
<db:warning>
<db:para>The maximum number of batches per <db:link xlink:href="qrhi.xml">QRhi</db:link> is 64. When this limit is reached, the function will return null until a batch is returned to the pool.</db:para>
</db:warning>
</db:section>
<db:section xml:id="pipelineCacheData">
<db:title>QByteArray QRhi::pipelineCacheData()</db:title>
<db:para>Returns a binary data blob with data collected from the <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> and <db:link xlink:href="qrhicomputepipeline.xml">QRhiComputePipeline</db:link> successfully created during the lifetime of this <db:link xlink:href="qrhi.xml">QRhi</db:link>.</db:para>
<db:para>By saving and then, in subsequent runs of the same application, reloading the cache data, pipeline and shader creation times can potentially be reduced. What exactly the cache and its serialized version includes is not specified, is always specific to the backend used, and in some cases also dependent on the particular implementation of the graphics API.</db:para>
<db:para>When the <db:link xlink:href="qrhi.xml#Feature-enum">PipelineCacheDataLoadSave</db:link> is reported as unsupported, the returned <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is empty.</db:para>
<db:para>When the <db:link xlink:href="qrhi.xml#Flag-enum">EnablePipelineCacheDataSave</db:link> flag was not specified when calling <db:link xlink:href="qrhi.xml#create">create</db:link>(), the returned <db:link xlink:href="qbytearray.xml">QByteArray</db:link> may be empty, even when the <db:link xlink:href="qrhi.xml#Feature-enum">PipelineCacheDataLoadSave</db:link> feature is supported.</db:para>
<db:para>When the returned data is non-empty, it is always specific to the Qt version and <db:link xlink:href="qrhi.xml">QRhi</db:link> backend. In addition, in some cases there is a strong dependency to the graphics device and the exact driver version used. <db:link xlink:href="qrhi.xml">QRhi</db:link> takes care of adding the appropriate header and safeguards that ensure that the data can always be passed safely to <db:link xlink:href="qrhi.xml#setPipelineCacheData">setPipelineCacheData</db:link>(), therefore attempting to load data from a run on another version of a driver will be handled safely and gracefully.</db:para>
<db:note>
<db:para>Calling <db:link xlink:href="qrhi.xml#releaseCachedResources">releaseCachedResources</db:link>() may, depending on the backend, clear the pipeline data collected. A subsequent call to this function may then not return any data.</db:para>
</db:note>
<db:para>See <db:link xlink:href="qrhi.xml#Flag-enum">EnablePipelineCacheDataSave</db:link> for further details about this feature.</db:para>
<db:note>
<db:para>Minimize the number of calls to this function. Retrieving the blob is not always a cheap operation, and therefore this function should only be called at a low frequency, ideally only once e.g. when closing the application.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#setPipelineCacheData">setPipelineCacheData</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#create">create</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#isFeatureSupported">isFeatureSupported</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="probe">
<db:title>[static] bool QRhi::probe(QRhi::Implementation <db:emphasis>impl</db:emphasis>, QRhiInitParams *<db:emphasis>params</db:emphasis>)</db:title>
<db:para>Returns true if <db:link xlink:href="qrhi.xml#create">create</db:link>() can be expected to succeed when called the given <db:code role="parameter">impl</db:code> and <db:code role="parameter">params</db:code>.</db:para>
<db:para>For some backends this is equivalent to calling <db:link xlink:href="qrhi.xml#create">create</db:link>(), checking its return value, and then destroying the resulting <db:link xlink:href="qrhi.xml">QRhi</db:link>.</db:para>
<db:para>For others, in particular with Metal, there may be a specific probing implementation, which allows testing in a more lightweight manner without polluting the debug output with warnings upon failures.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#create">create</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="releaseCachedResources">
<db:title>void QRhi::releaseCachedResources()</db:title>
<db:para>Attempts to release resources in the backend's caches. This can include both CPU and GPU resources. Only memory and resources that can be recreated automatically are in scope. As an example, if the backend's <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> implementation maintains a cache of shader compilation results, calling this function leads to emptying that cache, thus potentially freeing up memory and graphics resources.</db:para>
<db:para>Calling this function makes sense in resource constrained environments, where at a certain point there is a need to ensure minimal resource usage, at the expense of performance.</db:para>
</db:section>
<db:section xml:id="removeCleanupCallback">
<db:title>void QRhi::removeCleanupCallback(const void *<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Deregisters the callback with <db:code role="parameter">key</db:code>. If no cleanup callback was registered with <db:code role="parameter">key</db:code>, the function does nothing. Callbacks registered without a key cannot be removed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#addCleanupCallback">addCleanupCallback</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resourceLimit">
<db:title>int QRhi::resourceLimit(QRhi::ResourceLimit <db:emphasis>limit</db:emphasis>) const</db:title>
<db:para>Returns the value for the specified resource <db:code role="parameter">limit</db:code>.</db:para>
<db:para>The values are expected to be queried by the backends upon initialization, meaning calling this function is a light operation.</db:para>
</db:section>
<db:section xml:id="runCleanup">
<db:title>void QRhi::runCleanup()</db:title>
<db:para>Invokes all registered cleanup functions. The list of cleanup callbacks it then cleared. Normally destroying the <db:link xlink:href="qrhi.xml">QRhi</db:link> does this automatically, but sometimes it can be useful to trigger cleanup in order to release all cached, non-essential resources.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#addCleanupCallback">addCleanupCallback</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPipelineCacheData">
<db:title>void QRhi::setPipelineCacheData(const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:para>Loads <db:code role="parameter">data</db:code> into the pipeline cache, when applicable.</db:para>
<db:para>When the <db:link xlink:href="qrhi.xml#Feature-enum">PipelineCacheDataLoadSave</db:link> is reported as unsupported, the function is safe to call, but has no effect.</db:para>
<db:para>The blob returned by <db:link xlink:href="qrhi.xml#pipelineCacheData">pipelineCacheData</db:link>() is always specific to the Qt version, the <db:link xlink:href="qrhi.xml">QRhi</db:link> backend, and, in some cases, also to the graphics device, and a given version of the graphics driver. <db:link xlink:href="qrhi.xml">QRhi</db:link> takes care of adding the appropriate header and safeguards that ensure that the data can always be passed safely to this function. If there is a mismatch, e.g. because the driver has been upgraded to a newer version, or because the data was generated from a different <db:link xlink:href="qrhi.xml">QRhi</db:link> backend, a warning is printed and <db:code role="parameter">data</db:code> is safely ignored.</db:para>
<db:para>With Vulkan, this maps directly to VkPipelineCache. Calling this function creates a new Vulkan pipeline cache object, with its initial data sourced from <db:code role="parameter">data</db:code>. The pipeline cache object is then used by all subsequently created <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> and <db:link xlink:href="qrhicomputepipeline.xml">QRhiComputePipeline</db:link> objects, thus accelerating, potentially, the pipeline creation.</db:para>
<db:para>With other APIs there is no real pipeline cache, but they may provide a cache with bytecode from shader compilations (D3D) or program binaries (OpenGL). In applications that perform a lot of shader compilation from source at run time this can provide a significant boost in subsequent runs if the &quot;pipeline cache&quot; is pre-seeded from an earlier run using this function.</db:para>
<db:note>
<db:para><db:link xlink:href="qrhi.xml">QRhi</db:link> cannot give any guarantees that <db:code role="parameter">data</db:code> has an effect on the pipeline and shader creation performance. With APIs like Vulkan, it is up to the driver to decide if <db:code role="parameter">data</db:code> is used for some purpose, or if it is ignored.</db:para>
</db:note>
<db:para>See <db:link xlink:href="qrhi.xml#Flag-enum">EnablePipelineCacheDataSave</db:link> for further details about this feature.</db:para>
<db:note>
<db:para>This mechanism offered by <db:link xlink:href="qrhi.xml">QRhi</db:link> is independent of the drivers' own internal caching mechanism, if any. This means that, depending on the graphics API and its implementation, the exact effects of retrieving and then reloading <db:code role="parameter">data</db:code> are not predictable. Improved performance may not be visible at all in case other caching mechanisms outside of Qt's control are already active.</db:para>
</db:note>
<db:note>
<db:para>Minimize the number of calls to this function. Loading the blob is not always a cheap operation, and therefore this function should only be called at a low frequency, ideally only once e.g. when starting the application.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#pipelineCacheData">pipelineCacheData</db:link>()</db:member>
<db:member><db:link xlink:href="qrhi.xml#isFeatureSupported">isFeatureSupported</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sizeForMipLevel">
<db:title>[static] QSize QRhi::sizeForMipLevel(int <db:emphasis>mipLevel</db:emphasis>, const QSize &amp;<db:emphasis>baseLevelSize</db:emphasis>)</db:title>
<db:para>Returns the texture image size for a given <db:code role="parameter">mipLevel</db:code>, calculated based on the level 0 size given in <db:code role="parameter">baseLevelSize</db:code>.</db:para>
</db:section>
<db:section xml:id="statistics">
<db:title>QRhiStats QRhi::statistics() const</db:title>
<db:para>Gathers and returns statistics about the timings and allocations of graphics resources.</db:para>
<db:para>Data about memory allocations is only available with some backends, where such operations are under Qt's control. With graphics APIs where there is no lower level control over resource memory allocations, this will never be supported and all relevant fields in the results are 0.</db:para>
<db:para>With Vulkan in particular, the values are valid always, and are queried from the underlying memory allocator library. This gives an insight into the memory requirements of the active buffers and textures.</db:para>
<db:para>The same is true for Direct 3D 12. In addition to the memory allocator library's statistics, here the result also includes a <db:code>totalUsageBytes</db:code> field which reports the total size including additional resources that are not under the memory allocator library's control (swapchain buffers, descriptor heaps, etc.), as reported by DXGI.</db:para>
<db:para>The values correspond to all types of memory used, combined. (i.e. video + system in case of a discreet GPU)</db:para>
<db:para>Additional data, such as the total time in milliseconds spent in graphics and compute pipeline creation (which usually involves shader compilation or cache lookups, and potentially expensive processing) is available with most backends.</db:para>
<db:note>
<db:para>The elapsed times for operations such as pipeline creation may be affected by various factors. The results should not be compared between different backends since the concept of &quot;pipelines&quot; and what exactly happens under the hood during, for instance, a call to QRhiGraphicsPipeline::create(), differ greatly between graphics APIs and their implementations.</db:para>
</db:note>
<db:note>
<db:para>Additionally, many drivers will likely employ various caching strategies for shaders, programs, pipelines. (independently of Qt's own similar facilities, such as <db:link xlink:href="qrhi.xml#setPipelineCacheData">setPipelineCacheData</db:link>() or the OpenGL-specific program binary disk cache). Because such internal behavior is transparent to the API client, Qt and <db:link xlink:href="qrhi.xml">QRhi</db:link> have no knowledge or control over the exact caching strategy, persistency, invalidation of the cached data, etc. When reading timings, such as the time spent on pipeline creation, the potential presence and unspecified behavior of driver-level caching mechanisms should be kept in mind.</db:para>
</db:note>
</db:section>
<db:section xml:id="supportedSampleCounts">
<db:title>QList&lt;int&gt; QRhi::supportedSampleCounts() const</db:title>
<db:para>Returns the list of supported sample counts.</db:para>
<db:para>A typical example would be (1, 2, 4, 8).</db:para>
<db:para>With some backend this list of supported values is fixed in advance, while with some others the (physical) device properties indicate what is supported at run time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">QRhiRenderBuffer::setSampleCount()</db:link></db:member>
<db:member><db:link xlink:href="">QRhiTexture::setSampleCount()</db:link></db:member>
<db:member><db:link xlink:href="">QRhiGraphicsPipeline::setSampleCount()</db:link></db:member>
<db:member><db:link xlink:href="">QRhiSwapChain::setSampleCount()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="thread">
<db:title>QThread *QRhi::thread() const</db:title>
<db:para>Returns the thread on which the <db:link xlink:href="qrhi.xml">QRhi</db:link> was <db:link xlink:href="qrhi.xml#create">initialized</db:link>.</db:para>
</db:section>
<db:section xml:id="ubufAligned">
<db:title>int QRhi::ubufAligned(int <db:emphasis>v</db:emphasis>) const</db:title>
<db:para>Returns the value (typically an offset) <db:code role="parameter">v</db:code> aligned to the uniform buffer alignment given by by <db:link xlink:href="qrhi.xml#ubufAlignment">ubufAlignment</db:link>().</db:para>
</db:section>
<db:section xml:id="ubufAlignment">
<db:title>int QRhi::ubufAlignment() const</db:title>
<db:para>Returns the minimum uniform buffer offset alignment in bytes. This is typically 256.</db:para>
<db:para>Attempting to bind a uniform buffer region with an offset not aligned to this value will lead to failures depending on the backend and the underlying graphics API.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml#ubufAligned">ubufAligned</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="updateSwapChainProxyData">
<db:title>[static] QRhiSwapChainProxyData QRhi::updateSwapChainProxyData(QRhi::Implementation <db:emphasis>impl</db:emphasis>, QWindow *<db:emphasis>window</db:emphasis>)</db:title>
<db:para>Generates and returns a <db:link xlink:href="qrhiswapchainproxydata.xml">QRhiSwapChainProxyData</db:link> struct containing opaque data specific to the backend and graphics API specified by <db:code role="parameter">impl</db:code>. <db:code role="parameter">window</db:code> is the <db:link xlink:href="qwindow.xml">QWindow</db:link> a swapchain is targeting.</db:para>
<db:para>The returned struct can be passed to QRhiSwapChain::setProxyData(). This makes sense in threaded rendering systems: this static function is expected to be called on the <db:emphasis role="bold">main (gui) thread</db:emphasis>, unlike all <db:link xlink:href="qrhi.xml">QRhi</db:link> operations, then transferred to the thread working with the <db:link xlink:href="qrhi.xml">QRhi</db:link> and <db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link> and passed on to the swapchain. This allows doing native platform queries that are only safe to be called on the main thread, for example to query the CAMetalLayer from a NSView, and then passing on the data to the <db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link> living on the rendering thread. With the Metal example, doing the view.layer access on a dedicated rendering thread causes a warning in the Xcode Thread Checker. With the data proxy mechanism, this is avoided.</db:para>
<db:para>When threads are not involved, generating and passing on the <db:link xlink:href="qrhiswapchainproxydata.xml">QRhiSwapChainProxyData</db:link> is not required: backends are guaranteed to be able to query whatever is needed on their own, and if everything lives on the main (gui) thread, that should be sufficient.</db:para>
<db:note>
<db:para><db:code role="parameter">impl</db:code> should match what the <db:link xlink:href="qrhi.xml">QRhi</db:link> is created with. For example, calling with <db:link xlink:href="qrhi.xml#Implementation-enum">QRhi::Metal</db:link> on a non-Apple platform will not generate any useful data.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="QRhiShaderResourceBindingSet-typedef">
<db:title>[alias, since 6.7] QRhiShaderResourceBindingSet</db:title>
<db:para>Synonym for <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link>.</db:para>
<db:para>This typedef was introduced in Qt 6.7.</db:para>
</db:section>
</db:section>
</db:article>
