<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Quick Responsive Layouts</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A guideline to make Qt Quick Layouts adaptive to screen size.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Layouts are a good technique to make resizable user interfaces. However, this approach has its limitations as we cannot shrink and expand items limitless without sacrificing usability and aesthetics. At some point, it makes more sense to reorganize, remove or add certain elements. Adapting to different devices (e.g. phones and tables) and screen orientations (landscape or portrait) can be implemented similarly. This is what we usually understand as responsive layouts and <db:link xlink:href="qtquicklayouts-index.xml">Qt Quick Layouts</db:link> provide various APIs to implement them.</db:para>
<db:section xml:id="static-hierarchy-adaptive-layout">
<db:title>Static hierarchy, adaptive layout</db:title>
<db:para>Layouts have a hierarchy, which is usually defined by the declarative QML code. For some simple responsive layouts, it is sufficient to keep the hierarchy unmodified and instead just tweak some of the properties that affect layouting.</db:para>
<db:section xml:id="declarative-description">
<db:title>Declarative description</db:title>
<db:para>The simplest approach to change layouting is to modify layout properties and <db:link xlink:href="qml-qtquick-layouts-layout.xml">Layout</db:link> attached properties with small expressions. You can for instance use ternary operators in order to modify the layout depending on its width. <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> properties, such as <db:link xlink:href="qml-qtquick-item.xml#visible-prop">Item.visible</db:link>, hiding or showing various parts of the interface, can be modified the same way.</db:para>
<db:para>In the following snippet, this concept is used to change a two-column layout into a single-column layout if the window width is smaller than a certain value.</db:para>
<db:programlisting language="qml">GridLayout {
    columns: width &lt; 300 ? 1 : 2
    anchors.fill: parent

    Rectangle {
        id: rectangle1
        color: &quot;tomato&quot;
        Layout.fillHeight: true
        Layout.fillWidth: true
    }

    Rectangle {
        id: rectangle2
        color: &quot;lightskyblue&quot;
        Layout.fillHeight: true
        Layout.fillWidth: true
    }
}
</db:programlisting>
<db:para>The resulting layouts look like this, depending on the width of the window.</db:para>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/simpleProxy.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
<db:para>Various levels of layouts and items can be nested but <db:link xlink:href="qml-qtquick-item.xml">Items</db:link> can only be moved within a their <db:link xlink:href="qml-qtquick-item.xml#parent-prop">Item.parent</db:link>.</db:para>
</db:section>
<db:section xml:id="states">
<db:title>States</db:title>
<db:para>The same result can be achieved with <db:link xlink:href="qtquick-statesanimations-states.xml">Qt Quick States</db:link>. The upside of using states is that the <db:link xlink:href="qml-qtquick-layouts-layout.xml">Layout</db:link> properties for a specific layout are collected at a single point in the QML file (at least the changing ones). The previously shown example can be implemented as follows and the result looks and behaves the exact same.</db:para>
<db:programlisting language="qml">GridLayout {
    anchors.fill: parent

    Rectangle {
        id: rectangle1
        color: &quot;tomato&quot;
        Layout.fillHeight: true
        Layout.fillWidth: true
    }

    Rectangle {
        id: rectangle2
        color: &quot;lightskyblue&quot;
        Layout.fillHeight: true
        Layout.fillWidth: true
    }

    states: [
        State {
            when: width &lt; 300
            PropertyChanges { target: rectangle2; Layout.row: 1 }
            PropertyChanges { target: rectangle2; Layout.column: 0 }
        },
        State {
            when: width &gt;= 300
            PropertyChanges { target: rectangle2; Layout.row: 0 }
            PropertyChanges { target: rectangle2; Layout.column: 1 }
        }
    ]
}
</db:programlisting>
</db:section>
<db:section xml:id="layoutitemproxy">
<db:title>LayoutItemProxy</db:title>
<db:para>A third approach is the application of the <db:link xlink:href="qml-qtquick-layouts-layoutitemproxy.xml">LayoutItemProxy</db:link>. The implementation of the previously shown minimalistic example can be found in the type documentation. In contrast to previously shown solutions, the <db:link xlink:href="qml-qtquick-layouts-layoutitemproxy.xml">LayoutItemProxy</db:link> enables the declaration of completely separate layouts for various form factors. Especially with more complex layouts this might be useful to improve and maintain a reasonable source code structure.</db:para>
<db:para>Note, that the <db:link xlink:href="qml-qtquick-layouts-layoutitemproxy.xml">LayoutItemProxy</db:link> API is a technical preview and might be subject to change or removal in future Qt versions.</db:para>
</db:section>
</db:section>
<db:section xml:id="adaptive-hierarchy-adaptive-layout">
<db:title>Adaptive hierarchy, adaptive layout</db:title>
<db:para>More complex reconstructions of the layout might require changes to the hierarchy. A small stand-alone button in a small layout might be combined with other buttons and put into a box of a larger layout. An item that is fully visible in one layout, might require a <db:link xlink:href="qml-qtquick-flickable.xml">Flickable</db:link> in another, smaller layout. In this scenario, it is best to rely on the <db:link xlink:href="qml-qtquick-layouts-layoutitemproxy.xml">LayoutItemProxy</db:link>. The <db:link xlink:href="qml-qtquick-layouts-layoutitemproxy.xml">LayoutItemProxy</db:link> allows to move <db:link xlink:href="qml-qtquick-item.xml">Items</db:link> across various hierarchy levels and between different <db:link xlink:href="qml-qtquick-item.xml#parent-prop">Item.parent</db:link>.</db:para>
<db:para>The <db:link xlink:href="qtquick-responsivelayouts-example.xml">Qt Quick Layouts - Responsive Layout Example</db:link> shows a case where an item is moved between different hierarchy levels, put into a <db:link xlink:href="qml-qtquick-flickable.xml">Flickable</db:link> in one case and on the top level in another layout. The two resulting layouts look as follows.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtquicklayouts-example-responsivelayouts.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
<db:section xml:id="useful-links-consult-your-design-guidelines">
<db:title>Useful links: Consult your design guidelines</db:title>
<db:para>Many design guidelines offer help and tips to create responsive layouts. Implementing the respective techniques is possible with the APIs mentioned above. For further information we recommend the following links:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="https://developer.apple.com/design/human-interface-guidelines/layout">Apple human interface guidelines</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="https://m3.material.io/foundations/layout/applying-layout/window-size-classes">Material3 layouts</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="https://learn.microsoft.com/en-us/windows/apps/design/layout/responsive-design">Microsoft Fluent responsive design techniques</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:article>
