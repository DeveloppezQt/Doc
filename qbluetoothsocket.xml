<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QBluetoothSocket Class</db:title>
<db:productname>QtBluetooth</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Bluetooth Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link> class enables connection to a Bluetooth device running a bluetooth server.</db:para>
<db:para>This class was introduced in Qt 5.2.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QBluetoothSocket</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.2</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += bluetooth</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qiodevice.xml" xlink:role="class">QIODevice</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link> supports two socket types, <db:link xlink:href="qbluetoothserviceinfo.xml#Protocol-enum">L2CAP</db:link> and <db:link xlink:href="qbluetoothserviceinfo.xml#Protocol-enum">RFCOMM</db:link>.</db:para>
<db:para><db:link xlink:href="qbluetoothserviceinfo.xml#Protocol-enum">L2CAP</db:link> is a low level datagram-oriented Bluetooth socket. Android does not support <db:link xlink:href="qbluetoothserviceinfo.xml#Protocol-enum">L2CAP</db:link> for socket connections.</db:para>
<db:para><db:link xlink:href="qbluetoothserviceinfo.xml#Protocol-enum">RFCOMM</db:link> is a reliable, stream-oriented socket. RFCOMM sockets emulate an RS-232 serial port.</db:para>
<db:para>To create a connection to a Bluetooth service, create a socket of the appropriate type and call <db:link xlink:href="qbluetoothsocket.xml#connectToService">connectToService</db:link>() passing the Bluetooth address and port number. <db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link> will emit the <db:link xlink:href="qbluetoothsocket.xml#connected">connected</db:link>() signal when the connection is established.</db:para>
<db:para>If the <db:link xlink:href="qbluetoothserviceinfo.xml#Protocol-enum">Protocol</db:link> is not supported on a platform, calling <db:link xlink:href="qbluetoothsocket.xml#connectToService">connectToService</db:link>() will emit a <db:link xlink:href="qbluetoothsocket.xml#SocketError-enum">UnsupportedProtocolError</db:link> error.</db:para>
<db:note>
<db:para><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link> does not support synchronous read and write operations. Functions such as <db:link xlink:href="qiodevice.xml#waitForReadyRead">waitForReadyRead</db:link>() and <db:link xlink:href="qiodevice.xml#waitForBytesWritten">waitForBytesWritten</db:link>() are not implemented. I/O operations should be performed using <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>(), <db:link xlink:href="qiodevice.xml#read">read</db:link>() and <db:link xlink:href="qiodevice.xml#write">write</db:link>().</db:para>
</db:note>
<db:para>On iOS, this class cannot be used because the platform does not expose an API which may permit access to <db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link> related features.</db:para>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="SocketError-enum">
<db:title>enum QBluetoothSocket::SocketError</db:title>
<db:enumsynopsis>
<db:enumname>SocketError</db:enumname>
<db:enumitem>
<db:enumidentifier>NoSocketError</db:enumidentifier>
<db:enumvalue>-2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnknownSocketError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::UnknownSocketError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RemoteHostClosedError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::RemoteHostClosedError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>HostNotFoundError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::HostNotFoundError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ServiceNotFoundError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::SocketAddressNotAvailableError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NetworkError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::NetworkError</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnsupportedProtocolError</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>OperationError</db:enumidentifier>
<db:enumvalue>QAbstractSocket::OperationError</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes Bluetooth socket error types.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::UnknownSocketError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::UnknownSocketError</db:code></db:td>
<db:td>
<db:para>An unknown error has occurred.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::NoSocketError</db:code></db:para>
</db:td>
<db:td><db:code>-2</db:code></db:td>
<db:td>
<db:para>No error. Used for testing.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::HostNotFoundError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::HostNotFoundError</db:code></db:td>
<db:td>
<db:para>Could not find the remote host.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::ServiceNotFoundError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::SocketAddressNotAvailableError</db:code></db:td>
<db:td>
<db:para>Could not find the service UUID on remote host.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::NetworkError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::NetworkError</db:code></db:td>
<db:td>
<db:para>Attempt to read or write from socket returned an error</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::UnsupportedProtocolError</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>The <db:link xlink:href="qbluetoothserviceinfo.xml#Protocol-enum">Protocol</db:link> is not supported on this platform.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::OperationError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::OperationError</db:code></db:td>
<db:td>
<db:para>An operation was attempted while the socket was in a state that did not permit it.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::RemoteHostClosedError</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::RemoteHostClosedError</db:code></db:td>
<db:td>
<db:para>The remote host closed the connection. This value was introduced by Qt 5.10.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="SocketState-enum">
<db:title>enum QBluetoothSocket::SocketState</db:title>
<db:enumsynopsis>
<db:enumname>SocketState</db:enumname>
<db:enumitem>
<db:enumidentifier>UnconnectedState</db:enumidentifier>
<db:enumvalue>QAbstractSocket::UnconnectedState</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ServiceLookupState</db:enumidentifier>
<db:enumvalue>QAbstractSocket::HostLookupState</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ConnectingState</db:enumidentifier>
<db:enumvalue>QAbstractSocket::ConnectingState</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ConnectedState</db:enumidentifier>
<db:enumvalue>QAbstractSocket::ConnectedState</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BoundState</db:enumidentifier>
<db:enumvalue>QAbstractSocket::BoundState</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ClosingState</db:enumidentifier>
<db:enumvalue>QAbstractSocket::ClosingState</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ListeningState</db:enumidentifier>
<db:enumvalue>QAbstractSocket::ListeningState</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the state of the Bluetooth socket.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::UnconnectedState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::UnconnectedState</db:code></db:td>
<db:td>
<db:para>Socket is not connected.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::ServiceLookupState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::HostLookupState</db:code></db:td>
<db:td>
<db:para>Socket is querying connection parameters.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::ConnectingState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::ConnectingState</db:code></db:td>
<db:td>
<db:para>Socket is attempting to connect to a device.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::ConnectedState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::ConnectedState</db:code></db:td>
<db:td>
<db:para>Socket is connected to a device.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::BoundState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::BoundState</db:code></db:td>
<db:td>
<db:para>Socket is bound to a local address and port.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::ClosingState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::ClosingState</db:code></db:td>
<db:td>
<db:para>Socket is connected and will be closed once all pending data is written to the socket.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link></db:emphasis>::ListeningState</db:code></db:para>
</db:td>
<db:td><db:code>QAbstractSocket::ListeningState</db:code></db:td>
<db:td>
<db:para>Socket is listening for incoming connections.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QBluetoothSocket">
<db:title>[explicit] QBluetoothSocket::QBluetoothSocket(QBluetoothServiceInfo::Protocol <db:emphasis>socketType</db:emphasis>, QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QBluetoothSocket</db:methodname>
<db:methodparam>
<db:type>QBluetoothServiceInfo::Protocol</db:type>
<db:parameter>socketType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QBluetoothSocket(QBluetoothServiceInfo::Protocol socketType, QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a Bluetooth socket of <db:code role="parameter">socketType</db:code> type, with <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="QBluetoothSocket-1">
<db:title>[explicit] QBluetoothSocket::QBluetoothSocket(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QBluetoothSocket</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QBluetoothSocket(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a Bluetooth socket with <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QBluetoothSocket">
<db:title>[virtual] QBluetoothSocket::~QBluetoothSocket()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QBluetoothSocket</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QBluetoothSocket()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the Bluetooth socket.</db:para>
</db:section>
<db:section xml:id="abort">
<db:title>void QBluetoothSocket::abort()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>abort</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void abort()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Aborts the current connection and resets the socket. Unlike <db:link xlink:href="qbluetoothsocket.xml#disconnectFromService">disconnectFromService</db:link>(), this function immediately closes the socket, discarding any pending data in the write buffer.</db:para>
<db:note>
<db:para>On Android, aborting the socket requires asynchronous interaction with Android threads. Therefore the associated <db:link xlink:href="qbluetoothsocket.xml#disconnected">disconnected</db:link>() and <db:link xlink:href="qbluetoothsocket.xml#stateChanged">stateChanged</db:link>() signals are delayed until the threads have finished the closure.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#disconnectFromService">disconnectFromService</db:link>()</db:member>
<db:member><db:link xlink:href="qbluetoothsocket.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesAvailable">
<db:title>[override virtual] qint64 QBluetoothSocket::bytesAvailable() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>bytesAvailable</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 bytesAvailable() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#bytesAvailable" role="function">QIODevice::bytesAvailable() const</db:link>.</db:para>
<db:para>Returns the number of incoming bytes that are waiting to be read.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#bytesToWrite">bytesToWrite</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#read">read</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesToWrite">
<db:title>[override virtual] qint64 QBluetoothSocket::bytesToWrite() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>bytesToWrite</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 bytesToWrite() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#bytesToWrite" role="function">QIODevice::bytesToWrite() const</db:link>.</db:para>
<db:para>Returns the number of bytes that are waiting to be written. The bytes are written when control goes back to the event loop.</db:para>
</db:section>
<db:section xml:id="canReadLine">
<db:title>[override virtual] bool QBluetoothSocket::canReadLine() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>canReadLine</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool canReadLine() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#canReadLine" role="function">QIODevice::canReadLine() const</db:link>.</db:para>
<db:para>Returns true if you can read at least one line from the device</db:para>
</db:section>
<db:section xml:id="close">
<db:title>[override virtual] void QBluetoothSocket::close()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>close</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void close() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#close" role="function">QIODevice::close()</db:link>.</db:para>
<db:para>Disconnects the socket's connection with the device.</db:para>
<db:note>
<db:para>On Android, closing the socket requires asynchronous interaction with Android threads. Therefore the associated <db:link xlink:href="qbluetoothsocket.xml#disconnected">disconnected</db:link>() and <db:link xlink:href="qbluetoothsocket.xml#stateChanged">stateChanged</db:link>() signals are delayed until the threads have finished the closure.</db:para>
</db:note>
</db:section>
<db:section xml:id="connectToService">
<db:title>void QBluetoothSocket::connectToService(const QBluetoothServiceInfo &amp;<db:emphasis>service</db:emphasis>, QIODevice::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connectToService</db:methodname>
<db:methodparam>
<db:type>const QBluetoothServiceInfo &amp;</db:type>
<db:parameter>service</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QIODevice::OpenMode</db:type>
<db:parameter>openMode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void connectToService(const QBluetoothServiceInfo &amp;service, QIODevice::OpenMode openMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to connect to the service described by <db:code role="parameter">service</db:code>.</db:para>
<db:para>The socket is opened in the given <db:code role="parameter">openMode</db:code>. The <db:link xlink:href="qbluetoothsocket.xml#socketType">socketType</db:link>() is ignored if <db:code role="parameter">service</db:code> specifies a differing <db:link xlink:href="qbluetoothserviceinfo.xml#socketProtocol">QBluetoothServiceInfo::socketProtocol</db:link>().</db:para>
<db:para>The socket first enters <db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">ConnectingState</db:link> and attempts to connect to the device providing <db:code role="parameter">service</db:code>. If a connection is established, <db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link> enters <db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">ConnectedState</db:link> and emits <db:link xlink:href="qbluetoothsocket.xml#connected">connected</db:link>().</db:para>
<db:para>At any point, the socket can emit <db:link xlink:href="qbluetoothsocket.xml#error">error</db:link>() to signal that an error occurred.</db:para>
<db:para>Note that most platforms require a pairing prior to connecting to the remote device. Otherwise the connection process may fail.</db:para>
<db:para>On Android, only RFCOMM connections are possible. This function ignores any socket protocol indicator and assumes RFCOMM.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qbluetoothsocket.xml#disconnectFromService">disconnectFromService</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectToService-1">
<db:title>void QBluetoothSocket::connectToService(const QBluetoothAddress &amp;<db:emphasis>address</db:emphasis>, const QBluetoothUuid &amp;<db:emphasis>uuid</db:emphasis>, QIODevice::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connectToService</db:methodname>
<db:methodparam>
<db:type>const QBluetoothAddress &amp;</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QBluetoothUuid &amp;</db:type>
<db:parameter>uuid</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QIODevice::OpenMode</db:type>
<db:parameter>openMode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void connectToService(const QBluetoothAddress &amp;address, const QBluetoothUuid &amp;uuid, QIODevice::OpenMode openMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to make a connection to the service identified by <db:code role="parameter">uuid</db:code> on the device with address <db:code role="parameter">address</db:code>.</db:para>
<db:para>The socket is opened in the given <db:code role="parameter">openMode</db:code>.</db:para>
<db:para>For BlueZ, the socket first enters the <db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">ServiceLookupState</db:link> and queries the connection parameters for <db:code role="parameter">uuid</db:code>. If the service parameters are successfully retrieved the socket enters <db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">ConnectingState</db:link>, and attempts to connect to <db:code role="parameter">address</db:code>. If a connection is established, <db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link> enters <db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">ConnectedState</db:link> and emits <db:link xlink:href="qbluetoothsocket.xml#connected">connected</db:link>().</db:para>
<db:para>On Android, the service connection can directly be established using the UUID of the remote service. Therefore the platform does not require the <db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">ServiceLookupState</db:link> and <db:link xlink:href="qbluetoothsocket.xml#socketType">socketType</db:link>() is always set to <db:link xlink:href="qbluetoothserviceinfo.xml#Protocol-enum">QBluetoothServiceInfo::RfcommProtocol</db:link>.</db:para>
<db:para>At any point, the socket can emit <db:link xlink:href="qbluetoothsocket.xml#error">error</db:link>() to signal that an error occurred.</db:para>
<db:para>Note that most platforms require a pairing prior to connecting to the remote device. Otherwise the connection process may fail.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qbluetoothsocket.xml#disconnectFromService">disconnectFromService</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectToService-2">
<db:title>void QBluetoothSocket::connectToService(const QBluetoothAddress &amp;<db:emphasis>address</db:emphasis>, quint16 <db:emphasis>port</db:emphasis>, QIODevice::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connectToService</db:methodname>
<db:methodparam>
<db:type>const QBluetoothAddress &amp;</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QIODevice::OpenMode</db:type>
<db:parameter>openMode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void connectToService(const QBluetoothAddress &amp;address, quint16 port, QIODevice::OpenMode openMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to make a connection with <db:code role="parameter">address</db:code> on the given <db:code role="parameter">port</db:code>.</db:para>
<db:para>The socket is opened in the given <db:code role="parameter">openMode</db:code>.</db:para>
<db:para>The socket first enters <db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">ConnectingState</db:link>, and attempts to connect to <db:code role="parameter">address</db:code>. If a connection is established, <db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link> enters <db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">ConnectedState</db:link> and emits <db:link xlink:href="qbluetoothsocket.xml#connected">connected</db:link>().</db:para>
<db:para>At any point, the socket can emit <db:link xlink:href="qbluetoothsocket.xml#error">error</db:link>() to signal that an error occurred.</db:para>
<db:para>On Android and BlueZ (version 5.46 or above), a connection to a service can not be established using a port. Calling this function will emit a <db:link xlink:href="qbluetoothsocket.xml#SocketError-enum">ServiceNotFoundError</db:link>.</db:para>
<db:para>Note that most platforms require a pairing prior to connecting to the remote device. Otherwise the connection process may fail.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qbluetoothsocket.xml#disconnectFromService">disconnectFromService</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connected">
<db:title>void QBluetoothSocket::connected()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connected</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void connected()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when a connection is established.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">QBluetoothSocket::ConnectedState</db:link></db:member>
<db:member><db:link xlink:href="qbluetoothsocket.xml#stateChanged">stateChanged</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="disconnectFromService">
<db:title>void QBluetoothSocket::disconnectFromService()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>disconnectFromService</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void disconnectFromService()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to close the socket. If there is pending data waiting to be written <db:link xlink:href="qbluetoothsocket.xml">QBluetoothSocket</db:link> will enter <db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">ClosingState</db:link> and wait until all data has been written. Eventually, it will enter <db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">UnconnectedState</db:link> and emit the <db:link xlink:href="qbluetoothsocket.xml#disconnected">disconnected</db:link>() signal.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#connectToService">connectToService</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="disconnected">
<db:title>void QBluetoothSocket::disconnected()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>disconnected</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void disconnected()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the socket is disconnected.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">QBluetoothSocket::UnconnectedState</db:link></db:member>
<db:member><db:link xlink:href="qbluetoothsocket.xml#stateChanged">stateChanged</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="doDeviceDiscovery">
<db:title>[protected] void QBluetoothSocket::doDeviceDiscovery(const QBluetoothServiceInfo &amp;<db:emphasis>service</db:emphasis>, QIODevice::OpenMode <db:emphasis>openMode</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>doDeviceDiscovery</db:methodname>
<db:methodparam>
<db:type>const QBluetoothServiceInfo &amp;</db:type>
<db:parameter>service</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QIODevice::OpenMode</db:type>
<db:parameter>openMode</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void doDeviceDiscovery(const QBluetoothServiceInfo &amp;service, QIODevice::OpenMode openMode)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Start device discovery for <db:code role="parameter">service</db:code> and open the socket with <db:code role="parameter">openMode</db:code>. If the socket is created with a service uuid device address, use service discovery to find the port number to connect to.</db:para>
</db:section>
<db:section xml:id="error">
<db:title>QBluetoothSocket::SocketError QBluetoothSocket::error() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QBluetoothSocket::SocketError</db:type>
<db:methodname>error</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QBluetoothSocket::SocketError error() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the last error.</db:para>
</db:section>
<db:section xml:id="error-1">
<db:title>void QBluetoothSocket::error(QBluetoothSocket::SocketError <db:emphasis>error</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>error</db:methodname>
<db:methodparam>
<db:type>QBluetoothSocket::SocketError</db:type>
<db:parameter>error</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void error(QBluetoothSocket::SocketError error)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when an <db:code role="parameter">error</db:code> occurs.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#error">error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QBluetoothSocket::errorString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>errorString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString errorString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a user displayable text string for the error.</db:para>
</db:section>
<db:section xml:id="isSequential">
<db:title>[override virtual] bool QBluetoothSocket::isSequential() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSequential</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSequential() const override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#isSequential" role="function">QIODevice::isSequential() const</db:link>.</db:para>
</db:section>
<db:section xml:id="localAddress">
<db:title>QBluetoothAddress QBluetoothSocket::localAddress() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QBluetoothAddress</db:type>
<db:methodname>localAddress</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QBluetoothAddress localAddress() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the address of the local device.</db:para>
<db:para>Although some platforms may differ the socket must generally be connected to guarantee the return of a valid address. In particular, this is true when dealing with platforms that support multiple local Bluetooth adapters.</db:para>
</db:section>
<db:section xml:id="localName">
<db:title>QString QBluetoothSocket::localName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>localName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString localName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name of the local device.</db:para>
<db:para>Although some platforms may differ the socket must generally be connected to guarantee the return of a valid name. In particular, this is true when dealing with platforms that support multiple local Bluetooth adapters.</db:para>
</db:section>
<db:section xml:id="localPort">
<db:title>quint16 QBluetoothSocket::localPort() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint16</db:type>
<db:methodname>localPort</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint16 localPort() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the port number of the local socket if available, otherwise returns 0. Although some platforms may differ the socket must generally be connected to guarantee the return of a valid port number.</db:para>
<db:para>On Android and macOS, this feature is not supported and returns 0.</db:para>
</db:section>
<db:section xml:id="peerAddress">
<db:title>QBluetoothAddress QBluetoothSocket::peerAddress() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QBluetoothAddress</db:type>
<db:methodname>peerAddress</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QBluetoothAddress peerAddress() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the address of the peer device.</db:para>
</db:section>
<db:section xml:id="peerName">
<db:title>QString QBluetoothSocket::peerName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>peerName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString peerName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name of the peer device.</db:para>
</db:section>
<db:section xml:id="peerPort">
<db:title>quint16 QBluetoothSocket::peerPort() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint16</db:type>
<db:methodname>peerPort</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint16 peerPort() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Return the port number of the peer socket if available, otherwise returns 0. On Android, this feature is not supported.</db:para>
</db:section>
<db:section xml:id="preferredSecurityFlags">
<db:title>[since 5.6] QBluetooth::SecurityFlags QBluetoothSocket::preferredSecurityFlags() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QBluetooth::SecurityFlags</db:type>
<db:methodname>preferredSecurityFlags</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QBluetooth::SecurityFlags preferredSecurityFlags() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the security parameters used for the initial connection attempt.</db:para>
<db:para>The security parameters may be renegotiated between the two parties during or after the connection has been established. If such a change happens it is not reflected in the value of this flag.</db:para>
<db:para>On macOS, this flag is always set to <db:link xlink:href="qbluetooth.xml#Security-enum">QBluetooth::Secure</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#setPreferredSecurityFlags">setPreferredSecurityFlags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readData">
<db:title>[override virtual protected] qint64 QBluetoothSocket::readData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>readData</db:methodname>
<db:methodparam>
<db:type>char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>maxSize</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 readData(char *data, qint64 maxSize) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#readData" role="function">QIODevice::readData(char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
<db:section xml:id="setPreferredSecurityFlags">
<db:title>[since 5.6] void QBluetoothSocket::setPreferredSecurityFlags(QBluetooth::SecurityFlags <db:emphasis>flags</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPreferredSecurityFlags</db:methodname>
<db:methodparam>
<db:type>QBluetooth::SecurityFlags</db:type>
<db:parameter>flags</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPreferredSecurityFlags(QBluetooth::SecurityFlags flags)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the preferred security parameter for the connection attempt to <db:code role="parameter">flags</db:code>. This value is incorporated when calling <db:link xlink:href="qbluetoothsocket.xml#connectToService">connectToService</db:link>(). Therefore it is required to reconnect to change this parameter for an existing connection.</db:para>
<db:para>On Bluez this property is set to <db:link xlink:href="qbluetooth.xml#Security-enum">QBluetooth::Authorization</db:link> by default.</db:para>
<db:para>On macOS, this value is ignored as the platform does not permit access to the security parameter of the socket. By default the platform prefers secure/encrypted connections though and therefore this function always returns <db:link xlink:href="qbluetooth.xml#Security-enum">QBluetooth::Secure</db:link>.</db:para>
<db:para>Android only supports two levels of security (secure and non-secure). If this flag is set to <db:link xlink:href="qbluetooth.xml#Security-enum">QBluetooth::NoSecurity</db:link> the socket object will not employ any authentication or encryption. Any other security flag combination will trigger a secure Bluetooth connection. This flag is set to <db:link xlink:href="qbluetooth.xml#Security-enum">QBluetooth::Secure</db:link> by default.</db:para>
<db:note>
<db:para>A secure connection requires a pairing between the two devices. On some platforms, the pairing is automatically initiated during the establishment of the connection. Other platforms require the application to manually trigger the pairing before attempting to connect.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#preferredSecurityFlags">preferredSecurityFlags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSocketDescriptor">
<db:title>bool QBluetoothSocket::setSocketDescriptor(int <db:emphasis>socketDescriptor</db:emphasis>, QBluetoothServiceInfo::Protocol <db:emphasis>socketType</db:emphasis>, QBluetoothSocket::SocketState <db:emphasis>socketState</db:emphasis> = ConnectedState, QIODevice::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>setSocketDescriptor</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>socketDescriptor</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QBluetoothServiceInfo::Protocol</db:type>
<db:parameter>socketType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QBluetoothSocket::SocketState</db:type>
<db:parameter>socketState</db:parameter>
<db:initializer>ConnectedState</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QIODevice::OpenMode</db:type>
<db:parameter>openMode</db:parameter>
<db:initializer>ReadWrite</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool setSocketDescriptor(int socketDescriptor, QBluetoothServiceInfo::Protocol socketType, QBluetoothSocket::SocketState socketState, QIODevice::OpenMode openMode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Set the socket to use <db:code role="parameter">socketDescriptor</db:code> with a type of <db:code role="parameter">socketType</db:code>, which is in state, <db:code role="parameter">socketState</db:code>, and mode, <db:code role="parameter">openMode</db:code>.</db:para>
<db:para>Returns true on success</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#socketDescriptor">socketDescriptor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSocketError">
<db:title>[protected] void QBluetoothSocket::setSocketError(QBluetoothSocket::SocketError <db:emphasis>error_</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSocketError</db:methodname>
<db:methodparam>
<db:type>QBluetoothSocket::SocketError</db:type>
<db:parameter>error_</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSocketError(QBluetoothSocket::SocketError error_)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the type of error that last occurred to <db:code role="parameter">error_</db:code>.</db:para>
</db:section>
<db:section xml:id="setSocketState">
<db:title>[protected] void QBluetoothSocket::setSocketState(QBluetoothSocket::SocketState <db:emphasis>state</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSocketState</db:methodname>
<db:methodparam>
<db:type>QBluetoothSocket::SocketState</db:type>
<db:parameter>state</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSocketState(QBluetoothSocket::SocketState state)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the socket state to <db:code role="parameter">state</db:code>.</db:para>
</db:section>
<db:section xml:id="socketDescriptor">
<db:title>int QBluetoothSocket::socketDescriptor() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>socketDescriptor</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int socketDescriptor() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the platform-specific socket descriptor, if available. This function returns -1 if the descriptor is not available or an error has occurred.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#setSocketDescriptor">setSocketDescriptor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="socketType">
<db:title>QBluetoothServiceInfo::Protocol QBluetoothSocket::socketType() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QBluetoothServiceInfo::Protocol</db:type>
<db:methodname>socketType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QBluetoothServiceInfo::Protocol socketType() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the socket type. The socket automatically adjusts to the protocol offered by the remote service.</db:para>
<db:para>Android only support <db:link xlink:href="qbluetoothserviceinfo.xml#Protocol-enum">RFCOMM</db:link> based sockets.</db:para>
</db:section>
<db:section xml:id="state">
<db:title>QBluetoothSocket::SocketState QBluetoothSocket::state() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QBluetoothSocket::SocketState</db:type>
<db:methodname>state</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QBluetoothSocket::SocketState state() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the current state of the socket.</db:para>
</db:section>
<db:section xml:id="stateChanged">
<db:title>void QBluetoothSocket::stateChanged(QBluetoothSocket::SocketState <db:emphasis>state</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>stateChanged</db:methodname>
<db:methodparam>
<db:type>QBluetoothSocket::SocketState</db:type>
<db:parameter>state</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void stateChanged(QBluetoothSocket::SocketState state)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the socket state changes to <db:code role="parameter">state</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbluetoothsocket.xml#connected">connected</db:link>()</db:member>
<db:member><db:link xlink:href="qbluetoothsocket.xml#disconnected">disconnected</db:link>()</db:member>
<db:member><db:link xlink:href="qbluetoothsocket.xml#state">state</db:link>()</db:member>
<db:member><db:link xlink:href="qbluetoothsocket.xml#SocketState-enum">QBluetoothSocket::SocketState</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="writeData">
<db:title>[override virtual protected] qint64 QBluetoothSocket::writeData(const char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>qint64</db:type>
<db:methodname>writeData</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>maxSize</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 writeData(const char *data, qint64 maxSize) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#writeData" role="function">QIODevice::writeData(const char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
</db:section>
</db:article>
