<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSet Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QSet</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.4.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qset.xml">QSet</db:link> class is a template class that provides a hash-table-based set.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSet</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QSet is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores values in an unspecified order and provides very fast lookup of the values. Internally, <db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt; is implemented as a <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link>.</db:para>
<db:para>Here's an example <db:link xlink:href="qset.xml">QSet</db:link> with <db:link xlink:href="qstring.xml">QString</db:link> values:</db:para>
<db:programlisting language="cpp">QSet&lt;QString&gt; set;
</db:programlisting>
<db:para>To insert a value into the set, use insert():</db:para>
<db:programlisting language="cpp">set.insert(&quot;one&quot;);
set.insert(&quot;three&quot;);
set.insert(&quot;seven&quot;);
</db:programlisting>
<db:para>Another way to insert items into the set is to use operator&lt;&lt;():</db:para>
<db:programlisting language="cpp">set &lt;&lt; &quot;twelve&quot; &lt;&lt; &quot;fifteen&quot; &lt;&lt; &quot;nineteen&quot;;
</db:programlisting>
<db:para>To test whether an item belongs to the set or not, use contains():</db:para>
<db:programlisting language="cpp">if (!set.contains(&quot;ninety-nine&quot;))
    ...
</db:programlisting>
<db:para>If you want to navigate through all the values stored in a <db:link xlink:href="qset.xml">QSet</db:link>, you can use an iterator. <db:link xlink:href="qset.xml">QSet</db:link> supports both <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qsetiterator.xml">QSetIterator</db:link> and <db:link xlink:href="qmutablesetiterator.xml">QMutableSetIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qset-iterator.xml">QSet::iterator</db:link> and <db:link xlink:href="qset-const-iterator.xml">QSet::const_iterator</db:link>). Here's how to iterate over a <db:link xlink:href="qset.xml">QSet</db:link>&lt;QWidget *&gt; using a Java-style iterator:</db:para>
<db:programlisting language="cpp">QSetIterator&lt;QWidget *&gt; i(set);
while (i.hasNext())
    qDebug() &lt;&lt; i.next();
</db:programlisting>
<db:para>Here's the same code, but using an STL-style iterator:</db:para>
<db:programlisting language="cpp">QSet&lt;QWidget *&gt;::const_iterator i = set.constBegin();
while (i != set.constEnd()) {
    qDebug() &lt;&lt; *i;
    ++i;
}
</db:programlisting>
<db:para><db:link xlink:href="qset.xml">QSet</db:link> is unordered, so an iterator's sequence cannot be assumed to be predictable. If ordering by key is required, use a <db:link xlink:href="qmap.xml">QMap</db:link>.</db:para>
<db:para>To navigate through a <db:link xlink:href="qset.xml">QSet</db:link>, you can also use <db:link xlink:href="containers.xml#the-foreach-keyword">foreach</db:link>:</db:para>
<db:programlisting language="cpp">QSet&lt;QString&gt; set;
...
foreach (const QString &amp;value, set)
    qDebug() &lt;&lt; value;
</db:programlisting>
<db:para>Items can be removed from the set using remove(). There is also a clear() function that removes all items.</db:para>
<db:para><db:link xlink:href="qset.xml">QSet</db:link>'s value data type must be an <db:link xlink:href="containers.xml">assignable data type</db:link>. You cannot, for example, store a QWidget as a value; instead, store a QWidget *. In addition, the type must provide operator==(), and there must also be a global <db:link xlink:href="qhash.xml#qHash">qHash</db:link>() function that returns a hash value for an argument of the key's type. See the <db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link> documentation for a list of types supported by <db:link xlink:href="qhash.xml#qHash">qHash</db:link>().</db:para>
<db:para>Internally, <db:link xlink:href="qset.xml">QSet</db:link> uses a hash table to perform lookups. The hash table automatically grows and shrinks to provide fast lookups without wasting memory. You can still control the size of the hash table by calling reserve(), if you already know approximately how many elements the <db:link xlink:href="qset.xml">QSet</db:link> will contain, but this isn't necessary to obtain good performance. You can also call capacity() to retrieve the hash table's size.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsetiterator.xml">QSetIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablesetiterator.xml">QMutableSetIterator</db:link></db:member>
<db:member><db:link xlink:href="qhash.xml#the-qhash-hashing-function">QHash</db:link></db:member>
<db:member><db:link xlink:href="qmap.xml">QMap</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QSet::ConstIterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qset-const-iterator.xml">QSet::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>[since 4.2] QSet::Iterator</db:title>
<db:para>Qt-style synonym for <db:link xlink:href="qset-iterator.xml">QSet::iterator</db:link>.</db:para>
<db:para>This typedef was introduced in Qt 4.2.</db:para>
</db:section>
<db:section xml:id="const_pointer-typedef">
<db:title>QSet::const_pointer</db:title>
<db:para>Typedef for const T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>QSet::const_reference</db:title>
<db:para>Typedef for const T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>QSet::difference_type</db:title>
<db:para>Typedef for const ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="key_type-typedef">
<db:title>QSet::key_type</db:title>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="pointer-typedef">
<db:title>QSet::pointer</db:title>
<db:para>Typedef for T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>QSet::reference</db:title>
<db:para>Typedef for T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>QSet::size_type</db:title>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>QSet::value_type</db:title>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
</db:article>
