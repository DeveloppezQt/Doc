<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSet Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QSet</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.11.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qset.xml">QSet</db:link> class is a template class that provides a hash-table-based set.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSet</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QSet is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It stores values in an unspecified order and provides very fast lookup of the values. Internally, <db:link xlink:href="qset.xml">QSet</db:link>&lt;T&gt; is implemented as a <db:link xlink:href="qhash.xml#qhash">QHash</db:link>.</db:para>
<db:para>Here's an example <db:link xlink:href="qset.xml">QSet</db:link> with <db:link xlink:href="qstring.xml">QString</db:link> values:</db:para>
<db:programlisting language="cpp">QSet&amp;lt;QString&amp;gt; set;
</db:programlisting>
<db:para>To insert a value into the set, use <db:link xlink:href="qset.xml#insert">insert</db:link>():</db:para>
<db:programlisting language="cpp">set.insert(&quot;one&quot;);
set.insert(&quot;three&quot;);
set.insert(&quot;seven&quot;);
</db:programlisting>
<db:para>Another way to insert items into the set is to use operator&lt;&lt;():</db:para>
<db:programlisting language="cpp">set &amp;lt;&amp;lt; &quot;twelve&quot; &amp;lt;&amp;lt; &quot;fifteen&quot; &amp;lt;&amp;lt; &quot;nineteen&quot;;
</db:programlisting>
<db:para>To test whether an item belongs to the set or not, use <db:link xlink:href="qset.xml#contains">contains</db:link>():</db:para>
<db:programlisting language="cpp">if (!set.contains(&quot;ninety-nine&quot;))
    ...
</db:programlisting>
<db:para>If you want to navigate through all the values stored in a <db:link xlink:href="qset.xml">QSet</db:link>, you can use an iterator. <db:link xlink:href="qset.xml">QSet</db:link> supports both <db:link xlink:href="containers.xml#java-style-iterators">Java-style iterators</db:link> (<db:link xlink:href="qsetiterator.xml">QSetIterator</db:link> and <db:link xlink:href="qmutablesetiterator.xml">QMutableSetIterator</db:link>) and <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qset-iterator.xml">QSet::iterator</db:link> and <db:link xlink:href="qset-const-iterator.xml">QSet::const_iterator</db:link>). Here's how to iterate over a <db:link xlink:href="qset.xml">QSet</db:link>&lt;<db:link xlink:href="qwidget.xml">QWidget</db:link> *&gt; using a Java-style iterator:</db:para>
<db:programlisting language="cpp">QSetIterator&amp;lt;QWidget *&amp;gt; i(set);
while (i.hasNext())
    qDebug() &amp;lt;&amp;lt; i.next();
</db:programlisting>
<db:para>Here's the same code, but using an STL-style iterator:</db:para>
<db:programlisting language="cpp">QSet&amp;lt;QWidget *&amp;gt;::const_iterator i = set.constBegin();
while (i != set.constEnd()) {
    qDebug() &amp;lt;&amp;lt; *i;
    ++i;
}
</db:programlisting>
<db:para><db:link xlink:href="qset.xml">QSet</db:link> is unordered, so an iterator's sequence cannot be assumed to be predictable. If ordering by key is required, use a <db:link xlink:href="qmap.xml">QMap</db:link>.</db:para>
<db:para>To navigate through a <db:link xlink:href="qset.xml">QSet</db:link>, you can also use <db:link xlink:href="containers.xml#foreach">foreach</db:link>:</db:para>
<db:programlisting language="cpp">QSet&amp;lt;QString&amp;gt; set;
...
foreach (const QString &amp;amp;value, set)
    qDebug() &amp;lt;&amp;lt; value;
</db:programlisting>
<db:para>Items can be removed from the set using <db:link xlink:href="qset.xml#remove">remove</db:link>(). There is also a <db:link xlink:href="qset.xml#clear">clear</db:link>() function that removes all items.</db:para>
<db:para><db:link xlink:href="qset.xml">QSet</db:link>'s value data type must be an <db:link xlink:href="containers.xml#assignable-data-type">assignable data type</db:link>. You cannot, for example, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> as a value; instead, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> *. In addition, the type must provide operator==(), and there must also be a global qHash() function that returns a hash value for an argument of the key's type. See the <db:link xlink:href="qhash.xml#qhash">QHash</db:link> documentation for a list of types supported by qHash().</db:para>
<db:para>Internally, <db:link xlink:href="qset.xml">QSet</db:link> uses a hash table to perform lookups. The hash table automatically grows and shrinks to provide fast lookups without wasting memory. You can still control the size of the hash table by calling <db:link xlink:href="qset.xml#reserve">reserve</db:link>(), if you already know approximately how many elements the <db:link xlink:href="qset.xml">QSet</db:link> will contain, but this isn't necessary to obtain good performance. You can also call <db:link xlink:href="qset.xml#capacity">capacity</db:link>() to retrieve the hash table's size.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsetiterator.xml">QSetIterator</db:link></db:member>
<db:member><db:link xlink:href="qmutablesetiterator.xml">QMutableSetIterator</db:link></db:member>
<db:member><db:link xlink:href="qhash.xml#qhash">QHash</db:link></db:member>
<db:member><db:link xlink:href="qmap.xml">QMap</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ConstIterator-typedef">
<db:title>QSet::ConstIterator</db:title>
<db:typedefsynopsis>
<db:typedefname>ConstIterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qset-const-iterator.xml">QSet::const_iterator</db:link>.</db:para>
</db:section>
<db:section xml:id="Iterator-typedef">
<db:title>[since 4.2] QSet::Iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>Iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Qt-style synonym for <db:link xlink:href="qset-iterator.xml">QSet::iterator</db:link>.</db:para>
<db:para>This typedef was introduced in Qt 4.2.</db:para>
</db:section>
<db:section xml:id="const_pointer-typedef">
<db:title>QSet::const_pointer</db:title>
<db:typedefsynopsis>
<db:typedefname>const_pointer</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for const T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>QSet::const_reference</db:title>
<db:typedefsynopsis>
<db:typedefname>const_reference</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for const T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reverse_iterator-typedef">
<db:title>[since 5.6] QSet::const_reverse_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>const_reverse_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The QSet::const_reverse_iterator typedef provides an STL-style const reverse iterator for <db:link xlink:href="qset.xml">QSet</db:link>.</db:para>
<db:para>It is simply a typedef for std::reverse_iterator&lt;QSet::const_iterator&gt;.</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#rbegin">QSet::rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#rend">QSet::rend</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#reverse_iterator-typedef">QSet::reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qset-const-iterator.xml">QSet::const_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>QSet::difference_type</db:title>
<db:typedefsynopsis>
<db:typedefname>difference_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for const ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="key_type-typedef">
<db:title>QSet::key_type</db:title>
<db:typedefsynopsis>
<db:typedefname>key_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="pointer-typedef">
<db:title>QSet::pointer</db:title>
<db:typedefsynopsis>
<db:typedefname>pointer</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>QSet::reference</db:title>
<db:typedefsynopsis>
<db:typedefname>reference</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reverse_iterator-typedef">
<db:title>[since 5.6] QSet::reverse_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>reverse_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The QSet::reverse_iterator typedef provides an STL-style non-const reverse iterator for <db:link xlink:href="qset.xml">QSet</db:link>.</db:para>
<db:para>It is simply a typedef for std::reverse_iterator&lt;QSet::iterator&gt;.</db:para>
<db:warning>
<db:para>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <db:link xlink:href="containers.xml#implicit-sharing-iterator-problem">Implicit sharing iterator problem</db:link>.</db:para>
</db:warning>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#rbegin">QSet::rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#rend">QSet::rend</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#const_reverse_iterator-typedef">QSet::const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qset-iterator.xml">QSet::iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>QSet::size_type</db:title>
<db:typedefsynopsis>
<db:typedefname>size_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>QSet::value_type</db:title>
<db:typedefsynopsis>
<db:typedefname>value_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="operator-2b-eq-1">
<db:title>QSet&lt;T&gt; &amp;QSet::operator+=(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="operator-lt-lt">QSet&lt;T&gt; &amp;QSet::operator&lt;&lt;(const T &amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="operator-7c-eq-1">QSet&lt;T&gt; &amp;QSet::operator|=(const T &amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Inserts a new item <db:code role="parameter">value</db:code> and returns a reference to the set. If <db:code role="parameter">value</db:code> already exists in the set, the set is left unchanged.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq">
<db:title>QSet&lt;T&gt; &amp;QSet::operator+=(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="operator-7c-eq">QSet&lt;T&gt; &amp;QSet::operator|=(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:bridgehead>
<db:para>Same as unite(<db:code role="parameter">other</db:code>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#operator-7c">operator|</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-and-eq">operator&amp;=</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator--eq">operator-=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b">
<db:title>QSet&lt;T&gt; QSet::operator+(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:bridgehead renderas="sect2" xml:id="operator-7c">QSet&lt;T&gt; QSet::operator|(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:bridgehead>
<db:para>Returns a new <db:link xlink:href="qset.xml">QSet</db:link> that is the union of this set and the <db:code role="parameter">other</db:code> set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#unite">unite</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-7c-eq">operator|=</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-and">operator&amp;</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-">operator-</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QSet">
<db:title>QSet::QSet()</db:title>
<db:constructorsynopsis>
<db:methodname>QSet</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#clear">clear</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QSet-1">
<db:title>[since 5.1] QSet::QSet(std::initializer_list&lt;T&gt; <db:emphasis>list</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QSet</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;T&gt;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet(std::initializer_list&lt;T&gt; list)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a set with a copy of each of the elements in the initializer list <db:code role="parameter">list</db:code>.</db:para>
<db:para>This function is only available if the program is being compiled in C++11 mode.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QSet::const_iterator QSet::begin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet::const_iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::const_iterator begin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> positioned at the first item in the set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>[since 4.2] QSet::iterator QSet::begin()</db:title>
<db:methodsynopsis>
<db:type>QSet::iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::iterator begin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a non-const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> positioned at the first item in the set.</db:para>
<db:para>This function was introduced in Qt 4.2.</db:para>
</db:section>
<db:section xml:id="capacity">
<db:title>int QSet::capacity() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>capacity</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int capacity() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of buckets in the set's internal hash table.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qset.xml">QSet</db:link>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the set, call <db:link xlink:href="qset.xml#size">size</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>[since 5.0] QSet::const_iterator QSet::cbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet::const_iterator</db:type>
<db:methodname>cbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::const_iterator cbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> positioned at the first item in the set.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[since 5.0] QSet::const_iterator QSet::cend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet::const_iterator</db:type>
<db:methodname>cend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::const_iterator cend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the set.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QSet::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements from the set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>QSet::const_iterator QSet::constBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet::const_iterator</db:type>
<db:methodname>constBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::const_iterator constBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> positioned at the first item in the set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QSet::const_iterator QSet::constEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet::const_iterator</db:type>
<db:methodname>constEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::const_iterator constEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constFind">
<db:title>[since 4.2] QSet::const_iterator QSet::constFind(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet::const_iterator</db:type>
<db:methodname>constFind</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::const_iterator constFind(const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const iterator positioned at the item <db:code role="parameter">value</db:code> in the set. If the set contains no item <db:code role="parameter">value</db:code>, the function returns <db:link xlink:href="qset.xml#constEnd">constEnd</db:link>().</db:para>
<db:para>This function was introduced in Qt 4.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#find">find</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>bool QSet::contains(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the set contains item <db:code role="parameter">value</db:code>; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#find">find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains-1">
<db:title>[since 4.6] bool QSet::contains(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(const QSet&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the set contains all items from the <db:code role="parameter">other</db:code> set; otherwise returns false.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#find">find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>int QSet::count() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>count</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int count() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Same as <db:link xlink:href="qset.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="crbegin">
<db:title>[since 5.6] QSet::const_reverse_iterator QSet::crbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet::const_reverse_iterator</db:type>
<db:methodname>crbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::const_reverse_iterator crbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first item in the set, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="crend">
<db:title>[since 5.6] QSet::const_reverse_iterator QSet::crend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet::const_reverse_iterator</db:type>
<db:methodname>crend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::const_reverse_iterator crend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to one past the last item in the set, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="empty">
<db:title>bool QSet::empty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>empty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool empty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the set is empty. This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qset.xml#isEmpty">isEmpty</db:link>().</db:para>
</db:section>
<db:section xml:id="end">
<db:title>QSet::const_iterator QSet::end() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet::const_iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::const_iterator end() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> positioned at the imaginary item after the last item in the set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#constEnd">constEnd</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#begin">begin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>[since 4.2] QSet::iterator QSet::end()</db:title>
<db:methodsynopsis>
<db:type>QSet::iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::iterator end()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a non-const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the set.</db:para>
<db:para>This function was introduced in Qt 4.2.</db:para>
</db:section>
<db:section xml:id="erase">
<db:title>[since 5.7] QSet::iterator QSet::erase(QSet::const_iterator <db:emphasis>pos</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSet::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QSet::const_iterator</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::iterator erase(QSet::const_iterator pos)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the item at the iterator position <db:code role="parameter">pos</db:code> from the set, and returns an iterator positioned at the next item in the set.</db:para>
<db:para>Unlike <db:link xlink:href="qset.xml#remove">remove</db:link>(), this function never causes <db:link xlink:href="qset.xml">QSet</db:link> to rehash its internal data structure. This means that it can safely be called while iterating, and won't affect the order of items in the set.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#find">find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase-1">
<db:title>[since 4.2] QSet::iterator QSet::erase(QSet::iterator <db:emphasis>pos</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSet::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QSet::iterator</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::iterator erase(QSet::iterator pos)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 4.2.</db:para>
</db:section>
<db:section xml:id="find">
<db:title>[since 4.2] QSet::const_iterator QSet::find(const T &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet::const_iterator</db:type>
<db:methodname>find</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::const_iterator find(const T &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const iterator positioned at the item <db:code role="parameter">value</db:code> in the set. If the set contains no item <db:code role="parameter">value</db:code>, the function returns <db:link xlink:href="qset.xml#constEnd">constEnd</db:link>().</db:para>
<db:para>This function was introduced in Qt 4.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#constFind">constFind</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find-1">
<db:title>[since 4.2] QSet::iterator QSet::find(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSet::iterator</db:type>
<db:methodname>find</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::iterator find(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a non-const iterator positioned at the item <db:code role="parameter">value</db:code> in the set. If the set contains no item <db:code role="parameter">value</db:code>, the function returns <db:link xlink:href="qset.xml#end">end</db:link>().</db:para>
<db:para>This function was introduced in Qt 4.2.</db:para>
</db:section>
<db:section xml:id="fromList">
<db:title>[static] QSet&lt;T&gt; QSet::fromList(const QList&lt;T&gt; &amp;<db:emphasis>list</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QSet&lt;T&gt;</db:type>
<db:methodname>fromList</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet&lt;T&gt; fromList(const QList&lt;T&gt; &amp;list)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a new <db:link xlink:href="qset.xml">QSet</db:link> object containing the data contained in <db:code role="parameter">list</db:code>. Since <db:link xlink:href="qset.xml">QSet</db:link> doesn't allow duplicates, the resulting <db:link xlink:href="qset.xml">QSet</db:link> might be smaller than the <db:code role="parameter">list</db:code>, because <db:link xlink:href="qlist.xml">QList</db:link> can contain duplicates.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QStringList list;
list &amp;lt;&amp;lt; &quot;Julia&quot; &amp;lt;&amp;lt; &quot;Mike&quot; &amp;lt;&amp;lt; &quot;Mike&quot; &amp;lt;&amp;lt; &quot;Julia&quot; &amp;lt;&amp;lt; &quot;Julia&quot;;

QSet&amp;lt;QString&amp;gt; set = QSet&amp;lt;QString&amp;gt;::fromList(list);
set.contains(&quot;Julia&quot;);  // returns true
set.contains(&quot;Mike&quot;);   // returns true
set.size();             // returns 2
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#toList">toList</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#toSet">QList::toSet</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert">
<db:title>QSet::iterator QSet::insert(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSet::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::iterator insert(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts item <db:code role="parameter">value</db:code> into the set, if <db:code role="parameter">value</db:code> isn't already in the set, and returns an iterator pointing at the inserted item.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#remove">remove</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="intersect">
<db:title>QSet&lt;T&gt; &amp;QSet::intersect(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSet&lt;T&gt; &amp;</db:type>
<db:methodname>intersect</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet&lt;T&gt; &amp; intersect(const QSet&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all items from this set that are not contained in the <db:code role="parameter">other</db:code> set. A reference to this set is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#intersects">intersects</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-and-eq">operator&amp;=</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#unite">unite</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#subtract">subtract</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="intersects">
<db:title>[since 5.6] bool QSet::intersects(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>intersects</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool intersects(const QSet&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this set has at least one item in common with <db:code role="parameter">other</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#intersect">intersect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QSet::isEmpty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isEmpty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isEmpty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the set contains no elements; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rbegin">
<db:title>[since 5.6] QSet::reverse_iterator QSet::rbegin()</db:title>
<db:methodsynopsis>
<db:type>QSet::reverse_iterator</db:type>
<db:methodname>rbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::reverse_iterator rbegin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first item in the set, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rbegin-1">
<db:title>[since 5.6] QSet::const_reverse_iterator QSet::rbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet::const_reverse_iterator</db:type>
<db:methodname>rbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::const_reverse_iterator rbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="remove">
<db:title>bool QSet::remove(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool remove(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes any occurrence of item <db:code role="parameter">value</db:code> from the set. Returns true if an item was actually removed; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend">
<db:title>[since 5.6] QSet::reverse_iterator QSet::rend()</db:title>
<db:methodsynopsis>
<db:type>QSet::reverse_iterator</db:type>
<db:methodname>rend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::reverse_iterator rend()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to one past the last item in the set, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend-1">
<db:title>[since 5.6] QSet::const_reverse_iterator QSet::rend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet::const_reverse_iterator</db:type>
<db:methodname>rend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet::const_reverse_iterator rend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="reserve">
<db:title>void QSet::reserve(int <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>reserve</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void reserve(int size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Ensures that the set's internal hash table consists of at least <db:code role="parameter">size</db:code> buckets.</db:para>
<db:para>This function is useful for code that needs to build a huge set and wants to avoid repeated reallocation. For example:</db:para>
<db:programlisting language="cpp">QSet&amp;lt;QString&amp;gt; set;
set.reserve(20000);
for (int i = 0; i &amp;lt; 20000; ++i)
    set.insert(values[i]);
</db:programlisting>
<db:para>Ideally, <db:code role="parameter">size</db:code> should be slightly more than the maximum number of elements expected in the set. <db:code role="parameter">size</db:code> doesn't have to be prime, because <db:link xlink:href="qset.xml">QSet</db:link> will use a prime number internally anyway. If <db:code role="parameter">size</db:code> is an underestimate, the worst that will happen is that the <db:link xlink:href="qset.xml">QSet</db:link> will be a bit slower.</db:para>
<db:para>In general, you will rarely ever need to call this function. <db:link xlink:href="qset.xml">QSet</db:link>'s internal hash table automatically shrinks or grows to provide good performance without wasting too much memory.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#squeeze">squeeze</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>int QSet::size() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int size() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of items in the set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#count">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="squeeze">
<db:title>void QSet::squeeze()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>squeeze</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void squeeze()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reduces the size of the set's internal hash table to save memory.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qset.xml">QSet</db:link>'s memory usage. In general, you will rarely ever need to call this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="subtract">
<db:title>QSet&lt;T&gt; &amp;QSet::subtract(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSet&lt;T&gt; &amp;</db:type>
<db:methodname>subtract</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet&lt;T&gt; &amp; subtract(const QSet&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all items from this set that are contained in the <db:code role="parameter">other</db:code> set. Returns a reference to this set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#operator--eq">operator-=</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#unite">unite</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#intersect">intersect</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QSet::swap(QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QSet&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QSet&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps set <db:code role="parameter">other</db:code> with this set. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="toList">
<db:title>QList&lt;T&gt; QSet::toList() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>toList</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; toList() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a new <db:link xlink:href="qlist.xml">QList</db:link> containing the elements in the set. The order of the elements in the <db:link xlink:href="qlist.xml">QList</db:link> is undefined.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QSet&amp;lt;QString&amp;gt; set;
set &amp;lt;&amp;lt; &quot;red&quot; &amp;lt;&amp;lt; &quot;green&quot; &amp;lt;&amp;lt; &quot;blue&quot; &amp;lt;&amp;lt; ... &amp;lt;&amp;lt; &quot;black&quot;;

QList&amp;lt;QString&amp;gt; list = set.toList();
qSort(list);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#fromList">fromList</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#fromSet">QList::fromSet</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unite">
<db:title>QSet&lt;T&gt; &amp;QSet::unite(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSet&lt;T&gt; &amp;</db:type>
<db:methodname>unite</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet&lt;T&gt; &amp; unite(const QSet&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Each item in the <db:code role="parameter">other</db:code> set that isn't already in this set is inserted into this set. A reference to this set is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#operator-7c-eq">operator|=</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#intersect">intersect</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#subtract">subtract</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="values">
<db:title>QList&lt;T&gt; QSet::values() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;T&gt;</db:type>
<db:methodname>values</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;T&gt; values() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a new <db:link xlink:href="qlist.xml">QList</db:link> containing the elements in the set. The order of the elements in the <db:link xlink:href="qlist.xml">QList</db:link> is undefined.</db:para>
<db:para>This is the same as <db:link xlink:href="qset.xml#toList">toList</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#fromList">fromList</db:link>()</db:member>
<db:member><db:link xlink:href="qlist.xml#fromSet">QList::fromSet</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QSet::operator!=(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QSet&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the <db:code role="parameter">other</db:code> set is not equal to this set; otherwise returns false.</db:para>
<db:para>Two sets are considered equal if they contain the same elements.</db:para>
<db:para>This function requires the value type to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-and">
<db:title>QSet&lt;T&gt; QSet::operator&amp;(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet&lt;T&gt;</db:type>
<db:methodname>operator&amp;</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet&lt;T&gt; operator&amp;(const QSet&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a new <db:link xlink:href="qset.xml">QSet</db:link> that is the intersection of this set and the <db:code role="parameter">other</db:code> set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#intersect">intersect</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-and-eq">operator&amp;=</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-7c">operator|</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-">operator-</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-and-eq">
<db:title>QSet&lt;T&gt; &amp;QSet::operator&amp;=(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSet&lt;T&gt; &amp;</db:type>
<db:methodname>operator&amp;=</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet&lt;T&gt; &amp; operator&amp;=(const QSet&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Same as intersect(<db:code role="parameter">other</db:code>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#operator-and">operator&amp;</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-7c-eq">operator|=</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator--eq">operator-=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-and-eq-1">
<db:title>QSet&lt;T&gt; &amp;QSet::operator&amp;=(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSet&lt;T&gt; &amp;</db:type>
<db:methodname>operator&amp;=</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet&lt;T&gt; &amp; operator&amp;=(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as intersect(<db:emphasis>other</db:emphasis>), if we consider <db:emphasis>other</db:emphasis> to be a set that contains the singleton <db:code role="parameter">value</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-">
<db:title>QSet&lt;T&gt; QSet::operator-(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet&lt;T&gt;</db:type>
<db:methodname>operator-</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet&lt;T&gt; operator-(const QSet&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a new <db:link xlink:href="qset.xml">QSet</db:link> that is the set difference of this set and the <db:code role="parameter">other</db:code> set, i.e., this set - <db:code role="parameter">other</db:code> set.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#subtract">subtract</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator--eq">operator-=</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-7c">operator|</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-and">operator&amp;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator--eq">
<db:title>QSet&lt;T&gt; &amp;QSet::operator-=(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSet&lt;T&gt; &amp;</db:type>
<db:methodname>operator-=</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet&lt;T&gt; &amp; operator-=(const QSet&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Same as subtract(<db:code role="parameter">other</db:code>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#operator-">operator-</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-7c-eq">operator|=</db:link>()</db:member>
<db:member><db:link xlink:href="qset.xml#operator-and-eq">operator&amp;=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator--eq-1">
<db:title>QSet&lt;T&gt; &amp;QSet::operator-=(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSet&lt;T&gt; &amp;</db:type>
<db:methodname>operator-=</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet&lt;T&gt; &amp; operator-=(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the occurrence of item <db:code role="parameter">value</db:code> from the set, if it is found, and returns a reference to the set. If the <db:code role="parameter">value</db:code> is not contained the set, nothing is removed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QSet::operator==(const QSet&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QSet&lt;T&gt; &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the <db:code role="parameter">other</db:code> set is equal to this set; otherwise returns false.</db:para>
<db:para>Two sets are considered equal if they contain the same elements.</db:para>
<db:para>This function requires the value type to implement operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qset.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="operator-lt-lt-1">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QSet&lt;T&gt; &amp;<db:emphasis>set</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>out</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QSet&lt;T&gt; &amp;</db:type>
<db:parameter>set</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&lt;&lt;(QDataStream &amp;out, const QSet&lt;T&gt; &amp;set)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the <db:code role="parameter">set</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:para>This function requires the value type to implement operator&lt;&lt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QSet&lt;T&gt; &amp;<db:emphasis>set</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>in</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSet&lt;T&gt; &amp;</db:type>
<db:parameter>set</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&gt;&gt;(QDataStream &amp;in, QSet&lt;T&gt; &amp;set)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a set from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">set</db:code>.</db:para>
<db:para>This function requires the value type to implement operator&gt;&gt;().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Format of the QDataStream operators</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
