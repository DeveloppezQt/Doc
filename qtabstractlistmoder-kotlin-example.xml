<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Exposing QtAbstractListModel to QML</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Uses the <db:link xlink:href="">QtAbstractListModel Android Class</db:link> to share data between Android code and a QML view.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The Qt Quick for Android API examples are provided as Android Studio projects. The project folders are found in your Qt install location.</db:para>
<db:para>For example, under the default Windows install path, they are found here:</db:para>
<db:programlisting language="cpp" role="bad">C:\Qt\Examples\Qt-/1\platforms\android
</db:programlisting>
<db:section xml:id="overview">
<db:title>Overview</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtabstractlistmodel_portrait.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>This example consists of two separate projects: A QML project and a Kotlin-based Android project which will host and display the QML content. It shows how to use QtAbstractListModel to share data from the Android side to the QML view which displays the data using a <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link>.</db:para>
</db:section>
<db:section xml:id="running-the-example">
<db:title>Running the example</db:title>
<db:para>To run this example, you need Android Studio and a <db:link xlink:href="">Qt for Android</db:link> installation.</db:para>
<db:para>The <db:link xlink:href="">Qt Gradle Plugin</db:link> will be used to build the QML project during the Android project build process. For this, the example has some plugin configuration in the app-level build.gradle.kts file which may need to be modified if the plugin cannot, for example, find the Qt kit directory.</db:para>
<db:programlisting language="cpp">QtBuild {
    // Relative for Qt (Installer or MaintenanceTool) installations.
    qtPath = file(&quot;../../../../../../../6.9.1&quot;)
    projectPath = file(&quot;../../qtabstractlistmodel&quot;)
}
</db:programlisting>
<db:para>For further configuration of the plugin, please refer to the <db:link xlink:href="">Qt Gradle Plugin documentation</db:link>.</db:para>
</db:section>
<db:section xml:id="qml-project">
<db:title>QML project</db:title>
<db:para>The QML project is quite simple, it defines a data model as a property of the root object and some UI elements to display the data from that model.</db:para>
<db:programlisting language="qml">Rectangle {
    id: mainRectangle

    property AbstractItemModel dataModel
</db:programlisting>
<db:para>To display the data from the model, a <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> is created. The <db:code>model</db:code> property is then set to the data model declared earlier.</db:para>
<db:programlisting language="qml">    ListView {
        id: listView

        model: mainRectangle.dataModel
</db:programlisting>
<db:para>In order to display the data model, the <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> needs a delegate which will be instantiated for each item in the data model. In this case, the delegate will be a <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link> that holds two <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> elements in a <db:link xlink:href="qml-qtquick-column.xml">Column</db:link>, displaying the data from each element in the data model.</db:para>
<db:programlisting language="qml">        delegate: Rectangle {
            required property var model

            width: listView.width
            height: textColumn.height + (2 * textColumn.spacing)
            color: &quot;#2CDE85&quot;
            radius: 25

            Column {
                id: textColumn

                height: idText.height + rowText.height + spacing
                spacing: 15

                anchors {
                    verticalCenter: parent.verticalCenter
                    left: parent.left
                    right: parent.right
                    leftMargin: 20
                    rightMargin: 20
                }

                Text {
                    id: idText

                    color: &quot;#00414A&quot;
                    text: model.id
                    font.pixelSize: 36
                    font.bold: true
                }

                Text {
                    id: rowText

                    color: &quot;#00414A&quot;
                    text: model.row
                    font.pixelSize: 36
                    font.bold: true
                }
            }
        }
</db:programlisting>
</db:section>
<db:section xml:id="kotlin-project">
<db:title>Kotlin project</db:title>
<db:para>The Android side consists of a single <db:link xlink:href="https://developer.android.com/reference/android/app/Activity">Activity</db:link> and the definition for the data model used earlier in the QML view.</db:para>
<db:section xml:id="data-model">
<db:title>Data model</db:title>
<db:para>The data model <db:code>MyListModel</db:code> is a child class of QtAbstractListModel, with <db:code>ArrayList&lt;String&gt;</db:code> as the internal storage system for data. In the initializer block of <db:code>MyListModel</db:code>, it generates some random data for the list.</db:para>
<db:programlisting language="cpp">class MyListModel : QtAbstractListModel() {
    private val m_dataList = ArrayList&lt;String&gt;()

    init {
        synchronized(this) {
            for (row in 0..4) {
                m_dataList.add(UUID.randomUUID().toString())
            }
        }
    }
</db:programlisting>
<db:para>Each item in the model has a set of data elements associated with it, each with its own role. Custom implementations of QtAbstractItemModel must define a custom role for each data element. Each role has an associated <db:link xlink:href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/">Int</db:link> value, which is used when retrieving the data, and a <db:link xlink:href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/">String</db:link> value, which specifies the name of the data element when used from QML.</db:para>
<db:programlisting language="cpp">    @Synchronized
    override fun roleNames(): HashMap&lt;Int, String&gt; {
        val m_roles = HashMap&lt;Int, String&gt;()
        m_roles[DataRole.UUID.value()] = &quot;id&quot;
        m_roles[DataRole.Row.value()] = &quot;row&quot;
        return m_roles
    }
</db:programlisting>
<db:para>While the <db:code>Int</db:code> values in the <db:code>&quot;roleNames()&quot;</db:code> method may be hard-coded, this example specifies a custom enum class <db:code>DataRole</db:code> within <db:code>MyListModel</db:code>, which is used when referring to these values. In this example, we define two roles: UUID and Row.</db:para>
<db:programlisting language="cpp">    private enum class DataRole(val m_value: Int) {
        UUID(0),
        Row(1);

        fun value(): Int {
            return m_value
        }

        companion object {
            fun valueOf(value: Int): DataRole? {
                val values = entries.toTypedArray()
                if (0 &lt;= value &amp;&amp; value &lt; values.size) return values[value]
                return null
            }
        }
    }
</db:programlisting>
<db:para>When it comes to returning data from the data model, the class must override the <db:code>&quot;QtAbstractListModel::data()&quot;</db:code> method. This method takes two parameters: QtModelIndex and <db:code>Int</db:code>, which refer to the index and role of the data element, respectively.</db:para>
<db:para>In <db:code>&quot;MyDataModel::data()&quot;</db:code>, the <db:code>UUID</db:code> role returns the data from the given index in the internal data, while the <db:code>Row</db:code> role returns the row of the requested element.</db:para>
<db:note>
<db:para>This method, along with some others, is annotated with a <db:link xlink:href="">@Synchronized</db:link> tag. This is due to calls to these methods originating from the Qt thread and accessing the underlying data possibly at the same time as requests from the Android thread via the <db:code>&quot;addRow()&quot;</db:code> and <db:code>&quot;removeRow()&quot;</db:code> methods.</db:para>
</db:note>
<db:programlisting language="cpp">    @Synchronized
    override fun data(qtModelIndex: QtModelIndex, role: Int): Any {
        return when (DataRole.valueOf(role)) {
            DataRole.UUID -&gt; &quot;UUID: &quot; + m_dataList[qtModelIndex.row()]
            DataRole.Row -&gt; &quot;Row: &quot; + qtModelIndex.row()
            else -&gt; &quot;&quot;
        }
    }
</db:programlisting>
<db:para>To allow outside actors to manipulate the QtAbstractItemModel, the example adds two additional methods to <db:code>MyDataModel</db:code>. To add data to the row, it has the <db:code>&quot;addRow()&quot;</db:code> method; to remove data, there is the <db:code>&quot;removeRow()&quot;</db:code> method. These are used from the main activity.</db:para>
<db:programlisting language="cpp">    @Synchronized
    fun addRow() {
        beginInsertRows(QtModelIndex(), m_dataList.size, m_dataList.size)
        m_dataList.add(UUID.randomUUID().toString())
        endInsertRows()
    }
    @Synchronized
    fun removeRow() {
        if (!m_dataList.isEmpty()) {
            beginRemoveRows(QtModelIndex(), m_dataList.size - 1, m_dataList.size - 1)
            m_dataList.removeAt(m_dataList.size - 1)
            endRemoveRows()
        }
    }
</db:programlisting>
</db:section>
<db:section xml:id="main-activity">
<db:title>Main activity</db:title>
<db:para>The <db:code>MainActivity</db:code> class is a simple Kotlin-based Activity but also implements the <db:link xlink:href="">interface QtQmlStatusChangeListener</db:link> to listen to QML loading status events. It also stores the <db:code>QtQuickViewContent</db:code> object for the main view of the QML application and an instance of the data model detailed above.</db:para>
<db:programlisting language="cpp">class MainActivity : AppCompatActivity(), QtQmlStatusChangeListener {
    private val m_mainQmlContent: Main = Main()
    private val m_listModel = MyListModel()
</db:programlisting>
<db:para>When creating the main Activity of the application, the example first creates a <db:link xlink:href="qtquickview-android-class.xml#qtquickview">QtQuickView</db:link> and places it into the view hierarchy.</db:para>
<db:programlisting language="cpp">        val qtQuickView: QtQuickView = QtQuickView(this)

        val params: ViewGroup.LayoutParams = FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT
        )
        val qmlFrameLayout: FrameLayout = findViewById&lt;FrameLayout&gt;(R.id.qmlFrame)
        qmlFrameLayout.addView(qtQuickView, params)
</db:programlisting>
<db:para>After adding the QtQuickView into the UI, the example finds the buttons that are used to manipulate the data model and sets some click listeners to call <db:code>addRow()</db:code> and <db:code>removeRow()</db:code> on the member data model.</db:para>
<db:programlisting language="cpp">        val addRowAtEndButton: Button = findViewById&lt;Button&gt;(R.id.addRow)
        val removeRowFromEndButton: Button = findViewById&lt;Button&gt;(R.id.removeRow)
        addRowAtEndButton.setOnClickListener { _: View? -&gt;
            m_listModel.addRow()
        }
        removeRowFromEndButton.setOnClickListener { _: View? -&gt;
            m_listModel.removeRow()
        }
</db:programlisting>
<db:para>Once the UI setup and listeners are done, the QML component can be prepared and loaded. The example sets the <db:code>MainActivity</db:code> as a listener for the status change signal of the QML component and tells <db:code>QtQuickView</db:code> to load the QML component.</db:para>
<db:programlisting language="cpp">        m_mainQmlContent.setStatusChangeListener(this)
        qtQuickView.loadContent(m_mainQmlContent)
</db:programlisting>
<db:para>Finally, once the QML component is successfully loaded, the example assigns the value of the MyDataModel instance into the <db:code>dataModel</db:code> property in the QML component.</db:para>
<db:programlisting language="cpp">    override fun onStatusChanged(qtQmlStatus: QtQmlStatus) {
        if (qtQmlStatus === QtQmlStatus.READY) {
            m_mainQmlContent.setDataModel(m_listModel)
        }
    }
</db:programlisting>
</db:section>
</db:section>
</db:article>
