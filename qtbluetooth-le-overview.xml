<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Bluetooth Low Energy Overview</db:title>
<db:productname>QtBluetooth</db:productname>
<db:edition>Qt 5.5.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Bluetooth Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Qt Bluetooth Low Energy API enables communication between Bluetooth Low Energy devices.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The Qt Bluetooth Low Energy API was introduced by Qt 5.4. Since Qt 5.5 the API is final and a compatibility guarantee is given for future releases. At the moment, Qt supports the Bluetooth Low Energy central role. For more details on this limitation see below.</db:para>
<db:section xml:id="what-is-bluetooth-low-energy">
<db:title>What Is Bluetooth Low Energy</db:title>
<db:para>Bluetooth Low Energy, also known as Bluetooth Smart, is a wireless computer network technology, which was officially introduced in 2011. It works on the same 2.4 GHz frequency as ”classic” Bluetooth. The main difference is, as stated by its technology name, low energy consumption. It provides an opportunity for Bluetooth Low Energy devices to operate for months, even years, on coin-cell batteries. The technology was introduced by <db:link xlink:href="https://www.bluetooth.org/en-us/specification/adopted-specifications">Bluetooth v4.0</db:link>. Devices which support this technology are called Bluetooth Smart Ready Devices. The key features of the technology are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Ultra-low peak, average and idle mode power consumption</db:para>
</db:listitem>
<db:listitem>
<db:para>Ability to run for years on standard, coin-cell batteries</db:para>
</db:listitem>
<db:listitem>
<db:para>Low cost</db:para>
</db:listitem>
<db:listitem>
<db:para>Multi-vendor interoperability</db:para>
</db:listitem>
<db:listitem>
<db:para>Enhanced range</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Bluetooth Low Energy uses a client-server architecture. The server (also known as peripheral) offers services such as temperature or heart rate and advertises them. The client (known as central device) connects to the server and reads the values advertised by the server. An example might be an apartment with Bluetooth Smart Ready sensors such as a thermostat, humidity or pressure sensor. Those sensors are peripheral devices advertising the environment values of the apartment. At the same time a mobile phone or computer might connect to those sensors, retrieve their values and present them as part of a larger environment control application to the user.</db:para>
</db:section>
<db:section xml:id="basic-service-structure">
<db:title>Basic Service Structure</db:title>
<db:para>Bluetooth Low Energy is based on two protocols: ATT (Attribute Protocol) and GATT (Generic Attribute Profile). They specify the communication layers used by every Bluetooth Smart Ready device.</db:para>
<db:section xml:id="att-protocol">
<db:title>ATT Protocol</db:title>
<db:para>The basic building block of ATT is an <db:emphasis>attribute</db:emphasis>. Each attribute consists of three elements:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>a value - the payload or desirable piece of information</db:para>
</db:listitem>
<db:listitem>
<db:para>a UUID - the type of attribute (used by GATT)</db:para>
</db:listitem>
<db:listitem>
<db:para>a 16-bit handle - a unique identifier for the attribute</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The server stores the attributes and the client uses the ATT protocol to read and write values on the server.</db:para>
</db:section>
<db:section xml:id="gatt-profile">
<db:title>GATT Profile</db:title>
<db:para>GATT defines grouping for a set of attributes by applying a meaning to predefined UUIDs. The table below shows an example service exposing a heart rate on a particular day. The actual values are stored inside the two characteristics:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Handle</db:para>
</db:th>
<db:th>
<db:para>UUID</db:para>
</db:th>
<db:th>
<db:para>Value</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>0x0001</db:para>
</db:td>
<db:td>
<db:para>0x2800</db:para>
</db:td>
<db:td>
<db:para>UUID 0x180D</db:para>
</db:td>
<db:td>
<db:para>Begin Heart Rate service</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>0x0002</db:para>
</db:td>
<db:td>
<db:para>0x2803</db:para>
</db:td>
<db:td>
<db:para>UUID 0x2A37, Value handle: 0x0003</db:para>
</db:td>
<db:td>
<db:para>Characteristic of type <db:emphasis>Heart Rate Measurement (HRM)</db:emphasis></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>0x0003</db:para>
</db:td>
<db:td>
<db:para>0x2A37</db:para>
</db:td>
<db:td>
<db:para>65 bpm</db:para>
</db:td>
<db:td>
<db:para>Heart rate value</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>0x0004</db:para>
</db:td>
<db:td>
<db:para>0x2803</db:para>
</db:td>
<db:td>
<db:para>UUID 0x2A08, Value handle: 0x0006</db:para>
</db:td>
<db:td>
<db:para>Characteristic of type Date Time</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>0x0005</db:para>
</db:td>
<db:td>
<db:para>0x2A08</db:para>
</db:td>
<db:td>
<db:para>18/08/2014 11:00</db:para>
</db:td>
<db:td>
<db:para>Date and Time of the measurement</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>0x0006</db:para>
</db:td>
<db:td>
<db:para>0x2800</db:para>
</db:td>
<db:td>
<db:para>UUID xxxxxx</db:para>
</db:td>
<db:td>
<db:para>Begin next service</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>...</db:para>
</db:td>
<db:td>
<db:para>...</db:para>
</db:td>
<db:td>
<db:para>...</db:para>
</db:td>
<db:td>
<db:para>...</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>GATT specifies that the above used UUID <db:code>0x2800</db:code> marks the begin of a service definition. Every attribute following <db:code>0x2800</db:code> is part of the service until the next <db:code>0x2800</db:code> or the end is encountered. In similar ways the well known UUID <db:code>0x2803</db:code> states that a characteristic is to be found and each of the characteristics has a type defining the nature of the value. The example above uses the UUIDs <db:code>0x2A08</db:code> (Date Time) and <db:code>0x2A37</db:code> (Heart Rate Measurement). Each of the above UUIDs is defined by the <db:link xlink:href="https://bluetooth.org">Bluetooth Special Interest Group</db:link>. and can be found in the <db:link xlink:href="https://developer.bluetooth.org/gatt/Pages/default.aspx">GATT specification</db:link>. While it is advisable to use pre-defined UUIDs where available it is entirely possible to use new and not yet used UUIDs for characteristic and service types.</db:para>
<db:para>In general, each service may consist of one or more characteristics. A characteristic contains data and can be further described by descriptors, which provide additional information or means of manipulating the characteristic. All services, characteristics and descriptors are recognized by their 128-bit UUID. Finally, it is possible to include services inside of services (see picture below).</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/peripheral-structure.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
</db:section>
<db:section xml:id="using-qt-bluetooth-low-energy-api">
<db:title>Using Qt Bluetooth Low Energy API</db:title>
<db:para>This section describes how to use the Bluetooth Low Energy API provided by Qt. Currently the API permits creating connections to peripheral devices, discovering their services, as well as reading and writing data stored on the device. The example code below is taken from the <db:link xlink:href="qtbluetooth-heartlistener-example.xml">Heart Listener</db:link> example.</db:para>
<db:section xml:id="establishing-a-connection">
<db:title>Establishing a Connection</db:title>
<db:para>To be able to read and write the characteristics of the Bluetooth Low Energy peripheral device, it is necessary to find and connect the device. This requires the peripheral device to advertise its presence and services. We start the device discovery with the help of the QBluetoothDeviceDiscoveryAgent class. We connect to its <db:link xlink:href="">QBluetoothDeviceDiscoveryAgent::deviceDiscovered()</db:link> signal and start the search with <db:link xlink:href="">start()</db:link>:</db:para>
<db:programlisting language="cpp">m_deviceDiscoveryAgent = new QBluetoothDeviceDiscoveryAgent(this);

connect(m_deviceDiscoveryAgent, SIGNAL(deviceDiscovered(const QBluetoothDeviceInfo&amp;)),
        this, SLOT(addDevice(const QBluetoothDeviceInfo&amp;)));
connect(m_deviceDiscoveryAgent, SIGNAL(error(QBluetoothDeviceDiscoveryAgent::Error)),
        this, SLOT(deviceScanError(QBluetoothDeviceDiscoveryAgent::Error)));
connect(m_deviceDiscoveryAgent, SIGNAL(finished()), this, SLOT(scanFinished()));
m_deviceDiscoveryAgent-&gt;start();
</db:programlisting>
<db:para>Since we are only interested in Low Energy devices we filter the device type within the receiving slot. The device type can be ascertained using the <db:link xlink:href="">QBluetoothDeviceInfo::coreConfigurations()</db:link> flag:</db:para>
<db:programlisting language="cpp">void HeartRate::addDevice(const QBluetoothDeviceInfo &amp;device)
{
    if (device.coreConfigurations() &amp; QBluetoothDeviceInfo::LowEnergyCoreConfiguration) {
        qWarning() &lt;&lt; &quot;Discovered LE Device name: &quot; &lt;&lt; device.name() &lt;&lt; &quot; Address: &quot;
                   &lt;&lt; device.address().toString();
    }
    //...
}
</db:programlisting>
<db:para>Once the address of the peripheral device is known we use the QLowEnergyController class. This class is the entry point for all Bluetooth Low Energy development. The constructor of the class accepts the remote device's QBluetoothAddress. Finally we set up the customary slots and directly connect to the device using <db:link xlink:href="">connectToDevice()</db:link>:</db:para>
<db:programlisting language="cpp">m_control = new QLowEnergyController(m_currentDevice.getDevice(), this);
connect(m_control, SIGNAL(serviceDiscovered(QBluetoothUuid)),
        this, SLOT(serviceDiscovered(QBluetoothUuid)));
connect(m_control, SIGNAL(discoveryFinished()),
        this, SLOT(serviceScanDone()));
connect(m_control, SIGNAL(error(QLowEnergyController::Error)),
        this, SLOT(controllerError(QLowEnergyController::Error)));
connect(m_control, SIGNAL(connected()),
        this, SLOT(deviceConnected()));
connect(m_control, SIGNAL(disconnected()),
        this, SLOT(deviceDisconnected()));

m_control-&gt;connectToDevice();
</db:programlisting>
</db:section>
<db:section xml:id="service-search">
<db:title>Service Search</db:title>
<db:para>As soon as the connection is established we initiate the service discovery:</db:para>
<db:programlisting language="cpp">void HeartRate::deviceConnected()
{
    m_control-&gt;discoverServices();
}

void HeartRate::deviceDisconnected()
{
    setMessage(&quot;Heart Rate service disconnected&quot;);
    qWarning() &lt;&lt; &quot;Remote device disconnected&quot;;
}

</db:programlisting>
<db:para>The <db:code>serviceDiscovered()</db:code> slot below is triggered as a result of the <db:link xlink:href="">QLowEnergyController::serviceDiscovered()</db:link> signal and provides an intermittent progress report. Since we are talking about the heart listener app which monitors HeartRate devices in the vicinity we ignore any service that is not of type <db:link xlink:href="">QBluetoothUuid::HeartRate</db:link>.</db:para>
<db:programlisting language="cpp">void HeartRate::serviceDiscovered(const QBluetoothUuid &amp;gatt)
{
    if (gatt == QBluetoothUuid(QBluetoothUuid::HeartRate)) {
        setMessage(&quot;Heart Rate service discovered. Waiting for service scan to be done...&quot;);
        foundHeartRateService = true;
    }
}
</db:programlisting>
<db:para>Eventually the <db:link xlink:href="">QLowEnergyController::discoveryFinished()</db:link> signal is emitted to indicate the successful completion of the service discovery. Provided a HeartRate service was found, a QLowEnergyService instance is created to represent the service. The returned service object provides the required signals for update notifications and the discovery of service details is triggered using <db:link xlink:href="">QLowEnergyService::discoverDetails()</db:link>:</db:para>
<db:programlisting language="cpp">if (foundHeartRateService) {
    setMessage(&quot;Connecting to service...&quot;);
    m_service = m_control-&gt;createServiceObject(
                QBluetoothUuid(QBluetoothUuid::HeartRate), this);
}

if (!m_service) {
    setMessage(&quot;Heart Rate Service not found.&quot;);
    return;
}

connect(m_service, SIGNAL(stateChanged(QLowEnergyService::ServiceState)),
        this, SLOT(serviceStateChanged(QLowEnergyService::ServiceState)));
connect(m_service, SIGNAL(characteristicChanged(QLowEnergyCharacteristic,QByteArray)),
        this, SLOT(updateHeartRateValue(QLowEnergyCharacteristic,QByteArray)));
connect(m_service, SIGNAL(descriptorWritten(QLowEnergyDescriptor,QByteArray)),
        this, SLOT(confirmedDescriptorWrite(QLowEnergyDescriptor,QByteArray)));

m_service-&gt;discoverDetails();
</db:programlisting>
<db:para>During the detail search the service's <db:link xlink:href="">state()</db:link> transitions from DiscoveryRequired to DiscoveringServices and eventually ends with ServiceDiscovered:</db:para>
<db:programlisting language="cpp">void HeartRate::serviceStateChanged(QLowEnergyService::ServiceState s)
{
    switch (s) {
    case QLowEnergyService::ServiceDiscovered:
    {
        const QLowEnergyCharacteristic hrChar = m_service-&gt;characteristic(
                    QBluetoothUuid(QBluetoothUuid::HeartRateMeasurement));
        if (!hrChar.isValid()) {
            setMessage(&quot;HR Data not found.&quot;);
            break;
        }

        const QLowEnergyDescriptor m_notificationDesc = hrChar.descriptor(
                    QBluetoothUuid::ClientCharacteristicConfiguration);
        if (m_notificationDesc.isValid()) {
            m_service-&gt;writeDescriptor(m_notificationDesc, QByteArray::fromHex(&quot;0100&quot;));
            setMessage(&quot;Measuring&quot;);
            m_start = QDateTime::currentDateTime();
        }

        break;
    }
    default:
        //nothing for now
        break;
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="interaction-with-the-peripheral-device">
<db:title>Interaction with the Peripheral Device</db:title>
<db:para>In the code example above, the desired characteristic is of type HeartRateMeasurement. Since the application measures the heart rate changes, it must enable change notifications for the characteristic. Note that not all characteristics provide change notifications. Since the HeartRate characteristic has been standardized it is possible to assume that notifications can be received. Ultimately <db:link xlink:href="">QLowEnergyCharacteristic::properties()</db:link> must have the <db:link xlink:href="">QLowEnergyCharacteristic::Notify</db:link> flag set and a descriptor of type <db:link xlink:href="">QBluetoothUuid::ClientCharacteristicConfiguration</db:link> must exist to confirm the availability of an appropriate notification.</db:para>
<db:para>Finally, we process the value of the HeartRate characteristic, as per Bluetooth Low Energy standard:</db:para>
<db:programlisting language="cpp">void HeartRate::updateHeartRateValue(const QLowEnergyCharacteristic &amp;c,
                                     const QByteArray &amp;value)
{
    // ignore any other characteristic change -&gt; shouldn't really happen though
    if (c.uuid() != QBluetoothUuid(QBluetoothUuid::HeartRateMeasurement))
        return;

    const char *data = value.constData();
    quint8 flags = data[0];

    //Heart Rate
    if (flags &amp; 0x1) { // HR 16 bit? otherwise 8 bit
        quint16 *heartRate = (quint16 *) &amp;data[1];
        //qDebug() &lt;&lt; &quot;16 bit HR value:&quot; &lt;&lt; *heartRate;
        m_measurements.append(*heartRate);
    } else {
        quint8 *heartRate = (quint8 *) &amp;data[1];
        m_measurements.append(*heartRate);
        //qDebug() &lt;&lt; &quot;8 bit HR value:&quot; &lt;&lt; *heartRate;
    }

    //Energy Expended
    if (flags &amp; 0x8) {
        int index = (flags &amp; 0x1) ? 5 : 3;
        quint16 *energy = (quint16 *) &amp;data[index];
        qDebug() &lt;&lt; &quot;Used Energy:&quot; &lt;&lt; *energy;
    }
}
</db:programlisting>
<db:para>In general a characteristic value is a series of bytes. The precise interpretation of those bytes depends on the characteristic type and value structure. A significant number has been standardized by the <db:link xlink:href="https://developer.bluetooth.org/gatt/services/Pages/ServicesHome.aspx">Bluetooth SIG</db:link> whereas others may follow a custom protocol. The above code snippet demonstrates how to the read the standardized HeartRate value.</db:para>
</db:section>
</db:section>
</db:article>
