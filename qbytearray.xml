<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QByteArray Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qbytearray.xml">QByteArray</db:link> class provides an array of bytes.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QByteArray</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QByteArray is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member><db:member>string-processing</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link> can be used to store both raw bytes (including '\0's) and traditional 8-bit '\0'-terminated strings. Using <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is much more convenient than using <db:code>const char *</db:code>. Behind the scenes, it always ensures that the data is followed by a '\0' terminator, and uses <db:link xlink:href="implicit-sharing.xml">implicit sharing</db:link> (copy-on-write) to reduce memory usage and avoid needless copying of data.</db:para>
<db:para>In addition to <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, Qt also provides the <db:link xlink:href="qstring.xml">QString</db:link> class to store string data. For most purposes, <db:link xlink:href="qstring.xml">QString</db:link> is the class you want to use. It stores 16-bit Unicode characters, making it easy to store non-ASCII/non-Latin-1 characters in your application. Furthermore, <db:link xlink:href="qstring.xml">QString</db:link> is used throughout in the Qt API. The two main cases where <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g., with Qt for Embedded Linux).</db:para>
<db:para>One way to initialize a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is simply to pass a <db:code>const char *</db:code> to its constructor. For example, the following code creates a byte array of size 5 containing the data &quot;Hello&quot;:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Hello&quot;);
</db:programlisting>
<db:para>Although the <db:link xlink:href="qbytearray.xml#size">size</db:link>() is 5, the byte array also maintains an extra '\0' character at the end so that if a function is used that asks for a pointer to the underlying data (e.g. a call to <db:link xlink:href="qbytearray.xml#data">data</db:link>()), the data pointed to is guaranteed to be '\0'-terminated.</db:para>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link> makes a deep copy of the <db:code>const char *</db:code> data, so you can modify it later without experiencing side effects. (If for performance reasons you don't want to take a deep copy of the character data, use <db:link xlink:href="qbytearray.xml#fromRawData">QByteArray::fromRawData</db:link>() instead.)</db:para>
<db:para>Another approach is to set the size of the array using <db:link xlink:href="qbytearray.xml#resize">resize</db:link>() and to initialize the data byte per byte. <db:link xlink:href="qbytearray.xml">QByteArray</db:link> uses 0-based indexes, just like C++ arrays. To access the byte at a particular index position, you can use operator[](). On non-const byte arrays, operator[]() returns a reference to a byte that can be used on the left side of an assignment. For example:</db:para>
<db:programlisting language="cpp">QByteArray ba;
ba.resize(5);
ba[0] = 0x3c;
ba[1] = 0xb8;
ba[2] = 0x64;
ba[3] = 0x18;
ba[4] = 0xca;
</db:programlisting>
<db:para>For read-only access, an alternative syntax is to use <db:link xlink:href="qbytearray.xml#at">at</db:link>():</db:para>
<db:programlisting language="cpp">for (int i = 0; i &lt; ba.size(); ++i) {
    if (ba.at(i) &gt;= 'a' &amp;&amp; ba.at(i) &lt;= 'f')
        cout &lt;&lt; &quot;Found character in range [a-f]&quot; &lt;&lt; endl;
}
</db:programlisting>
<db:para><db:link xlink:href="qbytearray.xml#at">at</db:link>() can be faster than operator[](), because it never causes a <db:link xlink:href="implicit-sharing.xml#deep-copy">deep copy</db:link> to occur.</db:para>
<db:para>To extract many bytes at a time, use <db:link xlink:href="qbytearray.xml#left">left</db:link>(), <db:link xlink:href="qbytearray.xml#right">right</db:link>(), or <db:link xlink:href="qbytearray.xml#mid">mid</db:link>().</db:para>
<db:para>A <db:link xlink:href="qbytearray.xml">QByteArray</db:link> can embed '\0' bytes. The <db:link xlink:href="qbytearray.xml#size">size</db:link>() function always returns the size of the whole array, including embedded '\0' bytes, but excluding the terminating '\0' added by <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. For example:</db:para>
<db:programlisting language="cpp">QByteArray ba1(&quot;ca\0r\0t&quot;);
ba1.size();                     // Returns 2.
ba1.constData();                // Returns &quot;ca&quot; with terminating \0.

QByteArray ba2(&quot;ca\0r\0t&quot;, 3);
ba2.size();                     // Returns 3.
ba2.constData();                // Returns &quot;ca\0&quot; with terminating \0.

QByteArray ba3(&quot;ca\0r\0t&quot;, 4);
ba3.size();                     // Returns 4.
ba3.constData();                // Returns &quot;ca\0r&quot; with terminating \0.

const char cart[] = {'c', 'a', '\0', 'r', '\0', 't'};
QByteArray ba4(QByteArray::fromRawData(cart, 6));
ba4.size();                     // Returns 6.
ba4.constData();                // Returns &quot;ca\0r\0t&quot; without terminating \0.
</db:programlisting>
<db:para>If you want to obtain the length of the data up to and excluding the first '\0' character, call <db:link xlink:href="qbytearray.xml#qstrlen">qstrlen</db:link>() on the byte array.</db:para>
<db:para>After a call to <db:link xlink:href="qbytearray.xml#resize">resize</db:link>(), newly allocated bytes have undefined values. To set all the bytes to a particular value, call <db:link xlink:href="qbytearray.xml#fill">fill</db:link>().</db:para>
<db:para>To obtain a pointer to the actual character data, call <db:link xlink:href="qbytearray.xml#data">data</db:link>() or <db:link xlink:href="qbytearray.xml#constData">constData</db:link>(). These functions return a pointer to the beginning of the data. The pointer is guaranteed to remain valid until a non-const function is called on the <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. It is also guaranteed that the data ends with a '\0' byte unless the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> was created from a <db:link xlink:href="qbytearray.xml#fromRawData">raw data</db:link>. This '\0' byte is automatically provided by <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and is not counted in <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link> provides the following basic functions for modifying the byte data: <db:link xlink:href="qbytearray.xml#append">append</db:link>(), <db:link xlink:href="qbytearray.xml#prepend">prepend</db:link>(), <db:link xlink:href="qbytearray.xml#insert">insert</db:link>(), <db:link xlink:href="qbytearray.xml#replace">replace</db:link>(), and <db:link xlink:href="qbytearray.xml#remove">remove</db:link>(). For example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;and&quot;);
x.prepend(&quot;rock &quot;);         // x == &quot;rock and&quot;
x.append(&quot; roll&quot;);          // x == &quot;rock and roll&quot;
x.replace(5, 3, &quot;&amp;&quot;);       // x == &quot;rock &amp; roll&quot;
</db:programlisting>
<db:para>The <db:link xlink:href="qbytearray.xml#replace">replace</db:link>() and <db:link xlink:href="qbytearray.xml#remove">remove</db:link>() functions' first two arguments are the position from which to start erasing and the number of bytes that should be erased.</db:para>
<db:para>When you <db:link xlink:href="qbytearray.xml#append">append</db:link>() data to a non-empty array, the array will be reallocated and the new data copied to it. You can avoid this behavior by calling <db:link xlink:href="qbytearray.xml#reserve">reserve</db:link>(), which preallocates a certain amount of memory. You can also call <db:link xlink:href="qbytearray.xml#capacity">capacity</db:link>() to find out how much memory <db:link xlink:href="qbytearray.xml">QByteArray</db:link> actually allocated. Data appended to an empty array is not copied.</db:para>
<db:para>A frequent requirement is to remove whitespace characters from a byte array ('\n', '\t', ' ', etc.). If you want to remove whitespace from both ends of a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, use trimmed(). If you want to remove whitespace from both ends and replace multiple consecutive whitespaces with a single space character within the byte array, use simplified().</db:para>
<db:para>If you want to find all occurrences of a particular character or substring in a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, use <db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>() or <db:link xlink:href="qbytearray.xml#lastIndexOf">lastIndexOf</db:link>(). The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular substring:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;&quot;);
int j = 0;
while ((j = ba.indexOf(&quot;&lt;b&gt;&quot;, j)) != -1) {
    cout &lt;&lt; &quot;Found &lt;b&gt; tag at index position &quot; &lt;&lt; j &lt;&lt; endl;
    ++j;
}
</db:programlisting>
<db:para>If you simply want to check whether a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> contains a particular character or substring, use <db:link xlink:href="qbytearray.xml#contains">contains</db:link>(). If you want to find out how many times a particular character or substring occurs in the byte array, use <db:link xlink:href="qbytearray.xml#count-1">count</db:link>(). If you want to replace all occurrences of a particular value with another, use one of the two-parameter <db:link xlink:href="qbytearray.xml#replace">replace</db:link>() overloads.</db:para>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link>s can be compared using overloaded operators such as operator&lt;(), operator&lt;=(), operator==(), operator&gt;=(), and so on. The comparison is based exclusively on the numeric values of the characters and is very fast, but is not what a human would expect. <db:link xlink:href="qstring.xml#localeAwareCompare">QString::localeAwareCompare</db:link>() is a better choice for sorting user-interface strings.</db:para>
<db:para>For historical reasons, <db:link xlink:href="qbytearray.xml">QByteArray</db:link> distinguishes between a null byte array and an empty byte array. A <db:emphasis>null</db:emphasis> byte array is a byte array that is initialized using <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s default constructor or by passing (const char *)0 to the constructor. An <db:emphasis>empty</db:emphasis> byte array is any byte array with size 0. A null byte array is always empty, but an empty byte array isn't necessarily null:</db:para>
<db:programlisting language="cpp">QByteArray().isNull();          // returns true
QByteArray().isEmpty();         // returns true

QByteArray(&quot;&quot;).isNull();        // returns false
QByteArray(&quot;&quot;).isEmpty();       // returns true

QByteArray(&quot;abc&quot;).isNull();     // returns false
QByteArray(&quot;abc&quot;).isEmpty();    // returns false
</db:programlisting>
<db:para>All functions except <db:link xlink:href="qbytearray.xml#isNull">isNull</db:link>() treat null byte arrays the same as empty byte arrays. For example, <db:link xlink:href="qbytearray.xml#data">data</db:link>() returns a pointer to a '\0' character for a null byte array (<db:emphasis>not</db:emphasis> a null pointer), and <db:link xlink:href="qbytearray.xml#QByteArray">QByteArray</db:link>() compares equal to <db:link xlink:href="qbytearray.xml">QByteArray</db:link>(&quot;&quot;). We recommend that you always use <db:link xlink:href="qbytearray.xml#isEmpty">isEmpty</db:link>() and avoid <db:link xlink:href="qbytearray.xml#isNull">isNull</db:link>().</db:para>
<db:section xml:id="notes-on-locale">
<db:title>Notes on Locale</db:title>
<db:section xml:id="number-string-conversions">
<db:title>Number-String Conversions</db:title>
<db:para>Functions that perform conversions between numeric data types and strings are performed in the C locale, irrespective of the user's locale settings. Use <db:link xlink:href="qstring.xml">QString</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:section>
<db:section xml:id="A8-bit-character-comparisons">
<db:title>8-bit Character Comparisons</db:title>
<db:para>In <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, the notion of uppercase and lowercase and of which character is greater than or less than another character is locale dependent. This affects functions that support a case insensitive option or that compare or lowercase or uppercase their arguments. Case insensitive operations and comparisons will be accurate if both strings contain only ASCII characters. (If <db:code>$LC_CTYPE</db:code> is set, most Unix systems do &quot;the right thing&quot;.) Functions that this affects include <db:link xlink:href="qbytearray.xml#contains">contains</db:link>(), <db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>(), <db:link xlink:href="qbytearray.xml#lastIndexOf">lastIndexOf</db:link>(), operator&lt;(), operator&lt;=(), operator&gt;(), operator&gt;=(), toLower() and toUpper().</db:para>
<db:para>This issue does not apply to <db:link xlink:href="qstring.xml">QString</db:link>s since they represent characters using Unicode.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml">QString</db:link></db:member>
<db:member><db:link xlink:href="qbitarray.xml">QBitArray</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Base64Option-enum">
<db:title>[since 5.2] enum QByteArray::Base64Option</db:title>
<db:bridgehead renderas="sect2">flags QByteArray::Base64Options</db:bridgehead>
<db:para>This enum contains the options available for encoding and decoding Base64. Base64 is defined by <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</db:link>, with the following options:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:emphasis>::Base64Encoding</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>(default) The regular Base64 alphabet, called simply &quot;base64&quot;</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:emphasis>::Base64UrlEncoding</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>An alternate alphabet, called &quot;base64url&quot;, which replaces two characters in the alphabet to be more friendly to URLs.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:emphasis>::KeepTrailingEquals</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>(default) Keeps the trailing padding equal signs at the end of the encoded data, so the data is always a size multiple of four.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:emphasis>::OmitTrailingEquals</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Omits adding the padding equal signs at the end of the encoded data.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para><db:link xlink:href="qbytearray.xml#fromBase64">QByteArray::fromBase64</db:link>() ignores the KeepTrailingEquals and OmitTrailingEquals options and will not flag errors in case they are missing or if there are too many of them.</db:para>
<db:para>This enum was introduced in Qt 5.2.</db:para>
<db:para>The <db:code>Base64Options</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Base64Option&gt;. </db:code>It stores an OR combination of <db:code>Base64Option</db:code> values.</db:para>
</db:section>
<db:section xml:id="const_iterator-typedef">
<db:title>QByteArray::const_iterator</db:title>
<db:para>This typedef provides an STL-style const iterator for <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#iterator-typedef">QByteArray::iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="const_reverse_iterator-typedef">
<db:title>[since 5.6] QByteArray::const_reverse_iterator</db:title>
<db:para>This typedef provides an STL-style const reverse iterator for <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#reverse_iterator-typedef">QByteArray::reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#const_iterator-typedef">QByteArray::const_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="iterator-typedef">
<db:title>QByteArray::iterator</db:title>
<db:para>This typedef provides an STL-style non-const iterator for <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#reverse_iterator-typedef">QByteArray::reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#const_iterator-typedef">QByteArray::const_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reverse_iterator-typedef">
<db:title>[since 5.6] QByteArray::reverse_iterator</db:title>
<db:para>This typedef provides an STL-style non-const reverse iterator for <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#iterator-typedef">QByteArray::iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QByteArray">
<db:title>[noexcept] QByteArray::QByteArray()</db:title>
<db:para>Constructs an empty byte array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QByteArray-3">
<db:title>QByteArray::QByteArray(const char *<db:emphasis>data</db:emphasis>, int <db:emphasis>size</db:emphasis> = -1)</db:title>
<db:para>Constructs a byte array containing the first <db:code role="parameter">size</db:code> bytes of array <db:code role="parameter">data</db:code>.</db:para>
<db:para>If <db:code role="parameter">data</db:code> is 0, a null byte array is constructed.</db:para>
<db:para>If <db:code role="parameter">size</db:code> is negative, <db:code role="parameter">data</db:code> is assumed to point to a nul-terminated string and its length is determined dynamically. The terminating nul-character is not considered part of the byte array.</db:para>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link> makes a deep copy of the string data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QByteArray-4">
<db:title>QByteArray::QByteArray(int <db:emphasis>size</db:emphasis>, char <db:emphasis>ch</db:emphasis>)</db:title>
<db:para>Constructs a byte array of size <db:code role="parameter">size</db:code> with every byte set to character <db:code role="parameter">ch</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fill">fill</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QByteArray-2">
<db:title>[noexcept] QByteArray::QByteArray(const QByteArray &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:para>This operation takes <db:link xlink:href="containers.xml#constant-time">constant time</db:link>, because <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>. This makes returning a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), taking <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QByteArray-1">
<db:title>[default, since 5.2] QByteArray::QByteArray(QByteArray &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-constructs a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="dtor.QByteArray">
<db:title>[noexcept] QByteArray::~QByteArray()</db:title>
<db:para>Destroys the byte array.</db:para>
</db:section>
<db:section xml:id="append">
<db:title>QByteArray &amp;QByteArray::append(const QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:para>Appends the byte array <db:code role="parameter">ba</db:code> onto the end of this byte array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;free&quot;);
QByteArray y(&quot;dom&quot;);
x.append(y);
// x == &quot;freedom&quot;
</db:programlisting>
<db:para>This is the same as insert(<db:link xlink:href="qbytearray.xml#size">size</db:link>(), <db:code role="parameter">ba</db:code>).</db:para>
<db:para>Note: <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is an <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link> class. Consequently, if <db:emphasis>this</db:emphasis> is an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, then <db:emphasis>this</db:emphasis> will just share the data held in <db:code role="parameter">ba</db:code>. In this case, no copying of data is done, taking <db:link xlink:href="containers.xml#constant-time">constant time</db:link>. If a shared instance is modified, it will be copied (copy-on-write), taking <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:para>If <db:emphasis>this</db:emphasis> is not an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, a deep copy of the data is performed, taking <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:para>This operation typically does not suffer from allocation overhead, because <db:link xlink:href="qbytearray.xml">QByteArray</db:link> preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#operator-2b-eq">operator+=</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-1">
<db:title>QByteArray &amp;QByteArray::append(char <db:emphasis>ch</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the character <db:code role="parameter">ch</db:code> to this byte array.</db:para>
</db:section>
<db:section xml:id="append-2">
<db:title>QByteArray &amp;QByteArray::append(const QString &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the string <db:code role="parameter">str</db:code> to this byte array. The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call QString::toUtf8() (or QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
</db:section>
<db:section xml:id="append-3">
<db:title>QByteArray &amp;QByteArray::append(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the string <db:code role="parameter">str</db:code> to this byte array.</db:para>
</db:section>
<db:section xml:id="append-4">
<db:title>QByteArray &amp;QByteArray::append(const char *<db:emphasis>str</db:emphasis>, int <db:emphasis>len</db:emphasis>)</db:title>
<db:para>This function overloads <db:link xlink:href="qbytearray.xml#append">append</db:link>().</db:para>
<db:para>Appends the first <db:code role="parameter">len</db:code> characters of the string <db:code role="parameter">str</db:code> to this byte array and returns a reference to this byte array.</db:para>
<db:para>If <db:code role="parameter">len</db:code> is negative, the length of the string will be determined automatically using <db:link xlink:href="qbytearray.xml#qstrlen">qstrlen</db:link>(). If <db:code role="parameter">len</db:code> is zero or <db:code role="parameter">str</db:code> is null, nothing is appended to the byte array. Ensure that <db:code role="parameter">len</db:code> is <db:emphasis>not</db:emphasis> longer than <db:code role="parameter">str</db:code>.</db:para>
</db:section>
<db:section xml:id="append-5">
<db:title>[since 5.7] QByteArray &amp;QByteArray::append(int <db:emphasis>count</db:emphasis>, char <db:emphasis>ch</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends <db:code role="parameter">count</db:code> copies of character <db:code role="parameter">ch</db:code> to this byte array and returns a reference to this byte array.</db:para>
<db:para>If <db:code role="parameter">count</db:code> is negative or zero nothing is appended to the byte array.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="at">
<db:title>char QByteArray::at(int <db:emphasis>i</db:emphasis>) const</db:title>
<db:para>Returns the character at index position <db:code role="parameter">i</db:code> in the byte array.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the byte array (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qbytearray.xml#size">size</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin">
<db:title>QByteArray::iterator QByteArray::begin()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first character in the byte-array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>QByteArray::const_iterator QByteArray::begin() const</db:title>
<db:para>This function overloads <db:link xlink:href="qbytearray.xml#begin">begin</db:link>().</db:para>
</db:section>
<db:section xml:id="capacity">
<db:title>int QByteArray::capacity() const</db:title>
<db:para>Returns the maximum number of bytes that can be stored in the byte array without forcing a reallocation.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many bytes are in the byte array, call <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>[since 5.0] QByteArray::const_iterator QByteArray::cbegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first character in the byte-array.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[since 5.0] QByteArray::const_iterator QByteArray::cend() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary character after the last character in the list.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="chop">
<db:title>void QByteArray::chop(int <db:emphasis>n</db:emphasis>)</db:title>
<db:para>Removes <db:code role="parameter">n</db:code> bytes from the end of the byte array.</db:para>
<db:para>If <db:code role="parameter">n</db:code> is greater than <db:link xlink:href="qbytearray.xml#size">size</db:link>(), the result is an empty byte array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;STARTTLS\r\n&quot;);
ba.chop(2);                 // ba == &quot;STARTTLS&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#resize">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#left">left</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QByteArray::clear()</db:title>
<db:para>Clears the contents of the byte array and makes it null.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#resize">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#isNull">isNull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>QByteArray::const_iterator QByteArray::constBegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first character in the byte-array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constData">
<db:title>const char *QByteArray::constData() const</db:title>
<db:para>Returns a pointer to the data stored in the byte array. The pointer can be used to access the bytes that compose the array. The data is '\0'-terminated unless the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> object was created from raw data. The pointer remains valid as long as the byte array isn't reallocated or destroyed.</db:para>
<db:para>This function is mostly useful to pass a byte array to a function that accepts a <db:code>const char *</db:code>.</db:para>
<db:para>Note: A <db:link xlink:href="qbytearray.xml">QByteArray</db:link> can store any byte values including '\0's, but most functions that take <db:code>char *</db:code> arguments assume that the data ends at the first '\0' they encounter.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QByteArray::const_iterator QByteArray::constEnd() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary character after the last character in the list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>bool QByteArray::contains(const QByteArray &amp;<db:emphasis>ba</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if the byte array contains an occurrence of the byte array <db:code role="parameter">ba</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#count-1">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains-1">
<db:title>bool QByteArray::contains(char <db:emphasis>ch</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if the byte array contains the character <db:code role="parameter">ch</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="contains-2">
<db:title>bool QByteArray::contains(const char *<db:emphasis>str</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if the byte array contains the string <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="count">
<db:title>int QByteArray::count(const QByteArray &amp;<db:emphasis>ba</db:emphasis>) const</db:title>
<db:para>Returns the number of (potentially overlapping) occurrences of byte array <db:code role="parameter">ba</db:code> in this byte array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count-1">
<db:title>int QByteArray::count() const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="count-2">
<db:title>int QByteArray::count(char <db:emphasis>ch</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the number of occurrences of character <db:code role="parameter">ch</db:code> in the byte array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count-3">
<db:title>int QByteArray::count(const char *<db:emphasis>str</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the number of (potentially overlapping) occurrences of string <db:code role="parameter">str</db:code> in the byte array.</db:para>
</db:section>
<db:section xml:id="crbegin">
<db:title>[since 5.6] QByteArray::const_reverse_iterator QByteArray::crbegin() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first character in the byte-array, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="crend">
<db:title>[since 5.6] QByteArray::const_reverse_iterator QByteArray::crend() const</db:title>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to one past the last character in the byte-array, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>char *QByteArray::data()</db:title>
<db:para>Returns a pointer to the data stored in the byte array. The pointer can be used to access and modify the bytes that compose the array. The data is '\0'-terminated, i.e. the number of bytes in the returned character string is <db:link xlink:href="qbytearray.xml#size">size</db:link>() + 1 for the '\0' terminator.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Hello world&quot;);
char *data = ba.data();
while (*data) {
    cout &lt;&lt; &quot;[&quot; &lt;&lt; *data &lt;&lt; &quot;]&quot; &lt;&lt; endl;
    ++data;
}
</db:programlisting>
<db:para>The pointer remains valid as long as the byte array isn't reallocated or destroyed. For read-only access, <db:link xlink:href="qbytearray.xml#constData">constData</db:link>() is faster because it never causes a <db:link xlink:href="implicit-sharing.xml#deep-copy">deep copy</db:link> to occur.</db:para>
<db:para>This function is mostly useful to pass a byte array to a function that accepts a <db:code>const char *</db:code>.</db:para>
<db:para>The following example makes a copy of the char* returned by data(), but it will corrupt the heap and cause a crash because it does not allocate a byte for the '\0' at the end:</db:para>
<db:programlisting language="cpp">QString tmp = &quot;test&quot;;
QByteArray text = tmp.toLocal8Bit();
char *data = new char[text.size()];
strcpy(data, text.data());
delete [] data;
</db:programlisting>
<db:para>This one allocates the correct amount of space:</db:para>
<db:programlisting language="cpp">QString tmp = &quot;test&quot;;
QByteArray text = tmp.toLocal8Bit();
char *data = new char[text.size() + 1];
strcpy(data, text.data());
delete [] data;
</db:programlisting>
<db:para>Note: A <db:link xlink:href="qbytearray.xml">QByteArray</db:link> can store any byte values including '\0's, but most functions that take <db:code>char *</db:code> arguments assume that the data ends at the first '\0' they encounter.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#constData">constData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data-1">
<db:title>const char *QByteArray::data() const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="end">
<db:title>QByteArray::iterator QByteArray::end()</db:title>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary character after the last character in the byte-array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>QByteArray::const_iterator QByteArray::end() const</db:title>
<db:para>This function overloads <db:link xlink:href="qbytearray.xml#end">end</db:link>().</db:para>
</db:section>
<db:section xml:id="endsWith">
<db:title>bool QByteArray::endsWith(const QByteArray &amp;<db:emphasis>ba</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this byte array ends with byte array <db:code role="parameter">ba</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray url(&quot;http://qt-project.org/doc/qt-5.0/qtdoc/index.html&quot;);
if (url.endsWith(&quot;.html&quot;))
    ...
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#startsWith">startsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#right">right</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="endsWith-1">
<db:title>bool QByteArray::endsWith(char <db:emphasis>ch</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if this byte array ends with character <db:code role="parameter">ch</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="endsWith-2">
<db:title>bool QByteArray::endsWith(const char *<db:emphasis>str</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if this byte array ends with string <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="fill">
<db:title>QByteArray &amp;QByteArray::fill(char <db:emphasis>ch</db:emphasis>, int <db:emphasis>size</db:emphasis> = -1)</db:title>
<db:para>Sets every byte in the byte array to character <db:code role="parameter">ch</db:code>. If <db:code role="parameter">size</db:code> is different from -1 (the default), the byte array is resized to size <db:code role="parameter">size</db:code> beforehand.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Istambul&quot;);
ba.fill('o');
// ba == &quot;oooooooo&quot;

ba.fill('X', 2);
// ba == &quot;XX&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromBase64">
<db:title>[static] QByteArray QByteArray::fromBase64(const QByteArray &amp;<db:emphasis>base64</db:emphasis>)</db:title>
<db:para>Returns a decoded copy of the Base64 array <db:code role="parameter">base64</db:code>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">QByteArray text = QByteArray::fromBase64(&quot;UXQgaXMgZ3JlYXQh&quot;);
text.data();            // returns &quot;Qt is great!&quot;
</db:programlisting>
<db:para>The algorithm used to decode Base64-encoded data is defined in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toBase64">toBase64</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromBase64-1">
<db:title>[static, since 5.2] QByteArray QByteArray::fromBase64(const QByteArray &amp;<db:emphasis>base64</db:emphasis>, QByteArray::Base64Options <db:emphasis>options</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a decoded copy of the Base64 array <db:code role="parameter">base64</db:code>, using the alphabet defined by <db:code role="parameter">options</db:code>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">QByteArray::fromBase64(&quot;PHA+SGVsbG8/PC9wPg==&quot;, QByteArray::Base64Encoding); // returns &quot;&lt;p&gt;Hello?&lt;/p&gt;&quot;
QByteArray::fromBase64(&quot;PHA-SGVsbG8_PC9wPg==&quot;, QByteArray::Base64UrlEncoding); // returns &quot;&lt;p&gt;Hello?&lt;/p&gt;&quot;
</db:programlisting>
<db:para>The algorithm used to decode Base64-encoded data is defined in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toBase64">toBase64</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromCFData">
<db:title>[static, since 5.3] QByteArray QByteArray::fromCFData(int <db:emphasis>data</db:emphasis>)</db:title>
<db:para>Constructs a new <db:link xlink:href="qbytearray.xml">QByteArray</db:link> containing a copy of the CFData <db:code role="parameter">data</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromRawCFData">fromRawCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toRawCFData">toRawCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toCFData">toCFData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromHex">
<db:title>[static] QByteArray QByteArray::fromHex(const QByteArray &amp;<db:emphasis>hexEncoded</db:emphasis>)</db:title>
<db:para>Returns a decoded copy of the hex encoded array <db:code role="parameter">hexEncoded</db:code>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">QByteArray text = QByteArray::fromHex(&quot;517420697320677265617421&quot;);
text.data();            // returns &quot;Qt is great!&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toHex">toHex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromNSData">
<db:title>[static, since 5.3] QByteArray QByteArray::fromNSData(const int *<db:emphasis>data</db:emphasis>)</db:title>
<db:para>Constructs a new <db:link xlink:href="qbytearray.xml">QByteArray</db:link> containing a copy of the NSData <db:code role="parameter">data</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromRawNSData">fromRawNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toNSData">toNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toRawNSData">toRawNSData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromPercentEncoding">
<db:title>[static, since 4.4] QByteArray QByteArray::fromPercentEncoding(const QByteArray &amp;<db:emphasis>input</db:emphasis>, char <db:emphasis>percent</db:emphasis> = '%')</db:title>
<db:para>Returns a decoded copy of the URI/URL-style percent-encoded <db:code role="parameter">input</db:code>. The <db:code role="parameter">percent</db:code> parameter allows you to replace the '%' character for another (for instance, '_' or '=').</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">QByteArray text = QByteArray::fromPercentEncoding(&quot;Qt%20is%20great%33&quot;);
text.data();            // returns &quot;Qt is great!&quot;
</db:programlisting>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toPercentEncoding">toPercentEncoding</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#fromPercentEncoding">QUrl::fromPercentEncoding</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromRawCFData">
<db:title>[static, since 5.3] QByteArray QByteArray::fromRawCFData(int <db:emphasis>data</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> that uses the bytes of the CFData <db:code role="parameter">data</db:code>.</db:para>
<db:para>The <db:code role="parameter">data</db:code>'s bytes are not copied.</db:para>
<db:para>The caller guarantees that the CFData will not be deleted or modified as long as this <db:link xlink:href="qbytearray.xml">QByteArray</db:link> object exists.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromCFData">fromCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toRawCFData">toRawCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toCFData">toCFData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromRawData">
<db:title>[static] QByteArray QByteArray::fromRawData(const char *<db:emphasis>data</db:emphasis>, int <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> that uses the first <db:code role="parameter">size</db:code> bytes of the <db:code role="parameter">data</db:code> array. The bytes are <db:emphasis>not</db:emphasis> copied. The <db:link xlink:href="qbytearray.xml">QByteArray</db:link> will contain the <db:code role="parameter">data</db:code> pointer. The caller guarantees that <db:code role="parameter">data</db:code> will not be deleted or modified as long as this <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and any copies of it exist that have not been modified. In other words, because <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is an <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link> class and the instance returned by this function contains the <db:code role="parameter">data</db:code> pointer, the caller must not delete <db:code role="parameter">data</db:code> or modify it directly as long as the returned <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and any copies exist. However, <db:link xlink:href="qbytearray.xml">QByteArray</db:link> does not take ownership of <db:code role="parameter">data</db:code>, so the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> destructor will never delete the raw <db:code role="parameter">data</db:code>, even when the last <db:link xlink:href="qbytearray.xml">QByteArray</db:link> referring to <db:code role="parameter">data</db:code> is destroyed.</db:para>
<db:para>A subsequent attempt to modify the contents of the returned <db:link xlink:href="qbytearray.xml">QByteArray</db:link> or any copy made from it will cause it to create a deep copy of the <db:code role="parameter">data</db:code> array before doing the modification. This ensures that the raw <db:code role="parameter">data</db:code> array itself will never be modified by <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>Here is an example of how to read data using a <db:link xlink:href="qdatastream.xml">QDataStream</db:link> on raw data in memory without copying the raw data into a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>:</db:para>
<db:programlisting language="cpp"> static const char mydata[] = {
    0x00, 0x00, 0x03, 0x84, 0x78, 0x9c, 0x3b, 0x76,
    0xec, 0x18, 0xc3, 0x31, 0x0a, 0xf1, 0xcc, 0x99,
    ...
    0x6d, 0x5b
};

QByteArray data = QByteArray::fromRawData(mydata, sizeof(mydata));
QDataStream in(&amp;data, QIODevice::ReadOnly);
...
</db:programlisting>
<db:warning>
<db:para>A byte array created with fromRawData() is <db:emphasis>not</db:emphasis> null-terminated, unless the raw data contains a 0 character at position <db:code role="parameter">size</db:code>. While that does not matter for <db:link xlink:href="qdatastream.xml">QDataStream</db:link> or functions like <db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>(), passing the byte array to a function accepting a <db:code>const char *</db:code> expected to be '\0'-terminated will fail.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#setRawData">setRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#constData">constData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromRawNSData">
<db:title>[static, since 5.3] QByteArray QByteArray::fromRawNSData(const int *<db:emphasis>data</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> that uses the bytes of the NSData <db:code role="parameter">data</db:code>.</db:para>
<db:para>The <db:code role="parameter">data</db:code>'s bytes are not copied.</db:para>
<db:para>The caller guarantees that the NSData will not be deleted or modified as long as this <db:link xlink:href="qbytearray.xml">QByteArray</db:link> object exists.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromNSData">fromNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toRawNSData">toRawNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toNSData">toNSData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromStdString">
<db:title>[static, since 5.4] QByteArray QByteArray::fromStdString(const std::string &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:para>Returns a copy of the <db:code role="parameter">str</db:code> string as a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toStdString">toStdString</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#fromStdString">QString::fromStdString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="indexOf">
<db:title>int QByteArray::indexOf(const QByteArray &amp;<db:emphasis>ba</db:emphasis>, int <db:emphasis>from</db:emphasis> = 0) const</db:title>
<db:para>Returns the index position of the first occurrence of the byte array <db:code role="parameter">ba</db:code> in this byte array, searching forward from index position <db:code role="parameter">from</db:code>. Returns -1 if <db:code role="parameter">ba</db:code> could not be found.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;sticky question&quot;);
QByteArray y(&quot;sti&quot;);
x.indexOf(y);               // returns 0
x.indexOf(y, 1);            // returns 10
x.indexOf(y, 10);           // returns 10
x.indexOf(y, 11);           // returns -1
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#lastIndexOf">lastIndexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#count-1">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="indexOf-1">
<db:title>int QByteArray::indexOf(char <db:emphasis>ch</db:emphasis>, int <db:emphasis>from</db:emphasis> = 0) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the index position of the first occurrence of the character <db:code role="parameter">ch</db:code> in the byte array, searching forward from index position <db:code role="parameter">from</db:code>. Returns -1 if <db:code role="parameter">ch</db:code> could not be found.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;ABCBA&quot;);
ba.indexOf(&quot;B&quot;);            // returns 1
ba.indexOf(&quot;B&quot;, 1);         // returns 1
ba.indexOf(&quot;B&quot;, 2);         // returns 3
ba.indexOf(&quot;X&quot;);            // returns -1
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#lastIndexOf">lastIndexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="indexOf-2">
<db:title>int QByteArray::indexOf(const QString &amp;<db:emphasis>str</db:emphasis>, int <db:emphasis>from</db:emphasis> = 0) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the index position of the first occurrence of the string <db:code role="parameter">str</db:code> in the byte array, searching forward from index position <db:code role="parameter">from</db:code>. Returns -1 if <db:code role="parameter">str</db:code> could not be found.</db:para>
<db:para>The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call QString::toUtf8() (or QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
</db:section>
<db:section xml:id="indexOf-3">
<db:title>int QByteArray::indexOf(const char *<db:emphasis>str</db:emphasis>, int <db:emphasis>from</db:emphasis> = 0) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the index position of the first occurrence of the string <db:code role="parameter">str</db:code> in the byte array, searching forward from index position <db:code role="parameter">from</db:code>. Returns -1 if <db:code role="parameter">str</db:code> could not be found.</db:para>
</db:section>
<db:section xml:id="insert">
<db:title>QByteArray &amp;QByteArray::insert(int <db:emphasis>i</db:emphasis>, const QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:para>Inserts the byte array <db:code role="parameter">ba</db:code> at index position <db:code role="parameter">i</db:code> and returns a reference to this byte array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Meal&quot;);
ba.insert(1, QByteArray(&quot;ontr&quot;));
// ba == &quot;Montreal&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#replace">replace</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-1">
<db:title>QByteArray &amp;QByteArray::insert(int <db:emphasis>i</db:emphasis>, char <db:emphasis>ch</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts character <db:code role="parameter">ch</db:code> at index position <db:code role="parameter">i</db:code> in the byte array. If <db:code role="parameter">i</db:code> is greater than <db:link xlink:href="qbytearray.xml#size">size</db:link>(), the array is first extended using <db:link xlink:href="qbytearray.xml#resize">resize</db:link>().</db:para>
</db:section>
<db:section xml:id="insert-2">
<db:title>QByteArray &amp;QByteArray::insert(int <db:emphasis>i</db:emphasis>, const QString &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts the string <db:code role="parameter">str</db:code> at index position <db:code role="parameter">i</db:code> in the byte array. The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>If <db:code role="parameter">i</db:code> is greater than <db:link xlink:href="qbytearray.xml#size">size</db:link>(), the array is first extended using <db:link xlink:href="qbytearray.xml#resize">resize</db:link>().</db:para>
<db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call QString::toUtf8() (or QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
</db:section>
<db:section xml:id="insert-3">
<db:title>QByteArray &amp;QByteArray::insert(int <db:emphasis>i</db:emphasis>, const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts the string <db:code role="parameter">str</db:code> at position <db:code role="parameter">i</db:code> in the byte array.</db:para>
<db:para>If <db:code role="parameter">i</db:code> is greater than <db:link xlink:href="qbytearray.xml#size">size</db:link>(), the array is first extended using <db:link xlink:href="qbytearray.xml#resize">resize</db:link>().</db:para>
</db:section>
<db:section xml:id="insert-4">
<db:title>[since 4.6] QByteArray &amp;QByteArray::insert(int <db:emphasis>i</db:emphasis>, const char *<db:emphasis>str</db:emphasis>, int <db:emphasis>len</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts <db:code role="parameter">len</db:code> bytes of the string <db:code role="parameter">str</db:code> at position <db:code role="parameter">i</db:code> in the byte array.</db:para>
<db:para>If <db:code role="parameter">i</db:code> is greater than <db:link xlink:href="qbytearray.xml#size">size</db:link>(), the array is first extended using <db:link xlink:href="qbytearray.xml#resize">resize</db:link>().</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
</db:section>
<db:section xml:id="insert-5">
<db:title>[since 5.7] QByteArray &amp;QByteArray::insert(int <db:emphasis>i</db:emphasis>, int <db:emphasis>count</db:emphasis>, char <db:emphasis>ch</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts <db:code role="parameter">count</db:code> copies of character <db:code role="parameter">ch</db:code> at index position <db:code role="parameter">i</db:code> in the byte array.</db:para>
<db:para>If <db:code role="parameter">i</db:code> is greater than <db:link xlink:href="qbytearray.xml#size">size</db:link>(), the array is first extended using <db:link xlink:href="qbytearray.xml#resize">resize</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QByteArray::isEmpty() const</db:title>
<db:para>Returns <db:code>true</db:code> if the byte array has size 0; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray().isEmpty();         // returns true
QByteArray(&quot;&quot;).isEmpty();       // returns true
QByteArray(&quot;abc&quot;).isEmpty();    // returns false
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QByteArray::isNull() const</db:title>
<db:para>Returns <db:code>true</db:code> if this byte array is null; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray().isNull();          // returns true
QByteArray(&quot;&quot;).isNull();        // returns false
QByteArray(&quot;abc&quot;).isNull();     // returns false
</db:programlisting>
<db:para>Qt makes a distinction between null byte arrays and empty byte arrays for historical reasons. For most applications, what matters is whether or not a byte array contains any data, and this can be determined using <db:link xlink:href="qbytearray.xml#isEmpty">isEmpty</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastIndexOf">
<db:title>int QByteArray::lastIndexOf(const QByteArray &amp;<db:emphasis>ba</db:emphasis>, int <db:emphasis>from</db:emphasis> = -1) const</db:title>
<db:para>Returns the index position of the last occurrence of the byte array <db:code role="parameter">ba</db:code> in this byte array, searching backward from index position <db:code role="parameter">from</db:code>. If <db:code role="parameter">from</db:code> is -1 (the default), the search starts at the last byte. Returns -1 if <db:code role="parameter">ba</db:code> could not be found.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;crazy azimuths&quot;);
QByteArray y(&quot;az&quot;);
x.lastIndexOf(y);           // returns 6
x.lastIndexOf(y, 6);        // returns 6
x.lastIndexOf(y, 5);        // returns 2
x.lastIndexOf(y, 1);        // returns -1
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#count-1">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastIndexOf-1">
<db:title>int QByteArray::lastIndexOf(char <db:emphasis>ch</db:emphasis>, int <db:emphasis>from</db:emphasis> = -1) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the index position of the last occurrence of character <db:code role="parameter">ch</db:code> in the byte array, searching backward from index position <db:code role="parameter">from</db:code>. If <db:code role="parameter">from</db:code> is -1 (the default), the search starts at the last (<db:link xlink:href="qbytearray.xml#size">size</db:link>() - 1) byte. Returns -1 if <db:code role="parameter">ch</db:code> could not be found.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;ABCBA&quot;);
ba.lastIndexOf(&quot;B&quot;);        // returns 3
ba.lastIndexOf(&quot;B&quot;, 3);     // returns 3
ba.lastIndexOf(&quot;B&quot;, 2);     // returns 1
ba.lastIndexOf(&quot;X&quot;);        // returns -1
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastIndexOf-2">
<db:title>int QByteArray::lastIndexOf(const QString &amp;<db:emphasis>str</db:emphasis>, int <db:emphasis>from</db:emphasis> = -1) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the index position of the last occurrence of the string <db:code role="parameter">str</db:code> in the byte array, searching backward from index position <db:code role="parameter">from</db:code>. If <db:code role="parameter">from</db:code> is -1 (the default), the search starts at the last (<db:link xlink:href="qbytearray.xml#size">size</db:link>() - 1) byte. Returns -1 if <db:code role="parameter">str</db:code> could not be found.</db:para>
<db:para>The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call QString::toUtf8() (or QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
</db:section>
<db:section xml:id="lastIndexOf-3">
<db:title>int QByteArray::lastIndexOf(const char *<db:emphasis>str</db:emphasis>, int <db:emphasis>from</db:emphasis> = -1) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the index position of the last occurrence of the string <db:code role="parameter">str</db:code> in the byte array, searching backward from index position <db:code role="parameter">from</db:code>. If <db:code role="parameter">from</db:code> is -1 (the default), the search starts at the last (<db:link xlink:href="qbytearray.xml#size">size</db:link>() - 1) byte. Returns -1 if <db:code role="parameter">str</db:code> could not be found.</db:para>
</db:section>
<db:section xml:id="left">
<db:title>QByteArray QByteArray::left(int <db:emphasis>len</db:emphasis>) const</db:title>
<db:para>Returns a byte array that contains the leftmost <db:code role="parameter">len</db:code> bytes of this byte array.</db:para>
<db:para>The entire byte array is returned if <db:code role="parameter">len</db:code> is greater than <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;Pineapple&quot;);
QByteArray y = x.left(4);
// y == &quot;Pine&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#right">right</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#mid">mid</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#startsWith">startsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="leftJustified">
<db:title>QByteArray QByteArray::leftJustified(int <db:emphasis>width</db:emphasis>, char <db:emphasis>fill</db:emphasis> = ' ', bool <db:emphasis>truncate</db:emphasis> = false) const</db:title>
<db:para>Returns a byte array of size <db:code role="parameter">width</db:code> that contains this byte array padded by the <db:code role="parameter">fill</db:code> character.</db:para>
<db:para>If <db:code role="parameter">truncate</db:code> is false and the <db:link xlink:href="qbytearray.xml#size">size</db:link>() of the byte array is more than <db:code role="parameter">width</db:code>, then the returned byte array is a copy of this byte array.</db:para>
<db:para>If <db:code role="parameter">truncate</db:code> is true and the <db:link xlink:href="qbytearray.xml#size">size</db:link>() of the byte array is more than <db:code role="parameter">width</db:code>, then any bytes in a copy of the byte array after position <db:code role="parameter">width</db:code> are removed, and the copy is returned.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;apple&quot;);
QByteArray y = x.leftJustified(8, '.');   // y == &quot;apple...&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#rightJustified">rightJustified</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="length">
<db:title>int QByteArray::length() const</db:title>
<db:para>Same as <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="mid">
<db:title>QByteArray QByteArray::mid(int <db:emphasis>pos</db:emphasis>, int <db:emphasis>len</db:emphasis> = -1) const</db:title>
<db:para>Returns a byte array containing <db:code role="parameter">len</db:code> bytes from this byte array, starting at position <db:code role="parameter">pos</db:code>.</db:para>
<db:para>If <db:code role="parameter">len</db:code> is -1 (the default), or <db:code role="parameter">pos</db:code> + <db:code role="parameter">len</db:code> &gt;= <db:link xlink:href="qbytearray.xml#size">size</db:link>(), returns a byte array containing all bytes starting at position <db:code role="parameter">pos</db:code> until the end of the byte array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;Five pineapples&quot;);
QByteArray y = x.mid(5, 4);     // y == &quot;pine&quot;
QByteArray z = x.mid(5);        // z == &quot;pineapples&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#left">left</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#right">right</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="number">
<db:title>[static] QByteArray QByteArray::number(int <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:para>Returns a byte array containing the string equivalent of the number <db:code role="parameter">n</db:code> to base <db:code role="parameter">base</db:code> (10 by default). The <db:code role="parameter">base</db:code> can be any value between 2 and 36.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">int n = 63;
QByteArray::number(n);              // returns &quot;63&quot;
QByteArray::number(n, 16);          // returns &quot;3f&quot;
QByteArray::number(n, 16).toUpper();  // returns &quot;3F&quot;
</db:programlisting>
<db:note>
<db:para>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#setNum">setNum</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toInt">toInt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="number-1">
<db:title>[static] QByteArray QByteArray::number(qlonglong <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toLongLong">toLongLong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="number-2">
<db:title>[static] QByteArray QByteArray::number(qulonglong <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toULongLong">toULongLong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="number-3">
<db:title>[static] QByteArray QByteArray::number(uint <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toUInt">toUInt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="number-4">
<db:title>[static] QByteArray QByteArray::number(double <db:emphasis>n</db:emphasis>, char <db:emphasis>f</db:emphasis> = 'g', int <db:emphasis>prec</db:emphasis> = 6)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a byte array that contains the printed value of <db:code role="parameter">n</db:code>, formatted in format <db:code role="parameter">f</db:code> with precision <db:code role="parameter">prec</db:code>.</db:para>
<db:para>Argument <db:code role="parameter">n</db:code> is formatted according to the <db:code role="parameter">f</db:code> format specified, which is <db:code>g</db:code> by default, and can be any of the following:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Format</db:para>
</db:th>
<db:th>
<db:para>Meaning</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:code>e</db:code></db:para>
</db:td>
<db:td>
<db:para>format as [-]9.9e[+|-]999</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>E</db:code></db:para>
</db:td>
<db:td>
<db:para>format as [-]9.9E[+|-]999</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>f</db:code></db:para>
</db:td>
<db:td>
<db:para>format as [-]9.9</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>g</db:code></db:para>
</db:td>
<db:td>
<db:para>use <db:code>e</db:code> or <db:code>f</db:code> format, whichever is the most concise</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>G</db:code></db:para>
</db:td>
<db:td>
<db:para>use <db:code>E</db:code> or <db:code>f</db:code> format, whichever is the most concise</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>With 'e', 'E', and 'f', <db:code role="parameter">prec</db:code> is the number of digits after the decimal point. With 'g' and 'G', <db:code role="parameter">prec</db:code> is the maximum number of significant digits (trailing zeroes are omitted).</db:para>
<db:programlisting language="cpp">QByteArray ba = QByteArray::number(12.3456, 'E', 3);
// ba == 1.235E+01
</db:programlisting>
<db:note>
<db:para>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toDouble">toDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="prepend">
<db:title>QByteArray &amp;QByteArray::prepend(const QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:para>Prepends the byte array <db:code role="parameter">ba</db:code> to this byte array and returns a reference to this byte array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;ship&quot;);
QByteArray y(&quot;air&quot;);
x.prepend(y);
// x == &quot;airship&quot;
</db:programlisting>
<db:para>This is the same as insert(0, <db:code role="parameter">ba</db:code>).</db:para>
<db:para>Note: <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is an <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link> class. Consequently, if <db:emphasis>this</db:emphasis> is an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, then <db:emphasis>this</db:emphasis> will just share the data held in <db:code role="parameter">ba</db:code>. In this case, no copying of data is done, taking <db:link xlink:href="containers.xml#constant-time">constant time</db:link>. If a shared instance is modified, it will be copied (copy-on-write), taking <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:para>If <db:emphasis>this</db:emphasis> is not an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, a deep copy of the data is performed, taking <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="prepend-1">
<db:title>QByteArray &amp;QByteArray::prepend(char <db:emphasis>ch</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Prepends the character <db:code role="parameter">ch</db:code> to this byte array.</db:para>
</db:section>
<db:section xml:id="prepend-2">
<db:title>QByteArray &amp;QByteArray::prepend(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Prepends the string <db:code role="parameter">str</db:code> to this byte array.</db:para>
</db:section>
<db:section xml:id="prepend-3">
<db:title>[since 4.6] QByteArray &amp;QByteArray::prepend(const char *<db:emphasis>str</db:emphasis>, int <db:emphasis>len</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Prepends <db:code role="parameter">len</db:code> bytes of the string <db:code role="parameter">str</db:code> to this byte array.</db:para>
<db:para>This function was introduced in Qt 4.6.</db:para>
</db:section>
<db:section xml:id="prepend-4">
<db:title>[since 5.7] QByteArray &amp;QByteArray::prepend(int <db:emphasis>count</db:emphasis>, char <db:emphasis>ch</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Prepends <db:code role="parameter">count</db:code> copies of character <db:code role="parameter">ch</db:code> to this byte array.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="push_back">
<db:title>void QByteArray::push_back(const QByteArray &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>This function is provided for STL compatibility. It is equivalent to append(<db:code role="parameter">other</db:code>).</db:para>
</db:section>
<db:section xml:id="push_back-1">
<db:title>void QByteArray::push_back(char <db:emphasis>ch</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as append(<db:code role="parameter">ch</db:code>).</db:para>
</db:section>
<db:section xml:id="push_back-2">
<db:title>void QByteArray::push_back(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as append(<db:code role="parameter">str</db:code>).</db:para>
</db:section>
<db:section xml:id="push_front">
<db:title>void QByteArray::push_front(const QByteArray &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>This function is provided for STL compatibility. It is equivalent to prepend(<db:code role="parameter">other</db:code>).</db:para>
</db:section>
<db:section xml:id="push_front-1">
<db:title>void QByteArray::push_front(char <db:emphasis>ch</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as prepend(<db:code role="parameter">ch</db:code>).</db:para>
</db:section>
<db:section xml:id="push_front-2">
<db:title>void QByteArray::push_front(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as prepend(<db:code role="parameter">str</db:code>).</db:para>
</db:section>
<db:section xml:id="rbegin">
<db:title>[since 5.6] QByteArray::reverse_iterator QByteArray::rbegin()</db:title>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first character in the byte-array, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rbegin-1">
<db:title>[since 5.6] QByteArray::const_reverse_iterator QByteArray::rbegin() const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="remove">
<db:title>QByteArray &amp;QByteArray::remove(int <db:emphasis>pos</db:emphasis>, int <db:emphasis>len</db:emphasis>)</db:title>
<db:para>Removes <db:code role="parameter">len</db:code> bytes from the array, starting at index position <db:code role="parameter">pos</db:code>, and returns a reference to the array.</db:para>
<db:para>If <db:code role="parameter">pos</db:code> is out of range, nothing happens. If <db:code role="parameter">pos</db:code> is valid, but <db:code role="parameter">pos</db:code> + <db:code role="parameter">len</db:code> is larger than the size of the array, the array is truncated at position <db:code role="parameter">pos</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Montreal&quot;);
ba.remove(1, 4);
// ba == &quot;Meal&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#replace">replace</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend">
<db:title>[since 5.6] QByteArray::reverse_iterator QByteArray::rend()</db:title>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to one past the last character in the byte-array, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend-1">
<db:title>[since 5.6] QByteArray::const_reverse_iterator QByteArray::rend() const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="repeated">
<db:title>[since 4.5] QByteArray QByteArray::repeated(int <db:emphasis>times</db:emphasis>) const</db:title>
<db:para>Returns a copy of this byte array repeated the specified number of <db:code role="parameter">times</db:code>.</db:para>
<db:para>If <db:code role="parameter">times</db:code> is less than 1, an empty byte array is returned.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;ab&quot;);
ba.repeated(4);             // returns &quot;abababab&quot;
</db:programlisting>
<db:para>This function was introduced in Qt 4.5.</db:para>
</db:section>
<db:section xml:id="replace">
<db:title>QByteArray &amp;QByteArray::replace(int <db:emphasis>pos</db:emphasis>, int <db:emphasis>len</db:emphasis>, const QByteArray &amp;<db:emphasis>after</db:emphasis>)</db:title>
<db:para>Replaces <db:code role="parameter">len</db:code> bytes from index position <db:code role="parameter">pos</db:code> with the byte array <db:code role="parameter">after</db:code>, and returns a reference to this byte array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;Say yes!&quot;);
QByteArray y(&quot;no&quot;);
x.replace(4, 3, y);
// x == &quot;Say no!&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="replace-1">
<db:title>QByteArray &amp;QByteArray::replace(char <db:emphasis>before</db:emphasis>, char <db:emphasis>after</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the character <db:code role="parameter">before</db:code> with the character <db:code role="parameter">after</db:code>.</db:para>
</db:section>
<db:section xml:id="replace-2">
<db:title>QByteArray &amp;QByteArray::replace(char <db:emphasis>before</db:emphasis>, const QByteArray &amp;<db:emphasis>after</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the character <db:code role="parameter">before</db:code> with the byte array <db:code role="parameter">after</db:code>.</db:para>
</db:section>
<db:section xml:id="replace-3">
<db:title>QByteArray &amp;QByteArray::replace(char <db:emphasis>before</db:emphasis>, const QString &amp;<db:emphasis>after</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the character <db:code role="parameter">before</db:code> with the string <db:code role="parameter">after</db:code>. The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call QString::toUtf8() (or QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
</db:section>
<db:section xml:id="replace-4">
<db:title>QByteArray &amp;QByteArray::replace(char <db:emphasis>before</db:emphasis>, const char *<db:emphasis>after</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the character <db:code role="parameter">before</db:code> with the string <db:code role="parameter">after</db:code>.</db:para>
</db:section>
<db:section xml:id="replace-5">
<db:title>QByteArray &amp;QByteArray::replace(const QByteArray &amp;<db:emphasis>before</db:emphasis>, const QByteArray &amp;<db:emphasis>after</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the byte array <db:code role="parameter">before</db:code> with the byte array <db:code role="parameter">after</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;colour behaviour flavour neighbour&quot;);
ba.replace(QByteArray(&quot;ou&quot;), QByteArray(&quot;o&quot;));
// ba == &quot;color behavior flavor neighbor&quot;
</db:programlisting>
</db:section>
<db:section xml:id="replace-6">
<db:title>QByteArray &amp;QByteArray::replace(const QByteArray &amp;<db:emphasis>before</db:emphasis>, const char *<db:emphasis>after</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the byte array <db:code role="parameter">before</db:code> with the string <db:code role="parameter">after</db:code>.</db:para>
</db:section>
<db:section xml:id="replace-7">
<db:title>QByteArray &amp;QByteArray::replace(const QString &amp;<db:emphasis>before</db:emphasis>, const QByteArray &amp;<db:emphasis>after</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the string <db:code role="parameter">before</db:code> with the byte array <db:code role="parameter">after</db:code>. The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call QString::toUtf8() (or QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
</db:section>
<db:section xml:id="replace-8">
<db:title>QByteArray &amp;QByteArray::replace(const QString &amp;<db:emphasis>before</db:emphasis>, const char *<db:emphasis>after</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the string <db:code role="parameter">before</db:code> with the string <db:code role="parameter">after</db:code>.</db:para>
</db:section>
<db:section xml:id="replace-9">
<db:title>QByteArray &amp;QByteArray::replace(const char *<db:emphasis>before</db:emphasis>, const QByteArray &amp;<db:emphasis>after</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the string <db:code role="parameter">before</db:code> with the byte array <db:code role="parameter">after</db:code>.</db:para>
</db:section>
<db:section xml:id="replace-10">
<db:title>QByteArray &amp;QByteArray::replace(const char *<db:emphasis>before</db:emphasis>, const char *<db:emphasis>after</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the string <db:code role="parameter">before</db:code> with the string <db:code role="parameter">after</db:code>.</db:para>
</db:section>
<db:section xml:id="replace-11">
<db:title>QByteArray &amp;QByteArray::replace(int <db:emphasis>pos</db:emphasis>, int <db:emphasis>len</db:emphasis>, const char *<db:emphasis>after</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces <db:code role="parameter">len</db:code> bytes from index position <db:code role="parameter">pos</db:code> with the zero terminated string <db:code role="parameter">after</db:code>.</db:para>
<db:para>Notice: this can change the length of the byte array.</db:para>
</db:section>
<db:section xml:id="replace-12">
<db:title>QByteArray &amp;QByteArray::replace(const char *<db:emphasis>before</db:emphasis>, int <db:emphasis>bsize</db:emphasis>, const char *<db:emphasis>after</db:emphasis>, int <db:emphasis>asize</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the string <db:code role="parameter">before</db:code> with the string <db:code role="parameter">after</db:code>. Since the sizes of the strings are given by <db:code role="parameter">bsize</db:code> and <db:code role="parameter">asize</db:code>, they may contain zero characters and do not need to be zero-terminated.</db:para>
</db:section>
<db:section xml:id="replace-13">
<db:title>[since 4.7] QByteArray &amp;QByteArray::replace(int <db:emphasis>pos</db:emphasis>, int <db:emphasis>len</db:emphasis>, const char *<db:emphasis>after</db:emphasis>, int <db:emphasis>alen</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces <db:code role="parameter">len</db:code> bytes from index position <db:code role="parameter">pos</db:code> with <db:code role="parameter">alen</db:code> bytes from the string <db:code role="parameter">after</db:code>. <db:code role="parameter">after</db:code> is allowed to have '\0' characters.</db:para>
<db:para>This function was introduced in Qt 4.7.</db:para>
</db:section>
<db:section xml:id="reserve">
<db:title>void QByteArray::reserve(int <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Attempts to allocate memory for at least <db:code role="parameter">size</db:code> bytes. If you know in advance how large the byte array will be, you can call this function, and if you call <db:link xlink:href="qbytearray.xml#resize">resize</db:link>() often you are likely to get better performance. If <db:code role="parameter">size</db:code> is an underestimate, the worst that will happen is that the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> will be a bit slower.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the byte array, call <db:link xlink:href="qbytearray.xml#resize">resize</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#squeeze">squeeze</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resize">
<db:title>void QByteArray::resize(int <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Sets the size of the byte array to <db:code role="parameter">size</db:code> bytes.</db:para>
<db:para>If <db:code role="parameter">size</db:code> is greater than the current size, the byte array is extended to make it <db:code role="parameter">size</db:code> bytes with the extra bytes added to the end. The new bytes are uninitialized.</db:para>
<db:para>If <db:code role="parameter">size</db:code> is less than the current size, bytes are removed from the end.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="right">
<db:title>QByteArray QByteArray::right(int <db:emphasis>len</db:emphasis>) const</db:title>
<db:para>Returns a byte array that contains the rightmost <db:code role="parameter">len</db:code> bytes of this byte array.</db:para>
<db:para>The entire byte array is returned if <db:code role="parameter">len</db:code> is greater than <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;Pineapple&quot;);
QByteArray y = x.right(5);
// y == &quot;apple&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#endsWith">endsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#left">left</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#mid">mid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rightJustified">
<db:title>QByteArray QByteArray::rightJustified(int <db:emphasis>width</db:emphasis>, char <db:emphasis>fill</db:emphasis> = ' ', bool <db:emphasis>truncate</db:emphasis> = false) const</db:title>
<db:para>Returns a byte array of size <db:code role="parameter">width</db:code> that contains the <db:code role="parameter">fill</db:code> character followed by this byte array.</db:para>
<db:para>If <db:code role="parameter">truncate</db:code> is false and the size of the byte array is more than <db:code role="parameter">width</db:code>, then the returned byte array is a copy of this byte array.</db:para>
<db:para>If <db:code role="parameter">truncate</db:code> is true and the size of the byte array is more than <db:code role="parameter">width</db:code>, then the resulting byte array is truncated at position <db:code role="parameter">width</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;apple&quot;);
QByteArray y = x.rightJustified(8, '.');    // y == &quot;...apple&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#leftJustified">leftJustified</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum">
<db:title>QByteArray &amp;QByteArray::setNum(int <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:para>Sets the byte array to the printed value of <db:code role="parameter">n</db:code> in base <db:code role="parameter">base</db:code> (10 by default) and returns a reference to the byte array. The <db:code role="parameter">base</db:code> can be any value between 2 and 36. For bases other than 10, n is treated as an unsigned integer.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba;
int n = 63;
ba.setNum(n);           // ba == &quot;63&quot;
ba.setNum(n, 16);       // ba == &quot;3f&quot;
</db:programlisting>
<db:note>
<db:para>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toInt">toInt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-1">
<db:title>QByteArray &amp;QByteArray::setNum(qlonglong <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toLongLong">toLongLong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-2">
<db:title>QByteArray &amp;QByteArray::setNum(qulonglong <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toULongLong">toULongLong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-3">
<db:title>QByteArray &amp;QByteArray::setNum(short <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toShort">toShort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-4">
<db:title>QByteArray &amp;QByteArray::setNum(uint <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toUInt">toUInt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-5">
<db:title>QByteArray &amp;QByteArray::setNum(ushort <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toUShort">toUShort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-6">
<db:title>QByteArray &amp;QByteArray::setNum(double <db:emphasis>n</db:emphasis>, char <db:emphasis>f</db:emphasis> = 'g', int <db:emphasis>prec</db:emphasis> = 6)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the byte array to the printed value of <db:code role="parameter">n</db:code>, formatted in format <db:code role="parameter">f</db:code> with precision <db:code role="parameter">prec</db:code>, and returns a reference to the byte array.</db:para>
<db:para>The format <db:code role="parameter">f</db:code> can be any of the following:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Format</db:para>
</db:th>
<db:th>
<db:para>Meaning</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:code>e</db:code></db:para>
</db:td>
<db:td>
<db:para>format as [-]9.9e[+|-]999</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>E</db:code></db:para>
</db:td>
<db:td>
<db:para>format as [-]9.9E[+|-]999</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>f</db:code></db:para>
</db:td>
<db:td>
<db:para>format as [-]9.9</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>g</db:code></db:para>
</db:td>
<db:td>
<db:para>use <db:code>e</db:code> or <db:code>f</db:code> format, whichever is the most concise</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>G</db:code></db:para>
</db:td>
<db:td>
<db:para>use <db:code>E</db:code> or <db:code>f</db:code> format, whichever is the most concise</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>With 'e', 'E', and 'f', <db:code role="parameter">prec</db:code> is the number of digits after the decimal point. With 'g' and 'G', <db:code role="parameter">prec</db:code> is the maximum number of significant digits (trailing zeroes are omitted).</db:para>
<db:note>
<db:para>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toDouble">toDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-7">
<db:title>QByteArray &amp;QByteArray::setNum(float <db:emphasis>n</db:emphasis>, char <db:emphasis>f</db:emphasis> = 'g', int <db:emphasis>prec</db:emphasis> = 6)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the byte array to the printed value of <db:code role="parameter">n</db:code>, formatted in format <db:code role="parameter">f</db:code> with precision <db:code role="parameter">prec</db:code>, and returns a reference to the byte array.</db:para>
<db:note>
<db:para>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toFloat">toFloat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setRawData">
<db:title>[since 4.7] QByteArray &amp;QByteArray::setRawData(const char *<db:emphasis>data</db:emphasis>, uint <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Resets the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> to use the first <db:code role="parameter">size</db:code> bytes of the <db:code role="parameter">data</db:code> array. The bytes are <db:emphasis>not</db:emphasis> copied. The <db:link xlink:href="qbytearray.xml">QByteArray</db:link> will contain the <db:code role="parameter">data</db:code> pointer. The caller guarantees that <db:code role="parameter">data</db:code> will not be deleted or modified as long as this <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and any copies of it exist that have not been modified.</db:para>
<db:para>This function can be used instead of <db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>() to re-use existing <db:link xlink:href="qbytearray.xml">QByteArray</db:link> objects to save memory re-allocations.</db:para>
<db:para>This function was introduced in Qt 4.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#constData">constData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>int QByteArray::size() const</db:title>
<db:para>Returns the number of bytes in this byte array.</db:para>
<db:para>The last byte in the byte array is at position size() - 1. In addition, <db:link xlink:href="qbytearray.xml">QByteArray</db:link> ensures that the byte at position size() is always '\0', so that you can use the return value of <db:link xlink:href="qbytearray.xml#data">data</db:link>() and <db:link xlink:href="qbytearray.xml#constData">constData</db:link>() as arguments to functions that expect '\0'-terminated strings. If the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> object was created from a <db:link xlink:href="qbytearray.xml#fromRawData">raw data</db:link> that didn't include the trailing null-termination character then <db:link xlink:href="qbytearray.xml">QByteArray</db:link> doesn't add it automaticall unless the <db:link xlink:href="implicit-sharing.xml#deep-copy">deep copy</db:link> is created.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Hello&quot;);
int n = ba.size();          // n == 5
ba.data()[0];               // returns 'H'
ba.data()[4];               // returns 'o'
ba.data()[5];               // returns '\0'
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="split">
<db:title>QList&lt;QByteArray&gt; QByteArray::split(char <db:emphasis>sep</db:emphasis>) const</db:title>
<db:para>Splits the byte array into subarrays wherever <db:code role="parameter">sep</db:code> occurs, and returns the list of those arrays. If <db:code role="parameter">sep</db:code> does not match anywhere in the byte array, split() returns a single-element list containing this byte array.</db:para>
</db:section>
<db:section xml:id="squeeze">
<db:title>void QByteArray::squeeze()</db:title>
<db:para>Releases any memory not required to store the array's data.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s memory usage. In general, you will rarely ever need to call this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startsWith">
<db:title>bool QByteArray::startsWith(const QByteArray &amp;<db:emphasis>ba</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this byte array starts with byte array <db:code role="parameter">ba</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray url(&quot;ftp://ftp.qt-project.org/&quot;);
if (url.startsWith(&quot;ftp:&quot;))
    ...
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#endsWith">endsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#left">left</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startsWith-1">
<db:title>bool QByteArray::startsWith(char <db:emphasis>ch</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if this byte array starts with character <db:code role="parameter">ch</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="startsWith-2">
<db:title>bool QByteArray::startsWith(const char *<db:emphasis>str</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if this byte array starts with string <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="swap">
<db:title>[noexcept, since 4.8] void QByteArray::swap(QByteArray &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps byte array <db:code role="parameter">other</db:code> with this byte array. This operation is very fast and never fails.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
</db:section>
<db:section xml:id="toBase64">
<db:title>QByteArray QByteArray::toBase64() const</db:title>
<db:para>Returns a copy of the byte array, encoded as Base64.</db:para>
<db:programlisting language="cpp">QByteArray text(&quot;Qt is great!&quot;);
text.toBase64();        // returns &quot;UXQgaXMgZ3JlYXQh&quot;
</db:programlisting>
<db:para>The algorithm used to encode Base64-encoded data is defined in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromBase64">fromBase64</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toBase64-1">
<db:title>[since 5.2] QByteArray QByteArray::toBase64(QByteArray::Base64Options <db:emphasis>options</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a copy of the byte array, encoded using the options <db:code role="parameter">options</db:code>.</db:para>
<db:programlisting language="cpp">QByteArray text(&quot;&lt;p&gt;Hello?&lt;/p&gt;&quot;);
text.toBase64(QByteArray::Base64Encoding | QByteArray::OmitTrailingEquals);      // returns &quot;PHA+SGVsbG8/PC9wPg&quot;
text.toBase64(QByteArray::Base64Encoding);                                       // returns &quot;PHA+SGVsbG8/PC9wPg==&quot;
text.toBase64(QByteArray::Base64UrlEncoding);                                    // returns &quot;PHA-SGVsbG8_PC9wPg==&quot;
text.toBase64(QByteArray::Base64UrlEncoding | QByteArray::OmitTrailingEquals);   // returns &quot;PHA-SGVsbG8_PC9wPg&quot;
</db:programlisting>
<db:para>The algorithm used to encode Base64-encoded data is defined in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromBase64">fromBase64</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toCFData">
<db:title>[since 5.3] int QByteArray::toCFData() const</db:title>
<db:para>Creates a CFData from a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. The caller owns the CFData object and is responsible for releasing it.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toRawCFData">toRawCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromCFData">fromCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawCFData">fromRawCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDouble">
<db:title>double QByteArray::toDouble(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR) const</db:title>
<db:para>Returns the byte array converted to a <db:code>double</db:code> value.</db:para>
<db:para>Returns 0.0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not 0: if a conversion error occurs, *<db:code role="parameter">ok</db:code> is set to false; otherwise *<db:code role="parameter">ok</db:code> is set to true.</db:para>
<db:programlisting language="cpp">QByteArray string(&quot;1234.56&quot;);
double a = string.toDouble();   // a == 1234.56
</db:programlisting>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toFloat">
<db:title>float QByteArray::toFloat(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR) const</db:title>
<db:para>Returns the byte array converted to a <db:code>float</db:code> value.</db:para>
<db:para>Returns 0.0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not 0: if a conversion error occurs, *<db:code role="parameter">ok</db:code> is set to false; otherwise *<db:code role="parameter">ok</db:code> is set to true.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toHex">
<db:title>QByteArray QByteArray::toHex() const</db:title>
<db:para>Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and the letters a-f.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromHex">fromHex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toInt">
<db:title>int QByteArray::toInt(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:para>Returns the byte array converted to an <db:code>int</db:code> using base <db:code role="parameter">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not 0: if a conversion error occurs, *<db:code role="parameter">ok</db:code> is set to false; otherwise *<db:code role="parameter">ok</db:code> is set to true.</db:para>
<db:programlisting language="cpp">QByteArray str(&quot;FF&quot;);
bool ok;
int hex = str.toInt(&amp;ok, 16);     // hex == 255, ok == true
int dec = str.toInt(&amp;ok, 10);     // dec == 0, ok == false
</db:programlisting>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLong">
<db:title>[since 4.1] long QByteArray::toLong(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:para>Returns the byte array converted to a <db:code>long</db:code> int using base <db:code role="parameter">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not 0: if a conversion error occurs, *<db:code role="parameter">ok</db:code> is set to false; otherwise *<db:code role="parameter">ok</db:code> is set to true.</db:para>
<db:programlisting language="cpp">QByteArray str(&quot;FF&quot;);
bool ok;
long hex = str.toLong(&amp;ok, 16);   // hex == 255, ok == true
long dec = str.toLong(&amp;ok, 10);   // dec == 0, ok == false
</db:programlisting>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
</db:note>
<db:para>This function was introduced in Qt 4.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLongLong">
<db:title>qlonglong QByteArray::toLongLong(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:para>Returns the byte array converted to a <db:code>long long</db:code> using base <db:code role="parameter">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not 0: if a conversion error occurs, *<db:code role="parameter">ok</db:code> is set to false; otherwise *<db:code role="parameter">ok</db:code> is set to true.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toNSData">
<db:title>[since 5.3] int *QByteArray::toNSData() const</db:title>
<db:para>Creates a NSData from a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. The NSData object is autoreleased.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromNSData">fromNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawNSData">fromRawNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toRawNSData">toRawNSData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPercentEncoding">
<db:title>[since 4.4] QByteArray QByteArray::toPercentEncoding(const QByteArray &amp;<db:emphasis>exclude</db:emphasis> = QByteArray(), const QByteArray &amp;<db:emphasis>include</db:emphasis> = QByteArray(), char <db:emphasis>percent</db:emphasis> = '%') const</db:title>
<db:para>Returns a URI/URL-style percent-encoded copy of this byte array. The <db:code role="parameter">percent</db:code> parameter allows you to override the default '%' character for another.</db:para>
<db:para>By default, this function will encode all characters that are not one of the following:</db:para>
<db:para>ALPHA (&quot;a&quot; to &quot;z&quot; and &quot;A&quot; to &quot;Z&quot;) / DIGIT (0 to 9) / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;</db:para>
<db:para>To prevent characters from being encoded pass them to <db:code role="parameter">exclude</db:code>. To force characters to be encoded pass them to <db:code role="parameter">include</db:code>. The <db:code role="parameter">percent</db:code> character is always encoded.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray text = &quot;{a fishy string?}&quot;;
QByteArray ba = text.toPercentEncoding(&quot;{}&quot;, &quot;s&quot;);
qDebug(ba.constData());
// prints &quot;{a fi%73hy %73tring%3F}&quot;
</db:programlisting>
<db:para>The hex encoding uses the numbers 0-9 and the uppercase letters A-F.</db:para>
<db:para>This function was introduced in Qt 4.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromPercentEncoding">fromPercentEncoding</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#toPercentEncoding">QUrl::toPercentEncoding</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRawCFData">
<db:title>[since 5.3] int QByteArray::toRawCFData() const</db:title>
<db:para>Constructs a CFData that uses the bytes of the <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>The <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s bytes are not copied.</db:para>
<db:para>The caller guarantees that the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> will not be deleted or modified as long as this CFData object exists.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toCFData">toCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawCFData">fromRawCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromCFData">fromCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRawNSData">
<db:title>[since 5.3] int *QByteArray::toRawNSData() const</db:title>
<db:para>Constructs a NSData that uses the bytes of the <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>The <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s bytes are not copied.</db:para>
<db:para>The caller guarantees that the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> will not be deleted or modified as long as this NSData object exists.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromRawNSData">fromRawNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromNSData">fromNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toNSData">toNSData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toShort">
<db:title>short QByteArray::toShort(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:para>Returns the byte array converted to a <db:code>short</db:code> using base <db:code role="parameter">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not 0: if a conversion error occurs, *<db:code role="parameter">ok</db:code> is set to false; otherwise *<db:code role="parameter">ok</db:code> is set to true.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toStdString">
<db:title>[since 5.4] std::string QByteArray::toStdString() const</db:title>
<db:para>Returns a std::string object with the data contained in this <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>This operator is mostly useful to pass a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> to a function that accepts a std::string object.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromStdString">fromStdString</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#toStdString">QString::toStdString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUInt">
<db:title>uint QByteArray::toUInt(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:para>Returns the byte array converted to an <db:code>unsigned int</db:code> using base <db:code role="parameter">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not 0: if a conversion error occurs, *<db:code role="parameter">ok</db:code> is set to false; otherwise *<db:code role="parameter">ok</db:code> is set to true.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toULong">
<db:title>[since 4.1] ulong QByteArray::toULong(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:para>Returns the byte array converted to an <db:code>unsigned long int</db:code> using base <db:code role="parameter">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not 0: if a conversion error occurs, *<db:code role="parameter">ok</db:code> is set to false; otherwise *<db:code role="parameter">ok</db:code> is set to true.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
</db:note>
<db:para>This function was introduced in Qt 4.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toULongLong">
<db:title>qulonglong QByteArray::toULongLong(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:para>Returns the byte array converted to an <db:code>unsigned long long</db:code> using base <db:code role="parameter">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not 0: if a conversion error occurs, *<db:code role="parameter">ok</db:code> is set to false; otherwise *<db:code role="parameter">ok</db:code> is set to true.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUShort">
<db:title>ushort QByteArray::toUShort(bool *<db:emphasis>ok</db:emphasis> = Q_NULLPTR, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:para>Returns the byte array converted to an <db:code>unsigned short</db:code> using base <db:code role="parameter">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not 0: if a conversion error occurs, *<db:code role="parameter">ok</db:code> is set to false; otherwise *<db:code role="parameter">ok</db:code> is set to true.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="truncate">
<db:title>void QByteArray::truncate(int <db:emphasis>pos</db:emphasis>)</db:title>
<db:para>Truncates the byte array at index position <db:code role="parameter">pos</db:code>.</db:para>
<db:para>If <db:code role="parameter">pos</db:code> is beyond the end of the array, nothing happens.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Stockholm&quot;);
ba.truncate(5);             // ba == &quot;Stock&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#resize">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#left">left</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QByteArray::operator!=(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this byte array is not equal to string <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>The comparison is case sensitive.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>(), <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>(), or <db:link xlink:href="qstring.xml#fromLocal8Bit">QString::fromLocal8Bit</db:link>() explicitly if you want to convert the byte array to a <db:link xlink:href="qstring.xml">QString</db:link> before doing the comparison.</db:para>
</db:section>
<db:section xml:id="operator-2b-eq">
<db:title>QByteArray &amp;QByteArray::operator+=(const QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:para>Appends the byte array <db:code role="parameter">ba</db:code> onto the end of this byte array and returns a reference to this byte array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;free&quot;);
QByteArray y(&quot;dom&quot;);
x += y;
// x == &quot;freedom&quot;
</db:programlisting>
<db:para>Note: <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is an <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link> class. Consequently, if <db:emphasis>this</db:emphasis> is an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, then <db:emphasis>this</db:emphasis> will just share the data held in <db:code role="parameter">ba</db:code>. In this case, no copying of data is done, taking <db:link xlink:href="containers.xml#constant-time">constant time</db:link>. If a shared instance is modified, it will be copied (copy-on-write), taking <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:para>If <db:emphasis>this</db:emphasis> is not an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, a deep copy of the data is performed, taking <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:para>This operation typically does not suffer from allocation overhead, because <db:link xlink:href="qbytearray.xml">QByteArray</db:link> preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#prepend">prepend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq-1">
<db:title>QByteArray &amp;QByteArray::operator+=(char <db:emphasis>ch</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the character <db:code role="parameter">ch</db:code> onto the end of this byte array and returns a reference to this byte array.</db:para>
</db:section>
<db:section xml:id="operator-2b-eq-2">
<db:title>QByteArray &amp;QByteArray::operator+=(const QString &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the string <db:code role="parameter">str</db:code> onto the end of this byte array and returns a reference to this byte array. The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call QString::toUtf8() (or QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-2b-eq-3">
<db:title>QByteArray &amp;QByteArray::operator+=(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the string <db:code role="parameter">str</db:code> onto the end of this byte array and returns a reference to this byte array.</db:para>
</db:section>
<db:section xml:id="operator-lt">
<db:title>bool QByteArray::operator&lt;(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this byte array is lexically less than string <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>The comparison is case sensitive.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>(), <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>(), or <db:link xlink:href="qstring.xml#fromLocal8Bit">QString::fromLocal8Bit</db:link>() explicitly if you want to convert the byte array to a <db:link xlink:href="qstring.xml">QString</db:link> before doing the comparison.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq">
<db:title>bool QByteArray::operator&lt;=(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this byte array is lexically less than or equal to string <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>The comparison is case sensitive.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>(), <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>(), or <db:link xlink:href="qstring.xml#fromLocal8Bit">QString::fromLocal8Bit</db:link>() explicitly if you want to convert the byte array to a <db:link xlink:href="qstring.xml">QString</db:link> before doing the comparison.</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>[default, since 5.2] QByteArray &amp;QByteArray::operator=(QByteArray &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qbytearray.xml">QByteArray</db:link> instance.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[noexcept] QByteArray &amp;QByteArray::operator=(const QByteArray &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Assigns <db:code role="parameter">other</db:code> to this byte array and returns a reference to this byte array.</db:para>
</db:section>
<db:section xml:id="operator-eq-2">
<db:title>QByteArray &amp;QByteArray::operator=(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Assigns <db:code role="parameter">str</db:code> to this byte array.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QByteArray::operator==(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this byte array is equal to string <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>The comparison is case sensitive.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>(), <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>(), or <db:link xlink:href="qstring.xml#fromLocal8Bit">QString::fromLocal8Bit</db:link>() explicitly if you want to convert the byte array to a <db:link xlink:href="qstring.xml">QString</db:link> before doing the comparison.</db:para>
</db:section>
<db:section xml:id="operator-gt">
<db:title>bool QByteArray::operator&gt;(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this byte array is lexically greater than string <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>The comparison is case sensitive.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>(), <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>(), or <db:link xlink:href="qstring.xml#fromLocal8Bit">QString::fromLocal8Bit</db:link>() explicitly if you want to convert the byte array to a <db:link xlink:href="qstring.xml">QString</db:link> before doing the comparison.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq">
<db:title>bool QByteArray::operator&gt;=(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this byte array is greater than or equal to string <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The Unicode data is converted into 8-bit characters using QString::toUtf8().</db:para>
<db:para>The comparison is case sensitive.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>(), <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>(), or <db:link xlink:href="qstring.xml#fromLocal8Bit">QString::fromLocal8Bit</db:link>() explicitly if you want to convert the byte array to a <db:link xlink:href="qstring.xml">QString</db:link> before doing the comparison.</db:para>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>QByteRef QByteArray::operator[](int <db:emphasis>i</db:emphasis>)</db:title>
<db:para>Returns the byte at index position <db:code role="parameter">i</db:code> as a modifiable reference.</db:para>
<db:para>If an assignment is made beyond the end of the byte array, the array is extended with <db:link xlink:href="qbytearray.xml#resize">resize</db:link>() before the assignment takes place.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba;
for (int i = 0; i &lt; 10; ++i)
    ba[i] = 'A' + i;
// ba == &quot;ABCDEFGHIJ&quot;
</db:programlisting>
<db:para>The return value is of type QByteRef, a helper class for <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. When you get an object of type QByteRef, you can use it as if it were a char &amp;. If you assign to it, the assignment will apply to the character in the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> from which you got the reference.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#at">at</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>QByteRef QByteArray::operator[](uint <db:emphasis>i</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="operator-5b-5d-2">
<db:title>char QByteArray::operator[](int <db:emphasis>i</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as at(<db:code role="parameter">i</db:code>).</db:para>
</db:section>
<db:section xml:id="operator-5b-5d-3">
<db:title>char QByteArray::operator[](uint <db:emphasis>i</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qChecksum">
<db:title>quint16 qChecksum(const char *<db:emphasis>data</db:emphasis>, uint <db:emphasis>len</db:emphasis>)</db:title>
<db:para>Returns the CRC-16 checksum of the first <db:code role="parameter">len</db:code> bytes of <db:code role="parameter">data</db:code>.</db:para>
<db:para>The checksum is independent of the byte order (endianness).</db:para>
<db:note>
<db:para>This function is a 16-bit cache conserving (16 entry table) implementation of the CRC-16-CCITT algorithm.</db:para>
</db:note>
</db:section>
<db:section xml:id="qCompress">
<db:title>QByteArray qCompress(const QByteArray &amp;<db:emphasis>data</db:emphasis>, int <db:emphasis>compressionLevel</db:emphasis> = -1)</db:title>
<db:para>Compresses the <db:code role="parameter">data</db:code> byte array and returns the compressed data in a new byte array.</db:para>
<db:para>The <db:code role="parameter">compressionLevel</db:code> parameter specifies how much compression should be used. Valid values are between 0 and 9, with 9 corresponding to the greatest compression (i.e. smaller compressed data) at the cost of using a slower algorithm. Smaller values (8, 7, ..., 1) provide successively less compression at slightly faster speeds. The value 0 corresponds to no compression at all. The default value is -1, which specifies zlib's default compression.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qUncompress">qUncompress</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qCompress-1">
<db:title>QByteArray qCompress(const uchar *<db:emphasis>data</db:emphasis>, int <db:emphasis>nbytes</db:emphasis>, int <db:emphasis>compressionLevel</db:emphasis> = -1)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Compresses the first <db:code role="parameter">nbytes</db:code> of <db:code role="parameter">data</db:code> at compression level <db:code role="parameter">compressionLevel</db:code> and returns the compressed data in a new byte array.</db:para>
</db:section>
<db:section xml:id="qUncompress">
<db:title>QByteArray qUncompress(const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:para>Uncompresses the <db:code role="parameter">data</db:code> byte array and returns a new byte array with the uncompressed data.</db:para>
<db:para>Returns an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link> if the input data was corrupt.</db:para>
<db:para>This function will uncompress data compressed with <db:link xlink:href="qbytearray.xml#qCompress">qCompress</db:link>() from this and any earlier Qt version, back to Qt 3.1 when this feature was added.</db:para>
<db:para><db:emphasis role="bold">Note:</db:emphasis> If you want to use this function to uncompress external data that was compressed using zlib, you first need to prepend a four byte header to the byte array containing the data. The header must contain the expected length (in bytes) of the uncompressed data, expressed as an unsigned, big-endian, 32-bit integer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qCompress">qCompress</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qUncompress-2">
<db:title>QByteArray qUncompress(const uchar *<db:emphasis>data</db:emphasis>, int <db:emphasis>nbytes</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Uncompresses the first <db:code role="parameter">nbytes</db:code> of <db:code role="parameter">data</db:code> and returns a new byte array with the uncompressed data.</db:para>
</db:section>
<db:section xml:id="qsnprintf">
<db:title>int qsnprintf(char *<db:emphasis>str</db:emphasis>, size_t <db:emphasis>n</db:emphasis>, const char *<db:emphasis>fmt</db:emphasis>, <db:emphasis>...</db:emphasis>)</db:title>
<db:anchor xml:id="bytearray-qsnprintf"/>
<db:para>A portable snprintf() function, calls qvsnprintf.</db:para>
<db:para><db:code role="parameter">fmt</db:code> is the <db:code>printf()</db:code> format string. The result is put into <db:code role="parameter">str</db:code>, which is a buffer of at least <db:code role="parameter">n</db:code> bytes.</db:para>
<db:warning>
<db:para>Call this function only when you know what you are doing since it shows different behavior on certain platforms. Use <db:link xlink:href="qstring.xml#asprintf">QString::asprintf</db:link>() to format a string instead.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qvsnprintf">qvsnprintf</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#asprintf">QString::asprintf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrcmp">
<db:title>int qstrcmp(const char *<db:emphasis>str1</db:emphasis>, const char *<db:emphasis>str2</db:emphasis>)</db:title>
<db:para>A safe <db:code>strcmp()</db:code> function.</db:para>
<db:para>Compares <db:code role="parameter">str1</db:code> and <db:code role="parameter">str2</db:code>. Returns a negative value if <db:code role="parameter">str1</db:code> is less than <db:code role="parameter">str2</db:code>, 0 if <db:code role="parameter">str1</db:code> is equal to <db:code role="parameter">str2</db:code> or a positive value if <db:code role="parameter">str1</db:code> is greater than <db:code role="parameter">str2</db:code>.</db:para>
<db:para>Special case 1: Returns 0 if <db:code role="parameter">str1</db:code> and <db:code role="parameter">str2</db:code> are both 0.</db:para>
<db:para>Special case 2: Returns an arbitrary non-zero value if <db:code role="parameter">str1</db:code> is 0 or <db:code role="parameter">str2</db:code> is 0 (but not both).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrncmp">qstrncmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstricmp">qstricmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstrnicmp">qstrnicmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#8-bit-character-comparisons">8-bit Character Comparisons</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrcpy">
<db:title>char *qstrcpy(char *<db:emphasis>dst</db:emphasis>, const char *<db:emphasis>src</db:emphasis>)</db:title>
<db:para>Copies all the characters up to and including the '\0' from <db:code role="parameter">src</db:code> into <db:code role="parameter">dst</db:code> and returns a pointer to <db:code role="parameter">dst</db:code>. If <db:code role="parameter">src</db:code> is 0, it immediately returns 0.</db:para>
<db:para>This function assumes that <db:code role="parameter">dst</db:code> is large enough to hold the contents of <db:code role="parameter">src</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrncpy">qstrncpy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrdup">
<db:title>char *qstrdup(const char *<db:emphasis>src</db:emphasis>)</db:title>
<db:para>Returns a duplicate string.</db:para>
<db:para>Allocates space for a copy of <db:code role="parameter">src</db:code>, copies it, and returns a pointer to the copy. If <db:code role="parameter">src</db:code> is 0, it immediately returns 0.</db:para>
<db:para>Ownership is passed to the caller, so the returned string must be deleted using <db:code>delete[]</db:code>.</db:para>
</db:section>
<db:section xml:id="qstricmp">
<db:title>int qstricmp(const char *<db:emphasis>str1</db:emphasis>, const char *<db:emphasis>str2</db:emphasis>)</db:title>
<db:para>A safe <db:code>stricmp()</db:code> function.</db:para>
<db:para>Compares <db:code role="parameter">str1</db:code> and <db:code role="parameter">str2</db:code> ignoring the case of the characters. The encoding of the strings is assumed to be Latin-1.</db:para>
<db:para>Returns a negative value if <db:code role="parameter">str1</db:code> is less than <db:code role="parameter">str2</db:code>, 0 if <db:code role="parameter">str1</db:code> is equal to <db:code role="parameter">str2</db:code> or a positive value if <db:code role="parameter">str1</db:code> is greater than <db:code role="parameter">str2</db:code>.</db:para>
<db:para>Special case 1: Returns 0 if <db:code role="parameter">str1</db:code> and <db:code role="parameter">str2</db:code> are both 0.</db:para>
<db:para>Special case 2: Returns a random non-zero value if <db:code role="parameter">str1</db:code> is 0 or <db:code role="parameter">str2</db:code> is 0 (but not both).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrcmp">qstrcmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstrncmp">qstrncmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstrnicmp">qstrnicmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#8-bit-character-comparisons">8-bit Character Comparisons</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrlen">
<db:title>uint qstrlen(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:para>A safe <db:code>strlen()</db:code> function.</db:para>
<db:para>Returns the number of characters that precede the terminating '\0', or 0 if <db:code role="parameter">str</db:code> is 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrnlen">qstrnlen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrncmp">
<db:title>int qstrncmp(const char *<db:emphasis>str1</db:emphasis>, const char *<db:emphasis>str2</db:emphasis>, uint <db:emphasis>len</db:emphasis>)</db:title>
<db:para>A safe <db:code>strncmp()</db:code> function.</db:para>
<db:para>Compares at most <db:code role="parameter">len</db:code> bytes of <db:code role="parameter">str1</db:code> and <db:code role="parameter">str2</db:code>.</db:para>
<db:para>Returns a negative value if <db:code role="parameter">str1</db:code> is less than <db:code role="parameter">str2</db:code>, 0 if <db:code role="parameter">str1</db:code> is equal to <db:code role="parameter">str2</db:code> or a positive value if <db:code role="parameter">str1</db:code> is greater than <db:code role="parameter">str2</db:code>.</db:para>
<db:para>Special case 1: Returns 0 if <db:code role="parameter">str1</db:code> and <db:code role="parameter">str2</db:code> are both 0.</db:para>
<db:para>Special case 2: Returns a random non-zero value if <db:code role="parameter">str1</db:code> is 0 or <db:code role="parameter">str2</db:code> is 0 (but not both).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrcmp">qstrcmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstricmp">qstricmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstrnicmp">qstrnicmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#8-bit-character-comparisons">8-bit Character Comparisons</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrncpy">
<db:title>char *qstrncpy(char *<db:emphasis>dst</db:emphasis>, const char *<db:emphasis>src</db:emphasis>, uint <db:emphasis>len</db:emphasis>)</db:title>
<db:para>A safe <db:code>strncpy()</db:code> function.</db:para>
<db:para>Copies at most <db:code role="parameter">len</db:code> bytes from <db:code role="parameter">src</db:code> (stopping at <db:code role="parameter">len</db:code> or the terminating '\0' whichever comes first) into <db:code role="parameter">dst</db:code> and returns a pointer to <db:code role="parameter">dst</db:code>. Guarantees that <db:code role="parameter">dst</db:code> is '\0'-terminated. If <db:code role="parameter">src</db:code> or <db:code role="parameter">dst</db:code> is 0, returns 0 immediately.</db:para>
<db:para>This function assumes that <db:code role="parameter">dst</db:code> is at least <db:code role="parameter">len</db:code> characters long.</db:para>
<db:note>
<db:para>When compiling with Visual C++ compiler version 14.00 (Visual C++ 2005) or later, internally the function strncpy_s will be used.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrcpy">qstrcpy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrnicmp">
<db:title>int qstrnicmp(const char *<db:emphasis>str1</db:emphasis>, const char *<db:emphasis>str2</db:emphasis>, uint <db:emphasis>len</db:emphasis>)</db:title>
<db:para>A safe <db:code>strnicmp()</db:code> function.</db:para>
<db:para>Compares at most <db:code role="parameter">len</db:code> bytes of <db:code role="parameter">str1</db:code> and <db:code role="parameter">str2</db:code> ignoring the case of the characters. The encoding of the strings is assumed to be Latin-1.</db:para>
<db:para>Returns a negative value if <db:code role="parameter">str1</db:code> is less than <db:code role="parameter">str2</db:code>, 0 if <db:code role="parameter">str1</db:code> is equal to <db:code role="parameter">str2</db:code> or a positive value if <db:code role="parameter">str1</db:code> is greater than <db:code role="parameter">str2</db:code>.</db:para>
<db:para>Special case 1: Returns 0 if <db:code role="parameter">str1</db:code> and <db:code role="parameter">str2</db:code> are both 0.</db:para>
<db:para>Special case 2: Returns a random non-zero value if <db:code role="parameter">str1</db:code> is 0 or <db:code role="parameter">str2</db:code> is 0 (but not both).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrcmp">qstrcmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstrncmp">qstrncmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstricmp">qstricmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#8-bit-character-comparisons">8-bit Character Comparisons</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrnlen">
<db:title>[since 4.2] uint qstrnlen(const char *<db:emphasis>str</db:emphasis>, uint <db:emphasis>maxlen</db:emphasis>)</db:title>
<db:para>A safe <db:code>strnlen()</db:code> function.</db:para>
<db:para>Returns the number of characters that precede the terminating '\0', but at most <db:code role="parameter">maxlen</db:code>. If <db:code role="parameter">str</db:code> is 0, returns 0.</db:para>
<db:para>This function was introduced in Qt 4.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrlen">qstrlen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qvsnprintf">
<db:title>int qvsnprintf(char *<db:emphasis>str</db:emphasis>, size_t <db:emphasis>n</db:emphasis>, const char *<db:emphasis>fmt</db:emphasis>, va_list <db:emphasis>ap</db:emphasis>)</db:title>
<db:para>A portable <db:code>vsnprintf()</db:code> function. Will call <db:code>::vsnprintf()</db:code>, <db:code>::_vsnprintf()</db:code>, or <db:code>::vsnprintf_s</db:code> depending on the system, or fall back to an internal version.</db:para>
<db:para><db:code role="parameter">fmt</db:code> is the <db:code>printf()</db:code> format string. The result is put into <db:code role="parameter">str</db:code>, which is a buffer of at least <db:code role="parameter">n</db:code> bytes.</db:para>
<db:para>The caller is responsible to call <db:code>va_end()</db:code> on <db:code role="parameter">ap</db:code>.</db:para>
<db:warning>
<db:para>Since vsnprintf() shows different behavior on certain platforms, you should not rely on the return value or on the fact that you will always get a 0 terminated string back.</db:para>
</db:warning>
<db:para>Ideally, you should never call this function but use <db:link xlink:href="qstring.xml#asprintf">QString::asprintf</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qsnprintf">qsnprintf</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#asprintf">QString::asprintf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq-1">
<db:title>[noexcept] bool operator!=(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is not equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-2">
<db:title>[noexcept] bool operator!=(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is not equal to string <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-3">
<db:title>[noexcept] bool operator!=(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">a1</db:code> is not equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-2b">
<db:title>const QByteArray operator+(char <db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a byte array that is the result of concatenating character <db:code role="parameter">a1</db:code> and byte array <db:code role="parameter">a2</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-2b-1">
<db:title>const QByteArray operator+(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, char <db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a byte array that is the result of concatenating byte array <db:code role="parameter">a1</db:code> and character <db:code role="parameter">a2</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-2b-2">
<db:title>const QByteArray operator+(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>Returns a byte array that is the result of concatenating byte array <db:code role="parameter">a1</db:code> and byte array <db:code role="parameter">a2</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#operator-2b-eq">QByteArray::operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-3">
<db:title>const QByteArray operator+(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a byte array that is the result of concatenating byte array <db:code role="parameter">a1</db:code> and string <db:code role="parameter">a2</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-2b-4">
<db:title>const QByteArray operator+(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a byte array that is the result of concatenating string <db:code role="parameter">a1</db:code> and byte array <db:code role="parameter">a2</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-1">
<db:title>[noexcept] bool operator&lt;(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically less than byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-2">
<db:title>[noexcept] bool operator&lt;(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically less than string <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-3">
<db:title>[noexcept] bool operator&lt;(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">a1</db:code> is lexically less than byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt-2">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:para>Writes byte array <db:code role="parameter">ba</db:code> to the stream <db:code role="parameter">out</db:code> and returns a reference to the stream.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-eq-1">
<db:title>[noexcept] bool operator&lt;=(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically less than or equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq-2">
<db:title>[noexcept] bool operator&lt;=(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically less than or equal to string <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq-3">
<db:title>[noexcept] bool operator&lt;=(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">a1</db:code> is lexically less than or equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-1">
<db:title>[noexcept] bool operator==(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-2">
<db:title>[noexcept] bool operator==(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is equal to string <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-3">
<db:title>[noexcept] bool operator==(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">a1</db:code> is equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-1">
<db:title>[noexcept] bool operator&gt;(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically greater than byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-2">
<db:title>[noexcept] bool operator&gt;(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically greater than string <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-3">
<db:title>[noexcept] bool operator&gt;(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">a1</db:code> is lexically greater than byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-1">
<db:title>[noexcept] bool operator&gt;=(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically greater than or equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-2">
<db:title>[noexcept] bool operator&gt;=(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically greater than or equal to string <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-3">
<db:title>[noexcept] bool operator&gt;=(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">a1</db:code> is lexically greater than or equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-gt-1">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:para>Reads a byte array into <db:code role="parameter">ba</db:code> from the stream <db:code role="parameter">in</db:code> and returns a reference to the stream.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QT_NO_CAST_FROM_BYTEARRAY">
<db:title>QT_NO_CAST_FROM_BYTEARRAY</db:title>
<db:para>Disables automatic conversions from <db:link xlink:href="qbytearray.xml">QByteArray</db:link> to const char * or const void *.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</db:link></db:member>
<db:member><db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QByteArray</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qbytearray.xml">QByteArray</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="operator-const-char--2a">
<db:title>[deprecated] const char *QByteArray::operator const char *() const</db:title>
<db:bridgehead renderas="sect2" xml:id="operator-const-void--2a">[deprecated] const void *QByteArray::operator const void *() const</db:bridgehead>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qbytearray.xml#constData">constData</db:link>() instead.</db:para>
<db:para>Returns a pointer to the data stored in the byte array. The pointer can be used to access the bytes that compose the array. The data is '\0'-terminated. The pointer remains valid as long as the array isn't reallocated or destroyed.</db:para>
<db:para>This operator is mostly useful to pass a byte array to a function that accepts a <db:code>const char *</db:code>.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_BYTEARRAY</db:code> when you compile your applications.</db:para>
<db:para>Note: A <db:link xlink:href="qbytearray.xml">QByteArray</db:link> can store any byte values including '\0's, but most functions that take <db:code>char *</db:code> arguments assume that the data ends at the first '\0' they encounter.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#constData">constData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
