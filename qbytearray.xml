<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QByteArray Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.0.4 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qbytearray.xml">QByteArray</db:link> class provides an array of bytes.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QByteArray</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QByteArray is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member><db:member>string-processing</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link> can be used to store both raw bytes (including '\0's) and traditional 8-bit '\0'-terminated strings. Using <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is much more convenient than using <db:code>const char *</db:code>. Behind the scenes, it always ensures that the data is followed by a '\0' terminator, and uses <db:link xlink:href="implicit-sharing.xml">implicit sharing</db:link> (copy-on-write) to reduce memory usage and avoid needless copying of data.</db:para>
<db:para>In addition to <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, Qt also provides the <db:link xlink:href="qstring.xml">QString</db:link> class to store string data. For most purposes, <db:link xlink:href="qstring.xml">QString</db:link> is the class you want to use. It understands its content as Unicode text (encoded using UTF-16) where <db:link xlink:href="qbytearray.xml">QByteArray</db:link> aims to avoid assumptions about the encoding or semantics of the bytes it stores (aside from a few legacy cases where it uses ASCII). Furthermore, <db:link xlink:href="qstring.xml">QString</db:link> is used throughout in the Qt API. The two main cases where <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g., with Qt for Embedded Linux).</db:para>
<db:para>One way to initialize a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is simply to pass a <db:code>const char *</db:code> to its constructor. For example, the following code creates a byte array of size 5 containing the data &quot;Hello&quot;:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Hello&quot;);
</db:programlisting>
<db:para>Although the <db:link xlink:href="qbytearray.xml#size">size</db:link>() is 5, the byte array also maintains an extra '\0' byte at the end so that if a function is used that asks for a pointer to the underlying data (e.g. a call to <db:link xlink:href="qbytearray.xml#data">data</db:link>()), the data pointed to is guaranteed to be '\0'-terminated.</db:para>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link> makes a deep copy of the <db:code>const char *</db:code> data, so you can modify it later without experiencing side effects. (If, for example for performance reasons, you don't want to take a deep copy of the data, use <db:link xlink:href="qbytearray.xml#fromRawData">QByteArray::fromRawData</db:link>() instead.)</db:para>
<db:para>Another approach is to set the size of the array using <db:link xlink:href="qbytearray.xml#resize">resize</db:link>() and to initialize the data byte by byte. <db:link xlink:href="qbytearray.xml">QByteArray</db:link> uses 0-based indexes, just like C++ arrays. To access the byte at a particular index position, you can use operator[](). On non-const byte arrays, operator[]() returns a reference to a byte that can be used on the left side of an assignment. For example:</db:para>
<db:programlisting language="cpp">QByteArray ba;
ba.resize(5);
ba[0] = 0x3c;
ba[1] = 0xb8;
ba[2] = 0x64;
ba[3] = 0x18;
ba[4] = 0xca;
</db:programlisting>
<db:para>For read-only access, an alternative syntax is to use <db:link xlink:href="qbytearray.xml#at">at</db:link>():</db:para>
<db:programlisting language="cpp">for (qsizetype i = 0; i &amp;lt; ba.size(); ++i) {
    if (ba.at(i) &amp;gt;= 'a' &amp;amp;&amp;amp; ba.at(i) &amp;lt;= 'f')
        cout &amp;lt;&amp;lt; &quot;Found character in range [a-f]&quot; &amp;lt;&amp;lt; Qt::endl;
}
</db:programlisting>
<db:para><db:link xlink:href="qbytearray.xml#at">at</db:link>() can be faster than operator[](), because it never causes a <db:link xlink:href="implicit-sharing.xml#deep-copy">deep copy</db:link> to occur.</db:para>
<db:para>To extract many bytes at a time, use <db:link xlink:href="qbytearray.xml#first">first</db:link>(), <db:link xlink:href="qbytearray.xml#last">last</db:link>(), or <db:link xlink:href="qbytearray.xml#sliced">sliced</db:link>().</db:para>
<db:para>A <db:link xlink:href="qbytearray.xml">QByteArray</db:link> can embed '\0' bytes. The <db:link xlink:href="qbytearray.xml#size">size</db:link>() function always returns the size of the whole array, including embedded '\0' bytes, but excluding the terminating '\0' added by <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. For example:</db:para>
<db:programlisting language="cpp">QByteArray ba1(&quot;ca\0r\0t&quot;);
ba1.size();                     // Returns 2.
ba1.constData();                // Returns &quot;ca&quot; with terminating \0.

QByteArray ba2(&quot;ca\0r\0t&quot;, 3);
ba2.size();                     // Returns 3.
ba2.constData();                // Returns &quot;ca\0&quot; with terminating \0.

QByteArray ba3(&quot;ca\0r\0t&quot;, 4);
ba3.size();                     // Returns 4.
ba3.constData();                // Returns &quot;ca\0r&quot; with terminating \0.

const char cart[] = {'c', 'a', '\0', 'r', '\0', 't'};
QByteArray ba4(QByteArray::fromRawData(cart, 6));
ba4.size();                     // Returns 6.
ba4.constData();                // Returns &quot;ca\0r\0t&quot; without terminating \0.
</db:programlisting>
<db:para>If you want to obtain the length of the data up to and excluding the first '\0' byte, call <db:link xlink:href="qbytearray.xml#qstrlen">qstrlen</db:link>() on the byte array.</db:para>
<db:para>After a call to <db:link xlink:href="qbytearray.xml#resize">resize</db:link>(), newly allocated bytes have undefined values. To set all the bytes to a particular value, call <db:link xlink:href="qbytearray.xml#fill">fill</db:link>().</db:para>
<db:para>To obtain a pointer to the actual bytes, call <db:link xlink:href="qbytearray.xml#data">data</db:link>() or <db:link xlink:href="qbytearray.xml#constData">constData</db:link>(). These functions return a pointer to the beginning of the data. The pointer is guaranteed to remain valid until a non-const function is called on the <db:link xlink:href="qbytearray.xml">QByteArray</db:link>. It is also guaranteed that the data ends with a '\0' byte unless the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> was created from <db:link xlink:href="qbytearray.xml#fromRawData">raw data</db:link>. This '\0' byte is automatically provided by <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and is not counted in <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link> provides the following basic functions for modifying the byte data: <db:link xlink:href="qbytearray.xml#append">append</db:link>(), <db:link xlink:href="qbytearray.xml#prepend">prepend</db:link>(), <db:link xlink:href="qbytearray.xml#insert">insert</db:link>(), <db:link xlink:href="qbytearray.xml#replace">replace</db:link>(), and <db:link xlink:href="qbytearray.xml#remove">remove</db:link>(). For example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;and&quot;);
x.prepend(&quot;rock &quot;);         // x == &quot;rock and&quot;
x.append(&quot; roll&quot;);          // x == &quot;rock and roll&quot;
x.replace(5, 3, &quot;&amp;amp;&quot;);       // x == &quot;rock &amp;amp; roll&quot;
</db:programlisting>
<db:para>In the above example the <db:link xlink:href="qbytearray.xml#replace">replace</db:link>() function's first two arguments are the position from which to start replacing and the number of bytes that should be replaced.</db:para>
<db:para>When data-modifying functions increase the size of the array, they may lead to reallocation of memory for the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> object. When this happens, <db:link xlink:href="qbytearray.xml">QByteArray</db:link> expands by more than it immediately needs so as to have space for further expansion without reallocation until the size of the array has greatly increased.</db:para>
<db:para>The <db:link xlink:href="qbytearray.xml#insert">insert</db:link>(), <db:link xlink:href="qbytearray.xml#remove">remove</db:link>() and, when replacing a sub-array with one of different size, <db:link xlink:href="qbytearray.xml#replace">replace</db:link>() functions can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>) for large arrays, because they require moving many bytes in the array by at least one position in memory.</db:para>
<db:para>If you are building a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> gradually and know in advance approximately how many bytes the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> will contain, you can call <db:link xlink:href="qbytearray.xml#reserve">reserve</db:link>(), asking <db:link xlink:href="qbytearray.xml">QByteArray</db:link> to preallocate a certain amount of memory. You can also call <db:link xlink:href="qbytearray.xml#capacity">capacity</db:link>() to find out how much memory the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> actually has allocated.</db:para>
<db:para>Note that using non-const operators and functions can cause <db:link xlink:href="qbytearray.xml">QByteArray</db:link> to do a deep copy of the data, due to <db:link xlink:href="implicit-sharing.xml">implicit sharing</db:link>.</db:para>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link> provides <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterators</db:link> (<db:link xlink:href="qbytearray.xml#const_iterator-typedef">QByteArray::const_iterator</db:link> and <db:link xlink:href="qbytearray.xml#iterator-typedef">QByteArray::iterator</db:link>). In practice, iterators are handy when working with generic algorithms provided by the C++ standard library.</db:para>
<db:note>
<db:para>Iterators and references to individual <db:link xlink:href="qbytearray.xml">QByteArray</db:link> elements are subject to stability issues. They are often invalidated when a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>-modifying operation (e.g. <db:link xlink:href="qbytearray.xml#insert">insert</db:link>() or <db:link xlink:href="qbytearray.xml#remove">remove</db:link>()) is called. When stability and iterator-like functionality is required, you should use indexes instead of iterators as they are not tied to <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s internal state and thus do not get invalidated.</db:para>
</db:note>
<db:note>
<db:para>Iterators over a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, and references to individual bytes within one, cannot be relied on to remain valid when any non-const method of the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is called. Accessing such an iterator or reference after the call to a non-const method leads to undefined behavior. When stability for iterator-like functionality is required, you should use indexes instead of iterators as they are not tied to <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s internal state and thus do not get invalidated.</db:para>
</db:note>
<db:para>If you want to find all occurrences of a particular byte or sequence of bytes in a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, use <db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>() or <db:link xlink:href="qbytearray.xml#lastIndexOf">lastIndexOf</db:link>(). The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the byte sequence if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular string:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;We must be &amp;lt;b&amp;gt;bold&amp;lt;/b&amp;gt;, very &amp;lt;b&amp;gt;bold&amp;lt;/b&amp;gt;&quot;);
qsizetype j = 0;
while ((j = ba.indexOf(&quot;&amp;lt;b&amp;gt;&quot;, j)) != -1) {
    cout &amp;lt;&amp;lt; &quot;Found &amp;lt;b&amp;gt; tag at index position &quot; &amp;lt;&amp;lt; j &amp;lt;&amp;lt; Qt::endl;
    ++j;
}
</db:programlisting>
<db:para>If you simply want to check whether a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> contains a particular byte sequence, use <db:link xlink:href="qbytearray.xml#contains">contains</db:link>(). If you want to find out how many times a particular byte sequence occurs in the byte array, use <db:link xlink:href="qbytearray.xml#count-2">count</db:link>(). If you want to replace all occurrences of a particular value with another, use one of the two-parameter <db:link xlink:href="qbytearray.xml#replace">replace</db:link>() overloads.</db:para>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link>s can be compared using overloaded operators such as operator&lt;(), operator&lt;=(), operator==(), operator&gt;=(), and so on. The comparison is based exclusively on the numeric values of the bytes and is very fast, but is not what a human would expect. <db:link xlink:href="qstring.xml#localeAwareCompare">QString::localeAwareCompare</db:link>() is a better choice for sorting user-interface strings.</db:para>
<db:para>For historical reasons, <db:link xlink:href="qbytearray.xml">QByteArray</db:link> distinguishes between a null byte array and an empty byte array. A <db:emphasis>null</db:emphasis> byte array is a byte array that is initialized using <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s default constructor or by passing (const char *)0 to the constructor. An <db:emphasis>empty</db:emphasis> byte array is any byte array with size 0. A null byte array is always empty, but an empty byte array isn't necessarily null:</db:para>
<db:programlisting language="cpp">QByteArray().isNull();          // returns true
QByteArray().isEmpty();         // returns true

QByteArray(&quot;&quot;).isNull();        // returns false
QByteArray(&quot;&quot;).isEmpty();       // returns true

QByteArray(&quot;abc&quot;).isNull();     // returns false
QByteArray(&quot;abc&quot;).isEmpty();    // returns false
</db:programlisting>
<db:para>All functions except <db:link xlink:href="qbytearray.xml#isNull">isNull</db:link>() treat null byte arrays the same as empty byte arrays. For example, <db:link xlink:href="qbytearray.xml#data">data</db:link>() returns a valid pointer (<db:emphasis>not</db:emphasis> nullptr) to a '\0' byte for a null byte array and <db:link xlink:href="qbytearray.xml#QByteArray">QByteArray</db:link>() compares equal to <db:link xlink:href="qbytearray.xml">QByteArray</db:link>(&quot;&quot;). We recommend that you always use <db:link xlink:href="qbytearray.xml#isEmpty">isEmpty</db:link>() and avoid <db:link xlink:href="qbytearray.xml#isNull">isNull</db:link>().</db:para>
<db:section xml:id="maximum-size-and-out-of-memory-conditions">
<db:title>Maximum size and out-of-memory conditions</db:title>
<db:para>The maximum size of <db:link xlink:href="qbytearray.xml">QByteArray</db:link> depends on the architecture. Most 64-bit systems can allocate more than 2 GB of memory, with a typical limit of 2^63 bytes. The actual value also depends on the overhead required for managing the data block. As a result, you can expect the maximum size of 2 GB minus overhead on 32-bit platforms, and 2^63 bytes minus overhead on 64-bit platforms. The number of elements that can be stored in a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is this maximum size.</db:para>
<db:para>When memory allocation fails, <db:link xlink:href="qbytearray.xml">QByteArray</db:link> throws a <db:code>std::bad_alloc</db:code> exception if the application is being compiled with exception support. Out of memory conditions in Qt containers are the only case where Qt will throw exceptions. If exceptions are disabled, then running out of memory is undefined behavior.</db:para>
<db:para>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> API.</db:para>
</db:section>
<db:section xml:id="c-locale-and-ascii-functions">
<db:title>C locale and ASCII functions</db:title>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link> generally handles data as bytes, without presuming any semantics; where it does presume semantics, it uses the C locale and ASCII encoding. Standard Unicode encodings are supported by <db:link xlink:href="qstring.xml">QString</db:link>, other encodings may be supported using <db:link xlink:href="qstringencoder.xml">QStringEncoder</db:link> and <db:link xlink:href="qstringdecoder.xml">QStringDecoder</db:link> to convert to Unicode. For locale-specific interpretation of text, use <db:link xlink:href="qlocale.xml">QLocale</db:link> or <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
<db:section xml:id="c-strings">
<db:title>C Strings</db:title>
<db:para>Traditional C strings, also known as '\0'-terminated strings, are sequences of bytes, specified by a start-point and implicitly including each byte up to, but not including, the first '\0' byte thereafter. Methods that accept such a pointer, without a length, will interpret it as this sequence of bytes. Such a sequence, by construction, cannot contain a '\0' byte.</db:para>
<db:para>Other overloads accept a start-pointer and a byte-count; these use the given number of bytes, following the start address, regardless of whether any of them happen to be '\0' bytes. In some cases, where there is no overload taking only a pointer, passing a length of -1 will cause the method to use the offset of the first '\0' byte after the pointer as the length; a length of -1 should only be passed if the method explicitly says it does this (in which case it is typically a default argument).</db:para>
</db:section>
<db:section xml:id="spacing-characters">
<db:title>Spacing Characters</db:title>
<db:para>A frequent requirement is to remove spacing characters from a byte array ('\n', '\t', ' ', etc.). If you want to remove spacing from both ends of a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, use <db:link xlink:href="qbytearray.xml#trimmed">trimmed</db:link>(). If you want to also replace each run of spacing characters with a single space character within the byte array, use <db:link xlink:href="qbytearray.xml#simplified">simplified</db:link>(). Only ASCII spacing characters are recognized for these purposes.</db:para>
</db:section>
<db:section xml:id="number-string-conversions">
<db:title>Number-String Conversions</db:title>
<db:para>Functions that perform conversions between numeric data types and strings are performed in the C locale, regardless of the user's locale settings. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:section>
<db:section xml:id="character-case">
<db:title>Character Case</db:title>
<db:para>In <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, the notion of uppercase and lowercase and of case-independent comparison is limited to ASCII. Non-ASCII characters are treated as caseless, since their case depends on encoding. This affects functions that support a case insensitive option or that change the case of their arguments. Functions that this affects include <db:link xlink:href="qbytearray.xml#contains">contains</db:link>(), <db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>(), <db:link xlink:href="qbytearray.xml#lastIndexOf">lastIndexOf</db:link>(), <db:link xlink:href="qbytearray.xml#isLower">isLower</db:link>(), <db:link xlink:href="qbytearray.xml#isUpper">isUpper</db:link>(), <db:link xlink:href="qbytearray.xml#toLower">toLower</db:link>() and <db:link xlink:href="qbytearray.xml#toUpper">toUpper</db:link>().</db:para>
<db:para>This issue does not apply to <db:link xlink:href="qstring.xml">QString</db:link>s since they represent characters using Unicode.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearrayview.xml">QByteArrayView</db:link></db:member>
<db:member><db:link xlink:href="qstring.xml">QString</db:link></db:member>
<db:member><db:link xlink:href="qbitarray.xml">QBitArray</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Base64Option-enum">
<db:title>[since 5.2] enum QByteArray::Base64Option</db:title>
<db:bridgehead renderas="sect2">flags QByteArray::Base64Options</db:bridgehead>
<db:enumsynopsis>
<db:enumname>Base64Option</db:enumname>
<db:enumitem>
<db:enumidentifier>Base64Encoding</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Base64UrlEncoding</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>KeepTrailingEquals</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>OmitTrailingEquals</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>IgnoreBase64DecodingErrors</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AbortOnBase64DecodingErrors</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QByteArray::Base64Options</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum contains the options available for encoding and decoding Base64. Base64 is defined by <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</db:link>, with the following options:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:emphasis>::Base64Encoding</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>(default) The regular Base64 alphabet, called simply &quot;base64&quot;</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:emphasis>::Base64UrlEncoding</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>An alternate alphabet, called &quot;base64url&quot;, which replaces two characters in the alphabet to be more friendly to URLs.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:emphasis>::KeepTrailingEquals</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>(default) Keeps the trailing padding equal signs at the end of the encoded data, so the data is always a size multiple of four.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:emphasis>::OmitTrailingEquals</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Omits adding the padding equal signs at the end of the encoded data.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:emphasis>::IgnoreBase64DecodingErrors</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>When decoding Base64-encoded data, ignores errors in the input; invalid characters are simply skipped. This enum value has been added in Qt 5.15.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:emphasis>::AbortOnBase64DecodingErrors</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>When decoding Base64-encoded data, stops at the first decoding error. This enum value has been added in Qt 5.15.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para><db:link xlink:href="qbytearray.xml#fromBase64Encoding">QByteArray::fromBase64Encoding</db:link>() and <db:link xlink:href="qbytearray.xml#fromBase64">QByteArray::fromBase64</db:link>() ignore the KeepTrailingEquals and OmitTrailingEquals options. If the IgnoreBase64DecodingErrors option is specified, they will not flag errors in case trailing equal signs are missing or if there are too many of them. If instead the AbortOnBase64DecodingErrors is specified, then the input must either have no padding or have the correct amount of equal signs.</db:para>
<db:para>This enum was introduced or modified in Qt 5.2.</db:para>
<db:para>The <db:code>Base64Options</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Base64Option&gt;. </db:code>It stores an OR combination of <db:code>Base64Option</db:code> values.</db:para>
</db:section>
<db:section xml:id="const_iterator-typedef">
<db:title>QByteArray::const_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>const_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>This typedef provides an STL-style const iterator for <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#iterator-typedef">QByteArray::iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="const_reverse_iterator-typedef">
<db:title>[since 5.6] QByteArray::const_reverse_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>const_reverse_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>This typedef provides an STL-style const reverse iterator for <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#reverse_iterator-typedef">QByteArray::reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#const_iterator-typedef">QByteArray::const_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="iterator-typedef">
<db:title>QByteArray::iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>This typedef provides an STL-style non-const iterator for <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#reverse_iterator-typedef">QByteArray::reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#const_iterator-typedef">QByteArray::const_iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reverse_iterator-typedef">
<db:title>[since 5.6] QByteArray::reverse_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>reverse_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>This typedef provides an STL-style non-const reverse iterator for <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#iterator-typedef">QByteArray::iterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="operator-const-char--2a">
<db:title>const char *QByteArray::operator const char *() const</db:title>
<db:bridgehead renderas="sect2" xml:id="operator-const-void--2a">const void *QByteArray::operator const void *() const</db:bridgehead>
<db:note>
<db:para>Use <db:link xlink:href="qbytearray.xml#constData">constData</db:link>() instead in new code.</db:para>
</db:note>
<db:para>Returns a pointer to the data stored in the byte array. The pointer can be used to access the bytes that compose the array. The data is '\0'-terminated.</db:para>
<db:para>The pointer remains valid as long as no detach happens and the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is not modified. This operator is mostly useful to pass a byte array to a function that accepts a <db:code>const char *</db:code>.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_BYTEARRAY</db:code> when you compile your applications.</db:para>
<db:para>Note: A <db:link xlink:href="qbytearray.xml">QByteArray</db:link> can store any byte values including '\0's, but most functions that take <db:code>char *</db:code> arguments assume that the data ends at the first '\0' they encounter.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#constData">constData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromBase64Encoding">
<db:title>[static, since 5.15] QByteArray::FromBase64Result QByteArray::fromBase64Encoding(QByteArray &amp;&amp;<db:emphasis>base64</db:emphasis>, QByteArray::Base64Options <db:emphasis>options</db:emphasis> = Base64Encoding)</db:title>
<db:bridgehead renderas="sect2" xml:id="fromBase64Encoding-1">[static, since 5.15] QByteArray::FromBase64Result QByteArray::fromBase64Encoding(const QByteArray &amp;<db:emphasis>base64</db:emphasis>, QByteArray::Base64Options <db:emphasis>options</db:emphasis> = Base64Encoding)</db:bridgehead>
<db:para>This is an overloaded function.</db:para>
<db:para>Decodes the Base64 array <db:code role="parameter">base64</db:code>, using the options defined by <db:code role="parameter">options</db:code>. If <db:code role="parameter">options</db:code> contains <db:code>IgnoreBase64DecodingErrors</db:code> (the default), the input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters. If <db:code role="parameter">options</db:code> contains <db:code>AbortOnBase64DecodingErrors</db:code>, then decoding will stop at the first invalid character.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">void process(const QByteArray &amp;amp;);

if (auto result = QByteArray::fromBase64Encoding(encodedData))
    process(*result);
</db:programlisting>
<db:para>The algorithm used to decode Base64-encoded data is defined in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</db:link>.</db:para>
<db:para>Returns a QByteArrayFromBase64Result object, containing the decoded data and a flag telling whether decoding was successful. If the <db:code>AbortOnBase64DecodingErrors</db:code> option was passed and the input data was invalid, it is unspecified what the decoded data contains.</db:para>
<db:para>This function was introduced in Qt 5.15.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toBase64">toBase64</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QByteArray">
<db:title>[constexpr] QByteArray::QByteArray()</db:title>
<db:constructorsynopsis>
<db:methodname>QByteArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an empty byte array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QByteArray-1">
<db:title>QByteArray::QByteArray(const char *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>size</db:emphasis> = -1)</db:title>
<db:constructorsynopsis>
<db:methodname>QByteArray</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray(const char *data, qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a byte array containing the first <db:code role="parameter">size</db:code> bytes of array <db:code role="parameter">data</db:code>.</db:para>
<db:para>If <db:code role="parameter">data</db:code> is 0, a null byte array is constructed.</db:para>
<db:para>If <db:code role="parameter">size</db:code> is negative, <db:code role="parameter">data</db:code> is assumed to point to a '\0'-terminated string and its length is determined dynamically.</db:para>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link> makes a deep copy of the string data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QByteArray-2">
<db:title>QByteArray::QByteArray(qsizetype <db:emphasis>size</db:emphasis>, char <db:emphasis>ch</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QByteArray</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray(qsizetype size, char ch)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a byte array of size <db:code role="parameter">size</db:code> with every byte set to <db:code role="parameter">ch</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fill">fill</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QByteArray-3">
<db:title>QByteArray::QByteArray(const QByteArray &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QByteArray</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray(const QByteArray &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
<db:para>This operation takes <db:link xlink:href="containers.xml#constant-time">constant time</db:link>, because <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link>. This makes returning a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), taking <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QByteArray-4">
<db:title>[since 5.2] QByteArray::QByteArray(QByteArray &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QByteArray</db:methodname>
<db:methodparam>
<db:type>QByteArray &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray(QByteArray &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Move-constructs a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> instance, making it point at the same object that <db:code role="parameter">other</db:code> was pointing to.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="dtor.QByteArray">
<db:title>QByteArray::~QByteArray()</db:title>
<db:destructorsynopsis>
<db:methodname>~QByteArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QByteArray()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the byte array.</db:para>
</db:section>
<db:section xml:id="append">
<db:title>QByteArray &amp;QByteArray::append(const QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>ba</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; append(const QByteArray &amp;ba)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends the byte array <db:code role="parameter">ba</db:code> onto the end of this byte array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;free&quot;);
QByteArray y(&quot;dom&quot;);
x.append(y);
// x == &quot;freedom&quot;
</db:programlisting>
<db:para>This is the same as insert(<db:link xlink:href="qbytearray.xml#size">size</db:link>(), <db:code role="parameter">ba</db:code>).</db:para>
<db:para>Note: <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is an <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link> class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in <db:code role="parameter">ba</db:code>. In this case, no copying of data is done, taking <db:link xlink:href="containers.xml#constant-time">constant time</db:link>. If a shared instance is modified, it will be copied (copy-on-write), taking <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:para>If the byte array being appended to is not empty, a deep copy of the data is performed, taking <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:para>The append() function is typically very fast (<db:link xlink:href="containers.xml#constant-time">constant time</db:link>), because <db:link xlink:href="qbytearray.xml">QByteArray</db:link> preallocates extra space at the end of the data, so it can grow without reallocating the entire array each time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#operator-2b-eq">operator+=</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-1">
<db:title>QByteArray &amp;QByteArray::append(char <db:emphasis>ch</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; append(char ch)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the byte <db:code role="parameter">ch</db:code> to this byte array.</db:para>
</db:section>
<db:section xml:id="append-2">
<db:title>[since 5.7] QByteArray &amp;QByteArray::append(qsizetype <db:emphasis>count</db:emphasis>, char <db:emphasis>ch</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; append(qsizetype count, char ch)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends <db:code role="parameter">count</db:code> copies of byte <db:code role="parameter">ch</db:code> to this byte array and returns a reference to this byte array.</db:para>
<db:para>If <db:code role="parameter">count</db:code> is negative or zero nothing is appended to the byte array.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="append-3">
<db:title>QByteArray &amp;QByteArray::append(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; append(const char *str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the '\0'-terminated string <db:code role="parameter">str</db:code> to this byte array.</db:para>
</db:section>
<db:section xml:id="append-4">
<db:title>QByteArray &amp;QByteArray::append(const char *<db:emphasis>str</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; append(const char *str, qsizetype len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the first <db:code role="parameter">len</db:code> bytes starting at <db:code role="parameter">str</db:code> to this byte array and returns a reference to this byte array. The bytes appended may include '\0' bytes.</db:para>
<db:para>If <db:code role="parameter">len</db:code> is negative, <db:code role="parameter">str</db:code> will be assumed to be a '\0'-terminated string and the length to be copied will be determined automatically using <db:link xlink:href="qbytearray.xml#qstrlen">qstrlen</db:link>().</db:para>
<db:para>If <db:code role="parameter">len</db:code> is zero or <db:code role="parameter">str</db:code> is null, nothing is appended to the byte array. Ensure that <db:code role="parameter">len</db:code> is <db:emphasis>not</db:emphasis> longer than <db:code role="parameter">str</db:code>.</db:para>
</db:section>
<db:section xml:id="append-5">
<db:title>QByteArray &amp;QByteArray::append(QByteArrayView <db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; append(QByteArrayView data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends <db:code role="parameter">data</db:code> to this byte array.</db:para>
</db:section>
<db:section xml:id="at">
<db:title>char QByteArray::at(qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>char</db:type>
<db:methodname>at</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">char at(qsizetype i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte at index position <db:code role="parameter">i</db:code> in the byte array.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the byte array (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qbytearray.xml#size">size</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="back">
<db:title>[since 5.10] char QByteArray::back() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>char</db:type>
<db:methodname>back</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">char back() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the last byte in the byte array. Same as <db:code>at(size() - 1)</db:code>.</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:warning>
<db:para>Calling this function on an empty byte array constitutes undefined behavior.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#front">front</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="back-1">
<db:title>[since 5.10] char &amp;QByteArray::back()</db:title>
<db:methodsynopsis>
<db:type>char &amp;</db:type>
<db:methodname>back</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">char &amp; back()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a reference to the last byte in the byte array. Same as <db:code>operator[](size() - 1)</db:code>.</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:warning>
<db:para>Calling this function on an empty byte array constitutes undefined behavior.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#front">front</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin">
<db:title>QByteArray::iterator QByteArray::begin()</db:title>
<db:methodsynopsis>
<db:type>QByteArray::iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::iterator begin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first byte in the byte-array.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>QByteArray::const_iterator QByteArray::begin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray::const_iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::const_iterator begin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads <db:link xlink:href="qbytearray.xml#begin">begin</db:link>().</db:para>
</db:section>
<db:section xml:id="capacity">
<db:title>qsizetype QByteArray::capacity() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>capacity</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype capacity() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum number of bytes that can be stored in the byte array without forcing a reallocation.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many bytes are in the byte array, call <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
<db:note>
<db:para>a statically allocated byte array will report a capacity of 0, even if it's not empty.</db:para>
</db:note>
<db:note>
<db:para>The free space position in the allocated memory block is undefined. In other words, one should not assume that the free memory is always located after the initialized elements.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>[since 5.0] QByteArray::const_iterator QByteArray::cbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray::const_iterator</db:type>
<db:methodname>cbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::const_iterator cbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first byte in the byte-array.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is modified.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[since 5.0] QByteArray::const_iterator QByteArray::cend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray::const_iterator</db:type>
<db:methodname>cend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::const_iterator cend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing just after the last byte in the byte-array.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is modified.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="chop">
<db:title>void QByteArray::chop(qsizetype <db:emphasis>n</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>chop</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void chop(qsizetype n)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes <db:code role="parameter">n</db:code> bytes from the end of the byte array.</db:para>
<db:para>If <db:code role="parameter">n</db:code> is greater than <db:link xlink:href="qbytearray.xml#size">size</db:link>(), the result is an empty byte array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;STARTTLS\r\n&quot;);
ba.chop(2);                 // ba == &quot;STARTTLS&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#resize">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#first">first</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="chopped">
<db:title>[since 5.10] QByteArray QByteArray::chopped(qsizetype <db:emphasis>len</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>chopped</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray chopped(qsizetype len) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a byte array that contains the leftmost <db:link xlink:href="qbytearray.xml#size">size</db:link>() - <db:code role="parameter">len</db:code> bytes of this byte array.</db:para>
<db:note>
<db:para>The behavior is undefined if <db:code role="parameter">len</db:code> is negative or greater than <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#endsWith">endsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QByteArray::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Clears the contents of the byte array and makes it null.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#resize">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#isNull">isNull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="compare">
<db:title>[since 6.0] int QByteArray::compare(QByteArrayView <db:emphasis>bv</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseSensitive) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>compare</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>bv</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::CaseSensitivity</db:type>
<db:parameter>cs</db:parameter>
<db:initializer>Qt::CaseSensitive</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int compare(QByteArrayView bv, Qt::CaseSensitivity cs) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an integer less than, equal to, or greater than zero depending on whether this <db:link xlink:href="qbytearray.xml">QByteArray</db:link> sorts before, at the same position as, or after the <db:link xlink:href="qbytearrayview.xml">QByteArrayView</db:link> <db:code role="parameter">bv</db:code>. The comparison is performed according to case sensitivity <db:code role="parameter">cs</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#operator-eq-eq">operator==</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#character-case">Character Case</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constBegin">
<db:title>QByteArray::const_iterator QByteArray::constBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray::const_iterator</db:type>
<db:methodname>constBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::const_iterator constBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first byte in the byte-array.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constData">
<db:title>const char *QByteArray::constData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const char *</db:type>
<db:methodname>constData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * constData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the const data stored in the byte array. The pointer can be used to access the bytes that compose the array. The data is '\0'-terminated unless the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> object was created from raw data.</db:para>
<db:para>The pointer remains valid as long as no detach happens and the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is not modified.</db:para>
<db:para>This function is mostly useful to pass a byte array to a function that accepts a <db:code>const char *</db:code>.</db:para>
<db:para>Note: A <db:link xlink:href="qbytearray.xml">QByteArray</db:link> can store any byte values including '\0's, but most functions that take <db:code>char *</db:code> arguments assume that the data ends at the first '\0' they encounter.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QByteArray::const_iterator QByteArray::constEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray::const_iterator</db:type>
<db:methodname>constEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::const_iterator constEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing just after the last byte in the byte-array.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>[since 6.0] bool QByteArray::contains(QByteArrayView <db:emphasis>bv</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>bv</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(QByteArrayView bv) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this byte array contains an occurrence of the sequence of bytes viewed by <db:code role="parameter">bv</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#count-2">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains-1">
<db:title>bool QByteArray::contains(char <db:emphasis>ch</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(char ch) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if the byte array contains the byte <db:code role="parameter">ch</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="count">
<db:title>[since 6.0] qsizetype QByteArray::count(QByteArrayView <db:emphasis>bv</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>count</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>bv</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype count(QByteArrayView bv) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of (potentially overlapping) occurrences of the sequence of bytes viewed by <db:code role="parameter">bv</db:code> in this byte array.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count-1">
<db:title>qsizetype QByteArray::count(char <db:emphasis>ch</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>count</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype count(char ch) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the number of occurrences of byte <db:code role="parameter">ch</db:code> in the byte array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count-2">
<db:title>qsizetype QByteArray::count() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>count</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype count() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="crbegin">
<db:title>[since 5.6] QByteArray::const_reverse_iterator QByteArray::crbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray::const_reverse_iterator</db:type>
<db:methodname>crbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::const_reverse_iterator crbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first byte in the byte-array, in reverse order.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is modified.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="crend">
<db:title>[since 5.6] QByteArray::const_reverse_iterator QByteArray::crend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray::const_reverse_iterator</db:type>
<db:methodname>crend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::const_reverse_iterator crend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing just after the last byte in the byte-array, in reverse order.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is modified.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>char *QByteArray::data()</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>data</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">char * data()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the data stored in the byte array. The pointer can be used to access and modify the bytes that compose the array. The data is '\0'-terminated, i.e. the number of bytes you can access following the returned pointer is <db:link xlink:href="qbytearray.xml#size">size</db:link>() + 1, including the '\0' terminator.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Hello world&quot;);
char *data = ba.data();
while (*data) {
    cout &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; *data &amp;lt;&amp;lt; &quot;]&quot; &amp;lt;&amp;lt; Qt::endl;
    ++data;
}
</db:programlisting>
<db:para>The pointer remains valid as long as no detach happens and the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is not modified.</db:para>
<db:para>For read-only access, <db:link xlink:href="qbytearray.xml#constData">constData</db:link>() is faster because it never causes a <db:link xlink:href="implicit-sharing.xml#deep-copy">deep copy</db:link> to occur.</db:para>
<db:para>This function is mostly useful to pass a byte array to a function that accepts a <db:code>const char *</db:code>.</db:para>
<db:para>The following example makes a copy of the char* returned by data(), but it will corrupt the heap and cause a crash because it does not allocate a byte for the '\0' at the end:</db:para>
<db:programlisting language="cpp">QString tmp = &quot;test&quot;;
QByteArray text = tmp.toLocal8Bit();
char *data = new char[text.size()];
strcpy(data, text.data());
delete [] data;
</db:programlisting>
<db:para>This one allocates the correct amount of space:</db:para>
<db:programlisting language="cpp">QString tmp = &quot;test&quot;;
QByteArray text = tmp.toLocal8Bit();
char *data = new char[text.size() + 1];
strcpy(data, text.data());
delete [] data;
</db:programlisting>
<db:para>Note: A <db:link xlink:href="qbytearray.xml">QByteArray</db:link> can store any byte values including '\0's, but most functions that take <db:code>char *</db:code> arguments assume that the data ends at the first '\0' they encounter.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#constData">constData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data-1">
<db:title>const char *QByteArray::data() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const char *</db:type>
<db:methodname>data</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * data() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="end">
<db:title>QByteArray::iterator QByteArray::end()</db:title>
<db:methodsynopsis>
<db:type>QByteArray::iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::iterator end()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing just after the last byte in the byte-array.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is modified.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>QByteArray::const_iterator QByteArray::end() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray::const_iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::const_iterator end() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads <db:link xlink:href="qbytearray.xml#end">end</db:link>().</db:para>
</db:section>
<db:section xml:id="endsWith">
<db:title>[since 6.0] bool QByteArray::endsWith(QByteArrayView <db:emphasis>bv</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>endsWith</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>bv</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool endsWith(QByteArrayView bv) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this byte array ends with the sequence of bytes viewed by <db:code role="parameter">bv</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray url(&quot;http://qt-project.org/doc/qt-5.0/qtdoc/index.html&quot;);
if (url.endsWith(&quot;.html&quot;))
    ...
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#startsWith">startsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#last">last</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="endsWith-1">
<db:title>bool QByteArray::endsWith(char <db:emphasis>ch</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>endsWith</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool endsWith(char ch) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if this byte array ends with byte <db:code role="parameter">ch</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="fill">
<db:title>QByteArray &amp;QByteArray::fill(char <db:emphasis>ch</db:emphasis>, qsizetype <db:emphasis>size</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>fill</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; fill(char ch, qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets every byte in the byte array to <db:code role="parameter">ch</db:code>. If <db:code role="parameter">size</db:code> is different from -1 (the default), the byte array is resized to size <db:code role="parameter">size</db:code> beforehand.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Istambul&quot;);
ba.fill('o');
// ba == &quot;oooooooo&quot;

ba.fill('X', 2);
// ba == &quot;XX&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first">
<db:title>[since 6.0] QByteArray QByteArray::first(qsizetype <db:emphasis>n</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>first</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray first(qsizetype n) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the first <db:code role="parameter">n</db:code> bytes of the byte array.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">n</db:code> &lt; 0 or <db:code role="parameter">n</db:code> &gt; <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;Pineapple&quot;);
QByteArray y = x.first(4);
// y == &quot;Pine&quot;
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#startsWith">startsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromBase64">
<db:title>[static, since 5.2] QByteArray QByteArray::fromBase64(const QByteArray &amp;<db:emphasis>base64</db:emphasis>, QByteArray::Base64Options <db:emphasis>options</db:emphasis> = Base64Encoding)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>fromBase64</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>base64</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QByteArray::Base64Options</db:type>
<db:parameter>options</db:parameter>
<db:initializer>Base64Encoding</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray fromBase64(const QByteArray &amp;base64, QByteArray::Base64Options options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a decoded copy of the Base64 array <db:code role="parameter">base64</db:code>, using the options defined by <db:code role="parameter">options</db:code>. If <db:code role="parameter">options</db:code> contains <db:code>IgnoreBase64DecodingErrors</db:code> (the default), the input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters. If <db:code role="parameter">options</db:code> contains <db:code>AbortOnBase64DecodingErrors</db:code>, then decoding will stop at the first invalid character.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">QByteArray text = QByteArray::fromBase64(&quot;UXQgaXMgZ3JlYXQh&quot;);
text.data();            // returns &quot;Qt is great!&quot;

QByteArray::fromBase64(&quot;PHA+SGVsbG8/PC9wPg==&quot;, QByteArray::Base64Encoding); // returns &quot;&amp;lt;p&amp;gt;Hello?&amp;lt;/p&amp;gt;&quot;
QByteArray::fromBase64(&quot;PHA-SGVsbG8_PC9wPg==&quot;, QByteArray::Base64UrlEncoding); // returns &quot;&amp;lt;p&amp;gt;Hello?&amp;lt;/p&amp;gt;&quot;
</db:programlisting>
<db:para>The algorithm used to decode Base64-encoded data is defined in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</db:link>.</db:para>
<db:para>Returns the decoded data, or, if the <db:code>AbortOnBase64DecodingErrors</db:code> option was passed and the input data was invalid, an empty byte array.</db:para>
<db:note>
<db:para>The <db:link xlink:href="qbytearray.xml#fromBase64Encoding">fromBase64Encoding</db:link>() function is recommended in new code.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toBase64">toBase64</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromBase64Encoding">fromBase64Encoding</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromCFData">
<db:title>[static, since 5.3] QByteArray QByteArray::fromCFData(CFDataRef <db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>fromCFData</db:methodname>
<db:methodparam>
<db:type>CFDataRef</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray fromCFData(CFDataRef data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs a new <db:link xlink:href="qbytearray.xml">QByteArray</db:link> containing a copy of the CFData <db:code role="parameter">data</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromRawCFData">fromRawCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toRawCFData">toRawCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toCFData">toCFData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromHex">
<db:title>[static] QByteArray QByteArray::fromHex(const QByteArray &amp;<db:emphasis>hexEncoded</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>fromHex</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>hexEncoded</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray fromHex(const QByteArray &amp;hexEncoded)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a decoded copy of the hex encoded array <db:code role="parameter">hexEncoded</db:code>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">QByteArray text = QByteArray::fromHex(&quot;517420697320677265617421&quot;);
text.data();            // returns &quot;Qt is great!&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toHex">toHex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromNSData">
<db:title>[static, since 5.3] QByteArray QByteArray::fromNSData(const NSData *<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>fromNSData</db:methodname>
<db:methodparam>
<db:type>const NSData *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray fromNSData(const NSData *data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs a new <db:link xlink:href="qbytearray.xml">QByteArray</db:link> containing a copy of the NSData <db:code role="parameter">data</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromRawNSData">fromRawNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toNSData">toNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toRawNSData">toRawNSData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromPercentEncoding">
<db:title>[static] QByteArray QByteArray::fromPercentEncoding(const QByteArray &amp;<db:emphasis>input</db:emphasis>, char <db:emphasis>percent</db:emphasis> = '%')</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>fromPercentEncoding</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>input</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>percent</db:parameter>
<db:initializer>'%'</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray fromPercentEncoding(const QByteArray &amp;input, char percent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a decoded copy of the URI/URL-style percent-encoded <db:code role="parameter">input</db:code>. The <db:code role="parameter">percent</db:code> parameter allows you to replace the '%' character for another (for instance, '_' or '=').</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">QByteArray text = QByteArray::fromPercentEncoding(&quot;Qt%20is%20great%33&quot;);
text.data();            // returns &quot;Qt is great!&quot;
</db:programlisting>
<db:note>
<db:para>Given invalid input (such as a string containing the sequence &quot;%G5&quot;, which is not a valid hexadecimal number) the output will be invalid as well. As an example: the sequence &quot;%G5&quot; could be decoded to 'W'.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toPercentEncoding">toPercentEncoding</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#fromPercentEncoding">QUrl::fromPercentEncoding</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromRawCFData">
<db:title>[static, since 5.3] QByteArray QByteArray::fromRawCFData(CFDataRef <db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>fromRawCFData</db:methodname>
<db:methodparam>
<db:type>CFDataRef</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray fromRawCFData(CFDataRef data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> that uses the bytes of the CFData <db:code role="parameter">data</db:code>.</db:para>
<db:para>The <db:code role="parameter">data</db:code>'s bytes are not copied.</db:para>
<db:para>The caller guarantees that the CFData will not be deleted or modified as long as this <db:link xlink:href="qbytearray.xml">QByteArray</db:link> object exists.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromCFData">fromCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toRawCFData">toRawCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toCFData">toCFData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromRawData">
<db:title>[static] QByteArray QByteArray::fromRawData(const char *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>fromRawData</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray fromRawData(const char *data, qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> that uses the first <db:code role="parameter">size</db:code> bytes of the <db:code role="parameter">data</db:code> array. The bytes are <db:emphasis>not</db:emphasis> copied. The <db:link xlink:href="qbytearray.xml">QByteArray</db:link> will contain the <db:code role="parameter">data</db:code> pointer. The caller guarantees that <db:code role="parameter">data</db:code> will not be deleted or modified as long as this <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and any copies of it exist that have not been modified. In other words, because <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is an <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link> class and the instance returned by this function contains the <db:code role="parameter">data</db:code> pointer, the caller must not delete <db:code role="parameter">data</db:code> or modify it directly as long as the returned <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and any copies exist. However, <db:link xlink:href="qbytearray.xml">QByteArray</db:link> does not take ownership of <db:code role="parameter">data</db:code>, so the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> destructor will never delete the raw <db:code role="parameter">data</db:code>, even when the last <db:link xlink:href="qbytearray.xml">QByteArray</db:link> referring to <db:code role="parameter">data</db:code> is destroyed.</db:para>
<db:para>A subsequent attempt to modify the contents of the returned <db:link xlink:href="qbytearray.xml">QByteArray</db:link> or any copy made from it will cause it to create a deep copy of the <db:code role="parameter">data</db:code> array before doing the modification. This ensures that the raw <db:code role="parameter">data</db:code> array itself will never be modified by <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>Here is an example of how to read data using a <db:link xlink:href="qdatastream.xml">QDataStream</db:link> on raw data in memory without copying the raw data into a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>:</db:para>
<db:programlisting language="cpp"> static const char mydata[] = {
    '\x00', '\x00', '\x03', '\x84', '\x78', '\x9c', '\x3b', '\x76',
    '\xec', '\x18', '\xc3', '\x31', '\x0a', '\xf1', '\xcc', '\x99',
    ...
    '\x6d', '\x5b'
};

QByteArray data = QByteArray::fromRawData(mydata, sizeof(mydata));
QDataStream in(&amp;amp;data, QIODevice::ReadOnly);
...
</db:programlisting>
<db:warning>
<db:para>A byte array created with fromRawData() is <db:emphasis>not</db:emphasis> '\0'-terminated, unless the raw data contains a '\0' byte at position <db:code role="parameter">size</db:code>. While that does not matter for <db:link xlink:href="qdatastream.xml">QDataStream</db:link> or functions like <db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>(), passing the byte array to a function accepting a <db:code>const char *</db:code> expected to be '\0'-terminated will fail.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#setRawData">setRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#constData">constData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromRawNSData">
<db:title>[static, since 5.3] QByteArray QByteArray::fromRawNSData(const NSData *<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>fromRawNSData</db:methodname>
<db:methodparam>
<db:type>const NSData *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray fromRawNSData(const NSData *data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> that uses the bytes of the NSData <db:code role="parameter">data</db:code>.</db:para>
<db:para>The <db:code role="parameter">data</db:code>'s bytes are not copied.</db:para>
<db:para>The caller guarantees that the NSData will not be deleted or modified as long as this <db:link xlink:href="qbytearray.xml">QByteArray</db:link> object exists.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromNSData">fromNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toRawNSData">toRawNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toNSData">toNSData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromStdString">
<db:title>[static, since 5.4] QByteArray QByteArray::fromStdString(const std::string &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>fromStdString</db:methodname>
<db:methodparam>
<db:type>const std::string &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray fromStdString(const std::string &amp;str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a copy of the <db:code role="parameter">str</db:code> string as a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toStdString">toStdString</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#fromStdString">QString::fromStdString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="front">
<db:title>[since 5.10] char QByteArray::front() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>char</db:type>
<db:methodname>front</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">char front() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the first byte in the byte array. Same as <db:code>at(0)</db:code>.</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:warning>
<db:para>Calling this function on an empty byte array constitutes undefined behavior.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#back">back</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="front-1">
<db:title>[since 5.10] char &amp;QByteArray::front()</db:title>
<db:methodsynopsis>
<db:type>char &amp;</db:type>
<db:methodname>front</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">char &amp; front()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a reference to the first byte in the byte array. Same as <db:code>operator[](0)</db:code>.</db:para>
<db:para>This function is provided for STL compatibility.</db:para>
<db:warning>
<db:para>Calling this function on an empty byte array constitutes undefined behavior.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#back">back</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="indexOf">
<db:title>[since 6.0] qsizetype QByteArray::indexOf(QByteArrayView <db:emphasis>bv</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = 0) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>indexOf</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>bv</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>from</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype indexOf(QByteArrayView bv, qsizetype from) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the index position of the start of the first occurrence of the sequence of bytes viewed by <db:code role="parameter">bv</db:code> in this byte array, searching forward from index position <db:code role="parameter">from</db:code>. Returns -1 if no match is found.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;sticky question&quot;);
QByteArrayView y(&quot;sti&quot;);
x.indexOf(y);               // returns 0
x.indexOf(y, 1);            // returns 10
x.indexOf(y, 10);           // returns 10
x.indexOf(y, 11);           // returns -1
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#lastIndexOf">lastIndexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#count-2">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="indexOf-1">
<db:title>qsizetype QByteArray::indexOf(char <db:emphasis>ch</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = 0) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>indexOf</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>from</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype indexOf(char ch, qsizetype from) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the index position of the start of the first occurrence of the byte <db:code role="parameter">ch</db:code> in this byte array, searching forward from index position <db:code role="parameter">from</db:code>. Returns -1 if no match is found.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;ABCBA&quot;);
ba.indexOf(&quot;B&quot;);            // returns 1
ba.indexOf(&quot;B&quot;, 1);         // returns 1
ba.indexOf(&quot;B&quot;, 2);         // returns 3
ba.indexOf(&quot;X&quot;);            // returns -1
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#lastIndexOf">lastIndexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert">
<db:title>[since 6.0] QByteArray &amp;QByteArray::insert(qsizetype <db:emphasis>i</db:emphasis>, QByteArrayView <db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; insert(qsizetype i, QByteArrayView data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts <db:code role="parameter">data</db:code> at index position <db:code role="parameter">i</db:code> and returns a reference to this byte array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Meal&quot;);
ba.insert(1, QByteArrayView(&quot;ontr&quot;));
// ba == &quot;Montreal&quot;
</db:programlisting>
<db:para>For large byte arrays, this operation can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because it requires moving all the bytes at indexes <db:code role="parameter">i</db:code> and above by at least one position further in memory.</db:para>
<db:para>This array grows to accommodate the insertion. If <db:code role="parameter">i</db:code> is beyond the end of the array, the array is first extended with space characters to reach this <db:code role="parameter">i</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#replace">replace</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-1">
<db:title>QByteArray &amp;QByteArray::insert(qsizetype <db:emphasis>i</db:emphasis>, const char *<db:emphasis>s</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>s</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; insert(qsizetype i, const char *s)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts <db:code role="parameter">s</db:code> at index position <db:code role="parameter">i</db:code> and returns a reference to this byte array.</db:para>
<db:para>This array grows to accommodate the insertion. If <db:code role="parameter">i</db:code> is beyond the end of the array, the array is first extended with space characters to reach this <db:code role="parameter">i</db:code>.</db:para>
<db:para>The function is equivalent to <db:code>insert(i, QByteArrayView(s))</db:code></db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#replace">replace</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-2">
<db:title>QByteArray &amp;QByteArray::insert(qsizetype <db:emphasis>i</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; insert(qsizetype i, const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts <db:code role="parameter">data</db:code> at index position <db:code role="parameter">i</db:code> and returns a reference to this byte array.</db:para>
<db:para>This array grows to accommodate the insertion. If <db:code role="parameter">i</db:code> is beyond the end of the array, the array is first extended with space characters to reach this <db:code role="parameter">i</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#prepend">prepend</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#replace">replace</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-3">
<db:title>[since 5.7] QByteArray &amp;QByteArray::insert(qsizetype <db:emphasis>i</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, char <db:emphasis>ch</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; insert(qsizetype i, qsizetype count, char ch)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts <db:code role="parameter">count</db:code> copies of byte <db:code role="parameter">ch</db:code> at index position <db:code role="parameter">i</db:code> in the byte array.</db:para>
<db:para>This array grows to accommodate the insertion. If <db:code role="parameter">i</db:code> is beyond the end of the array, the array is first extended with space characters to reach this <db:code role="parameter">i</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="insert-4">
<db:title>QByteArray &amp;QByteArray::insert(qsizetype <db:emphasis>i</db:emphasis>, char <db:emphasis>ch</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; insert(qsizetype i, char ch)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts byte <db:code role="parameter">ch</db:code> at index position <db:code role="parameter">i</db:code> in the byte array.</db:para>
<db:para>This array grows to accommodate the insertion. If <db:code role="parameter">i</db:code> is beyond the end of the array, the array is first extended with space characters to reach this <db:code role="parameter">i</db:code>.</db:para>
</db:section>
<db:section xml:id="insert-5">
<db:title>QByteArray &amp;QByteArray::insert(qsizetype <db:emphasis>i</db:emphasis>, const char *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; insert(qsizetype i, const char *data, qsizetype len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts <db:code role="parameter">len</db:code> bytes, starting at <db:code role="parameter">data</db:code>, at position <db:code role="parameter">i</db:code> in the byte array.</db:para>
<db:para>This array grows to accommodate the insertion. If <db:code role="parameter">i</db:code> is beyond the end of the array, the array is first extended with space characters to reach this <db:code role="parameter">i</db:code>.</db:para>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QByteArray::isEmpty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isEmpty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isEmpty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the byte array has size 0; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray().isEmpty();         // returns true
QByteArray(&quot;&quot;).isEmpty();       // returns true
QByteArray(&quot;abc&quot;).isEmpty();    // returns false
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isLower">
<db:title>[since 5.12] bool QByteArray::isLower() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isLower</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isLower() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this byte array contains only lowercase ASCII letters, otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#isUpper">isUpper</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toLower">toLower</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QByteArray::isNull() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isNull</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isNull() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this byte array is null; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray().isNull();          // returns true
QByteArray(&quot;&quot;).isNull();        // returns false
QByteArray(&quot;abc&quot;).isNull();     // returns false
</db:programlisting>
<db:para>Qt makes a distinction between null byte arrays and empty byte arrays for historical reasons. For most applications, what matters is whether or not a byte array contains any data, and this can be determined using <db:link xlink:href="qbytearray.xml#isEmpty">isEmpty</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isUpper">
<db:title>[since 5.12] bool QByteArray::isUpper() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isUpper</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isUpper() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this byte array contains only ASCII uppercase letters, otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#isLower">isLower</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toUpper">toUpper</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last">
<db:title>[since 6.0] QByteArray QByteArray::last(qsizetype <db:emphasis>n</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>last</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray last(qsizetype n) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the last <db:code role="parameter">n</db:code> bytes of the byte array.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">n</db:code> &lt; 0 or <db:code role="parameter">n</db:code> &gt; <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;Pineapple&quot;);
QByteArray y = x.last(5);
// y == &quot;apple&quot;
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#endsWith">endsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastIndexOf">
<db:title>[since 6.0] qsizetype QByteArray::lastIndexOf(QByteArrayView <db:emphasis>bv</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>lastIndexOf</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>bv</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>from</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype lastIndexOf(QByteArrayView bv, qsizetype from) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the index position of the start of the last occurrence of the sequence of bytes viewed by <db:code role="parameter">bv</db:code> in this byte array, searching backward from index position <db:code role="parameter">from</db:code>. If <db:code role="parameter">from</db:code> is -1 (the default), the search starts from the end of the byte array. Returns -1 if no match is found.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;crazy azimuths&quot;);
QByteArrayView y(&quot;az&quot;);
x.lastIndexOf(y);           // returns 6
x.lastIndexOf(y, 6);        // returns 6
x.lastIndexOf(y, 5);        // returns 2
x.lastIndexOf(y, 1);        // returns -1
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#contains">contains</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#count-2">count</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastIndexOf-1">
<db:title>qsizetype QByteArray::lastIndexOf(char <db:emphasis>ch</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>lastIndexOf</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>from</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype lastIndexOf(char ch, qsizetype from) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns the index position of the start of the last occurrence of byte <db:code role="parameter">ch</db:code> in this byte array, searching backward from index position <db:code role="parameter">from</db:code>. If <db:code role="parameter">from</db:code> is -1 (the default), the search starts at the last byte (at index <db:link xlink:href="qbytearray.xml#size">size</db:link>() - 1). Returns -1 if no match is found.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;ABCBA&quot;);
ba.lastIndexOf(&quot;B&quot;);        // returns 3
ba.lastIndexOf(&quot;B&quot;, 3);     // returns 3
ba.lastIndexOf(&quot;B&quot;, 2);     // returns 1
ba.lastIndexOf(&quot;X&quot;);        // returns -1
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="left">
<db:title>QByteArray QByteArray::left(qsizetype <db:emphasis>len</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>left</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray left(qsizetype len) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a byte array that contains the first <db:code role="parameter">len</db:code> bytes of this byte array.</db:para>
<db:para>If you know that <db:code role="parameter">len</db:code> cannot be out of bounds, use <db:link xlink:href="qbytearray.xml#first">first</db:link>() instead in new code, because it is faster.</db:para>
<db:para>The entire byte array is returned if <db:code role="parameter">len</db:code> is greater than <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
<db:para>Returns an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link> if <db:code role="parameter">len</db:code> is smaller than 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#startsWith">startsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="leftJustified">
<db:title>QByteArray QByteArray::leftJustified(qsizetype <db:emphasis>width</db:emphasis>, char <db:emphasis>fill</db:emphasis> = ' ', bool <db:emphasis>truncate</db:emphasis> = false) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>leftJustified</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>width</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>fill</db:parameter>
<db:initializer>' '</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>truncate</db:parameter>
<db:initializer>false</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray leftJustified(qsizetype width, char fill, bool truncate) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a byte array of size <db:code role="parameter">width</db:code> that contains this byte array padded with the <db:code role="parameter">fill</db:code> byte.</db:para>
<db:para>If <db:code role="parameter">truncate</db:code> is false and the <db:link xlink:href="qbytearray.xml#size">size</db:link>() of the byte array is more than <db:code role="parameter">width</db:code>, then the returned byte array is a copy of this byte array.</db:para>
<db:para>If <db:code role="parameter">truncate</db:code> is true and the <db:link xlink:href="qbytearray.xml#size">size</db:link>() of the byte array is more than <db:code role="parameter">width</db:code>, then any bytes in a copy of the byte array after position <db:code role="parameter">width</db:code> are removed, and the copy is returned.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;apple&quot;);
QByteArray y = x.leftJustified(8, '.');   // y == &quot;apple...&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#rightJustified">rightJustified</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="length">
<db:title>qsizetype QByteArray::length() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>length</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype length() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Same as <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
</db:section>
<db:section xml:id="mid">
<db:title>QByteArray QByteArray::mid(qsizetype <db:emphasis>pos</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>mid</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray mid(qsizetype pos, qsizetype len) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a byte array containing <db:code role="parameter">len</db:code> bytes from this byte array, starting at position <db:code role="parameter">pos</db:code>.</db:para>
<db:para>If you know that <db:code role="parameter">pos</db:code> and <db:code role="parameter">len</db:code> cannot be out of bounds, use <db:link xlink:href="qbytearray.xml#sliced">sliced</db:link>() instead in new code, because it is faster.</db:para>
<db:para>If <db:code role="parameter">len</db:code> is -1 (the default), or <db:code role="parameter">pos</db:code> + <db:code role="parameter">len</db:code> &gt;= <db:link xlink:href="qbytearray.xml#size">size</db:link>(), returns a byte array containing all bytes starting at position <db:code role="parameter">pos</db:code> until the end of the byte array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="number">
<db:title>[static] QByteArray QByteArray::number(int <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>number</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray number(int n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a byte array containing the printed value of the number <db:code role="parameter">n</db:code> to base <db:code role="parameter">base</db:code> (ten by default). Bases 2 through 36 are supported, using letters for digits beyond 9: A is ten, B is eleven and so on.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">int n = 63;
QByteArray::number(n);              // returns &quot;63&quot;
QByteArray::number(n, 16);          // returns &quot;3f&quot;
QByteArray::number(n, 16).toUpper();  // returns &quot;3F&quot;
</db:programlisting>
<db:note>
<db:para>The format of the number is not localized; the default C locale is used regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#setNum">setNum</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toInt">toInt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="number-1">
<db:title>[static] QByteArray QByteArray::number(uint <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>number</db:methodname>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray number(uint n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toUInt">toUInt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="number-2">
<db:title>[static] QByteArray QByteArray::number(long <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>number</db:methodname>
<db:methodparam>
<db:type>long</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray number(long n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toLong">toLong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="number-3">
<db:title>[static] QByteArray QByteArray::number(ulong <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>number</db:methodname>
<db:methodparam>
<db:type>ulong</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray number(ulong n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toULong">toULong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="number-4">
<db:title>[static] QByteArray QByteArray::number(qlonglong <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>number</db:methodname>
<db:methodparam>
<db:type>qlonglong</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray number(qlonglong n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toLongLong">toLongLong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="number-5">
<db:title>[static] QByteArray QByteArray::number(qulonglong <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>number</db:methodname>
<db:methodparam>
<db:type>qulonglong</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray number(qulonglong n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toULongLong">toULongLong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="number-6">
<db:title>[static] QByteArray QByteArray::number(double <db:emphasis>n</db:emphasis>, char <db:emphasis>f</db:emphasis> = 'g', int <db:emphasis>prec</db:emphasis> = 6)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>number</db:methodname>
<db:methodparam>
<db:type>double</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>f</db:parameter>
<db:initializer>'g'</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>prec</db:parameter>
<db:initializer>6</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray number(double n, char f, int prec)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a byte array that contains the printed value of <db:code role="parameter">n</db:code>, formatted in format <db:code role="parameter">f</db:code> with precision <db:code role="parameter">prec</db:code>.</db:para>
<db:para>Argument <db:code role="parameter">n</db:code> is formatted according to the <db:code role="parameter">f</db:code> format specified, which is <db:code>g</db:code> by default, and can be any of the following:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Format</db:para>
</db:th>
<db:th>
<db:para>Meaning</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:code>e</db:code></db:para>
</db:td>
<db:td>
<db:para>format as [-]9.9e[+|-]999</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>E</db:code></db:para>
</db:td>
<db:td>
<db:para>format as [-]9.9E[+|-]999</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>f</db:code></db:para>
</db:td>
<db:td>
<db:para>format as [-]9.9</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>g</db:code></db:para>
</db:td>
<db:td>
<db:para>use <db:code>e</db:code> or <db:code>f</db:code> format, whichever is the most concise</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>G</db:code></db:para>
</db:td>
<db:td>
<db:para>use <db:code>E</db:code> or <db:code>f</db:code> format, whichever is the most concise</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>With 'e', 'E', and 'f', <db:code role="parameter">prec</db:code> is the number of digits after the decimal point. With 'g' and 'G', <db:code role="parameter">prec</db:code> is the maximum number of significant digits (trailing zeroes are omitted).</db:para>
<db:programlisting language="cpp">QByteArray ba = QByteArray::number(12.3456, 'E', 3);
// ba == 1.235E+01
</db:programlisting>
<db:note>
<db:para>The format of the number is not localized; the default C locale is used regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toDouble">toDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="prepend">
<db:title>QByteArray &amp;QByteArray::prepend(QByteArrayView <db:emphasis>ba</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>prepend</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>ba</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; prepend(QByteArrayView ba)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Prepends the byte array view <db:code role="parameter">ba</db:code> to this byte array and returns a reference to this byte array.</db:para>
<db:para>This operation is typically very fast (<db:link xlink:href="containers.xml#constant-time">constant time</db:link>), because <db:link xlink:href="qbytearray.xml">QByteArray</db:link> preallocates extra space at the beginning of the data, so it can grow without reallocating the entire array each time.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;ship&quot;);
QByteArray y(&quot;air&quot;);
x.prepend(y);
// x == &quot;airship&quot;
</db:programlisting>
<db:para>This is the same as insert(0, <db:code role="parameter">ba</db:code>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="prepend-1">
<db:title>QByteArray &amp;QByteArray::prepend(char <db:emphasis>ch</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>prepend</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; prepend(char ch)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Prepends the byte <db:code role="parameter">ch</db:code> to this byte array.</db:para>
</db:section>
<db:section xml:id="prepend-2">
<db:title>[since 5.7] QByteArray &amp;QByteArray::prepend(qsizetype <db:emphasis>count</db:emphasis>, char <db:emphasis>ch</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>prepend</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; prepend(qsizetype count, char ch)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Prepends <db:code role="parameter">count</db:code> copies of byte <db:code role="parameter">ch</db:code> to this byte array.</db:para>
<db:para>This function was introduced in Qt 5.7.</db:para>
</db:section>
<db:section xml:id="prepend-3">
<db:title>QByteArray &amp;QByteArray::prepend(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>prepend</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; prepend(const char *str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Prepends the '\0'-terminated string <db:code role="parameter">str</db:code> to this byte array.</db:para>
</db:section>
<db:section xml:id="prepend-4">
<db:title>QByteArray &amp;QByteArray::prepend(const char *<db:emphasis>str</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>prepend</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; prepend(const char *str, qsizetype len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Prepends <db:code role="parameter">len</db:code> bytes starting at <db:code role="parameter">str</db:code> to this byte array. The bytes prepended may include '\0' bytes.</db:para>
</db:section>
<db:section xml:id="prepend-5">
<db:title>QByteArray &amp;QByteArray::prepend(const QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>prepend</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>ba</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; prepend(const QByteArray &amp;ba)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Prepends <db:code role="parameter">ba</db:code> to this byte array.</db:para>
</db:section>
<db:section xml:id="push_back">
<db:title>void QByteArray::push_back(const QByteArray &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_back</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_back(const QByteArray &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to append(<db:code role="parameter">other</db:code>).</db:para>
</db:section>
<db:section xml:id="push_back-1">
<db:title>void QByteArray::push_back(char <db:emphasis>ch</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_back</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_back(char ch)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as append(<db:code role="parameter">ch</db:code>).</db:para>
</db:section>
<db:section xml:id="push_back-2">
<db:title>void QByteArray::push_back(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_back</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_back(const char *str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as append(<db:code role="parameter">str</db:code>).</db:para>
</db:section>
<db:section xml:id="push_back-3">
<db:title>[since 6.0] void QByteArray::push_back(QByteArrayView <db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_back</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_back(QByteArrayView str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as append(<db:code role="parameter">str</db:code>).</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="push_front">
<db:title>void QByteArray::push_front(const QByteArray &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_front</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_front(const QByteArray &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to prepend(<db:code role="parameter">other</db:code>).</db:para>
</db:section>
<db:section xml:id="push_front-1">
<db:title>void QByteArray::push_front(char <db:emphasis>ch</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_front</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_front(char ch)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as prepend(<db:code role="parameter">ch</db:code>).</db:para>
</db:section>
<db:section xml:id="push_front-2">
<db:title>void QByteArray::push_front(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_front</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_front(const char *str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as prepend(<db:code role="parameter">str</db:code>).</db:para>
</db:section>
<db:section xml:id="push_front-3">
<db:title>[since 6.0] void QByteArray::push_front(QByteArrayView <db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_front</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_front(QByteArrayView str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as prepend(<db:code role="parameter">str</db:code>).</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="rbegin">
<db:title>[since 5.6] QByteArray::reverse_iterator QByteArray::rbegin()</db:title>
<db:methodsynopsis>
<db:type>QByteArray::reverse_iterator</db:type>
<db:methodname>rbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::reverse_iterator rbegin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first byte in the byte-array, in reverse order.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is modified.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rbegin-1">
<db:title>[since 5.6] QByteArray::const_reverse_iterator QByteArray::rbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray::const_reverse_iterator</db:type>
<db:methodname>rbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::const_reverse_iterator rbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="remove">
<db:title>QByteArray &amp;QByteArray::remove(qsizetype <db:emphasis>pos</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; remove(qsizetype pos, qsizetype len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes <db:code role="parameter">len</db:code> bytes from the array, starting at index position <db:code role="parameter">pos</db:code>, and returns a reference to the array.</db:para>
<db:para>If <db:code role="parameter">pos</db:code> is out of range, nothing happens. If <db:code role="parameter">pos</db:code> is valid, but <db:code role="parameter">pos</db:code> + <db:code role="parameter">len</db:code> is larger than the size of the array, the array is truncated at position <db:code role="parameter">pos</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Montreal&quot;);
ba.remove(1, 4);
// ba == &quot;Meal&quot;
</db:programlisting>
<db:para>Element removal will preserve the array's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <db:link xlink:href="qbytearray.xml#squeeze">squeeze</db:link>() after the last change to the array's size.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#replace">replace</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend">
<db:title>[since 5.6] QByteArray::reverse_iterator QByteArray::rend()</db:title>
<db:methodsynopsis>
<db:type>QByteArray::reverse_iterator</db:type>
<db:methodname>rend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::reverse_iterator rend()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing just after the last byte in the byte-array, in reverse order.</db:para>
<db:warning>
<db:para>The returned iterator is invalidated on detachment or when the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is modified.</db:para>
</db:warning>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend-1">
<db:title>[since 5.6] QByteArray::const_reverse_iterator QByteArray::rend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray::const_reverse_iterator</db:type>
<db:methodname>rend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray::const_reverse_iterator rend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="repeated">
<db:title>QByteArray QByteArray::repeated(qsizetype <db:emphasis>times</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>repeated</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>times</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray repeated(qsizetype times) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a copy of this byte array repeated the specified number of <db:code role="parameter">times</db:code>.</db:para>
<db:para>If <db:code role="parameter">times</db:code> is less than 1, an empty byte array is returned.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;ab&quot;);
ba.repeated(4);             // returns &quot;abababab&quot;
</db:programlisting>
</db:section>
<db:section xml:id="replace">
<db:title>QByteArray &amp;QByteArray::replace(qsizetype <db:emphasis>pos</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>, QByteArrayView <db:emphasis>after</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>replace</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>after</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; replace(qsizetype pos, qsizetype len, QByteArrayView after)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces <db:code role="parameter">len</db:code> bytes from index position <db:code role="parameter">pos</db:code> with the byte array <db:code role="parameter">after</db:code>, and returns a reference to this byte array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;Say yes!&quot;);
QByteArray y(&quot;no&quot;);
x.replace(4, 3, y);
// x == &quot;Say no!&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="replace-1">
<db:title>QByteArray &amp;QByteArray::replace(qsizetype <db:emphasis>pos</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>, const char *<db:emphasis>after</db:emphasis>, qsizetype <db:emphasis>alen</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>replace</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>after</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>alen</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; replace(qsizetype pos, qsizetype len, const char *after, qsizetype alen)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces <db:code role="parameter">len</db:code> bytes from index position <db:code role="parameter">pos</db:code> with <db:code role="parameter">alen</db:code> bytes starting at position <db:code role="parameter">after</db:code>. The bytes inserted may include '\0' bytes.</db:para>
</db:section>
<db:section xml:id="replace-2">
<db:title>QByteArray &amp;QByteArray::replace(char <db:emphasis>before</db:emphasis>, QByteArrayView <db:emphasis>after</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>replace</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>before</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>after</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; replace(char before, QByteArrayView after)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the byte <db:code role="parameter">before</db:code> with the byte array <db:code role="parameter">after</db:code>.</db:para>
</db:section>
<db:section xml:id="replace-3">
<db:title>QByteArray &amp;QByteArray::replace(const char *<db:emphasis>before</db:emphasis>, qsizetype <db:emphasis>bsize</db:emphasis>, const char *<db:emphasis>after</db:emphasis>, qsizetype <db:emphasis>asize</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>replace</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>before</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>bsize</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>after</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>asize</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; replace(const char *before, qsizetype bsize, const char *after, qsizetype asize)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the <db:code role="parameter">bsize</db:code> bytes starting at <db:code role="parameter">before</db:code> with the <db:code role="parameter">asize</db:code> bytes starting at <db:code role="parameter">after</db:code>. Since the sizes of the strings are given by <db:code role="parameter">bsize</db:code> and <db:code role="parameter">asize</db:code>, they may contain '\0' bytes and do not need to be '\0'-terminated.</db:para>
</db:section>
<db:section xml:id="replace-4">
<db:title>[since 6.0] QByteArray &amp;QByteArray::replace(QByteArrayView <db:emphasis>before</db:emphasis>, QByteArrayView <db:emphasis>after</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>replace</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>before</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>after</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; replace(QByteArrayView before, QByteArrayView after)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the byte array <db:code role="parameter">before</db:code> with the byte array <db:code role="parameter">after</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;colour behaviour flavour neighbour&quot;);
ba.replace(QByteArray(&quot;ou&quot;), QByteArray(&quot;o&quot;));
// ba == &quot;color behavior flavor neighbor&quot;
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="replace-5">
<db:title>QByteArray &amp;QByteArray::replace(char <db:emphasis>before</db:emphasis>, char <db:emphasis>after</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>replace</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>before</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>after</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; replace(char before, char after)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Replaces every occurrence of the byte <db:code role="parameter">before</db:code> with the byte <db:code role="parameter">after</db:code>.</db:para>
</db:section>
<db:section xml:id="reserve">
<db:title>void QByteArray::reserve(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>reserve</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void reserve(qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to allocate memory for at least <db:code role="parameter">size</db:code> bytes.</db:para>
<db:para>If you know in advance how large the byte array will be, you can call this function, and if you call <db:link xlink:href="qbytearray.xml#resize">resize</db:link>() often you are likely to get better performance.</db:para>
<db:para>If in doubt about how much space shall be needed, it is usually better to use an upper bound as <db:code role="parameter">size</db:code>, or a high estimate of the most likely size, if a strict upper bound would be much bigger than this. If <db:code role="parameter">size</db:code> is an underestimate, the array will grow as needed once the reserved size is exceeded, which may lead to a larger allocation than your best overestimate would have and will slow the operation that triggers it.</db:para>
<db:warning>
<db:para>reserve() reserves memory but does not change the size of the byte array. Accessing data beyond the end of the byte array is undefined behavior. If you need to access memory beyond the current end of the array, use <db:link xlink:href="qbytearray.xml#resize">resize</db:link>().</db:para>
</db:warning>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s memory usage. In general, you will rarely ever need to call this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#squeeze">squeeze</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resize">
<db:title>void QByteArray::resize(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resize</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resize(qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the size of the byte array to <db:code role="parameter">size</db:code> bytes.</db:para>
<db:para>If <db:code role="parameter">size</db:code> is greater than the current size, the byte array is extended to make it <db:code role="parameter">size</db:code> bytes with the extra bytes added to the end. The new bytes are uninitialized.</db:para>
<db:para>If <db:code role="parameter">size</db:code> is less than the current size, bytes beyond position <db:code role="parameter">size</db:code> are excluded from the byte array.</db:para>
<db:note>
<db:para>While resize() will grow the capacity if needed, it never shrinks capacity. To shed excess capacity, use <db:link xlink:href="qbytearray.xml#squeeze">squeeze</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="right">
<db:title>QByteArray QByteArray::right(qsizetype <db:emphasis>len</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>right</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray right(qsizetype len) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a byte array that contains the last <db:code role="parameter">len</db:code> bytes of this byte array.</db:para>
<db:para>If you know that <db:code role="parameter">len</db:code> cannot be out of bounds, use <db:link xlink:href="qbytearray.xml#last">last</db:link>() instead in new code, because it is faster.</db:para>
<db:para>The entire byte array is returned if <db:code role="parameter">len</db:code> is greater than <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
<db:para>Returns an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link> if <db:code role="parameter">len</db:code> is smaller than 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#endsWith">endsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rightJustified">
<db:title>QByteArray QByteArray::rightJustified(qsizetype <db:emphasis>width</db:emphasis>, char <db:emphasis>fill</db:emphasis> = ' ', bool <db:emphasis>truncate</db:emphasis> = false) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>rightJustified</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>width</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>fill</db:parameter>
<db:initializer>' '</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>truncate</db:parameter>
<db:initializer>false</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray rightJustified(qsizetype width, char fill, bool truncate) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a byte array of size <db:code role="parameter">width</db:code> that contains the <db:code role="parameter">fill</db:code> byte followed by this byte array.</db:para>
<db:para>If <db:code role="parameter">truncate</db:code> is false and the size of the byte array is more than <db:code role="parameter">width</db:code>, then the returned byte array is a copy of this byte array.</db:para>
<db:para>If <db:code role="parameter">truncate</db:code> is true and the size of the byte array is more than <db:code role="parameter">width</db:code>, then the resulting byte array is truncated at position <db:code role="parameter">width</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;apple&quot;);
QByteArray y = x.rightJustified(8, '.');    // y == &quot;...apple&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#leftJustified">leftJustified</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum">
<db:title>QByteArray &amp;QByteArray::setNum(int <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>setNum</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; setNum(int n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the byte array to the printed value of <db:code role="parameter">n</db:code> in base <db:code role="parameter">base</db:code> (ten by default) and returns a reference to the byte array. Bases 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on. For bases other than ten, n is treated as an unsigned integer.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba;
int n = 63;
ba.setNum(n);           // ba == &quot;63&quot;
ba.setNum(n, 16);       // ba == &quot;3f&quot;
</db:programlisting>
<db:note>
<db:para>The format of the number is not localized; the default C locale is used regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toInt">toInt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-1">
<db:title>QByteArray &amp;QByteArray::setNum(short <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>setNum</db:methodname>
<db:methodparam>
<db:type>short</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; setNum(short n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toShort">toShort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-2">
<db:title>QByteArray &amp;QByteArray::setNum(ushort <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>setNum</db:methodname>
<db:methodparam>
<db:type>ushort</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; setNum(ushort n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toUShort">toUShort</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-3">
<db:title>QByteArray &amp;QByteArray::setNum(uint <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>setNum</db:methodname>
<db:methodparam>
<db:type>uint</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; setNum(uint n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toUInt">toUInt</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-4">
<db:title>QByteArray &amp;QByteArray::setNum(long <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>setNum</db:methodname>
<db:methodparam>
<db:type>long</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; setNum(long n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toLong">toLong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-5">
<db:title>QByteArray &amp;QByteArray::setNum(ulong <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>setNum</db:methodname>
<db:methodparam>
<db:type>ulong</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; setNum(ulong n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toULong">toULong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-6">
<db:title>QByteArray &amp;QByteArray::setNum(qlonglong <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>setNum</db:methodname>
<db:methodparam>
<db:type>qlonglong</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; setNum(qlonglong n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toLongLong">toLongLong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-7">
<db:title>QByteArray &amp;QByteArray::setNum(qulonglong <db:emphasis>n</db:emphasis>, int <db:emphasis>base</db:emphasis> = 10)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>setNum</db:methodname>
<db:methodparam>
<db:type>qulonglong</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; setNum(qulonglong n, int base)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toULongLong">toULongLong</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-8">
<db:title>QByteArray &amp;QByteArray::setNum(float <db:emphasis>n</db:emphasis>, char <db:emphasis>f</db:emphasis> = 'g', int <db:emphasis>prec</db:emphasis> = 6)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>setNum</db:methodname>
<db:methodparam>
<db:type>float</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>f</db:parameter>
<db:initializer>'g'</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>prec</db:parameter>
<db:initializer>6</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">8</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; setNum(float n, char f, int prec)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the byte array to the printed value of <db:code role="parameter">n</db:code>, formatted in format <db:code role="parameter">f</db:code> with precision <db:code role="parameter">prec</db:code>, and returns a reference to the byte array.</db:para>
<db:note>
<db:para>The format of the number is not localized; the default C locale is used regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toFloat">toFloat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNum-9">
<db:title>QByteArray &amp;QByteArray::setNum(double <db:emphasis>n</db:emphasis>, char <db:emphasis>f</db:emphasis> = 'g', int <db:emphasis>prec</db:emphasis> = 6)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>setNum</db:methodname>
<db:methodparam>
<db:type>double</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>f</db:parameter>
<db:initializer>'g'</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>prec</db:parameter>
<db:initializer>6</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">9</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; setNum(double n, char f, int prec)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the byte array to the printed value of <db:code role="parameter">n</db:code>, formatted in format <db:code role="parameter">f</db:code> with precision <db:code role="parameter">prec</db:code>, and returns a reference to the byte array.</db:para>
<db:para>The format <db:code role="parameter">f</db:code> can be any of the following:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Format</db:para>
</db:th>
<db:th>
<db:para>Meaning</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:code>e</db:code></db:para>
</db:td>
<db:td>
<db:para>format as [-]9.9e[+|-]999</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>E</db:code></db:para>
</db:td>
<db:td>
<db:para>format as [-]9.9E[+|-]999</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>f</db:code></db:para>
</db:td>
<db:td>
<db:para>format as [-]9.9</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>g</db:code></db:para>
</db:td>
<db:td>
<db:para>use <db:code>e</db:code> or <db:code>f</db:code> format, whichever is the most concise</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>G</db:code></db:para>
</db:td>
<db:td>
<db:para>use <db:code>E</db:code> or <db:code>f</db:code> format, whichever is the most concise</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>With 'e', 'E', and 'f', <db:code role="parameter">prec</db:code> is the number of digits after the decimal point. With 'g' and 'G', <db:code role="parameter">prec</db:code> is the maximum number of significant digits (trailing zeroes are omitted).</db:para>
<db:note>
<db:para>The format of the number is not localized; the default C locale is used regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toDouble">toDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setRawData">
<db:title>QByteArray &amp;QByteArray::setRawData(const char *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>setRawData</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; setRawData(const char *data, qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Resets the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> to use the first <db:code role="parameter">size</db:code> bytes of the <db:code role="parameter">data</db:code> array. The bytes are <db:emphasis>not</db:emphasis> copied. The <db:link xlink:href="qbytearray.xml">QByteArray</db:link> will contain the <db:code role="parameter">data</db:code> pointer. The caller guarantees that <db:code role="parameter">data</db:code> will not be deleted or modified as long as this <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and any copies of it exist that have not been modified.</db:para>
<db:para>This function can be used instead of <db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>() to re-use existing <db:link xlink:href="qbytearray.xml">QByteArray</db:link> objects to save memory re-allocations.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#constData">constData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="shrink_to_fit">
<db:title>[since 5.10] void QByteArray::shrink_to_fit()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>shrink_to_fit</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void shrink_to_fit()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is provided for STL compatibility. It is equivalent to <db:link xlink:href="qbytearray.xml#squeeze">squeeze</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
</db:section>
<db:section xml:id="simplified">
<db:title>QByteArray QByteArray::simplified() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>simplified</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray simplified() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a copy of this byte array that has spacing characters removed from the start and end, and in which each sequence of internal spacing characters is replaced with a single space.</db:para>
<db:para>The spacing characters are those for which the standard C++ <db:code>isspace()</db:code> function returns <db:code>true</db:code> in the C locale; these are the ASCII characters tabulation '\t', line feed '\n', carriage return '\r', vertical tabulation '\v', form feed '\f', and space ' '.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;  lots\t of\nwhitespace\r\n &quot;);
ba = ba.simplified();
// ba == &quot;lots of whitespace&quot;;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#trimmed">trimmed</db:link>()</db:member>
<db:member><db:link xlink:href="qchar.xml#SpecialCharacter-enum">QChar::SpecialCharacter</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#spacing-characters">Spacing Characters</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>qsizetype QByteArray::size() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype size() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of bytes in this byte array.</db:para>
<db:para>The last byte in the byte array is at position size() - 1. In addition, <db:link xlink:href="qbytearray.xml">QByteArray</db:link> ensures that the byte at position size() is always '\0', so that you can use the return value of <db:link xlink:href="qbytearray.xml#data">data</db:link>() and <db:link xlink:href="qbytearray.xml#constData">constData</db:link>() as arguments to functions that expect '\0'-terminated strings. If the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> object was created from a <db:link xlink:href="qbytearray.xml#fromRawData">raw data</db:link> that didn't include the trailing '\0'-termination byte, then <db:link xlink:href="qbytearray.xml">QByteArray</db:link> doesn't add it automaticall unless a <db:link xlink:href="implicit-sharing.xml#deep-copy">deep copy</db:link> is created.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Hello&quot;);
qsizetype n = ba.size();    // n == 5
ba.data()[0];               // returns 'H'
ba.data()[4];               // returns 'o'
ba.data()[5];               // returns '\0'
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sliced">
<db:title>[since 6.0] QByteArray QByteArray::sliced(qsizetype <db:emphasis>pos</db:emphasis>, qsizetype <db:emphasis>n</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>sliced</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray sliced(qsizetype pos, qsizetype n) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a byte array containing the <db:code role="parameter">n</db:code> bytes of this object starting at position <db:code role="parameter">pos</db:code>.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">pos</db:code> &lt; 0, <db:code role="parameter">n</db:code> &lt; 0, or <db:code role="parameter">pos</db:code> + <db:code role="parameter">n</db:code> &gt; <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;Five pineapples&quot;);
QByteArray y = x.sliced(5, 4);     // y == &quot;pine&quot;
QByteArray z = x.sliced(5);        // z == &quot;pineapples&quot;
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sliced-1">
<db:title>[since 6.0] QByteArray QByteArray::sliced(qsizetype <db:emphasis>pos</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>sliced</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray sliced(qsizetype pos) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a byte array containing the bytes starting at position <db:code role="parameter">pos</db:code> in this object, and extending to the end of this object.</db:para>
<db:note>
<db:para>The behavior is undefined when <db:code role="parameter">pos</db:code> &lt; 0 or <db:code role="parameter">pos</db:code> &gt; <db:link xlink:href="qbytearray.xml#size">size</db:link>().</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#truncate">truncate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="split">
<db:title>QList&lt;QByteArray&gt; QByteArray::split(char <db:emphasis>sep</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QByteArray&gt;</db:type>
<db:methodname>split</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>sep</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QByteArray&gt; split(char sep) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Splits the byte array into subarrays wherever <db:code role="parameter">sep</db:code> occurs, and returns the list of those arrays. If <db:code role="parameter">sep</db:code> does not match anywhere in the byte array, split() returns a single-element list containing this byte array.</db:para>
</db:section>
<db:section xml:id="squeeze">
<db:title>void QByteArray::squeeze()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>squeeze</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void squeeze()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Releases any memory not required to store the array's data.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s memory usage. In general, you will rarely ever need to call this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#capacity">capacity</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startsWith">
<db:title>[since 6.0] bool QByteArray::startsWith(QByteArrayView <db:emphasis>bv</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>startsWith</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>bv</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool startsWith(QByteArrayView bv) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this byte array starts with the sequence of bytes viewed by <db:code role="parameter">bv</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray url(&quot;ftp://ftp.qt-project.org/&quot;);
if (url.startsWith(&quot;ftp:&quot;))
    ...
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#endsWith">endsWith</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#first">first</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startsWith-1">
<db:title>bool QByteArray::startsWith(char <db:emphasis>ch</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>startsWith</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool startsWith(char ch) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if this byte array starts with byte <db:code role="parameter">ch</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="swap">
<db:title>void QByteArray::swap(QByteArray &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QByteArray &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QByteArray &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps byte array <db:code role="parameter">other</db:code> with this byte array. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="toBase64">
<db:title>[since 5.2] QByteArray QByteArray::toBase64(QByteArray::Base64Options <db:emphasis>options</db:emphasis> = Base64Encoding) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>toBase64</db:methodname>
<db:methodparam>
<db:type>QByteArray::Base64Options</db:type>
<db:parameter>options</db:parameter>
<db:initializer>Base64Encoding</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray toBase64(QByteArray::Base64Options options) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a copy of the byte array, encoded using the options <db:code role="parameter">options</db:code>.</db:para>
<db:programlisting language="cpp">QByteArray text(&quot;Qt is great!&quot;);
text.toBase64();        // returns &quot;UXQgaXMgZ3JlYXQh&quot;

QByteArray text(&quot;&amp;lt;p&amp;gt;Hello?&amp;lt;/p&amp;gt;&quot;);
text.toBase64(QByteArray::Base64Encoding | QByteArray::OmitTrailingEquals);      // returns &quot;PHA+SGVsbG8/PC9wPg&quot;
text.toBase64(QByteArray::Base64Encoding);                                       // returns &quot;PHA+SGVsbG8/PC9wPg==&quot;
text.toBase64(QByteArray::Base64UrlEncoding);                                    // returns &quot;PHA-SGVsbG8_PC9wPg==&quot;
text.toBase64(QByteArray::Base64UrlEncoding | QByteArray::OmitTrailingEquals);   // returns &quot;PHA-SGVsbG8_PC9wPg&quot;
</db:programlisting>
<db:para>The algorithm used to encode Base64-encoded data is defined in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromBase64">fromBase64</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toCFData">
<db:title>[since 5.3] CFDataRef QByteArray::toCFData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>CFDataRef</db:type>
<db:methodname>toCFData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">CFDataRef toCFData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a CFData from a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>The caller owns the CFData object and is responsible for releasing it.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toRawCFData">toRawCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromCFData">fromCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawCFData">fromRawCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDouble">
<db:title>double QByteArray::toDouble(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>double</db:type>
<db:methodname>toDouble</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">double toDouble(bool *ok) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte array converted to a <db:code>double</db:code> value.</db:para>
<db:para>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="parameter">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="parameter">ok</db:code> to <db:code>true</db:code>.</db:para>
<db:programlisting language="cpp">QByteArray string(&quot;1234.56&quot;);
bool ok;
double a = string.toDouble(&amp;amp;ok);   // a == 1234.56, ok == true

string = &quot;1234.56 Volt&quot;;
a = str.toDouble(&amp;amp;ok);             // a == 0, ok == false
</db:programlisting>
<db:warning>
<db:para>The <db:link xlink:href="qbytearray.xml">QByteArray</db:link> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</db:para>
</db:warning>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:para>This function ignores leading and trailing whitespace.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toFloat">
<db:title>float QByteArray::toFloat(bool *<db:emphasis>ok</db:emphasis> = nullptr) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>float</db:type>
<db:methodname>toFloat</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">float toFloat(bool *ok) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte array converted to a <db:code>float</db:code> value.</db:para>
<db:para>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="parameter">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="parameter">ok</db:code> to <db:code>true</db:code>.</db:para>
<db:programlisting language="cpp">QByteArray string(&quot;1234.56&quot;);
bool ok;
float a = string.toFloat(&amp;amp;ok);    // a == 1234.56, ok == true

string = &quot;1234.56 Volt&quot;;
a = str.toFloat(&amp;amp;ok);              // a == 0, ok == false
</db:programlisting>
<db:warning>
<db:para>The <db:link xlink:href="qbytearray.xml">QByteArray</db:link> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</db:para>
</db:warning>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:para>This function ignores leading and trailing whitespace.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toHex">
<db:title>[since 5.9] QByteArray QByteArray::toHex(char <db:emphasis>separator</db:emphasis> = '\0') const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>toHex</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>separator</db:parameter>
<db:initializer>'\0'</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray toHex(char separator) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a hex encoded copy of the byte array.</db:para>
<db:para>The hex encoding uses the numbers 0-9 and the letters a-f.</db:para>
<db:para>If <db:code role="parameter">separator</db:code> is not '\0', the separator character is inserted between the hex bytes.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray macAddress = QByteArray::fromHex(&quot;123456abcdef&quot;);
macAddress.toHex(':'); // returns &quot;12:34:56:ab:cd:ef&quot;
macAddress.toHex(0);   // returns &quot;123456abcdef&quot;
</db:programlisting>
<db:para>This function was introduced in Qt 5.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromHex">fromHex</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toInt">
<db:title>int QByteArray::toInt(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>toInt</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int toInt(bool *ok, int base) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte array converted to an <db:code>int</db:code> using base <db:code role="parameter">base</db:code>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal (base 8); otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="parameter">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="parameter">ok</db:code> to <db:code>true</db:code>.</db:para>
<db:programlisting language="cpp">QByteArray str(&quot;FF&quot;);
bool ok;
int hex = str.toInt(&amp;amp;ok, 16);     // hex == 255, ok == true
int dec = str.toInt(&amp;amp;ok, 10);     // dec == 0, ok == false
</db:programlisting>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLong">
<db:title>long QByteArray::toLong(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>long</db:type>
<db:methodname>toLong</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">long toLong(bool *ok, int base) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte array converted to a <db:code>long</db:code> int using base <db:code role="parameter">base</db:code>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal (base 8); otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="parameter">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="parameter">ok</db:code> to <db:code>true</db:code>.</db:para>
<db:programlisting language="cpp">QByteArray str(&quot;FF&quot;);
bool ok;
long hex = str.toLong(&amp;amp;ok, 16);   // hex == 255, ok == true
long dec = str.toLong(&amp;amp;ok, 10);   // dec == 0, ok == false
</db:programlisting>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLongLong">
<db:title>qlonglong QByteArray::toLongLong(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qlonglong</db:type>
<db:methodname>toLongLong</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qlonglong toLongLong(bool *ok, int base) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte array converted to a <db:code>long long</db:code> using base <db:code role="parameter">base</db:code>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal (base 8); otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="parameter">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="parameter">ok</db:code> to <db:code>true</db:code>.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toLower">
<db:title>QByteArray QByteArray::toLower() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>toLower</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray toLower() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a copy of the byte array in which each ASCII uppercase letter converted to lowercase.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;Qt by THE QT COMPANY&quot;);
QByteArray y = x.toLower();
// y == &quot;qt by the qt company&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#isLower">isLower</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toUpper">toUpper</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#character-case">Character Case</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toNSData">
<db:title>[since 5.3] NSData *QByteArray::toNSData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>NSData *</db:type>
<db:methodname>toNSData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">NSData * toNSData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a NSData from a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>The NSData object is autoreleased.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromNSData">fromNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawNSData">fromRawNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toRawNSData">toRawNSData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPercentEncoding">
<db:title>QByteArray QByteArray::toPercentEncoding(const QByteArray &amp;<db:emphasis>exclude</db:emphasis> = QByteArray(), const QByteArray &amp;<db:emphasis>include</db:emphasis> = QByteArray(), char <db:emphasis>percent</db:emphasis> = '%') const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>toPercentEncoding</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>exclude</db:parameter>
<db:initializer>QByteArray()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>include</db:parameter>
<db:initializer>QByteArray()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>percent</db:parameter>
<db:initializer>'%'</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray toPercentEncoding(const QByteArray &amp;exclude, const QByteArray &amp;include, char percent) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a URI/URL-style percent-encoded copy of this byte array. The <db:code role="parameter">percent</db:code> parameter allows you to override the default '%' character for another.</db:para>
<db:para>By default, this function will encode all bytes that are not one of the following:</db:para>
<db:para>ALPHA (&quot;a&quot; to &quot;z&quot; and &quot;A&quot; to &quot;Z&quot;) / DIGIT (0 to 9) / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;</db:para>
<db:para>To prevent bytes from being encoded pass them to <db:code role="parameter">exclude</db:code>. To force bytes to be encoded pass them to <db:code role="parameter">include</db:code>. The <db:code role="parameter">percent</db:code> character is always encoded.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray text = &quot;{a fishy string?}&quot;;
QByteArray ba = text.toPercentEncoding(&quot;{}&quot;, &quot;s&quot;);
qDebug(ba.constData());
// prints &quot;{a fi%73hy %73tring%3F}&quot;
</db:programlisting>
<db:para>The hex encoding uses the numbers 0-9 and the uppercase letters A-F.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromPercentEncoding">fromPercentEncoding</db:link>()</db:member>
<db:member><db:link xlink:href="qurl.xml#toPercentEncoding">QUrl::toPercentEncoding</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRawCFData">
<db:title>[since 5.3] CFDataRef QByteArray::toRawCFData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>CFDataRef</db:type>
<db:methodname>toRawCFData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">CFDataRef toRawCFData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs a CFData that uses the bytes of the <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>The <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s bytes are not copied.</db:para>
<db:para>The caller guarantees that the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> will not be deleted or modified as long as this CFData object exists.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#toCFData">toCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawCFData">fromRawCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromCFData">fromCFData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRawNSData">
<db:title>[since 5.3] NSData *QByteArray::toRawNSData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>NSData *</db:type>
<db:methodname>toRawNSData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">NSData * toRawNSData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Constructs a NSData that uses the bytes of the <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>The <db:link xlink:href="qbytearray.xml">QByteArray</db:link>'s bytes are not copied.</db:para>
<db:para>The caller guarantees that the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> will not be deleted or modified as long as this NSData object exists.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromRawNSData">fromRawNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromNSData">fromNSData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toNSData">toNSData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toShort">
<db:title>short QByteArray::toShort(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>short</db:type>
<db:methodname>toShort</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">short toShort(bool *ok, int base) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte array converted to a <db:code>short</db:code> using base <db:code role="parameter">base</db:code>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; otherwise, if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="parameter">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="parameter">ok</db:code> to <db:code>true</db:code>.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toStdString">
<db:title>[since 5.4] std::string QByteArray::toStdString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>std::string</db:type>
<db:methodname>toStdString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">std::string toStdString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a std::string object with the data contained in this <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:para>This operator is mostly useful to pass a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> to a function that accepts a std::string object.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#fromStdString">fromStdString</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#toStdString">QString::toStdString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUInt">
<db:title>uint QByteArray::toUInt(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>uint</db:type>
<db:methodname>toUInt</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">uint toUInt(bool *ok, int base) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte array converted to an <db:code>unsigned int</db:code> using base <db:code role="parameter">base</db:code>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal (base 8); otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="parameter">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="parameter">ok</db:code> to <db:code>true</db:code>.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toULong">
<db:title>ulong QByteArray::toULong(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>ulong</db:type>
<db:methodname>toULong</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">ulong toULong(bool *ok, int base) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte array converted to an <db:code>unsigned long int</db:code> using base <db:code role="parameter">base</db:code>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal (base 8); otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="parameter">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="parameter">ok</db:code> to <db:code>true</db:code>.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toULongLong">
<db:title>qulonglong QByteArray::toULongLong(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qulonglong</db:type>
<db:methodname>toULongLong</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qulonglong toULongLong(bool *ok, int base) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte array converted to an <db:code>unsigned long long</db:code> using base <db:code role="parameter">base</db:code>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal (base 8); otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="parameter">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="parameter">ok</db:code> to <db:code>true</db:code>.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUShort">
<db:title>ushort QByteArray::toUShort(bool *<db:emphasis>ok</db:emphasis> = nullptr, int <db:emphasis>base</db:emphasis> = 10) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>ushort</db:type>
<db:methodname>toUShort</db:methodname>
<db:methodparam>
<db:type>bool *</db:type>
<db:parameter>ok</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>base</db:parameter>
<db:initializer>10</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">ushort toUShort(bool *ok, int base) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte array converted to an <db:code>unsigned short</db:code> using base <db:code role="parameter">base</db:code>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</db:para>
<db:para>If <db:code role="parameter">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; otherwise, if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
<db:para>Returns 0 if the conversion fails.</db:para>
<db:para>If <db:code role="parameter">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="parameter">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="parameter">ok</db:code> to <db:code>true</db:code>.</db:para>
<db:note>
<db:para>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <db:link xlink:href="qlocale.xml">QLocale</db:link> to perform locale-aware conversions between numbers and strings.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#number">number</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUpper">
<db:title>QByteArray QByteArray::toUpper() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>toUpper</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray toUpper() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a copy of the byte array in which each ASCII lowercase letter converted to uppercase.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;Qt by THE QT COMPANY&quot;);
QByteArray y = x.toUpper();
// y == &quot;QT BY THE QT COMPANY&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#isUpper">isUpper</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#toLower">toLower</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#character-case">Character Case</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="trimmed">
<db:title>QByteArray QByteArray::trimmed() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>trimmed</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray trimmed() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a copy of this byte array with spacing characters removed from the start and end.</db:para>
<db:para>The spacing characters are those for which the standard C++ <db:code>isspace()</db:code> function returns <db:code>true</db:code> in the C locale; these are the ASCII characters tabulation '\t', line feed '\n', carriage return '\r', vertical tabulation '\v', form feed '\f', and space ' '.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;  lots\t of\nwhitespace\r\n &quot;);
ba = ba.trimmed();
// ba == &quot;lots\t of\nwhitespace&quot;;
</db:programlisting>
<db:para>Unlike <db:link xlink:href="qbytearray.xml#simplified">simplified</db:link>(), trimmed() leaves internal spacing unchanged.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#simplified">simplified</db:link>()</db:member>
<db:member><db:link xlink:href="qchar.xml#SpecialCharacter-enum">QChar::SpecialCharacter</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#spacing-characters">Spacing Characters</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="truncate">
<db:title>void QByteArray::truncate(qsizetype <db:emphasis>pos</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>truncate</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void truncate(qsizetype pos)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Truncates the byte array at index position <db:code role="parameter">pos</db:code>.</db:para>
<db:para>If <db:code role="parameter">pos</db:code> is beyond the end of the array, nothing happens.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Stockholm&quot;);
ba.truncate(5);             // ba == &quot;Stock&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#chop">chop</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#resize">resize</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#first">first</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QByteArray::operator!=(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QString &amp;str) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this byte array is not equal to the UTF-8 encoding of <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison is case sensitive.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>(), <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>(), or <db:link xlink:href="qstring.xml#fromLocal8Bit">QString::fromLocal8Bit</db:link>() explicitly if you want to convert the byte array to a <db:link xlink:href="qstring.xml">QString</db:link> before doing the comparison.</db:para>
</db:section>
<db:section xml:id="operator-2b-eq">
<db:title>QByteArray &amp;QByteArray::operator+=(const QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>ba</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; operator+=(const QByteArray &amp;ba)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends the byte array <db:code role="parameter">ba</db:code> onto the end of this byte array and returns a reference to this byte array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray x(&quot;free&quot;);
QByteArray y(&quot;dom&quot;);
x += y;
// x == &quot;freedom&quot;
</db:programlisting>
<db:para>Note: <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is an <db:link xlink:href="implicit-sharing.xml">implicitly shared</db:link> class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in <db:code role="parameter">ba</db:code>. In this case, no copying of data is done, taking <db:link xlink:href="containers.xml#constant-time">constant time</db:link>. If a shared instance is modified, it will be copied (copy-on-write), taking <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:para>If the byte array being appended to is not empty, a deep copy of the data is performed, taking <db:link xlink:href="containers.xml#linear-time">linear time</db:link>.</db:para>
<db:para>This operation typically does not suffer from allocation overhead, because <db:link xlink:href="qbytearray.xml">QByteArray</db:link> preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#prepend">prepend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq-1">
<db:title>QByteArray &amp;QByteArray::operator+=(char <db:emphasis>ch</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ch</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; operator+=(char ch)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the byte <db:code role="parameter">ch</db:code> onto the end of this byte array and returns a reference to this byte array.</db:para>
</db:section>
<db:section xml:id="operator-2b-eq-2">
<db:title>QByteArray &amp;QByteArray::operator+=(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; operator+=(const char *str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Appends the '\0'-terminated string <db:code role="parameter">str</db:code> onto the end of this byte array and returns a reference to this byte array.</db:para>
</db:section>
<db:section xml:id="operator-lt">
<db:title>bool QByteArray::operator&lt;(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator&lt;</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;(const QString &amp;str) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this byte array is lexically less than the UTF-8 encoding of <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison is case sensitive.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>(), <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>(), or <db:link xlink:href="qstring.xml#fromLocal8Bit">QString::fromLocal8Bit</db:link>() explicitly if you want to convert the byte array to a <db:link xlink:href="qstring.xml">QString</db:link> before doing the comparison.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq">
<db:title>bool QByteArray::operator&lt;=(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator&lt;=</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;=(const QString &amp;str) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this byte array is lexically less than or equal to the UTF-8 encoding of <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison is case sensitive.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>(), <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>(), or <db:link xlink:href="qstring.xml#fromLocal8Bit">QString::fromLocal8Bit</db:link>() explicitly if you want to convert the byte array to a <db:link xlink:href="qstring.xml">QString</db:link> before doing the comparison.</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QByteArray &amp;QByteArray::operator=(const QByteArray &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; operator=(const QByteArray &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">other</db:code> to this byte array and returns a reference to this byte array.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QByteArray &amp;QByteArray::operator=(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; operator=(const char *str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Assigns <db:code role="parameter">str</db:code> to this byte array.</db:para>
</db:section>
<db:section xml:id="operator-eq-2">
<db:title>[since 5.2] QByteArray &amp;QByteArray::operator=(QByteArray &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QByteArray &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray &amp; operator=(QByteArray &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qbytearray.xml">QByteArray</db:link> instance.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QByteArray::operator==(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QString &amp;str) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this byte array is equal to the UTF-8 encoding of <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison is case sensitive.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>(), <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>(), or <db:link xlink:href="qstring.xml#fromLocal8Bit">QString::fromLocal8Bit</db:link>() explicitly if you want to convert the byte array to a <db:link xlink:href="qstring.xml">QString</db:link> before doing the comparison.</db:para>
</db:section>
<db:section xml:id="operator-gt">
<db:title>bool QByteArray::operator&gt;(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator&gt;</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;(const QString &amp;str) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this byte array is lexically greater than the UTF-8 encoding of <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison is case sensitive.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>(), <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>(), or <db:link xlink:href="qstring.xml#fromLocal8Bit">QString::fromLocal8Bit</db:link>() explicitly if you want to convert the byte array to a <db:link xlink:href="qstring.xml">QString</db:link> before doing the comparison.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq">
<db:title>bool QByteArray::operator&gt;=(const QString &amp;<db:emphasis>str</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator&gt;=</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;=(const QString &amp;str) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this byte array is greater than or equal to the UTF-8 encoding of <db:code role="parameter">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison is case sensitive.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>(), <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>(), or <db:link xlink:href="qstring.xml#fromLocal8Bit">QString::fromLocal8Bit</db:link>() explicitly if you want to convert the byte array to a <db:link xlink:href="qstring.xml">QString</db:link> before doing the comparison.</db:para>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>char &amp;QByteArray::operator[](qsizetype <db:emphasis>i</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char &amp;</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">char &amp; operator[](qsizetype i)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte at index position <db:code role="parameter">i</db:code> as a modifiable reference.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the byte array (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qbytearray.xml#size">size</db:link>()).</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QByteArray ba(&quot;Hello, world&quot;);
cout &amp;lt;&amp;lt; ba[0]; // prints H
ba[7] = 'W';
// ba == &quot;Hello, World&quot;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#at">at</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>char QByteArray::operator[](qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>char</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">char operator[](qsizetype i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Same as at(<db:code role="parameter">i</db:code>).</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qChecksum">
<db:title>[since 5.9] quint16 qChecksum(QByteArrayView <db:emphasis>data</db:emphasis>, Qt::ChecksumType <db:emphasis>standard</db:emphasis> = Qt::ChecksumIso3309)</db:title>
<db:methodsynopsis>
<db:type>quint16</db:type>
<db:methodname>qChecksum</db:methodname>
<db:methodparam>
<db:type>QByteArrayView</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ChecksumType</db:type>
<db:parameter>standard</db:parameter>
<db:initializer>Qt::ChecksumIso3309</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint16 qChecksum(QByteArrayView data, Qt::ChecksumType standard)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the CRC-16 checksum of <db:code role="parameter">data</db:code>.</db:para>
<db:para>The checksum is independent of the byte order (endianness) and will be calculated accorded to the algorithm published in <db:code role="parameter">standard</db:code>. By default the algorithm published in ISO 3309 (<db:link xlink:href="qt.xml#ChecksumType-enum">Qt::ChecksumIso3309</db:link>) is used.</db:para>
<db:note>
<db:para>This function is a 16-bit cache conserving (16 entry table) implementation of the CRC-16-CCITT algorithm.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.9.</db:para>
</db:section>
<db:section xml:id="qCompress">
<db:title>QByteArray qCompress(const QByteArray &amp;<db:emphasis>data</db:emphasis>, int <db:emphasis>compressionLevel</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:type>QByteArray</db:type>
<db:methodname>qCompress</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>compressionLevel</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray qCompress(const QByteArray &amp;data, int compressionLevel)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compresses the <db:code role="parameter">data</db:code> byte array and returns the compressed data in a new byte array.</db:para>
<db:para>The <db:code role="parameter">compressionLevel</db:code> parameter specifies how much compression should be used. Valid values are between 0 and 9, with 9 corresponding to the greatest compression (i.e. smaller compressed data) at the cost of using a slower algorithm. Smaller values (8, 7, ..., 1) provide successively less compression at slightly faster speeds. The value 0 corresponds to no compression at all. The default value is -1, which specifies zlib's default compression.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qUncompress-1">qUncompress</db:link>(const QByteArray &amp;data)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qCompress-1">
<db:title>QByteArray qCompress(const uchar *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>nbytes</db:emphasis>, int <db:emphasis>compressionLevel</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:type>QByteArray</db:type>
<db:methodname>qCompress</db:methodname>
<db:methodparam>
<db:type>const uchar *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>nbytes</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>compressionLevel</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray qCompress(const uchar *data, qsizetype nbytes, int compressionLevel)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Compresses the first <db:code role="parameter">nbytes</db:code> of <db:code role="parameter">data</db:code> at compression level <db:code role="parameter">compressionLevel</db:code> and returns the compressed data in a new byte array.</db:para>
</db:section>
<db:section xml:id="qUncompress-1">
<db:title>QByteArray qUncompress(const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray</db:type>
<db:methodname>qUncompress</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray qUncompress(const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Uncompresses the <db:code role="parameter">data</db:code> byte array and returns a new byte array with the uncompressed data.</db:para>
<db:para>Returns an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link> if the input data was corrupt.</db:para>
<db:para>This function will uncompress data compressed with <db:link xlink:href="qbytearray.xml#qCompress">qCompress</db:link>() from this and any earlier Qt version, back to Qt 3.1 when this feature was added.</db:para>
<db:para><db:emphasis role="bold">Note:</db:emphasis> If you want to use this function to uncompress external data that was compressed using zlib, you first need to prepend a four byte header to the byte array containing the data. The header must contain the expected length (in bytes) of the uncompressed data, expressed as an unsigned, big-endian, 32-bit integer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qCompress">qCompress</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qUncompress-2">
<db:title>QByteArray qUncompress(const uchar *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>nbytes</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QByteArray</db:type>
<db:methodname>qUncompress</db:methodname>
<db:methodparam>
<db:type>const uchar *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>nbytes</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray qUncompress(const uchar *data, qsizetype nbytes)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Uncompresses the first <db:code role="parameter">nbytes</db:code> of <db:code role="parameter">data</db:code> and returns a new byte array with the uncompressed data.</db:para>
</db:section>
<db:section xml:id="qsnprintf">
<db:title>int qsnprintf(char *<db:emphasis>str</db:emphasis>, size_t <db:emphasis>n</db:emphasis>, const char *<db:emphasis>fmt</db:emphasis>, <db:emphasis>...</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qsnprintf</db:methodname>
<db:methodparam>
<db:type>char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>fmt</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>...</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qsnprintf(char *str, size_t n, const char *fmt, ...)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:anchor xml:id="bytearray-qsnprintf"/>
<db:para>A portable snprintf() function, calls qvsnprintf.</db:para>
<db:para><db:code role="parameter">fmt</db:code> is the <db:code>printf()</db:code> format string. The result is put into <db:code role="parameter">str</db:code>, which is a buffer of at least <db:code role="parameter">n</db:code> bytes.</db:para>
<db:warning>
<db:para>Call this function only when you know what you are doing since it shows different behavior on certain platforms. Use <db:link xlink:href="qstring.xml#asprintf">QString::asprintf</db:link>() to format a string instead.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qvsnprintf">qvsnprintf</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#asprintf">QString::asprintf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrcmp">
<db:title>int qstrcmp(const char *<db:emphasis>str1</db:emphasis>, const char *<db:emphasis>str2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qstrcmp</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qstrcmp(const char *str1, const char *str2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>A safe <db:code>strcmp()</db:code> function.</db:para>
<db:para>Compares <db:code role="parameter">str1</db:code> and <db:code role="parameter">str2</db:code>. Returns a negative value if <db:code role="parameter">str1</db:code> is less than <db:code role="parameter">str2</db:code>, 0 if <db:code role="parameter">str1</db:code> is equal to <db:code role="parameter">str2</db:code> or a positive value if <db:code role="parameter">str1</db:code> is greater than <db:code role="parameter">str2</db:code>.</db:para>
<db:para>If both strings are <db:code>nullptr</db:code>, they are deemed equal; otherwise, if either is <db:code>nullptr</db:code>, it is treated as less than the other (even if the other is an empty string).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrncmp">qstrncmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstricmp">qstricmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstrnicmp">qstrnicmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#character-case">Character Case</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrcpy">
<db:title>char *qstrcpy(char *<db:emphasis>dst</db:emphasis>, const char *<db:emphasis>src</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>qstrcpy</db:methodname>
<db:methodparam>
<db:type>char *</db:type>
<db:parameter>dst</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">char * qstrcpy(char *dst, const char *src)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Copies all the characters up to and including the '\0' from <db:code role="parameter">src</db:code> into <db:code role="parameter">dst</db:code> and returns a pointer to <db:code role="parameter">dst</db:code>. If <db:code role="parameter">src</db:code> is <db:code>nullptr</db:code>, it immediately returns <db:code>nullptr</db:code>.</db:para>
<db:para>This function assumes that <db:code role="parameter">dst</db:code> is large enough to hold the contents of <db:code role="parameter">src</db:code>.</db:para>
<db:note>
<db:para>If <db:code role="parameter">dst</db:code> and <db:code role="parameter">src</db:code> overlap, the behavior is undefined.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrncpy">qstrncpy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrdup">
<db:title>char *qstrdup(const char *<db:emphasis>src</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>qstrdup</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">char * qstrdup(const char *src)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a duplicate string.</db:para>
<db:para>Allocates space for a copy of <db:code role="parameter">src</db:code>, copies it, and returns a pointer to the copy. If <db:code role="parameter">src</db:code> is <db:code>nullptr</db:code>, it immediately returns <db:code>nullptr</db:code>.</db:para>
<db:para>Ownership is passed to the caller, so the returned string must be deleted using <db:code>delete[]</db:code>.</db:para>
</db:section>
<db:section xml:id="qstricmp">
<db:title>int qstricmp(const char *<db:emphasis>str1</db:emphasis>, const char *<db:emphasis>str2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qstricmp</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qstricmp(const char *str1, const char *str2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>A safe <db:code>stricmp()</db:code> function.</db:para>
<db:para>Compares <db:code role="parameter">str1</db:code> and <db:code role="parameter">str2</db:code>, ignoring differences in the case of any ASCII characters.</db:para>
<db:para>Returns a negative value if <db:code role="parameter">str1</db:code> is less than <db:code role="parameter">str2</db:code>, 0 if <db:code role="parameter">str1</db:code> is equal to <db:code role="parameter">str2</db:code> or a positive value if <db:code role="parameter">str1</db:code> is greater than <db:code role="parameter">str2</db:code>.</db:para>
<db:para>If both strings are <db:code>nullptr</db:code>, they are deemed equal; otherwise, if either is <db:code>nullptr</db:code>, it is treated as less than the other (even if the other is an empty string).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrcmp">qstrcmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstrncmp">qstrncmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstrnicmp">qstrnicmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#character-case">Character Case</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrlen">
<db:title>size_t qstrlen(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qstrlen</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qstrlen(const char *str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>A safe <db:code>strlen()</db:code> function.</db:para>
<db:para>Returns the number of characters that precede the terminating '\0', or 0 if <db:code role="parameter">str</db:code> is <db:code>nullptr</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrnlen">qstrnlen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrncmp">
<db:title>int qstrncmp(const char *<db:emphasis>str1</db:emphasis>, const char *<db:emphasis>str2</db:emphasis>, size_t <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qstrncmp</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str2</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qstrncmp(const char *str1, const char *str2, size_t len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>A safe <db:code>strncmp()</db:code> function.</db:para>
<db:para>Compares at most <db:code role="parameter">len</db:code> bytes of <db:code role="parameter">str1</db:code> and <db:code role="parameter">str2</db:code>.</db:para>
<db:para>Returns a negative value if <db:code role="parameter">str1</db:code> is less than <db:code role="parameter">str2</db:code>, 0 if <db:code role="parameter">str1</db:code> is equal to <db:code role="parameter">str2</db:code> or a positive value if <db:code role="parameter">str1</db:code> is greater than <db:code role="parameter">str2</db:code>.</db:para>
<db:para>If both strings are <db:code>nullptr</db:code>, they are deemed equal; otherwise, if either is <db:code>nullptr</db:code>, it is treated as less than the other (even if the other is an empty string or <db:code role="parameter">len</db:code> is 0).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrcmp">qstrcmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstricmp">qstricmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstrnicmp">qstrnicmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#character-case">Character Case</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrncpy">
<db:title>char *qstrncpy(char *<db:emphasis>dst</db:emphasis>, const char *<db:emphasis>src</db:emphasis>, size_t <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>qstrncpy</db:methodname>
<db:methodparam>
<db:type>char *</db:type>
<db:parameter>dst</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>src</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">char * qstrncpy(char *dst, const char *src, size_t len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>A safe <db:code>strncpy()</db:code> function.</db:para>
<db:para>Copies at most <db:code role="parameter">len</db:code> bytes from <db:code role="parameter">src</db:code> (stopping at <db:code role="parameter">len</db:code> or the terminating '\0' whichever comes first) into <db:code role="parameter">dst</db:code> and returns a pointer to <db:code role="parameter">dst</db:code>. Guarantees that <db:code role="parameter">dst</db:code> is '\0'-terminated. If <db:code role="parameter">src</db:code> or <db:code role="parameter">dst</db:code> is <db:code>nullptr</db:code>, returns <db:code>nullptr</db:code> immediately.</db:para>
<db:para>This function assumes that <db:code role="parameter">dst</db:code> is at least <db:code role="parameter">len</db:code> characters long.</db:para>
<db:note>
<db:para>If <db:code role="parameter">dst</db:code> and <db:code role="parameter">src</db:code> overlap, the behavior is undefined.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrcpy">qstrcpy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrnicmp">
<db:title>int qstrnicmp(const char *<db:emphasis>str1</db:emphasis>, const char *<db:emphasis>str2</db:emphasis>, size_t <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qstrnicmp</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str2</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qstrnicmp(const char *str1, const char *str2, size_t len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>A safe <db:code>strnicmp()</db:code> function.</db:para>
<db:para>Compares at most <db:code role="parameter">len</db:code> bytes of <db:code role="parameter">str1</db:code> and <db:code role="parameter">str2</db:code>, ignoring differences in the case of any ASCII characters.</db:para>
<db:para>Returns a negative value if <db:code role="parameter">str1</db:code> is less than <db:code role="parameter">str2</db:code>, 0 if <db:code role="parameter">str1</db:code> is equal to <db:code role="parameter">str2</db:code> or a positive value if <db:code role="parameter">str1</db:code> is greater than <db:code role="parameter">str2</db:code>.</db:para>
<db:para>If both strings are <db:code>nullptr</db:code>, they are deemed equal; otherwise, if either is <db:code>nullptr</db:code>, it is treated as less than the other (even if the other is an empty string or <db:code role="parameter">len</db:code> is 0).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrcmp">qstrcmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstrncmp">qstrncmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#qstricmp">qstricmp</db:link>()</db:member>
<db:member><db:link xlink:href="qbytearray.xml#character-case">Character Case</db:link></db:member>
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qstrnlen">
<db:title>size_t qstrnlen(const char *<db:emphasis>str</db:emphasis>, size_t <db:emphasis>maxlen</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qstrnlen</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>maxlen</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qstrnlen(const char *str, size_t maxlen)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>A safe <db:code>strnlen()</db:code> function.</db:para>
<db:para>Returns the number of characters that precede the terminating '\0', but at most <db:code role="parameter">maxlen</db:code>. If <db:code role="parameter">str</db:code> is <db:code>nullptr</db:code>, returns 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qstrlen">qstrlen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qvsnprintf">
<db:title>int qvsnprintf(char *<db:emphasis>str</db:emphasis>, size_t <db:emphasis>n</db:emphasis>, const char *<db:emphasis>fmt</db:emphasis>, va_list <db:emphasis>ap</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qvsnprintf</db:methodname>
<db:methodparam>
<db:type>char *</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>n</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>fmt</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>va_list</db:type>
<db:parameter>ap</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qvsnprintf(char *str, size_t n, const char *fmt, va_list ap)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>A portable <db:code>vsnprintf()</db:code> function. Will call <db:code>::vsnprintf()</db:code>, <db:code>::_vsnprintf()</db:code>, or <db:code>::vsnprintf_s</db:code> depending on the system, or fall back to an internal version.</db:para>
<db:para><db:code role="parameter">fmt</db:code> is the <db:code>printf()</db:code> format string. The result is put into <db:code role="parameter">str</db:code>, which is a buffer of at least <db:code role="parameter">n</db:code> bytes.</db:para>
<db:para>The caller is responsible to call <db:code>va_end()</db:code> on <db:code role="parameter">ap</db:code>.</db:para>
<db:warning>
<db:para>Since vsnprintf() shows different behavior on certain platforms, you should not rely on the return value or on the fact that you will always get a 0 terminated string back.</db:para>
</db:warning>
<db:para>Ideally, you should never call this function but use <db:link xlink:href="qstring.xml#asprintf">QString::asprintf</db:link>() instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#qsnprintf">qsnprintf</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#asprintf">QString::asprintf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq-1">
<db:title>bool operator!=(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QByteArray &amp;a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is not equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq-2">
<db:title>bool operator!=(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QByteArray &amp;a1, const char *a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is not equal to the '\0'-terminated string <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq-3">
<db:title>bool operator!=(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const char *a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if '\0'-terminated string <db:code role="parameter">a1</db:code> is not equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b">
<db:title>const QByteArray operator+(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>const QByteArray</db:type>
<db:methodname>operator+</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QByteArray operator+(const QByteArray &amp;a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a byte array that is the result of concatenating byte array <db:code role="parameter">a1</db:code> and byte array <db:code role="parameter">a2</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#operator-2b-eq">QByteArray::operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-1">
<db:title>const QByteArray operator+(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>const QByteArray</db:type>
<db:methodname>operator+</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const QByteArray operator+(const QByteArray &amp;a1, const char *a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a byte array that is the result of concatenating byte array <db:code role="parameter">a1</db:code> and '\0'-terminated string <db:code role="parameter">a2</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-2b-2">
<db:title>const QByteArray operator+(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, char <db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>const QByteArray</db:type>
<db:methodname>operator+</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">const QByteArray operator+(const QByteArray &amp;a1, char a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a byte array that is the result of concatenating byte array <db:code role="parameter">a1</db:code> and byte <db:code role="parameter">a2</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-2b-3">
<db:title>const QByteArray operator+(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>const QByteArray</db:type>
<db:methodname>operator+</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">const QByteArray operator+(const char *a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a byte array that is the result of concatenating '\0'-terminated string <db:code role="parameter">a1</db:code> and byte array <db:code role="parameter">a2</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-2b-4">
<db:title>const QByteArray operator+(char <db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>const QByteArray</db:type>
<db:methodname>operator+</db:methodname>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">const QByteArray operator+(char a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a byte array that is the result of concatenating byte <db:code role="parameter">a1</db:code> and byte array <db:code role="parameter">a2</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-1">
<db:title>bool operator&lt;(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&lt;</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;(const QByteArray &amp;a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically less than byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-2">
<db:title>bool operator&lt;(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&lt;</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;(const QByteArray &amp;a1, const char *a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically less than the '\0'-terminated string <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-3">
<db:title>bool operator&lt;(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&lt;</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;(const char *a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if '\0'-terminated string <db:code role="parameter">a1</db:code> is lexically less than byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>out</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>ba</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&lt;&lt;(QDataStream &amp;out, const QByteArray &amp;ba)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes byte array <db:code role="parameter">ba</db:code> to the stream <db:code role="parameter">out</db:code> and returns a reference to the stream.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-eq-1">
<db:title>bool operator&lt;=(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&lt;=</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;=(const QByteArray &amp;a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically less than or equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-eq-2">
<db:title>bool operator&lt;=(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&lt;=</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;=(const QByteArray &amp;a1, const char *a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically less than or equal to the '\0'-terminated string <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-eq-3">
<db:title>bool operator&lt;=(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&lt;=</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;=(const char *a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if '\0'-terminated string <db:code role="parameter">a1</db:code> is lexically less than or equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-eq-1">
<db:title>bool operator==(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QByteArray &amp;a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-eq-2">
<db:title>bool operator==(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QByteArray &amp;a1, const char *a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is equal to the '\0'-terminated string <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq-eq-3">
<db:title>bool operator==(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const char *a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if '\0'-terminated string <db:code role="parameter">a1</db:code> is equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-1">
<db:title>bool operator&gt;(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&gt;</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;(const QByteArray &amp;a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically greater than byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-2">
<db:title>bool operator&gt;(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&gt;</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;(const QByteArray &amp;a1, const char *a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically greater than the '\0'-terminated string <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-3">
<db:title>bool operator&gt;(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&gt;</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;(const char *a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if '\0'-terminated string <db:code role="parameter">a1</db:code> is lexically greater than byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-eq-1">
<db:title>bool operator&gt;=(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&gt;=</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;=(const QByteArray &amp;a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically greater than or equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-eq-2">
<db:title>bool operator&gt;=(const QByteArray &amp;<db:emphasis>a1</db:emphasis>, const char *<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&gt;=</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;=(const QByteArray &amp;a1, const char *a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if byte array <db:code role="parameter">a1</db:code> is lexically greater than or equal to the '\0'-terminated string <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-eq-3">
<db:title>bool operator&gt;=(const char *<db:emphasis>a1</db:emphasis>, const QByteArray &amp;<db:emphasis>a2</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&gt;=</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>a1</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>a2</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;=(const char *a1, const QByteArray &amp;a2)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns <db:code>true</db:code> if '\0'-terminated string <db:code role="parameter">a1</db:code> is lexically greater than or equal to byte array <db:code role="parameter">a2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbytearray.xml#compare">QByteArray::compare</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>in</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QByteArray &amp;</db:type>
<db:parameter>ba</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&gt;&gt;(QDataStream &amp;in, QByteArray &amp;ba)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a byte array into <db:code role="parameter">ba</db:code> from the stream <db:code role="parameter">in</db:code> and returns a reference to the stream.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QByteArrayLiteral">
<db:title>QByteArrayLiteral(<db:emphasis>ba</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QByteArrayLiteral</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>ba</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArrayLiteral(ba)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The macro generates the data for a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> out of the string literal <db:code role="parameter">ba</db:code> at compile time. Creating a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> from it is free in this case, and the generated byte array data is stored in the read-only segment of the compiled object file.</db:para>
<db:para>For instance:</db:para>
<db:programlisting language="cpp">QByteArray ba = QByteArrayLiteral(&quot;byte array contents&quot;);
</db:programlisting>
<db:para>Using QByteArrayLiteral instead of a double quoted plain C++ string literal can significantly speed up creation of <db:link xlink:href="qbytearray.xml">QByteArray</db:link> instances from data known at compile time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml#QStringLiteral">QStringLiteral</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QT_NO_CAST_FROM_BYTEARRAY">
<db:title>QT_NO_CAST_FROM_BYTEARRAY</db:title>
<db:methodsynopsis>
<db:methodname>QT_NO_CAST_FROM_BYTEARRAY</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QT_NO_CAST_FROM_BYTEARRAY</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Disables automatic conversions from <db:link xlink:href="qbytearray.xml">QByteArray</db:link> to const char * or const void *.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</db:link></db:member>
<db:member><db:link xlink:href="qstring.xml#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
