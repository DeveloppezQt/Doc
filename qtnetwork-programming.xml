<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Network Programming with Qt</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 5.3.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Programming applications with networking capabilities.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The Qt Network module offers classes that allow you to write TCP/IP clients and servers. It offers lower-level classes such as <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>, <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> and <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> that represent low level network concepts, and high level classes such as <db:link xlink:href="qnetworkrequest.xml">QNetworkRequest</db:link>, <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> and <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> to perform network operations using common protocols. It also offers classes such as <db:link xlink:href="qnetworkconfiguration.xml">QNetworkConfiguration</db:link>, <db:link xlink:href="qnetworkconfigurationmanager.xml">QNetworkConfigurationManager</db:link> and <db:link xlink:href="qnetworksession.xml">QNetworkSession</db:link> that implement bearer management.</db:para>
<db:section xml:id="qt-s-classes-for-network-programming">
<db:title>Qt's Classes for Network Programming</db:title>
<db:para>The <db:link xlink:href="qtnetwork-module.xml">Qt Network C++ Classes</db:link> page contains a list of the C++ classes in Qt Network.</db:para>
</db:section>
<db:section xml:id="high-level-network-operations-for-http-and-ftp">
<db:title>High Level Network Operations for HTTP and FTP</db:title>
<db:para>The Network Access API is a collection of classes for performing common network operations. The API provides an abstraction layer over the specific operations and protocols used (for example, getting and posting data over HTTP), and only exposes classes, functions, and signals for general or high level concepts.</db:para>
<db:para>Network requests are represented by the <db:link xlink:href="qnetworkrequest.xml">QNetworkRequest</db:link> class, which also acts as a general container for information associated with a request, such as any header information and the encryption used. The URL specified when a request object is constructed determines the protocol used for a request. Currently HTTP, FTP and local file URLs are supported for uploading and downloading.</db:para>
<db:para>The coordination of network operations is performed by the <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> class. Once a request has been created, this class is used to dispatch it and emit signals to report on its progress. The manager also coordinates the use of <db:link xlink:href="qnetworkcookiejar.xml">cookies</db:link> to store data on the client, authentication requests, and the use of proxies.</db:para>
<db:para>Replies to network requests are represented by the <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> class; these are created by <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> when a request is dispatched. The signals provided by <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> can be used to monitor each reply individually, or developers may choose to use the manager's signals for this purpose instead and discard references to replies. Since <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> is a subclass of <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, replies can be handled synchronously or asynchronously; i.e., as blocking or non-blocking operations.</db:para>
<db:para>Each application or library can create one or more instances of <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> to handle network communication.</db:para>
</db:section>
<db:section xml:id="using-tcp-with-qtcpsocket-and-qtcpserver">
<db:title>Using TCP with QTcpSocket and QTcpServer</db:title>
<db:para>TCP (Transmission Control Protocol) is a low-level network protocol used by most Internet protocols, including HTTP and FTP, for data transfer. It is a reliable, stream-oriented, connection-oriented transport protocol. It is particularly well suited to the continuous transmission of data.</db:para>
<db:mediaobject>
<db:alt>A TCP Stream</db:alt>
<db:imageobject>
<db:imagedata fileref="images/tcpstream.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> class provides an interface for TCP. You can use <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> to implement standard network protocols such as POP3, SMTP, and NNTP, as well as custom protocols.</db:para>
<db:para>A TCP connection must be established to a remote host and port before any data transfer can begin. Once the connection has been established, the IP address and port of the peer are available through <db:link xlink:href="qabstractsocket.xml#peerAddress">QTcpSocket::peerAddress</db:link>() and <db:link xlink:href="qabstractsocket.xml#peerPort">QTcpSocket::peerPort</db:link>(). At any time, the peer can close the connection, and data transfer will then stop immediately.</db:para>
<db:para><db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> works asynchronously and emits signals to report status changes and errors, just like <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>. It relies on the event loop to detect incoming data and to automatically flush outgoing data. You can write data to the socket using <db:link xlink:href="qiodevice.xml#write">QTcpSocket::write</db:link>(), and read data using <db:link xlink:href="qiodevice.xml#read">QTcpSocket::read</db:link>(). <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> represents two independent streams of data: one for reading and one for writing.</db:para>
<db:para>Since <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> inherits <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, you can use it with <db:link xlink:href="qtextstream.xml">QTextStream</db:link> and <db:link xlink:href="qdatastream.xml">QDataStream</db:link>. When reading from a <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>, you must make sure that enough data is available by calling <db:link xlink:href="qabstractsocket.xml#bytesAvailable">QTcpSocket::bytesAvailable</db:link>() beforehand.</db:para>
<db:para>If you need to handle incoming TCP connections (e.g., in a server application), use the <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> class. Call <db:link xlink:href="qtcpserver.xml#listen">QTcpServer::listen</db:link>() to set up the server, and connect to the <db:link xlink:href="qtcpserver.xml#newConnection">QTcpServer::newConnection</db:link>() signal, which is emitted once for every client that connects. In your slot, call <db:link xlink:href="qtcpserver.xml#nextPendingConnection">QTcpServer::nextPendingConnection</db:link>() to accept the connection and use the returned <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> to communicate with the client.</db:para>
<db:para>Although most of its functions work asynchronously, it's possible to use <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> synchronously (i.e., blocking). To get blocking behavior, call <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>'s waitFor...() functions; these suspend the calling thread until a signal has been emitted. For example, after calling the non-blocking <db:link xlink:href="qabstractsocket.xml#connectToHost">QTcpSocket::connectToHost</db:link>() function, call <db:link xlink:href="qabstractsocket.xml#waitForConnected">QTcpSocket::waitForConnected</db:link>() to block the thread until the <db:link xlink:href="qabstractsocket.xml#connected">connected</db:link>() signal has been emitted.</db:para>
<db:para>Synchronous sockets often lead to code with a simpler flow of control. The main disadvantage of the waitFor...() approach is that events won't be processed while a waitFor...() function is blocking. If used in the GUI thread, this might freeze the application's user interface. For this reason, we recommend that you use synchronous sockets only in non-GUI threads. When used synchronously, <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> doesn't require an event loop.</db:para>
<db:para>The <db:link xlink:href="qtnetwork-fortuneclient-example.xml">Fortune Client</db:link> and <db:link xlink:href="qtnetwork-fortuneserver-example.xml">Fortune Server</db:link> examples show how to use <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> and <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> to write TCP client-server applications. See also <db:link xlink:href="qtnetwork-blockingfortuneclient-example.xml">Blocking Fortune Client</db:link> for an example on how to use a synchronous <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> in a separate thread (without using an event loop), and <db:link xlink:href="qtnetwork-threadedfortuneserver-example.xml">Threaded Fortune Server</db:link> for an example of a multithreaded TCP server with one thread per active client.</db:para>
</db:section>
<db:section xml:id="using-udp-with-qudpsocket">
<db:title>Using UDP with QUdpSocket</db:title>
<db:para>UDP (User Datagram Protocol) is a lightweight, unreliable, datagram-oriented, connectionless protocol. It can be used when reliability isn't important. For example, a server that reports the time of day could choose UDP. If a datagram with the time of day is lost, the client can simply make another request.</db:para>
<db:mediaobject>
<db:alt>UDP Packets</db:alt>
<db:imageobject>
<db:imagedata fileref="images/udppackets.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> class allows you to send and receive UDP datagrams. It inherits <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link>, and it therefore shares most of <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>'s interface. The main difference is that <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> transfers data as datagrams instead of as a continuous stream of data. In short, a datagram is a data packet of limited size (normally smaller than 512 bytes), containing the IP address and port of the datagram's sender and receiver in addition to the data being transferred.</db:para>
<db:para><db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> supports IPv4 broadcasting. Broadcasting is often used to implement network discovery protocols, such as finding which host on the network has the most free hard disk space. One host broadcasts a datagram to the network that all other hosts receive. Each host that receives a request then sends a reply back to the sender with its current amount of free disk space. The originator waits until it has received replies from all hosts, and can then choose the server with most free space to store data. To broadcast a datagram, simply send it to the special address <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::Broadcast</db:link> (255.255.255.255), or to your local network's broadcast address.</db:para>
<db:para><db:link xlink:href="qabstractsocket.xml#bind">QUdpSocket::bind</db:link>() prepares the socket for accepting incoming datagrams, much like <db:link xlink:href="qtcpserver.xml#listen">QTcpServer::listen</db:link>() for TCP servers. Whenever one or more datagrams arrive, <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> emits the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal. Call <db:link xlink:href="qudpsocket.xml#readDatagram">QUdpSocket::readDatagram</db:link>() to read the datagram.</db:para>
<db:para>The <db:link xlink:href="qtnetwork-broadcastsender-example.xml">Broadcast Sender</db:link> and <db:link xlink:href="qtnetwork-broadcastreceiver-example.xml">Broadcast Receiver</db:link> examples show how to write a UDP sender and a UDP receiver using Qt.</db:para>
<db:para><db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> also supports multicasting. The <db:link xlink:href="qtnetwork-multicastsender-example.xml">Multicast Sender</db:link> and <db:link xlink:href="qtnetwork-multicastreceiver-example.xml">Multicast Receiver</db:link> examples show how to use write UDP multicast clients.</db:para>
</db:section>
<db:section xml:id="resolving-host-names-using-qhostinfo">
<db:title>Resolving Host Names using QHostInfo</db:title>
<db:para>Before establishing a network connection, <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> and <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> perform a name lookup, translating the host name you're connecting to into an IP address. This operation is usually performed using the DNS (Domain Name Service) protocol.</db:para>
<db:para><db:link xlink:href="qhostinfo.xml">QHostInfo</db:link> provides a static function that lets you perform such a lookup yourself. By calling <db:link xlink:href="qhostinfo.xml#lookupHost">QHostInfo::lookupHost</db:link>() with a host name, a <db:link xlink:href="qobject.xml">QObject</db:link> pointer, and a slot signature, <db:link xlink:href="qhostinfo.xml">QHostInfo</db:link> will perform the name lookup and invoke the given slot when the results are ready. The actual lookup is done in a separate thread, making use of the operating system's own methods for performing name lookups.</db:para>
<db:para><db:link xlink:href="qhostinfo.xml">QHostInfo</db:link> also provides a static function called <db:link xlink:href="qhostinfo.xml#fromName">QHostInfo::fromName</db:link>() that takes the host name as argument and returns the results. In this case, the name lookup is performed in the same thread as the caller. This overload is useful for non-GUI applications or for doing name lookups in a separate, non-GUI thread. (Calling this function in a GUI thread may cause your user interface to freeze while the function blocks as it performs the lookup.)</db:para>
</db:section>
<db:section xml:id="support-for-network-proxies">
<db:title>Support for Network Proxies</db:title>
<db:para>Network communication with Qt can be performed through proxies, which direct or filter network traffic between local and remote connections.</db:para>
<db:para>Individual proxies are represented by the <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> class, which is used to describe and configure the connection to a proxy. Proxy types which operate on different levels of network communication are supported, with SOCKS 5 support allowing proxying of network traffic at a low level, and HTTP and FTP proxying working at the protocol level. See <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::ProxyType</db:link> for more information.</db:para>
<db:para>Proxying can be enabled on a per-socket basis or for all network communication in an application. A newly opened socket can be made to use a proxy by calling its <db:link xlink:href="qabstractsocket.xml#setProxy">QAbstractSocket::setProxy</db:link>() function before it is connected. Application-wide proxying can be enabled for all subsequent socket connections through the use of the <db:link xlink:href="qnetworkproxy.xml#setApplicationProxy">QNetworkProxy::setApplicationProxy</db:link>() function.</db:para>
<db:para>Proxy factories are used to create policies for proxy use. <db:link xlink:href="qnetworkproxyfactory.xml">QNetworkProxyFactory</db:link> supplies proxies based on queries for specific proxy types. The queries themselves are encoded in <db:link xlink:href="qnetworkproxyquery.xml">QNetworkProxyQuery</db:link> objects which enable proxies to be selected based on key criteria, such as the purpose of the proxy (TCP, UDP, TCP server, URL request), local port, remote host and port, and the protocol in use (HTTP, FTP, etc.).</db:para>
<db:para><db:link xlink:href="qnetworkproxyfactory.xml#proxyForQuery">QNetworkProxyFactory::proxyForQuery</db:link>() is used to query the factory directly. An application-wide policy for proxying can be implemented by passing a factory to <db:link xlink:href="qnetworkproxyfactory.xml#setApplicationProxyFactory">QNetworkProxyFactory::setApplicationProxyFactory</db:link>() and a custom proxying policy can be created by subclassing <db:link xlink:href="qnetworkproxyfactory.xml">QNetworkProxyFactory</db:link>; see the class documentation for details.</db:para>
</db:section>
<db:section xml:id="bearer-management-support">
<db:title>Bearer Management Support</db:title>
<db:para>Bearer Management controls the connectivity state of the device such that the application can start or stop network interfaces and roam transparently between access points.</db:para>
<db:para>The <db:link xlink:href="qnetworkconfigurationmanager.xml">QNetworkConfigurationManager</db:link> class manages the list of network configurations known to the device. A network configuration describes the set of parameters used to start a network interface and is represented by the <db:link xlink:href="qnetworkconfiguration.xml">QNetworkConfiguration</db:link> class.</db:para>
<db:para>A network interface is started by openning a <db:link xlink:href="qnetworksession.xml">QNetworkSession</db:link> based on a given network configuration. In most situations creating a network session based on the platform specified default network configuration is appropriate. The default network configuration is returned by the <db:link xlink:href="qnetworkconfigurationmanager.xml#defaultConfiguration">QNetworkConfigurationManager::defaultConfiguration</db:link>() function.</db:para>
<db:para>On some platforms it is a platform requirement that the application open a network session before any network operations can be performed. This can be tested by the presents of the <db:link xlink:href="qnetworkconfigurationmanager.xml#Capability-enum">QNetworkConfigurationManager::NetworkSessionRequired</db:link> flag in the value returned by the <db:link xlink:href="qnetworkconfigurationmanager.xml#capabilities">QNetworkConfigurationManager::capabilities</db:link>() function.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="bearer-management.xml">Bearer Management</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
