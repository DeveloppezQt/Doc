<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QVarLengthArray Class</db:title>
<db:subtitle>template &lt;typename T, qsizetype Prealloc&gt; class QVarLengthArray</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.4.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> class provides a low-level variable-length array.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QVarLengthArray</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qvlabase.xml" xlink:role="class">QVLABase</db:link> and <db:link xlink:href="qvlastorage.xml" xlink:role="class">QVLAStorage</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QVarLengthArray is part of <db:simplelist><db:member>tools</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The C++ language doesn't support variable-length arrays on the stack. For example, the following code won't compile:</db:para>
<db:programlisting language="cpp">int myfunc(int n)
{
    int table[n + 1];  // WRONG
    ...
    return table[n];
}
</db:programlisting>
<db:para>The alternative is to allocate the array on the heap (with new):</db:para>
<db:programlisting language="cpp">int myfunc(int n)
{
    int *table = new int[n + 1];
    ...
    int ret = table[n];
    delete[] table;
    return ret;
}
</db:programlisting>
<db:para>However, if myfunc() is called very frequently from the application's inner loop, heap allocation can be a major source of slowdown.</db:para>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> is an attempt to work around this gap in the C++ language. It allocates a certain number of elements on the stack, and if you resize the array to a larger size, it automatically uses the heap instead. Stack allocation has the advantage that it is much faster than heap allocation.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">int myfunc(int n)
{
    QVarLengthArray&amp;lt;int, 1024&amp;gt; array(n + 1);
    ...
    return array[n];
}
</db:programlisting>
<db:para>In the example above, <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> will preallocate 1024 elements on the stack and use them unless n + 1 is greater than 1024. If you omit the second template argument, <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>'s default of 256 is used.</db:para>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>'s value type must be an <db:link xlink:href="containers.xml#assignable-data-type">assignable data type</db:link>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> as a value; instead, store a <db:link xlink:href="qwidget.xml">QWidget</db:link> *.</db:para>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>, like <db:link xlink:href="qlist.xml">QList</db:link>, provides a resizable array data structure. The main differences between the two classes are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>'s API is much more low-level and it lacks some of <db:link xlink:href="qlist.xml">QList</db:link>'s functionality.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> doesn't initialize the memory if the value is a basic type. (<db:link xlink:href="qlist.xml">QList</db:link> always does.)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qlist.xml">QList</db:link> uses <db:link xlink:href="implicit-sharing.xml">implicit sharing</db:link> as a memory optimization. <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> doesn't provide that feature; however, it usually produces slightly better performance due to reduced overhead, especially in tight loops.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In summary, <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> is a low-level optimization class that only makes sense in very specific cases. It is used a few places inside Qt and was added to Qt's public API for the convenience of advanced users.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml">QList</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="const_iterator-typedef">
<db:title>[alias] QVarLengthArray::const_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>const_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for const T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_pointer-typedef">
<db:title>[alias] QVarLengthArray::const_pointer</db:title>
<db:typedefsynopsis>
<db:typedefname>const_pointer</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for const T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>[alias] QVarLengthArray::const_reference</db:title>
<db:typedefsynopsis>
<db:typedefname>const_reference</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for const T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="const_reverse_iterator-typedef">
<db:title>[alias, since 5.6] QVarLengthArray::const_reverse_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>const_reverse_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for std::reverse_iterator&lt;const T*&gt;. Provided for STL compatibility.</db:para>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>[alias] QVarLengthArray::difference_type</db:title>
<db:typedefsynopsis>
<db:typedefname>difference_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="iterator-typedef">
<db:title>[alias] QVarLengthArray::iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="pointer-typedef">
<db:title>[alias] QVarLengthArray::pointer</db:title>
<db:typedefsynopsis>
<db:typedefname>pointer</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T *. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>[alias] QVarLengthArray::reference</db:title>
<db:typedefsynopsis>
<db:typedefname>reference</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T &amp;. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="reverse_iterator-typedef">
<db:title>[alias, since 5.6] QVarLengthArray::reverse_iterator</db:title>
<db:typedefsynopsis>
<db:typedefname>reverse_iterator</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for std::reverse_iterator&lt;T*&gt;. Provided for STL compatibility.</db:para>
<db:para>This typedef was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>[alias] QVarLengthArray::size_type</db:title>
<db:typedefsynopsis>
<db:typedefname>size_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>[alias] QVarLengthArray::value_type</db:title>
<db:typedefsynopsis>
<db:typedefname>value_type</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="insert">
<db:title>void QVarLengthArray::insert(qsizetype <db:emphasis>i</db:emphasis>, T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="insert-1">void QVarLengthArray::insert(qsizetype <db:emphasis>i</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>Inserts <db:code role="parameter">value</db:code> at index position <db:code role="parameter">i</db:code> in the array. If <db:code role="parameter">i</db:code> is 0, the value is prepended to the vector. If <db:code role="parameter">i</db:code> is <db:link xlink:href="qvarlengtharray.xml#size">size</db:link>(), the value is appended to the vector.</db:para>
<db:para>For large arrays, this operation can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because it requires moving all the items at indexes <db:code role="parameter">i</db:code> and above by one position further in memory. If you want a container class that provides a fast <db:link xlink:href="qvarlengtharray.xml#insert">insert</db:link>() function, use std::list instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-4">
<db:title>QVarLengthArray::iterator QVarLengthArray::insert(QVarLengthArray::const_iterator <db:emphasis>before</db:emphasis>, T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="insert-5">QVarLengthArray::iterator QVarLengthArray::insert(QVarLengthArray::const_iterator <db:emphasis>before</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts <db:code role="parameter">value</db:code> in front of the item pointed to by the iterator <db:code role="parameter">before</db:code>. Returns an iterator pointing at the inserted item.</db:para>
</db:section>
<db:section xml:id="QVarLengthArray">
<db:title>QVarLengthArray::QVarLengthArray()</db:title>
<db:constructorsynopsis>
<db:methodname>QVarLengthArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an array with an initial size of zero.</db:para>
</db:section>
<db:section xml:id="QVarLengthArray-1">
<db:title>[explicit] QVarLengthArray::QVarLengthArray(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVarLengthArray</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray(qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an array with an initial size of <db:code role="parameter">size</db:code> elements.</db:para>
<db:para>If the value type is a primitive type (e.g., char, int, float) or a pointer type (e.g., <db:link xlink:href="qwidget.xml">QWidget</db:link> *), the elements are not initialized. For other types, the elements are initialized with a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
</db:section>
<db:section xml:id="QVarLengthArray-2">
<db:title>[explicit, since 6.4] QVarLengthArray::QVarLengthArray(qsizetype <db:emphasis>size</db:emphasis>, const T &amp;<db:emphasis>v</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVarLengthArray</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray(qsizetype size, const T &amp;v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an array with an initial size of <db:code role="parameter">size</db:code> elements filled with copies of <db:code role="parameter">v</db:code>.</db:para>
<db:note>
<db:para>This constructor is only available when T is copy-constructible.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVarLengthArray-3">
<db:title>QVarLengthArray::QVarLengthArray(const QVarLengthArray&lt;T, Prealloc&gt; &amp;<db:emphasis>other</db:emphasis> = Prealloc)</db:title>
<db:constructorsynopsis>
<db:methodname>QVarLengthArray</db:methodname>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
<db:initializer>Prealloc</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray(const QVarLengthArray&lt;T, Prealloc&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
</db:section>
<db:section xml:id="QVarLengthArray-4">
<db:title>[since 6.0] QVarLengthArray::QVarLengthArray(QVarLengthArray&lt;T, Prealloc&gt; &amp;&amp;<db:emphasis>other</db:emphasis> = Prealloc)</db:title>
<db:constructorsynopsis>
<db:methodname>QVarLengthArray</db:methodname>
<db:methodparam>
<db:type>QVarLengthArray&lt;T, Prealloc&gt; &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
<db:initializer>Prealloc</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray(QVarLengthArray&lt;T, Prealloc&gt; &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Move-constructs this variable-length array from <db:code role="parameter">other</db:code>. After the move, <db:code role="parameter">other</db:code> is empty.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="QVarLengthArray-5">
<db:title>[since 5.5] QVarLengthArray::QVarLengthArray(std::initializer_list&lt;T&gt; <db:emphasis>args</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVarLengthArray</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;T&gt;</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray(std::initializer_list&lt;T&gt; args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an array from the std::initializer_list given by <db:code role="parameter">args</db:code>.</db:para>
<db:para>This constructor is only enabled if the compiler supports C++11 initializer lists.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
</db:section>
<db:section xml:id="QVarLengthArray-6">
<db:title>[since 5.14] QVarLengthArray::QVarLengthArray(InputIterator <db:emphasis>first</db:emphasis>, InputIterator <db:emphasis>last</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QVarLengthArray</db:methodname>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>first</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputIterator</db:type>
<db:parameter>last</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray(InputIterator first, InputIterator last)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs an array with the contents in the iterator range [<db:code role="parameter">first</db:code>, <db:code role="parameter">last</db:code>).</db:para>
<db:para>The value type of InputIterator must be convertible to T.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
</db:section>
<db:section xml:id="dtor.QVarLengthArray">
<db:title>QVarLengthArray::~QVarLengthArray()</db:title>
<db:destructorsynopsis>
<db:methodname>~QVarLengthArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QVarLengthArray()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the array.</db:para>
</db:section>
<db:section xml:id="append">
<db:title>void QVarLengthArray::append(const T &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(const T &amp;t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends item <db:code role="parameter">t</db:code> to the array, extending the array if necessary.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#removeLast">removeLast</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="append-1">
<db:title>[since 5.9] void QVarLengthArray::append(T &amp;&amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>T &amp;&amp;</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(T &amp;&amp;t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads <db:link xlink:href="qvarlengtharray.xml#append">append</db:link>.</db:para>
<db:note>
<db:para>Unlike the lvalue overload of <db:link xlink:href="qvarlengtharray.xml#append">append</db:link>(), passing a reference to an object that is already an element of *this leads to undefined behavior:</db:para>
</db:note>
<db:programlisting language="cpp">vla.append(std::move(vla[0])); // BUG: passing an object that is already in the container
</db:programlisting>
<db:para>This function was introduced in Qt 5.9.</db:para>
</db:section>
<db:section xml:id="append-2">
<db:title>void QVarLengthArray::append(const T *<db:emphasis>buf</db:emphasis>, qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>append</db:methodname>
<db:methodparam>
<db:type>const T *</db:type>
<db:parameter>buf</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void append(const T *buf, qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends <db:code role="parameter">size</db:code> amount of items referenced by <db:code role="parameter">buf</db:code> to this array.</db:para>
</db:section>
<db:section xml:id="at">
<db:title>const T &amp;QVarLengthArray::at(qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>at</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; at(qsizetype i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a reference to the item at index position <db:code role="parameter">i</db:code>.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the array (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qvarlengtharray.xml#size">size</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#value">value</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="back">
<db:title>[since 5.0] T &amp;QVarLengthArray::back()</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>back</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; back()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Same as <db:link xlink:href="qvarlengtharray.xml#last">last</db:link>(). Provided for STL-compatibility.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="back-1">
<db:title>[since 5.0] const T &amp;QVarLengthArray::back() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>back</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; back() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="begin">
<db:title>QVarLengthArray::iterator QVarLengthArray::begin()</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray::iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::iterator begin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin-1">
<db:title>QVarLengthArray::const_iterator QVarLengthArray::begin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVarLengthArray::const_iterator</db:type>
<db:methodname>begin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::const_iterator begin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="capacity">
<db:title>qsizetype QVarLengthArray::capacity() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>capacity</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype capacity() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the maximum number of elements that can be stored in the array without forcing a reallocation.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the array, call <db:link xlink:href="qvarlengtharray.xml#size">size</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>[since 5.0] QVarLengthArray::const_iterator QVarLengthArray::cbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVarLengthArray::const_iterator</db:type>
<db:methodname>cbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::const_iterator cbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the array.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#cend">cend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[since 5.0] QVarLengthArray::const_iterator QVarLengthArray::cend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVarLengthArray::const_iterator</db:type>
<db:methodname>cend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::const_iterator cend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the array.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clear">
<db:title>void QVarLengthArray::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all the elements from the array.</db:para>
<db:para>Same as resize(0).</db:para>
</db:section>
<db:section xml:id="constBegin">
<db:title>QVarLengthArray::const_iterator QVarLengthArray::constBegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVarLengthArray::const_iterator</db:type>
<db:methodname>constBegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::const_iterator constBegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the first item in the array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constData">
<db:title>const T *QVarLengthArray::constData() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T *</db:type>
<db:methodname>constData</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const T * constData() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const pointer to the data stored in the array. The pointer can be used to access the items in the array. The pointer remains valid as long as the array isn't reallocated.</db:para>
<db:para>This function is mostly useful to pass an array to a function that accepts a plain C++ array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="constEnd">
<db:title>QVarLengthArray::const_iterator QVarLengthArray::constEnd() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVarLengthArray::const_iterator</db:type>
<db:methodname>constEnd</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::const_iterator constEnd() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#constBegin">constBegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#end">end</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contains">
<db:title>[since 5.3] bool QVarLengthArray::contains(const AT &amp;<db:emphasis>value</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>contains</db:methodname>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool contains(const AT &amp;value) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the array contains an occurrence of <db:code role="parameter">value</db:code>; otherwise returns false.</db:para>
<db:para>This function requires the value type to have an implementation of operator==().</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#lastIndexOf">lastIndexOf</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="count">
<db:title>qsizetype QVarLengthArray::count() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>count</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype count() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Same as <db:link xlink:href="qvarlengtharray.xml#size">size</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="crbegin">
<db:title>[since 5.6] QVarLengthArray::const_reverse_iterator QVarLengthArray::crbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVarLengthArray::const_reverse_iterator</db:type>
<db:methodname>crbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::const_reverse_iterator crbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first item in the variable length array, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="crend">
<db:title>[since 5.6] QVarLengthArray::const_reverse_iterator QVarLengthArray::crend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVarLengthArray::const_reverse_iterator</db:type>
<db:methodname>crend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::const_reverse_iterator crend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a const <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to one past the last item in the variable length array, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>T *QVarLengthArray::data()</db:title>
<db:methodsynopsis>
<db:type>T *</db:type>
<db:methodname>data</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T * data()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the data stored in the array. The pointer can be used to access and modify the items in the array.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVarLengthArray&amp;lt;int&amp;gt; array(10);
int *data = array.data();
for (int i = 0; i &amp;lt; 10; ++i)
    data[i] = 2 * i;
</db:programlisting>
<db:para>The pointer remains valid as long as the array isn't reallocated.</db:para>
<db:para>This function is mostly useful to pass an array to a function that accepts a plain C++ array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#constData">constData</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data-1">
<db:title>const T *QVarLengthArray::data() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T *</db:type>
<db:methodname>data</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T * data() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="emplace">
<db:title>[since 6.3] QVarLengthArray::iterator QVarLengthArray::emplace(QVarLengthArray::const_iterator <db:emphasis>pos</db:emphasis>, Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray::iterator</db:type>
<db:methodname>emplace</db:methodname>
<db:methodparam>
<db:type>QVarLengthArray::const_iterator</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Args &amp;&amp;...</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::iterator emplace(QVarLengthArray::const_iterator pos, Args &amp;&amp;... args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts an item in front of the item pointed to by the iterator <db:code role="parameter">pos</db:code>, passing <db:code role="parameter">args</db:code> to its constructor.</db:para>
<db:para>Returns an iterator pointing at the emplaced item.</db:para>
<db:para>This function was introduced in Qt 6.3.</db:para>
</db:section>
<db:section xml:id="emplace_back">
<db:title>[since 6.3] T &amp;QVarLengthArray::emplace_back(Args &amp;&amp;... <db:emphasis>args</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>emplace_back</db:methodname>
<db:methodparam>
<db:type>Args &amp;&amp;...</db:type>
<db:parameter>args</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; emplace_back(Args &amp;&amp;... args)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts an item at the back of this <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>, passing <db:code role="parameter">args</db:code> to its constructor.</db:para>
<db:para>Returns a reference to the emplaced item.</db:para>
<db:para>This function was introduced in Qt 6.3.</db:para>
</db:section>
<db:section xml:id="empty">
<db:title>[since 5.0] bool QVarLengthArray::empty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>empty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool empty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the array has size 0; otherwise returns false.</db:para>
<db:para>Same as <db:link xlink:href="qvarlengtharray.xml#isEmpty">isEmpty</db:link>(). Provided for STL-compatibility.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="end">
<db:title>QVarLengthArray::iterator QVarLengthArray::end()</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray::iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::iterator end()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns an <db:link xlink:href="containers.xml#stl-style-iterators">STL-style iterator</db:link> pointing to the imaginary item after the last item in the array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#constEnd">constEnd</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end-1">
<db:title>QVarLengthArray::const_iterator QVarLengthArray::end() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVarLengthArray::const_iterator</db:type>
<db:methodname>end</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::const_iterator end() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="erase">
<db:title>QVarLengthArray::iterator QVarLengthArray::erase(QVarLengthArray::const_iterator <db:emphasis>pos</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QVarLengthArray::const_iterator</db:type>
<db:parameter>pos</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::iterator erase(QVarLengthArray::const_iterator pos)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the item pointed to by the iterator <db:code role="parameter">pos</db:code> from the vector, and returns an iterator to the next item in the vector (which may be <db:link xlink:href="qvarlengtharray.xml#end">end</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase-1">
<db:title>QVarLengthArray::iterator QVarLengthArray::erase(QVarLengthArray::const_iterator <db:emphasis>begin</db:emphasis>, QVarLengthArray::const_iterator <db:emphasis>end</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray::iterator</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QVarLengthArray::const_iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QVarLengthArray::const_iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::iterator erase(QVarLengthArray::const_iterator begin, QVarLengthArray::const_iterator end)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Removes all the items from <db:code role="parameter">begin</db:code> up to (but not including) <db:code role="parameter">end</db:code>. Returns an iterator to the same item that <db:code role="parameter">end</db:code> referred to before the call.</db:para>
</db:section>
<db:section xml:id="first">
<db:title>T &amp;QVarLengthArray::first()</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>first</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; first()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a reference to the first item in the array. The array must not be empty. If the array can be empty, check <db:link xlink:href="qvarlengtharray.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first-1">
<db:title>const T &amp;QVarLengthArray::first() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>first</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; first() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="front">
<db:title>[since 5.0] T &amp;QVarLengthArray::front()</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>front</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; front()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Same as <db:link xlink:href="qvarlengtharray.xml#first">first</db:link>(). Provided for STL-compatibility.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="front-1">
<db:title>[since 5.0] const T &amp;QVarLengthArray::front() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>front</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; front() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="indexOf">
<db:title>[since 5.3] qsizetype QVarLengthArray::indexOf(const AT &amp;<db:emphasis>value</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = 0) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>indexOf</db:methodname>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>from</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype indexOf(const AT &amp;value, qsizetype from) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the index position of the first occurrence of <db:code role="parameter">value</db:code> in the array, searching forward from index position <db:code role="parameter">from</db:code>. Returns -1 if no item matched.</db:para>
<db:para>This function requires the value type to have an implementation of operator==().</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#lastIndexOf">lastIndexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="insert-2">
<db:title>void QVarLengthArray::insert(qsizetype <db:emphasis>i</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void insert(qsizetype i, qsizetype count, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Inserts <db:code role="parameter">count</db:code> copies of <db:code role="parameter">value</db:code> at index position <db:code role="parameter">i</db:code> in the vector.</db:para>
</db:section>
<db:section xml:id="insert-3">
<db:title>QVarLengthArray::iterator QVarLengthArray::insert(QVarLengthArray::const_iterator <db:emphasis>before</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray::iterator</db:type>
<db:methodname>insert</db:methodname>
<db:methodparam>
<db:type>QVarLengthArray::const_iterator</db:type>
<db:parameter>before</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::iterator insert(QVarLengthArray::const_iterator before, qsizetype count, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts <db:code role="parameter">count</db:code> copies of <db:code role="parameter">value</db:code> in front of the item pointed to by the iterator <db:code role="parameter">before</db:code>. Returns an iterator pointing at the first of the inserted items.</db:para>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QVarLengthArray::isEmpty() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isEmpty</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isEmpty() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the array has size 0; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last">
<db:title>T &amp;QVarLengthArray::last()</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>last</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; last()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a reference to the last item in the array. The array must not be empty. If the array can be empty, check <db:link xlink:href="qvarlengtharray.xml#isEmpty">isEmpty</db:link>() before calling this function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last-1">
<db:title>const T &amp;QVarLengthArray::last() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>last</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; last() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="lastIndexOf">
<db:title>[since 5.3] qsizetype QVarLengthArray::lastIndexOf(const AT &amp;<db:emphasis>value</db:emphasis>, qsizetype <db:emphasis>from</db:emphasis> = -1) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>lastIndexOf</db:methodname>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>from</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype lastIndexOf(const AT &amp;value, qsizetype from) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the index position of the last occurrence of the value <db:code role="parameter">value</db:code> in the array, searching backward from index position <db:code role="parameter">from</db:code>. If <db:code role="parameter">from</db:code> is -1 (the default), the search starts at the last item. Returns -1 if no item matched.</db:para>
<db:para>This function requires the value type to have an implementation of operator==().</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#indexOf">indexOf</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#contains">contains</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="length">
<db:title>[since 5.0] qsizetype QVarLengthArray::length() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>length</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype length() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Same as <db:link xlink:href="qvarlengtharray.xml#size">size</db:link>().</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pop_back">
<db:title>[since 5.0] void QVarLengthArray::pop_back()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>pop_back</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void pop_back()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Same as <db:link xlink:href="qvarlengtharray.xml#removeLast">removeLast</db:link>(). Provided for STL-compatibility.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="push_back">
<db:title>[since 5.0] void QVarLengthArray::push_back(const T &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_back</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_back(const T &amp;t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends item <db:code role="parameter">t</db:code> to the array, extending the array if necessary. Provided for STL-compatibility.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="push_back-1">
<db:title>[since 5.9] void QVarLengthArray::push_back(T &amp;&amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>push_back</db:methodname>
<db:methodparam>
<db:type>T &amp;&amp;</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void push_back(T &amp;&amp;t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads <db:link xlink:href="qvarlengtharray.xml#push_back">push_back</db:link>.</db:para>
<db:note>
<db:para>Unlike the lvalue overload of <db:link xlink:href="qvarlengtharray.xml#push_back">push_back</db:link>(), passing a reference to an object that is already an element of *this leads to undefined behavior:</db:para>
</db:note>
<db:programlisting language="cpp">vla.push_back(std::move(vla[0])); // BUG: passing an object that is already in the container
</db:programlisting>
<db:para>This function was introduced in Qt 5.9.</db:para>
</db:section>
<db:section xml:id="rbegin">
<db:title>[since 5.6] QVarLengthArray::reverse_iterator QVarLengthArray::rbegin()</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray::reverse_iterator</db:type>
<db:methodname>rbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::reverse_iterator rbegin()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to the first item in the variable length array, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#rend">rend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rbegin-1">
<db:title>[since 5.6] QVarLengthArray::const_reverse_iterator QVarLengthArray::rbegin() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVarLengthArray::const_reverse_iterator</db:type>
<db:methodname>rbegin</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::const_reverse_iterator rbegin() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="remove">
<db:title>void QVarLengthArray::remove(qsizetype <db:emphasis>i</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis> = 1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>remove</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>count</db:parameter>
<db:initializer>1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void remove(qsizetype i, qsizetype count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Removes <db:code role="parameter">count</db:code> elements from the middle of the array, starting at index position <db:code role="parameter">i</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#insert">insert</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#replace">replace</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeAll">
<db:title>[since 6.1] qsizetype QVarLengthArray::removeAll(const AT &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>removeAll</db:methodname>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype removeAll(const AT &amp;t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements that compare equal to <db:code role="parameter">t</db:code> from the array. Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#removeOne">removeOne</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeIf">
<db:title>[since 6.1] qsizetype QVarLengthArray::removeIf(Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>removeIf</db:methodname>
<db:methodparam>
<db:type>Predicate</db:type>
<db:parameter>pred</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype removeIf(Predicate pred)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the array. Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#removeAll">removeAll</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeLast">
<db:title>void QVarLengthArray::removeLast()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeLast</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeLast()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Decreases the size of the array by one. The allocated size is not changed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#append">append</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeOne">
<db:title>[since 6.1] bool QVarLengthArray::removeOne(const AT &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>removeOne</db:methodname>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool removeOne(const AT &amp;t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the first element that compares equal to <db:code role="parameter">t</db:code> from the array. Returns whether an element was, in fact, removed.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#removeAll">removeAll</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend">
<db:title>[since 5.6] QVarLengthArray::reverse_iterator QVarLengthArray::rend()</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray::reverse_iterator</db:type>
<db:methodname>rend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::reverse_iterator rend()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="containers.xml#stl-style-iterators">STL-style</db:link> reverse iterator pointing to one past the last item in the variable length array, in reverse order.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#rbegin">rbegin</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend-1">
<db:title>[since 5.6] QVarLengthArray::const_reverse_iterator QVarLengthArray::rend() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVarLengthArray::const_reverse_iterator</db:type>
<db:methodname>rend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray::const_reverse_iterator rend() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="replace">
<db:title>void QVarLengthArray::replace(qsizetype <db:emphasis>i</db:emphasis>, const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>replace</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void replace(qsizetype i, const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces the item at index position <db:code role="parameter">i</db:code> with <db:code role="parameter">value</db:code>.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the array (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qvarlengtharray.xml#size">size</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#remove">remove</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reserve">
<db:title>void QVarLengthArray::reserve(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>reserve</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void reserve(qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to allocate memory for at least <db:code role="parameter">size</db:code> elements. If you know in advance how large the array can get, you can call this function and if you call <db:link xlink:href="qvarlengtharray.xml#resize">resize</db:link>() often, you are likely to get better performance. If <db:code role="parameter">size</db:code> is an underestimate, the worst that will happen is that the <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> will be a bit slower.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>'s memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the array, call <db:link xlink:href="qvarlengtharray.xml#resize">resize</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#capacity">capacity</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resize">
<db:title>void QVarLengthArray::resize(qsizetype <db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resize</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resize(qsizetype size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the size of the array to <db:code role="parameter">size</db:code>. If <db:code role="parameter">size</db:code> is greater than the current size, elements are added to the end. If <db:code role="parameter">size</db:code> is less than the current size, elements are removed from the end.</db:para>
<db:para>If the value type is a primitive type (e.g., char, int, float) or a pointer type (e.g., <db:link xlink:href="qwidget.xml">QWidget</db:link> *), new elements are not initialized. For other types, the elements are initialized with a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resize-1">
<db:title>[since 6.4] void QVarLengthArray::resize(qsizetype <db:emphasis>size</db:emphasis>, const T &amp;<db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resize</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void resize(qsizetype size, const T &amp;v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the size of the array to <db:code role="parameter">size</db:code>. If <db:code role="parameter">size</db:code> is greater than the current size, copies of <db:code role="parameter">v</db:code> are added to the end. If <db:code role="parameter">size</db:code> is less than the current size, elements are removed from the end.</db:para>
<db:note>
<db:para>This function is only available when T is copy-constructible.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#squeeze">squeeze</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="shrink_to_fit">
<db:title>[since 5.10] void QVarLengthArray::shrink_to_fit()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>shrink_to_fit</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void shrink_to_fit()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Same as <db:link xlink:href="qvarlengtharray.xml#squeeze">squeeze</db:link>(). Provided for STL-compatibility.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
</db:section>
<db:section xml:id="size">
<db:title>qsizetype QVarLengthArray::size() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>size</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype size() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of elements in the array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#isEmpty">isEmpty</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="squeeze">
<db:title>[since 5.1] void QVarLengthArray::squeeze()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>squeeze</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void squeeze()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Releases any memory not required to store the items. If the container can fit its storage on the stack allocation, it will free the heap allocation and copy the elements back to the stack.</db:para>
<db:para>The sole purpose of this function is to provide a means of fine tuning <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>'s memory usage. In general, you will rarely ever need to call this function.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#reserve">reserve</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#capacity">capacity</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#resize">resize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value">
<db:title>T QVarLengthArray::value(qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T value(qsizetype i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the value at index position <db:code role="parameter">i</db:code>.</db:para>
<db:para>If the index <db:code role="parameter">i</db:code> is out of bounds, the function returns a <db:link xlink:href="containers.xml#default-constructed-value">default-constructed value</db:link>. If you are certain that <db:code role="parameter">i</db:code> is within bounds, you can use <db:link xlink:href="qvarlengtharray.xml#at">at</db:link>() instead, which is slightly faster.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#at">at</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#operator-5b-5d">operator[]</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="value-1">
<db:title>T QVarLengthArray::value(qsizetype <db:emphasis>i</db:emphasis>, const T &amp;<db:emphasis>defaultValue</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>value</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>defaultValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T value(qsizetype i, const T &amp;defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>If the index <db:code role="parameter">i</db:code> is out of bounds, the function returns <db:code role="parameter">defaultValue</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-2b-eq">
<db:title>QVarLengthArray&lt;T, Prealloc&gt; &amp;QVarLengthArray::operator+=(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray&lt;T, Prealloc&gt; &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray&lt;T, Prealloc&gt; &amp; operator+=(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends <db:code role="parameter">value</db:code> to the array and returns a reference to this vector.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq-1">
<db:title>[since 5.11] QVarLengthArray&lt;T, Prealloc&gt; &amp;QVarLengthArray::operator+=(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray&lt;T, Prealloc&gt; &amp;</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>T &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray&lt;T, Prealloc&gt; &amp; operator+=(T &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.11.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#operator-lt-lt">operator&lt;&lt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt">
<db:title>QVarLengthArray&lt;T, Prealloc&gt; &amp;QVarLengthArray::operator&lt;&lt;(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray&lt;T, Prealloc&gt; &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray&lt;T, Prealloc&gt; &amp; operator&lt;&lt;(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends <db:code role="parameter">value</db:code> to the array and returns a reference to this vector.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt-1">
<db:title>[since 5.11] QVarLengthArray&lt;T, Prealloc&gt; &amp;QVarLengthArray::operator&lt;&lt;(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray&lt;T, Prealloc&gt; &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>T &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray&lt;T, Prealloc&gt; &amp; operator&lt;&lt;(T &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.11.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QVarLengthArray&lt;T, Prealloc&gt; &amp;QVarLengthArray::operator=(const QVarLengthArray&lt;T, Prealloc&gt; &amp;<db:emphasis>other</db:emphasis> = Prealloc)</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray&lt;T, Prealloc&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
<db:initializer>Prealloc</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray&lt;T, Prealloc&gt; &amp; operator=(const QVarLengthArray&lt;T, Prealloc&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">other</db:code> to this array and returns a reference to this array.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[since 6.0] QVarLengthArray&lt;T, Prealloc&gt; &amp;QVarLengthArray::operator=(QVarLengthArray&lt;T, Prealloc&gt; &amp;&amp;<db:emphasis>other</db:emphasis> = Prealloc)</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray&lt;T, Prealloc&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QVarLengthArray&lt;T, Prealloc&gt; &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
<db:initializer>Prealloc</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray&lt;T, Prealloc&gt; &amp; operator=(QVarLengthArray&lt;T, Prealloc&gt; &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this array and returns a reference to this array. After the move, <db:code role="parameter">other</db:code> is empty.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="operator-eq-2">
<db:title>[since 5.5] QVarLengthArray&lt;T, Prealloc&gt; &amp;QVarLengthArray::operator=(std::initializer_list&lt;T&gt; <db:emphasis>list</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVarLengthArray&lt;T, Prealloc&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>std::initializer_list&lt;T&gt;</db:type>
<db:parameter>list</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QVarLengthArray&lt;T, Prealloc&gt; &amp; operator=(std::initializer_list&lt;T&gt; list)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns the values of <db:code role="parameter">list</db:code> to this array, and returns a reference to this array.</db:para>
<db:para>This constructor is only enabled if the compiler supports C++11 initializer lists.</db:para>
<db:para>This function was introduced in Qt 5.5.</db:para>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>T &amp;QVarLengthArray::operator[](qsizetype <db:emphasis>i</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T &amp;</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T &amp; operator[](qsizetype i)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a reference to the item at index position <db:code role="parameter">i</db:code>.</db:para>
<db:para><db:code role="parameter">i</db:code> must be a valid index position in the array (i.e., 0 &lt;= <db:code role="parameter">i</db:code> &lt; <db:link xlink:href="qvarlengtharray.xml#size">size</db:link>()).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#at">at</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>const T &amp;QVarLengthArray::operator[](qsizetype <db:emphasis>i</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const T &amp;</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const T &amp; operator[](qsizetype i) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="erase-2">
<db:title>[since 6.1] qsizetype erase(QVarLengthArray&lt;T, Prealloc&gt; &amp;<db:emphasis>array</db:emphasis> = Prealloc, const AT &amp;<db:emphasis>t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>erase</db:methodname>
<db:methodparam>
<db:type>QVarLengthArray&lt;T, Prealloc&gt; &amp;</db:type>
<db:parameter>array</db:parameter>
<db:initializer>Prealloc</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const AT &amp;</db:type>
<db:parameter>t</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype erase(QVarLengthArray&lt;T, Prealloc&gt; &amp;array, const AT &amp;t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements that compare equal to <db:code role="parameter">t</db:code> from the array <db:code role="parameter">array</db:code>. Returns the number of elements removed, if any.</db:para>
<db:note>
<db:para><db:code role="parameter">t</db:code> is not allowed to be a reference to an element inside <db:code role="parameter">array</db:code>. If you cannot be sure that this is not the case, take a copy of <db:code role="parameter">t</db:code> and call this function with the copy.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#erase_if">erase_if</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="erase_if">
<db:title>[since 6.1] qsizetype erase_if(QVarLengthArray&lt;T, Prealloc&gt; &amp;<db:emphasis>array</db:emphasis> = Prealloc, Predicate <db:emphasis>pred</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>qsizetype</db:type>
<db:methodname>erase_if</db:methodname>
<db:methodparam>
<db:type>QVarLengthArray&lt;T, Prealloc&gt; &amp;</db:type>
<db:parameter>array</db:parameter>
<db:initializer>Prealloc</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>Predicate</db:type>
<db:parameter>pred</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype erase_if(QVarLengthArray&lt;T, Prealloc&gt; &amp;array, Predicate pred)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes all elements for which the predicate <db:code role="parameter">pred</db:code> returns true from the list <db:code role="parameter">array</db:code>. Returns the number of elements removed, if any.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#erase">erase</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qHash">
<db:title>[since 5.14] size_t qHash(const QVarLengthArray&lt;T, Prealloc&gt; &amp;<db:emphasis>key</db:emphasis> = Prealloc, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc&gt; &amp;</db:type>
<db:parameter>key</db:parameter>
<db:initializer>Prealloc</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QVarLengthArray&lt;T, Prealloc&gt; &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-1">
<db:title>bool operator!=(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;<db:emphasis>left</db:emphasis> = Prealloc1, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;<db:emphasis>right</db:emphasis> = Prealloc2)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc1&gt; &amp;</db:type>
<db:parameter>left</db:parameter>
<db:initializer>Prealloc1</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc2&gt; &amp;</db:type>
<db:parameter>right</db:parameter>
<db:initializer>Prealloc2</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;left, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the two arrays, specified by <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code>, are <db:emphasis>not</db:emphasis> equal.</db:para>
<db:para>Two arrays are considered equal if they contain the same values in the same order.</db:para>
<db:para>This function requires the value type to have an implementation of operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#operator-eq-eq-1">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-1">
<db:title>[since 5.6] bool operator&lt;(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;<db:emphasis>lhs</db:emphasis> = Prealloc1, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;<db:emphasis>rhs</db:emphasis> = Prealloc2)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&lt;</db:methodname>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc1&gt; &amp;</db:type>
<db:parameter>lhs</db:parameter>
<db:initializer>Prealloc1</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc2&gt; &amp;</db:type>
<db:parameter>rhs</db:parameter>
<db:initializer>Prealloc2</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;lhs, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;rhs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if variable length array <db:code role="parameter">lhs</db:code> is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexicographically less than</db:link> <db:code role="parameter">rhs</db:code>; otherwise returns false.</db:para>
<db:para>This function requires the value type to have an implementation of operator&lt;().</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq-1">
<db:title>[since 5.6] bool operator&lt;=(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;<db:emphasis>lhs</db:emphasis> = Prealloc1, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;<db:emphasis>rhs</db:emphasis> = Prealloc2)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&lt;=</db:methodname>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc1&gt; &amp;</db:type>
<db:parameter>lhs</db:parameter>
<db:initializer>Prealloc1</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc2&gt; &amp;</db:type>
<db:parameter>rhs</db:parameter>
<db:initializer>Prealloc2</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;=(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;lhs, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;rhs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if variable length array <db:code role="parameter">lhs</db:code> is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexicographically less than or equal to</db:link> <db:code role="parameter">rhs</db:code>; otherwise returns false.</db:para>
<db:para>This function requires the value type to have an implementation of operator&lt;().</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-1">
<db:title>bool operator==(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;<db:emphasis>left</db:emphasis> = Prealloc1, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;<db:emphasis>right</db:emphasis> = Prealloc2)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc1&gt; &amp;</db:type>
<db:parameter>left</db:parameter>
<db:initializer>Prealloc1</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc2&gt; &amp;</db:type>
<db:parameter>right</db:parameter>
<db:initializer>Prealloc2</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;left, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the two arrays, specified by <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code>, are equal.</db:para>
<db:para>Two arrays are considered equal if they contain the same values in the same order.</db:para>
<db:para>This function requires the value type to have an implementation of operator==().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#operator-not-eq-1">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-1">
<db:title>[since 5.6] bool operator&gt;(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;<db:emphasis>lhs</db:emphasis> = Prealloc1, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;<db:emphasis>rhs</db:emphasis> = Prealloc2)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&gt;</db:methodname>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc1&gt; &amp;</db:type>
<db:parameter>lhs</db:parameter>
<db:initializer>Prealloc1</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc2&gt; &amp;</db:type>
<db:parameter>rhs</db:parameter>
<db:initializer>Prealloc2</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;lhs, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;rhs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if variable length array <db:code role="parameter">lhs</db:code> is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexicographically greater than</db:link> <db:code role="parameter">rhs</db:code>; otherwise returns false.</db:para>
<db:para>This function requires the value type to have an implementation of operator&lt;().</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-1">
<db:title>[since 5.6] bool operator&gt;=(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;<db:emphasis>lhs</db:emphasis> = Prealloc1, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;<db:emphasis>rhs</db:emphasis> = Prealloc2)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>operator&gt;=</db:methodname>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc1&gt; &amp;</db:type>
<db:parameter>lhs</db:parameter>
<db:initializer>Prealloc1</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QVarLengthArray&lt;T, Prealloc2&gt; &amp;</db:type>
<db:parameter>rhs</db:parameter>
<db:initializer>Prealloc2</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&gt;=(const QVarLengthArray&lt;T, Prealloc1&gt; &amp;lhs, const QVarLengthArray&lt;T, Prealloc2&gt; &amp;rhs)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if variable length array <db:code role="parameter">lhs</db:code> is <db:link xlink:href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">lexicographically greater than or equal to</db:link> <db:code role="parameter">rhs</db:code>; otherwise returns false.</db:para>
<db:para>This function requires the value type to have an implementation of operator&lt;().</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QVarLengthArray</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="prepend">
<db:title>void QVarLengthArray::prepend(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="prepend-1">void QVarLengthArray::prepend(const T &amp;<db:emphasis>value</db:emphasis>)</db:bridgehead>
<db:para>This function is deprecated since 6.3. We strongly advise against using it in new code.</db:para>
<db:para>This is slow. If you must, use insert(cbegin(), ~~~) instead.</db:para>
<db:para>Inserts <db:code role="parameter">value</db:code> at the beginning of the array.</db:para>
<db:para>This is the same as vector.insert(0, <db:code role="parameter">value</db:code>).</db:para>
<db:para>For large arrays, this operation can be slow (<db:link xlink:href="containers.xml#linear-time">linear time</db:link>), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast <db:link xlink:href="qvarlengtharray.xml#prepend">prepend</db:link>() function, use std::list instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvarlengtharray.xml#append">append</db:link>()</db:member>
<db:member><db:link xlink:href="qvarlengtharray.xml#insert">insert</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
