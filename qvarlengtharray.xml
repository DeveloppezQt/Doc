<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QVarLengthArray Class</db:title>
<db:subtitle>template &lt;typename T, int Prealloc = 256&gt; class QVarLengthArray</db:subtitle>
<db:productname>QtCore</db:productname>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> class provides a low-level variable-length array.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QVarLengthArray</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QVarLengthArray is part of <db:simplelist><db:member>tools</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The C++ language doesn't support variable-length arrays on the stack. For example, the following code won't compile:</db:para>
<db:programlisting language="cpp">int myfunc(int n)
{
    int table[n + 1];  // WRONG
    ...
    return table[n];
}
</db:programlisting>
<db:para>The alternative is to allocate the array on the heap (with <db:code>new</db:code>):</db:para>
<db:programlisting language="cpp">int myfunc(int n)
{
    int *table = new int[n + 1];
    ...
    int ret = table[n];
    delete[] table;
    return ret;
}
</db:programlisting>
<db:para>However, if myfunc() is called very frequently from the application's inner loop, heap allocation can be a major source of slowdown.</db:para>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> is an attempt to work around this gap in the C++ language. It allocates a certain number of elements on the stack, and if you resize the array to a larger size, it automatically uses the heap instead. Stack allocation has the advantage that it is much faster than heap allocation.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">int myfunc(int n)
{
    QVarLengthArray&lt;int, 1024&gt; array(n + 1);
    ...
    return array[n];
}
</db:programlisting>
<db:para>In the example above, <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> will preallocate 1024 elements on the stack and use them unless <db:code>n + 1</db:code> is greater than 1024. If you omit the second template argument, <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>'s default of 256 is used.</db:para>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>'s value type must be an <db:link xlink:href="containers.xml">assignable data type</db:link>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *.</db:para>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>, like <db:link xlink:href="qvector.xml">QVector</db:link>, provides a resizable array data structure. The main differences between the two classes are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>'s API is much more low-level. It provides no iterators and lacks much of <db:link xlink:href="qvector.xml">QVector</db:link>'s functionality.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> doesn't initialize the memory if the value is a basic type. (<db:link xlink:href="qvector.xml">QVector</db:link> always does.)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qvector.xml">QVector</db:link> uses <db:link xlink:href="implicit-sharing.xml">implicit sharing</db:link> as a memory optimization. <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> doesn't provide that feature; however, it usually produces slightly better performance due to reduced overhead, especially in tight loops.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In summary, <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link> is a low-level optimization class that only makes sense in very specific cases. It is used a few places inside Qt and was added to Qt's public API for the convenience of advanced users.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvector.xml">QVector</db:link></db:member>
<db:member><db:link xlink:href="qlist.xml">QList</db:link></db:member>
<db:member><db:link xlink:href="qlinkedlist.xml">QLinkedList</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="const_iterator-typedef">
<db:title>[since 4.7] QVarLengthArray::const_iterator</db:title>
<db:para>Typedef for const T *. Provided for STL compatibility.</db:para>
<db:para>This typedef was introduced in Qt 4.7.</db:para>
</db:section>
<db:section xml:id="const_pointer-typedef">
<db:title>[since 4.7] QVarLengthArray::const_pointer</db:title>
<db:para>Typedef for const T *. Provided for STL compatibility.</db:para>
<db:para>This typedef was introduced in Qt 4.7.</db:para>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>[since 4.7] QVarLengthArray::const_reference</db:title>
<db:para>Typedef for const T &amp;. Provided for STL compatibility.</db:para>
<db:para>This typedef was introduced in Qt 4.7.</db:para>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>[since 4.7] QVarLengthArray::difference_type</db:title>
<db:para>Typedef for ptrdiff_t. Provided for STL compatibility.</db:para>
<db:para>This typedef was introduced in Qt 4.7.</db:para>
</db:section>
<db:section xml:id="iterator-typedef">
<db:title>[since 4.7] QVarLengthArray::iterator</db:title>
<db:para>Typedef for T *. Provided for STL compatibility.</db:para>
<db:para>This typedef was introduced in Qt 4.7.</db:para>
</db:section>
<db:section xml:id="pointer-typedef">
<db:title>[since 4.7] QVarLengthArray::pointer</db:title>
<db:para>Typedef for T *. Provided for STL compatibility.</db:para>
<db:para>This typedef was introduced in Qt 4.7.</db:para>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>[since 4.7] QVarLengthArray::reference</db:title>
<db:para>Typedef for T &amp;. Provided for STL compatibility.</db:para>
<db:para>This typedef was introduced in Qt 4.7.</db:para>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>[since 4.7] QVarLengthArray::size_type</db:title>
<db:para>Typedef for int. Provided for STL compatibility.</db:para>
<db:para>This typedef was introduced in Qt 4.7.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>[since 4.7] QVarLengthArray::value_type</db:title>
<db:para>Typedef for T. Provided for STL compatibility.</db:para>
<db:para>This typedef was introduced in Qt 4.7.</db:para>
</db:section>
</db:section>
</db:article>
