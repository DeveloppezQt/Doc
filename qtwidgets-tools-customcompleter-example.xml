<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Custom Completer Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.13.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Custom Completer example shows how to provide string-completion facilities for an input widget based on data provided by a model. The completer pops up suggestions for possible words based on the first three characters input by the user and the user's choice of word is inserted into the <db:code>TextEdit</db:code> using QTextCursor.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customcompleter-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="setting-up-the-resource-file">
<db:title>Setting Up The Resource File</db:title>
<db:para>The Custom Completer example requires a resource file, <db:emphasis>wordlist.txt</db:emphasis>, that has a list of words to help QCompleter complete words. This file contains the following:</db:para>
<db:programlisting language="cpp">&amp;lt;!DOCTYPE RCC&amp;gt;&amp;lt;RCC version=&quot;1.0&quot;&amp;gt;
&amp;lt;qresource prefix=&quot;/&quot;&amp;gt;
   &amp;lt;file&amp;gt;resources/wordlist.txt&amp;lt;/file&amp;gt;
&amp;lt;/qresource&amp;gt;
&amp;lt;/RCC&amp;gt;
</db:programlisting>
</db:section>
<db:section xml:id="textedit-class-definition">
<db:title>TextEdit Class Definition</db:title>
<db:para>The <db:code>TextEdit</db:code> class is a subclass of QTextEdit with a custom <db:code>insertCompletion()</db:code> slot and it reimplements the <db:link xlink:href="">keyPressEvent()</db:link> and the <db:link xlink:href="">focusInEvent()</db:link> functions. <db:code>TextEdit</db:code> also contains a private function <db:code>textUnderCursor()</db:code> and a private instance of QCompleter, <db:code>c</db:code>.</db:para>
<db:programlisting language="cpp">class TextEdit : public QTextEdit
{
    Q_OBJECT

public:
    TextEdit(QWidget *parent = 0);
    ~TextEdit();

    void setCompleter(QCompleter *c);
    QCompleter *completer() const;

protected:
    void keyPressEvent(QKeyEvent *e) override;
    void focusInEvent(QFocusEvent *e) override;

private slots:
    void insertCompletion(const QString &amp;amp;completion);

private:
    QString textUnderCursor() const;

private:
    QCompleter *c;
};
</db:programlisting>
</db:section>
<db:section xml:id="textedit-class-implementation">
<db:title>TextEdit Class Implementation</db:title>
<db:para>The constructor for <db:code>TextEdit</db:code> constructs a <db:code>TextEdit</db:code> with a parent and initializes <db:code>c</db:code>. The instructions to use the completer is displayed on the <db:code>TextEdit</db:code> object, using the <db:link xlink:href="">setPlainText()</db:link> function.</db:para>
<db:programlisting language="cpp">TextEdit::TextEdit(QWidget *parent)
: QTextEdit(parent), c(0)
{
    setPlainText(tr(&quot;This TextEdit provides autocompletions for words that have more than&quot;
                    &quot; 3 characters. You can trigger autocompletion using &quot;) +
                    QKeySequence(&quot;Ctrl+E&quot;).toString(QKeySequence::NativeText));
}
</db:programlisting>
<db:para>In addition, <db:code>TextEdit</db:code> also includes a default destructor:</db:para>
<db:programlisting language="cpp">TextEdit::~TextEdit()
{
}
</db:programlisting>
<db:para>The <db:code>setCompleter()</db:code> function accepts a <db:code role="parameter">completer</db:code> and sets it up. We use <db:code>if (c)</db:code> to check if <db:code>c</db:code> has been initialized. If it has been initialized, the QObject::disconnect() function is invoked to disconnect the signal from the slot. This is to ensure that no previous completer object is still connected to the slot.</db:para>
<db:programlisting language="cpp">void TextEdit::setCompleter(QCompleter *completer)
{
    if (c)
        QObject::disconnect(c, 0, this, 0);

    c = completer;

    if (!c)
        return;

    c-&amp;gt;setWidget(this);
    c-&amp;gt;setCompletionMode(QCompleter::PopupCompletion);
    c-&amp;gt;setCaseSensitivity(Qt::CaseInsensitive);
    QObject::connect(c, QOverload&amp;lt;const QString &amp;amp;&amp;gt;::of(&amp;amp;QCompleter::activated),
                     this, &amp;amp;TextEdit::insertCompletion);
}
</db:programlisting>
<db:para>We then instantiate <db:code>c</db:code> with <db:code role="parameter">completer</db:code> and set it as <db:code>TextEdit</db:code>'s widget. The completion mode and case sensitivity are also set and then we connect the <db:link xlink:href="">activated()</db:link> signal to the <db:code>insertCompletion()</db:code> slot.</db:para>
<db:para>The <db:code>completer()</db:code> function is a getter function that returns <db:code>c</db:code>.</db:para>
<db:programlisting language="cpp">QCompleter *TextEdit::completer() const
{
    return c;
}
</db:programlisting>
<db:para>The completer pops up the options available, based on the contents of <db:emphasis>wordlist.txt</db:emphasis>, but the text cursor is responsible for filling in the missing characters, according to the user's choice of word.</db:para>
<db:para>Suppose the user inputs &quot;ACT&quot; and accepts the completer's suggestion of &quot;ACTUAL&quot;. The <db:code>completion</db:code> string is then sent to <db:code>insertCompletion()</db:code> by the completer's <db:link xlink:href="">activated()</db:link> signal.</db:para>
<db:para>The <db:code>insertCompletion()</db:code> function is responsible for completing the word using a QTextCursor object, <db:code>tc</db:code>. It validates to ensure that the completer's widget is <db:code>TextEdit</db:code> before using <db:code>tc</db:code> to insert the extra characters to complete the word.</db:para>
<db:programlisting language="cpp">void TextEdit::insertCompletion(const QString&amp;amp; completion)
{
    if (c-&amp;gt;widget() != this)
        return;
    QTextCursor tc = textCursor();
    int extra = completion.length() - c-&amp;gt;completionPrefix().length();
    tc.movePosition(QTextCursor::Left);
    tc.movePosition(QTextCursor::EndOfWord);
    tc.insertText(completion.right(extra));
    setTextCursor(tc);
}
</db:programlisting>
<db:para>The figure below illustrates this process:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customcompleter-insertcompletion.png"/>
</db:imageobject>
</db:mediaobject>
<db:para><db:code>completion.length()</db:code> = 6</db:para>
<db:para><db:code>c-&gt;completionPrefix().length()</db:code>=3</db:para>
<db:para>The difference between these two values is <db:code>extra</db:code>, which is 3. This means that the last three characters from the right, &quot;U&quot;, &quot;A&quot;, and &quot;L&quot;, will be inserted by <db:code>tc</db:code>.</db:para>
<db:para>The <db:code>textUnderCursor()</db:code> function uses a QTextCursor, <db:code>tc</db:code>, to select a word under the cursor and return it.</db:para>
<db:programlisting language="cpp">QString TextEdit::textUnderCursor() const
{
    QTextCursor tc = textCursor();
    tc.select(QTextCursor::WordUnderCursor);
    return tc.selectedText();
}
</db:programlisting>
<db:para>The <db:code>TextEdit</db:code> class reimplements <db:link xlink:href="">focusInEvent()</db:link> function, which is an event handler used to receive keyboard focus events for the widget.</db:para>
<db:programlisting language="cpp">void TextEdit::focusInEvent(QFocusEvent *e)
{
    if (c)
        c-&amp;gt;setWidget(this);
    QTextEdit::focusInEvent(e);
}
</db:programlisting>
<db:para>The <db:link xlink:href="">keyPressEvent()</db:link> is reimplemented to ignore key events like Qt::Key_Enter, Qt::Key_Return, Qt::Key_Escape, Qt::Key_Tab, and Qt::Key_Backtab so the completer can handle them.</db:para>
<db:para>If there is an active completer, we cannot process the shortcut, Ctrl+E.</db:para>
<db:programlisting language="cpp">void TextEdit::keyPressEvent(QKeyEvent *e)
{
    if (c &amp;amp;&amp;amp; c-&amp;gt;popup()-&amp;gt;isVisible()) {
        // The following keys are forwarded by the completer to the widget
       switch (e-&amp;gt;key()) {
       case Qt::Key_Enter:
       case Qt::Key_Return:
       case Qt::Key_Escape:
       case Qt::Key_Tab:
       case Qt::Key_Backtab:
            e-&amp;gt;ignore();
            return; // let the completer do default behavior
       default:
           break;
       }
    }

    bool isShortcut = ((e-&amp;gt;modifiers() &amp;amp; Qt::ControlModifier) &amp;amp;&amp;amp; e-&amp;gt;key() == Qt::Key_E); // CTRL+E
    if (!c || !isShortcut) // do not process the shortcut when we have a completer
        QTextEdit::keyPressEvent(e);
</db:programlisting>
<db:para>We also handle other modifiers and shortcuts for which we do not want the completer to respond to.</db:para>
<db:programlisting language="cpp">    const bool ctrlOrShift = e-&amp;gt;modifiers() &amp;amp; (Qt::ControlModifier | Qt::ShiftModifier);
    if (!c || (ctrlOrShift &amp;amp;&amp;amp; e-&amp;gt;text().isEmpty()))
        return;

    static QString eow(&quot;~!@#$%^&amp;amp;*()_+{}|:\&quot;&amp;lt;&amp;gt;?,./;'[]\\-=&quot;); // end of word
    bool hasModifier = (e-&amp;gt;modifiers() != Qt::NoModifier) &amp;amp;&amp;amp; !ctrlOrShift;
    QString completionPrefix = textUnderCursor();

    if (!isShortcut &amp;amp;&amp;amp; (hasModifier || e-&amp;gt;text().isEmpty()|| completionPrefix.length() &amp;lt; 3
                      || eow.contains(e-&amp;gt;text().right(1)))) {
        c-&amp;gt;popup()-&amp;gt;hide();
        return;
    }

    if (completionPrefix != c-&amp;gt;completionPrefix()) {
        c-&amp;gt;setCompletionPrefix(completionPrefix);
        c-&amp;gt;popup()-&amp;gt;setCurrentIndex(c-&amp;gt;completionModel()-&amp;gt;index(0, 0));
    }
    QRect cr = cursorRect();
    cr.setWidth(c-&amp;gt;popup()-&amp;gt;sizeHintForColumn(0)
                + c-&amp;gt;popup()-&amp;gt;verticalScrollBar()-&amp;gt;sizeHint().width());
    c-&amp;gt;complete(cr); // popup it up!
}
</db:programlisting>
<db:para>Finally, we pop up the completer.</db:para>
</db:section>
<db:section xml:id="mainwindow-class-definition">
<db:title>MainWindow Class Definition</db:title>
<db:para>The <db:code>MainWindow</db:code> class is a subclass of QMainWindow and implements a private slot, <db:code>about()</db:code>. This class also has two private functions, <db:code>createMenu()</db:code> and <db:code>modelFromFile()</db:code> as well as private instances of QCompleter and <db:code>TextEdit</db:code>.</db:para>
<db:programlisting language="cpp">class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = 0);

private slots:
    void about();

private:
    void createMenu();
    QAbstractItemModel *modelFromFile(const QString&amp;amp; fileName);

    QCompleter *completer;
    TextEdit *completingTextEdit;
};
</db:programlisting>
</db:section>
<db:section xml:id="mainwindow-class-implementation">
<db:title>MainWindow Class Implementation</db:title>
<db:para>The constructor constructs a <db:code>MainWindow</db:code> with a parent and initializes the <db:code>completer</db:code>. It also instantiates a <db:code>TextEdit</db:code> and sets its completer. A QStringListModel, obtained from <db:code>modelFromFile()</db:code>, is used to populate the <db:code>completer</db:code>. The <db:code>MainWindow</db:code>'s central widget is set to <db:code>TextEdit</db:code> and its size is set to 500 x 300.</db:para>
<db:programlisting language="cpp">MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), completer(0)
{
    createMenu();

    completingTextEdit = new TextEdit;
    completer = new QCompleter(this);
    completer-&amp;gt;setModel(modelFromFile(&quot;:/resources/wordlist.txt&quot;));
    completer-&amp;gt;setModelSorting(QCompleter::CaseInsensitivelySortedModel);
    completer-&amp;gt;setCaseSensitivity(Qt::CaseInsensitive);
    completer-&amp;gt;setWrapAround(false);
    completingTextEdit-&amp;gt;setCompleter(completer);

    setCentralWidget(completingTextEdit);
    resize(500, 300);
    setWindowTitle(tr(&quot;Completer&quot;));
}
</db:programlisting>
<db:para>The <db:code>createMenu()</db:code> function creates the necessary QAction objects needed for the &quot;File&quot; and &quot;Help&quot; menu and their <db:link xlink:href="">triggered()</db:link> signals are connected to the <db:code>quit()</db:code>, <db:code>about()</db:code>, and <db:code>aboutQt()</db:code> slots respectively.</db:para>
<db:programlisting language="cpp">void MainWindow::createMenu()
{
    QAction *exitAction = new QAction(tr(&quot;Exit&quot;), this);
    QAction *aboutAct = new QAction(tr(&quot;About&quot;), this);
    QAction *aboutQtAct = new QAction(tr(&quot;About Qt&quot;), this);

    connect(exitAction, &amp;amp;QAction::triggered, qApp, &amp;amp;QApplication::quit);
    connect(aboutAct, &amp;amp;QAction::triggered, this, &amp;amp;MainWindow::about);
    connect(aboutQtAct, &amp;amp;QAction::triggered, qApp, &amp;amp;QApplication::aboutQt);

    QMenu* fileMenu = menuBar()-&amp;gt;addMenu(tr(&quot;File&quot;));
    fileMenu-&amp;gt;addAction(exitAction);

    QMenu* helpMenu = menuBar()-&amp;gt;addMenu(tr(&quot;About&quot;));
    helpMenu-&amp;gt;addAction(aboutAct);
    helpMenu-&amp;gt;addAction(aboutQtAct);
}
</db:programlisting>
<db:para>The <db:code>modelFromFile()</db:code> function accepts a <db:code role="parameter">fileName</db:code> and attempts to extract the contents of this file into a QStringListModel. We display the Qt::WaitCursor when we are populating the <db:link xlink:href="qstringlist.xml">QStringList</db:link>, <db:code>words</db:code>, and restore the mouse cursor when we are done.</db:para>
<db:programlisting language="cpp">QAbstractItemModel *MainWindow::modelFromFile(const QString&amp;amp; fileName)
{
    QFile file(fileName);
    if (!file.open(QFile::ReadOnly))
        return new QStringListModel(completer);

#ifndef QT_NO_CURSOR
    QGuiApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
#endif
    QStringList words;

    while (!file.atEnd()) {
        QByteArray line = file.readLine();
        if (!line.isEmpty())
            words &amp;lt;&amp;lt; line.trimmed();
    }

#ifndef QT_NO_CURSOR
    QGuiApplication::restoreOverrideCursor();
#endif
    return new QStringListModel(words, completer);
}
</db:programlisting>
<db:para>The <db:code>about()</db:code> function provides a brief description about the Custom Completer example.</db:para>
<db:programlisting language="cpp">void MainWindow::about()
{
    QMessageBox::about(this, tr(&quot;About&quot;), tr(&quot;This example demonstrates the &quot;
        &quot;different features of the QCompleter class.&quot;));
}
</db:programlisting>
</db:section>
<db:section xml:id="main-function">
<db:title><db:code>main()</db:code> Function</db:title>
<db:para>The <db:code>main()</db:code> function instantiates <db:code>MainWindow</db:code> and invokes the <db:link xlink:href="">show()</db:link> function.</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    Q_INIT_RESOURCE(customcompleter);

    QApplication app(argc, argv);
    MainWindow window;
    window.show();
    return app.exec();
}
</db:programlisting>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/tools/customcompleter?h=5.13">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
