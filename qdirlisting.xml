<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QDirListing Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qdirlisting.xml">QDirListing</db:link> class provides an STL-style iterator for directory entries.</db:para>
<db:para>This class was introduced in Qt 6.8.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QDirListing</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.8</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QDirListing is part of <db:simplelist><db:member><db:link xlink:href="io.xml">Input/Output and Networking</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>You can use <db:link xlink:href="qdirlisting.xml">QDirListing</db:link> to navigate entries of a directory one at a time. It is similar to <db:link xlink:href="qdir.xml#entryList">QDir::entryList</db:link>() and <db:link xlink:href="qdir.xml#entryInfoList">QDir::entryInfoList</db:link>(), but because it lists entries one at a time instead of all at once, it scales better and is more suitable for large directories. It also supports listing directory contents recursively, and following symbolic links. Unlike <db:link xlink:href="qdir.xml#entryList">QDir::entryList</db:link>(), <db:link xlink:href="qdirlisting.xml">QDirListing</db:link> does not support sorting.</db:para>
<db:para>The <db:link xlink:href="qdirlisting.xml">QDirListing</db:link> constructor takes a directory path string as argument. Here's how to iterate over all entries recursively:</db:para>
<db:programlisting language="cpp">using ItFlag = QDirListing::IteratorFlag;
for (const auto &amp;dirEntry : QDirListing(u&quot;/etc&quot;_s, ItFlag::Recursive)) {
    qDebug() &lt;&lt; dirEntry.filePath();
    // /etc/.
    // /etc/..
    // /etc/X11
    // /etc/X11/fs
    // ...
}
</db:programlisting>
<db:para>Here's how to find and read all regular files filtered by name, recursively:</db:para>
<db:programlisting language="cpp">using F = QDirListing::IteratorFlag;
QDirListing dirList(u&quot;/sys&quot;_s, QStringList{u&quot;scaling_cur_freq&quot;_s}, F::FilesOnly | F::Recursive);
for (const auto &amp;dirEntry : dirList) {
    QFile f(dirEntry.filePath());
    if (f.open(QIODevice::ReadOnly))
        qDebug() &lt;&lt; f.fileName() &lt;&lt; f.readAll().trimmed().toDouble() / 1000 &lt;&lt; &quot;MHz&quot;;
}
</db:programlisting>
<db:para>Here's how to list only regular files, recursively:</db:para>
<db:programlisting language="cpp">using F = QDirListing::IteratorFlag;
const auto flags = F::FilesOnly | F::Recursive;
for (const auto &amp;dirEntry : QDirListing(u&quot;/etc&quot;_s, flags)) {
    // ...
}
</db:programlisting>
<db:para>Here's how to list only regular files and symbolic links to regular files, recursively:</db:para>
<db:programlisting language="cpp">using F = QDirListing::IteratorFlag;
const auto flags = F::FilesOnly | F::Recursive | F::ResolveSymlinks;
for (const auto &amp;dirEntry : QDirListing(u&quot;/etc&quot;_s, flags)) {
    // ...
}
</db:programlisting>
<db:para><db:link xlink:href="qdirlisting-const-iterator.xml">QDirListing::const_iterator</db:link> models C++20 <db:link xlink:href="https://en.cppreference.com/w/cpp/iterator/input_iterator">std::input_iterator</db:link>, that is, it is a move-only, forward-only, single-pass iterator, that doesn't allow random access. It can be used in ranged-for loops (or with C++20 range algorithms that don't require random access iterators). Dereferencing a valid iterator returns a <db:link xlink:href="qdirlisting-direntry.xml">QDirListing::DirEntry</db:link> object. The (c)<db:link xlink:href="qdirlisting.xml#end">end</db:link>() sentinel marks the end of the iteration. Dereferencing an iterator that is equal to <db:link xlink:href="qdirlisting-sentinel.xml">sentinel</db:link> is undefined behavior.</db:para>
<db:para><db:link xlink:href="qdirlisting-direntry.xml">QDirListing::DirEntry</db:link> offers a subset of <db:link xlink:href="qfileinfo.xml">QFileInfo</db:link>'s API (for example, fileName(), filePath(), exists()). Internally, <db:link xlink:href="qdirlisting-direntry.xml">DirEntry</db:link> only constructs a <db:link xlink:href="qfileinfo.xml">QFileInfo</db:link> object if needed, that is, if the info hasn't been already fetched by other system functions. You can use <db:link xlink:href="qdirlisting-direntry.xml#fileInfo">DirEntry::fileInfo</db:link>() to get a <db:link xlink:href="qfileinfo.xml">QFileInfo</db:link>. For example:</db:para>
<db:programlisting language="cpp">using ItFlag = QDirListing::IteratorFlag;
for (const auto &amp;dirEntry : QDirListing(u&quot;/etc&quot;_s, ItFlag::Recursive)) {
    // Faster
    if (dirEntry.fileName().endsWith(u&quot;.conf&quot;)) { /* ... */ }

    // This works, but might be potentially slower, since it has to construct a
    // QFileInfo, whereas (depending on the implementation) the fileName could
    // be known already
    if (dirEntry.fileInfo().fileName().endsWith(u&quot;.conf&quot;)) { /* ... */ }
}
using ItFlag = QDirListing::IteratorFlag;
for (const auto &amp;dirEntry : QDirListing(u&quot;/etc&quot;_s, ItFlag::Recursive)) {
    // Both approaches are the same, because DirEntry will have to construct
    // a QFileInfo to get this info (for example, by calling system stat())

    if (dirEntry.size() &gt;= 4'000 /* 4KB */) { /* ...*/ }
    if (dirEntry.fileInfo().size() &gt;= 4'000 /* 4KB */) { /* ... */ }
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdir.xml">QDir</db:link></db:member>
<db:member><db:link xlink:href="qdir.xml#entryList">QDir::entryList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="IteratorFlag-enum">
<db:title>enum QDirListing::IteratorFlag</db:title>
<db:bridgehead renderas="sect2">flags QDirListing::IteratorFlags</db:bridgehead>
<db:para>This enum class describes flags that can be used to configure the behavior of <db:link xlink:href="qdirlisting.xml">QDirListing</db:link>. Values from this enumerator can be bitwise OR'ed together.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdirlisting.xml">QDirListing</db:link></db:emphasis>::<db:emphasis role="bold">IteratorFlag</db:emphasis>::Default</db:code></db:para>
</db:td>
<db:td><db:code>0x000000</db:code></db:td>
<db:td>
<db:para>List all files, directories and symbolic links, including broken symlinks (where the target doesn't exist). Hidden files and directories and the special entries . and .. aren't listed by default.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdirlisting.xml">QDirListing</db:link></db:emphasis>::<db:emphasis role="bold">IteratorFlag</db:emphasis>::ExcludeFiles</db:code></db:para>
</db:td>
<db:td><db:code>0x000004</db:code></db:td>
<db:td>
<db:para>Don't list regular files. When combined with ResolveSymlinks, symbolic links to regular files will be excluded too.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdirlisting.xml">QDirListing</db:link></db:emphasis>::<db:emphasis role="bold">IteratorFlag</db:emphasis>::ExcludeDirs</db:code></db:para>
</db:td>
<db:td><db:code>0x000008</db:code></db:td>
<db:td>
<db:para>Don't list directories. When combined with ResolveSymlinks, symbolic links to directories will be excluded too.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdirlisting.xml">QDirListing</db:link></db:emphasis>::<db:emphasis role="bold">IteratorFlag</db:emphasis>::ExcludeSpecial</db:code></db:para>
</db:td>
<db:td><db:code>0x000010</db:code></db:td>
<db:td>
<db:para>Don't list file system entries that are <db:emphasis>not</db:emphasis> directories, regular files, nor symbolic links.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>On Unix, an example of a special file system entry is a FIFO, socket, character device, or block device. For more details on Linux, see the <db:link xlink:href="https://www.man7.org/linux/man-pages/man2/mknod.2.html">mknod manual page</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>On Windows (for historical reasons) .lnk files are considered special file system entries.</db:para>
</db:listitem>
</db:itemizedlist>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdirlisting.xml">QDirListing</db:link></db:emphasis>::<db:emphasis role="bold">IteratorFlag</db:emphasis>::ResolveSymlinks</db:code></db:para>
</db:td>
<db:td><db:code>0x000020</db:code></db:td>
<db:td>
<db:para>Filter symbolic links based on the type of the target of the link, rather than the symbolic link itself. With this flag, broken symbolic links (where the target doesn't exist) are excluded. This flag is ignored on operating systems that don't support symbolic links.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdirlisting.xml">QDirListing</db:link></db:emphasis>::<db:emphasis role="bold">IteratorFlag</db:emphasis>::FilesOnly</db:code></db:para>
</db:td>
<db:td><db:code>ExcludeDirs  | ExcludeSpecial</db:code></db:td>
<db:td>
<db:para>Only regular files will be listed. When combined with ResolveSymlinks, symbolic links to files will also be listed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdirlisting.xml">QDirListing</db:link></db:emphasis>::<db:emphasis role="bold">IteratorFlag</db:emphasis>::DirsOnly</db:code></db:para>
</db:td>
<db:td><db:code>ExcludeFiles | ExcludeSpecial</db:code></db:td>
<db:td>
<db:para>Only directories will be listed. When combined with ResolveSymlinks, symbolic links to directories will also be listed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdirlisting.xml">QDirListing</db:link></db:emphasis>::<db:emphasis role="bold">IteratorFlag</db:emphasis>::IncludeHidden</db:code></db:para>
</db:td>
<db:td><db:code>0x000040</db:code></db:td>
<db:td>
<db:para>List hidden entries. When combined with Recursive, the iteration will recurse into hidden sub-directories as well.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdirlisting.xml">QDirListing</db:link></db:emphasis>::<db:emphasis role="bold">IteratorFlag</db:emphasis>::IncludeDotAndDotDot</db:code></db:para>
</db:td>
<db:td><db:code>0x000080</db:code></db:td>
<db:td>
<db:para>List the . and .. special entries.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdirlisting.xml">QDirListing</db:link></db:emphasis>::<db:emphasis role="bold">IteratorFlag</db:emphasis>::CaseSensitive</db:code></db:para>
</db:td>
<db:td><db:code>0x000100</db:code></db:td>
<db:td>
<db:para>The file glob patterns in the name filters passed to the <db:link xlink:href="qdirlisting.xml">QDirListing</db:link> constructor, will be matched case sensitively (for details, see <db:link xlink:href="qdir.xml#setNameFilters">QDir::setNameFilters</db:link>()).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdirlisting.xml">QDirListing</db:link></db:emphasis>::<db:emphasis role="bold">IteratorFlag</db:emphasis>::Recursive</db:code></db:para>
</db:td>
<db:td><db:code>0x000400</db:code></db:td>
<db:td>
<db:para>List entries inside all sub-directories as well. When combined with FollowDirSymlinks, symbolic links to directories will be iterated too.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qdirlisting.xml">QDirListing</db:link></db:emphasis>::<db:emphasis role="bold">IteratorFlag</db:emphasis>::FollowDirSymlinks</db:code></db:para>
</db:td>
<db:td><db:code>0x000800</db:code></db:td>
<db:td>
<db:para>When combined with Recursive, symbolic links to directories will be iterated too. Symbolic link loops (e.g., link =&gt; . or link =&gt; ..) are automatically detected and ignored.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>IteratorFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;IteratorFlag&gt;. </db:code>It stores an OR combination of <db:code>IteratorFlag</db:code> values.</db:para>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="begin">
<db:title>QDirListing::const_iterator QDirListing::begin() const</db:title>
<db:bridgehead renderas="sect2" xml:id="cbegin">QDirListing::const_iterator QDirListing::cbegin() const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="cend">QDirListing::sentinel QDirListing::cend() const</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="end">QDirListing::sentinel QDirListing::end() const</db:bridgehead>
<db:para>(c)<db:link xlink:href="qdirlisting.xml#begin">begin</db:link>() returns a <db:link xlink:href="qdirlisting-const-iterator.xml">QDirListing::const_iterator</db:link> that can be used to iterate over directory entries.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>This is a forward-only, single-pass iterator (you cannot iterate directory entries in reverse order)</db:para>
</db:listitem>
<db:listitem>
<db:para>Can't be copied, only std::move()d.</db:para>
</db:listitem>
<db:listitem>
<db:para> The return value of post-increment on objects that model std::input_iterator is partially-formed (a copy of an iterator that has since been advanced), the only valid operations on such an object are destruction and assignment of a new iterator. Therefore the post-increment operator advances the iterator and returns void.</db:para>
</db:listitem>
<db:listitem>
<db:para>Doesn't allow random access</db:para>
</db:listitem>
<db:listitem>
<db:para>Can be used in ranged-for loops; or with C++20 std::ranges algorithms that don't require random access iterators</db:para>
</db:listitem>
<db:listitem>
<db:para>Dereferencing a valid iterator returns a const DirEntry &amp;</db:para>
</db:listitem>
<db:listitem>
<db:para>(c)<db:link xlink:href="qdirlisting.xml#end">end</db:link>() returns a <db:link xlink:href="qdirlisting-sentinel.xml">QDirListing::sentinel</db:link> that signals the end of the iteration. Dereferencing an iterator that compares equal to <db:link xlink:href="qdirlisting.xml#end">end</db:link>() is undefined behavior</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para>Each time (c)<db:link xlink:href="qdirlisting.xml#begin">begin</db:link>() is called on the same <db:link xlink:href="qdirlisting.xml">QDirListing</db:link> object, the internal state is reset and the iteration starts anew.</db:para>
</db:note>
<db:para>(Some of the above restrictions are dictated by the underlying system library functions' implementation).</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">using ItFlag = QDirListing::IteratorFlag;
for (const auto &amp;dirEntry : QDirListing(u&quot;/etc&quot;_s, ItFlag::Recursive)) {
    qDebug() &lt;&lt; dirEntry.filePath();
    // /etc/.
    // /etc/..
    // /etc/X11
    // /etc/X11/fs
    // ...
}
</db:programlisting>
<db:para>Here's how to find and read all files filtered by name, recursively:</db:para>
<db:programlisting language="cpp">using F = QDirListing::IteratorFlag;
QDirListing dirList(u&quot;/sys&quot;_s, QStringList{u&quot;scaling_cur_freq&quot;_s}, F::FilesOnly | F::Recursive);
for (const auto &amp;dirEntry : dirList) {
    QFile f(dirEntry.filePath());
    if (f.open(QIODevice::ReadOnly))
        qDebug() &lt;&lt; f.fileName() &lt;&lt; f.readAll().trimmed().toDouble() / 1000 &lt;&lt; &quot;MHz&quot;;
}
</db:programlisting>
<db:note>
<db:para>The &quot;classical&quot; STL algorithms don't support iterator/sentinel, so you need to use C++20 std::ranges algorithms for <db:link xlink:href="qdirlisting.xml">QDirListing</db:link>, or else a 3rd-party library that provides range-based algorithms in C++17.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdirlisting-direntry.xml">QDirListing::DirEntry</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QDirListing-1">
<db:title>[explicit] QDirListing::QDirListing(const QString &amp;<db:emphasis>path</db:emphasis>, QDirListing::IteratorFlags <db:emphasis>flags</db:emphasis> = IteratorFlag::Default)</db:title>
<db:para>Constructs a <db:link xlink:href="qdirlisting.xml">QDirListing</db:link> that can iterate over <db:code role="parameter">path</db:code>.</db:para>
<db:para>You can pass options via <db:code role="parameter">flags</db:code> to control how the directory should be iterated.</db:para>
<db:para>By default, <db:code role="parameter">flags</db:code> is <db:link xlink:href="qdirlisting.xml#IteratorFlag-enum">IteratorFlag::Default</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdirlisting.xml#IteratorFlag-enum">IteratorFlags</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QDirListing-2">
<db:title>[explicit] QDirListing::QDirListing(const QString &amp;<db:emphasis>path</db:emphasis>, const QStringList &amp;<db:emphasis>nameFilters</db:emphasis>, QDirListing::IteratorFlags <db:emphasis>flags</db:emphasis> = IteratorFlag::Default)</db:title>
<db:para>Constructs a <db:link xlink:href="qdirlisting.xml">QDirListing</db:link> that can iterate over <db:code role="parameter">path</db:code>.</db:para>
<db:para>You can pass options via <db:code role="parameter">flags</db:code> to control how the directory should be iterated. By default, <db:code role="parameter">flags</db:code> is <db:link xlink:href="qdirlisting.xml#IteratorFlag-enum">IteratorFlag::Default</db:link>.</db:para>
<db:para>The listed entries will be filtered according to the file glob patterns in <db:code role="parameter">nameFilters</db:code> (see <db:link xlink:href="qdir.xml#setNameFilters">QDir::setNameFilters</db:link>() for more details).</db:para>
<db:para>For example, the following iterator could be used to iterate over audio files:</db:para>
<db:programlisting language="cpp">QDirListing audioFileIt(u&quot;/home/johndoe/&quot;_s, QStringList{u&quot;*.mp3&quot;_s, u&quot;*.wav&quot;_s},
                        QDirListing::IteratorFlag::FilesOnly);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qdirlisting.xml#IteratorFlag-enum">IteratorFlags</db:link></db:member>
<db:member><db:link xlink:href="qdir.xml#setNameFilters">QDir::setNameFilters</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QDirListing">
<db:title>[noexcept] QDirListing::QDirListing(QDirListing &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move constructor. Moves <db:code role="parameter">other</db:code> into this <db:link xlink:href="qdirlisting.xml">QDirListing</db:link>.</db:para>
<db:note>
<db:para>The moved-from object <db:code role="parameter">other</db:code> is placed in a partially-formed state, in which the only valid operations are destruction and assignment of a new value.</db:para>
</db:note>
</db:section>
<db:section xml:id="dtor.QDirListing">
<db:title>[noexcept] QDirListing::~QDirListing()</db:title>
<db:para>Destroys the <db:link xlink:href="qdirlisting.xml">QDirListing</db:link>.</db:para>
</db:section>
<db:section xml:id="iteratorFlags">
<db:title>QDirListing::IteratorFlags QDirListing::iteratorFlags() const</db:title>
<db:para>Returns the set of <db:link xlink:href="qdirlisting.xml#IteratorFlag-enum">IteratorFlags</db:link> used to construct this <db:link xlink:href="qdirlisting.xml">QDirListing</db:link>.</db:para>
</db:section>
<db:section xml:id="iteratorPath">
<db:title>QString QDirListing::iteratorPath() const</db:title>
<db:para>Returns the directory path used to construct this <db:link xlink:href="qdirlisting.xml">QDirListing</db:link>.</db:para>
</db:section>
<db:section xml:id="nameFilters">
<db:title>QStringList QDirListing::nameFilters() const</db:title>
<db:para>Returns the list of file name glob filters used to construct this <db:link xlink:href="qdirlisting.xml">QDirListing</db:link>.</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>[noexcept] QDirListing &amp;QDirListing::operator=(QDirListing &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Move-assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qdirlisting.xml">QDirListing</db:link>.</db:para>
<db:note>
<db:para>The moved-from object <db:code role="parameter">other</db:code> is placed in a partially-formed state, in which the only valid operations are destruction and assignment of a new value.</db:para>
</db:note>
</db:section>
</db:section>
</db:section></db:article>
