<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSensor Class</db:title>
<db:productname>QtSensors</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Sensors Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsensor.xml">QSensor</db:link> class represents a single hardware sensor.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSensor</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Sensors)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Sensors)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += sensors</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qaccelerometer.xml" xlink:role="class">QAccelerometer</db:link>, <db:link xlink:href="qambientlightsensor.xml" xlink:role="class">QAmbientLightSensor</db:link>, <db:link xlink:href="qambienttemperaturesensor.xml" xlink:role="class">QAmbientTemperatureSensor</db:link>, <db:link xlink:href="qcompass.xml" xlink:role="class">QCompass</db:link>, <db:link xlink:href="qgyroscope.xml" xlink:role="class">QGyroscope</db:link>, <db:link xlink:href="qhumiditysensor.xml" xlink:role="class">QHumiditySensor</db:link>, <db:link xlink:href="qlightsensor.xml" xlink:role="class">QLightSensor</db:link>, <db:link xlink:href="qmagnetometer.xml" xlink:role="class">QMagnetometer</db:link>, <db:link xlink:href="qorientationsensor.xml" xlink:role="class">QOrientationSensor</db:link>, <db:link xlink:href="qpressuresensor.xml" xlink:role="class">QPressureSensor</db:link>, <db:link xlink:href="qproximitysensor.xml" xlink:role="class">QProximitySensor</db:link>, <db:link xlink:href="qrotationsensor.xml" xlink:role="class">QRotationSensor</db:link>, and <db:link xlink:href="qtiltsensor.xml" xlink:role="class">QTiltSensor</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QSensor is part of <db:simplelist><db:member>sensors_main</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The life cycle of a sensor is typically:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Create a sub-class of <db:link xlink:href="qsensor.xml">QSensor</db:link> on the stack or heap.</db:para>
</db:listitem>
<db:listitem>
<db:para>Setup as required by the application.</db:para>
</db:listitem>
<db:listitem>
<db:para>Start receiving values.</db:para>
</db:listitem>
<db:listitem>
<db:para>Sensor data is used by the application.</db:para>
</db:listitem>
<db:listitem>
<db:para>Stop receiving values.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The sensor data is delivered via <db:link xlink:href="qsensorreading.xml">QSensorReading</db:link> and its sub-classes.</db:para>
<db:section xml:id="orientation">
<db:title>Orientation</db:title>
<db:para>Some sensors react to screen orientation changes, such as <db:link xlink:href="qaccelerometer.xml">QAccelerometer</db:link>, <db:link xlink:href="qmagnetometer.xml">QMagnetometer</db:link> and <db:link xlink:href="qrotationsensor.xml">QRotationSensor</db:link>. These are so called <db:emphasis>orientable</db:emphasis> sensors. For orientable sensors, <db:link xlink:href="qsensor.xml">QSensor</db:link> supports changing the reporting of the reading values based on the orientation of the screen.</db:para>
<db:para>For orientable sensors, the <db:link xlink:href="qsensor.xml#axesOrientationMode-prop">axesOrientationMode</db:link> property controls how the orientation affects the reading values.</db:para>
<db:para>In the default mode, <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">QSensor::FixedOrientation</db:link>, the reading values remain unaffected by the orientation. In the <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">QSensor::AutomaticOrientation</db:link> mode, the reading values are automatically rotated by taking the current screen orientation into account. And finally, in the <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">QSensor::UserOrientation</db:link> mode, the reading values are rotated according to a user-specified orientation.</db:para>
<db:para>The functionality of this is only available if it is supported by the backend and if the sensor is orientable, which can be checked by calling <db:link xlink:href="qsensor.xml#isFeatureSupported">QSensor::isFeatureSupported</db:link>() with the <db:link xlink:href="qsensor.xml#Feature-enum">QSensor::AxesOrientation</db:link> flag.</db:para>
<db:para>The orientation values here are always of the screen orientation, not the device orientation. The screen orientation is the orientation of the GUI. For example when rotating a device by 90 degrees counter-clockwise, the screen orientation compensates for that by rotating 90 degrees clockwise, to the effect that the GUI is still facing upright after the device has been rotated. Note that applications can lock the screen orientation, for example to force portrait or landscape mode. For locked orientations, orientable sensors will not react with reading changes if the device orientation is changed, as orientable sensors react to screen orientation changes only. This makes sense, as the purpose of orientable sensors is to keep the sensor orientation in sync with the screen orientation.</db:para>
<db:para>The orientation values range from 0 to 270 degrees. The orientation is applied in clockwise direction, e.g. an orientation value of 90 degrees means that the screen has been rotated 90 degress to the right from its origin position, to compensate a device rotation of 90 degrees to the left.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensorreading.xml">QSensorReading</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="AxesOrientationMode-enum">
<db:title>enum QSensor::AxesOrientationMode</db:title>
<db:enumsynopsis>
<db:enumname>AxesOrientationMode</db:enumname>
<db:enumitem>
<db:enumidentifier>FixedOrientation</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AutomaticOrientation</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UserOrientation</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Describes how reading values are affected by the screen orientation.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsensor.xml">QSensor</db:link></db:emphasis>::FixedOrientation</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>No automatic rotation is applied to the reading values.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsensor.xml">QSensor</db:link></db:emphasis>::AutomaticOrientation</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The reading values are automatically rotated based on the screen orientation.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsensor.xml">QSensor</db:link></db:emphasis>::UserOrientation</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The reading values are rotated based on the angle of the <db:link xlink:href="qsensor.xml#userOrientation-prop">userOrientation</db:link> property.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#axesOrientationMode-prop">QSensor::axesOrientationMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Feature-enum">
<db:title>enum QSensor::Feature</db:title>
<db:enumsynopsis>
<db:enumname>Feature</db:enumname>
<db:enumitem>
<db:enumidentifier>Buffering</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AlwaysOn</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>GeoValues</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>FieldOfView</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AccelerationMode</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SkipDuplicates</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AxesOrientation</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PressureSensorTemperature</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Reserved</db:enumidentifier>
<db:enumvalue>257</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Lists optional features a backend might support.</db:para>
<db:para>The features common to all sensor types are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsensor.xml">QSensor</db:link></db:emphasis>::Buffering</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The backend supports buffering of readings, controlled by the <db:link xlink:href="qsensor.xml#bufferSize-prop">QSensor::bufferSize</db:link> property.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsensor.xml">QSensor</db:link></db:emphasis>::AlwaysOn</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The backend supports changing the policy on whether to suspend when idle, controlled by the <db:link xlink:href="qsensor.xml#alwaysOn-prop">QSensor::alwaysOn</db:link> property.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsensor.xml">QSensor</db:link></db:emphasis>::SkipDuplicates</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>The backend supports skipping of same or very similar successive readings. This can be enabled by setting the <db:link xlink:href="qsensor.xml#skipDuplicates-prop">QSensor::skipDuplicates</db:link> property to true.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The features of <db:link xlink:href="qmagnetometer.xml">QMagnetometer</db:link> are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsensor.xml">QSensor</db:link></db:emphasis>::GeoValues</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The backend supports returning geo values, which can be controlled with the <db:link xlink:href="qmagnetometer.xml#returnGeoValues-prop">QMagnetometer::returnGeoValues</db:link> property.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The features of <db:link xlink:href="qlightsensor.xml">QLightSensor</db:link> are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsensor.xml">QSensor</db:link></db:emphasis>::FieldOfView</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The backend specifies its field of view, which can be read from the <db:link xlink:href="qlightsensor.xml#fieldOfView-prop">QLightSensor::fieldOfView</db:link> property.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The features of <db:link xlink:href="qaccelerometer.xml">QAccelerometer</db:link> are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsensor.xml">QSensor</db:link></db:emphasis>::AccelerationMode</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The backend supports switching the acceleration mode of the acceleromter with the <db:link xlink:href="qaccelerometer.xml#accelerationMode-prop">QAccelerometer::accelerationMode</db:link> property.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The features of <db:link xlink:href="qpressuresensor.xml">QPressureSensor</db:link> are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsensor.xml">QSensor</db:link></db:emphasis>::PressureSensorTemperature</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>The backend provides the pressure sensor's die temperature</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The features of all orientable sensors are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsensor.xml">QSensor</db:link></db:emphasis>::AxesOrientation</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The backend supports changing the axes orientation from the default of <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">QSensor::FixedOrientation</db:link> to something else.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#isFeatureSupported">QSensor::isFeatureSupported</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="active-prop">
<db:title>active : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>active</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isActive</db:synopsisinfo>
<db:synopsisinfo role="setter">setActive</db:synopsisinfo>
<db:synopsisinfo role="notifier">activeChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds a value to indicate if the sensor is active.</db:para>
<db:para>This is true if the sensor is active (returning values). This is false otherwise.</db:para>
<db:para>Note that setting this value to true will not have an immediate effect. Instead, the sensor will be started once the event loop has been reached.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isActive</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setActive</db:emphasis>(<db:type>bool</db:type> <db:emphasis>active</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qsensor.xml#activeChanged">activeChanged</db:link></db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="alwaysOn-prop">
<db:title>alwaysOn : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>alwaysOn</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isAlwaysOn</db:synopsisinfo>
<db:synopsisinfo role="setter">setAlwaysOn</db:synopsisinfo>
<db:synopsisinfo role="notifier">alwaysOnChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds a value to indicate if the sensor should remain running when the screen is off.</db:para>
<db:para>Some platforms have a policy of suspending sensors when the screen turns off. Setting this property to true will ensure the sensor continues to run.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isAlwaysOn</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setAlwaysOn</db:emphasis>(<db:type>bool</db:type> <db:emphasis>alwaysOn</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qsensor.xml#alwaysOnChanged">alwaysOnChanged</db:link></db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="availableDataRates-prop">
<db:title>[read-only] availableDataRates : const qrangelist</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>qrangelist</db:type>
<db:varname>availableDataRates</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">availableDataRates</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the data rates that the sensor supports.</db:para>
<db:para>This is a list of the data rates that the sensor supports. Measured in Hertz.</db:para>
<db:para>Entries in the list can represent discrete rates or a continuous range of rates. A discrete rate is noted by having both values the same.</db:para>
<db:para>Note that this information is not mandatory as not all sensors have a rate at which they run. In such cases, the list will be empty.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsensor.xml#qrangelist-typedef">qrangelist</db:link></db:type> <db:emphasis role="bold">availableDataRates</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#dataRate-prop">QSensor::dataRate</db:link></db:member>
<db:member><db:link xlink:href="qsensor.xml#qrangelist-typedef">qrangelist</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="axesOrientationMode-prop">
<db:title>axesOrientationMode : AxesOrientationMode</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>AxesOrientationMode</db:type>
<db:varname>axesOrientationMode</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">axesOrientationMode</db:synopsisinfo>
<db:synopsisinfo role="setter">setAxesOrientationMode</db:synopsisinfo>
<db:synopsisinfo role="notifier">axesOrientationModeChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the mode that affects how the screen orientation changes reading values.</db:para>
<db:para>When set to <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">FixedOrientation</db:link>, which is the default mode, no automatic rotation is applied to the reading. This is the only mode available for backends that do not support the <db:link xlink:href="qsensor.xml#Feature-enum">QSensor::AxesOrientation</db:link> feature.</db:para>
<db:para>When set to <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">AutomaticOrientation</db:link>, the reading values are automatically rotated when the screen orientation changes. In effect, the screen orientation is canceled out.</db:para>
<db:para>As an example, assume the device is rotated by 180 degrees and therefore the screen orientation also is rotated by 180 degrees from the native orientation. Without automatic axes orientation, the reading values would now be changed: Both the X and the Y values would be negated, forcing an application developer to manually cancel out the negation in application code. Automatic axes orientation does this automatically, in this mode the X and Y values would be the same as with the default screen orientation.</db:para>
<db:para>This automatic rotation of the axes is handy is some usecases, for example in a bubble level application that measures how level a surface is by looking at the X axis value of an accelerometer. When the device and screen orientation change by 90 degrees, an application developer does not need to change anything, he can continue using the X axis value even though the device is rotated. Without automatic axes orientation, the application developer would need to look at the Y values instead, thereby adding code to the application that reads from a different axis depending on the screen orientation.</db:para>
<db:para>The <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">UserOrientation</db:link> mode is quite similar to <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">AutomaticOrientation</db:link>, only that the screen orientation is manually controlled instead of automatically determined. The angle of the <db:link xlink:href="qsensor.xml#userOrientation-prop">userOrientation</db:link> property is then used for rotating the reading values.</db:para>
<db:para>Since the rotation of the reading values is based on the screen orientation, Z values will never change, as the Z axis is perpendicular to the screen. As screen orientation changes in 90 degree steps, rotating the reading values is also done in steps of 90 degrees.</db:para>
<db:para>This property is only used for orientable sensors.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">QSensor::AxesOrientationMode</db:link></db:type> <db:emphasis role="bold">axesOrientationMode</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setAxesOrientationMode</db:emphasis>(<db:type><db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">QSensor::AxesOrientationMode</db:link></db:type> <db:emphasis>axesOrientationMode</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">axesOrientationModeChanged</db:emphasis>(<db:type><db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">QSensor::AxesOrientationMode</db:link></db:type> <db:emphasis>axesOrientationMode</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="bufferSize-prop">
<db:title>bufferSize : int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>bufferSize</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">bufferSize</db:synopsisinfo>
<db:synopsisinfo role="setter">setBufferSize</db:synopsisinfo>
<db:synopsisinfo role="notifier">bufferSizeChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the size of the buffer. By default, the buffer size is 1, which means no buffering. If the maximum buffer size is 1, then buffering is not supported by the sensor.</db:para>
<db:para>Setting bufferSize greater than <db:link xlink:href="qsensor.xml#maxBufferSize-prop">maxBufferSize</db:link> will cause <db:link xlink:href="qsensor.xml#maxBufferSize-prop">maxBufferSize</db:link> to be used.</db:para>
<db:para>Buffering is turned on when bufferSize is greater than 1. The sensor will collect the requested number of samples and deliver them all to the application at one time. They will be delivered to the application as a burst of changed readings so it is particularly important that the application processes each reading immediately or saves the values somewhere else.</db:para>
<db:para>If <db:link xlink:href="qsensor.xml#stop">stop</db:link>() is called when buffering is on-going, the partial buffer is not delivered.</db:para>
<db:para>When the sensor is started with buffering option, values are collected from that moment onwards. There is no pre-existing buffer that can be utilized.</db:para>
<db:para>Some backends only support enabling or disabling the buffer and do not give control over the size. In this case, the <db:link xlink:href="qsensor.xml#maxBufferSize-prop">maxBufferSize</db:link> and <db:link xlink:href="qsensor.xml#efficientBufferSize-prop">efficientBufferSize</db:link> properties might not be set at all, even though buffering is supported. Setting the bufferSize property to any value greater than 1 will enable buffering. After the sensor has been started, the bufferSize property will be set to the actual value by the backend.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">bufferSize</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setBufferSize</db:emphasis>(<db:type>int</db:type> <db:emphasis>bufferSize</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">bufferSizeChanged</db:emphasis>(<db:type>int</db:type> <db:emphasis>bufferSize</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#maxBufferSize-prop">QSensor::maxBufferSize</db:link></db:member>
<db:member><db:link xlink:href="qsensor.xml#efficientBufferSize-prop">QSensor::efficientBufferSize</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="busy-prop">
<db:title>[read-only] busy : const bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>busy</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isBusy</db:synopsisinfo>
<db:synopsisinfo role="notifier">busyChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds a value to indicate if the sensor is busy.</db:para>
<db:para>Some sensors may be on the system but unavailable for use. This function will return true if the sensor is busy. You will not be able to <db:link xlink:href="qsensor.xml#start">start</db:link>() the sensor.</db:para>
<db:para>Note that this function does not return true if you are using the sensor, only if another process is using the sensor.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isBusy</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qsensor.xml#busyChanged">busyChanged</db:link></db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#busyChanged">busyChanged</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectedToBackend-prop">
<db:title>[read-only] connectedToBackend : const bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>connectedToBackend</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isConnectedToBackend</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds a value indicating if the sensor has connected to a backend.</db:para>
<db:para>A sensor that has not been connected to a backend cannot do anything useful.</db:para>
<db:para>Call the <db:link xlink:href="qsensor.xml#connectToBackend">connectToBackend</db:link>() method to force the sensor to connect to a backend immediately. This is automatically called if you call <db:link xlink:href="qsensor.xml#start">start</db:link>() so you only need to do this if you need access to sensor properties (ie. to poll the sensor's meta-data before you use it).</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isConnectedToBackend</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="currentOrientation-prop">
<db:title>[read-only] currentOrientation : const int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>currentOrientation</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">currentOrientation</db:synopsisinfo>
<db:synopsisinfo role="notifier">currentOrientationChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the current orientation that is used for rotating the reading values.</db:para>
<db:para>This might not be the same as the screen orientation. For example, in the <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">FixedOrientation</db:link> mode, the reading values are not rotated, and therefore the property is 0.</db:para>
<db:para>In the <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">UserOrientation</db:link> mode, the readings are rotated based on the <db:link xlink:href="qsensor.xml#userOrientation-prop">userOrientation</db:link> property, and therefore this property is equal to the <db:link xlink:href="qsensor.xml#userOrientation-prop">userOrientation</db:link> property.</db:para>
<db:para>In the <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">AutomaticOrientation</db:link> mode, the readings are rotated based on the screen orientation, and therefore this property will be equal to the current screen orientation.</db:para>
<db:para>This property is set by the backend and only valid for orientable sensors.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">currentOrientation</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">currentOrientationChanged</db:emphasis>(<db:type>int</db:type> <db:emphasis>currentOrientation</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="dataRate-prop">
<db:title>dataRate : int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>dataRate</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">dataRate</db:synopsisinfo>
<db:synopsisinfo role="setter">setDataRate</db:synopsisinfo>
<db:synopsisinfo role="notifier">dataRateChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the data rate that the sensor should be run at.</db:para>
<db:para>Measured in Hertz.</db:para>
<db:para>The data rate is the maximum frequency at which the sensor can detect changes.</db:para>
<db:para>Setting this property is not portable and can cause conflicts with other applications. Check with the sensor backend and platform documentation for any policy regarding multiple applications requesting a data rate.</db:para>
<db:para>The default value (0) means that the app does not care what the data rate is. Applications should consider using a timer-based poll of the current value or ensure that the code that processes values can run very quickly as the platform may provide updates hundreds of times each second.</db:para>
<db:para>This should be set before calling <db:link xlink:href="qsensor.xml#start">start</db:link>() because the sensor may not notice changes to this value while it is running.</db:para>
<db:para>Note that there is no mechanism to determine the current data rate in use by the platform.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">dataRate</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setDataRate</db:emphasis>(<db:type>int</db:type> <db:emphasis>rate</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">dataRateChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#availableDataRates-prop">QSensor::availableDataRates</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="description-prop">
<db:title>[read-only] description : const QString</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QString</db:type>
<db:varname>description</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">description</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds a descriptive string for the sensor.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">description</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="efficientBufferSize-prop">
<db:title>[read-only] efficientBufferSize : const int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>efficientBufferSize</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">efficientBufferSize</db:synopsisinfo>
<db:synopsisinfo role="notifier">efficientBufferSizeChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>The property holds the most efficient buffer size. Normally this is 1 (which means no particular size is most efficient). Some sensor drivers have a FIFO buffer which makes it more efficient to deliver the FIFO's size worth of readings at one time.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">efficientBufferSize</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">efficientBufferSizeChanged</db:emphasis>(<db:type>int</db:type> <db:emphasis>efficientBufferSize</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#bufferSize-prop">QSensor::bufferSize</db:link></db:member>
<db:member><db:link xlink:href="qsensor.xml#maxBufferSize-prop">QSensor::maxBufferSize</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="error-prop">
<db:title>[read-only] error : const int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>error</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">error</db:synopsisinfo>
<db:synopsisinfo role="notifier">sensorError</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the last error code set on the sensor.</db:para>
<db:para>Note that error codes are sensor-specific.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">error</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qsensor.xml#sensorError">sensorError</db:link></db:emphasis>(<db:type>int</db:type> <db:emphasis>error</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="identifier-prop">
<db:title>identifier : QByteArray</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QByteArray</db:type>
<db:varname>identifier</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">identifier</db:synopsisinfo>
<db:synopsisinfo role="setter">setIdentifier</db:synopsisinfo>
<db:synopsisinfo role="notifier">identifierChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the backend identifier for the sensor.</db:para>
<db:para>Note that the identifier is filled out automatically when the sensor is connected to a backend. If you want to connect a specific backend, you should call setIdentifier() before <db:link xlink:href="qsensor.xml#connectToBackend">connectToBackend</db:link>().</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:type> <db:emphasis role="bold">identifier</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setIdentifier</db:emphasis>(const <db:type><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:type> &amp;<db:emphasis>identifier</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">identifierChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="maxBufferSize-prop">
<db:title>[read-only] maxBufferSize : const int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>maxBufferSize</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">maxBufferSize</db:synopsisinfo>
<db:synopsisinfo role="notifier">maxBufferSizeChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>The property holds the maximum buffer size.</db:para>
<db:para>Note that this may be 1, in which case the sensor does not support any form of buffering. In that case, <db:link xlink:href="qsensor.xml#isFeatureSupported">isFeatureSupported</db:link>(<db:link xlink:href="qsensor.xml#Feature-enum">QSensor::Buffering</db:link>) will also return false.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">maxBufferSize</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">maxBufferSizeChanged</db:emphasis>(<db:type>int</db:type> <db:emphasis>maxBufferSize</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#bufferSize-prop">QSensor::bufferSize</db:link></db:member>
<db:member><db:link xlink:href="qsensor.xml#efficientBufferSize-prop">QSensor::efficientBufferSize</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="outputRange-prop">
<db:title>outputRange : int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>outputRange</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">outputRange</db:synopsisinfo>
<db:synopsisinfo role="setter">setOutputRange</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the output range in use by the sensor.</db:para>
<db:para>This value represents the index in the <db:link xlink:href="qsensor.xml#outputRanges-prop">QSensor::outputRanges</db:link> list to use.</db:para>
<db:para>Setting this property is not portable and can cause conflicts with other applications. Check with the sensor backend and platform documentation for any policy regarding multiple applications requesting an output range.</db:para>
<db:para>The default value (-1) means that the app does not care what the output range is.</db:para>
<db:para>Note that there is no mechanism to determine the current output range in use by the platform.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">outputRange</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setOutputRange</db:emphasis>(<db:type>int</db:type> <db:emphasis>index</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#outputRanges-prop">QSensor::outputRanges</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="outputRanges-prop">
<db:title>[read-only] outputRanges : const qoutputrangelist</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>qoutputrangelist</db:type>
<db:varname>outputRanges</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">outputRanges</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds a list of output ranges the sensor supports.</db:para>
<db:para>A sensor may have more than one output range. Typically this is done to give a greater measurement range at the cost of lowering accuracy.</db:para>
<db:para>Note that this information is not mandatory. This information is typically only available for sensors that have selectable output ranges (such as typical accelerometers).</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsensor.xml#qoutputrangelist-typedef">qoutputrangelist</db:link></db:type> <db:emphasis role="bold">outputRanges</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#outputRange-prop">QSensor::outputRange</db:link></db:member>
<db:member><db:link xlink:href="qsensor.xml#qoutputrangelist-typedef">qoutputrangelist</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reading-prop">
<db:title>[read-only] reading : QSensorReading* const</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QSensorReading*</db:type>
<db:varname>reading</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">reading</db:synopsisinfo>
<db:synopsisinfo role="notifier">readingChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the reading class.</db:para>
<db:para>The reading class provides access to sensor readings. The reading object is a volatile cache of the most recent sensor reading that has been received so the application should process readings immediately or save the values somewhere for later processing.</db:para>
<db:para>Note that this will return 0 until a sensor backend is connected to a backend.</db:para>
<db:para>Also note that readings are not immediately available after <db:link xlink:href="qsensor.xml#start">start</db:link>() is called. Applications must wait for the <db:link xlink:href="qsensor.xml#readingChanged">readingChanged</db:link>() signal to be emitted.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsensorreading.xml">QSensorReading</db:link></db:type> *<db:emphasis role="bold">reading</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qsensor.xml#readingChanged">readingChanged</db:link></db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#connectedToBackend-prop">isConnectedToBackend</db:link>()</db:member>
<db:member><db:link xlink:href="qsensor.xml#start">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="skipDuplicates-prop">
<db:title>skipDuplicates : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>skipDuplicates</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">skipDuplicates</db:synopsisinfo>
<db:synopsisinfo role="setter">setSkipDuplicates</db:synopsisinfo>
<db:synopsisinfo role="notifier">skipDuplicatesChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Indicates whether duplicate reading values should be omitted.</db:para>
<db:para>When duplicate skipping is enabled, successive readings with the same or very similar values are omitted. This helps reducing the amount of processing done, as less sensor readings are made available. As a consequence, readings arrive at an irregular interval.</db:para>
<db:para>Duplicate skipping is not just enabled for readings that are exactly the same, but also for readings that are quite similar, as each sensor has a bit of jitter even if the device is not moved.</db:para>
<db:para>Support for this property depends on the backend. Use <db:link xlink:href="qsensor.xml#isFeatureSupported">isFeatureSupported</db:link>() to check if it is supported on the current platform.</db:para>
<db:para>Duplicate skipping is disabled by default.</db:para>
<db:para>Duplicate skipping takes effect when the sensor is started, changing the property while the sensor is active has no immediate effect.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">skipDuplicates</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qsensor.xml#setSkipDuplicates">setSkipDuplicates</db:link></db:emphasis>(<db:type>bool</db:type> <db:emphasis>skipDuplicates</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qsensor.xml#skipDuplicatesChanged">skipDuplicatesChanged</db:link></db:emphasis>(<db:type>bool</db:type> <db:emphasis>skipDuplicates</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="type-prop">
<db:title>[read-only] type : const QByteArray</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QByteArray</db:type>
<db:varname>type</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">type</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the type of the sensor.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:type> <db:emphasis role="bold">type</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="userOrientation-prop">
<db:title>userOrientation : int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>userOrientation</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">userOrientation</db:synopsisinfo>
<db:synopsisinfo role="setter">setUserOrientation</db:synopsisinfo>
<db:synopsisinfo role="notifier">userOrientationChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the angle used for rotating the reading values in the <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">UserOrientation</db:link> mode.</db:para>
<db:para>When the <db:link xlink:href="qsensor.xml#axesOrientationMode-prop">axesOrientationMode</db:link> property is set to <db:link xlink:href="qsensor.xml#AxesOrientationMode-enum">UserOrientation</db:link>, the angle for rotating the reading values is taken from this property. In other modes, the property has no effect.</db:para>
<db:para>The default is 0. The only valid values are 0, 90, 180 and 270, as those are the only possible screen orientations.</db:para>
<db:para>This property is only valid for orientable sensors.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">userOrientation</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setUserOrientation</db:emphasis>(<db:type>int</db:type> <db:emphasis>userOrientation</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">userOrientationChanged</db:emphasis>(<db:type>int</db:type> <db:emphasis>userOrientation</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QSensor">
<db:title>[explicit] QSensor::QSensor(const QByteArray &amp;<db:emphasis>type</db:emphasis>, QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QSensor</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QSensor(const QByteArray &amp;type, QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Construct the <db:code role="parameter">type</db:code> sensor as a child of <db:code role="parameter">parent</db:code>.</db:para>
<db:para>Do not use this constructor if a derived class exists for the specific sensor type.</db:para>
<db:para>The wrong way is to use the base class constructor:</db:para>
<db:programlisting language="cpp">QSensor *magnetometer = new QSensor(QMagnetometer::sensorType, this);
</db:programlisting>
<db:para>The right way is to create an instance of the derived class:</db:para>
<db:programlisting language="cpp">QMagnetometer *magnetometer = new QMagnetometer(this);
</db:programlisting>
<db:para>The derived classes have additional properties and data members which are needed for certain features such as geo value support in <db:link xlink:href="qmagnetometer.xml">QMagnetometer</db:link> or acceleration mode support in <db:link xlink:href="qaccelerometer.xml">QAccelerometer</db:link>. These features will only work properly when creating a sensor instance from a <db:link xlink:href="qsensor.xml">QSensor</db:link> subclass.</db:para>
<db:para>Only use this constructor if there is no derived sensor class available. Note that all built-in sensors have a derived class, so using this constructor should only be necessary when implementing custom sensors.</db:para>
</db:section>
<db:section xml:id="dtor.QSensor">
<db:title>[virtual] QSensor::~QSensor()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QSensor</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QSensor()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroy the sensor. Stops the sensor if it has not already been stopped.</db:para>
</db:section>
<db:section xml:id="activeChanged">
<db:title>void QSensor::activeChanged()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>activeChanged</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">active</db:synopsisinfo>
<db:synopsisinfo role="signature">void activeChanged()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the <db:link xlink:href="qsensor.xml#active-prop">QSensor::active</db:link> property has changed.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qsensor.xml#active-prop">active</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#active-prop">QSensor::active</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addFilter">
<db:title>void QSensor::addFilter(QSensorFilter *<db:emphasis>filter</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addFilter</db:methodname>
<db:methodparam>
<db:type>QSensorFilter *</db:type>
<db:parameter>filter</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addFilter(QSensorFilter *filter)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Add a <db:code role="parameter">filter</db:code> to the sensor.</db:para>
<db:para>The sensor does not take ownership of the filter. <db:link xlink:href="qsensorfilter.xml">QSensorFilter</db:link> will inform the sensor if it is destroyed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensorfilter.xml">QSensorFilter</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="alwaysOnChanged">
<db:title>void QSensor::alwaysOnChanged()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>alwaysOnChanged</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">alwaysOn</db:synopsisinfo>
<db:synopsisinfo role="signature">void alwaysOnChanged()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the <db:link xlink:href="qsensor.xml#alwaysOn-prop">alwaysOn</db:link> property changes.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qsensor.xml#alwaysOn-prop">alwaysOn</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="availableSensorsChanged">
<db:title>void QSensor::availableSensorsChanged()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>availableSensorsChanged</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void availableSensorsChanged()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the list of available sensors has changed. The sensors available to a program will not generally change over time however some of the available sensors may represent hardware that is not permanently connected. For example, a game controller that is connected via bluetooth would become available when it was on and would become unavailable when it was off.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#sensorTypes">QSensor::sensorTypes</db:link>()</db:member>
<db:member><db:link xlink:href="qsensor.xml#sensorsForType">QSensor::sensorsForType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="busyChanged">
<db:title>void QSensor::busyChanged()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>busyChanged</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">busy</db:synopsisinfo>
<db:synopsisinfo role="signature">void busyChanged()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the sensor is no longer busy. This can be used to grab a sensor when it becomes available.</db:para>
<db:programlisting language="cpp">sensor.start();
if (sensor.isBusy()) {
    // need to wait for busyChanged signal and try again
}
</db:programlisting>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qsensor.xml#busy-prop">busy</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="connectToBackend">
<db:title>bool QSensor::connectToBackend()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>connectToBackend</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool connectToBackend()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Try to connect to a sensor backend.</db:para>
<db:para>Returns true if a suitable backend could be found, false otherwise.</db:para>
<db:para>The type must be set before calling this method if you are using <db:link xlink:href="qsensor.xml">QSensor</db:link> directly.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#connectedToBackend-prop">isConnectedToBackend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="defaultSensorForType">
<db:title>[static] QByteArray QSensor::defaultSensorForType(const QByteArray &amp;<db:emphasis>type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>defaultSensorForType</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray defaultSensorForType(const QByteArray &amp;type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the default sensor identifier for <db:code role="parameter">type</db:code>. This is set in a config file and can be overridden if required. If no default is available the system will return the first registered sensor for <db:code role="parameter">type</db:code>.</db:para>
<db:para>Note that there is special case logic to prevent the generic plugin's backends from becoming the default when another backend is registered for the same type. This logic means that a backend identifier starting with <db:code>generic.</db:code> will only be the default if no other backends have been registered for that type or if it is specified in <db:code>Sensors.conf</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="determining-the-default-sensor-for-a-type.xml">Determining the default sensor for a type</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filters">
<db:title>QList&lt;QSensorFilter *&gt; QSensor::filters() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QSensorFilter *&gt;</db:type>
<db:methodname>filters</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QSensorFilter *&gt; filters() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the filters currently attached to the sensor.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensorfilter.xml">QSensorFilter</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isFeatureSupported">
<db:title>bool QSensor::isFeatureSupported(QSensor::Feature <db:emphasis>feature</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFeatureSupported</db:methodname>
<db:methodparam>
<db:type>QSensor::Feature</db:type>
<db:parameter>feature</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFeatureSupported(QSensor::Feature feature) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Checks if a specific feature is supported by the backend.</db:para>
<db:para><db:link xlink:href="qtsensors-qmlmodule.xml">QtSensors</db:link> supports a rich API for controlling and providing information about sensors. Naturally, not all of this functionality can be supported by all of the backends.</db:para>
<db:para>To check if the current backend supports the feature <db:code role="parameter">feature</db:code>, call this function.</db:para>
<db:para>The backend needs to be connected, otherwise false will be returned. Calling <db:link xlink:href="qsensor.xml#connectToBackend">connectToBackend</db:link>() or <db:link xlink:href="qsensor.xml#start">start</db:link>() will create a connection to the backend.</db:para>
<db:para>Backends have to implement <db:link xlink:href="qsensorbackend.xml#isFeatureSupported">QSensorBackend::isFeatureSupported</db:link>() to make this work.</db:para>
<db:para>Returns whether or not the feature is supported if the backend is connected, or false if the backend is not connected.</db:para>
</db:section>
<db:section xml:id="readingChanged">
<db:title>void QSensor::readingChanged()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>readingChanged</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">reading</db:synopsisinfo>
<db:synopsisinfo role="signature">void readingChanged()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when a new sensor reading is received.</db:para>
<db:para>The sensor reading can be found in the <db:link xlink:href="qsensor.xml#reading-prop">QSensor::reading</db:link> property. Note that the reading object is a volatile cache of the most recent sensor reading that has been received so the application should process the reading immediately or save the values somewhere for later processing.</db:para>
<db:para>Before this signal has been emitted for the first time, the reading object will have uninitialized data.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qsensor.xml#reading-prop">reading</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#start">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeFilter">
<db:title>void QSensor::removeFilter(QSensorFilter *<db:emphasis>filter</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeFilter</db:methodname>
<db:methodparam>
<db:type>QSensorFilter *</db:type>
<db:parameter>filter</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeFilter(QSensorFilter *filter)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Remove <db:code role="parameter">filter</db:code> from the sensor.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensorfilter.xml">QSensorFilter</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sensorError">
<db:title>void QSensor::sensorError(int <db:emphasis>error</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>sensorError</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>error</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">error</db:synopsisinfo>
<db:synopsisinfo role="signature">void sensorError(int error)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when an <db:code role="parameter">error</db:code> code is set on the sensor. Note that some errors will cause the sensor to stop working. You should call <db:link xlink:href="qsensor.xml#active-prop">isActive</db:link>() to determine if the sensor is still running.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qsensor.xml#error-prop">error</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="sensorTypes">
<db:title>[static] QList&lt;QByteArray&gt; QSensor::sensorTypes()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QList&lt;QByteArray&gt;</db:type>
<db:methodname>sensorTypes</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QByteArray&gt; sensorTypes()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list of all sensor types.</db:para>
</db:section>
<db:section xml:id="sensorsForType">
<db:title>[static] QList&lt;QByteArray&gt; QSensor::sensorsForType(const QByteArray &amp;<db:emphasis>type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QList&lt;QByteArray&gt;</db:type>
<db:methodname>sensorsForType</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QByteArray&gt; sensorsForType(const QByteArray &amp;type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list of ids for each of the sensors for <db:code role="parameter">type</db:code>. If there are no sensors of that type available the list will be empty.</db:para>
</db:section>
<db:section xml:id="setCurrentOrientation">
<db:title>void QSensor::setCurrentOrientation(int <db:emphasis>currentOrientation</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setCurrentOrientation</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>currentOrientation</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setCurrentOrientation(int currentOrientation)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the current screen orientation to <db:code role="parameter">currentOrientation</db:code>. This is to be called from the backend whenever the screen orientation or the <db:link xlink:href="qsensor.xml#userOrientation-prop">userOrientation</db:link> property changes.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#currentOrientation-prop">currentOrientation</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setEfficientBufferSize">
<db:title>void QSensor::setEfficientBufferSize(int <db:emphasis>efficientBufferSize</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setEfficientBufferSize</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>efficientBufferSize</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setEfficientBufferSize(int efficientBufferSize)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the efficient buffer size to <db:code role="parameter">efficientBufferSize</db:code>. This is to be called from the backend.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#efficientBufferSize-prop">efficientBufferSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMaxBufferSize">
<db:title>void QSensor::setMaxBufferSize(int <db:emphasis>maxBufferSize</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setMaxBufferSize</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>maxBufferSize</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setMaxBufferSize(int maxBufferSize)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the maximum buffer size to <db:code role="parameter">maxBufferSize</db:code>. This is to be called from the backend.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#maxBufferSize-prop">maxBufferSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSkipDuplicates">
<db:title>void QSensor::setSkipDuplicates(bool <db:emphasis>skipDuplicates</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setSkipDuplicates</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>skipDuplicates</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">skipDuplicates</db:synopsisinfo>
<db:synopsisinfo role="signature">void setSkipDuplicates(bool skipDuplicates)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the duplicate skipping to <db:code role="parameter">skipDuplicates</db:code>.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qsensor.xml#skipDuplicates-prop">skipDuplicates</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#skipDuplicates-prop">skipDuplicates</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="skipDuplicatesChanged">
<db:title>void QSensor::skipDuplicatesChanged(bool <db:emphasis>skipDuplicates</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>skipDuplicatesChanged</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>skipDuplicates</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">skipDuplicates</db:synopsisinfo>
<db:synopsisinfo role="signature">void skipDuplicatesChanged(bool skipDuplicates)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the <db:code role="parameter">skipDuplicates</db:code> property changes.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qsensor.xml#skipDuplicates-prop">skipDuplicates</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="start">
<db:title>bool QSensor::start()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>start</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool start()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Start retrieving values from the sensor. Returns true if the sensor was started, false otherwise.</db:para>
<db:para>The sensor may fail to start for several reasons.</db:para>
<db:para>Once an application has started a sensor it must wait until the sensor receives a new value before it can query the sensor's values. This is due to how the sensor receives values from the system. Sensors do not (in general) poll for new values, rather new values are pushed to the sensors as they happen.</db:para>
<db:para>For example, this code will not work as intended.</db:para>
<db:programlisting language="cpp" role="bad">sensor-&amp;gt;start();
sensor-&amp;gt;reading()-&amp;gt;x(); // no data available
</db:programlisting>
<db:para>To work correctly, the code that accesses the reading should ensure the <db:link xlink:href="qsensor.xml#readingChanged">readingChanged</db:link>() signal has been emitted.</db:para>
<db:programlisting language="cpp">    connect(sensor, SIGNAL(readingChanged()), this, SLOT(checkReading()));
    sensor-&amp;gt;start();
}
void MyClass::checkReading() {
    sensor-&amp;gt;reading()-&amp;gt;x();
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#busy-prop">QSensor::busy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stop">
<db:title>void QSensor::stop()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>stop</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void stop()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Stop retrieving values from the sensor.</db:para>
<db:para>This releases the sensor so that other processes can use it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsensor.xml#busy-prop">QSensor::busy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qoutputrangelist-typedef">
<db:title>[alias] qoutputrangelist</db:title>
<db:typedefsynopsis>
<db:typedefname>qoutputrangelist</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>This type is defined as a list of qoutputrange values.</db:para>
<db:programlisting language="cpp">typedef QList&amp;lt;qoutputrange&amp;gt; qoutputrangelist;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml">QList</db:link></db:member>
<db:member><db:link xlink:href="qoutputrange.xml">qoutputrange</db:link></db:member>
<db:member><db:link xlink:href="qsensor.xml#outputRanges-prop">QSensor::outputRanges</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qrange-typedef">
<db:title>[alias] qrange</db:title>
<db:typedefsynopsis>
<db:typedefname>qrange</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>This type is defined as a <db:link xlink:href="qpair-proxy.xml#QPair-typedef">QPair</db:link>.</db:para>
<db:programlisting language="cpp">typedef QPair&amp;lt;int,int&amp;gt; qrange;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qpair-proxy.xml">QPair</db:link></db:member>
<db:member><db:link xlink:href="qsensor.xml#qrangelist-typedef">qrangelist</db:link></db:member>
<db:member><db:link xlink:href="qsensor.xml#availableDataRates-prop">QSensor::availableDataRates</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qrangelist-typedef">
<db:title>[alias] qrangelist</db:title>
<db:typedefsynopsis>
<db:typedefname>qrangelist</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>This type is defined as a list of qrange values.</db:para>
<db:programlisting language="cpp">typedef QList&amp;lt;qrange&amp;gt; qrangelist;
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml">QList</db:link></db:member>
<db:member><db:link xlink:href="qsensor.xml#qrange-typedef">qrange</db:link></db:member>
<db:member><db:link xlink:href="qsensor.xml#availableDataRates-prop">QSensor::availableDataRates</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
