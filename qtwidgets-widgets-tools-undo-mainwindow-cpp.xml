<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Undo Framework</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>This example shows Qt's undo framework in action.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the demonstration applications of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &amp;lt;QUndoGroup&amp;gt;
#include &amp;lt;QUndoStack&amp;gt;
#include &amp;lt;QFileDialog&amp;gt;
#include &amp;lt;QMessageBox&amp;gt;
#include &amp;lt;QRandomGenerator&amp;gt;
#include &amp;lt;QTextStream&amp;gt;
#include &amp;lt;QToolButton&amp;gt;
#include &quot;document.h&quot;
#include &quot;mainwindow.h&quot;
#include &quot;commands.h&quot;

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
    setupUi(this);

    QWidget *w = documentTabs-&amp;gt;widget(0);
    documentTabs-&amp;gt;removeTab(0);
    delete w;

    connect(actionOpen, SIGNAL(triggered()), this, SLOT(openDocument()));
    connect(actionClose, SIGNAL(triggered()), this, SLOT(closeDocument()));
    connect(actionNew, SIGNAL(triggered()), this, SLOT(newDocument()));
    connect(actionSave, SIGNAL(triggered()), this, SLOT(saveDocument()));
    connect(actionExit, SIGNAL(triggered()), this, SLOT(close()));
    connect(actionRed, SIGNAL(triggered()), this, SLOT(setShapeColor()));
    connect(actionGreen, SIGNAL(triggered()), this, SLOT(setShapeColor()));
    connect(actionBlue, SIGNAL(triggered()), this, SLOT(setShapeColor()));
    connect(actionAddCircle, SIGNAL(triggered()), this, SLOT(addShape()));
    connect(actionAddRectangle, SIGNAL(triggered()), this, SLOT(addShape()));
    connect(actionAddTriangle, SIGNAL(triggered()), this, SLOT(addShape()));
    connect(actionRemoveShape, SIGNAL(triggered()), this, SLOT(removeShape()));
    connect(actionAddRobot, SIGNAL(triggered()), this, SLOT(addRobot()));
    connect(actionAddSnowman, SIGNAL(triggered()), this, SLOT(addSnowman()));
    connect(actionAbout, SIGNAL(triggered()), this, SLOT(about()));
    connect(actionAboutQt, SIGNAL(triggered()), this, SLOT(aboutQt()));

    connect(undoLimit, SIGNAL(valueChanged(int)), this, SLOT(updateActions()));
    connect(documentTabs, SIGNAL(currentChanged(int)), this, SLOT(updateActions()));

    actionOpen-&amp;gt;setShortcut(QString(&quot;Ctrl+O&quot;));
    actionClose-&amp;gt;setShortcut(QString(&quot;Ctrl+W&quot;));
    actionNew-&amp;gt;setShortcut(QString(&quot;Ctrl+N&quot;));
    actionSave-&amp;gt;setShortcut(QString(&quot;Ctrl+S&quot;));
    actionExit-&amp;gt;setShortcut(QString(&quot;Ctrl+Q&quot;));
    actionRemoveShape-&amp;gt;setShortcut(QString(&quot;Del&quot;));
    actionRed-&amp;gt;setShortcut(QString(&quot;Alt+R&quot;));
    actionGreen-&amp;gt;setShortcut(QString(&quot;Alt+G&quot;));
    actionBlue-&amp;gt;setShortcut(QString(&quot;Alt+B&quot;));
    actionAddCircle-&amp;gt;setShortcut(QString(&quot;Alt+C&quot;));
    actionAddRectangle-&amp;gt;setShortcut(QString(&quot;Alt+L&quot;));
    actionAddTriangle-&amp;gt;setShortcut(QString(&quot;Alt+T&quot;));

    m_undoGroup = new QUndoGroup(this);
    undoView-&amp;gt;setGroup(m_undoGroup);
    undoView-&amp;gt;setCleanIcon(QIcon(&quot;:/icons/ok.png&quot;));

    QAction *undoAction = m_undoGroup-&amp;gt;createUndoAction(this);
    QAction *redoAction = m_undoGroup-&amp;gt;createRedoAction(this);
    undoAction-&amp;gt;setIcon(QIcon(&quot;:/icons/undo.png&quot;));
    redoAction-&amp;gt;setIcon(QIcon(&quot;:/icons/redo.png&quot;));
    menuShape-&amp;gt;insertAction(menuShape-&amp;gt;actions().at(0), undoAction);
    menuShape-&amp;gt;insertAction(undoAction, redoAction);

    toolBar-&amp;gt;addAction(undoAction);
    toolBar-&amp;gt;addAction(redoAction);

    newDocument();
    updateActions();
};

void MainWindow::updateActions()
{
    Document *doc = currentDocument();
    m_undoGroup-&amp;gt;setActiveStack(doc == 0 ? 0 : doc-&amp;gt;undoStack());
    QString shapeName = doc == 0 ? QString() : doc-&amp;gt;currentShapeName();

    actionAddRobot-&amp;gt;setEnabled(doc != 0);
    actionAddSnowman-&amp;gt;setEnabled(doc != 0);
    actionAddCircle-&amp;gt;setEnabled(doc != 0);
    actionAddRectangle-&amp;gt;setEnabled(doc != 0);
    actionAddTriangle-&amp;gt;setEnabled(doc != 0);
    actionClose-&amp;gt;setEnabled(doc != 0);
    actionSave-&amp;gt;setEnabled(doc != 0 &amp;amp;&amp;amp; !doc-&amp;gt;undoStack()-&amp;gt;isClean());
    undoLimit-&amp;gt;setEnabled(doc != 0 &amp;amp;&amp;amp; doc-&amp;gt;undoStack()-&amp;gt;count() == 0);

    if (shapeName.isEmpty()) {
        actionRed-&amp;gt;setEnabled(false);
        actionGreen-&amp;gt;setEnabled(false);
        actionBlue-&amp;gt;setEnabled(false);
        actionRemoveShape-&amp;gt;setEnabled(false);
    } else {
        Shape shape = doc-&amp;gt;shape(shapeName);
        actionRed-&amp;gt;setEnabled(shape.color() != Qt::red);
        actionGreen-&amp;gt;setEnabled(shape.color() != Qt::green);
        actionBlue-&amp;gt;setEnabled(shape.color() != Qt::blue);
        actionRemoveShape-&amp;gt;setEnabled(true);
    }

    if (doc != 0) {
        int index = documentTabs-&amp;gt;indexOf(doc);
        Q_ASSERT(index != -1);
        static const QIcon unsavedIcon(&quot;:/icons/filesave.png&quot;);
        documentTabs-&amp;gt;setTabIcon(index, doc-&amp;gt;undoStack()-&amp;gt;isClean() ? QIcon() : unsavedIcon);

        if (doc-&amp;gt;undoStack()-&amp;gt;count() == 0)
            doc-&amp;gt;undoStack()-&amp;gt;setUndoLimit(undoLimit-&amp;gt;value());
    }
}

void MainWindow::openDocument()
{
    QString fileName = QFileDialog::getOpenFileName(this);
    if (fileName.isEmpty())
        return;

    QFile file(fileName);
    if (!file.open(QIODevice::ReadOnly)) {
        QMessageBox::warning(this,
                            tr(&quot;File error&quot;),
                            tr(&quot;Failed to open\n%1&quot;).arg(fileName));
        return;
    }
    QTextStream stream(&amp;amp;file);

    Document *doc = new Document();
    if (!doc-&amp;gt;load(stream)) {
        QMessageBox::warning(this,
                            tr(&quot;Parse error&quot;),
                            tr(&quot;Failed to parse\n%1&quot;).arg(fileName));
        delete doc;
        return;
    }

    doc-&amp;gt;setFileName(fileName);
    addDocument(doc);
}

QString MainWindow::fixedWindowTitle(const Document *doc) const
{
    QString title = doc-&amp;gt;fileName();

    if (title.isEmpty())
        title = tr(&quot;Unnamed&quot;);
    else
        title = QFileInfo(title).fileName();

    QString result;

    for (int i = 0; ; ++i) {
        result = title;
        if (i &amp;gt; 0)
            result += QString::number(i);

        bool unique = true;
        for (int j = 0; j &amp;lt; documentTabs-&amp;gt;count(); ++j) {
            const QWidget *widget = documentTabs-&amp;gt;widget(j);
            if (widget == doc)
                continue;
            if (result == documentTabs-&amp;gt;tabText(j)) {
                unique = false;
                break;
            }
        }

        if (unique)
            break;
    }

    return result;
}

void MainWindow::addDocument(Document *doc)
{
    if (documentTabs-&amp;gt;indexOf(doc) != -1)
        return;
    m_undoGroup-&amp;gt;addStack(doc-&amp;gt;undoStack());
    documentTabs-&amp;gt;addTab(doc, fixedWindowTitle(doc));
    connect(doc, SIGNAL(currentShapeChanged(QString)), this, SLOT(updateActions()));
    connect(doc-&amp;gt;undoStack(), SIGNAL(indexChanged(int)), this, SLOT(updateActions()));
    connect(doc-&amp;gt;undoStack(), SIGNAL(cleanChanged(bool)), this, SLOT(updateActions()));

    setCurrentDocument(doc);
}

void MainWindow::setCurrentDocument(Document *doc)
{
    documentTabs-&amp;gt;setCurrentWidget(doc);
}

Document *MainWindow::currentDocument() const
{
    return qobject_cast&amp;lt;Document*&amp;gt;(documentTabs-&amp;gt;currentWidget());
}

void MainWindow::removeDocument(Document *doc)
{
    int index = documentTabs-&amp;gt;indexOf(doc);
    if (index == -1)
        return;

    documentTabs-&amp;gt;removeTab(index);
    m_undoGroup-&amp;gt;removeStack(doc-&amp;gt;undoStack());
    disconnect(doc, SIGNAL(currentShapeChanged(QString)), this, SLOT(updateActions()));
    disconnect(doc-&amp;gt;undoStack(), SIGNAL(indexChanged(int)), this, SLOT(updateActions()));
    disconnect(doc-&amp;gt;undoStack(), SIGNAL(cleanChanged(bool)), this, SLOT(updateActions()));

    if (documentTabs-&amp;gt;count() == 0) {
        newDocument();
        updateActions();
    }
}

void MainWindow::saveDocument()
{
    Document *doc = currentDocument();
    if (doc == 0)
        return;

    for (;;) {
        QString fileName = doc-&amp;gt;fileName();

        if (fileName.isEmpty())
            fileName = QFileDialog::getSaveFileName(this);
        if (fileName.isEmpty())
            break;

        QFile file(fileName);
        if (!file.open(QIODevice::WriteOnly)) {
            QMessageBox::warning(this,
                                tr(&quot;File error&quot;),
                                tr(&quot;Failed to open\n%1&quot;).arg(fileName));
            doc-&amp;gt;setFileName(QString());
        } else {
            QTextStream stream(&amp;amp;file);
            doc-&amp;gt;save(stream);
            doc-&amp;gt;setFileName(fileName);

            int index = documentTabs-&amp;gt;indexOf(doc);
            Q_ASSERT(index != -1);
            documentTabs-&amp;gt;setTabText(index, fixedWindowTitle(doc));

            break;
        }
    }
}

void MainWindow::closeDocument()
{
    Document *doc = currentDocument();
    if (doc == 0)
        return;

    if (!doc-&amp;gt;undoStack()-&amp;gt;isClean()) {
        int button
            = QMessageBox::warning(this,
                            tr(&quot;Unsaved changes&quot;),
                            tr(&quot;Would you like to save this document?&quot;),
                            QMessageBox::Yes, QMessageBox::No);
        if (button == QMessageBox::Yes)
            saveDocument();
    }

    removeDocument(doc);
    delete doc;
}

void MainWindow::newDocument()
{
    addDocument(new Document());
}

static QColor randomColor()
{
    int r = QRandomGenerator::global()-&amp;gt;bounded(3);
    switch (r) {
        case 0:
            return Qt::red;
        case 1:
            return Qt::green;
        default:
            break;
    }
    return Qt::blue;
}

static QRect randomRect(const QSize &amp;amp;s)
{
    QSize min = Shape::minSize;

    int left = (int) ((0.0 + s.width() - min.width())*(QRandomGenerator::global()-&amp;gt;bounded(1.0)));
    int top = (int) ((0.0 + s.height() - min.height())*(QRandomGenerator::global()-&amp;gt;bounded(1.0)));
    int width = (int) ((0.0 + s.width() - left - min.width())*(QRandomGenerator::global()-&amp;gt;bounded(1.0))) + min.width();
    int height = (int) ((0.0 + s.height() - top - min.height())*(QRandomGenerator::global()-&amp;gt;bounded(1.0))) + min.height();

    return QRect(left, top, width, height);
}

void MainWindow::addShape()
{
    Document *doc = currentDocument();
    if (doc == 0)
        return;

    Shape::Type type;

    if (sender() == actionAddCircle)
        type = Shape::Circle;
    else if (sender() == actionAddRectangle)
        type = Shape::Rectangle;
    else if (sender() == actionAddTriangle)
        type = Shape::Triangle;
    else return;

    Shape newShape(type, randomColor(), randomRect(doc-&amp;gt;size()));
    doc-&amp;gt;undoStack()-&amp;gt;push(new AddShapeCommand(doc, newShape));
}

void MainWindow::removeShape()
{
    Document *doc = currentDocument();
    if (doc == 0)
        return;

    QString shapeName = doc-&amp;gt;currentShapeName();
    if (shapeName.isEmpty())
        return;

    doc-&amp;gt;undoStack()-&amp;gt;push(new RemoveShapeCommand(doc, shapeName));
}

void MainWindow::setShapeColor()
{
    Document *doc = currentDocument();
    if (doc == 0)
        return;

    QString shapeName = doc-&amp;gt;currentShapeName();
    if (shapeName.isEmpty())
        return;

    QColor color;

    if (sender() == actionRed)
        color = Qt::red;
    else if (sender() == actionGreen)
        color = Qt::green;
    else if (sender() == actionBlue)
        color = Qt::blue;
    else
        return;

    if (color == doc-&amp;gt;shape(shapeName).color())
        return;

    doc-&amp;gt;undoStack()-&amp;gt;push(new SetShapeColorCommand(doc, shapeName, color));
}

void MainWindow::addSnowman()
{
    Document *doc = currentDocument();
    if (doc == 0)
        return;

    // Create a macro command using beginMacro() and endMacro()

    doc-&amp;gt;undoStack()-&amp;gt;beginMacro(tr(&quot;Add snowman&quot;));
    doc-&amp;gt;undoStack()-&amp;gt;push(new AddShapeCommand(doc,
                            Shape(Shape::Circle, Qt::blue, QRect(51, 30, 97, 95))));
    doc-&amp;gt;undoStack()-&amp;gt;push(new AddShapeCommand(doc,
                            Shape(Shape::Circle, Qt::blue, QRect(27, 123, 150, 133))));
    doc-&amp;gt;undoStack()-&amp;gt;push(new AddShapeCommand(doc,
                            Shape(Shape::Circle, Qt::blue, QRect(11, 253, 188, 146))));
    doc-&amp;gt;undoStack()-&amp;gt;endMacro();
}

void MainWindow::addRobot()
{
    Document *doc = currentDocument();
    if (doc == 0)
        return;

    // Compose a macro command by explicitly adding children to a parent command

    QUndoCommand *parent = new QUndoCommand(tr(&quot;Add robot&quot;));

    new AddShapeCommand(doc, Shape(Shape::Rectangle, Qt::green, QRect(115, 15, 81, 70)), parent);
    new AddShapeCommand(doc, Shape(Shape::Rectangle, Qt::green, QRect(82, 89, 148, 188)), parent);
    new AddShapeCommand(doc, Shape(Shape::Rectangle, Qt::green, QRect(76, 280, 80, 165)), parent);
    new AddShapeCommand(doc, Shape(Shape::Rectangle, Qt::green, QRect(163, 280, 80, 164)), parent);
    new AddShapeCommand(doc, Shape(Shape::Circle, Qt::blue, QRect(116, 25, 80, 50)), parent);
    new AddShapeCommand(doc, Shape(Shape::Rectangle, Qt::green, QRect(232, 92, 80, 127)), parent);
    new AddShapeCommand(doc, Shape(Shape::Rectangle, Qt::green, QRect(2, 92, 80, 125)), parent);

    doc-&amp;gt;undoStack()-&amp;gt;push(parent);
}

void MainWindow::about()
{
    QMessageBox::about(this, tr(&quot;About Undo&quot;), tr(&quot;The Undo demonstration shows how to use the Qt Undo framework.&quot;));
}

void MainWindow::aboutQt()
{
    QMessageBox::aboutQt(this, tr(&quot;About Qt&quot;));
}

</db:programlisting>
</db:article>
