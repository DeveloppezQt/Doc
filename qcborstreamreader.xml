<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QCborStreamReader Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.15.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> class is a simple CBOR stream decoder, operating on either a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> or <db:link xlink:href="qiodevice.xml">QIODevice</db:link>.</db:para>
<db:para>This class was introduced in Qt 5.12.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QCborStreamReader</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.12</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QCborStreamReader is part of <db:simplelist><db:member>cbor</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>This class can be used to decode a stream of CBOR content directly from either a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> or a <db:link xlink:href="qiodevice.xml">QIODevice</db:link>. CBOR is the Concise Binary Object Representation, a very compact form of binary data encoding that is compatible with JSON. It was created by the IETF Constrained RESTful Environments (CoRE) WG, which has used it in many new RFCs. It is meant to be used alongside the <db:link xlink:href="https://tools.ietf.org/html/rfc7252">CoAP protocol</db:link>.</db:para>
<db:para><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> provides a StAX-like API, similar to that of <db:link xlink:href="qxmlstreamreader.xml">QXmlStreamReader</db:link>. Using it requires a bit of knowledge of CBOR encoding. For a simpler API, see <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> and especially the decoding function <db:link xlink:href="qcborvalue.xml#fromCbor">QCborValue::fromCbor</db:link>().</db:para>
<db:para>Typically, one creates a <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> by passing the source <db:link xlink:href="qbytearray.xml">QByteArray</db:link> or <db:link xlink:href="qiodevice.xml">QIODevice</db:link> as a parameter to the constructor, then pop elements off the stream if there were no errors in decoding. There are three kinds of CBOR types:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Kind</db:para>
</db:th>
<db:th>
<db:para>Types</db:para>
</db:th>
<db:th>
<db:para>Behavior</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Fixed-width</db:para>
</db:td>
<db:td>
<db:para>Integers, Tags, Simple types, Floating point</db:para>
</db:td>
<db:td>
<db:para>Value is pre-parsed by <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link>, so accessor functions are const. Must call <db:link xlink:href="qcborstreamreader.xml#next">next</db:link>() to advance.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Strings</db:para>
</db:td>
<db:td>
<db:para>Byte arrays, Text strings</db:para>
</db:td>
<db:td>
<db:para>Length (if known) is pre-parsed, but the string itself is not. The accessor functions are not const and may allocate memory. Once called, the accessor functions automatically advance to the next element.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Containers</db:para>
</db:td>
<db:td>
<db:para>Arrays, Maps</db:para>
</db:td>
<db:td>
<db:para>Length (if known) is pre-parsed. To access the elements, you must call <db:link xlink:href="qcborstreamreader.xml#enterContainer">enterContainer</db:link>(), read all elements, then call <db:link xlink:href="qcborstreamreader.xml#leaveContainer">leaveContainer</db:link>(). That function advances to the next element.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>So a processor function typically looks like this:</db:para>
<db:programlisting language="cpp">   void handleStream(QCborStreamReader &amp;amp;reader)
   {
       switch (reader.type())
       case QCborStreamReader::UnsignedInteger:
       case QCborStreamReader::NegativeInteger:
       case QCborStreamReader::SimpleType:
       case QCborStreamReader::Float16:
       case QCborStreamReader::Float:
       case QCborStreamReader::Double:
           handleFixedWidth(reader);
           reader.next();
           break;
       case QCborStreamReader::ByteArray:
       case QCborStreamReader::String:
           handleString(reader);
           break;
       case QCborStreamReader::Array:
       case QCborStreamReader::Map:
           reader.enterContainer();
           while (reader.lastError() == QCborError::NoError)
               handleStream(reader);
           if (reader.lastError() == QCborError::NoError)
               reader.leaveContainer();
       }
   }
</db:programlisting>
<db:section xml:id="cbor-support">
<db:title>CBOR support</db:title>
<db:para>The following table lists the CBOR features that <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> supports.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Feature</db:para>
</db:th>
<db:th>
<db:para>Support</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Unsigned numbers</db:para>
</db:td>
<db:td>
<db:para>Yes (full range)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Negative numbers</db:para>
</db:td>
<db:td>
<db:para>Yes (full range)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Byte strings</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Text strings</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Chunked strings</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Tags</db:para>
</db:td>
<db:td>
<db:para>Yes (arbitrary)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Booleans</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Null</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Undefined</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Arbitrary simple values</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Half-precision float (16-bit)</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Single-precision float (32-bit)</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Double-precision float (64-bit)</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Infinities and NaN floating point</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Determinate-length arrays and maps</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Indeterminate-length arrays and maps</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Map key types other than strings and integers</db:para>
</db:td>
<db:td>
<db:para>Yes (arbitrary)</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="dealing-with-invalid-or-incomplete-cbor-streams">
<db:title>Dealing with invalid or incomplete CBOR streams</db:title>
<db:para><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> is capable of detecting corrupt input on its own. The library it uses has been extensively tested against invalid input of any kind and is quite able to report errors. If any is detected, <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> will set <db:link xlink:href="qcborstreamreader.xml#lastError">lastError</db:link>() to a value besides <db:link xlink:href="qcborerror.xml#Code-enum">QCborError::NoError</db:link>, indicating which situation was detected.</db:para>
<db:para>Most errors detected by <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> during normal item parsing are not recoverable. The code using <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> may opt to handle the data that was properly decoded or it can opt to discard the entire data.</db:para>
<db:para>The only recoverable error is <db:link xlink:href="qcborerror.xml#Code-enum">QCborError::EndOfFile</db:link>, which indicates that more data is required in order to complete the parsing. This situation is useful when data is being read from an asynchronous source, such as a pipe (<db:link xlink:href="qprocess.xml">QProcess</db:link>) or a socket (<db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>, <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link>, <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link>, etc.). When more data arrives, the surrounding code needs to call either <db:link xlink:href="qcborstreamreader.xml#addData">addData</db:link>(), if parsing from a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, or <db:link xlink:href="qcborstreamreader.xml#reparse">reparse</db:link>(), if it is instead reading directly a the QIDOevice that now has more data available (see <db:link xlink:href="qcborstreamreader.xml#setDevice">setDevice</db:link>()).</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link></db:member>
<db:member><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:member>
<db:member><db:link xlink:href="qxmlstreamreader.xml">QXmlStreamReader</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="StringResultCode-enum">
<db:title>enum QCborStreamReader::StringResultCode</db:title>
<db:enumsynopsis>
<db:enumname>StringResultCode</db:enumname>
<db:enumitem>
<db:enumidentifier>EndOfString</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Ok</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Error</db:enumidentifier>
<db:enumvalue>-1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum is returned by <db:link xlink:href="qcborstreamreader.xml#readString">readString</db:link>() and <db:link xlink:href="qcborstreamreader.xml#readByteArray">readByteArray</db:link>() and is used to indicate what the status of the parsing is.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::EndOfString</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The parsing for the string is complete, with no error.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::Ok</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The function returned data; there was no error.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::Error</db:code></db:para>
</db:td>
<db:td><db:code>-1</db:code></db:td>
<db:td>
<db:para>Parsing failed with an error.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="Type-enum">
<db:title>enum QCborStreamReader::Type</db:title>
<db:enumsynopsis>
<db:enumname>Type</db:enumname>
<db:enumitem>
<db:enumidentifier>UnsignedInteger</db:enumidentifier>
<db:enumvalue>0x00</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NegativeInteger</db:enumidentifier>
<db:enumvalue>0x20</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ByteString</db:enumidentifier>
<db:enumvalue>0x40</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ByteArray</db:enumidentifier>
<db:enumvalue>ByteString</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TextString</db:enumidentifier>
<db:enumvalue>0x60</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>String</db:enumidentifier>
<db:enumvalue>TextString</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Array</db:enumidentifier>
<db:enumvalue>0x80</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Map</db:enumidentifier>
<db:enumvalue>0xa0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Tag</db:enumidentifier>
<db:enumvalue>0xc0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SimpleType</db:enumidentifier>
<db:enumvalue>0xe0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>HalfFloat</db:enumidentifier>
<db:enumvalue>0xf9</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Float16</db:enumidentifier>
<db:enumvalue>HalfFloat</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Float</db:enumidentifier>
<db:enumvalue>0xfa</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Double</db:enumidentifier>
<db:enumvalue>0xfb</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Invalid</db:enumidentifier>
<db:enumvalue>0xff</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enumeration contains all possible CBOR types as decoded by <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link>. CBOR has 7 major types, plus a number of simple types carrying no value, and floating point values.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::UnsignedInteger</db:code></db:para>
</db:td>
<db:td><db:code>0x00</db:code></db:td>
<db:td>
<db:para>(Major type 0) Ranges from 0 to 2<db:superscript>64</db:superscript> - 1 (18,446,744,073,709,551,616)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::NegativeInteger</db:code></db:para>
</db:td>
<db:td><db:code>0x20</db:code></db:td>
<db:td>
<db:para>(Major type 1) Ranges from -1 to -2<db:superscript>64</db:superscript> (-18,446,744,073,709,551,616)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::ByteArray</db:code></db:para>
</db:td>
<db:td><db:code>ByteString</db:code></db:td>
<db:td>
<db:para>(Major type 2) Arbitrary binary data.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::ByteString</db:code></db:para>
</db:td>
<db:td><db:code>0x40</db:code></db:td>
<db:td>
<db:para>An alias to ByteArray.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::String</db:code></db:para>
</db:td>
<db:td><db:code>TextString</db:code></db:td>
<db:td>
<db:para>(Major type 3) Unicode text, possibly containing NULs.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::TextString</db:code></db:para>
</db:td>
<db:td><db:code>0x60</db:code></db:td>
<db:td>
<db:para>An alias to String</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::Array</db:code></db:para>
</db:td>
<db:td><db:code>0x80</db:code></db:td>
<db:td>
<db:para>(Major type 4) Array of heterogeneous items.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::Map</db:code></db:para>
</db:td>
<db:td><db:code>0xa0</db:code></db:td>
<db:td>
<db:para>(Major type 5) Map/dictionary of heterogeneous items.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::Tag</db:code></db:para>
</db:td>
<db:td><db:code>0xc0</db:code></db:td>
<db:td>
<db:para>(Major type 6) Numbers giving further semantic value to generic CBOR items. See <db:link xlink:href="qtcborcommon.xml#QCborTag-enum">QCborTag</db:link> for more information.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::SimpleType</db:code></db:para>
</db:td>
<db:td><db:code>0xe0</db:code></db:td>
<db:td>
<db:para>(Major type 7) Types carrying no further value. Includes booleans (true and false), null, undefined.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::Float16</db:code></db:para>
</db:td>
<db:td><db:code>HalfFloat</db:code></db:td>
<db:td>
<db:para>IEEE 754 half-precision floating point (qfloat16).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::HalfFloat</db:code></db:para>
</db:td>
<db:td><db:code>0xf9</db:code></db:td>
<db:td>
<db:para>An alias to Float16.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::Float</db:code></db:para>
</db:td>
<db:td><db:code>0xfa</db:code></db:td>
<db:td>
<db:para>IEEE 754 single-precision floating point (<db:code>float</db:code>).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::Double</db:code></db:para>
</db:td>
<db:td><db:code>0xfb</db:code></db:td>
<db:td>
<db:para>IEEE 754 double-precision floating point (<db:code>double</db:code>).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:emphasis>::Invalid</db:code></db:para>
</db:td>
<db:td><db:code>0xff</db:code></db:td>
<db:td>
<db:para>Not a valid type, either due to parsing error or due to reaching the end of an array or map.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QCborStreamReader">
<db:title>QCborStreamReader::QCborStreamReader()</db:title>
<db:constructorsynopsis>
<db:methodname>QCborStreamReader</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborStreamReader()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> object with no source data. After construction, <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> will report an error parsing.</db:para>
<db:para>You can add more data by calling <db:link xlink:href="qcborstreamreader.xml#addData">addData</db:link>() or by setting a different source device using <db:link xlink:href="qcborstreamreader.xml#setDevice">setDevice</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#addData">addData</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborStreamReader-1">
<db:title>QCborStreamReader::QCborStreamReader(const char *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborStreamReader</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborStreamReader(const char *data, qsizetype len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates a <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> object with <db:code role="parameter">len</db:code> bytes of data starting at <db:code role="parameter">data</db:code>. The pointer must remain valid until <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> is destroyed.</db:para>
</db:section>
<db:section xml:id="QCborStreamReader-2">
<db:title>QCborStreamReader::QCborStreamReader(const quint8 *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborStreamReader</db:methodname>
<db:methodparam>
<db:type>const quint8 *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborStreamReader(const quint8 *data, qsizetype len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates a <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> object with <db:code role="parameter">len</db:code> bytes of data starting at <db:code role="parameter">data</db:code>. The pointer must remain valid until <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> is destroyed.</db:para>
</db:section>
<db:section xml:id="QCborStreamReader-3">
<db:title>[explicit] QCborStreamReader::QCborStreamReader(const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborStreamReader</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborStreamReader(const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates a <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> object that will parse the CBOR stream found in <db:code role="parameter">data</db:code>.</db:para>
</db:section>
<db:section xml:id="QCborStreamReader-4">
<db:title>[explicit] QCborStreamReader::QCborStreamReader(QIODevice *<db:emphasis>device</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborStreamReader</db:methodname>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborStreamReader(QIODevice *device)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates a <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> object that will parse the CBOR stream found by reading from <db:code role="parameter">device</db:code>. <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> does not take ownership of <db:code role="parameter">device</db:code>, so it must remain valid until this oject is destroyed.</db:para>
</db:section>
<db:section xml:id="dtor.QCborStreamReader">
<db:title>QCborStreamReader::~QCborStreamReader()</db:title>
<db:destructorsynopsis>
<db:methodname>~QCborStreamReader</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QCborStreamReader()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys this <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> object and frees any associated resources.</db:para>
</db:section>
<db:section xml:id="addData">
<db:title>void QCborStreamReader::addData(const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addData</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addData(const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds <db:code role="parameter">data</db:code> to the CBOR stream and reparses the current element. This function is useful if the end of the data was previously reached while processing the stream, but now more data is available.</db:para>
</db:section>
<db:section xml:id="addData-1">
<db:title>void QCborStreamReader::addData(const char *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addData</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void addData(const char *data, qsizetype len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Adds <db:code role="parameter">len</db:code> bytes of data starting at <db:code role="parameter">data</db:code> to the CBOR stream and reparses the current element. This function is useful if the end of the data was previously reached while processing the stream, but now more data is available.</db:para>
</db:section>
<db:section xml:id="addData-2">
<db:title>void QCborStreamReader::addData(const quint8 *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addData</db:methodname>
<db:methodparam>
<db:type>const quint8 *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>len</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void addData(const quint8 *data, qsizetype len)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Adds <db:code role="parameter">len</db:code> bytes of data starting at <db:code role="parameter">data</db:code> to the CBOR stream and reparses the current element. This function is useful if the end of the data was previously reached while processing the stream, but now more data is available.</db:para>
</db:section>
<db:section xml:id="clear">
<db:title>void QCborStreamReader::clear()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clear</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clear()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Clears the decoder state and resets the input source data to an empty byte array. After this function is called, <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> will be indicating an error parsing.</db:para>
<db:para>Call <db:link xlink:href="qcborstreamreader.xml#addData">addData</db:link>() to add more data to be parsed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#reset">reset</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#setDevice">setDevice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="containerDepth">
<db:title>int QCborStreamReader::containerDepth() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>containerDepth</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int containerDepth() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of containers that this stream has entered with <db:link xlink:href="qcborstreamreader.xml#enterContainer">enterContainer</db:link>() but not yet left.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#enterContainer">enterContainer</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#leaveContainer">leaveContainer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentOffset">
<db:title>qint64 QCborStreamReader::currentOffset() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>currentOffset</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 currentOffset() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the offset in the input stream of the item currently being decoded. The current offset is the number of decoded bytes so far only if the source data is a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> or it is a <db:link xlink:href="qiodevice.xml">QIODevice</db:link> that was positioned at its beginning when decoding started.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#reset">reset</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#clear">clear</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#device">device</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentStringChunkSize">
<db:title>qsizetype QCborStreamReader::currentStringChunkSize() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>currentStringChunkSize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype currentStringChunkSize() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the size of the current text or byte string chunk. If the CBOR stream contains a non-chunked string (that is, if <db:link xlink:href="qcborstreamreader.xml#isLengthKnown">isLengthKnown</db:link>() returns true), this function returns the size of the entire string, the same as <db:link xlink:href="qcborstreamreader.xml#length">length</db:link>().</db:para>
<db:para>This function is useful to pre-allocate the buffer whose pointer can be passed to <db:link xlink:href="qcborstreamreader.xml#readStringChunk">readStringChunk</db:link>() later.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#readString">readString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readByteArray">readByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readStringChunk">readStringChunk</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="device">
<db:title>QIODevice *QCborStreamReader::device() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QIODevice *</db:type>
<db:methodname>device</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QIODevice * device() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> that was set with either <db:link xlink:href="qcborstreamreader.xml#setDevice">setDevice</db:link>() or the <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> constructor. If this object was reading from a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, this function returns nullptr instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#setDevice">setDevice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="enterContainer">
<db:title>bool QCborStreamReader::enterContainer()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>enterContainer</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool enterContainer()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Enters the array or map that is the current item and prepares for iterating the elements contained in the container. Returns true if entering the container succeeded, false otherwise (usually, a parsing error). Each call to enterContainer() must be paired with a call to <db:link xlink:href="qcborstreamreader.xml#leaveContainer">leaveContainer</db:link>().</db:para>
<db:para>This function may only be called if the current item is an array or a map (that is, if <db:link xlink:href="qcborstreamreader.xml#isArray">isArray</db:link>(), <db:link xlink:href="qcborstreamreader.xml#isMap">isMap</db:link>() or <db:link xlink:href="qcborstreamreader.xml#isContainer">isContainer</db:link>() is true). Calling it in any other condition is an error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#leaveContainer">leaveContainer</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isContainer">isContainer</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isArray">isArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isMap">isMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasNext">
<db:title>bool QCborStreamReader::hasNext() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasNext</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasNext() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if there are more items to be decoded in the current container or false of we've reached its end. If we're parsing the root element, hasNext() returning false indicates the parsing is complete; otherwise, if the container depth is non-zero, then the outer code needs to call <db:link xlink:href="qcborstreamreader.xml#leaveContainer">leaveContainer</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#parentContainerType">parentContainerType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#containerDepth">containerDepth</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#leaveContainer">leaveContainer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isArray">
<db:title>bool QCborStreamReader::isArray() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isArray() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is an array (that is, if <db:link xlink:href="qcborstreamreader.xml#type">type</db:link>() returns <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::Array</db:link>). If this function returns true, you may call <db:link xlink:href="qcborstreamreader.xml#enterContainer">enterContainer</db:link>() to begin parsing that container.</db:para>
<db:para>When the current element is an array, you may also call <db:link xlink:href="qcborstreamreader.xml#isLengthKnown">isLengthKnown</db:link>() to find out if the array's size is explicit in the CBOR stream. If it is, that size can be obtained by calling <db:link xlink:href="qcborstreamreader.xml#length">length</db:link>().</db:para>
<db:para>The following example pre-allocates a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> given the array's size for more efficient decoding:</db:para>
<db:programlisting language="cpp">   QVariantList populateFromCbor(QCborStreamReader &amp;amp;reader)
   {
       QVariantList list;
       if (reader.isLengthKnown())
           list.reserve(reader.length());

       reader.enterContainer();
       while (reader.lastError() == QCborError::NoError &amp;amp;&amp;amp; reader.hasNext())
           list.append(readOneElement(reader));
       if (reader.lastError() == QCborError::NoError)
           reader.leaveContainer();
   }
</db:programlisting>
<db:note>
<db:para>The code above does not validate that the length is a sensible value. If the input stream reports that the length is 1 billion elements, the above function will try to allocate some 16 GB or more of RAM, which can lead to a crash.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isMap">isMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isLengthKnown">isLengthKnown</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#length">length</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#enterContainer">enterContainer</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#leaveContainer">leaveContainer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isBool">
<db:title>bool QCborStreamReader::isBool() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isBool</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isBool() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the current element is a boolean value (true or false), false if it is anything else. If this function returns true, you may call <db:link xlink:href="qcborstreamreader.xml#toBool">toBool</db:link>() to retrieve the value of the boolean. You may also call <db:link xlink:href="qcborstreamreader.xml#toSimpleType">toSimpleType</db:link>() and compare to either QCborSimpleValue::True or QCborSimpleValue::False.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isFalse">isFalse</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toBool">toBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isSimpleType">isSimpleType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toSimpleType">toSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isByteArray">
<db:title>bool QCborStreamReader::isByteArray() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isByteArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isByteArray() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is a byte array (that is, if <db:link xlink:href="qcborstreamreader.xml#type">type</db:link>() returns <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::ByteArray</db:link>). If this function returns true, you may call <db:link xlink:href="qcborstreamreader.xml#readByteArray">readByteArray</db:link>() to read that data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readByteArray">readByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isString">isString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isContainer">
<db:title>bool QCborStreamReader::isContainer() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isContainer</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isContainer() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the current element is a container (that is, an array or a map), false if it is anything else. If the current element is a container, the <db:link xlink:href="qcborstreamreader.xml#isLengthKnown">isLengthKnown</db:link>() function may be used to find out if the container's size is explicit in the stream and, if so, <db:link xlink:href="qcborstreamreader.xml#length">length</db:link>() can be used to get that size.</db:para>
<db:para>More importantly, for a container, the <db:link xlink:href="qcborstreamreader.xml#enterContainer">enterContainer</db:link>() function is available to begin iterating through the elements contained therein.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isArray">isArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isMap">isMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isLengthKnown">isLengthKnown</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#length">length</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#enterContainer">enterContainer</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#leaveContainer">leaveContainer</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#containerDepth">containerDepth</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isDouble">
<db:title>bool QCborStreamReader::isDouble() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isDouble</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isDouble() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is an IEEE 754 double-precision floating point (that is, if <db:link xlink:href="qcborstreamreader.xml#type">type</db:link>() returns <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::Double</db:link>). If this function returns true, you may call <db:link xlink:href="qcborstreamreader.xml#toDouble">toDouble</db:link>() to read that data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toDouble">toDouble</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isFloat16">isFloat16</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isFloat">isFloat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isFalse">
<db:title>bool QCborStreamReader::isFalse() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFalse</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFalse() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the current element is the false value, false if it is anything else.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isBool">isBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toBool">toBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isSimpleType">isSimpleType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toSimpleType">toSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isFloat16">
<db:title>bool QCborStreamReader::isFloat16() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFloat16</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFloat16() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is an IEEE 754 half-precision floating point (that is, if <db:link xlink:href="qcborstreamreader.xml#type">type</db:link>() returns <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::Float16</db:link>). If this function returns true, you may call <db:link xlink:href="qcborstreamreader.xml#toFloat16">toFloat16</db:link>() to read that data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toFloat16">toFloat16</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isFloat">isFloat</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isDouble">isDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isFloat">
<db:title>bool QCborStreamReader::isFloat() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFloat</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFloat() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is an IEEE 754 single-precision floating point (that is, if <db:link xlink:href="qcborstreamreader.xml#type">type</db:link>() returns <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::Float</db:link>). If this function returns true, you may call <db:link xlink:href="qcborstreamreader.xml#toFloat">toFloat</db:link>() to read that data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toFloat">toFloat</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isFloat16">isFloat16</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isDouble">isDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isInteger">
<db:title>bool QCborStreamReader::isInteger() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isInteger</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isInteger() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is either an unsigned integer or a negative one (that is, if <db:link xlink:href="qcborstreamreader.xml#type">type</db:link>() returns <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::UnsignedInteger</db:link> or <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::NegativeInteger</db:link>). If this function returns true, you may call <db:link xlink:href="qcborstreamreader.xml#toInteger">toInteger</db:link>() to read that value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toInteger">toInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toUnsignedInteger">toUnsignedInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toNegativeInteger">toNegativeInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isUnsignedInteger">isUnsignedInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isNegativeInteger">isNegativeInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isInvalid">
<db:title>bool QCborStreamReader::isInvalid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isInvalid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isInvalid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the current element is invalid, false otherwise. The current element may be invalid if there was a decoding error or we've just parsed the last element in an array or map.</db:para>
<db:note>
<db:para>This function is not to be confused with <db:link xlink:href="qcborstreamreader.xml#isNull">isNull</db:link>(). Null is a normal CBOR type that must be handled by the application.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isLengthKnown">
<db:title>bool QCborStreamReader::isLengthKnown() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isLengthKnown</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isLengthKnown() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the length of the current array, map, byte array or string is known (explicit in the CBOR stream), false otherwise. This function should only be called if the element is one of those.</db:para>
<db:para>If the length is known, it may be obtained by calling <db:link xlink:href="qcborstreamreader.xml#length">length</db:link>().</db:para>
<db:para>If the length of a map or an array is not known, it is implied by the number of elements present in the stream. <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> has no API to calculate the length in that condition.</db:para>
<db:para>Strings and byte arrays may also have indeterminate length (that is, they may be transmitted in multiple chunks). Those cannot currently be created with <db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link>, but they could be with other encoders, so <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> supports them.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#length">length</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#startArray">QCborStreamWriter::startArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#startMap">QCborStreamWriter::startMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isMap">
<db:title>bool QCborStreamReader::isMap() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isMap</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isMap() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is a map (that is, if <db:link xlink:href="qcborstreamreader.xml#type">type</db:link>() returns <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::Map</db:link>). If this function returns true, you may call <db:link xlink:href="qcborstreamreader.xml#enterContainer">enterContainer</db:link>() to begin parsing that container.</db:para>
<db:para>When the current element is a map, you may also call <db:link xlink:href="qcborstreamreader.xml#isLengthKnown">isLengthKnown</db:link>() to find out if the map's size is explicit in the CBOR stream. If it is, that size can be obtained by calling <db:link xlink:href="qcborstreamreader.xml#length">length</db:link>().</db:para>
<db:para>The following example pre-allocates a <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> given the map's size for more efficient decoding:</db:para>
<db:programlisting language="cpp">   QVariantMap populateFromCbor(QCborStreamReader &amp;amp;reader)
   {
       QVariantMap map;
       if (reader.isLengthKnown())
           map.reserve(reader.length());

       reader.enterContainer();
       while (reader.lastError() == QCborError::NoError &amp;amp;&amp;amp; reader.hasNext()) {
           QString key = readElementAsString(reader);
           map.insert(key, readOneElement(reader));
       }
       if (reader.lastError() == QCborError::NoError)
           reader.leaveContainer();
   }
</db:programlisting>
<db:para>The example above uses a function called readElementAsString to read the map's keys and obtain a string. That is because CBOR maps may contain any type as keys, not just strings. User code needs to either perform this conversion, reject non-string keys, or instead use a different container besides <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> and <db:link xlink:href="qvariant.xml#QVariantHash-typedef">QVariantHash</db:link>. For example, if the map is expected to contain integer keys, which is recommended as it reduces stream size and parsing, the correct container would be \l{QMap}&lt;int, QVariant&gt; or \l{QHash}&lt;int, QVariant&gt;.</db:para>
<db:note>
<db:para>The code above does not validate that the length is a sensible value. If the input stream reports that the length is 1 billion elements, the above function will try to allocate some 24 GB or more of RAM, which can lead to a crash.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isArray">isArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isLengthKnown">isLengthKnown</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#length">length</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#enterContainer">enterContainer</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#leaveContainer">leaveContainer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isNegativeInteger">
<db:title>bool QCborStreamReader::isNegativeInteger() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isNegativeInteger</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isNegativeInteger() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is a negative integer (that is if <db:link xlink:href="qcborstreamreader.xml#type">type</db:link>() returns <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::NegativeInteger</db:link>). If this function returns true, you may call <db:link xlink:href="qcborstreamreader.xml#toNegativeInteger">toNegativeInteger</db:link>() or <db:link xlink:href="qcborstreamreader.xml#toInteger">toInteger</db:link>() to read that value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toNegativeInteger">toNegativeInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toInteger">toInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isInteger">isInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isUnsignedInteger">isUnsignedInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QCborStreamReader::isNull() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isNull</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isNull() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the current element is the null value, false if it is anything else. Null values may be used to indicate the absence of some optional data.</db:para>
<db:note>
<db:para>This function is not the opposite of <db:link xlink:href="qcborstreamreader.xml#isValid">isValid</db:link>(). A Null value is a valid CBOR value.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isSimpleType">isSimpleType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toSimpleType">toSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSimpleType">
<db:title>bool QCborStreamReader::isSimpleType() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSimpleType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSimpleType() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is any CBOR simple type, including a boolean value (true and false) as well as null and undefined. To find out which simple type this is, call <db:link xlink:href="qcborstreamreader.xml#toSimpleType">toSimpleType</db:link>(). Alternatively, to test for one specific simple type, call the overload that takes a <db:link xlink:href="qtcborcommon.xml#QCborSimpleType-enum">QCborSimpleType</db:link> parameter.</db:para>
<db:para>CBOR simple types are types that do not carry extra value. There are 255 possibilities, but there are currently only four values that have defined meaning. Code is not expected to cope with unknown simple types and may simply discard the stream as invalid if it finds an unknown one.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcborcommon.xml#QCborSimpleType-enum">QCborSimpleType</db:link></db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isSimpleType-1">isSimpleType</db:link>(QCborSimpleType)</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toSimpleType">toSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSimpleType-1">
<db:title>bool QCborStreamReader::isSimpleType(QCborSimpleType <db:emphasis>st</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSimpleType</db:methodname>
<db:methodparam>
<db:type>QCborSimpleType</db:type>
<db:parameter>st</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSimpleType(QCborSimpleType st) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is the simple type <db:code role="parameter">st</db:code>, false otherwise. If this function returns true, then <db:link xlink:href="qcborstreamreader.xml#toSimpleType">toSimpleType</db:link>() will return <db:code role="parameter">st</db:code>.</db:para>
<db:para>CBOR simple types are types that do not carry extra value. There are 255 possibilities, but there are currently only four values that have defined meaning. Code is not expected to cope with unknown simple types and may simply discard the stream as invalid if it finds an unknown one.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcborcommon.xml#QCborSimpleType-enum">QCborSimpleType</db:link></db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isSimpleType">isSimpleType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toSimpleType">toSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isString">
<db:title>bool QCborStreamReader::isString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is a text string (that is, if <db:link xlink:href="qcborstreamreader.xml#type">type</db:link>() returns <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::String</db:link>). If this function returns true, you may call <db:link xlink:href="qcborstreamreader.xml#readString">readString</db:link>() to read that data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readString">readString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isByteArray">isByteArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isTag">
<db:title>bool QCborStreamReader::isTag() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isTag</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isTag() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is a CBOR tag (that is, if <db:link xlink:href="qcborstreamreader.xml#type">type</db:link>() returns <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::Tag</db:link>). If this function returns true, you may call <db:link xlink:href="qcborstreamreader.xml#toTag">toTag</db:link>() to read that data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toTag">toTag</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isTrue">
<db:title>bool QCborStreamReader::isTrue() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isTrue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isTrue() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the current element is the true value, false if it is anything else.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isFalse">isFalse</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isBool">isBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toBool">toBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isSimpleType">isSimpleType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toSimpleType">toSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isUndefined">
<db:title>bool QCborStreamReader::isUndefined() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isUndefined</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isUndefined() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the current element is the undefined value, false if it is anything else. Undefined values may be encoded to indicate that some conversion failed or was not possible when creating the stream. <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> never performs any replacement and this function will only return true if the stream contains an explicit undefined value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isSimpleType">isSimpleType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toSimpleType">toSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isUnsignedInteger">
<db:title>bool QCborStreamReader::isUnsignedInteger() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isUnsignedInteger</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isUnsignedInteger() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the type of the current element is an unsigned integer (that is if <db:link xlink:href="qcborstreamreader.xml#type">type</db:link>() returns <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::UnsignedInteger</db:link>). If this function returns true, you may call <db:link xlink:href="qcborstreamreader.xml#toUnsignedInteger">toUnsignedInteger</db:link>() or <db:link xlink:href="qcborstreamreader.xml#toInteger">toInteger</db:link>() to read that value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toUnsignedInteger">toUnsignedInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toInteger">toInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isInteger">isInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isNegativeInteger">isNegativeInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QCborStreamReader::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the current element is valid, false otherwise. The current element may be invalid if there was a decoding error or we've just parsed the last element in an array or map.</db:para>
<db:note>
<db:para>This function is not the opposite of <db:link xlink:href="qcborstreamreader.xml#isNull">isNull</db:link>(). Null is a normal CBOR type that must be handled by the application.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isInvalid">isInvalid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lastError">
<db:title>QCborError QCborStreamReader::lastError()</db:title>
<db:methodsynopsis>
<db:type>QCborError</db:type>
<db:methodname>lastError</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborError lastError()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the last error in decoding the stream, if any. If no error was encountered, this returns an <db:link xlink:href="qcborerror.xml#Code-enum">QCborError::NoError</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="leaveContainer">
<db:title>bool QCborStreamReader::leaveContainer()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>leaveContainer</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool leaveContainer()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Leaves the array or map whose items were being processed and positions the decoder at the next item after the end of the container. Returns true if leaving the container succeeded, false otherwise (usually, a parsing error). Each call to <db:link xlink:href="qcborstreamreader.xml#enterContainer">enterContainer</db:link>() must be paired with a call to leaveContainer().</db:para>
<db:para>This function may only be called if <db:link xlink:href="qcborstreamreader.xml#hasNext">hasNext</db:link>() has returned false and <db:link xlink:href="qcborstreamreader.xml#containerDepth">containerDepth</db:link>() is not zero. Calling it in any other condition is an error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#enterContainer">enterContainer</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#parentContainerType">parentContainerType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#containerDepth">containerDepth</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="length">
<db:title>quint64 QCborStreamReader::length() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint64</db:type>
<db:methodname>length</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint64 length() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the length of the string or byte array, or the number of items in an array or the number, of item pairs in a map, if known. This function must not be called if the length is unknown (that is, if <db:link xlink:href="qcborstreamreader.xml#isLengthKnown">isLengthKnown</db:link>() returned false). It is an error to do that and it will cause <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> to stop parsing the input stream.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isLengthKnown">isLengthKnown</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#startArray">QCborStreamWriter::startArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml#startMap">QCborStreamWriter::startMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="next">
<db:title>bool QCborStreamReader::next(int <db:emphasis>maxRecursion</db:emphasis> = 10000)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>next</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>maxRecursion</db:parameter>
<db:initializer>10000</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool next(int maxRecursion)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Advance the CBOR stream decoding one element. You should usually call this function when parsing fixed-width basic elements (that is, integers, simple values, tags and floating point values). But this function can be called when the current item is a string, array or map too and it will skip over that entire element, including all contained elements.</db:para>
<db:para>This function returns true if advancing was successful, false otherwise. It may fail if the stream is corrupt, incomplete or if the nesting level of arrays and maps exceeds <db:code role="parameter">maxRecursion</db:code>. Calling this function when <db:link xlink:href="qcborstreamreader.xml#hasNext">hasNext</db:link>() has returned false is also an error. If this function returns false, <db:link xlink:href="qcborstreamreader.xml#lastError">lastError</db:link>() will return the error code detailing what the failure was.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#lastError">lastError</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#hasNext">hasNext</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="parentContainerType">
<db:title>QCborStreamReader::Type QCborStreamReader::parentContainerType() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborStreamReader::Type</db:type>
<db:methodname>parentContainerType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborStreamReader::Type parentContainerType() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns either <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::Array</db:link> or <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::Map</db:link>, indicating whether the container that contains the current item was an array or map, respectively. If we're currently parsing the root element, this function returns <db:link xlink:href="qcborstreamreader.xml#Type-enum">QCborStreamReader::Invalid</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#containerDepth">containerDepth</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#enterContainer">enterContainer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readByteArray">
<db:title>StringResult&lt;QByteArray&gt; QCborStreamReader::readByteArray()</db:title>
<db:methodsynopsis>
<db:type>StringResult&lt;QByteArray&gt;</db:type>
<db:methodname>readByteArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">StringResult&lt;QByteArray&gt; readByteArray()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Decodes one byte array chunk from the CBOR string and returns it. This function is used for both regular and chunked contents, so the caller must always loop around calling this function, even if <db:link xlink:href="qcborstreamreader.xml#isLengthKnown">isLengthKnown</db:link>() has is true. The typical use of this function is as follows:</db:para>
<db:programlisting language="cpp">   QBytearray decodeBytearray(QCborStreamReader &amp;amp;reader)
   {
       QBytearray result;
       auto r = reader.readBytearray();
       while (r.code == QCborStreamReader::Ok) {
           result += r.data;
           r = reader.readByteArray();
       }

       if (r.code == QCborStreamReader::Error) {
           // handle error condition
           result.clear();
       }
       return result;
   }
</db:programlisting>
<db:para>This function does not perform any type conversions, including from integers or from strings. Therefore, it may only be called if <db:link xlink:href="qcborstreamreader.xml#isByteArray">isByteArray</db:link>() is true; calling it in any other condition is an error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#readString">readString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isByteArray">isByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readStringChunk">readStringChunk</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readString">
<db:title>StringResult&lt;QString&gt; QCborStreamReader::readString()</db:title>
<db:methodsynopsis>
<db:type>StringResult&lt;QString&gt;</db:type>
<db:methodname>readString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">StringResult&lt;QString&gt; readString()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Decodes one string chunk from the CBOR string and returns it. This function is used for both regular and chunked string contents, so the caller must always loop around calling this function, even if <db:link xlink:href="qcborstreamreader.xml#isLengthKnown">isLengthKnown</db:link>() has is true. The typical use of this function is as follows:</db:para>
<db:programlisting language="cpp">   QString decodeString(QCborStreamReader &amp;amp;reader)
   {
       QString result;
       auto r = reader.readString();
       while (r.code == QCborStreamReader::Ok) {
           result += r.data;
           r = reader.readString();
       }

       if (r.code == QCborStreamReader::Error) {
           // handle error condition
           result.clear();
       }
       return result;
   }
</db:programlisting>
<db:para>This function does not perform any type conversions, including from integers or from byte arrays. Therefore, it may only be called if <db:link xlink:href="qcborstreamreader.xml#isString">isString</db:link>() returned true; calling it in any other condition is an error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#readByteArray">readByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isString">isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readStringChunk">readStringChunk</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readStringChunk">
<db:title>StringResult&lt;qsizetype&gt; QCborStreamReader::readStringChunk(char *<db:emphasis>ptr</db:emphasis>, qsizetype <db:emphasis>maxlen</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>StringResult&lt;qsizetype&gt;</db:type>
<db:methodname>readStringChunk</db:methodname>
<db:methodparam>
<db:type>char *</db:type>
<db:parameter>ptr</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>maxlen</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">StringResult&lt;qsizetype&gt; readStringChunk(char *ptr, qsizetype maxlen)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads the current string chunk into the buffer pointed to by <db:code role="parameter">ptr</db:code>, whose size is <db:code role="parameter">maxlen</db:code>. This function returns a <db:link xlink:href="qcborstreamreader-stringresult.xml">StringResult</db:link> object, with the number of bytes copied into <db:code role="parameter">ptr</db:code> saved in the \l <db:link xlink:href="qcborstreamreader-stringresult.xml#data-var">StringResult::data</db:link> member. The \l <db:link xlink:href="qcborstreamreader-stringresult.xml#status-var">StringResult::status</db:link> member indicates whether there was an error reading the string, whether data was copied or whether this was the last chunk.</db:para>
<db:para>This function can be called for both <db:link xlink:href="qcborstreamreader.xml#Type-enum">String</db:link> and <db:link xlink:href="qcborstreamreader.xml#Type-enum">ByteArray</db:link> types. For the latter, this function will read the same data that <db:link xlink:href="qcborstreamreader.xml#readByteArray">readByteArray</db:link>() would have returned. For strings, it returns the UTF-8 equivalent of the <db:link xlink:href="qstring.xml">QString</db:link> that would have been returned.</db:para>
<db:para>This function is usually used alongside <db:link xlink:href="qcborstreamreader.xml#currentStringChunkSize">currentStringChunkSize</db:link>() in a loop. For example:</db:para>
<db:programlisting language="cpp">    QCborStreamReader&amp;lt;qsizetype&amp;gt; result;
    do {
        qsizetype size = reader.currentStringChunkSize();
        qsizetype oldsize = buffer.size();
        buffer.resize(oldsize + size);
        result = reader.readStringChunk(buffer.data() + oldsize, size);
    } while (result.status() == QCborStreamReader::Ok);
</db:programlisting>
<db:para>Unlike <db:link xlink:href="qcborstreamreader.xml#readByteArray">readByteArray</db:link>() and <db:link xlink:href="qcborstreamreader.xml#readString">readString</db:link>(), this function is not limited by implementation limits of <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
<db:note>
<db:para>This function does not perform verification that the UTF-8 contents are properly formatted. That means this function does not produce the <db:link xlink:href="qcborerror.xml#Code-enum">QCborError::InvalidUtf8String</db:link> error, even when <db:link xlink:href="qcborstreamreader.xml#readString">readString</db:link>() does.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#currentStringChunkSize">currentStringChunkSize</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readString">readString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#readByteArray">readByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isString">isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isByteArray">isByteArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reparse">
<db:title>void QCborStreamReader::reparse()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>reparse</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void reparse()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reparses the current element. This function must be called when more data becomes available in the source <db:link xlink:href="qiodevice.xml">QIODevice</db:link> after parsing failed due to reaching the end of the input data before the end of the CBOR stream.</db:para>
<db:para>When reading from QByteArray(), the <db:link xlink:href="qcborstreamreader.xml#addData">addData</db:link>() function automatically calls this function. Calling it when the reading had not failed is a no-op.</db:para>
</db:section>
<db:section xml:id="reset">
<db:title>void QCborStreamReader::reset()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>reset</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void reset()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Resets the source back to the beginning and clears the decoder state. If the source data was a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link> will restart from the beginning of the array.</db:para>
<db:para>If the source data is a <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, this function will call <db:link xlink:href="qiodevice.xml#reset">QIODevice::reset</db:link>(), which will seek to byte position 0. If the CBOR stream is not found at the beginning of the device (e.g., beginning of a file), then this function will likely do the wrong thing. Instead, position the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> to the right offset and call <db:link xlink:href="qcborstreamreader.xml#setDevice">setDevice</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#clear">clear</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#setDevice">setDevice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDevice">
<db:title>void QCborStreamReader::setDevice(QIODevice *<db:emphasis>device</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setDevice</db:methodname>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setDevice(QIODevice *device)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the source of data to <db:code role="parameter">device</db:code>, resetting the decoder to its initial state.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#device">device</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toBool">
<db:title>bool QCborStreamReader::toBool() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>toBool</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool toBool() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the boolean value of the current element.</db:para>
<db:para>This function does not perform any type conversions, including from integer. Therefore, it may only be called if <db:link xlink:href="qcborstreamreader.xml#isTrue">isTrue</db:link>(), <db:link xlink:href="qcborstreamreader.xml#isFalse">isFalse</db:link>() or <db:link xlink:href="qcborstreamreader.xml#isBool">isBool</db:link>() returned true; calling it in any other condition is an error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isBool">isBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isFalse">isFalse</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toInteger">toInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDouble">
<db:title>double QCborStreamReader::toDouble() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>double</db:type>
<db:methodname>toDouble</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">double toDouble() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the 64-bit double-precision floating point value of the current element.</db:para>
<db:para>This function does not perform any type conversions, including from other floating point types or from integer values. Therefore, it may only be called if <db:link xlink:href="qcborstreamreader.xml#isDouble">isDouble</db:link>() is true; calling it in any other condition is an error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isDouble">isDouble</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toFloat16">toFloat16</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toFloat">toFloat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toFloat16">
<db:title>qfloat16 QCborStreamReader::toFloat16() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qfloat16</db:type>
<db:methodname>toFloat16</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qfloat16 toFloat16() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the 16-bit half-precision floating point value of the current element.</db:para>
<db:para>This function does not perform any type conversions, including from other floating point types or from integer values. Therefore, it may only be called if <db:link xlink:href="qcborstreamreader.xml#isFloat16">isFloat16</db:link>() is true; calling it in any other condition is an error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isFloat16">isFloat16</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toFloat">toFloat</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toDouble">toDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toFloat">
<db:title>float QCborStreamReader::toFloat() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>float</db:type>
<db:methodname>toFloat</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">float toFloat() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the 32-bit single-precision floating point value of the current element.</db:para>
<db:para>This function does not perform any type conversions, including from other floating point types or from integer values. Therefore, it may only be called if <db:link xlink:href="qcborstreamreader.xml#isFloat">isFloat</db:link>() is true; calling it in any other condition is an error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isFloat">isFloat</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toFloat16">toFloat16</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toDouble">toDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toInteger">
<db:title>qint64 QCborStreamReader::toInteger() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>toInteger</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 toInteger() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the integer value of the current element, be it negative, positive or zero. If the value is larger than 2<db:superscript>63</db:superscript> - 1 or smaller than -2<db:superscript>63</db:superscript>, the returned value will overflow and will have an incorrect sign. If handling those values is required, use <db:link xlink:href="qcborstreamreader.xml#toUnsignedInteger">toUnsignedInteger</db:link>() or <db:link xlink:href="qcborstreamreader.xml#toNegativeInteger">toNegativeInteger</db:link>() instead.</db:para>
<db:para>This function does not perform any type conversions, including from boolean or CBOR tag. Therefore, it may only be called if <db:link xlink:href="qcborstreamreader.xml#isInteger">isInteger</db:link>() is true; calling it in any other condition is an error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isInteger">isInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toUnsignedInteger">toUnsignedInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toNegativeInteger">toNegativeInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toNegativeInteger">
<db:title>QCborNegativeInteger QCborStreamReader::toNegativeInteger() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborNegativeInteger</db:type>
<db:methodname>toNegativeInteger</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborNegativeInteger toNegativeInteger() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the negative integer value of the current element. QCborNegativeValue is a 64-bit unsigned integer containing the absolute value of the negative number that was stored in the CBOR stream. Additionally, QCborNegativeValue(0) represents the number -2<db:superscript>64</db:superscript>.</db:para>
<db:para>This function does not perform any type conversions, including from boolean or CBOR tag. Therefore, it may only be called if <db:link xlink:href="qcborstreamreader.xml#isNegativeInteger">isNegativeInteger</db:link>() is true; calling it in any other condition is an error.</db:para>
<db:para>This function may be used to obtain numbers beyond the range of the return type of <db:link xlink:href="qcborstreamreader.xml#toInteger">toInteger</db:link>(). However, use of negative numbers smaller than -2<db:superscript>63</db:superscript> is extremely discouraged.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toInteger">toInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isNegativeInteger">isNegativeInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isUnsignedInteger">isUnsignedInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toSimpleType">
<db:title>QCborSimpleType QCborStreamReader::toSimpleType() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborSimpleType</db:type>
<db:methodname>toSimpleType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborSimpleType toSimpleType() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns value of the current simple type.</db:para>
<db:para>This function does not perform any type conversions, including from integer. Therefore, it may only be called if <db:link xlink:href="qcborstreamreader.xml#isSimpleType">isSimpleType</db:link>() is true; calling it in any other condition is an error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isSimpleType">isSimpleType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isFalse">isFalse</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isBool">isBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isUndefined">isUndefined</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toTag">
<db:title>QCborTag QCborStreamReader::toTag() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborTag</db:type>
<db:methodname>toTag</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborTag toTag() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the tag value of the current element.</db:para>
<db:para>This function does not perform any type conversions, including from integer. Therefore, it may only be called if <db:link xlink:href="qcborstreamreader.xml#isTag">isTag</db:link>() is true; calling it in any other condition is an error.</db:para>
<db:para>Tags are 64-bit numbers attached to generic CBOR types that give them further meaning. For a list of known tags, see the <db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">QCborKnownTags</db:link> enumeration.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isTag">isTag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toInteger">toInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">QCborKnownTags</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUnsignedInteger">
<db:title>quint64 QCborStreamReader::toUnsignedInteger() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint64</db:type>
<db:methodname>toUnsignedInteger</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint64 toUnsignedInteger() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the unsigned integer value of the current element.</db:para>
<db:para>This function does not perform any type conversions, including from boolean or CBOR tag. Therefore, it may only be called if <db:link xlink:href="qcborstreamreader.xml#isUnsignedInteger">isUnsignedInteger</db:link>() is true; calling it in any other condition is an error.</db:para>
<db:para>This function may be used to obtain numbers beyond the range of the return type of <db:link xlink:href="qcborstreamreader.xml#toInteger">toInteger</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#toInteger">toInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isUnsignedInteger">isUnsignedInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isNegativeInteger">isNegativeInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="type">
<db:title>QCborStreamReader::Type QCborStreamReader::type() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborStreamReader::Type</db:type>
<db:methodname>type</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborStreamReader::Type type() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the type of the current element. It is one of the valid types or Invalid.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborstreamreader.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isUnsignedInteger">isUnsignedInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isNegativeInteger">isNegativeInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isInteger">isInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isByteArray">isByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isString">isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isArray">isArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isMap">isMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isTag">isTag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isSimpleType">isSimpleType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isBool">isBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isFalse">isFalse</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isUndefined">isUndefined</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isFloat16">isFloat16</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isFloat">isFloat</db:link>()</db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml#isDouble">isDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
