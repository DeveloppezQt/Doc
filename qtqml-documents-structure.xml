<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Structure of a QML Document</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Qml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Description of the structure of QML documents.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>A QML document is a self contained piece of QML source code that consists of three parts:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>An optional list of pragmas</db:para>
</db:listitem>
<db:listitem>
<db:para>Its <db:emphasis>import</db:emphasis> statements</db:para>
</db:listitem>
<db:listitem>
<db:para>A single root object declaration</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>By convention, a single empty line separates the imports from the object hierarchy definition.</db:para>
<db:para>QML documents are always encoded in UTF-8 format.</db:para>
<db:section xml:id="pragmas">
<db:title>Pragmas</db:title>
<db:para>Pragmas are instructions to the QML engine itself that can be used to specify certain characteristics of objects in the current file or to modify how the engine interprets code. The following pragmas are exaplained in details below.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Singleton</db:para>
</db:listitem>
<db:listitem>
<db:para>ListPropertyAssignBehavior</db:para>
</db:listitem>
<db:listitem>
<db:para>ComponentBehavior</db:para>
</db:listitem>
<db:listitem>
<db:para>FunctionSignatureBehavior</db:para>
</db:listitem>
<db:listitem>
<db:para>NativeMethodBehavior</db:para>
</db:listitem>
<db:listitem>
<db:para>ValueTypeBehavior</db:para>
</db:listitem>
<db:listitem>
<db:para>Translator</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="singleton">
<db:title>Singleton</db:title>
<db:para>pragma Singleton declares the component defined in the QML document as singleton. Singletons are created only once per QML engine. In order to use a QML-declared singleton you also have to register it with its module. See <db:link xlink:href="qt-target-qml-sources.xml">qt_target_qml_sources</db:link> for how to do this with CMake.</db:para>
</db:section>
<db:section xml:id="listpropertyassignbehavior">
<db:title>ListPropertyAssignBehavior</db:title>
<db:para>With this pragma you can define how assignments to list properties shall be handled in components defined in the QML document. By default, assigning to a list property appends to the list. You can explicitly request this behavior using the value Append. Alternatively, you can request the contents of list properties to always be replaced using Replace, or replaced if the property is not the default property using ReplaceIfNotDefault. For example:</db:para>
<db:programlisting language="qml">pragma ListPropertyAssignBehavior: ReplaceIfNotDefault
</db:programlisting>
<db:note>
<db:para>The same declaration can also be given for C++-defined types, by adding the <db:link xlink:href="qqmllistproperty.xml#QML_LIST_PROPERTY_ASSIGN_BEHAVIOR_APPEND">QML_LIST_PROPERTY_ASSIGN_BEHAVIOR_APPEND</db:link>, <db:link xlink:href="qqmllistproperty.xml#QML_LIST_PROPERTY_ASSIGN_BEHAVIOR_REPLACE">QML_LIST_PROPERTY_ASSIGN_BEHAVIOR_REPLACE</db:link>, and <db:link xlink:href="qqmllistproperty.xml#QML_LIST_PROPERTY_ASSIGN_BEHAVIOR_REPLACE_IF_NOT_DEFAULT">QML_LIST_PROPERTY_ASSIGN_BEHAVIOR_REPLACE_IF_NOT_DEFAULT</db:link> macros to the class declaration.</db:para>
</db:note>
</db:section>
<db:section xml:id="componentbehavior">
<db:title>ComponentBehavior</db:title>
<db:para>You may have multiple components defined in the same QML file. The root scope of the QML file is a component, and you may additionally have elements of type <db:link xlink:href="qqmlcomponent.xml">QQmlComponent</db:link>, explicitly or implicitly created as properties, or inline components. Those components are nested. Each of the inner components is within one specific outer component. Most of the time, IDs defined in an outer component are accessible within all its nested inner components. You can, however, create elements from a component in any a different context, with different IDs available. Doing so breaks the assumption that outer IDs are available. Therefore, the engine and the QML tooling cannot generally know in advance what type, if any, such IDs will resolve to at run time.</db:para>
<db:para>With the ComponentBehavior pragma you can restrict all inner components defined in a file to only create objects within their original context. If a component is bound to its context, you can safely use IDs from outer components in the same file within the component. QML tooling will then assume the outer IDs with their specific types to be available.</db:para>
<db:para>In order to bind the components to their context specify the Bound argument:</db:para>
<db:programlisting language="qml">pragma ComponentBehavior: Bound
</db:programlisting>
<db:para>This implies that, in case of name clashes, IDs defined outside a bound component override local properties of objects created from the component. Otherwise it wouldn't actually be safe to use the IDs since later versions of a module might add more properties to the component. If the component is not bound, local properties override IDs defined outside the component, but not IDs defined inside the component.</db:para>
<db:para>The example below prints the <db:emphasis>r</db:emphasis> property of the ListView object with the id <db:emphasis>color</db:emphasis>, not the <db:emphasis>r</db:emphasis> property of the rectangle's color.</db:para>
<db:programlisting language="qml">pragma ComponentBehavior: Bound
import QtQuick

ListView {
 id: color
 property int r: 12
 model: 1

 delegate: Rectangle {
  Component.onCompleted: console.log(color.r)
 }
}
</db:programlisting>
<db:para>The default value of ComponentBehavior is Unbound. You can also specify it explicitly. In a future version of Qt the default will change to Bound.</db:para>
<db:para>Delegate components bound to their context don't receive their own private contexts on instantiation. This means that model data can only be passed via <db:link xlink:href="qtqml-syntax-objectattributes.xml#required-properties">required properties</db:link> in this case. Passing model data via context properties will not work. This concerns delegates to e.g. Instantiator, Repeater, ListView, TableView, GridView, TreeView and in general anything that uses DelegateModel internally.</db:para>
<db:para>For example, the following will <db:emphasis>not</db:emphasis> work:</db:para>
<db:programlisting language="qml">pragma ComponentBehavior: Bound
import QtQuick

ListView {
 delegate: Rectangle {
     color: model.myColor
 }
}
</db:programlisting>
<db:para>The delegate property of ListView is a component. Therefore, a <db:link xlink:href="qml-qtqml-component.xml">Component</db:link> is implicitly created around the Rectangle here. That component is bound to its context. It doesn't receive the context property model provided by ListView. To make it work, you'd have to write it this way:</db:para>
<db:programlisting language="qml">pragma ComponentBehavior: Bound
import QtQuick

ListView {
 delegate: Rectangle {
     required property color myColor
     color: myColor
 }
}
</db:programlisting>
<db:para>You can nest components in a QML file. The pragma holds for all components in the file, no matter how deeply nested.</db:para>
</db:section>
<db:section xml:id="functionsignaturebehavior">
<db:title>FunctionSignatureBehavior</db:title>
<db:para>With this pragma you can change the way type annotations on functions are handled. Since Qt 6.7 type annotations are enforced when calling functions. Before, only the <db:link xlink:href="qtqml-qml-script-compiler.xml">QML script compiler</db:link> enforced the type annotations. The interpreter and JIT compiler ignored them. Always enforcing the type annotations is a behavior change in comparison to earlier versions since you could call functions with mismatched arguments before.</db:para>
<db:para>Specifying Ignored as value makes the QML engine and the <db:link xlink:href="qtqml-qml-script-compiler.xml">QML script compiler</db:link> ignore any type annotations and therefore restores the pre-6.7 behavior of the interpreter and JIT. As a result less code is compiled to C++ ahead of time, and more code has to be interpreted or JIT-compiled.</db:para>
<db:para>Specifying Enforced as value explicitly states the default: Type annotations are always enforced.</db:para>
</db:section>
<db:section xml:id="nativemethodbehavior">
<db:title>NativeMethodBehavior</db:title>
<db:para>Calling C++ methods with this objects different from the one they were retrieved from is broken, due to historical reasons. The original object is used as this object. You can allow the given this object to be used by setting pragma NativeMethodBehavior: AcceptThisObject. Specifying RejectThisObject keeps the historical behavior.</db:para>
<db:para>An example of this can be found under <db:link xlink:href="qtqml-cppintegration-exposecppattributes.xml#c-methods-and-the-this-object">C++ methods and the 'this' object</db:link>.</db:para>
</db:section>
<db:section xml:id="valuetypebehavior">
<db:title>ValueTypeBehavior</db:title>
<db:para>With this pragma you can change the way value types and sequences are handled.</db:para>
<db:para>Usually lower case names cannot be type names in JavaScript code. This is a problem because value type names are lower case. You can specify Addressable as value for this pragma to change this. If Addressable is specified a JavaScript value can be explicitly coerced to a specific, named, value type. This is done using the as operator, like you would do with object types. Furthermore, you can also check for value types using the instanceof operator:</db:para>
<db:programlisting language="qml">pragma ValueTypeBehavior: Addressable
import QtQml

QtObject {
 property var a
 property real b: (a as rect).x
 property bool c: a instanceof rect

 property var rect // inaccessible. &quot;rect&quot; is a type name.
}
</db:programlisting>
<db:para>Since rect in the above example is now a type name, it will shadow any properties called rect.</db:para>
<db:para>Explicitly casting to the desired type helps tooling. It can allow the <db:link xlink:href="qtqml-qtquick-compiler-tech.xml">Qt Quick Compiler</db:link> generate efficient code where it otherwise would not be able to. You can use <db:link xlink:href="qtqml-tooling-qmllint.xml">qmllint</db:link> to find such occurrences.</db:para>
<db:para>There is also a Inaddressable value you can use to explicitly specify the default behavior.</db:para>
<db:para>Another attribute to the ValueTypeBehavior pragma is Assertable, introduced in Qt 6.8. Due to a mistake in Qt 6.6 and 6.7 the a as rect above not only checks whether a is a rect but also constructs a rect if a is of a compatible type. This is obviously not what a type assertion should do. Specifying Assertable prevents this behavior and restricts type assertions for value types to only check for the type. You should always specify it if you are going to use value types with as. In any case, if the type assertion for a value type fails, the result is undefined.</db:para>
<db:para>instanceof does not have this problem since it only checks for inheritance, not for all possible type coercions.</db:para>
<db:note>
<db:para>Using as with the int and double types is not advisable since by JavaScript rules, the result of any calculation is a floating point number, even if it happens to hold the same value as its integer equivalent. Conversely, any integer constant you declare in JavaScript is not a double by QML's type mapping rules. Furthermore, int and double are reserved words. You can only address these types via type namespaces.</db:para>
</db:note>
<db:para>Value types and sequences are generally treated as references. This means, if you retrieve a value type instance from a property into a local value, and then change the local value, the original property is also changed. Furthermore, if you write the original property explicitly, the local value is also updated. This behavior is rather unintuitive in many places, and you should not rely on it. The Copy and Reference values for the ValueTypeBehavior pragma are experimental options to change this behavior. You should not use them. Specifying Copy causes all value types to be treated as actual copies. Specifying Reference explicitly states the default behavior.</db:para>
<db:para>Rather than using Copy you should explicitly re-load references to value types and sequences any time they can have been affected by side effects. Side effects can happen whenever you call a function or imperatively set a property. <db:link xlink:href="qtqml-tooling-qmllint.xml">qmllint</db:link> provides guidance on this. For example, in the following code the variable f is affected by side effects after writing width. This is because there may be a binding in a derived type or in a Binding element that updates font when width is changed.</db:para>
<db:programlisting language="qml">import QtQuick
Text {
 function a() : real {
     var f = font;
     width = f.pixelSize;
     return f.pointSize;
 }
}
</db:programlisting>
<db:para>In order to address this, you can avoid holding f across the write operation on width:</db:para>
<db:programlisting language="qml">import QtQuick
Text {
 function a() : real {
     var f = font;
     width = f.pixelSize;
     f = font;
     return f.pointSize;
 }
}
</db:programlisting>
<db:para>This, in turn can be shortened to:</db:para>
<db:programlisting language="qml">import QtQuick
Text {
 function a() : real {
     width = font.pixelSize;
     return font.pointSize;
 }
}
</db:programlisting>
<db:para>You might assume that re-retrieving the font property is costly, but actually the QML engine automatically refreshes value type references each time you read from them. So this is not more expensive than the first version, but a clearer way to express the same operations.</db:para>
</db:section>
<db:section xml:id="translator">
<db:title>Translator</db:title>
<db:para>With this pragma you can set the context for the translations in the file.</db:para>
<db:programlisting language="qml">pragma Translator: myTranslationContext
</db:programlisting>
<db:programlisting language="qml">pragma Translator: &quot;myTranslationContext&quot;
</db:programlisting>
<db:para>For more information on internationalization with QML, see <db:link xlink:href="">Use qsTr</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="imports">
<db:title>Imports</db:title>
<db:para>A document must import the necessary modules or type namespaces to enable the engine to load the QML object types referenced within the document. By default, a document can access any QML object types that have been defined through .qml files in the same directory; if a document needs to refer to any other object types, it must import the type namespace into which those types have been registered.</db:para>
<db:para>QML does <db:emphasis>not</db:emphasis> have a preprocessor that modifies the document prior to presentation to the <db:link xlink:href="qqmlengine.xml">QML engine</db:link>, unlike C or C++. The import statements do not copy and prepend the code in the document, but instead instruct the QML engine on how to resolve type references found in the document. Any type reference present in a QML document - such as Rectangle and ListView - including those made within a <db:link xlink:href="qtqml-javascript-expressions.xml">JavaScript block</db:link> or <db:link xlink:href="qtqml-syntax-propertybinding.xml">property bindings</db:link>, are <db:emphasis>resolved</db:emphasis> based exclusively on the import statements. At least one import statement must be present such as import QtQuick 2.0.</db:para>
<db:para>Please see the <db:link xlink:href="qtqml-syntax-imports.xml">QML Syntax - Import Statements</db:link> documentation for in-depth information about QML imports.</db:para>
</db:section>
<db:section xml:id="the-root-object-declaration">
<db:title>The Root Object Declaration</db:title>
<db:para>A QML document describes a hierarchy of objects which can be instantiated. Each object definition has a certain structure; it has a type, it can have an id and an object name, it can have properties, it can have methods, it can have signals and it can have signal handlers.</db:para>
<db:para>A QML file must only contain <db:emphasis role="bold">a single root object definition</db:emphasis>. The following is invalid and will generate an error:</db:para>
<db:programlisting language="cpp">// MyQmlFile.qml
import QtQuick 2.0

Rectangle { width: 200; height: 200; color: &quot;red&quot; }
Rectangle { width: 200; height: 200; color: &quot;blue&quot; }    // invalid!
</db:programlisting>
<db:para>This is because a .qml file automatically defines a QML type, which encapsulates a <db:emphasis>single</db:emphasis> QML object definition. This is discussed further in <db:link xlink:href="qtqml-documents-definetypes.xml">Documents as QML object type definitions</db:link>.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtqml-javascript-hostenvironment.xml#type-annotations-and-assertions">Type annotations and assertions</db:link></db:member>
<db:member><db:link xlink:href="qtqml-javascript-hostenvironment.xml#type-annotations-and-assertions">Type annotations and assertions</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
