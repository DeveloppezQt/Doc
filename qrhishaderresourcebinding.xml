<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRhiShaderResourceBinding Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Describes the shader resource for a single binding point.</db:para>
<db:para>This class was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>rhi/qrhi.h</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::GuiPrivate)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui-private</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A <db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link> cannot be constructed directly. Instead, use the static functions such as <db:link xlink:href="qrhishaderresourcebinding.xml#uniformBuffer">uniformBuffer</db:link>() or <db:link xlink:href="qrhishaderresourcebinding.xml#sampledTexture">sampledTexture</db:link>() to get an instance.</db:para>
<db:note>
<db:para>This is a RHI API with limited compatibility guarantees, see <db:link xlink:href="qrhi.xml">QRhi</db:link> for details.</db:para>
</db:note>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="StageFlag-enum">
<db:title>enum QRhiShaderResourceBinding::StageFlag</db:title>
<db:bridgehead renderas="sect2">flags QRhiShaderResourceBinding::StageFlags</db:bridgehead>
<db:para>Flag values to indicate which stages the shader resource is visible in</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::VertexStage</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 0</db:code></db:td>
<db:td>
<db:para>Vertex stage</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::TessellationControlStage</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 1</db:code></db:td>
<db:td>
<db:para>Tessellation control (hull shader) stage</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::TessellationEvaluationStage</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 2</db:code></db:td>
<db:td>
<db:para>Tessellation evaluation (domain shader) stage</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::FragmentStage</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 4</db:code></db:td>
<db:td>
<db:para>Fragment (pixel shader) stage</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::ComputeStage</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 5</db:code></db:td>
<db:td>
<db:para>Compute stage</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::GeometryStage</db:code></db:para>
</db:td>
<db:td><db:code>1 &lt;&lt; 3</db:code></db:td>
<db:td>
<db:para>Geometry stage</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>StageFlags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;StageFlag&gt;. </db:code>It stores an OR combination of <db:code>StageFlag</db:code> values.</db:para>
</db:section>
<db:section xml:id="Type-enum">
<db:title>enum QRhiShaderResourceBinding::Type</db:title>
<db:para>Specifies type of the shader resource bound to a binding point</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::UniformBuffer</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Uniform buffer</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::SampledTexture</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Combined image sampler (a texture and sampler pair). Even when the shading language associated with the underlying 3D API has no support for this concept (e.g. D3D and HLSL), this is still supported because the shader translation layer takes care of the appropriate translation and remapping of binding points or shader registers.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::Texture</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Texture (separate)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::Sampler</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>Sampler (separate)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::ImageLoad</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>Image load (with GLSL this maps to doing <db:link xlink:href="qrhishaderresourcebinding.xml#imageLoad">imageLoad</db:link>() on a single level - and either one or all layers - of a texture exposed to the shader as an image object)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::ImageStore</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>Image store (with GLSL this maps to doing <db:link xlink:href="qrhishaderresourcebinding.xml#imageStore">imageStore</db:link>() or imageAtomic*() on a single level - and either one or all layers - of a texture exposed to the shader as an image object)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::ImageLoadStore</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>Image load and store</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::BufferLoad</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>Storage buffer store (with GLSL this maps to reading from a shader storage buffer)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::BufferStore</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>Storage buffer store (with GLSL this maps to writing to a shader storage buffer)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link></db:emphasis>::BufferLoadStore</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>Storage buffer load and store</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="bufferLoad">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::bufferLoad(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiBuffer *<db:emphasis>buf</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for a read-only storage buffer with the given <db:code role="parameter">binding</db:code> number and pipeline <db:code role="parameter">stage</db:code>.</db:para>
<db:note>
<db:para>When <db:code role="parameter">buf</db:code> is not null, must have been created with <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">QRhiBuffer::StorageBuffer</db:link>.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">buf</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>Buffer load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</db:para>
</db:note>
</db:section>
<db:section xml:id="bufferLoad-1">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::bufferLoad(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiBuffer *<db:emphasis>buf</db:emphasis>, quint32 <db:emphasis>offset</db:emphasis>, quint32 <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for a read-only storage buffer with the given <db:code role="parameter">binding</db:code> number and pipeline <db:code role="parameter">stage</db:code>. This overload binds a region only, as specified by <db:code role="parameter">offset</db:code> and <db:code role="parameter">size</db:code>.</db:para>
<db:note>
<db:para>When <db:code role="parameter">buf</db:code> is not null, must have been created with <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">QRhiBuffer::StorageBuffer</db:link>.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">buf</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>Buffer load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</db:para>
</db:note>
</db:section>
<db:section xml:id="bufferLoadStore">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::bufferLoadStore(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiBuffer *<db:emphasis>buf</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for a read-write storage buffer with the given <db:code role="parameter">binding</db:code> number and pipeline <db:code role="parameter">stage</db:code>.</db:para>
<db:note>
<db:para>When <db:code role="parameter">buf</db:code> is not null, must have been created with <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">QRhiBuffer::StorageBuffer</db:link>.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">buf</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>Buffer load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</db:para>
</db:note>
</db:section>
<db:section xml:id="bufferLoadStore-1">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::bufferLoadStore(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiBuffer *<db:emphasis>buf</db:emphasis>, quint32 <db:emphasis>offset</db:emphasis>, quint32 <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for a read-write storage buffer with the given <db:code role="parameter">binding</db:code> number and pipeline <db:code role="parameter">stage</db:code>. This overload binds a region only, as specified by <db:code role="parameter">offset</db:code> and <db:code role="parameter">size</db:code>.</db:para>
<db:note>
<db:para>When <db:code role="parameter">buf</db:code> is not null, must have been created with <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">QRhiBuffer::StorageBuffer</db:link>.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">buf</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>Buffer load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</db:para>
</db:note>
</db:section>
<db:section xml:id="bufferStore">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::bufferStore(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiBuffer *<db:emphasis>buf</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for a write-only storage buffer with the given <db:code role="parameter">binding</db:code> number and pipeline <db:code role="parameter">stage</db:code>.</db:para>
<db:note>
<db:para>When <db:code role="parameter">buf</db:code> is not null, must have been created with <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">QRhiBuffer::StorageBuffer</db:link>.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">buf</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>Buffer load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</db:para>
</db:note>
</db:section>
<db:section xml:id="bufferStore-1">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::bufferStore(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiBuffer *<db:emphasis>buf</db:emphasis>, quint32 <db:emphasis>offset</db:emphasis>, quint32 <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for a write-only storage buffer with the given <db:code role="parameter">binding</db:code> number and pipeline <db:code role="parameter">stage</db:code>. This overload binds a region only, as specified by <db:code role="parameter">offset</db:code> and <db:code role="parameter">size</db:code>.</db:para>
<db:note>
<db:para>When <db:code role="parameter">buf</db:code> is not null, must have been created with <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">QRhiBuffer::StorageBuffer</db:link>.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">buf</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>Buffer load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</db:para>
</db:note>
</db:section>
<db:section xml:id="imageLoad">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::imageLoad(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiTexture *<db:emphasis>tex</db:emphasis>, int <db:emphasis>level</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for a read-only storage image with the given <db:code role="parameter">binding</db:code> number and pipeline <db:code role="parameter">stage</db:code>. The image load operations will have access to all layers of the specified <db:code role="parameter">level</db:code>. (so if the texture is a cubemap, the shader must use imageCube instead of image2D)</db:para>
<db:note>
<db:para>When <db:code role="parameter">tex</db:code> is not null, it must have been created with <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::UsedWithLoadStore</db:link>.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">tex</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>Image load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</db:para>
</db:note>
</db:section>
<db:section xml:id="imageLoadStore">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::imageLoadStore(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiTexture *<db:emphasis>tex</db:emphasis>, int <db:emphasis>level</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for a read/write storage image with the given <db:code role="parameter">binding</db:code> number and pipeline <db:code role="parameter">stage</db:code>. The image load/store operations will have access to all layers of the specified <db:code role="parameter">level</db:code>. (so if the texture is a cubemap, the shader must use imageCube instead of image2D)</db:para>
<db:note>
<db:para>When <db:code role="parameter">tex</db:code> is not null, it must have been created with <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::UsedWithLoadStore</db:link>.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">tex</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>Image load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</db:para>
</db:note>
</db:section>
<db:section xml:id="imageStore">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::imageStore(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiTexture *<db:emphasis>tex</db:emphasis>, int <db:emphasis>level</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for a write-only storage image with the given <db:code role="parameter">binding</db:code> number and pipeline <db:code role="parameter">stage</db:code>. The image store operations will have access to all layers of the specified <db:code role="parameter">level</db:code>. (so if the texture is a cubemap, the shader must use imageCube instead of image2D)</db:para>
<db:note>
<db:para>When <db:code role="parameter">tex</db:code> is not null, it must have been created with <db:link xlink:href="qrhitexture.xml#Flag-enum">QRhiTexture::UsedWithLoadStore</db:link>.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">tex</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>Image load/store is only guaranteed to be available within a compute pipeline. While some backends may support using these resources in a graphics pipeline as well, this is not universally supported, and even when it is, unexpected problems may arise when it comes to barriers and synchronization. Therefore, avoid using such resources with shaders other than compute.</db:para>
</db:note>
</db:section>
<db:section xml:id="isLayoutCompatible">
<db:title>bool QRhiShaderResourceBinding::isLayoutCompatible(const QRhiShaderResourceBinding &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if the layout is compatible with <db:code role="parameter">other</db:code>. The layout does not include the actual resource (such as, buffer or texture) and related parameters (such as, offset or size).</db:para>
<db:para>For example, <db:code>a</db:code> and <db:code>b</db:code> below are not equal, but are compatible layout-wise:</db:para>
<db:programlisting language="cpp">auto a = QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, buffer);
auto b = QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, someOtherBuffer, 256);
</db:programlisting>
</db:section>
<db:section xml:id="sampledTexture">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::sampledTexture(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiTexture *<db:emphasis>tex</db:emphasis>, QRhiSampler *<db:emphasis>sampler</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for the given binding number, pipeline stages, texture, and sampler specified by <db:code role="parameter">binding</db:code>, <db:code role="parameter">stage</db:code>, <db:code role="parameter">tex</db:code>, <db:code role="parameter">sampler</db:code>.</db:para>
<db:note>
<db:para>This function is equivalent to calling <db:link xlink:href="qrhishaderresourcebinding.xml#sampledTextures">sampledTextures</db:link>() with a <db:code>count</db:code> of 1.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">tex</db:code> and <db:code role="parameter">sampler</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>A shader may not be able to consume more than 16 textures/samplers, depending on the underlying graphics API. This hard limit must be kept in mind in renderer design. This does not apply to texture arrays which consume a single binding point (shader register) and can contain 256-2048 textures, depending on the underlying graphics API. Arrays of textures (see <db:link xlink:href="qrhishaderresourcebinding.xml#sampledTextures">sampledTextures</db:link>()) are however no different in this regard than using the same number of individual textures.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhishaderresourcebinding.xml#sampledTextures">sampledTextures</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sampledTextures">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::sampledTextures(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, int <db:emphasis>count</db:emphasis>, const QRhiShaderResourceBinding::TextureAndSampler *<db:emphasis>texSamplers</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for the given binding number, pipeline stages, and the array of texture-sampler pairs specified by <db:code role="parameter">binding</db:code>, <db:code role="parameter">stage</db:code>, <db:code role="parameter">count</db:code>, and <db:code role="parameter">texSamplers</db:code>.</db:para>
<db:note>
<db:para><db:code role="parameter">count</db:code> must be at least 1, and not larger than 16.</db:para>
</db:note>
<db:note>
<db:para>When <db:code role="parameter">count</db:code> is 1, this function is equivalent to <db:link xlink:href="qrhishaderresourcebinding.xml#sampledTexture">sampledTexture</db:link>().</db:para>
</db:note>
<db:para>This function is relevant when arrays of combined image samplers are involved. For example, in GLSL <db:code>layout(binding = 5) uniform sampler2D shadowMaps[8];</db:code> declares an array of combined image samplers. The application is then expected provide a <db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link> for binding point 5, set up by calling this function with <db:code role="parameter">count</db:code> set to 8 and a valid texture and sampler for each element of the array.</db:para>
<db:warning>
<db:para>All elements of the array must be specified. With the above example, the only valid, portable approach is calling this function with a <db:code role="parameter">count</db:code> of 8. Additionally, all <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> and <db:link xlink:href="qrhisampler.xml">QRhiSampler</db:link> instances must be valid, meaning nullptr is not an accepted value. This is due to some of the underlying APIs, such as, Vulkan, that require a valid image and sampler object for each element in descriptor arrays. Applications are advised to provide &quot;dummy&quot; samplers and textures if some array elements are not relevant (due to not being accessed in the shader).</db:para>
</db:warning>
<db:note>
<db:para><db:code role="parameter">texSamplers</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhishaderresourcebinding.xml#sampledTexture">sampledTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sampler">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::sampler(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiSampler *<db:emphasis>sampler</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for the given binding number, pipeline stages, and sampler specified by <db:code role="parameter">binding</db:code>, <db:code role="parameter">stage</db:code>, <db:code role="parameter">sampler</db:code>.</db:para>
<db:note>
<db:para><db:code role="parameter">sampler</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:para>Arrays of separate samplers are not supported.</db:para>
<db:para>This creates a binding for a separate sampler object, whereas <db:link xlink:href="qrhishaderresourcebinding.xml#sampledTexture">sampledTexture</db:link>() is suitable for combined image samplers. In Vulkan-compatible GLSL code separate samplers are declared as <db:code>sampler</db:code> as opposed to <db:code>sampler2D</db:code>: <db:code>layout(binding = 2) uniform sampler samp;</db:code></db:para>
<db:para>With both a <db:code>texture2D</db:code> and <db:code>sampler</db:code> present, they can be used together to sample the texture: <db:code>fragColor = texture(sampler2D(tex, samp), texcoord);</db:code>.</db:para>
<db:note>
<db:para>A shader may not be able to consume more than 16 samplers, depending on the underlying graphics API. This hard limit must be kept in mind in renderer design.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhishaderresourcebinding.xml#texture">texture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="texture">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::texture(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiTexture *<db:emphasis>tex</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for the given binding number, pipeline stages, and texture specified by <db:code role="parameter">binding</db:code>, <db:code role="parameter">stage</db:code>, <db:code role="parameter">tex</db:code>.</db:para>
<db:note>
<db:para>This function is equivalent to calling <db:link xlink:href="qrhishaderresourcebinding.xml#textures">textures</db:link>() with a <db:code>count</db:code> of 1.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">tex</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:para>This creates a binding for a separate texture (image) object, whereas <db:link xlink:href="qrhishaderresourcebinding.xml#sampledTexture">sampledTexture</db:link>() is suitable for combined image samplers. In Vulkan-compatible GLSL code separate textures are declared as <db:code>texture2D</db:code> as opposed to <db:code>sampler2D</db:code>: <db:code>layout(binding = 1) uniform texture2D tex;</db:code></db:para>
<db:note>
<db:para>A shader may not be able to consume more than 16 textures, depending on the underlying graphics API. This hard limit must be kept in mind in renderer design. This does not apply to texture arrays which consume a single binding point (shader register) and can contain 256-2048 textures, depending on the underlying graphics API. Arrays of textures (see <db:link xlink:href="qrhishaderresourcebinding.xml#sampledTextures">sampledTextures</db:link>()) are however no different in this regard than using the same number of individual textures.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhishaderresourcebinding.xml#textures">textures</db:link>()</db:member>
<db:member><db:link xlink:href="qrhishaderresourcebinding.xml#sampler">sampler</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="textures">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::textures(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, int <db:emphasis>count</db:emphasis>, QRhiTexture **<db:emphasis>tex</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for the given binding number, pipeline stages, and the array of (separate) textures specified by <db:code role="parameter">binding</db:code>, <db:code role="parameter">stage</db:code>, <db:code role="parameter">count</db:code>, and <db:code role="parameter">tex</db:code>.</db:para>
<db:note>
<db:para><db:code role="parameter">count</db:code> must be at least 1, and not larger than 16.</db:para>
</db:note>
<db:note>
<db:para>When <db:code role="parameter">count</db:code> is 1, this function is equivalent to <db:link xlink:href="qrhishaderresourcebinding.xml#texture">texture</db:link>().</db:para>
</db:note>
<db:warning>
<db:para>All elements of the array must be specified.</db:para>
</db:warning>
<db:note>
<db:para><db:code role="parameter">tex</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhishaderresourcebinding.xml#texture">texture</db:link>()</db:member>
<db:member><db:link xlink:href="qrhishaderresourcebinding.xml#sampler">sampler</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="uniformBuffer">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::uniformBuffer(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiBuffer *<db:emphasis>buf</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for the given binding number, pipeline stages, and buffer specified by <db:code role="parameter">binding</db:code>, <db:code role="parameter">stage</db:code>, and <db:code role="parameter">buf</db:code>.</db:para>
<db:note>
<db:para>When <db:code role="parameter">buf</db:code> is not null, it must have been created with <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">QRhiBuffer::UniformBuffer</db:link>.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">buf</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>If the size of <db:code role="parameter">buf</db:code> exceeds the limit reported for <db:link xlink:href="qrhi.xml#ResourceLimit-enum">QRhi::MaxUniformBufferRange</db:link>, unexpected errors may occur.</db:para>
</db:note>
</db:section>
<db:section xml:id="uniformBuffer-1">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::uniformBuffer(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiBuffer *<db:emphasis>buf</db:emphasis>, quint32 <db:emphasis>offset</db:emphasis>, quint32 <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for the given binding number, pipeline stages, and buffer specified by <db:code role="parameter">binding</db:code>, <db:code role="parameter">stage</db:code>, and <db:code role="parameter">buf</db:code>. This overload binds a region only, as specified by <db:code role="parameter">offset</db:code> and <db:code role="parameter">size</db:code>.</db:para>
<db:note>
<db:para>It is up to the user to ensure the offset is aligned to <db:link xlink:href="qrhi.xml#ubufAlignment">QRhi::ubufAlignment</db:link>().</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">size</db:code> must be greater than 0.</db:para>
</db:note>
<db:note>
<db:para>When <db:code role="parameter">buf</db:code> is not null, it must have been created with <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">QRhiBuffer::UniformBuffer</db:link>.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">buf</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>If <db:code role="parameter">size</db:code> exceeds the limit reported for <db:link xlink:href="qrhi.xml#ResourceLimit-enum">QRhi::MaxUniformBufferRange</db:link>, unexpected errors may occur.</db:para>
</db:note>
</db:section>
<db:section xml:id="uniformBufferWithDynamicOffset">
<db:title>[static] QRhiShaderResourceBinding QRhiShaderResourceBinding::uniformBufferWithDynamicOffset(int <db:emphasis>binding</db:emphasis>, QRhiShaderResourceBinding::StageFlags <db:emphasis>stage</db:emphasis>, QRhiBuffer *<db:emphasis>buf</db:emphasis>, quint32 <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Returns a shader resource binding for the given binding number, pipeline stages, and buffer specified by <db:code role="parameter">binding</db:code>, <db:code role="parameter">stage</db:code>, and <db:code role="parameter">buf</db:code>. The uniform buffer is assumed to have dynamic offset. The dynamic offset can be specified in <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(), thus allowing using varying offset values without creating new bindings for the buffer. The size of the bound region is specified by <db:code role="parameter">size</db:code>. Like with non-dynamic offsets, <db:code>offset + size</db:code> cannot exceed the size of <db:code role="parameter">buf</db:code>.</db:para>
<db:note>
<db:para>When <db:code role="parameter">buf</db:code> is not null, it must have been created with <db:link xlink:href="qrhibuffer.xml#UsageFlag-enum">QRhiBuffer::UniformBuffer</db:link>.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">buf</db:code> can be null. It is valid to create a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with unspecified resources, but such an object cannot be used with <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>(). It is however suitable for creating pipelines. Such a pipeline must then always be used together with another, layout compatible <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> with resources present passed to <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">QRhiCommandBuffer::setShaderResources</db:link>().</db:para>
</db:note>
<db:note>
<db:para>If <db:code role="parameter">size</db:code> exceeds the limit reported for <db:link xlink:href="qrhi.xml#ResourceLimit-enum">QRhi::MaxUniformBufferRange</db:link>, unexpected errors may occur.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="operator-not-eq">
<db:title>[noexcept] bool operator!=(const QRhiShaderResourceBinding &amp;<db:emphasis>a</db:emphasis>, const QRhiShaderResourceBinding &amp;<db:emphasis>b</db:emphasis>)</db:title>
<db:para>Returns <db:code>false</db:code> if all the bindings in the two <db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link> objects <db:code role="parameter">a</db:code> and <db:code role="parameter">b</db:code> are equal; otherwise returns <db:code>true</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>[noexcept] bool operator==(const QRhiShaderResourceBinding &amp;<db:emphasis>a</db:emphasis>, const QRhiShaderResourceBinding &amp;<db:emphasis>b</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if the contents of the two <db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link> objects <db:code role="parameter">a</db:code> and <db:code role="parameter">b</db:code> are equal. This includes the resources (buffer, texture) and related parameters (offset, size) as well. To only compare layouts (binding point, pipeline stage, resource type), use <db:link xlink:href="qrhishaderresourcebinding.xml#isLayoutCompatible">isLayoutCompatible</db:link>() instead.</db:para>
</db:section>
</db:section>
</db:article>
