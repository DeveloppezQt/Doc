<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>qt_add_qml_plugin</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Qml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Defines a plugin associated with a QML module.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="synopsis">
<db:title>Synopsis</db:title>
<db:programlisting language="cpp" role="bad">qt_add_qml_plugin(
    target
    [BACKING_TARGET backing_target]
    [STATIC | SHARED]
    [OUTPUT_DIRECTORY]
    [URI]
    [CLASS_NAME]
    [NO_GENERATE_PLUGIN_SOURCE]
    [NAMESPACE namespace]
)
</db:programlisting>
<db:para>If <db:link xlink:href="">versionless commands</db:link> are disabled, use qt6_add_qml_plugin() instead. It supports the same set of arguments as this command.</db:para>
</db:section>
<db:section xml:id="description">
<db:title>Description</db:title>
<db:para>This command creates the plugin target associated with a QML module. It would normally be called internally by <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module()</db:link> to create or update the plugin associated with its backing target. You should not call this function directly unless you have special circumstances that require you to create the target in a special way.</db:para>
<db:para>The documentation for <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module()</db:link> describes different structural patterns for how the CMake targets associated with a QML module can be arranged. Note that even if the QML module has no separate backing target and all functionality is implemented directly in the plugin (not the recommended arrangement), you should still call <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module()</db:link> rather than qt_add_qml_plugin().</db:para>
</db:section>
<db:section xml:id="arguments">
<db:title>Arguments</db:title>
<db:para>The target specifies the name of the target to use for the QML plugin. If it does not already exist, it will be created.</db:para>
<db:para>BACKING_TARGET specifies the name of the backing target that the plugin is associated with. The backing target can be the same as the plugin target, in which case there is only the one merged target, but this is not typically recommended (see <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module()</db:link> for more information). BACKING_TARGET should always be provided unless there are special circumstances that require the plugin target to be created before the backing target. If BACKING_TARGET is not provided, a URI option must be given.</db:para>
<db:para>By default, the plugin is created with a type that is compatible with the backing target. If the backing target is a static library, the plugin will also be created as a static library. If the backing target is a shared library, the plugin will be created as a module library. Where no backing target is provided or the plugin has no separate backing target, the plugin type can be specified with either the STATIC or SHARED keywords. If the plugin type is not determined by any of the preceding conditions, a static plugin will be created if Qt was built as static libraries, or a module library plugin otherwise.</db:para>
<db:para>OUTPUT_DIRECTORY specifies the directory where the plugin library will be created. It should always be the same location as the QML module's <db:link xlink:href="qtqml-modules-qmldir.xml">qmldir</db:link> file. When OUTPUT_DIRECTORY is not given, it will be obtained from information stored on the BACKING_TARGET, where available. Note that this could be different to the directory of the backing target's own library. If an output directory cannot be obtained from the backing target, the CMAKE_CURRENT_BINARY_DIR is used by default.</db:para>
<db:para>URI declares the module identifier of the QML module this plugin is associated with. The module identifier is the (dotted URI notation) identifier for the QML module. If URI is not given, a BACKING_TARGET must be provided and the backing target must have its URI recorded on it (typically by an earlier call to <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module()</db:link>).</db:para>
<db:para>Each plugin should have a C++ class that registers the module with the QML engine. By default, qt_add_qml_plugin() auto-generates the sources for this C++ class, and adds them to the target's list of sources. The generated plugin class satisfies the requirements of the plugin being optional (see <db:link xlink:href="qtqml-modules-qmldir.xml">Module Definition qmldir Files</db:link>). The class name is determined as follows:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If CLASS_NAME has been given, it will be used. It must match the name used in the QML module's qmldir file.</db:para>
</db:listitem>
<db:listitem>
<db:para>If CLASS_NAME has not been given, but BACKING_TARGET has, the C++ class name will be taken from details recorded on that backing target. Those details are usually recorded by an earlier call to <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module()</db:link>, and they will match the name used in the generated qmldir file. This is the recommended way to provide the class name in most scenarios.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the class name still cannot be determined, it is set to the module's URI with dots replaced by underscores, and Plugin appended.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>If a namespace is given with the NAMESPACE keyword, the plugin code will be generated into a C++ namespace of this name.</db:para>
<db:para>Some plugins may require the plugin class to be written manually. For example, the plugin may need to perform additional initialization or register things not implemented by the default plugin class. In such cases, the NO_GENERATE_PLUGIN_SOURCE option can be given. You are then responsible for writing your own C++ plugin class and adding it to the target. Note that if you need to write your own plugin class, it is very unlikely that the plugin can be optional. This in turn means that the NO_PLUGIN_OPTIONAL keyword should be included in the call to <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module()</db:link> when defining the QML module, or else the generated qmldir file will be incorrect. Make sure your plugin class uses the same class name as determined from the logic just above.</db:para>
</db:section>
</db:article>
