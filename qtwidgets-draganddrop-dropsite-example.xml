<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Drop Site Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The example shows how to distinguish the various MIME formats available in a drag and drop operation.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:alt>Screenshot of the Drop Site example</db:alt>
<db:imageobject>
<db:imagedata fileref="images/dropsite-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The Drop Site example accepts drops from other applications, and displays the MIME formats provided by the drag object.</db:para>
<db:para>There are two classes, <db:code>DropArea</db:code> and <db:code>DropSiteWindow</db:code>, and a <db:code>main()</db:code> function in this example. A <db:code>DropArea</db:code> object is instantiated in <db:code>DropSiteWindow</db:code>; a <db:code>DropSiteWindow</db:code> object is then invoked in the <db:code>main()</db:code> function.</db:para>
<db:section xml:id="droparea-class-definition">
<db:title>DropArea Class Definition</db:title>
<db:para>The <db:code>DropArea</db:code> class is a subclass of <db:link xlink:href="qlabel.xml">QLabel</db:link> with a public slot, <db:code>clear()</db:code>, and a <db:code>changed()</db:code> signal.</db:para>
<db:programlisting language="cpp">class DropArea : public QLabel
{
    Q_OBJECT

public:
    DropArea(QWidget *parent = 0);

public slots:
    void clear();

signals:
    void changed(const QMimeData *mimeData = 0);
</db:programlisting>
<db:para>In addition, <db:code>DropArea</db:code> also contains a private instance of <db:link xlink:href="qlabel.xml">QLabel</db:link> and reimplementations of four <db:link xlink:href="qwidget.xml">QWidget</db:link> event handlers:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#dragEnterEvent">dragEnterEvent</db:link>()</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#dragMoveEvent">dragMoveEvent</db:link>()</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#dragLeaveEvent">dragLeaveEvent</db:link>()</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml#dropEvent">dropEvent</db:link>()</db:para>
</db:listitem>
</db:orderedlist>
<db:para>These event handlers are further explained in the implementation of the <db:code>DropArea</db:code> class.</db:para>
<db:programlisting language="cpp">protected:
    void dragEnterEvent(QDragEnterEvent *event);
    void dragMoveEvent(QDragMoveEvent *event);
    void dragLeaveEvent(QDragLeaveEvent *event);
    void dropEvent(QDropEvent *event);

private:
    QLabel *label;
};
</db:programlisting>
</db:section>
<db:section xml:id="droparea-class-implementation">
<db:title>DropArea Class Implementation</db:title>
<db:para>In the <db:code>DropArea</db:code> constructor, we set the <db:link xlink:href="">minimum size</db:link> to 200x200 pixels, the <db:link xlink:href="qframe.xml#setFrameStyle">frame style</db:link> to both <db:link xlink:href="qframe.xml#Shadow-enum">QFrame::Sunken</db:link> and <db:link xlink:href="qframe.xml#Shape-enum">QFrame::StyledPanel</db:link>, and we align its contents to the center.</db:para>
<db:programlisting language="cpp">DropArea::DropArea(QWidget *parent)
    : QLabel(parent)
{
    setMinimumSize(200, 200);
    setFrameStyle(QFrame::Sunken | QFrame::StyledPanel);
    setAlignment(Qt::AlignCenter);
    setAcceptDrops(true);
    setAutoFillBackground(true);
    clear();
}
</db:programlisting>
<db:para>Also, we enable drop events in <db:code>DropArea</db:code> by setting the acceptDrops property to <db:code>true</db:code>. Then, we enable the autoFillBackground property and invoke the <db:code>clear()</db:code> function.</db:para>
<db:para>The <db:link xlink:href="qwidget.xml#dragEnterEvent">dragEnterEvent</db:link>() event handler is called when a drag is in progress and the mouse enters the <db:code>DropArea</db:code> object. For the <db:code>DropSite</db:code> example, when the mouse enters <db:code>DropArea</db:code>, we set its text to &quot;&lt;drop content&gt;&quot; and highlight its background.</db:para>
<db:programlisting language="cpp">void DropArea::dragEnterEvent(QDragEnterEvent *event)
{
    setText(tr(&quot;&lt;drop content&gt;&quot;));
    setBackgroundRole(QPalette::Highlight);

    event-&gt;acceptProposedAction();
    emit changed(event-&gt;mimeData());
}
</db:programlisting>
<db:para>Then, we invoke <db:link xlink:href="qdropevent.xml#acceptProposedAction">acceptProposedAction</db:link>() on <db:code role="parameter">event</db:code>, setting the drop action to the one proposed. Lastly, we emit the <db:code>changed()</db:code> signal, with the data that was dropped and its MIME type information as a parameter.</db:para>
<db:para>For <db:link xlink:href="qwidget.xml#dragMoveEvent">dragMoveEvent</db:link>(), we just accept the proposed <db:link xlink:href="qdragmoveevent.xml">QDragMoveEvent</db:link> object, <db:code role="parameter">event</db:code>, with <db:link xlink:href="qdropevent.xml#acceptProposedAction">acceptProposedAction</db:link>().</db:para>
<db:programlisting language="cpp">void DropArea::dragMoveEvent(QDragMoveEvent *event)
{
    event-&gt;acceptProposedAction();
}
</db:programlisting>
<db:para>The <db:code>DropArea</db:code> class's implementation of <db:link xlink:href="qwidget.xml#dropEvent">dropEvent</db:link>() extracts the <db:code role="parameter">event</db:code>'s mime data and displays it accordingly.</db:para>
<db:programlisting language="cpp">void DropArea::dropEvent(QDropEvent *event)
{
    const QMimeData *mimeData = event-&gt;mimeData();
</db:programlisting>
<db:para>The <db:code>mimeData</db:code> object can contain one of the following objects: an image, HTML text, plain text, or a list of URLs.</db:para>
<db:programlisting language="cpp">    if (mimeData-&gt;hasImage()) {
        setPixmap(qvariant_cast&lt;QPixmap&gt;(mimeData-&gt;imageData()));
    } else if (mimeData-&gt;hasHtml()) {
        setText(mimeData-&gt;html());
        setTextFormat(Qt::RichText);
    } else if (mimeData-&gt;hasText()) {
        setText(mimeData-&gt;text());
        setTextFormat(Qt::PlainText);
    } else if (mimeData-&gt;hasUrls()) {
        QList&lt;QUrl&gt; urlList = mimeData-&gt;urls();
        QString text;
        for (int i = 0; i &lt; urlList.size() &amp;&amp; i &lt; 32; ++i) {
            QString url = urlList.at(i).path();
            text += url + QString(&quot;\n&quot;);
        }
        setText(text);
    } else {
        setText(tr(&quot;Cannot display data&quot;));
    }
</db:programlisting>
<db:itemizedlist>
<db:listitem>
<db:para>If <db:code>mimeData</db:code> contains an image, we display it in <db:code>DropArea</db:code> with <db:link xlink:href="">setPixmap()</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>If <db:code>mimeData</db:code> contains HTML, we display it with <db:link xlink:href="">setText()</db:link> and set <db:code>DropArea</db:code>'s text format as <db:link xlink:href="qt.xml#TextFormat-enum">Qt::RichText</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>If <db:code>mimeData</db:code> contains plain text, we display it with <db:link xlink:href="">setText()</db:link> and set <db:code>DropArea</db:code>'s text format as <db:link xlink:href="qt.xml#TextFormat-enum">Qt::PlainText</db:link>. In the event that <db:code>mimeData</db:code> contains URLs, we iterate through the list of URLs to display them on individual lines.</db:para>
</db:listitem>
<db:listitem>
<db:para>If <db:code>mimeData</db:code> contains other types of objects, we set <db:code>DropArea</db:code>'s text, with <db:link xlink:href="">setText()</db:link> to &quot;Cannot display data&quot; to inform the user.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>We then set <db:code>DropArea</db:code>'s <db:link xlink:href="qwidget.xml#backgroundRole">backgroundRole</db:link> to <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::Dark</db:link> and we accept <db:code>event</db:code>'s proposed action.</db:para>
<db:programlisting language="cpp">    setBackgroundRole(QPalette::Dark);
    event-&gt;acceptProposedAction();
}
</db:programlisting>
<db:para>The <db:link xlink:href="qwidget.xml#dragLeaveEvent">dragLeaveEvent</db:link>() event handler is called when a drag is in progress and the mouse leaves the widget.</db:para>
<db:programlisting language="cpp">void DropArea::dragLeaveEvent(QDragLeaveEvent *event)
{
    clear();
    event-&gt;accept();
}
</db:programlisting>
<db:para>For <db:code>DropArea</db:code>'s implementation, we clear invoke <db:code>clear()</db:code> and then accept the proposed event.</db:para>
<db:para>The <db:code>clear()</db:code> function sets the text in <db:code>DropArea</db:code> to &quot;&lt;drop content&gt;&quot; and sets the <db:link xlink:href="qwidget.xml#backgroundRole">backgroundRole</db:link> to <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::Dark</db:link>. Lastly, it emits the <db:code>changed()</db:code> signal.</db:para>
<db:programlisting language="cpp">void DropArea::clear()
{
    setText(tr(&quot;&lt;drop content&gt;&quot;));
    setBackgroundRole(QPalette::Dark);

    emit changed();
}
</db:programlisting>
</db:section>
<db:section xml:id="dropsitewindow-class-definition">
<db:title>DropSiteWindow Class Definition</db:title>
<db:para>The <db:code>DropSiteWindow</db:code> class contains a constructor and a public slot, <db:code>updateFormatsTable()</db:code>.</db:para>
<db:programlisting language="cpp">class DropSiteWindow : public QWidget
{
    Q_OBJECT

public:
    DropSiteWindow();

public slots:
    void updateFormatsTable(const QMimeData *mimeData);

private:
    DropArea *dropArea;
    QLabel *abstractLabel;
    QTableWidget *formatsTable;

    QPushButton *clearButton;
    QPushButton *quitButton;
    QDialogButtonBox *buttonBox;
};
</db:programlisting>
<db:para>The class also contains a private instance of <db:code>DropArea</db:code>, <db:code>dropArea</db:code>, <db:link xlink:href="qlabel.xml">QLabel</db:link>, <db:code>abstractLabel</db:code>, <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link>, <db:code>formatsTable</db:code>, <db:link xlink:href="qdialogbuttonbox.xml">QDialogButtonBox</db:link>, <db:code>buttonBox</db:code>, and two <db:link xlink:href="qpushbutton.xml">QPushButton</db:link> objects, <db:code>clearButton</db:code> and <db:code>quitButton</db:code>.</db:para>
</db:section>
<db:section xml:id="dropsitewindow-class-implementation">
<db:title>DropSiteWindow Class Implementation</db:title>
<db:para>In the constructor of <db:code>DropSiteWindow</db:code>, we instantiate <db:code>abstractLabel</db:code> and set its wordWrap property to <db:code>true</db:code>. We also call the <db:link xlink:href="qwidget.xml#adjustSize">adjustSize</db:link>() function to adjust <db:code>abstractLabel</db:code>'s size according to its contents.</db:para>
<db:programlisting language="cpp">DropSiteWindow::DropSiteWindow()
{
    abstractLabel = new QLabel(tr(&quot;This example accepts drags from other &quot;
                                  &quot;applications and displays the MIME types &quot;
                                  &quot;provided by the drag object.&quot;));
    abstractLabel-&gt;setWordWrap(true);
    abstractLabel-&gt;adjustSize();
</db:programlisting>
<db:para>Then we instantiate <db:code>dropArea</db:code> and connect its <db:code>changed()</db:code> signal to <db:code>DropSiteWindow</db:code>'s <db:code>updateFormatsTable()</db:code> slot.</db:para>
<db:programlisting language="cpp">    dropArea = new DropArea;
    connect(dropArea, SIGNAL(changed(const QMimeData*)),
            this, SLOT(updateFormatsTable(const QMimeData*)));
</db:programlisting>
<db:para>We now set up the <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link> object, <db:code>formatsTable</db:code>. Its horizontal header is set using a <db:link xlink:href="qstringlist.xml">QStringList</db:link> object, <db:code>labels</db:code>. The number of columms are set to two and the table is not editable. Also, the <db:code>formatTable</db:code>'s horizontal header is formatted to ensure that its second column stretches to occupy additional space available.</db:para>
<db:programlisting language="cpp">    QStringList labels;
    labels &lt;&lt; tr(&quot;Format&quot;) &lt;&lt; tr(&quot;Content&quot;);

    formatsTable = new QTableWidget;
    formatsTable-&gt;setColumnCount(2);
    formatsTable-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);
    formatsTable-&gt;setHorizontalHeaderLabels(labels);
    formatsTable-&gt;horizontalHeader()-&gt;setStretchLastSection(true);
</db:programlisting>
<db:para>Two <db:link xlink:href="qpushbutton.xml">QPushButton</db:link> objects, <db:code>clearButton</db:code> and <db:code>quitButton</db:code>, are instantiated and added to <db:code>buttonBox</db:code> - a <db:link xlink:href="qdialogbuttonbox.xml">QDialogButtonBox</db:link> object. We use <db:link xlink:href="qdialogbuttonbox.xml">QDialogButtonBox</db:link> here to ensure that the push buttons are presented in a layout that conforms to the platform's style.</db:para>
<db:programlisting language="cpp">    clearButton = new QPushButton(tr(&quot;Clear&quot;));
    quitButton = new QPushButton(tr(&quot;Quit&quot;));

    buttonBox = new QDialogButtonBox;
    buttonBox-&gt;addButton(clearButton, QDialogButtonBox::ActionRole);
    buttonBox-&gt;addButton(quitButton, QDialogButtonBox::RejectRole);

    connect(quitButton, SIGNAL(pressed()), this, SLOT(close()));
    connect(clearButton, SIGNAL(pressed()), dropArea, SLOT(clear()));
</db:programlisting>
<db:para>The <db:link xlink:href="qabstractbutton.xml#clicked">clicked</db:link>() signals for <db:code>quitButton</db:code> and <db:code>clearButton</db:code> are connected to <db:link xlink:href="qwidget.xml#close">close</db:link>() and <db:code>clear()</db:code>, respectively.</db:para>
<db:para>For the layout, we use a <db:link xlink:href="qvboxlayout.xml">QVBoxLayout</db:link>, <db:code>mainLayout</db:code>, to arrange our widgets vertically. We also set the window title to &quot;Drop Site&quot; and the minimum size to 350x500 pixels.</db:para>
<db:programlisting language="cpp">    QVBoxLayout *mainLayout = new QVBoxLayout;
    mainLayout-&gt;addWidget(abstractLabel);
    mainLayout-&gt;addWidget(dropArea);
    mainLayout-&gt;addWidget(formatsTable);
    mainLayout-&gt;addWidget(buttonBox);
    setLayout(mainLayout);

    setWindowTitle(tr(&quot;Drop Site&quot;));
    setMinimumSize(350, 500);
}
</db:programlisting>
<db:para>We move on to the <db:code>updateFormatsTable()</db:code> function. This function updates the <db:code>formatsTable</db:code>, displaying the MIME formats of the object dropped onto the <db:code>DropArea</db:code> object. First, we set <db:link xlink:href="qtablewidget.xml">QTableWidget</db:link>'s <db:link xlink:href="qtablewidget.xml#setRowCount">rowCount</db:link> property to 0. Then, we validate to ensure that the <db:link xlink:href="qmimedata.xml">QMimeData</db:link> object passed in is a valid object.</db:para>
<db:programlisting language="cpp">void DropSiteWindow::updateFormatsTable(const QMimeData *mimeData)
{
    formatsTable-&gt;setRowCount(0);
    if (!mimeData)
        return;
</db:programlisting>
<db:para>Once we are sure that <db:code>mimeData</db:code> is valid, we iterate through its supported formats using the <db:link xlink:href="containers.xml#the-foreach-keyword">foreach keyword</db:link>. This keyword has the following format:</db:para>
<db:programlisting language="cpp">foreach(variable, container)
</db:programlisting>
<db:para>In our example, <db:code>format</db:code> is the <db:code role="parameter">variable</db:code> and the <db:code role="parameter">container</db:code> is a <db:link xlink:href="qstringlist.xml">QStringList</db:link>, obtained from <db:code>mimeData-&gt;formats()</db:code>.</db:para>
<db:note>
<db:para>The <db:link xlink:href="qmimedata.xml#formats">formats</db:link>() function returns a <db:link xlink:href="qstringlist.xml">QStringList</db:link> object, containing all the formats supported by the <db:code>mimeData</db:code>.</db:para>
</db:note>
<db:programlisting language="cpp">    foreach (QString format, mimeData-&gt;formats()) {
        QTableWidgetItem *formatItem = new QTableWidgetItem(format);
        formatItem-&gt;setFlags(Qt::ItemIsEnabled);
        formatItem-&gt;setTextAlignment(Qt::AlignTop | Qt::AlignLeft);
</db:programlisting>
<db:para>Within each iteration, we create a <db:link xlink:href="qtablewidgetitem.xml">QTableWidgetItem</db:link>, <db:code>formatItem</db:code> and we set its <db:link xlink:href="qtablewidgetitem.xml#setFlags">flags</db:link> to <db:link xlink:href="qt.xml#ItemFlag-enum">Qt::ItemIsEnabled</db:link>, and its <db:link xlink:href="qtablewidgetitem.xml#setTextAlignment">text alignment</db:link> to <db:link xlink:href="qt.xml#AlignmentFlag-enum">Qt::AlignTop</db:link> and <db:link xlink:href="qt.xml#AlignmentFlag-enum">Qt::AlignLeft</db:link>.</db:para>
<db:para>A <db:link xlink:href="qstring.xml">QString</db:link> object, <db:code>text</db:code>, is customized to display data according to the contents of <db:code>format</db:code>. We invoke {<db:link xlink:href="qstring.xml">QString</db:link>}'s <db:link xlink:href="qstring.xml#simplified">simplified</db:link>() function on <db:code>text</db:code>, to obtain a string that has no additional space before, after or in between words.</db:para>
<db:programlisting language="cpp">        QString text;
        if (format == &quot;text/plain&quot;) {
            text = mimeData-&gt;text().simplified();
        } else if (format == &quot;text/html&quot;) {
            text = mimeData-&gt;html().simplified();
        } else if (format == &quot;text/uri-list&quot;) {
            QList&lt;QUrl&gt; urlList = mimeData-&gt;urls();
            for (int i = 0; i &lt; urlList.size() &amp;&amp; i &lt; 32; ++i)
                text.append(urlList[i].toString() + &quot; &quot;);
        } else {
            QByteArray data = mimeData-&gt;data(format);
            for (int i = 0; i &lt; data.size() &amp;&amp; i &lt; 32; ++i) {
                QString hex = QString(&quot;%1&quot;).arg(uchar(data[i]), 2, 16,
                                                QChar('0'))
                                           .toUpper();
                text.append(hex + &quot; &quot;);
            }
        }
</db:programlisting>
<db:para>If <db:code>format</db:code> contains a list of URLs, we iterate through them, using spaces to separate them. On the other hand, if <db:code>format</db:code> contains an image, we display the data by converting the text to hexadecimal.</db:para>
<db:programlisting language="cpp">        int row = formatsTable-&gt;rowCount();
        formatsTable-&gt;insertRow(row);
        formatsTable-&gt;setItem(row, 0, new QTableWidgetItem(format));
        formatsTable-&gt;setItem(row, 1, new QTableWidgetItem(text));
    }

    formatsTable-&gt;resizeColumnToContents(0);
}
</db:programlisting>
<db:para>Once <db:code>text</db:code> has been customized to contain the appropriate data, we insert both <db:code>format</db:code> and <db:code>text</db:code> into <db:code>formatsTable</db:code> with <db:link xlink:href="qtablewidget.xml#setItem">setItem</db:link>(). Lastly, we invoke <db:link xlink:href="qtableview.xml#resizeColumnToContents">resizeColumnToContents</db:link>() on <db:code>formatsTable</db:code>'s first column.</db:para>
</db:section>
<db:section xml:id="the-main-function">
<db:title>The main() Function</db:title>
<db:para>Within the <db:code>main()</db:code> function, we instantiate <db:code>DropSiteWindow</db:code> and invoke its <db:link xlink:href="qwidget.xml#show">show</db:link>() function.</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    DropSiteWindow window;
    window.show();
    return app.exec();
}
</db:programlisting>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/dropsite/droparea.cpp">draganddrop/dropsite/droparea.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/dropsite/droparea.h">draganddrop/dropsite/droparea.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/dropsite/dropsite.pro">draganddrop/dropsite/dropsite.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/dropsite/dropsitewindow.cpp">draganddrop/dropsite/dropsitewindow.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/dropsite/dropsitewindow.h">draganddrop/dropsite/dropsitewindow.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="draganddrop/dropsite/main.cpp">draganddrop/dropsite/main.cpp</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
