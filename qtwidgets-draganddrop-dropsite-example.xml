<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Drop Site Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.14.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The example shows how to distinguish the various MIME formats available in a drag and drop operation.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:alt>Screenshot of the Drop Site example</db:alt>
<db:imageobject>
<db:imagedata fileref="images/dropsite-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The Drop Site example accepts drops from other applications, and displays the MIME formats provided by the drag object.</db:para>
<db:para>There are two classes, <db:code>DropArea</db:code> and <db:code>DropSiteWindow</db:code>, and a <db:code>main()</db:code> function in this example. A <db:code>DropArea</db:code> object is instantiated in <db:code>DropSiteWindow</db:code>; a <db:code>DropSiteWindow</db:code> object is then invoked in the <db:code>main()</db:code> function.</db:para>
<db:section xml:id="droparea-class-definition">
<db:title>DropArea Class Definition</db:title>
<db:para>The <db:code>DropArea</db:code> class is a subclass of QLabel with a public slot, <db:code>clear()</db:code>, and a <db:code>changed()</db:code> signal.</db:para>
<db:programlisting language="cpp">class DropArea : public QLabel
{
    Q_OBJECT

public:
    explicit DropArea(QWidget *parent = nullptr);

public slots:
    void clear();

signals:
    void changed(const QMimeData *mimeData = nullptr);
</db:programlisting>
<db:para>In addition, <db:code>DropArea</db:code> also contains a private instance of QLabel and reimplementations of four <db:link xlink:href="qwidget-proxy.xml">QWidget</db:link> event handlers:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para><db:link xlink:href="">dragEnterEvent()</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="">dragMoveEvent()</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="">dragLeaveEvent()</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="">dropEvent()</db:link></db:para>
</db:listitem>
</db:orderedlist>
<db:para>These event handlers are further explained in the implementation of the <db:code>DropArea</db:code> class.</db:para>
<db:programlisting language="cpp">protected:
    void dragEnterEvent(QDragEnterEvent *event) override;
    void dragMoveEvent(QDragMoveEvent *event) override;
    void dragLeaveEvent(QDragLeaveEvent *event) override;
    void dropEvent(QDropEvent *event) override;

private:
    QLabel *label;
};
</db:programlisting>
</db:section>
<db:section xml:id="droparea-class-implementation">
<db:title>DropArea Class Implementation</db:title>
<db:para>In the <db:code>DropArea</db:code> constructor, we set the <db:link xlink:href="">minimum size</db:link> to 200x200 pixels, the <db:link xlink:href="">frame style</db:link> to both QFrame::Sunken and QFrame::StyledPanel, and we align its contents to the center.</db:para>
<db:programlisting language="cpp">DropArea::DropArea(QWidget *parent)
    : QLabel(parent)
{
    setMinimumSize(200, 200);
    setFrameStyle(QFrame::Sunken | QFrame::StyledPanel);
    setAlignment(Qt::AlignCenter);
    setAcceptDrops(true);
    setAutoFillBackground(true);
    clear();
}
</db:programlisting>
<db:para>Also, we enable drop events in <db:code>DropArea</db:code> by setting the acceptDrops property to <db:code>true</db:code>. Then, we enable the autoFillBackground property and invoke the <db:code>clear()</db:code> function.</db:para>
<db:para>The <db:link xlink:href="">dragEnterEvent()</db:link> event handler is called when a drag is in progress and the mouse enters the <db:code>DropArea</db:code> object. For the <db:code>DropSite</db:code> example, when the mouse enters <db:code>DropArea</db:code>, we set its text to &quot;&lt;drop content&gt;&quot; and highlight its background.</db:para>
<db:programlisting language="cpp">void DropArea::dragEnterEvent(QDragEnterEvent *event)
{
    setText(tr(&quot;&amp;lt;drop content&amp;gt;&quot;));
    setBackgroundRole(QPalette::Highlight);

    event-&amp;gt;acceptProposedAction();
    emit changed(event-&amp;gt;mimeData());
}
</db:programlisting>
<db:para>Then, we invoke <db:link xlink:href="">acceptProposedAction()</db:link> on <db:code role="parameter">event</db:code>, setting the drop action to the one proposed. Lastly, we emit the <db:code>changed()</db:code> signal, with the data that was dropped and its MIME type information as a parameter.</db:para>
<db:para>For <db:link xlink:href="">dragMoveEvent()</db:link>, we just accept the proposed QDragMoveEvent object, <db:code role="parameter">event</db:code>, with <db:link xlink:href="">acceptProposedAction()</db:link>.</db:para>
<db:programlisting language="cpp">void DropArea::dragMoveEvent(QDragMoveEvent *event)
{
    event-&amp;gt;acceptProposedAction();
}
</db:programlisting>
<db:para>The <db:code>DropArea</db:code> class's implementation of <db:link xlink:href="">dropEvent()</db:link> extracts the <db:code role="parameter">event</db:code>'s mime data and displays it accordingly.</db:para>
<db:programlisting language="cpp">void DropArea::dropEvent(QDropEvent *event)
{
    const QMimeData *mimeData = event-&amp;gt;mimeData();
</db:programlisting>
<db:para>The <db:code>mimeData</db:code> object can contain one of the following objects: an image, HTML text, plain text, or a list of URLs.</db:para>
<db:programlisting language="cpp">    if (mimeData-&amp;gt;hasImage()) {
        setPixmap(qvariant_cast&amp;lt;QPixmap&amp;gt;(mimeData-&amp;gt;imageData()));
    } else if (mimeData-&amp;gt;hasHtml()) {
        setText(mimeData-&amp;gt;html());
        setTextFormat(Qt::RichText);
    } else if (mimeData-&amp;gt;hasText()) {
        setText(mimeData-&amp;gt;text());
        setTextFormat(Qt::PlainText);
    } else if (mimeData-&amp;gt;hasUrls()) {
        QList&amp;lt;QUrl&amp;gt; urlList = mimeData-&amp;gt;urls();
        QString text;
        for (int i = 0; i &amp;lt; urlList.size() &amp;amp;&amp;amp; i &amp;lt; 32; ++i)
            text += urlList.at(i).path() + QLatin1Char('\n');
        setText(text);
    } else {
        setText(tr(&quot;Cannot display data&quot;));
    }
</db:programlisting>
<db:itemizedlist>
<db:listitem>
<db:para>If <db:code>mimeData</db:code> contains an image, we display it in <db:code>DropArea</db:code> with <db:link xlink:href="">setPixmap()</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>If <db:code>mimeData</db:code> contains HTML, we display it with <db:link xlink:href="">setText()</db:link> and set <db:code>DropArea</db:code>'s text format as Qt::RichText.</db:para>
</db:listitem>
<db:listitem>
<db:para>If <db:code>mimeData</db:code> contains plain text, we display it with <db:link xlink:href="">setText()</db:link> and set <db:code>DropArea</db:code>'s text format as Qt::PlainText. In the event that <db:code>mimeData</db:code> contains URLs, we iterate through the list of URLs to display them on individual lines.</db:para>
</db:listitem>
<db:listitem>
<db:para>If <db:code>mimeData</db:code> contains other types of objects, we set <db:code>DropArea</db:code>'s text, with <db:link xlink:href="">setText()</db:link> to &quot;Cannot display data&quot; to inform the user.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>We then set <db:code>DropArea</db:code>'s backgroundRole to QPalette::Dark and we accept <db:code>event</db:code>'s proposed action.</db:para>
<db:programlisting language="cpp">    setBackgroundRole(QPalette::Dark);
    event-&amp;gt;acceptProposedAction();
}
</db:programlisting>
<db:para>The <db:link xlink:href="">dragLeaveEvent()</db:link> event handler is called when a drag is in progress and the mouse leaves the widget.</db:para>
<db:programlisting language="cpp">void DropArea::dragLeaveEvent(QDragLeaveEvent *event)
{
    clear();
    event-&amp;gt;accept();
}
</db:programlisting>
<db:para>For <db:code>DropArea</db:code>'s implementation, we clear invoke <db:code>clear()</db:code> and then accept the proposed event.</db:para>
<db:para>The <db:code>clear()</db:code> function sets the text in <db:code>DropArea</db:code> to &quot;&lt;drop content&gt;&quot; and sets the backgroundRole to QPalette::Dark. Lastly, it emits the <db:code>changed()</db:code> signal.</db:para>
<db:programlisting language="cpp">void DropArea::clear()
{
    setText(tr(&quot;&amp;lt;drop content&amp;gt;&quot;));
    setBackgroundRole(QPalette::Dark);

    emit changed();
}
</db:programlisting>
</db:section>
<db:section xml:id="dropsitewindow-class-definition">
<db:title>DropSiteWindow Class Definition</db:title>
<db:para>The <db:code>DropSiteWindow</db:code> class contains a constructor and a public slot, <db:code>updateFormatsTable()</db:code>.</db:para>
<db:programlisting language="cpp">class DropSiteWindow : public QWidget
{
    Q_OBJECT

public:
    DropSiteWindow();

public slots:
    void updateFormatsTable(const QMimeData *mimeData);

private:
    DropArea *dropArea;
    QLabel *abstractLabel;
    QTableWidget *formatsTable;

    QPushButton *clearButton;
    QPushButton *quitButton;
    QDialogButtonBox *buttonBox;
};
</db:programlisting>
<db:para>The class also contains a private instance of <db:code>DropArea</db:code>, <db:code>dropArea</db:code>, QLabel, <db:code>abstractLabel</db:code>, QTableWidget, <db:code>formatsTable</db:code>, QDialogButtonBox, <db:code>buttonBox</db:code>, and two QPushButton objects, <db:code>clearButton</db:code> and <db:code>quitButton</db:code>.</db:para>
</db:section>
<db:section xml:id="dropsitewindow-class-implementation">
<db:title>DropSiteWindow Class Implementation</db:title>
<db:para>In the constructor of <db:code>DropSiteWindow</db:code>, we instantiate <db:code>abstractLabel</db:code> and set its wordWrap property to <db:code>true</db:code>. We also call the <db:link xlink:href="">adjustSize()</db:link> function to adjust <db:code>abstractLabel</db:code>'s size according to its contents.</db:para>
<db:programlisting language="cpp">DropSiteWindow::DropSiteWindow()
{
    abstractLabel = new QLabel(tr(&quot;This example accepts drags from other &quot;
                                  &quot;applications and displays the MIME types &quot;
                                  &quot;provided by the drag object.&quot;));
    abstractLabel-&amp;gt;setWordWrap(true);
    abstractLabel-&amp;gt;adjustSize();
</db:programlisting>
<db:para>Then we instantiate <db:code>dropArea</db:code> and connect its <db:code>changed()</db:code> signal to <db:code>DropSiteWindow</db:code>'s <db:code>updateFormatsTable()</db:code> slot.</db:para>
<db:programlisting language="cpp">    dropArea = new DropArea;
    connect(dropArea, &amp;amp;DropArea::changed,
            this, &amp;amp;DropSiteWindow::updateFormatsTable);
</db:programlisting>
<db:para>We now set up the QTableWidget object, <db:code>formatsTable</db:code>. Its horizontal header is set using a <db:link xlink:href="qstringlist.xml">QStringList</db:link> object, <db:code>labels</db:code>. The number of columms are set to two and the table is not editable. Also, the <db:code>formatTable</db:code>'s horizontal header is formatted to ensure that its second column stretches to occupy additional space available.</db:para>
<db:programlisting language="cpp">    QStringList labels;
    labels &amp;lt;&amp;lt; tr(&quot;Format&quot;) &amp;lt;&amp;lt; tr(&quot;Content&quot;);

    formatsTable = new QTableWidget;
    formatsTable-&amp;gt;setColumnCount(2);
    formatsTable-&amp;gt;setEditTriggers(QAbstractItemView::NoEditTriggers);
    formatsTable-&amp;gt;setHorizontalHeaderLabels(labels);
    formatsTable-&amp;gt;horizontalHeader()-&amp;gt;setStretchLastSection(true);
</db:programlisting>
<db:para>Two QPushButton objects, <db:code>clearButton</db:code> and <db:code>quitButton</db:code>, are instantiated and added to <db:code>buttonBox</db:code> - a QDialogButtonBox object. We use QDialogButtonBox here to ensure that the push buttons are presented in a layout that conforms to the platform's style.</db:para>
<db:programlisting language="cpp">    clearButton = new QPushButton(tr(&quot;Clear&quot;));
    quitButton = new QPushButton(tr(&quot;Quit&quot;));

    buttonBox = new QDialogButtonBox;
    buttonBox-&amp;gt;addButton(clearButton, QDialogButtonBox::ActionRole);
    buttonBox-&amp;gt;addButton(quitButton, QDialogButtonBox::RejectRole);

    connect(quitButton, &amp;amp;QAbstractButton::clicked, this, &amp;amp;QWidget::close);
    connect(clearButton, &amp;amp;QAbstractButton::clicked, dropArea, &amp;amp;DropArea::clear);
</db:programlisting>
<db:para>The <db:link xlink:href="">clicked()</db:link> signals for <db:code>quitButton</db:code> and <db:code>clearButton</db:code> are connected to <db:link xlink:href="">close()</db:link> and <db:code>clear()</db:code>, respectively.</db:para>
<db:para>For the layout, we use a QVBoxLayout, <db:code>mainLayout</db:code>, to arrange our widgets vertically. We also set the window title to &quot;Drop Site&quot; and the minimum size to 350x500 pixels.</db:para>
<db:programlisting language="cpp">    QVBoxLayout *mainLayout = new QVBoxLayout(this);
    mainLayout-&amp;gt;addWidget(abstractLabel);
    mainLayout-&amp;gt;addWidget(dropArea);
    mainLayout-&amp;gt;addWidget(formatsTable);
    mainLayout-&amp;gt;addWidget(buttonBox);

    setWindowTitle(tr(&quot;Drop Site&quot;));
    setMinimumSize(350, 500);
}
</db:programlisting>
<db:para>We move on to the <db:code>updateFormatsTable()</db:code> function. This function updates the <db:code>formatsTable</db:code>, displaying the MIME formats of the object dropped onto the <db:code>DropArea</db:code> object. First, we set QTableWidget's rowCount property to 0. Then, we validate to ensure that the QMimeData object passed in is a valid object.</db:para>
<db:programlisting language="cpp">void DropSiteWindow::updateFormatsTable(const QMimeData *mimeData)
{
    formatsTable-&amp;gt;setRowCount(0);
    if (!mimeData)
        return;
</db:programlisting>
<db:para>Once we are sure that <db:code>mimeData</db:code> is valid, we iterate through its supported formats.</db:para>
<db:note>
<db:para>The <db:link xlink:href="">formats()</db:link> function returns a <db:link xlink:href="qstringlist.xml">QStringList</db:link> object, containing all the formats supported by the <db:code>mimeData</db:code>.</db:para>
</db:note>
<db:programlisting language="cpp">    const QStringList formats = mimeData-&amp;gt;formats();
    for (const QString &amp;amp;format : formats) {
        QTableWidgetItem *formatItem = new QTableWidgetItem(format);
        formatItem-&amp;gt;setFlags(Qt::ItemIsEnabled);
        formatItem-&amp;gt;setTextAlignment(Qt::AlignTop | Qt::AlignLeft);
</db:programlisting>
<db:para>Within each iteration, we create a QTableWidgetItem, <db:code>formatItem</db:code> and we set its flags to Qt::ItemIsEnabled, and its <db:link xlink:href="">text alignment</db:link> to Qt::AlignTop and Qt::AlignLeft.</db:para>
<db:para>A QString object, <db:code>text</db:code>, is customized to display data according to the contents of <db:code>format</db:code>. We invoke <db:link xlink:href="qstring-proxy.xml">QString</db:link>'s <db:link xlink:href="">simplified()</db:link> function on <db:code>text</db:code>, to obtain a string that has no additional space before, after or in between words.</db:para>
<db:programlisting language="cpp">        QString text;
        if (format == QLatin1String(&quot;text/plain&quot;)) {
            text = mimeData-&amp;gt;text().simplified();
        } else if (format == QLatin1String(&quot;text/html&quot;)) {
            text = mimeData-&amp;gt;html().simplified();
        } else if (format == QLatin1String(&quot;text/uri-list&quot;)) {
            QList&amp;lt;QUrl&amp;gt; urlList = mimeData-&amp;gt;urls();
            for (int i = 0; i &amp;lt; urlList.size() &amp;amp;&amp;amp; i &amp;lt; 32; ++i)
                text.append(urlList.at(i).toString() + QLatin1Char(' '));
        } else {
            QByteArray data = mimeData-&amp;gt;data(format);
            for (int i = 0; i &amp;lt; data.size() &amp;amp;&amp;amp; i &amp;lt; 32; ++i)
                text.append(QStringLiteral(&quot;%1 &quot;).arg(uchar(data[i]), 2, 16, QLatin1Char('0')).toUpper());
        }
</db:programlisting>
<db:para>If <db:code>format</db:code> contains a list of URLs, we iterate through them, using spaces to separate them. On the other hand, if <db:code>format</db:code> contains an image, we display the data by converting the text to hexadecimal.</db:para>
<db:programlisting language="cpp">        int row = formatsTable-&amp;gt;rowCount();
        formatsTable-&amp;gt;insertRow(row);
        formatsTable-&amp;gt;setItem(row, 0, new QTableWidgetItem(format));
        formatsTable-&amp;gt;setItem(row, 1, new QTableWidgetItem(text));
    }

    formatsTable-&amp;gt;resizeColumnToContents(0);
}
</db:programlisting>
<db:para>Once <db:code>text</db:code> has been customized to contain the appropriate data, we insert both <db:code>format</db:code> and <db:code>text</db:code> into <db:code>formatsTable</db:code> with <db:link xlink:href="">setItem()</db:link>. Lastly, we invoke <db:link xlink:href="">resizeColumnToContents()</db:link> on <db:code>formatsTable</db:code>'s first column.</db:para>
</db:section>
<db:section xml:id="the-main-function">
<db:title>The main() Function</db:title>
<db:para>Within the <db:code>main()</db:code> function, we instantiate <db:code>DropSiteWindow</db:code> and invoke its <db:link xlink:href="">show()</db:link> function.</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    DropSiteWindow window;
    window.show();
    return app.exec();
}
</db:programlisting>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/draganddrop/dropsite?h=5.14">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
