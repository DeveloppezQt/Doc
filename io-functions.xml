<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>File and Datastream Functions</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.13.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Core Reference Documentation.</db:para></db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The QIODevice class is the base interface class of all I/O devices in <db:link xlink:href="qtcore-index.xml">Qt Core</db:link>. QIODevice provides both a common implementation and an abstract interface for devices that support reading and writing of blocks of data. The device can be a memory buffer, a file, or a datastream.</db:para>
<db:para>Some subclasses like QFile have been implemented using a memory buffer for intermediate storing of data. This speeds up programs by reducing read/write operations. Buffering makes functions like <db:link xlink:href="">getChar()</db:link> and <db:link xlink:href="">putChar()</db:link> fast, as they can operate on the memory buffer instead of directly on the device itself.</db:para>
<db:para>The QFile class provides functions for reading from and writing to files. A QFile may be used by itself or, more conveniently, with a QTextStream or QDataStream.</db:para>
<db:para>QBuffer allows you to access a QByteArray using the QIODevice interface. The QByteArray is treated just as a standard random-accessed file. An example:</db:para>
<db:programlisting language="cpp">QBuffer buffer;
char ch;

buffer.open(QBuffer::ReadWrite);
buffer.write(&quot;Qt rocks!&quot;);
buffer.seek(0);
buffer.getChar(&amp;amp;ch);  // ch == 'Q'
buffer.getChar(&amp;amp;ch);  // ch == 't'
buffer.getChar(&amp;amp;ch);  // ch == ' '
buffer.getChar(&amp;amp;ch);  // ch == 'r'
</db:programlisting>
<db:para>Call <db:link xlink:href="">open()</db:link> to open the buffer. Then call <db:link xlink:href="">write()</db:link> or <db:link xlink:href="">putChar()</db:link> to write to the buffer, and <db:link xlink:href="">read()</db:link>, <db:link xlink:href="">readLine()</db:link>, <db:link xlink:href="">readAll()</db:link>, or <db:link xlink:href="">getChar()</db:link> to read from it. <db:link xlink:href="">size()</db:link> returns the current size of the buffer, and you can seek to arbitrary positions in the buffer by calling <db:link xlink:href="">seek()</db:link>. When you are done with accessing the buffer, call <db:link xlink:href="">close()</db:link>.</db:para>
<db:para>The QDataStream class provides serialization of binary data to a QIODevice. A data stream is a binary stream of encoded information which is 100% inde- pendent of the host computer's operating system, CPU or byte order. For example, a data stream that is written by a PC under Windows can be read by a Sun SPARC running Solaris. You can also use a data stream to read/write raw unencoded binary data.</db:para>
<db:para>For more details on the datatypes that QDataStream can serialize, see <db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link>.</db:para>
<db:para>The QTextStream class provides a convenient interface for reading and writing text. QTextStream can operate on a QIODevice, a QByteArray or a QString. Using QTextStream's streaming operators, you can conveniently read and write words, lines and numbers. It's also common to use QTextStream to read console input and write console output.</db:para>
<db:para>There are three general ways to use QTextStream when reading text files:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Chunk by chunk, by calling <db:link xlink:href="">readLine()</db:link> or <db:link xlink:href="">readAll()</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Word by word. QTextStream supports streaming into <db:link xlink:href="qstring-proxy.xml">QString</db:link>s, <db:link xlink:href="qbytearray-proxy.xml">QByteArray</db:link>s and char* buffers. Words are delimited by space, and leading white space is automatically skipped.</db:para>
</db:listitem>
<db:listitem>
<db:para>Character by character, by streaming into QChar or char types. This method is often used for convenient input handling when parsing files, independent of character encoding and end-of-line semantics. To skip white space, call <db:link xlink:href="">skipWhiteSpace()</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>QByteArray can be used to store both raw bytes (including \0) and traditional 8-bit '\0'-terminated strings. Using QByteArray is much more convenient than using const char *. It always ensures that the data is followed by a '\0' terminator, and uses <db:link xlink:href="implicit-sharing.xml">implicitly shared classes</db:link> (copy-on-write) to reduce memory usage and avoid needless copying of data.</db:para>
<db:para>In addition to QByteArray, Qt also provides the QString class to store string data. For most purposes, QString is the most appropriate class to use. It stores 16-bit Unicode characters. It is, however, a good idea to use QByteArray when you need to store raw binary data, and when memory conservation is critical (for example, with Qt for Embedded Linux).</db:para>
</db:article>
