<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Style Sheets Examples</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.14.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:extendedlink xlink:type="extended"><db:link xlink:to="stylesheet-reference.xml" xlink:type="arc" xlink:arcrole="prev" xlink:title="Qt Style Sheets Reference"/></db:extendedlink>
<db:abstract>
<db:para>Qt Widgets Reference Documentation.</db:para></db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para><db:emphasis role="bold">&lt;Unknown command&gt;<db:code>contentspage</db:code></db:emphasis>{Qt Style Sheets}{Contents}</db:para>
<db:para>We will now see a few examples to get started with using Qt Style Sheets.</db:para>
<db:section xml:id="style-sheet-usage">
<db:title>Style Sheet Usage</db:title>
<db:section xml:id="customizing-the-foreground-and-background-colors">
<db:title>Customizing the Foreground and Background Colors</db:title>
<db:para>Let's start by setting yellow as the background color of all QLineEdits in an application. This could be achieved like this:</db:para>
<db:programlisting language="cpp">qApp-&amp;gt;setStyleSheet(&quot;QLineEdit { background-color: yellow }&quot;);
</db:programlisting>
<db:para>If we want the property to apply only to the QLineEdits that are children (or grandchildren or grand-grandchildren) of a specific dialog, we would rather do this:</db:para>
<db:programlisting language="cpp">myDialog-&amp;gt;setStyleSheet(&quot;QLineEdit { background-color: yellow }&quot;);
</db:programlisting>
<db:para>If we want the property to apply only to one specific QLineEdit, we can give it a name using QObject::setObjectName() and use an ID Selector to refer to it:</db:para>
<db:programlisting language="cpp">myDialog-&amp;gt;setStyleSheet(&quot;QLineEdit#nameEdit { background-color: yellow }&quot;);
</db:programlisting>
<db:para>Alternatively, we can set the <db:link xlink:href="stylesheet-reference.xml#background-prop">background-color</db:link> property directly on the QLineEdit, omitting the selector:</db:para>
<db:programlisting language="cpp">nameEdit-&amp;gt;setStyleSheet(&quot;background-color: yellow&quot;);
</db:programlisting>
<db:para>To ensure a good contrast, we should also specify a suitable color for the text:</db:para>
<db:programlisting language="cpp">nameEdit-&amp;gt;setStyleSheet(&quot;color: blue; background-color: yellow&quot;);
</db:programlisting>
<db:para>It might be a good idea to change the colors used for selected text as well:</db:para>
<db:programlisting language="cpp">nameEdit-&amp;gt;setStyleSheet(&quot;color: blue;&quot;
                        &quot;background-color: yellow;&quot;
                        &quot;selection-color: yellow;&quot;
                        &quot;selection-background-color: blue;&quot;);
</db:programlisting>
</db:section>
<db:section xml:id="customizing-using-dynamic-properties">
<db:title>Customizing Using Dynamic Properties</db:title>
<db:para>There are many situations where we need to present a form that has mandatory fields. To indicate to the user that the field is mandatory, one effective (albeit esthetically dubious) solution is to use yellow as the background color for those fields. It turns out this is very easy to implement using Qt Style Sheets. First, we would use the following application-wide style sheet:</db:para>
<db:programlisting language="cpp">*[mandatoryField=&quot;true&quot;] { background-color: yellow }
</db:programlisting>
<db:para>This means that every widget whose mandatoryField Qt property is set to true would have a yellow background.</db:para>
<db:para>Then, for each mandatory field widget, we would simply create a mandatoryField property on the fly and set it to true. For example:</db:para>
<db:programlisting language="cpp">QLineEdit *nameEdit = new QLineEdit(this);
nameEdit-&amp;gt;setProperty(&quot;mandatoryField&quot;, true);

QLineEdit *emailEdit = new QLineEdit(this);
emailEdit-&amp;gt;setProperty(&quot;mandatoryField&quot;, true);

QSpinBox *ageSpinBox = new QSpinBox(this);
ageSpinBox-&amp;gt;setProperty(&quot;mandatoryField&quot;, true);
</db:programlisting>
</db:section>
<db:section xml:id="customizing-a-qpushbutton-using-the-box-model">
<db:title>Customizing a QPushButton Using the Box Model</db:title>
<db:para>This time, we will show how to create a red QPushButton. This QPushButton would presumably be connected to a very destructive piece of code.</db:para>
<db:para>First, we are tempted to use this style sheet:</db:para>
<db:programlisting language="cpp">QPushButton#evilButton { background-color: red }
</db:programlisting>
<db:para>However, the result is a boring, flat button with no borders:</db:para>
<db:mediaobject>
<db:alt>A flat red button</db:alt>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-redbutton1.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>What happened is this:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>We have made a request that cannot be satisfied using the native styles alone (e.g., the Windows Vista theme engine doesn't let us specify the background color of a button).</db:para>
</db:listitem>
<db:listitem>
<db:para>Therefore, the button is rendered using style sheets.</db:para>
</db:listitem>
<db:listitem>
<db:para>We haven't specified any values for <db:link xlink:href="stylesheet-reference.xml#border-width-prop">border-width</db:link> and <db:link xlink:href="stylesheet-reference.xml#border-style-prop">border-style</db:link>, so by default we obtain a 0-pixel wide border of style none.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Let's improve the situation by specifying a border:</db:para>
<db:programlisting language="cpp">QPushButton#evilButton {
    background-color: red;
    border-style: outset;
    border-width: 2px;
    border-color: beige;
}
</db:programlisting>
<db:mediaobject>
<db:alt>A red button with a beige border</db:alt>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-redbutton2.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Things look already a lot better. But the button looks a bit cramped. Let's specify some spacing between the border and the text using the <db:link xlink:href="stylesheet-reference.xml#padding-prop">padding</db:link>. Additionally, we will enforce a minimum width, round the corners, and specify a larger font to make the button look nicer:</db:para>
<db:programlisting language="cpp">QPushButton#evilButton {
    background-color: red;
    border-style: outset;
    border-width: 2px;
    border-radius: 10px;
    border-color: beige;
    font: bold 14px;
    min-width: 10em;
    padding: 6px;
}
</db:programlisting>
<db:mediaobject>
<db:alt>A red button with a round beige border and big, bold text</db:alt>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-redbutton3.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The only issue remaining is that the button doesn't react when we press it. We can fix this by specifying a slightly different background color and use a different border style.</db:para>
<db:programlisting language="cpp">QPushButton#evilButton {
    background-color: red;
    border-style: outset;
    border-width: 2px;
    border-radius: 10px;
    border-color: beige;
    font: bold 14px;
    min-width: 10em;
    padding: 6px;
}
QPushButton#evilButton:pressed {
    background-color: rgb(224, 0, 0);
    border-style: inset;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-the-qpushbutton-s-menu-indicator-sub-control">
<db:title>Customizing the QPushButton's Menu Indicator Sub-Control</db:title>
<db:para>Subcontrols give access to the sub-elements of a widget. For example, a QPushButton associated with a menu (using QPushButton::setMenu()) has a menu indicator. Let's customize the menu indicator for the red push button:</db:para>
<db:programlisting language="cpp">QPushButton#evilButton::menu-indicator {
    image: url(myindicator.png);
}
</db:programlisting>
<db:para>By default, the menu indicator is located at the bottom-right corner of the padding rectangle. We can change this by specifying <db:link xlink:href="stylesheet-reference.xml#subcontrol-position-prop">subcontrol-position</db:link> and <db:link xlink:href="stylesheet-reference.xml#subcontrol-origin-prop">subcontrol-origin</db:link> to anchor the indicator differently. We can also use <db:link xlink:href="stylesheet-reference.xml#top-prop">top</db:link> and <db:link xlink:href="stylesheet-reference.xml#left-prop">left</db:link> to move the indicator by a few pixels. For example:</db:para>
<db:programlisting language="cpp">QPushButton::menu-indicator {
    image: url(myindicator.png);
    subcontrol-position: right center;
    subcontrol-origin: padding;
    left: -2px;
}
</db:programlisting>
<db:para>This positions the myindicator.png to the center right of the QPushButton's <db:link xlink:href="stylesheet-reference.xml#padding-prop">padding</db:link> rectangle (see <db:link xlink:href="stylesheet-reference.xml#subcontrol-origin-prop">subcontrol-origin</db:link> for more information).</db:para>
</db:section>
<db:section xml:id="complex-selector-example">
<db:title>Complex Selector Example</db:title>
<db:para>Since red seems to be our favorite color, let's make the text in QLineEdit red by setting the following application-wide stylesheet:</db:para>
<db:programlisting language="cpp">QLineEdit { color: red }
</db:programlisting>
<db:para>However, we would like to give a visual indication that a QLineEdit is read-only by making it appear gray:</db:para>
<db:programlisting language="cpp">QLineEdit { color: red }
QLineEdit[readOnly=&quot;true&quot;] { color: gray }
</db:programlisting>
<db:para>At some point, our design team comes with the requirement that all QLineEdits in the registration form (with the <db:link xlink:href="">object name</db:link> registrationDialog) to be brown:</db:para>
<db:programlisting language="cpp">QLineEdit { color: red }
QLineEdit[readOnly=&quot;true&quot;] { color: gray }
#registrationDialog QLineEdit { color: brown }
</db:programlisting>
<db:para>A few UI design meetings later, we decide that all our QDialogs should have brown colored QLineEdits:</db:para>
<db:programlisting language="cpp">QLineEdit { color: red }
QLineEdit[readOnly=&quot;true&quot;] { color: gray }
QDialog QLineEdit { color: brown }
</db:programlisting>
<db:para>Quiz: What happens if we have a read-only QLineEdit in a QDialog? [Hint: The <db:link xlink:href="stylesheet-syntax.xml#conflict-resolution">Conflict Resolution</db:link> section above explains what happens in cases like this.]</db:para>
</db:section>
</db:section>
<db:section xml:id="customizing-specific-widgets">
<db:title>Customizing Specific Widgets</db:title>
<db:para>This section provides examples to customize specific widgets using Style Sheets.</db:para>
<db:section xml:id="customizing-qabstractscrollarea">
<db:title>Customizing QAbstractScrollArea</db:title>
<db:para>The background of any QAbstractScrollArea (Item views, QTextEdit and QTextBrowser) can be set using the background properties. For example, to set a background-image that scrolls with the scroll bar:</db:para>
<db:programlisting language="cpp">QTextEdit, QListView {
    background-color: white;
    background-image: url(draft.png);
    background-attachment: scroll;
}
</db:programlisting>
<db:para>If the background-image is to be fixed with the viewport:</db:para>
<db:programlisting language="cpp">QTextEdit, QListView {
    background-color: white;
    background-image: url(draft.png);
    background-attachment: fixed;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qcheckbox">
<db:title>Customizing QCheckBox</db:title>
<db:para>Styling of a QCheckBox is almost identical to styling a QRadioButton. The main difference is that a tristate QCheckBox has an indeterminate state.</db:para>
<db:programlisting language="cpp">QCheckBox {
    spacing: 5px;
}

QCheckBox::indicator {
    width: 13px;
    height: 13px;
}

QCheckBox::indicator:unchecked {
    image: url(:/images/checkbox_unchecked.png);
}

QCheckBox::indicator:unchecked:hover {
    image: url(:/images/checkbox_unchecked_hover.png);
}

QCheckBox::indicator:unchecked:pressed {
    image: url(:/images/checkbox_unchecked_pressed.png);
}

QCheckBox::indicator:checked {
    image: url(:/images/checkbox_checked.png);
}

QCheckBox::indicator:checked:hover {
    image: url(:/images/checkbox_checked_hover.png);
}

QCheckBox::indicator:checked:pressed {
    image: url(:/images/checkbox_checked_pressed.png);
}

QCheckBox::indicator:indeterminate:hover {
    image: url(:/images/checkbox_indeterminate_hover.png);
}

QCheckBox::indicator:indeterminate:pressed {
    image: url(:/images/checkbox_indeterminate_pressed.png);
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qcombobox">
<db:title>Customizing QComboBox</db:title>
<db:para>We will look at an example where the drop down button of a QComboBox appears &quot;merged&quot; with the combo box frame.</db:para>
<db:programlisting language="cpp">QComboBox {
    border: 1px solid gray;
    border-radius: 3px;
    padding: 1px 18px 1px 3px;
    min-width: 6em;
}

QComboBox:editable {
    background: white;
}

QComboBox:!editable, QComboBox::drop-down:editable {
     background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                 stop: 0 #E1E1E1, stop: 0.4 #DDDDDD,
                                 stop: 0.5 #D8D8D8, stop: 1.0 #D3D3D3);
}

/* QComboBox gets the &quot;on&quot; state when the popup is open */
QComboBox:!editable:on, QComboBox::drop-down:editable:on {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #D3D3D3, stop: 0.4 #D8D8D8,
                                stop: 0.5 #DDDDDD, stop: 1.0 #E1E1E1);
}

QComboBox:on { /* shift the text when the popup opens */
    padding-top: 3px;
    padding-left: 4px;
}

QComboBox::drop-down {
    subcontrol-origin: padding;
    subcontrol-position: top right;
    width: 15px;

    border-left-width: 1px;
    border-left-color: darkgray;
    border-left-style: solid; /* just a single line */
    border-top-right-radius: 3px; /* same radius as the QComboBox */
    border-bottom-right-radius: 3px;
}

QComboBox::down-arrow {
    image: url(/usr/share/icons/crystalsvg/16x16/actions/1downarrow.png);
}

QComboBox::down-arrow:on { /* shift the arrow when popup is open */
    top: 1px;
    left: 1px;
}
</db:programlisting>
<db:para>The pop-up of the QComboBox is a QAbstractItemView and is styled using the descendant selector:</db:para>
<db:programlisting language="cpp">QComboBox QAbstractItemView {
    border: 2px solid darkgray;
    selection-background-color: lightgray;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qdockwidget">
<db:title>Customizing QDockWidget</db:title>
<db:para>The title bar and the buttons of a QDockWidget can be customized as follows:</db:para>
<db:programlisting language="cpp">QDockWidget {
    border: 1px solid lightgray;
    titlebar-close-icon: url(close.png);
    titlebar-normal-icon: url(undock.png);
}

QDockWidget::title {
    text-align: left; /* align the text to the left */
    background: lightgray;
    padding-left: 5px;
}

QDockWidget::close-button, QDockWidget::float-button {
    border: 1px solid transparent;
    background: darkgray;
    padding: 0px;
}

QDockWidget::close-button:hover, QDockWidget::float-button:hover {
    background: gray;
}

QDockWidget::close-button:pressed, QDockWidget::float-button:pressed {
    padding: 1px -1px -1px 1px;
}
</db:programlisting>
<db:para>If one desires to move the dock widget buttons to the left, the following style sheet can be used:</db:para>
<db:programlisting language="cpp">QDockWidget {
    border: 1px solid lightgray;
    titlebar-close-icon: url(close.png);
    titlebar-normal-icon: url(float.png);
}

QDockWidget::title {
    text-align: left;
    background: lightgray;
    padding-left: 35px;
}

QDockWidget::close-button, QDockWidget::float-button {
    background: darkgray;
    padding: 0px;
    icon-size: 14px; /* maximum icon size */
}

QDockWidget::close-button:hover, QDockWidget::float-button:hover {
    background: gray;
}

QDockWidget::close-button:pressed, QDockWidget::float-button:pressed {
    padding: 1px -1px -1px 1px;
}

QDockWidget::close-button {
    subcontrol-position: top left;
    subcontrol-origin: margin;
    position: absolute;
    top: 0px; left: 0px; bottom: 0px;
    width: 14px;
}

QDockWidget::float-button {
    subcontrol-position: top left;
    subcontrol-origin: margin;
    position: absolute;
    top: 0px; left: 16px; bottom: 0px;
    width: 14px;
}
</db:programlisting>
<db:note>
<db:para>To customize the separator (resize handle) of a QDockWidget, use QMainWindow::separator.</db:para>
</db:note>
</db:section>
<db:section xml:id="customizing-qframe">
<db:title>Customizing QFrame</db:title>
<db:para>A QFrame is styled using the <db:link xlink:href="stylesheet-customizing.xml#the-box-model">The Box Model</db:link>.</db:para>
<db:programlisting language="cpp">QFrame, QLabel, QToolTip {
    border: 2px solid green;
    border-radius: 4px;
    padding: 2px;
    background-image: url(images/welcome.png);
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qgroupbox">
<db:title>Customizing QGroupBox</db:title>
<db:para>Let us look at an example that moves the QGroupBox's title to the center.</db:para>
<db:programlisting language="cpp">QGroupBox {
    background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                      stop: 0 #E0E0E0, stop: 1 #FFFFFF);
    border: 2px solid gray;
    border-radius: 5px;
    margin-top: 1ex; /* leave space at the top for the title */
}

QGroupBox::title {
    subcontrol-origin: margin;
    subcontrol-position: top center; /* position at the top center */
    padding: 0 3px;
    background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                      stop: 0 #FF0ECE, stop: 1 #FFFFFF);
}
</db:programlisting>
<db:para>For a checkable QGroupBox, use the {#indicator-sub}{::indicator} subcontrol and style it exactly like a QCheckBox (i.e)</db:para>
<db:programlisting language="cpp">QGroupBox::indicator {
    width: 13px;
    height: 13px;
}

QGroupBox::indicator:unchecked {
    image: url(:/images/checkbox_unchecked.png);
}

/* proceed with styling just like QCheckBox */
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qheaderview">
<db:title>Customizing QHeaderView</db:title>
<db:para>QHeaderView is customized as follows:</db:para>
<db:programlisting language="cpp">QHeaderView::section {
    background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                      stop:0 #616161, stop: 0.5 #505050,
                                      stop: 0.6 #434343, stop:1 #656565);
    color: white;
    padding-left: 4px;
    border: 1px solid #6c6c6c;
}

QHeaderView::section:checked
{
    background-color: red;
}

/* style the sort indicator */
QHeaderView::down-arrow {
    image: url(down_arrow.png);
}

QHeaderView::up-arrow {
    image: url(up_arrow.png);
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qlineedit">
<db:title>Customizing QLineEdit</db:title>
<db:para>The frame of a QLineEdit is styled using the <db:link xlink:href="stylesheet-customizing.xml#the-box-model">The Box Model</db:link>. To create a line edit with rounded corners, we can set:</db:para>
<db:programlisting language="cpp">QLineEdit {
    border: 2px solid gray;
    border-radius: 10px;
    padding: 0 8px;
    background: yellow;
    selection-background-color: darkgray;
}
</db:programlisting>
<db:para>The password character of line edits that have QLineEdit::Password echo mode can be set using:</db:para>
<db:programlisting language="cpp">QLineEdit[echoMode=&quot;2&quot;] {
    lineedit-password-character: 9679;
}
</db:programlisting>
<db:para>The background of a read only QLineEdit can be modified as below:</db:para>
<db:programlisting language="cpp">QLineEdit:read-only {
    background: lightblue;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qlistview">
<db:title>Customizing QListView</db:title>
<db:para>The background color of alternating rows can be customized using the following style sheet:</db:para>
<db:programlisting language="cpp">QListView {
    alternate-background-color: yellow;
}
</db:programlisting>
<db:para>To provide a special background when you hover over items, we can use the <db:link xlink:href="stylesheet-reference.xml#item-sub">::item</db:link> subcontrol. For example,</db:para>
<db:programlisting language="cpp">QListView {
    show-decoration-selected: 1; /* make the selection span the entire width of the view */
}

QListView::item:alternate {
    background: #EEEEEE;
}

QListView::item:selected {
    border: 1px solid #6a6ea9;
}

QListView::item:selected:!active {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #ABAFE5, stop: 1 #8588B2);
}

QListView::item:selected:active {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #6a6ea9, stop: 1 #888dd9);
}

QListView::item:hover {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #FAFBFE, stop: 1 #DCDEF1);
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qmainwindow">
<db:title>Customizing QMainWindow</db:title>
<db:para>The separator of a QMainWindow can be styled as follows:</db:para>
<db:programlisting language="cpp">QMainWindow::separator {
    background: yellow;
    width: 10px; /* when vertical */
    height: 10px; /* when horizontal */
}

QMainWindow::separator:hover {
    background: red;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qmenu">
<db:title>Customizing QMenu</db:title>
<db:para>Individual items of a QMenu are styled using the 'item' subcontrol as follows:</db:para>
<db:programlisting language="cpp">QMenu {
    background-color: #ABABAB; /* sets background of the menu */
    border: 1px solid black;
}

QMenu::item {
    /* sets background of menu item. set this to something non-transparent
        if you want menu color and menu item color to be different */
    background-color: transparent;
}

QMenu::item:selected { /* when user selects item using mouse or keyboard */
    background-color: #654321;
}
</db:programlisting>
<db:para>For a more advanced customization, use a style sheet as follows:</db:para>
<db:programlisting language="cpp">QMenu {
    background-color: white;
    margin: 2px; /* some spacing around the menu */
}

QMenu::item {
    padding: 2px 25px 2px 20px;
    border: 1px solid transparent; /* reserve space for selection border */
}

QMenu::item:selected {
    border-color: darkblue;
    background: rgba(100, 100, 100, 150);
}

QMenu::icon:checked { /* appearance of a 'checked' icon */
    background: gray;
    border: 1px inset gray;
    position: absolute;
    top: 1px;
    right: 1px;
    bottom: 1px;
    left: 1px;
}

QMenu::separator {
    height: 2px;
    background: lightblue;
    margin-left: 10px;
    margin-right: 5px;
}

QMenu::indicator {
    width: 13px;
    height: 13px;
}

/* non-exclusive indicator = check box style indicator (see QActionGroup::setExclusive) */
QMenu::indicator:non-exclusive:unchecked {
    image: url(:/images/checkbox_unchecked.png);
}

QMenu::indicator:non-exclusive:unchecked:selected {
    image: url(:/images/checkbox_unchecked_hover.png);
}

QMenu::indicator:non-exclusive:checked {
    image: url(:/images/checkbox_checked.png);
}

QMenu::indicator:non-exclusive:checked:selected {
    image: url(:/images/checkbox_checked_hover.png);
}

/* exclusive indicator = radio button style indicator (see QActionGroup::setExclusive) */
QMenu::indicator:exclusive:unchecked {
    image: url(:/images/radiobutton_unchecked.png);
}

QMenu::indicator:exclusive:unchecked:selected {
    image: url(:/images/radiobutton_unchecked_hover.png);
}

QMenu::indicator:exclusive:checked {
    image: url(:/images/radiobutton_checked.png);
}

QMenu::indicator:exclusive:checked:selected {
    image: url(:/images/radiobutton_checked_hover.png);
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qmenubar">
<db:title>Customizing QMenuBar</db:title>
<db:para>QMenuBar is styled as follows:</db:para>
<db:programlisting language="cpp">QMenuBar {
    background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                      stop:0 lightgray, stop:1 darkgray);
    spacing: 3px; /* spacing between menu bar items */
}

QMenuBar::item {
    padding: 1px 4px;
    background: transparent;
    border-radius: 4px;
}

QMenuBar::item:selected { /* when selected using mouse or keyboard */
    background: #a8a8a8;
}

QMenuBar::item:pressed {
    background: #888888;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qprogressbar">
<db:title>Customizing QProgressBar</db:title>
<db:para>The QProgressBar's <db:link xlink:href="stylesheet-reference.xml#border-prop">border</db:link>, <db:link xlink:href="stylesheet-reference.xml#chunk-sub">chunk</db:link>, and <db:link xlink:href="stylesheet-reference.xml#text-align-prop">text-align</db:link> can be customized using style sheets. However, if one property or sub-control is customized, all the other properties or sub-controls must be customized as well.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/progressBar-stylesheet.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>For example, we change the <db:link xlink:href="stylesheet-reference.xml#border-prop">border</db:link> to grey and the <db:link xlink:href="stylesheet-reference.xml#chunk-sub">chunk</db:link> to cerulean.</db:para>
<db:programlisting language="cpp">QProgressBar {
    border: 2px solid grey;
    border-radius: 5px;
}

QProgressBar::chunk {
    background-color: #05B8CC;
    width: 20px;
}
</db:programlisting>
<db:para>This leaves the <db:link xlink:href="stylesheet-reference.xml#text-align-prop">text-align</db:link>, which we customize by positioning the text in the center of the progress bar.</db:para>
<db:programlisting language="cpp">QProgressBar {
    border: 2px solid grey;
    border-radius: 5px;
    text-align: center;
}
</db:programlisting>
<db:para>A <db:link xlink:href="stylesheet-reference.xml#margin-prop">margin</db:link> can be included to obtain more visible chunks.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/progressBar2-stylesheet.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>In the screenshot above, we use a <db:link xlink:href="stylesheet-reference.xml#margin-prop">margin</db:link> of 0.5 pixels.</db:para>
<db:programlisting language="cpp">QProgressBar::chunk {
    background-color: #CD96CD;
    width: 10px;
    margin: 0.5px;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qpushbutton">
<db:title>Customizing QPushButton</db:title>
<db:para>A QPushButton is styled as follows:</db:para>
<db:programlisting language="cpp">QPushButton {
    border: 2px solid #8f8f91;
    border-radius: 6px;
    background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                      stop: 0 #f6f7fa, stop: 1 #dadbde);
    min-width: 80px;
}

QPushButton:pressed {
    background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                      stop: 0 #dadbde, stop: 1 #f6f7fa);
}

QPushButton:flat {
    border: none; /* no border for a flat push button */
}

QPushButton:default {
    border-color: navy; /* make the default button prominent */
}
</db:programlisting>
<db:para>For a QPushButton with a menu, use the <db:link xlink:href="stylesheet-reference.xml#menu-indicator-sub">::menu-indicator</db:link> subcontrol.</db:para>
<db:programlisting language="cpp">QPushButton:open { /* when the button has its menu open */
    background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                      stop: 0 #dadbde, stop: 1 #f6f7fa);
}

QPushButton::menu-indicator {
    image: url(menu_indicator.png);
    subcontrol-origin: padding;
    subcontrol-position: bottom right;
}

QPushButton::menu-indicator:pressed, QPushButton::menu-indicator:open {
    position: relative;
    top: 2px; left: 2px; /* shift the arrow by 2 px */
}
</db:programlisting>
<db:para>Checkable QPushButton have the <db:link xlink:href="stylesheet-reference.xml#checked-ps">:checked</db:link> pseudo state set.</db:para>
</db:section>
<db:section xml:id="customizing-qradiobutton">
<db:title>Customizing QRadioButton</db:title>
<db:para>The indicator of a QRadioButton can be changed using:</db:para>
<db:programlisting language="cpp">QRadioButton::indicator {
    width: 13px;
    height: 13px;
}

QRadioButton::indicator::unchecked {
    image: url(:/images/radiobutton_unchecked.png);
}

QRadioButton::indicator:unchecked:hover {
    image: url(:/images/radiobutton_unchecked_hover.png);
}

QRadioButton::indicator:unchecked:pressed {
    image: url(:/images/radiobutton_unchecked_pressed.png);
}

QRadioButton::indicator::checked {
    image: url(:/images/radiobutton_checked.png);
}

QRadioButton::indicator:checked:hover {
    image: url(:/images/radiobutton_checked_hover.png);
}

QRadioButton::indicator:checked:pressed {
    image: url(:/images/radiobutton_checked_pressed.png);
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qscrollbar">
<db:title>Customizing QScrollBar</db:title>
<db:para>The QScrollBar can be styled using its subcontrols like <db:link xlink:href="stylesheet-reference.xml#handle-sub">handle</db:link>, <db:link xlink:href="stylesheet-reference.xml#add-line-sub">add-line</db:link>, <db:link xlink:href="stylesheet-reference.xml#sub-line-sub">sub-line</db:link>, and so on. Note that if one property or sub-control is customized, all the other properties or sub-controls must be customized as well.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-scrollbar1.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The scroll bar above has been styled in aquamarine with a solid grey border.</db:para>
<db:programlisting language="cpp">QScrollBar:horizontal {
    border: 2px solid grey;
    background: #32CC99;
    height: 15px;
    margin: 0px 20px 0 20px;
}
QScrollBar::handle:horizontal {
    background: white;
    min-width: 20px;
}
QScrollBar::add-line:horizontal {
    border: 2px solid grey;
    background: #32CC99;
    width: 20px;
    subcontrol-position: right;
    subcontrol-origin: margin;
}

QScrollBar::sub-line:horizontal {
    border: 2px solid grey;
    background: #32CC99;
    width: 20px;
    subcontrol-position: left;
    subcontrol-origin: margin;
}
</db:programlisting>
<db:para>The <db:link xlink:href="stylesheet-reference.xml#left-arrow-sub">left-arrow</db:link> and <db:link xlink:href="stylesheet-reference.xml#right-arrow-sub">right-arrow</db:link> have a solid grey border with a white background. As an alternative, you could also embed the image of an arrow.</db:para>
<db:programlisting language="cpp">QScrollBar:left-arrow:horizontal, QScrollBar::right-arrow:horizontal {
    border: 2px solid grey;
    width: 3px;
    height: 3px;
    background: white;
}

QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal {
    background: none;
}
</db:programlisting>
<db:para>If you want the scroll buttons of the scroll bar to be placed together (instead of the edges) like on macOS, you can use the following stylesheet:</db:para>
<db:programlisting language="cpp">QScrollBar:horizontal {
    border: 2px solid green;
    background: cyan;
    height: 15px;
    margin: 0px 40px 0 0px;
}

QScrollBar::handle:horizontal {
    background: gray;
    min-width: 20px;
}

QScrollBar::add-line:horizontal {
    background: blue;
    width: 16px;
    subcontrol-position: right;
    subcontrol-origin: margin;
    border: 2px solid black;
}

QScrollBar::sub-line:horizontal {
    background: magenta;
    width: 16px;
    subcontrol-position: top right;
    subcontrol-origin: margin;
    border: 2px solid black;
    position: absolute;
    right: 20px;
}

QScrollBar:left-arrow:horizontal, QScrollBar::right-arrow:horizontal {
    width: 3px;
    height: 3px;
    background: pink;
}

QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal {
    background: none;
}
</db:programlisting>
<db:para>The scroll bar using the above stylesheet looks like this:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-scrollbar2.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>To customize a vertical scroll bar use a style sheet similar to the following:</db:para>
<db:programlisting language="cpp"> QScrollBar:vertical {
     border: 2px solid grey;
     background: #32CC99;
     width: 15px;
     margin: 22px 0 22px 0;
 }
 QScrollBar::handle:vertical {
     background: white;
     min-height: 20px;
 }
 QScrollBar::add-line:vertical {
     border: 2px solid grey;
     background: #32CC99;
     height: 20px;
     subcontrol-position: bottom;
     subcontrol-origin: margin;
 }

 QScrollBar::sub-line:vertical {
     border: 2px solid grey;
     background: #32CC99;
     height: 20px;
     subcontrol-position: top;
     subcontrol-origin: margin;
 }
 QScrollBar::up-arrow:vertical, QScrollBar::down-arrow:vertical {
     border: 2px solid grey;
     width: 3px;
     height: 3px;
     background: white;
 }

 QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
     background: none;
 }
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qsizegrip">
<db:title>Customizing QSizeGrip</db:title>
<db:para>QSizeGrip is usually styled by just setting an image.</db:para>
<db:programlisting language="cpp">QSizeGrip {
    image: url(:/images/sizegrip.png);
    width: 16px;
    height: 16px;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qslider">
<db:title>Customizing QSlider</db:title>
<db:para>You can style horizontal slider as below:</db:para>
<db:programlisting language="cpp">QSlider::groove:horizontal {
    border: 1px solid #999999;
    height: 8px; /* the groove expands to the size of the slider by default. by giving it a height, it has a fixed size */
    background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #B1B1B1, stop:1 #c4c4c4);
    margin: 2px 0;
}

QSlider::handle:horizontal {
    background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #b4b4b4, stop:1 #8f8f8f);
    border: 1px solid #5c5c5c;
    width: 18px;
    margin: -2px 0; /* handle is placed by default on the contents rect of the groove. Expand outside the groove */
    border-radius: 3px;
}
</db:programlisting>
<db:para>If you want to change the color of the slider parts before and after the handle, you can use the add-page and sub-page subcontrols. For example, for a vertical slider:</db:para>
<db:programlisting language="cpp">QSlider::groove:vertical {
    background: red;
    position: absolute; /* absolutely position 4px from the left and right of the widget. setting margins on the widget should work too... */
    left: 4px; right: 4px;
}

QSlider::handle:vertical {
    height: 10px;
    background: green;
    margin: 0 -4px; /* expand outside the groove */
}

QSlider::add-page:vertical {
    background: white;
}

QSlider::sub-page:vertical {
    background: pink;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qspinbox">
<db:title>Customizing QSpinBox</db:title>
<db:para>QSpinBox can be completely customized as below (the style sheet has commentary inline):</db:para>
<db:programlisting language="cpp">QSpinBox {
    padding-right: 15px; /* make room for the arrows */
    border-image: url(:/images/frame.png) 4;
    border-width: 3;
}

QSpinBox::up-button {
    subcontrol-origin: border;
    subcontrol-position: top right; /* position at the top right corner */

    width: 16px; /* 16 + 2*1px border-width = 15px padding + 3px parent border */
    border-image: url(:/images/spinup.png) 1;
    border-width: 1px;
}

QSpinBox::up-button:hover {
    border-image: url(:/images/spinup_hover.png) 1;
}

QSpinBox::up-button:pressed {
    border-image: url(:/images/spinup_pressed.png) 1;
}

QSpinBox::up-arrow {
    image: url(:/images/up_arrow.png);
    width: 7px;
    height: 7px;
}

QSpinBox::up-arrow:disabled, QSpinBox::up-arrow:off { /* off state when value is max */
   image: url(:/images/up_arrow_disabled.png);
}

QSpinBox::down-button {
    subcontrol-origin: border;
    subcontrol-position: bottom right; /* position at bottom right corner */

    width: 16px;
    border-image: url(:/images/spindown.png) 1;
    border-width: 1px;
    border-top-width: 0;
}

QSpinBox::down-button:hover {
    border-image: url(:/images/spindown_hover.png) 1;
}

QSpinBox::down-button:pressed {
    border-image: url(:/images/spindown_pressed.png) 1;
}

QSpinBox::down-arrow {
    image: url(:/images/down_arrow.png);
    width: 7px;
    height: 7px;
}

QSpinBox::down-arrow:disabled,
QSpinBox::down-arrow:off { /* off state when value in min */
   image: url(:/images/down_arrow_disabled.png);
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qsplitter">
<db:title>Customizing QSplitter</db:title>
<db:para>A QSplitter derives from a QFrame and hence can be styled like a QFrame. The grip or the handle is customized using the <db:link xlink:href="stylesheet-reference.xml#handle-sub">::handle</db:link> subcontrol.</db:para>
<db:programlisting language="cpp">QSplitter::handle {
    image: url(images/splitter.png);
}

QSplitter::handle:horizontal {
    width: 2px;
}

QSplitter::handle:vertical {
    height: 2px;
}

QSplitter::handle:pressed {
    url(images/splitter_pressed.png);
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qstatusbar">
<db:title>Customizing QStatusBar</db:title>
<db:para>We can provide a background for the status bar and a border for items inside the status bar as follows:</db:para>
<db:programlisting language="cpp">QStatusBar {
    background: brown;
}

QStatusBar::item {
    border: 1px solid red;
    border-radius: 3px;
}
</db:programlisting>
<db:para>Note that widgets that have been added to the QStatusBar can be styled using the descendant declaration (i.e)</db:para>
<db:programlisting language="cpp">QStatusBar QLabel {
    border: 3px solid white;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qtabwidget-and-qtabbar">
<db:title>Customizing QTabWidget and QTabBar</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/tabWidget-stylesheet1.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>For the screenshot above, we need a stylesheet as follows:</db:para>
<db:programlisting language="cpp">QTabWidget::pane { /* The tab widget frame */
    border-top: 2px solid #C2C7CB;
}

QTabWidget::tab-bar {
    left: 5px; /* move to the right by 5px */
}

/* Style the tab using the tab sub-control. Note that
    it reads QTabBar _not_ QTabWidget */
QTabBar::tab {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #E1E1E1, stop: 0.4 #DDDDDD,
                                stop: 0.5 #D8D8D8, stop: 1.0 #D3D3D3);
    border: 2px solid #C4C4C3;
    border-bottom-color: #C2C7CB; /* same as the pane color */
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    min-width: 8ex;
    padding: 2px;
}

QTabBar::tab:selected, QTabBar::tab:hover {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #fafafa, stop: 0.4 #f4f4f4,
                                stop: 0.5 #e7e7e7, stop: 1.0 #fafafa);
}

QTabBar::tab:selected {
    border-color: #9B9B9B;
    border-bottom-color: #C2C7CB; /* same as pane color */
}

QTabBar::tab:!selected {
    margin-top: 2px; /* make non-selected tabs look smaller */
}
</db:programlisting>
<db:para>Often we require the tabs to overlap to look like below:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/tabWidget-stylesheet2.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>For a tab widget that looks like above, we make use of <db:link xlink:href="http://www.communitymx.com/content/article.cfm?cid=B0029">negative margins</db:link>. The resulting stylesheet looks like this:</db:para>
<db:programlisting language="cpp">QTabWidget::pane { /* The tab widget frame */
    border-top: 2px solid #C2C7CB;
}

QTabWidget::tab-bar {
    left: 5px; /* move to the right by 5px */
}

/* Style the tab using the tab sub-control. Note that
    it reads QTabBar _not_ QTabWidget */
QTabBar::tab {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #E1E1E1, stop: 0.4 #DDDDDD,
                                stop: 0.5 #D8D8D8, stop: 1.0 #D3D3D3);
    border: 2px solid #C4C4C3;
    border-bottom-color: #C2C7CB; /* same as the pane color */
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    min-width: 8ex;
    padding: 2px;
}

QTabBar::tab:selected, QTabBar::tab:hover {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #fafafa, stop: 0.4 #f4f4f4,
                                stop: 0.5 #e7e7e7, stop: 1.0 #fafafa);
}

QTabBar::tab:selected {
    border-color: #9B9B9B;
    border-bottom-color: #C2C7CB; /* same as pane color */
}

QTabBar::tab:!selected {
    margin-top: 2px; /* make non-selected tabs look smaller */
}

/* make use of negative margins for overlapping tabs */
QTabBar::tab:selected {
    /* expand/overlap to the left and right by 4px */
    margin-left: -4px;
    margin-right: -4px;
}

QTabBar::tab:first:selected {
    margin-left: 0; /* the first selected tab has nothing to overlap with on the left */
}

QTabBar::tab:last:selected {
    margin-right: 0; /* the last selected tab has nothing to overlap with on the right */
}

QTabBar::tab:only-one {
    margin: 0; /* if there is only one tab, we don't want overlapping margins */
}
</db:programlisting>
<db:para>To move the tab bar to the center (as below), we require the following stylesheet:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/tabWidget-stylesheet3.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">QTabWidget::pane { /* The tab widget frame */
    border-top: 2px solid #C2C7CB;
    position: absolute;
    top: -0.5em;
}

QTabWidget::tab-bar {
    alignment: center;
}

/* Style the tab using the tab sub-control. Note that
    it reads QTabBar _not_ QTabWidget */
QTabBar::tab {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #E1E1E1, stop: 0.4 #DDDDDD,
                                stop: 0.5 #D8D8D8, stop: 1.0 #D3D3D3);
    border: 2px solid #C4C4C3;
    border-bottom-color: #C2C7CB; /* same as the pane color */
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    min-width: 8ex;
    padding: 2px;
}

QTabBar::tab:selected, QTabBar::tab:hover {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #fafafa, stop: 0.4 #f4f4f4,
                                stop: 0.5 #e7e7e7, stop: 1.0 #fafafa);
}

QTabBar::tab:selected {
    border-color: #9B9B9B;
    border-bottom-color: #C2C7CB; /* same as pane color */
}
</db:programlisting>
<db:para>The tear indicator and the scroll buttons can be further customized as follows:</db:para>
<db:programlisting language="cpp">QTabBar::tear {
    image: url(tear_indicator.png);
}

QTabBar::scroller { /* the width of the scroll buttons */
    width: 20px;
}

QTabBar QToolButton { /* the scroll buttons are tool buttons */
    border-image: url(scrollbutton.png) 2;
    border-width: 2px;
}

QTabBar QToolButton::right-arrow { /* the arrow mark in the tool buttons */
    image: url(rightarrow.png);
}

QTabBar QToolButton::left-arrow {
    image: url(leftarrow.png);
}
</db:programlisting>
<db:para>Since Qt 4.6 the close button can be customized as follow:</db:para>
<db:programlisting language="cpp">QTabBar::close-button {
    image: url(close.png)
    subcontrol-position: left;
}
QTabBar::close-button:hover {
    image: url(close-hover.png)
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qtableview">
<db:title>Customizing QTableView</db:title>
<db:para>Suppose we'd like our selected item in QTableView to have bubblegum pink fade to white as its background.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/tableWidget-stylesheet.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>This is possible with the <db:link xlink:href="stylesheet-reference.xml#selection-background-color-prop">selection-background-color</db:link> property and the syntax required is:</db:para>
<db:programlisting language="cpp">QTableView {
    selection-background-color: qlineargradient(x1: 0, y1: 0, x2: 0.5, y2: 0.5,
                                stop: 0 #FF92BB, stop: 1 white);
}
</db:programlisting>
<db:para>The corner widget can be customized using the following style sheet</db:para>
<db:programlisting language="cpp">QTableView QTableCornerButton::section {
    background: red;
    border: 2px outset red;
}
</db:programlisting>
<db:para>The QTableView's checkbox indicator can also be customized. In the following snippet the indicator background-color in unchecked state is customized:</db:para>
<db:programlisting language="cpp">QTableView::indicator:unchecked {
    background-color: #d7d6d5
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qtoolbar">
<db:title>Customizing QToolBar</db:title>
<db:para>The background and the handle of a QToolBar is customized as below:</db:para>
<db:programlisting language="cpp">QToolBar {
    background: red;
    spacing: 3px; /* spacing between items in the tool bar */
}

QToolBar::handle {
    image: url(handle.png);
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qtoolbox">
<db:title>Customizing QToolBox</db:title>
<db:para>The tabs of the QToolBox are customized using the 'tab' subcontrol.</db:para>
<db:programlisting language="cpp">QToolBox::tab {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                stop: 0 #E1E1E1, stop: 0.4 #DDDDDD,
                                stop: 0.5 #D8D8D8, stop: 1.0 #D3D3D3);
    border-radius: 5px;
    color: darkgray;
}

QToolBox::tab:selected { /* italicize selected tabs */
    font: italic;
    color: white;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qtoolbutton">
<db:title>Customizing QToolButton</db:title>
<db:para>There are three types of QToolButtons.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The QToolButton has no menu. In this case, the QToolButton is styled exactly like QPushButton. See <db:link xlink:href="stylesheet-examples.xml#customizing-qpushbutton">Customizing QPushButton</db:link> for an example.</db:para>
</db:listitem>
<db:listitem>
<db:para>The QToolButton has a menu and has the QToolButton::popupMode set to QToolButton::DelayedPopup or QToolButton::InstantPopup. In this case, the QToolButton is styled exactly like a QPushButton with a menu. See <db:link xlink:href="stylesheet-examples.xml#customizing-qpushbutton">Customizing QPushButton</db:link> for an example of the usage of the menu-indicator pseudo state.</db:para>
</db:listitem>
<db:listitem>
<db:para>The QToolButton has its QToolButton::popupMode set to QToolButton::MenuButtonPopup. In this case, we style it as follows:</db:para>
</db:listitem>
</db:itemizedlist>
<db:programlisting language="cpp">QToolButton { /* all types of tool button */
    border: 2px solid #8f8f91;
    border-radius: 6px;
    background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                      stop: 0 #f6f7fa, stop: 1 #dadbde);
}

QToolButton[popupMode=&quot;1&quot;] { /* only for MenuButtonPopup */
    padding-right: 20px; /* make way for the popup button */
}

QToolButton:pressed {
    background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                      stop: 0 #dadbde, stop: 1 #f6f7fa);
}

/* the subcontrols below are used only in the MenuButtonPopup mode */
QToolButton::menu-button {
    border: 2px solid gray;
    border-top-right-radius: 6px;
    border-bottom-right-radius: 6px;
    /* 16px width + 4px for border = 20px allocated above */
    width: 16px;
}

QToolButton::menu-arrow {
    image: url(downarrow.png);
}

QToolButton::menu-arrow:open {
    top: 1px; left: 1px; /* shift it a bit */
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qtooltip">
<db:title>Customizing QToolTip</db:title>
<db:para>QToolTip is customized exactly like a QLabel. In addition, for platforms that support it, the opacity property may be set to adjust the opacity.</db:para>
<db:para>For example,</db:para>
<db:programlisting language="cpp">QToolTip {
    border: 2px solid darkkhaki;
    padding: 5px;
    border-radius: 3px;
    opacity: 200;
}
</db:programlisting>
</db:section>
<db:section xml:id="customizing-qtreeview">
<db:title>Customizing QTreeView</db:title>
<db:para>The background color of alternating rows can be customized using the following style sheet:</db:para>
<db:programlisting language="cpp">QTreeView {
    alternate-background-color: yellow;
}
</db:programlisting>
<db:para>To provide a special background when you hover over items, we can use the <db:link xlink:href="stylesheet-reference.xml#item-sub">::item</db:link> subcontrol. For example,</db:para>
<db:programlisting language="cpp">QTreeView {
    show-decoration-selected: 1;
}

QTreeView::item {
     border: 1px solid #d9d9d9;
    border-top-color: transparent;
    border-bottom-color: transparent;
}

QTreeView::item:hover {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #e7effd, stop: 1 #cbdaf1);
    border: 1px solid #bfcde4;
}

QTreeView::item:selected {
    border: 1px solid #567dbc;
}

QTreeView::item:selected:active{
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #6ea1f1, stop: 1 #567dbc);
}

QTreeView::item:selected:!active {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #6b9be8, stop: 1 #577fbf);
}
</db:programlisting>
<db:para>The branches of a QTreeView are styled using the <db:link xlink:href="stylesheet-reference.xml#branch-sub">::branch</db:link> subcontrol. The following stylesheet color codes the various states when drawing a branch.</db:para>
<db:programlisting language="cpp">QTreeView::branch {
        background: palette(base);
}

QTreeView::branch:has-siblings:!adjoins-item {
        background: cyan;
}

QTreeView::branch:has-siblings:adjoins-item {
        background: red;
}

QTreeView::branch:!has-children:!has-siblings:adjoins-item {
        background: blue;
}

QTreeView::branch:closed:has-children:has-siblings {
        background: pink;
}

QTreeView::branch:has-children:!has-siblings:closed {
        background: gray;
}

QTreeView::branch:open:has-children:has-siblings {
        background: magenta;
}

QTreeView::branch:open:has-children:!has-siblings {
        background: green;
}
</db:programlisting>
<db:para>Colorful, though it is, a more useful example can be made using the following images:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-vline.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-branch-more.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-branch-end.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-branch-closed.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-branch-open.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>vline.png</db:para>
</db:td>
<db:td>
<db:para>branch-more.png</db:para>
</db:td>
<db:td>
<db:para>branch-end.png</db:para>
</db:td>
<db:td>
<db:para>branch-closed.png</db:para>
</db:td>
<db:td>
<db:para>branch-open.png</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:programlisting language="cpp">QTreeView::branch:has-siblings:!adjoins-item {
    border-image: url(vline.png) 0;
}

QTreeView::branch:has-siblings:adjoins-item {
    border-image: url(branch-more.png) 0;
}

QTreeView::branch:!has-children:!has-siblings:adjoins-item {
    border-image: url(branch-end.png) 0;
}

QTreeView::branch:has-children:!has-siblings:closed,
QTreeView::branch:closed:has-children:has-siblings {
        border-image: none;
        image: url(branch-closed.png);
}

QTreeView::branch:open:has-children:!has-siblings,
QTreeView::branch:open:has-children:has-siblings  {
        border-image: none;
        image: url(branch-open.png);
}
</db:programlisting>
<db:para>The resulting tree view looks like this:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-treeview.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
</db:section>
<db:section xml:id="common-mistakes">
<db:title>Common Mistakes</db:title>
<db:para>This section lists some common mistakes when using stylesheets.</db:para>
<db:section xml:id="qpushbutton-and-images">
<db:title>QPushButton and images</db:title>
<db:para>When styling a QPushButton, it is often desirable to use an image as the button graphic. It is common to try the <db:link xlink:href="stylesheet-reference.xml#background-image-prop">background-image</db:link> property, but this has a number of drawbacks: For instance, the background will often appear hidden behind the button decoration, because it is not considered a background. In addition, if the button is resized, the entire background will be stretched or tiled, which does not always look good.</db:para>
<db:para>It is better to use the <db:link xlink:href="stylesheet-reference.xml#border-image-prop">border-image</db:link> property, as it will always display the image, regardless of the background (you can combine it with a background if it has alpha values in it), and it has special settings to deal with button resizing.</db:para>
<db:para>Consider the following snippet:</db:para>
<db:programlisting language="cpp">        QPushButton {
            color: grey;
            border-image: url(/home/kamlie/code/button.png) 3 10 3 10;
            border-top: 3px transparent;
            border-bottom: 3px transparent;
            border-right: 10px transparent;
            border-left: 10px transparent;
        }
</db:programlisting>
<db:para>This will produce a button looking like this:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-border-image-normal.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The numbers after the url gives the top, right, bottom and left number of pixels, respectively. These numbers correspond to the border and should not stretch when the size changes. Whenever you resize the button, the middle part of the image will stretch in both directions, while the pixels specified in the stylesheet will not. This makes the borders of the button look more natural, like this:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-border-image-stretched.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>With borders</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/stylesheet-border-image-wrong.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Without borders</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtwidgets-widgets-stylesheet-example.xml">Style Sheet Example</db:link></db:member>
<db:member><db:link xlink:href="richtext-html-subset.xml">Supported HTML Subset</db:link></db:member>
<db:member>QStyle</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
