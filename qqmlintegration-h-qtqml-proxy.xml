<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>qqmlintegration.h</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Qml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Qml Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QML_ADDED_IN_VERSION">
<db:title>QML_ADDED_IN_VERSION(<db:emphasis>MAJOR</db:emphasis>, <db:emphasis>MINOR</db:emphasis>)</db:title>
<db:para>Declares that the enclosing type or namespace was added in the specified <db:code role="parameter">MAJOR</db:code>.<db:code role="parameter">MINOR</db:code> version. The version is assumed to be in line with any revisions given by <db:link xlink:href="qobject.xml#Q_REVISION">Q_REVISION</db:link>() macros on methods, slots, or signals, and any REVISION() attributes on properties declared with <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>().</db:para>
<db:para><db:link xlink:href="">QML_ADDED_IN_VERSION</db:link>() only takes effect if the type or namespace is available in QML, by having a <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link>, <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link>, or <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_INTERFACE">QML_INTERFACE</db:link> macro.</db:para>
<db:para>If the QML module the type belongs to is imported with a lower version than the one determined this way, the QML type is invisible.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_ANONYMOUS">
<db:title>QML_ANONYMOUS</db:title>
<db:para>Declares the enclosing type to be available, but anonymous in QML. The type cannot be created or used to declare properties in QML, but when passed from C++, it is recognized. In QML, you can use properties of this type if they are declared in C++.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_INTERFACE">QML_INTERFACE</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_ATTACHED">
<db:title>QML_ATTACHED(<db:emphasis>ATTACHED_TYPE</db:emphasis>)</db:title>
<db:para>Declares that the enclosing type attaches <db:code role="parameter">ATTACHED_TYPE</db:code> as an <db:link xlink:href="qtqml-syntax-objectattributes.xml#attached-properties-and-attached-signal-handlers">attached property</db:link> to other types. This takes effect if the type is exposed to QML using a <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() macro.</db:para>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqml-h-qtqml-proxy.xml#qmlAttachedPropertiesObject">qmlAttachedPropertiesObject</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-definetypes.xml#providing-attached-properties">Providing Attached Properties</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_CONSTRUCTIBLE_VALUE">
<db:title>[since 6.5] QML_CONSTRUCTIBLE_VALUE</db:title>
<db:para>Marks the surrounding value type as constructible. That is, any <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> constructors of the type that take exactly one argument can be used when assigning a JavaScript value to a property of this type.</db:para>
<db:para>You can declare a constructible value type as follows:</db:para>
<db:programlisting language="cpp">class MyValueType
{
    Q_GADGET
    QML_VALUE_TYPE(myValueType)
    QML_CONSTRUCTIBLE_VALUE
public:
    Q_INVOKABLE MyValueType(double d);

    // ...
};
</db:programlisting>
<db:para>With the above type, the following QML code will produce a MyValueType value using the given constructor and assign it to the property.</db:para>
<db:programlisting language="qml">QtObject {
    property myValueType v: 5.4
}
</db:programlisting>
<db:para>You can also construct lists of values this way:</db:para>
<db:programlisting language="qml">QtObject {
    property list&lt;myValueType&gt; v: [5.4, 4.5, 3.3]
}
</db:programlisting>
<db:para>If you make value types <db:link xlink:href="qtqml-documents-structure.xml#valuetypebehavior">addressable</db:link>, you can use such a type in a <db:link xlink:href="qtqml-javascript-hostenvironment.xml#type-annotations-and-assertions">type assertion</db:link> to explicitly construct it:</db:para>
<db:programlisting language="qml">pragma ValueTypeBehavior: Addressable

QtObject {
    function process(d: real) {
        let v = d as myValueType;
        // v is a myValueType now, not a number
    }
}
</db:programlisting>
<db:para>This macro was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_VALUE_TYPE">QML_VALUE_TYPE</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_ELEMENT">
<db:title>QML_ELEMENT</db:title>
<db:para>Declares the enclosing type or namespace to be available in QML, using its class or namespace name as the QML element name.</db:para>
<db:para>For example, this makes the C++ class Slider available as a QML type named Slider. All its properties, invokable methods and enums are exposed.</db:para>
<db:programlisting language="cpp">class Slider : public QObject
{
    Q_OBJECT
    QML_ELEMENT
    Q_PROPERTY(int value READ value WRITE setValue NOTIFY valueChanged FINAL)
    // ...
public:
    enum Slippiness {
        Dry, Wet, Icy
    };
    Q_ENUM(Slippiness)

    Q_INVOKABLE void slide(Slippiness slippiness);

    // ...
}
</db:programlisting>
<db:para>You can use the build system to register the type in the type namespace <db:emphasis>com.mycompany.qmlcomponents</db:emphasis> with major version 1. For qmake, specify the following in your project file:</db:para>
<db:programlisting language="cpp" role="bad">CONFIG += qmltypes
QML_IMPORT_NAME = com.mycompany.qmlcomponents
QML_IMPORT_MAJOR_VERSION = 1
</db:programlisting>
<db:para>With CMake, you pass the URI and version to qt_add_qml_module</db:para>
<db:programlisting language="cpp" role="bad">qt6_add_qml_module(myapp
  URI com.mycompany.qmlcomponents
  VERSION 1.0
)
</db:programlisting>
<db:para>Once registered, the type can be used in QML by importing the same type namespace and version number:</db:para>
<db:programlisting language="qml">import com.mycompany.qmlcomponents 1.0

Slider {
    value: 12
    Component.onCompleted: slide(Slider.Icy)

    // ...
}
</db:programlisting>
<db:para>You can also make namespaces tagged with <db:link xlink:href="qobject.xml#Q_NAMESPACE">Q_NAMESPACE</db:link> available this way, in order to expose any enums tagged with <db:link xlink:href="qobject.xml#Q_ENUM_NS">Q_ENUM_NS</db:link> they contain:</db:para>
<db:programlisting language="cpp">namespace MyNamespace {
  Q_NAMESPACE
  QML_ELEMENT

  enum MyEnum {
      Key1,
      Key2,
  };
  Q_ENUM_NS(MyEnum)
}
</db:programlisting>
<db:para>In QML, you can then use the enums:</db:para>
<db:programlisting language="qml">Component.onCompleted: console.log(MyNamespace.Key2)
</db:programlisting>
<db:para><db:emphasis role="bold">NOTE:</db:emphasis> When classes have the same name but are located in different namespaces using <db:link xlink:href="">QML_ELEMENT</db:link> on both of them will cause a conflict. Make sure to use <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() for one of them instead.</db:para>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qobject.xml#Q_REVISION">Q_REVISION</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_EXTENDED">
<db:title>QML_EXTENDED(<db:emphasis>EXTENDED_TYPE</db:emphasis>)</db:title>
<db:para>Declares that the enclosing type uses <db:code role="parameter">EXTENDED_TYPE</db:code> as an extension to provide further properties, methods, and enumerations in QML. This takes effect if the type is exposed to QML using a <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() macro.</db:para>
<db:warning>
<db:para>Members of <db:code role="parameter">EXTENDED_TYPE</db:code> are implicitly treated as FINAL.</db:para>
</db:warning>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_EXTENDED_NAMESPACE">QML_EXTENDED_NAMESPACE</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-extension-objects">Registering Extension Objects</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_EXTENDED_NAMESPACE">
<db:title>QML_EXTENDED_NAMESPACE(<db:emphasis>EXTENSION_NAMESPACE</db:emphasis>)</db:title>
<db:para>Declares that the enclosing <db:emphasis role="bold">type</db:emphasis> uses <db:code role="parameter">EXTENSION_NAMESPACE</db:code> as an extension to provide further enumerations in QML. This takes effect if the type is exposed to QML using a <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() macro. The enumerations need to be exposed to the metaobject system for this to work.</db:para>
<db:para>For example, give the following C++ code</db:para>
<db:programlisting language="cpp">namespace MyNamespace {
    Q_NAMESPACE
    enum MyEnum { MyEnumerator = 10 };
    Q_ENUM_NS(MyEnum)
}

class QmlType : public QObject
{
    Q_OBJECT
    QML_ELEMENT
    QML_EXTENDED_NAMESPACE(MyNamespace)
}
</db:programlisting>
<db:para>we can access the enum in QML:</db:para>
<db:programlisting language="qml">QmlType {
    property int i: QmlType.MyEnumerator // i will be 10
}
</db:programlisting>
<db:note>
<db:para><db:code role="parameter">EXTENSION_NAMESPACE</db:code> can also be a <db:link xlink:href="qobject.xml">QObject</db:link> or QGadget; in that case - and in contrast to <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_EXTENDED">QML_EXTENDED</db:link>, which also exposes methods and properties - only its enumerations are exposed.</db:para>
</db:note>
<db:note>
<db:para><db:code role="parameter">EXTENSION_NAMESPACE</db:code> must have a metaobject; i.e. it must either be a namespace which contains the <db:link xlink:href="qobject.xml#Q_NAMESPACE">Q_NAMESPACE</db:link> macro or a <db:link xlink:href="qobject.xml">QObject</db:link>/QGadget.</db:para>
</db:note>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlengine.xml#QML_NAMESPACE_EXTENDED">QML_NAMESPACE_EXTENDED</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_EXTENDED">QML_EXTENDED</db:link>()</db:member>
<db:member><db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-extension-objects">Registering Extension Objects</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml#Q_ENUM">Q_ENUM</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml#Q_ENUM_NS">Q_ENUM_NS</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_EXTRA_VERSION">
<db:title>QML_EXTRA_VERSION(<db:emphasis>MAJOR</db:emphasis>, <db:emphasis>MINOR</db:emphasis>)</db:title>
<db:para>Declare that the type should also be available in version <db:code role="parameter">MAJOR</db:code>.<db:code role="parameter">MINOR</db:code>. This can be helpful if a type should be available in multiple major versions.</db:para>
<db:para>Types are automatically registered for:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The major version they were introduced in, see <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Any major versions any their members were introduced in.</db:para>
</db:listitem>
<db:listitem>
<db:para>The current major version of their module, unless they were <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_REMOVED_IN_VERSION">QML_REMOVED_IN_VERSION</db:link> before that.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Notably, they are not automatically registered in any <db:link xlink:href="qt-add-qml-module.xml#registering-past-major-versions">PAST_MAJOR_VERSIONS</db:link> between the above. You can use QML_EXTRA_VERSION to manually register your types in further major versions.</db:para>
<db:note>
<db:para>Keeping multiple <db:link xlink:href="qt-add-qml-module.xml#registering-past-major-versions">PAST_MAJOR_VERSIONS</db:link> around is computationally expensive.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_FOREIGN">
<db:title>QML_FOREIGN(<db:emphasis>FOREIGN_TYPE</db:emphasis>)</db:title>
<db:para>Declares that any <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link>, <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link>, <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_INTERFACE">QML_INTERFACE</db:link>, <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_SINGLETON">QML_SINGLETON</db:link>, <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_REMOVED_IN_VERSION">QML_REMOVED_IN_VERSION</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ADDED_IN_MINOR_VERSION" role="deprecated">QML_ADDED_IN_MINOR_VERSION</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_REMOVED_IN_MINOR_VERSION" role="deprecated">QML_REMOVED_IN_MINOR_VERSION</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_EXTENDED">QML_EXTENDED</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_EXTENDED_NAMESPACE">QML_EXTENDED_NAMESPACE</db:link>(), or <db:link xlink:href="qqmlengine.xml#QML_NAMESPACE_EXTENDED">QML_NAMESPACE_EXTENDED</db:link>() macros in the enclosing C++ type do not apply to the enclosing type but instead to <db:code role="parameter">FOREIGN_TYPE</db:code>. The enclosing type still needs to be registered with the <db:link xlink:href="metaobjects.xml">meta object system</db:link> using a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link> or <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:para>This is useful for registering types that cannot be amended to add the macros, for example because they belong to 3rdparty libraries. To register a namespace, see <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_FOREIGN_NAMESPACE">QML_FOREIGN_NAMESPACE</db:link>().</db:para>
<db:note>
<db:para>You may want to use <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() instead of <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link>. With <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link>, the element is named after the struct it is contained in, not the foreign type. The <db:link xlink:href="qtqml-tutorials-extending-qml-advanced-example.xml#foreign-objects-integration">Foreign objects integration</db:link> chapter in <db:link xlink:href="qtqml-tutorials-extending-qml-advanced-example.xml">Writing advanced QML Extensions with C++</db:link> demonstrates this.</db:para>
</db:note>
<db:note>
<db:para><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ATTACHED">QML_ATTACHED</db:link>() can currently not be redirected like this. It has to be specificed in the same type that implements qmlAttachedProperties().</db:para>
</db:note>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_FOREIGN_NAMESPACE">QML_FOREIGN_NAMESPACE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_FOREIGN_NAMESPACE">
<db:title>QML_FOREIGN_NAMESPACE(<db:emphasis>FOREIGN_NAMESPACE</db:emphasis>)</db:title>
<db:para>Declares that any <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link>, <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link>, <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_INTERFACE">QML_INTERFACE</db:link>, <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_SINGLETON">QML_SINGLETON</db:link>, <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_REMOVED_IN_VERSION">QML_REMOVED_IN_VERSION</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ADDED_IN_MINOR_VERSION" role="deprecated">QML_ADDED_IN_MINOR_VERSION</db:link>(), or <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_REMOVED_IN_MINOR_VERSION" role="deprecated">QML_REMOVED_IN_MINOR_VERSION</db:link>() macros in the enclosing C++ namespace do not apply to the enclosing type but instead to <db:code role="parameter">FOREIGN_NAMESPACE</db:code>. The enclosing namespace still needs to be registered with the <db:link xlink:href="metaobjects.xml">meta object system</db:link> using a <db:link xlink:href="qobject.xml#Q_NAMESPACE">Q_NAMESPACE</db:link> macro.</db:para>
<db:para>This is useful for registering namespaces that cannot be amended to add the macros, for example because they belong to 3rdparty libraries.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_FOREIGN">QML_FOREIGN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_IMPLEMENTS_INTERFACES">
<db:title>QML_IMPLEMENTS_INTERFACES(<db:emphasis>interfaces</db:emphasis>)</db:title>
<db:para>This macro tells Qt which QML <db:code role="parameter">interfaces</db:code> the class implements. This macro should only be used for interfacing with classes using <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_INTERFACE">QML_INTERFACE</db:link>, use <db:link xlink:href="qobject.xml#Q_INTERFACES">Q_INTERFACES</db:link> otherwise. It's required in order for declarative registration via <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link> to function properly.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_INTERFACE">QML_INTERFACE</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml#Q_INTERFACES">Q_INTERFACES</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_INTERFACE">
<db:title>QML_INTERFACE</db:title>
<db:para>This macro registers the enclosing C++ type in the QML system as an interface.</db:para>
<db:para>Types registered as an interface in QML should also declare themselves as an interface with the <db:link xlink:href="metaobjects.xml">meta object system</db:link>. For example:</db:para>
<db:programlisting language="cpp">struct FooInterface
{
    QML_INTERFACE
public:
    virtual ~FooInterface();
    virtual void doSomething() = 0;
};

Q_DECLARE_INTERFACE(FooInterface, &quot;org.foo.FooInterface&quot;)
</db:programlisting>
<db:para>When registered with QML in this way, they can be used as property types:</db:para>
<db:para><db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>(FooInterface *foo READ foo WRITE setFoo)</db:para>
<db:para>When you assign a <db:link xlink:href="qobject.xml">QObject</db:link> sub-class to this property, the QML engine does the interface cast to FooInterface* automatically.</db:para>
<db:para>Interface types are implicitly anonymous and uncreatable in QML.</db:para>
<db:para><db:emphasis role="bold">NOTE:</db:emphasis> When inheriting from types using QML_INTERFACE, use <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_IMPLEMENTS_INTERFACES">QML_IMPLEMENTS_INTERFACES</db:link> instead of <db:link xlink:href="qobject.xml#Q_INTERFACES">Q_INTERFACES</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_IMPLEMENTS_INTERFACES">QML_IMPLEMENTS_INTERFACES</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_NAMED_ELEMENT">
<db:title>QML_NAMED_ELEMENT(<db:emphasis>name</db:emphasis>)</db:title>
<db:para>Declares the enclosing type or namespace to be available in QML, using <db:code role="parameter">name</db:code> as the element name. Otherwise behaves the same as <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link>.</db:para>
<db:programlisting language="cpp">class SqlEventDatabase : public QObject
{
    Q_OBJECT
    QML_NAMED_ELEMENT(EventDatabase)

    // ...
};
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_REMOVED_IN_VERSION">
<db:title>QML_REMOVED_IN_VERSION(<db:emphasis>MAJOR</db:emphasis>, <db:emphasis>MINOR</db:emphasis>)</db:title>
<db:para>Declares that the enclosing type or namespace was removed in the specified <db:code role="parameter">MAJOR</db:code>.<db:code role="parameter">MINOR</db:code> version. This is primarily useful when replacing the implementation of a QML type. If a corresponding <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ADDED_IN_VERSION">QML_ADDED_IN_VERSION</db:link>() is present on a different type or namespace of the same QML name, then the removed type is used when importing versions of the module lower than <db:code role="parameter">MAJOR</db:code>.<db:code role="parameter">MINOR</db:code>, and the added type is used when importing versions of the module greater or equal <db:code role="parameter">MAJOR</db:code>.<db:code role="parameter">MINOR</db:code>.</db:para>
<db:para><db:link xlink:href="">QML_REMOVED_IN_VERSION</db:link>() only takes effect if type or namespace is available in QML, by having a <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link>, <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>(), <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link>, or <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_INTERFACE">QML_INTERFACE</db:link> macro.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_SEQUENTIAL_CONTAINER">
<db:title>QML_SEQUENTIAL_CONTAINER(<db:emphasis>VALUE_TYPE</db:emphasis>)</db:title>
<db:para>This macro declares the enclosing or referenced type as a sequential container managing a sequence of <db:code role="parameter">VALUE_TYPE</db:code> elements. <db:code role="parameter">VALUE_TYPE</db:code> can be an actual <db:link xlink:href="qtqml-typesystem-valuetypes.xml">value type</db:link> or a pointer to an <db:link xlink:href="qtqml-typesystem-objecttypes.xml">object type</db:link>. You will rarely be able to add this macro to the actual container declaration since containers are usually templates. You should use <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_FOREIGN">QML_FOREIGN</db:link> to attach the type registration to a template instantiation. Using this technique you can, for example, declare sequential containers like this:</db:para>
<db:programlisting language="cpp">class IntDequeRegistration
{
  Q_GADGET
  QML_FOREIGN(std::deque&lt;int&gt;)
  QML_ANONYMOUS
  QML_SEQUENTIAL_CONTAINER(int)
};
</db:programlisting>
<db:para>After this, you can use the container like a JavaScript array in QML.</db:para>
<db:programlisting language="cpp">class Maze
{
  Q_OBJECT
  Q_ELEMENT
  // 0: North, 1: East, 2: South, 3: West
  Q_PROPERTY(std::deque&lt;int&gt; solution READ solution CONSTANT FINAL)
  [...]
}
</db:programlisting>
<db:programlisting language="cpp">Item {
  Maze {
    id: maze
  }

  function showSolution() {
      maze.solution.forEach([...])
  }
}
</db:programlisting>
<db:note>
<db:para>For <db:link xlink:href="qtqml-typesystem-valuetypes.xml">QML Value Types</db:link> <db:link xlink:href="qlist.xml">QList</db:link> is automatically registered as sequential container. For <db:link xlink:href="qtqml-typesystem-objecttypes.xml">QML Object Types</db:link> <db:link xlink:href="qqmllistproperty.xml">QQmlListProperty</db:link> is. You don't have to add these registrations.</db:para>
</db:note>
<db:note>
<db:para>You cannot currently give the container a custom name. Any argument passed to <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link> is ignored. The automatically registered sequential containers are available under the familiar <db:emphasis>list&lt;...&gt;</db:emphasis> names, for example <db:emphasis>list&lt;<db:link xlink:href="qml-qtqml-qtobject.xml">QtObject</db:link>&gt;</db:emphasis> or <db:emphasis>list&lt;font&gt;</db:emphasis>.</db:para>
</db:note>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_FOREIGN">QML_FOREIGN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_SINGLETON">
<db:title>QML_SINGLETON</db:title>
<db:para>Declares the enclosing type to be a singleton in QML. This only takes effect if the type is a <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> and is available in QML (by having a <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() macro). By default, each <db:link xlink:href="qqmlengine.xml">QQmlEngine</db:link> will try to create a singleton instance using either the type's default constructor or a static factory function of the signature T *create(QQmlEngine *, QJSEngine *) when the type is first accessed. If both do exist and are accessible, the default constructor is preferred. If there is no default constructor and no factory function the singleton is inaccessible. The QML engine generally assumes ownership of the singleton and will delete it when the engine itself is destroyed. You can prevent this by calling <db:link xlink:href="qjsengine.xml#setObjectOwnership">QJSEngine::setObjectOwnership</db:link>() on the singleton.</db:para>
<db:para>In order to declare a default-constructible class as singleton, all you have to do is add <db:link xlink:href="">QML_SINGLETON</db:link>:</db:para>
<db:programlisting language="cpp">class MySingleton : public QObject
{
    Q_OBJECT
    QML_ELEMENT
    QML_SINGLETON
    // Q_PROPERTY( ... )
public:
    // members, Q_INVOKABLE functions, etc.
};
</db:programlisting>
<db:para>If the singleton class is not default-constructible, but you can modify it, you can add a factory function to it, in order to make it accessible:</db:para>
<db:programlisting language="cpp">class MySingleton : public QObject
{
    Q_OBJECT
    QML_ELEMENT
    QML_SINGLETON
    // Q_PROPERTY( ... )

public:
    static MySingleton *create(QQmlEngine *qmlEngine, QJSEngine *jsEngine)
    {
        MySingleton *result = nullptr;
        // Create the object using some custom constructor or factory.
        // The QML engine will assume ownership and delete it, eventually.
        return result;
    }

    // members, Q_INVOKABLE functions, etc
};
</db:programlisting>
<db:para>If you cannot modify the class and it does not have a default constructor or a suitable factory function, you can provide a <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_FOREIGN">QML_FOREIGN</db:link> wrapper to define the factory function:</db:para>
<db:programlisting language="cpp">struct SingletonForeign
{
    Q_GADGET
    QML_FOREIGN(MySingleton)
    QML_SINGLETON
    QML_NAMED_ELEMENT(MySingleton)
public:

    static MySingleton *create(QQmlEngine *, QJSEngine *engine)
    {
        MySingleton *result = nullptr;
        // Create the instance using some custom constructor or factory.
        // The QML engine will assume ownership and delete it, eventually.
        return result;
    }
};
</db:programlisting>
<db:para>Finally, if you want to provide one specific singleton object, the creation of which you cannot control, you can return that from a factory function. This is a replacement for the <db:link xlink:href="qqml-h-qtqml-proxy.xml#qmlRegisterSingletonInstance">qmlRegisterSingletonInstance</db:link> function. If you were calling</db:para>
<db:programlisting language="cpp">qmlRegisterSingletonInstance(&quot;MyModule&quot;, 1, 0, &quot;MySingleton&quot;, myObject);
</db:programlisting>
<db:para>with myObject being of type MySingleton *, you can do the following instead:</db:para>
<db:programlisting language="cpp">struct SingletonForeign
{
    Q_GADGET
    QML_FOREIGN(MySingleton)
    QML_SINGLETON
    QML_NAMED_ELEMENT(MySingleton)
public:

    // Initialize this using myObject where you would previously
    // call qmlRegisterSingletonInstance().
    inline static MySingleton *s_singletonInstance = nullptr;

    static MySingleton *create(QQmlEngine *, QJSEngine *engine)
    {
        // The instance has to exist before it is used. We cannot replace it.
        Q_ASSERT(s_singletonInstance);

        // The engine has to have the same thread affinity as the singleton.
        Q_ASSERT(engine-&gt;thread() == s_singletonInstance-&gt;thread());

        // There can only be one engine accessing the singleton.
        if (s_engine)
            Q_ASSERT(engine == s_engine);
        else
            s_engine = engine;

        // Explicitly specify C++ ownership so that the engine doesn't delete
        // the instance.
        QJSEngine::setObjectOwnership(s_singletonInstance,
                                      QJSEngine::CppOwnership);
        return s_singletonInstance;
    }

private:
    inline static QJSEngine *s_engine = nullptr;
};
</db:programlisting>
<db:para>This way, the pre-existing class MySingleton is declared to be a QML singleton, called MySingleton. You can specify an instance for it any time before it is used by setting the s_singletonInstance member. None of this requires modification of MySingleton itself.</db:para>
<db:note>
<db:para>This pattern doesn't work if either the singleton is accessed by multiple QML engines, or if the QML engine accessing it has a different thread affinity than the singleton object itself. As shown above, you can check the parameters to the create() method for identity and thread affinity of the engine in order to assert on that.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqml-h-qtqml-proxy.xml#qmlRegisterSingletonInstance">qmlRegisterSingletonInstance</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlengine.xml#singletonInstance">QQmlEngine::singletonInstance</db:link>()</db:member>
<db:member><db:link xlink:href="qml-singleton.xml">Singletons in QML</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_STRUCTURED_VALUE">
<db:title>[since 6.5] QML_STRUCTURED_VALUE</db:title>
<db:para>Marks the surrounding value type as structured. Structured value types can and will preferably be constructed property-by-property from a JavaScript object. A structured value type, however is always <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_CONSTRUCTIBLE_VALUE">QML_CONSTRUCTIBLE_VALUE</db:link>, too. This means, you can still provide <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> constructors in order to handle construction from primitive types.</db:para>
<db:para>You can declare a structured value type as follows:</db:para>
<db:programlisting language="cpp">class MyValueType
{
    Q_GADGET
    QML_VALUE_TYPE(myValueType)
    QML_STRUCTURED_VALUE
    Q_PROPERTY(double d READ d WRITE setD)
    Q_PROPERTY(string e READ e WRITE setE)

    // ...
};
</db:programlisting>
<db:para>Then you can populate a property of this type as follows:</db:para>
<db:programlisting language="qml">QtObject {
    property myValueType v: ({d: 4.4, e: &quot;a string&quot;})
}
</db:programlisting>
<db:para>The extra parentheses are necessary to disambiguate the JavaScript object from what might be interpreted as a JavaScript code block.</db:para>
<db:para>You can also construct lists of values this way:</db:para>
<db:programlisting language="qml">QtObject {
    property list&lt;myValueType&gt; v: [
        {d: 4.4, e: &quot;a string&quot;},
        {d: 7.1, e: &quot;another string&quot;}
    ]
}
</db:programlisting>
<db:para>If you make value types <db:link xlink:href="qtqml-documents-structure.xml#valuetypebehavior">addressable</db:link>, you can use such a type in a <db:link xlink:href="qtqml-javascript-hostenvironment.xml#type-annotations-and-assertions">type assertion</db:link> to explicitly construct it:</db:para>
<db:programlisting language="qml">pragma ValueTypeBehavior: Addressable

QtObject {
    function process(d: real) {
        let v = {d: d, e: objectName} as myValueType;
        // v is a myValueType now
    }
}
</db:programlisting>
<db:para>This macro was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_VALUE_TYPE">QML_VALUE_TYPE</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_CONSTRUCTIBLE_VALUE">QML_CONSTRUCTIBLE_VALUE</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_UNAVAILABLE">
<db:title>QML_UNAVAILABLE</db:title>
<db:para>This macro declares the enclosing type to be unavailable in QML. It registers an internal dummy type called QQmlTypeNotAvailable as <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_FOREIGN">QML_FOREIGN</db:link>() type, using any further QML macros you specify.</db:para>
<db:para>Normally, the types exported by a module should be fixed. However, if a C++ type is not available, you should at least &quot;reserve&quot; the QML type name, and give the user of the unavailable type a meaningful error message.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">#ifdef NO_GAMES_ALLOWED
struct MinehuntGame
{
    Q_GADGET
    QML_NAMED_ELEMENT(Game)
    QML_UNAVAILABLE
    QML_UNCREATABLE(&quot;Get back to work, slacker!&quot;);
};
#else
class MinehuntGame : public QObject
{
    Q_OBJECT
    QML_NAMED_ELEMENT(Game)
    // ...
};
#endif
</db:programlisting>
<db:para>This will cause any QML which attempts to use the &quot;Game&quot; type to produce an error message:</db:para>
<db:programlisting language="cpp" role="bad">fun.qml: Get back to work, slacker!
   Game {
   ^
</db:programlisting>
<db:para>Using this technique, you only need a <db:link xlink:href="qobject.xml#Q_GADGET">Q_GADGET</db:link> struct to customize the error message, not a full-blown <db:link xlink:href="qobject.xml">QObject</db:link>. Without <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>(), <db:link xlink:href="">QML_UNAVAILABLE</db:link> still results in a more specific error message than the usual &quot;is not a type&quot; for completely unknown types.</db:para>
<db:note>
<db:para>The class name needs to be fully qualified, even if you're already inside the namespace.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_UNCREATABLE">QML_UNCREATABLE</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_FOREIGN">QML_FOREIGN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_UNCREATABLE">
<db:title>QML_UNCREATABLE(<db:emphasis>reason</db:emphasis>)</db:title>
<db:para>Declares that the enclosing type shall not be creatable from QML. This takes effect if the type is available in QML, by having a <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>() macro. The <db:code role="parameter">reason</db:code> will be emitted as error message if an attempt to create the type from QML is detected.</db:para>
<db:para>Some QML types are implicitly uncreatable, in particular types exposed with <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link> or namespaces exposed with <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link> or <db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>().</db:para>
<db:para>Since Qt 6.0 you can use &quot;&quot; instead of a reason to use a standard message instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ELEMENT">QML_ELEMENT</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link>()</db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_ANONYMOUS">QML_ANONYMOUS</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QML_VALUE_TYPE">
<db:title>QML_VALUE_TYPE(<db:emphasis>name</db:emphasis>)</db:title>
<db:para>Declares the enclosing type or namespace to be available in QML, using <db:code role="parameter">name</db:code> as the name. The type has to be a value type and the name has to be lower case.</db:para>
<db:programlisting language="cpp">class MyValueType
{
    Q_GADGET
    QML_VALUE_TYPE(myValueType)

    // ...
};
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtqml-cppintegration-overview.xml#choosing-the-correct-integration-method-between-c-and-qml">Choosing the Correct Integration Method Between C++ and QML</db:link></db:member>
<db:member><db:link xlink:href="qqmlintegration-h-qtqml-proxy.xml#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
