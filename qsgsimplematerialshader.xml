<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSGSimpleMaterialShader Class</db:title>
<db:subtitle>template &lt;typename State&gt; class QSGSimpleMaterialShader</db:subtitle>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsgsimplematerialshader.xml">QSGSimpleMaterialShader</db:link> class provides a convenient way of building custom OpenGL-based materials for the scene graph.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSGSimpleMaterialShader</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += quick</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qsgmaterialshader.xml" xlink:role="class">QSGMaterialShader</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QSGSimpleMaterialShader is part of <db:simplelist><db:member><db:link xlink:href="qtquick-scenegraph-materials.xml">Qt Quick Scene Graph Material Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:warning>
<db:para>This utility class is only functional when running with the OpenGL backend of the Qt Quick scenegraph.</db:para>
</db:warning>
<db:para>Where the <db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link> and <db:link xlink:href="qsgmaterialshader.xml">QSGMaterialShader</db:link> API requires a bit of boilerplate code to create a functioning material, the <db:link xlink:href="qsgsimplematerialshader.xml">QSGSimpleMaterialShader</db:link> tries to hide some of this through the use of templates.</db:para>
<db:para><db:link xlink:href="qsgmaterialshader.xml#vertexShader">QSGSimpleMaterialShader::vertexShader</db:link>() and <db:link xlink:href="qsgmaterialshader.xml#fragmentShader">QSGSimpleMaterialShader::fragmentShader</db:link>() are used to specify the actual shader source code. The names of the vertex attributes should be listed in the <db:link xlink:href="qsgsimplematerialshader.xml#attributes">QSGSimpleMaterialShader::attributes</db:link>()</db:para>
<db:para><db:link xlink:href="qsgsimplematerialshader.xml#updateState-1">QSGSimpleMaterialShader::updateState</db:link>() is used to push the material state to the OpenGL shader program.</db:para>
<db:para>The actual OpenGL shader program is accessible through the <db:link xlink:href="qsgmaterialshader.xml#program">QSGSimpleMaterialShader::program</db:link>() function.</db:para>
<db:para>Each <db:link xlink:href="qsgsimplematerialshader.xml">QSGSimpleMaterialShader</db:link> implementation operates on a unique state struct. The state struct must be declared using the <db:code>QSG_DECLARE_SIMPLE_SHADER</db:code> macro.</db:para>
<db:para>Here is a simple example of a custom solid-color:</db:para>
<db:programlisting language="cpp">struct Color
{
    float r, g, b, a;
};

class MinimalShader : public QSGSimpleMaterialShader&amp;lt;Color&amp;gt;
{
    QSG_DECLARE_SIMPLE_SHADER(MinimalShader, Color)
public:

    const char *vertexShader() const {
        return
        &quot;attribute highp vec4 vertex;               \n&quot;
        &quot;uniform highp mat4 qt_Matrix;              \n&quot;
        &quot;void main() {                              \n&quot;
        &quot;    gl_Position = qt_Matrix * vertex;      \n&quot;
        &quot;}&quot;;
    }

    const char *fragmentShader() const {
        return
        &quot;uniform lowp float qt_Opacity;             \n&quot;
        &quot;uniform lowp vec4 color;                   \n&quot;
        &quot;void main() {                              \n&quot;
        &quot;    gl_FragColor = color * qt_Opacity;     \n&quot;
        &quot;}&quot;;
    }

    QList&amp;lt;QByteArray&amp;gt; attributes() const {
        return QList&amp;lt;QByteArray&amp;gt;() &amp;lt;&amp;lt; &quot;vertex&quot;;
    }

    void updateState(const Color *color, const Color *) {
        program()-&amp;gt;setUniformValue(&quot;color&quot;, color-&amp;gt;r, color-&amp;gt;g, color-&amp;gt;b, color-&amp;gt;a);
    }

};
</db:programlisting>
<db:para>Instances of materials using this shader can be created using the createMaterial() function which will be defined by the <db:link xlink:href="qsgsimplematerialshader.xml#QSG_DECLARE_SIMPLE_SHADER">QSG_DECLARE_SIMPLE_SHADER</db:link> macro.</db:para>
<db:programlisting language="cpp">QSGSimpleMaterial&amp;lt;Color&amp;gt; *material = MinimalShader::createMaterial();
material-&amp;gt;state()-&amp;gt;r = 1;
material-&amp;gt;state()-&amp;gt;g = 0;
material-&amp;gt;state()-&amp;gt;b = 0;
material-&amp;gt;state()-&amp;gt;a = 1;

node-&amp;gt;setMaterial(material);
</db:programlisting>
<db:para>The scene graph will often try to find materials that have the same or at least similar state so that these can be batched together inside the renderer, which gives better performance. To specify sortable material states, use <db:link xlink:href="qsgsimplematerialshader.xml#QSG_DECLARE_SIMPLE_COMPARABLE_SHADER">QSG_DECLARE_SIMPLE_COMPARABLE_SHADER</db:link> instead of <db:link xlink:href="qsgsimplematerialshader.xml#QSG_DECLARE_SIMPLE_SHADER">QSG_DECLARE_SIMPLE_SHADER</db:link>. The state struct must then also define the function:</db:para>
<db:programlisting language="cpp">int compare(const Type *other) const;
</db:programlisting>
<db:warning>
<db:para>The <db:link xlink:href="qsgsimplematerialshader.xml">QSGSimpleMaterialShader</db:link> relies on template instantiation to create a <db:link xlink:href="qsgmaterialtype.xml">QSGMaterialType</db:link> which the scene graph renderer internally uses to identify this shader. For this reason, the unique <db:link xlink:href="qsgsimplematerialshader.xml">QSGSimpleMaterialShader</db:link> implementation must be instantiated with a unique C++ type.</db:para>
</db:warning>
<db:note>
<db:para>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <db:link xlink:href="qtquick-visualcanvas-scenegraph.xml#scene-graph-and-rendering">Scene Graph and Rendering</db:link> for more information.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtquick-scenegraph-simplematerial-example.xml">Scene Graph - Simple Material</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="attributes">
<db:title>[pure virtual] QList&lt;QByteArray&gt; QSGSimpleMaterialShader::attributes() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QByteArray&gt;</db:type>
<db:methodname>attributes</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QByteArray&gt; attributes() const = 0</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list of names, declaring the vertex attributes in the vertex shader.</db:para>
</db:section>
<db:section xml:id="resolveUniforms">
<db:title>[virtual] void QSGSimpleMaterialShader::resolveUniforms()</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>resolveUniforms</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resolveUniforms()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to resolve the location of named uniforms in the shader program.</db:para>
<db:para>This function is called when the material shader is initialized.</db:para>
</db:section>
<db:section xml:id="uniformMatrixName">
<db:title>const char *QSGSimpleMaterialShader::uniformMatrixName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const char *</db:type>
<db:methodname>uniformMatrixName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * uniformMatrixName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name for the transform matrix uniform of this item. The default value is <db:code>qt_Matrix</db:code>.</db:para>
</db:section>
<db:section xml:id="uniformOpacityName">
<db:title>const char *QSGSimpleMaterialShader::uniformOpacityName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const char *</db:type>
<db:methodname>uniformOpacityName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * uniformOpacityName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name for the opacity uniform of this item. The default value is <db:code>qt_Opacity</db:code>.</db:para>
</db:section>
<db:section xml:id="updateState-1">
<db:title>[pure virtual] void QSGSimpleMaterialShader::updateState(const State *<db:emphasis>newState</db:emphasis>, const State *<db:emphasis>oldState</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>updateState</db:methodname>
<db:methodparam>
<db:type>const State *</db:type>
<db:parameter>newState</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const State *</db:type>
<db:parameter>oldState</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void updateState(const State *newState, const State *oldState) = 0</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Called whenever the state of this shader should be updated from <db:code role="parameter">oldState</db:code> to <db:code role="parameter">newState</db:code>, typical for each new set of geometries being drawn.</db:para>
<db:para>Both the old and the new state are passed in so that the implementation can compare and minimize the state changes when applicable.</db:para>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QSG_DECLARE_SIMPLE_COMPARABLE_SHADER">
<db:title>QSG_DECLARE_SIMPLE_COMPARABLE_SHADER(<db:emphasis>Shader</db:emphasis>, <db:emphasis>State</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QSG_DECLARE_SIMPLE_COMPARABLE_SHADER</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Shader</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>State</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QSG_DECLARE_SIMPLE_COMPARABLE_SHADER(Shader, State)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is used to declare a <db:link xlink:href="qsgmaterialtype.xml">QSGMaterialType</db:link> and a <db:code>createMaterial()</db:code> function for <db:code role="parameter">Shader</db:code> with the given <db:code role="parameter">State</db:code>, where the <db:code role="parameter">State</db:code> class must define a compare function on the form:</db:para>
<db:programlisting language="cpp">int compare(const State *other) const;
</db:programlisting>
</db:section>
<db:section xml:id="QSG_DECLARE_SIMPLE_SHADER">
<db:title>QSG_DECLARE_SIMPLE_SHADER(<db:emphasis>Shader</db:emphasis>, <db:emphasis>State</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QSG_DECLARE_SIMPLE_SHADER</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Shader</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>State</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QSG_DECLARE_SIMPLE_SHADER(Shader, State)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is used to declare a <db:link xlink:href="qsgmaterialtype.xml">QSGMaterialType</db:link> and a <db:code>createMaterial()</db:code> function for <db:code role="parameter">Shader</db:code> with the given <db:code role="parameter">State</db:code>.</db:para>
</db:section>
</db:section>
</db:article>
