<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QVulkanInstance Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.0.4 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> class represents a native Vulkan instance, enabling Vulkan rendering onto a <db:link xlink:href="qsurface.xml">QSurface</db:link>.</db:para>
<db:para>This class was introduced in Qt 5.10.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QVulkanInstance</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.10</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Gui)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="https://www.khronos.org/vulkan/">Vulkan</db:link> is a cross-platform, explicit graphics and compute API. This class provides support for loading a Vulkan library and creating an <db:code>instance</db:code> in a cross-platform manner. For an introduction on Vulkan instances, refer <db:link xlink:href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#initialization-instances">to section 3.2 of the specification</db:link>.</db:para>
<db:note>
<db:para>Platform-specific support for Vulkan instances and windows with Vulkan-capable surfaces is provided by the various platform plugins. Not all of them will support Vulkan, however. When running on such a platform, <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() will fail and always return <db:code>false</db:code>.</db:para>
</db:note>
<db:note>
<db:para>Vulkan support may get automatically disabled for a given Qt build due to not having the necessary Vulkan headers available at build time. When this is the case, and the output of <db:code>configure</db:code> indicates Vulkan support is disabled, the QVulkan* classes will be unavailable.</db:para>
</db:note>
<db:note>
<db:para>Some functions changed their signature between the various Vulkan header revisions. When building Qt and only headers with the old, conflicting signatures are present in a system, Vulkan support will get disabled. It is recommended to use headers from Vulkan 1.0.39 or newer.</db:para>
</db:note>
<db:section xml:id="initialization">
<db:title>Initialization</db:title>
<db:para>Similarly to <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link>, any actual Vulkan instance creation happens only when calling <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>(). This allows using <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> as a plain member variable while retaining control over when to perform initialization.</db:para>
<db:para>Querying the supported instance-level layers and extensions is possible by calling <db:link xlink:href="qvulkaninstance.xml#supportedLayers">supportedLayers</db:link>() and <db:link xlink:href="qvulkaninstance.xml#supportedExtensions">supportedExtensions</db:link>(). These ensure the Vulkan library is loaded, and can therefore be called safely before <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() as well.</db:para>
<db:para>Instances store per-application Vulkan state and creating a <db:code>VkInstance</db:code> object initializes the Vulkan library. In practice there will typically be a single instance constructed early on in main(). The object then stays alive until exiting the application.</db:para>
<db:para>Every Vulkan-based <db:link xlink:href="qwindow.xml">QWindow</db:link> must be associated with a <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> by calling <db:link xlink:href="qwindow.xml#setVulkanInstance">QWindow::setVulkanInstance</db:link>(). Thus a typical application pattern is the following:</db:para>
<db:programlisting language="cpp">    int main(int argc, char **argv)
    {
        QGuiApplication app(argc, argv);

        QVulkanInstance inst;
        if (!inst.create())
            return 1;

        // ...
        window-&amp;gt;setVulkanInstance(&amp;amp;inst);
        window-&amp;gt;show();

        return app.exec();
    }
</db:programlisting>
</db:section>
<db:section xml:id="configuration">
<db:title>Configuration</db:title>
<db:para><db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> automatically enables the minimum set of extensions it needs on the newly created instance. In practice this means the <db:code>VK_KHR_*_surface</db:code> family of extensions.</db:para>
<db:para>By default Vulkan debug output, for example messages from the validation layers, is routed to <db:link xlink:href="qtglobal.xml#qDebug">qDebug</db:link>(). This can be disabled by passing the flag <db:code>NoDebugOutputRedirect</db:code> to <db:link xlink:href="qvulkaninstance.xml#setFlags">setFlags</db:link>() <db:emphasis>before</db:emphasis> invoking <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>().</db:para>
<db:para>To enable additional layers and extensions, provide the list via <db:link xlink:href="qvulkaninstance.xml#setLayers">setLayers</db:link>() and <db:link xlink:href="qvulkaninstance.xml#setExtensions">setExtensions</db:link>() <db:emphasis>before</db:emphasis> invoking <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>(). When a given layer or extension is not reported as available from the instance, the request is ignored. After a successful call to <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>(), the values returned from functions like <db:link xlink:href="qvulkaninstance.xml#layers">layers</db:link>() and <db:link xlink:href="qvulkaninstance.xml#extensions">extensions</db:link>() reflect the actual enabled layers and extensions. When necessary, for example to avoid requesting extensions that conflict and thus would fail the Vulkan instance creation, the list of actually supported layers and extensions can be examined via <db:link xlink:href="qvulkaninstance.xml#supportedLayers">supportedLayers</db:link>() and <db:link xlink:href="qvulkaninstance.xml#supportedExtensions">supportedExtensions</db:link>() before calling <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>().</db:para>
<db:para>For example, to enable the standard validation layers, one could do the following:</db:para>
<db:programlisting language="cpp">    QVulkanInstance inst;

    // Enable validation layer, if supported. Messages go to qDebug by default.
    inst.setLayers(QByteArrayList() &amp;lt;&amp;lt; &quot;VK_LAYER_LUNARG_standard_validation&quot;);

    bool ok = inst.create();
    if (!ok) {
        // ... Vulkan not available
    }

    if (!inst.layers().contains(&quot;VK_LAYER_LUNARG_standard_validation&quot;)) {
        // ... validation layer not available
    }
</db:programlisting>
<db:para>Or, alternatively, to make decisions before attempting to create a Vulkan instance:</db:para>
<db:programlisting language="cpp">    QVulkanInstance inst;

    if (inst.supportedLayers().contains(&quot;VK_LAYER_LUNARG_standard_validation&quot;)) {
        // ...
    }
    bool ok = inst.create();
    // ...
</db:programlisting>
</db:section>
<db:section xml:id="adopting-an-existing-instance">
<db:title>Adopting an Existing Instance</db:title>
<db:para>By default <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> creates a new Vulkan instance. When working with external engines and renderers, this may sometimes not be desirable. When there is a <db:code>VkInstance</db:code> handle already available, call <db:link xlink:href="qvulkaninstance.xml#setVkInstance">setVkInstance</db:link>() before invoking <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>(). This way no additional instances will get created, and <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> will not own the handle.</db:para>
<db:note>
<db:para>It is up to the component creating the external instance to ensure the necessary extensions are enabled on it. These are: <db:code>VK_KHR_surface</db:code>, the WSI-specific <db:code>VK_KHR_*_surface</db:code> that is appropriate for the platform in question, and <db:code>VK_EXT_debug_report</db:code> in case <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link>'s debug output redirection is desired.</db:para>
</db:note>
</db:section>
<db:section xml:id="accessing-core-vulkan-commands">
<db:title>Accessing Core Vulkan Commands</db:title>
<db:para>To access the <db:code>VkInstance</db:code> handle the <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> wraps, call <db:link xlink:href="qvulkaninstance.xml#vkInstance">vkInstance</db:link>(). To resolve Vulkan functions, call <db:link xlink:href="qvulkaninstance.xml#getInstanceProcAddr">getInstanceProcAddr</db:link>(). For core Vulkan commands manual resolving is not necessary as they are provided via the QVulkanFunctions and QVulkanDeviceFunctions objects accessible via <db:link xlink:href="qvulkaninstance.xml#functions">functions</db:link>() and <db:link xlink:href="qvulkaninstance.xml#deviceFunctions">deviceFunctions</db:link>().</db:para>
<db:note>
<db:para>QVulkanFunctions and QVulkanDeviceFunctions are generated from the Vulkan API XML specifications when building the Qt libraries. Therefore no documentation is provided for them. They contain the Vulkan 1.0 functions with the same signatures as described in the <db:link xlink:href="https://www.khronos.org/registry/vulkan/specs/1.0/html/">Vulkan API documentation</db:link>.</db:para>
</db:note>
</db:section>
<db:section xml:id="getting-a-native-vulkan-surface-for-a-window">
<db:title>Getting a Native Vulkan Surface for a Window</db:title>
<db:para>The two common windowing system specific operations are getting a surface (a <db:code>VkSurfaceKHR</db:code> handle) for a window, and querying if a given queue family supports presenting to a given surface. To avoid WSI-specific bits in the applications, these are abstracted by <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> and the underlying QPA layers.</db:para>
<db:para>To create a Vulkan surface for a window, or retrieve an existing one, call <db:link xlink:href="qvulkaninstance.xml#surfaceForWindow">surfaceForWindow</db:link>(). Most platforms will only create the surface via <db:code>VK_KHR_*_surface</db:code> when first calling <db:link xlink:href="qvulkaninstance.xml#surfaceForWindow">surfaceForWindow</db:link>(), but there may be platform-specific variations in the internal behavior. Once created, subsequent calls to <db:link xlink:href="qvulkaninstance.xml#surfaceForWindow">surfaceForWindow</db:link>() just return the same handle. This fits the structure of typical Vulkan-enabled <db:link xlink:href="qwindow.xml">QWindow</db:link> subclasses well.</db:para>
<db:para>To query if a given queue family within a physical device can be used to perform presentation to a given surface, call <db:link xlink:href="qvulkaninstance.xml#supportsPresent">supportsPresent</db:link>(). This encapsulates both the generic <db:code>vkGetPhysicalDeviceSurfaceSupportKHR</db:code> and the WSI-specific <db:code>vkGetPhysicalDevice*PresentationSupportKHR</db:code> checks.</db:para>
</db:section>
<db:section xml:id="troubleshooting">
<db:title>Troubleshooting</db:title>
<db:para>Besides returning <db:code>false</db:code> from <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() or <db:code>0</db:code> from <db:link xlink:href="qvulkaninstance.xml#surfaceForWindow">surfaceForWindow</db:link>(), critical errors will also get printed to the debug output via <db:link xlink:href="qtglobal.xml#qWarning">qWarning</db:link>(). Additional logging can be requested by enabling debug output for the logging category <db:code>qt.vulkan</db:code>. The actual Vulkan error code from instance creation can be retrieved by calling <db:link xlink:href="qvulkaninstance.xml#errorCode">errorCode</db:link>() after a failing <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>().</db:para>
<db:para>In some special cases it may be necessary to override the Vulkan library name. This can be achieved by setting the <db:code>QT_VULKAN_LIB</db:code> environment variable.</db:para>
</db:section>
<db:section xml:id="example">
<db:title>Example</db:title>
<db:para>The following is the basic outline of creating a Vulkan-capable <db:link xlink:href="qwindow.xml">QWindow</db:link>:</db:para>
<db:programlisting language="cpp">class VulkanWindow : public QWindow
{
public:
    VulkanWindow() {
        setSurfaceType(VulkanSurface);
    }

    void exposeEvent(QExposeEvent *) {
        if (isExposed()) {
            if (!m_initialized) {
                m_initialized = true;
                // initialize device, swapchain, etc.
                QVulkanInstance *inst = vulkanInstance();
                QVulkanFunctions *f = inst-&amp;gt;functions();
                uint32_t devCount = 0;
                f-&amp;gt;vkEnumeratePhysicalDevices(inst-&amp;gt;vkInstance(), &amp;amp;devCount, nullptr);
                // ...
                // build the first frame
                render();
            }
        }
    }

    bool event(QEvent *e) {
        if (e-&amp;gt;type() == QEvent::UpdateRequest)
            render();
        return QWindow::event(e);
    }

    void render() {
       // ...
       requestUpdate(); // render continuously
    }

private:
    bool m_initialized = false;
};

int main(int argc, char **argv)
{
    QGuiApplication app(argc, argv);

    QVulkanInstance inst;
    if (!inst.create()) {
        qWarning(&quot;Vulkan not available&quot;);
        return 1;
    }

    VulkanWindow window;
    window.showMaximized();

    return app.exec();

}
</db:programlisting>
<db:note>
<db:para>In addition to expose, a well-behaving window implementation will also have to take care of additional events like resize and <db:link xlink:href="qplatformsurfaceevent.xml">QPlatformSurfaceEvent</db:link> in order to ensure proper management of the swap chain. Additionally, some platforms may require releasing resources when not being exposed anymore.</db:para>
</db:note>
</db:section>
<db:section xml:id="using-c-bindings-for-vulkan">
<db:title>Using C++ Bindings for Vulkan</db:title>
<db:para>Combining Qt's Vulkan enablers with a C++ Vulkan wrapper, for example <db:link xlink:href="https://github.com/KhronosGroup/Vulkan-Hpp">Vulkan-Hpp</db:link>, is possible as well. The pre-requisite here is that the C++ layer must be able to adopt native handles (VkInstance, VkSurfaceKHR) in its classes without taking ownership (since the ownership stays with <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> and <db:link xlink:href="qwindow.xml">QWindow</db:link>). Consider also the following:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Some wrappers require exception support to be enabled. Qt does not use exceptions. To enable exceptions for the application, add <db:code>CONFIG += exceptions</db:code> to the <db:code>.pro</db:code> file.</db:para>
</db:listitem>
<db:listitem>
<db:para>Some wrappers call Vulkan functions directly, assuming <db:code>vulkan.h</db:code> provides prototypes and the application links to a Vulkan library exporting all necessary symbols. Qt may not directly link to a Vulkan library. Therefore, on some platforms it may be necessary to add <db:code>LIBS += -lvulkan</db:code> or similar in the application's <db:code>.pro</db:code> file.</db:para>
</db:listitem>
<db:listitem>
<db:para>The headers for the QVulkan classes may include <db:code>vulkan.h</db:code> with <db:code>VK_NO_PROTOTYPES</db:code> enabled. This can cause issues in C++ wrapper headers that rely on the prototypes. Hence in application code it may be necessary to include <db:code>vulkan.hpp</db:code> or similar before any of the QVulkan headers.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>QVulkanFunctions</db:member>
<db:member><db:link xlink:href="qsurface.xml#SurfaceType-enum">QSurface::SurfaceType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="DebugFilter-typedef">
<db:title>QVulkanInstance::DebugFilter</db:title>
<db:typedefsynopsis>
<db:typedefname>DebugFilter</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for debug filtering callback functions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#installDebugOutputFilter">installDebugOutputFilter</db:link>()</db:member>
<db:member><db:link xlink:href="qvulkaninstance.xml#removeDebugOutputFilter">removeDebugOutputFilter</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Flag-enum">
<db:title>[since 5.10] enum QVulkanInstance::Flag</db:title>
<db:bridgehead renderas="sect2">flags QVulkanInstance::Flags</db:bridgehead>
<db:enumsynopsis>
<db:enumname>Flag</db:enumname>
<db:enumitem>
<db:enumidentifier>NoDebugOutputRedirect</db:enumidentifier>
<db:enumvalue>0x01</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QVulkanInstance::Flags</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum describes the flags that can be passed to <db:link xlink:href="qvulkaninstance.xml#setFlags">setFlags</db:link>(). These control the behavior of <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link></db:emphasis>::NoDebugOutputRedirect</db:code></db:para>
</db:td>
<db:td><db:code>0x01</db:code></db:td>
<db:td>
<db:para>Disables Vulkan debug output (<db:code>VK_EXT_debug_report</db:code>) redirection to <db:link xlink:href="qtglobal.xml#qDebug">qDebug</db:link>.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 5.10.</db:para>
<db:para>The <db:code>Flags</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Flag&gt;. </db:code>It stores an OR combination of <db:code>Flag</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QVulkanInstance">
<db:title>QVulkanInstance::QVulkanInstance()</db:title>
<db:constructorsynopsis>
<db:methodname>QVulkanInstance</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QVulkanInstance()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new instance.</db:para>
<db:note>
<db:para>No Vulkan initialization is performed in the constructor.</db:para>
</db:note>
</db:section>
<db:section xml:id="dtor.QVulkanInstance">
<db:title>QVulkanInstance::~QVulkanInstance()</db:title>
<db:destructorsynopsis>
<db:methodname>~QVulkanInstance</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QVulkanInstance()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destructor.</db:para>
<db:note>
<db:para>current() will return <db:code>nullptr</db:code> once the instance is destroyed.</db:para>
</db:note>
</db:section>
<db:section xml:id="apiVersion">
<db:title>QVersionNumber QVulkanInstance::apiVersion() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVersionNumber</db:type>
<db:methodname>apiVersion</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVersionNumber apiVersion() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the requested Vulkan API version against which the application expects to run, or a null version number if <db:link xlink:href="qvulkaninstance.xml#setApiVersion">setApiVersion</db:link>() was not called before <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#setApiVersion">setApiVersion</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="create">
<db:title>bool QVulkanInstance::create()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>create</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool create()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Initializes the Vulkan library and creates a new or adopts and existing Vulkan instance.</db:para>
<db:para>Returns true if successful, false on error or when Vulkan is not supported.</db:para>
<db:para>When successful, the pointer to this <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> is retrievable via the static function current().</db:para>
<db:para>The Vulkan instance and library is available as long as this <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> exists, or until <db:link xlink:href="qvulkaninstance.xml#destroy">destroy</db:link>() is called.</db:para>
</db:section>
<db:section xml:id="destroy">
<db:title>void QVulkanInstance::destroy()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>destroy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void destroy()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Destroys the underlying platform instance, thus destroying the VkInstance (when owned). The <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> object is still reusable by calling <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() again.</db:para>
</db:section>
<db:section xml:id="deviceFunctions">
<db:title>QVulkanDeviceFunctions *QVulkanInstance::deviceFunctions(VkDevice <db:emphasis>device</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QVulkanDeviceFunctions *</db:type>
<db:methodname>deviceFunctions</db:methodname>
<db:methodparam>
<db:type>VkDevice</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVulkanDeviceFunctions * deviceFunctions(VkDevice device)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the QVulkanDeviceFunctions object that exposes the device level core Vulkan command set and is guaranteed to be functional cross-platform.</db:para>
<db:note>
<db:para>The Vulkan functions in the returned object must only be called with <db:code role="parameter">device</db:code> or a child object (VkQueue, VkCommandBuffer) of <db:code role="parameter">device</db:code> as their first parameter. This is because these functions are resolved via <db:link xlink:href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetDeviceProcAddr.html">vkGetDeviceProcAddr</db:link> in order to avoid the potential overhead of internal dispatching.</db:para>
</db:note>
<db:note>
<db:para>The returned object is owned and managed by the <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link>. Do not destroy or alter it.</db:para>
</db:note>
<db:note>
<db:para>The object is cached so calling this function with the same <db:code role="parameter">device</db:code> again is a cheap operation. However, when the device gets destroyed, it is up to the application to notify the <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> by calling <db:link xlink:href="qvulkaninstance.xml#resetDeviceFunctions">resetDeviceFunctions</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#functions">functions</db:link>()</db:member>
<db:member><db:link xlink:href="qvulkaninstance.xml#resetDeviceFunctions">resetDeviceFunctions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorCode">
<db:title>VkResult QVulkanInstance::errorCode() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>VkResult</db:type>
<db:methodname>errorCode</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">VkResult errorCode() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the Vulkan error code after an unsuccessful <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>(), <db:code>VK_SUCCESS</db:code> otherwise.</db:para>
<db:para>The value is typically the return value from vkCreateInstance() (when creating a new Vulkan instance instead of adopting an existing one), but may also be <db:code>VK_NOT_READY</db:code> if the platform plugin does not support Vulkan.</db:para>
</db:section>
<db:section xml:id="extensions">
<db:title>QByteArrayList QVulkanInstance::extensions() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArrayList</db:type>
<db:methodname>extensions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArrayList extensions() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the enabled instance extensions, if <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() was called and was successful. The requested extensions otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#setExtensions">setExtensions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="flags">
<db:title>QVulkanInstance::Flags QVulkanInstance::flags() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVulkanInstance::Flags</db:type>
<db:methodname>flags</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVulkanInstance::Flags flags() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the requested flags.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#setFlags">setFlags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="functions">
<db:title>QVulkanFunctions *QVulkanInstance::functions() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVulkanFunctions *</db:type>
<db:methodname>functions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVulkanFunctions * functions() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the corresponding QVulkanFunctions object that exposes the core Vulkan command set, excluding device level functions, and is guaranteed to be functional cross-platform.</db:para>
<db:note>
<db:para>The returned object is owned and managed by the <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link>. Do not destroy or alter it.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#deviceFunctions">deviceFunctions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="getInstanceProcAddr">
<db:title>PFN_vkVoidFunction QVulkanInstance::getInstanceProcAddr(const char *<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>PFN_vkVoidFunction</db:type>
<db:methodname>getInstanceProcAddr</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">PFN_vkVoidFunction getInstanceProcAddr(const char *name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Resolves the Vulkan function with the given <db:code role="parameter">name</db:code>.</db:para>
<db:para>For core Vulkan commands prefer using the function wrappers retrievable from <db:link xlink:href="qvulkaninstance.xml#functions">functions</db:link>() and <db:link xlink:href="qvulkaninstance.xml#deviceFunctions">deviceFunctions</db:link>() instead.</db:para>
</db:section>
<db:section xml:id="installDebugOutputFilter">
<db:title>void QVulkanInstance::installDebugOutputFilter(QVulkanInstance::DebugFilter <db:emphasis>filter</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>installDebugOutputFilter</db:methodname>
<db:methodparam>
<db:type>QVulkanInstance::DebugFilter</db:type>
<db:parameter>filter</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void installDebugOutputFilter(QVulkanInstance::DebugFilter filter)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Installs a <db:code role="parameter">filter</db:code> function that is called for every Vulkan debug message. When the callback returns <db:code>true</db:code>, the message is stopped (filtered out) and will not appear on the debug output.</db:para>
<db:note>
<db:para>Filtering is only effective when <db:link xlink:href="qvulkaninstance.xml#Flag-enum">NoDebugOutputRedirect</db:link> is not <db:link xlink:href="qvulkaninstance.xml#setFlags">set</db:link>. Installing filters has no effect otherwise.</db:para>
</db:note>
<db:note>
<db:para>This function can be called before <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#removeDebugOutputFilter">removeDebugOutputFilter</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QVulkanInstance::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() was successful and the instance is valid.</db:para>
</db:section>
<db:section xml:id="layers">
<db:title>QByteArrayList QVulkanInstance::layers() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArrayList</db:type>
<db:methodname>layers</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArrayList layers() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the enabled instance layers, if <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() was called and was successful. The requested layers otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#setLayers">setLayers</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="presentAboutToBeQueued">
<db:title>[since 5.15] void QVulkanInstance::presentAboutToBeQueued(QWindow *<db:emphasis>window</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>presentAboutToBeQueued</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void presentAboutToBeQueued(QWindow *window)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function should be called by the application's renderer before queuing a present operation for <db:code role="parameter">window</db:code>.</db:para>
<db:para>While on some platforms this will be a no-op, some may perform windowing system dependent synchronization. For example, on Wayland this will add send a wl_surface.frame request in order to prevent the driver from blocking for minimized windows.</db:para>
<db:para>This function was introduced in Qt 5.15.</db:para>
</db:section>
<db:section xml:id="presentQueued">
<db:title>void QVulkanInstance::presentQueued(QWindow *<db:emphasis>window</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>presentQueued</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void presentQueued(QWindow *window)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function should be called by the application's renderer after queuing a present operation for <db:code role="parameter">window</db:code>.</db:para>
<db:para>While on some platforms this will be a no-op, some may perform windowing system dependent synchronization. For example, on X11 this will update <db:code>_NET_WM_SYNC_REQUEST_COUNTER</db:code>.</db:para>
</db:section>
<db:section xml:id="removeDebugOutputFilter">
<db:title>void QVulkanInstance::removeDebugOutputFilter(QVulkanInstance::DebugFilter <db:emphasis>filter</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeDebugOutputFilter</db:methodname>
<db:methodparam>
<db:type>QVulkanInstance::DebugFilter</db:type>
<db:parameter>filter</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeDebugOutputFilter(QVulkanInstance::DebugFilter filter)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes a <db:code role="parameter">filter</db:code> function previously installed by <db:link xlink:href="qvulkaninstance.xml#installDebugOutputFilter">installDebugOutputFilter</db:link>().</db:para>
<db:note>
<db:para>This function can be called before <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#installDebugOutputFilter">installDebugOutputFilter</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resetDeviceFunctions">
<db:title>void QVulkanInstance::resetDeviceFunctions(VkDevice <db:emphasis>device</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resetDeviceFunctions</db:methodname>
<db:methodparam>
<db:type>VkDevice</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resetDeviceFunctions(VkDevice device)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Invalidates and destroys the QVulkanDeviceFunctions object for the given <db:code role="parameter">device</db:code>.</db:para>
<db:para>This function must be called when a VkDevice, for which <db:link xlink:href="qvulkaninstance.xml#deviceFunctions">deviceFunctions</db:link>() was called, gets destroyed while the application intends to continue running, possibly creating a new logical Vulkan device later on.</db:para>
<db:para>There is no need to call this before destroying the <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> since clean up is then performed automatically.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#deviceFunctions">deviceFunctions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setApiVersion">
<db:title>void QVulkanInstance::setApiVersion(const QVersionNumber &amp;<db:emphasis>vulkanVersion</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setApiVersion</db:methodname>
<db:methodparam>
<db:type>const QVersionNumber &amp;</db:type>
<db:parameter>vulkanVersion</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setApiVersion(const QVersionNumber &amp;vulkanVersion)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Specifies the Vulkan API against which the application expects to run.</db:para>
<db:para>By default no <db:code role="parameter">vulkanVersion</db:code> is specified, and so no version check is performed during Vulkan instance creation.</db:para>
<db:note>
<db:para>This function can only be called before <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() and has no effect if called afterwards.</db:para>
</db:note>
<db:note>
<db:para>Be aware that Vulkan 1.1 changes the behavior with regards to the Vulkan API version field. In Vulkan 1.0 specifying an unsupported <db:code role="parameter">vulkanVersion</db:code> led to failing <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() with <db:code>VK_ERROR_INCOMPATIBLE_DRIVER</db:code>, as was mandated by the specification. Starting with Vulkan 1.1, the specification disallows this, the driver must accept any version without failing the instance creation.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#apiVersion">apiVersion</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setExtensions">
<db:title>void QVulkanInstance::setExtensions(const QByteArrayList &amp;<db:emphasis>extensions</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setExtensions</db:methodname>
<db:methodparam>
<db:type>const QByteArrayList &amp;</db:type>
<db:parameter>extensions</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setExtensions(const QByteArrayList &amp;extensions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Specifies the list of additional instance <db:code role="parameter">extensions</db:code> to enable. It is safe to specify unsupported extensions as well because these get ignored when not supported at run time. The surface-related extensions required by Qt will always be added automatically, no need to include them in this list.</db:para>
<db:note>
<db:para>This function can only be called before <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() and has no effect if called afterwards.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#extensions">extensions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFlags">
<db:title>void QVulkanInstance::setFlags(QVulkanInstance::Flags <db:emphasis>flags</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFlags</db:methodname>
<db:methodparam>
<db:type>QVulkanInstance::Flags</db:type>
<db:parameter>flags</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFlags(QVulkanInstance::Flags flags)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Configures the behavior of <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() based on the provided <db:code role="parameter">flags</db:code>.</db:para>
<db:note>
<db:para>This function can only be called before <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() and has no effect if called afterwards.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#flags">flags</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setLayers">
<db:title>void QVulkanInstance::setLayers(const QByteArrayList &amp;<db:emphasis>layers</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setLayers</db:methodname>
<db:methodparam>
<db:type>const QByteArrayList &amp;</db:type>
<db:parameter>layers</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setLayers(const QByteArrayList &amp;layers)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Specifies the list of instance <db:code role="parameter">layers</db:code> to enable. It is safe to specify unsupported layers as well because these get ignored when not supported at run time.</db:para>
<db:note>
<db:para>This function can only be called before <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() and has no effect if called afterwards.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#layers">layers</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setVkInstance">
<db:title>void QVulkanInstance::setVkInstance(VkInstance <db:emphasis>existingVkInstance</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setVkInstance</db:methodname>
<db:methodparam>
<db:type>VkInstance</db:type>
<db:parameter>existingVkInstance</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setVkInstance(VkInstance existingVkInstance)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Makes <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> adopt an existing VkInstance handle instead of creating a new one.</db:para>
<db:note>
<db:para><db:code role="parameter">existingVkInstance</db:code> must have at least <db:code>VK_KHR_surface</db:code> and the appropriate WSI-specific <db:code>VK_KHR_*_surface</db:code> extensions enabled. To ensure debug output redirection is functional, <db:code>VK_EXT_debug_report</db:code> is needed as well.</db:para>
</db:note>
<db:note>
<db:para>This function can only be called before <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() and has no effect if called afterwards.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#vkInstance">vkInstance</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportedExtensions">
<db:title>QVulkanInfoVector&lt;QVulkanExtension&gt; QVulkanInstance::supportedExtensions()</db:title>
<db:methodsynopsis>
<db:type>QVulkanInfoVector&lt;QVulkanExtension&gt;</db:type>
<db:methodname>supportedExtensions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVulkanInfoVector&lt;QVulkanExtension&gt; supportedExtensions()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of supported instance-level extensions.</db:para>
<db:note>
<db:para>This function can be called before <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>().</db:para>
</db:note>
</db:section>
<db:section xml:id="supportedLayers">
<db:title>QVulkanInfoVector&lt;QVulkanLayer&gt; QVulkanInstance::supportedLayers()</db:title>
<db:methodsynopsis>
<db:type>QVulkanInfoVector&lt;QVulkanLayer&gt;</db:type>
<db:methodname>supportedLayers</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVulkanInfoVector&lt;QVulkanLayer&gt; supportedLayers()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of supported instance-level layers.</db:para>
<db:note>
<db:para>This function can be called before <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>().</db:para>
</db:note>
</db:section>
<db:section xml:id="supportsPresent">
<db:title>bool QVulkanInstance::supportsPresent(VkPhysicalDevice <db:emphasis>physicalDevice</db:emphasis>, uint32_t <db:emphasis>queueFamilyIndex</db:emphasis>, QWindow *<db:emphasis>window</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>supportsPresent</db:methodname>
<db:methodparam>
<db:type>VkPhysicalDevice</db:type>
<db:parameter>physicalDevice</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>uint32_t</db:type>
<db:parameter>queueFamilyIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool supportsPresent(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, QWindow *window)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the queue family with <db:code role="parameter">queueFamilyIndex</db:code> within the <db:code role="parameter">physicalDevice</db:code> supports presenting to <db:code role="parameter">window</db:code>.</db:para>
<db:para>Call this function when examining the queues of a given Vulkan device, in order to decide which queue can be used for performing presentation.</db:para>
</db:section>
<db:section xml:id="surfaceForWindow">
<db:title>[static] VkSurfaceKHR QVulkanInstance::surfaceForWindow(QWindow *<db:emphasis>window</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>VkSurfaceKHR</db:type>
<db:methodname>surfaceForWindow</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">VkSurfaceKHR surfaceForWindow(QWindow *window)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates or retrieves the already existing <db:code>VkSurfaceKHR</db:code> handle for the given <db:code role="parameter">window</db:code>.</db:para>
<db:para>Returns the Vulkan surface handle or 0 when failed.</db:para>
</db:section>
<db:section xml:id="vkInstance">
<db:title>VkInstance QVulkanInstance::vkInstance() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>VkInstance</db:type>
<db:methodname>vkInstance</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">VkInstance vkInstance() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the VkInstance handle this <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> wraps, or <db:code>nullptr</db:code> if <db:link xlink:href="qvulkaninstance.xml#create">create</db:link>() has not yet been successfully called and no existing instance has been provided via <db:link xlink:href="qvulkaninstance.xml#setVkInstance">setVkInstance</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qvulkaninstance.xml#setVkInstance">setVkInstance</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
