<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Using VectorCAN Plugin</db:title>
<db:productname>QtSerialBus</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Serial Bus Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Overview of how to use the VectorCAN plugin.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The VectorCAN plugin encapsulates the low-level API to work with the <db:link xlink:href="http://www.vector.com/">Vector Informatik</db:link> CAN adapters.</db:para>
<db:section xml:id="creating-can-bus-devices">
<db:title>Creating CAN Bus Devices</db:title>
<db:para>At first it is necessary to check that <db:link xlink:href="qcanbus.xml">QCanBus</db:link> provides the desired plugin:</db:para>
<db:programlisting language="cpp">if (QCanBus::instance()-&gt;plugins().contains(QStringLiteral(&quot;vectorcan&quot;))) {
    // plugin available
}
</db:programlisting>
<db:para>Where <db:emphasis>vectorcan</db:emphasis> is the plugin name.</db:para>
<db:para>Next, a connection to a specific interface can be established:</db:para>
<db:programlisting language="cpp">QCanBusDevice *device = QCanBus::instance()-&gt;createDevice(
    QStringLiteral(&quot;vectorcan&quot;), QStringLiteral(&quot;can0&quot;));
device-&gt;connectDevice();
</db:programlisting>
<db:para>Where <db:emphasis>can0</db:emphasis> is the active CAN channel name. The VectorCAN plugin provides 64 channels (defined by XL_CONFIG_MAX_CHANNELS in the Vector API) from <db:emphasis>can0</db:emphasis> to <db:emphasis>can63</db:emphasis>. Some of these channels can be virtual, and therefore can be used without actual CAN hardware. To find out the virtual channels, the program &quot;Vector Hardware Config&quot; (vcanconf.exe) can be used, which is included in Vector's driver package.</db:para>
<db:para>The device is now open for writing and reading CAN frames:</db:para>
<db:programlisting language="cpp">QCanBusFrame frame;
frame.setFrameId(8);
QByteArray payload(&quot;A36E&quot;);
frame.setPayload(payload);
device-&gt;writeFrame(frame);
</db:programlisting>
<db:para>The reading can be done using the <db:link xlink:href="qcanbusdevice.xml#readFrame">readFrame</db:link>() method. The <db:link xlink:href="qcanbusdevice.xml#framesReceived">framesReceived</db:link>() signal is emitted when at least one new frame is available for reading:</db:para>
<db:programlisting language="cpp">QCanBusFrame frame = device-&gt;readFrame();
</db:programlisting>
<db:para>VectorCAN supports the following configurations that can be controlled through <db:link xlink:href="qcanbusdevice.xml#setConfigurationParameter">setConfigurationParameter</db:link>():</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Configuration parameter key</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qcanbusdevice.xml#ConfigurationKey-enum">QCanBusDevice::BitRateKey</db:link></db:para>
</db:td>
<db:td>
<db:para>Determines the bit rate of the CAN bus connection.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:article>
