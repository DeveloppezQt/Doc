<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QML Object Attributes</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt QML Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Description of QML object type attributes.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Every QML object type has a defined set of attributes. Each instance of an object type is created with the set of attributes that have been defined for that object type. There are several different kinds of attributes which can be specified, which are described below.</db:para>
<db:section xml:id="attributes-in-object-declarations">
<db:title>Attributes in Object Declarations</db:title>
<db:para>An <db:link xlink:href="qtqml-syntax-basics.xml#object-declarations">object declaration</db:link> in a QML document defines a new type. It also declares an object hierarchy that will be instantiated should an instance of that newly defined type be created.</db:para>
<db:para>The set of QML object-type attribute types is as follows:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>the <db:emphasis>id</db:emphasis> attribute</db:para>
</db:listitem>
<db:listitem>
<db:para>property attributes</db:para>
</db:listitem>
<db:listitem>
<db:para>signal attributes</db:para>
</db:listitem>
<db:listitem>
<db:para>signal handler attributes</db:para>
</db:listitem>
<db:listitem>
<db:para>method attributes</db:para>
</db:listitem>
<db:listitem>
<db:para>attached properties and attached signal handler attributes</db:para>
</db:listitem>
<db:listitem>
<db:para>enumeration attributes</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>These attributes are discussed in detail below.</db:para>
<db:section xml:id="the-id-attribute">
<db:title>The <db:emphasis>id</db:emphasis> Attribute</db:title>
<db:para>Every QML object type has exactly one <db:emphasis>id</db:emphasis> attribute. This attribute is provided by the language itself, and cannot be redefined or overridden by any QML object type.</db:para>
<db:para>A value may be assigned to the <db:emphasis>id</db:emphasis> attribute of an object instance to allow that object to be identified and referred to by other objects. This id must begin with a lower-case letter or an underscore, and cannot contain characters other than letters, numbers and underscores.</db:para>
<db:para>Below is a <db:link xlink:href="qml-qtquick-textinput.xml">TextInput</db:link> object and a <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> object. The <db:link xlink:href="qml-qtquick-textinput.xml">TextInput</db:link> object's id value is set to &quot;myTextInput&quot;. The <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> object sets its text property to have the same value as the text property of the <db:link xlink:href="qml-qtquick-textinput.xml">TextInput</db:link>, by referring to myTextInput.text. Now, both items will display the same text:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Column {
    width: 200; height: 200

    TextInput { id: myTextInput; text: &quot;Hello World&quot; }

    Text { text: myTextInput.text }
}
</db:programlisting>
<db:para>An object can be referred to by its id from anywhere within the <db:emphasis>component scope</db:emphasis> in which it is declared. Therefore, an id value must always be unique within its component scope. See <db:link xlink:href="qtqml-documents-scope.xml">Scope and Naming Resolution</db:link> for more information.</db:para>
<db:para>Once an object instance is created, the value of its <db:emphasis>id</db:emphasis> attribute cannot be changed. While it may look like an ordinary property, the id attribute is <db:emphasis role="bold">not</db:emphasis> an ordinary property attribute, and special semantics apply to it; for example, it is not possible to access myTextInput.id in the above example.</db:para>
</db:section>
<db:section xml:id="property-attributes">
<db:title>Property Attributes</db:title>
<db:para>A property is an attribute of an object that can be assigned a static value or bound to a dynamic expression. A property's value can be read by other objects. Generally it can also be modified by another object, unless a particular QML type has explicitly disallowed this for a specific property.</db:para>
<db:section xml:id="defining-property-attributes">
<db:title>Defining Property Attributes</db:title>
<db:para>A property may be defined for a type in C++ by registering a <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link> of a class which is then registered with the QML type system. Alternatively, a custom property of an object type may be defined in an object declaration in a QML document with the following syntax:</db:para>
<db:programlisting language="cpp">[default] property &amp;lt;propertyType&amp;gt; &amp;lt;propertyName&amp;gt;
</db:programlisting>
<db:para>In this way an object declaration may <db:link xlink:href="qtqml-typesystem-objecttypes.xml#defining-object-types-from-qml">expose a particular value</db:link> to outside objects or maintain some internal state more easily.</db:para>
<db:para>Property names must begin with a lower case letter and can only contain letters, numbers and underscores. <db:link xlink:href="https://developer.mozilla.org/en/JavaScript/Reference/Reserved_Words">JavaScript reserved words</db:link> are not valid property names. The default keyword is optional, and modifies the semantics of the property being declared. See the upcoming section on <db:link xlink:href="qtqml-syntax-objectattributes.xml#default-properties">default properties</db:link> for more information about the default property modifier.</db:para>
<db:para>Declaring a custom property implicitly creates a value-change <db:link xlink:href="qtqml-syntax-objectattributes.xml#signal-attributes">signal</db:link> for that property, as well as an associated <db:link xlink:href="qtqml-syntax-objectattributes.xml#signal-handler-attributes">signal handler</db:link> called <db:emphasis>on&lt;PropertyName&gt;Changed</db:emphasis>, where <db:emphasis>&lt;PropertyName&gt;</db:emphasis> is the name of the property, with the first letter capitalized.</db:para>
<db:para>For example, the following object declaration defines a new type which derives from the Rectangle base type. It has two new properties, with a <db:link xlink:href="qtqml-syntax-objectattributes.xml#signal-handler-attributes">signal handler</db:link> implemented for one of those new properties:</db:para>
<db:programlisting language="qml">Rectangle {
    property color previousColor
    property color nextColor
    onNextColorChanged: console.log(&quot;The next color will be: &quot; + nextColor.toString())
}
</db:programlisting>
<db:section xml:id="valid-types-in-custom-property-definitions">
<db:title>Valid Types in Custom Property Definitions</db:title>
<db:para>Any of the <db:link xlink:href="qtqml-typesystem-basictypes.xml">QML Basic Types</db:link> aside from the <db:link xlink:href="qml-enumeration.xml">enumeration</db:link> type can be used as custom property types. For example, these are all valid property declarations:</db:para>
<db:programlisting language="qml">Item {
    property int someNumber
    property string someString
    property url someUrl
}
</db:programlisting>
<db:para>(Enumeration values are simply whole number values and can be referred to with the <db:link xlink:href="qml-int.xml">int</db:link> type instead.)</db:para>
<db:para>Some basic types are provided by the QtQuick module and thus cannot be used as property types unless the module is imported. See the <db:link xlink:href="qtqml-typesystem-basictypes.xml">QML Basic Types</db:link> documentation for more details.</db:para>
<db:para>Note the <db:link xlink:href="qml-var.xml">var</db:link> basic type is a generic placeholder type that can hold any type of value, including lists and objects:</db:para>
<db:programlisting language="cpp">property var someNumber: 1.5
property var someString: &quot;abc&quot;
property var someBool: true
property var someList: [1, 2, &quot;three&quot;, &quot;four&quot;]
property var someObject: Rectangle { width: 100; height: 100; color: &quot;red&quot; }
</db:programlisting>
<db:para>Additionally, any <db:link xlink:href="qtqml-typesystem-objecttypes.xml">QML object type</db:link> can be used as a property type. For example:</db:para>
<db:programlisting language="cpp">property Item someItem
property Rectangle someRectangle
</db:programlisting>
<db:para>This applies to <db:link xlink:href="qtqml-typesystem-objecttypes.xml#defining-object-types-from-qml">custom QML types</db:link> as well. If a QML type was defined in a file named ColorfulButton.qml (in a directory which was then imported by the client), then a property of type ColorfulButton would also be valid.</db:para>
</db:section>
</db:section>
<db:section xml:id="assigning-values-to-property-attributes">
<db:title>Assigning Values to Property Attributes</db:title>
<db:para>The value of a property of an object instance may be specified in two separate ways:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>a value assignment on initialization</db:para>
</db:listitem>
<db:listitem>
<db:para>an imperative value assignment</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In either case, the value may be either a <db:emphasis>static</db:emphasis> value or a <db:emphasis>binding expression</db:emphasis> value.</db:para>
<db:section xml:id="value-assignment-on-initialization">
<db:title>Value Assignment on Initialization</db:title>
<db:para>The syntax for assigning a value to a property on initialization is:</db:para>
<db:programlisting language="cpp">&amp;lt;propertyName&amp;gt; : &amp;lt;value&amp;gt;
</db:programlisting>
<db:para>An initialization value assignment may be combined with a property definition in an object declaration, if desired. In that case, the syntax of the property definition becomes:</db:para>
<db:programlisting language="cpp">[default] property &amp;lt;propertyType&amp;gt; &amp;lt;propertyName&amp;gt; : &amp;lt;value&amp;gt;
</db:programlisting>
<db:para>An example of property value initialization follows:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Rectangle {
    color: &quot;red&quot;
    property color nextColor: &quot;blue&quot; // combined property declaration and initialization
}
</db:programlisting>
</db:section>
<db:section xml:id="imperative-value-assignment">
<db:title>Imperative Value Assignment</db:title>
<db:para>An imperative value assignment is where a property value (either static value or binding expression) is assigned to a property from imperative JavaScript code. The syntax of an imperative value assignment is just the JavaScript assignment operator, as shown below:</db:para>
<db:programlisting language="cpp">[&amp;lt;objectId&amp;gt;.]&amp;lt;propertyName&amp;gt; = value
</db:programlisting>
<db:para>An example of imperative value assignment follows:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Rectangle {
    id: rect
    Component.onCompleted: {
        rect.color = &quot;red&quot;
    }
}
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="static-values-and-binding-expression-values">
<db:title>Static Values and Binding Expression Values</db:title>
<db:para>As previously noted, there are two kinds of values which may be assigned to a property: <db:emphasis>static</db:emphasis> values, and <db:emphasis>binding expression</db:emphasis> values. The latter are also known as <db:link xlink:href="qtqml-syntax-propertybinding.xml">property bindings</db:link>.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Kind</db:para>
</db:th>
<db:th>
<db:para>Semantics</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Static Value</db:para>
</db:td>
<db:td>
<db:para>A constant value which does not depend on other properties.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Binding Expression</db:para>
</db:td>
<db:td>
<db:para>A JavaScript expression which describes a property's relationship with other properties. The variables in this expression are called the property's <db:emphasis>dependencies</db:emphasis>.</db:para>
<db:para>The QML engine enforces the relationship between a property and its dependencies. When any of the dependencies change in value, the QML engine automatically re-evaluates the binding expression and assigns the new result to the property.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Here is an example that shows both kinds of values being assigned to properties:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Rectangle {
    // both of these are static value assignments on initialization
    width: 400
    height: 200

    Rectangle {
        // both of these are binding expression value assignments on initialization
        width: parent.width / 2
        height: parent.height
    }
}
</db:programlisting>
<db:note>
<db:para>To assign a binding expression imperatively, the binding expression must be contained in a function that is passed into <db:link xlink:href="qml-qtqml-qt.xml#binding-method">Qt.binding</db:link>(), and then the value returned by Qt.binding() must be assigned to the property. In contrast, Qt.binding() must not be used when assigning a binding expression upon initialization. See <db:link xlink:href="qtqml-syntax-propertybinding.xml">Property Binding</db:link> for more information.</db:para>
</db:note>
</db:section>
<db:section xml:id="type-safety">
<db:title>Type Safety</db:title>
<db:para>Properties are type safe. A property can only be assigned a value that matches the property type.</db:para>
<db:para>For example, if a property is a real, and if you try to assign a string to it, you will get an error:</db:para>
<db:programlisting language="cpp">property int volume: &quot;four&quot;  // generates an error; the property's object will not be loaded
</db:programlisting>
<db:para>Likewise if a property is assigned a value of the wrong type during run time, the new value will not be assigned, and an error will be generated.</db:para>
<db:para>Some property types do not have a natural value representation, and for those property types the QML engine automatically performs string-to-typed-value conversion. So, for example, even though properties of the color type store colors and not strings, you are able to assign the string &quot;red&quot; to a color property, without an error being reported.</db:para>
<db:para>See <db:link xlink:href="qtqml-typesystem-basictypes.xml">QML Basic Types</db:link> for a list of the types of properties that are supported by default. Additionally, any available <db:link xlink:href="qtqml-typesystem-objecttypes.xml">QML object type</db:link> may also be used as a property type.</db:para>
</db:section>
<db:section xml:id="special-property-types">
<db:title>Special Property Types</db:title>
<db:section xml:id="object-list-property-attributes">
<db:title>Object List Property Attributes</db:title>
<db:para>A <db:link xlink:href="qml-list.xml">list</db:link> type property can be assigned a list of QML object-type values. The syntax for defining an object list value is a comma-separated list surrounded by square brackets:</db:para>
<db:programlisting language="cpp">[ &amp;lt;item 1&amp;gt;, &amp;lt;item 2&amp;gt;, ... ]
</db:programlisting>
<db:para>For example, the <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> type has a <db:link xlink:href="qml-qtquick-item.xml#states-prop">states</db:link> property that is used to hold a list of <db:link xlink:href="qml-qtqml-statemachine-state.xml">State</db:link> type objects. The code below initializes the value of this property to a list of three <db:link xlink:href="qml-qtqml-statemachine-state.xml">State</db:link> objects:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Item {
    states: [
        State { name: &quot;loading&quot; },
        State { name: &quot;running&quot; },
        State { name: &quot;stopped&quot; }
    ]
}
</db:programlisting>
<db:para>If the list contains a single item, the square brackets may be omitted:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Item {
    states: State { name: &quot;running&quot; }
}
</db:programlisting>
<db:para>A <db:link xlink:href="qml-list.xml">list</db:link> type property may be specified in an object declaration with the following syntax:</db:para>
<db:programlisting language="cpp">[default] property list&amp;lt;&amp;lt;objectType&amp;gt;&amp;gt; propertyName
</db:programlisting>
<db:para>and, like other property declarations, a property initialization may be combined with the property declaration with the following syntax:</db:para>
<db:programlisting language="cpp">[default] property list&amp;lt;&amp;lt;objectType&amp;gt;&amp;gt; propertyName: &amp;lt;value&amp;gt;
</db:programlisting>
<db:para>An example of list property declaration follows:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Rectangle {
    // declaration without initialization
    property list&amp;lt;Rectangle&amp;gt; siblingRects

    // declaration with initialization
    property list&amp;lt;Rectangle&amp;gt; childRects: [
        Rectangle { color: &quot;red&quot; },
        Rectangle { color: &quot;blue&quot;}
    ]
}
</db:programlisting>
<db:para>If you wish to declare a property to store a list of values which are not necessarily QML object-type values, you should declare a <db:link xlink:href="qml-var.xml">var</db:link> property instead.</db:para>
</db:section>
<db:section xml:id="grouped-properties">
<db:title>Grouped Properties</db:title>
<db:para>In some cases properties contain a logical group of sub-property attributes. These sub-property attributes can be assigned to using either the dot notation or group notation.</db:para>
<db:para>For example, the <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> type has a <db:link xlink:href="qml-qtquick-text.xml#font.family-prop">font</db:link> group property. Below, the first <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> object initializes its font values using dot notation, while the second uses group notation:</db:para>
<db:programlisting language="cpp">Text {
    //dot notation
    font.pixelSize: 12
    font.b: true
}

Text {
    //group notation
    font { pixelSize: 12; b: true }
}
</db:programlisting>
<db:para>Grouped property types are basic types which have subproperties. Some of these basic types are provided by the QML language, while others may only be used if the Qt Quick module is imported. See the documentation about <db:link xlink:href="qtqml-typesystem-basictypes.xml">QML Basic Types</db:link> for more information.</db:para>
</db:section>
</db:section>
<db:section xml:id="property-aliases">
<db:title>Property Aliases</db:title>
<db:para>Property aliases are properties which hold a reference to another property. Unlike an ordinary property definition, which allocates a new, unique storage space for the property, a property alias connects the newly declared property (called the aliasing property) as a direct reference to an existing property (the aliased property).</db:para>
<db:para>A property alias declaration looks like an ordinary property definition, except that it requires the alias keyword instead of a property type, and the right-hand-side of the property declaration must be a valid alias reference:</db:para>
<db:programlisting language="cpp">[default] property alias &amp;lt;name&amp;gt;: &amp;lt;alias reference&amp;gt;
</db:programlisting>
<db:para>Unlike an ordinary property, an alias has the following restrictions:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>It can only refer to an object, or the property of an object, that is within the scope of the <db:link xlink:href="qtqml-typesystem-objecttypes.xml">type</db:link> within which the alias is declared.</db:para>
</db:listitem>
<db:listitem>
<db:para>It cannot contain arbitrary JavaScript expressions</db:para>
</db:listitem>
<db:listitem>
<db:para>It cannot refer to objects declared outside of the scope of its type.</db:para>
</db:listitem>
<db:listitem>
<db:para>The <db:emphasis>alias reference</db:emphasis> is not optional, unlike the optional default value for an ordinary property; the alias reference must be provided when the alias is first declared.</db:para>
</db:listitem>
<db:listitem>
<db:para>It cannot refer to <db:link xlink:href="qtqml-syntax-objectattributes.xml#attached-properties-and-attached-signal-handlers">attached properties</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>It cannot refer to grouped properties; the following code will not work:</db:para>
<db:programlisting language="cpp">property alias color: rectangle.border.color

Rectangle {
    id: rectangle
}
</db:programlisting>
<db:para>However, aliases to <db:link xlink:href="qtqml-typesystem-basictypes.xml">value type</db:link> properties do work:</db:para>
<db:programlisting language="cpp">property alias rectX: object.rectProperty.x

Item {
    id: object
    property rect rectProperty
}
</db:programlisting>
</db:listitem>
</db:itemizedlist>
<db:para>For example, below is a Button type with a buttonText aliased property which is connected to the text object of the <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> child:</db:para>
<db:programlisting language="qml">// Button.qml
import QtQuick 2.0

Rectangle {
    property alias buttonText: textItem.text

    width: 100; height: 30; color: &quot;yellow&quot;

    Text { id: textItem }
}
</db:programlisting>
<db:para>The following code would create a Button with a defined text string for the child <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> object:</db:para>
<db:programlisting language="qml">Button { buttonText: &quot;Click Me&quot; }
</db:programlisting>
<db:para>Here, modifying buttonText directly modifies the textItem.text value; it does not change some other value that then updates textItem.text. If buttonText was not an alias, changing its value would not actually change the displayed text at all, as property bindings are not bi-directional: the buttonText value would have changed if textItem.text was changed, but not the other way around.</db:para>
<db:section xml:id="considerations-for-property-aliases">
<db:title>Considerations for Property Aliases</db:title>
<db:para>Aliases are only activated once a component has been fully initialized. An error is generated when an uninitialized alias is referenced. Likewise, aliasing an aliasing property will also result in an error.</db:para>
<db:programlisting language="qml">property alias widgetLabel: label

//will generate an error
//widgetLabel.text: &quot;Initial text&quot;

//will generate an error
//property alias widgetLabelText: widgetLabel.text

Component.onCompleted: widgetLabel.text = &quot;Alias completed Initialization&quot;
</db:programlisting>
<db:para>When importing a <db:link xlink:href="qtqml-typesystem-objecttypes.xml">QML object type</db:link> with a property alias in the root object, however, the property appear as a regular Qt property and consequently can be used in alias references.</db:para>
<db:para>It is possible for an aliasing property to have the same name as an existing property, effectively overwriting the existing property. For example, the following QML type has a color alias property, named the same as the built-in <db:link xlink:href="qml-qtquick-rectangle.xml#color-prop">Rectangle::color</db:link> property:</db:para>
<db:programlisting language="qml">Rectangle {
    id: coloredrectangle
    property alias color: bluerectangle.color
    color: &quot;red&quot;

    Rectangle {
        id: bluerectangle
        color: &quot;#1234ff&quot;
    }

    Component.onCompleted: {
        console.log (coloredrectangle.color)    //prints &quot;#1234ff&quot;
        setInternalColor()
        console.log (coloredrectangle.color)    //prints &quot;#111111&quot;
        coloredrectangle.color = &quot;#884646&quot;
        console.log (coloredrectangle.color)    //prints #884646
    }

    //internal function that has access to internal properties
    function setInternalColor() {
        color = &quot;#111111&quot;
    }
}
</db:programlisting>
<db:para>Any object that use this type and refer to its color property will be referring to the alias rather than the ordinary <db:link xlink:href="qml-qtquick-rectangle.xml#color-prop">Rectangle::color</db:link> property. Internally, however, the rectangle can correctly set its color property and refer to the actual defined property rather than the alias.</db:para>
</db:section>
</db:section>
<db:section xml:id="default-properties">
<db:title>Default Properties</db:title>
<db:para>An object definition can have a single <db:emphasis>default</db:emphasis> property. A default property is the property to which a value is assigned if an object is declared within another object's definition without declaring it as a value for a particular property.</db:para>
<db:para>Declaring a property with the optional default keyword marks it as the default property. For example, say there is a file MyLabel.qml with a default property someText:</db:para>
<db:programlisting language="qml">// MyLabel.qml
import QtQuick 2.0

Text {
    default property var someText

    text: &quot;Hello, &quot; + someText.text
}
</db:programlisting>
<db:para>The someText value could be assigned to in a MyLabel object definition, like this:</db:para>
<db:programlisting language="qml">MyLabel {
    Text { text: &quot;world!&quot; }
}
</db:programlisting>
<db:para>This has exactly the same effect as the following:</db:para>
<db:programlisting language="qml">MyLabel {
    someText: Text { text: &quot;world!&quot; }
}
</db:programlisting>
<db:para>However, since the someText property has been marked as the default property, it is not necessary to explicitly assign the <db:link xlink:href="qml-qtquick-text.xml">Text</db:link> object to this property.</db:para>
<db:para>You will notice that child objects can be added to any <db:link xlink:href="qml-qtquick-item.xml">Item</db:link>-based type without explicitly adding them to the <db:link xlink:href="qml-qtquick-item.xml#children-prop">children</db:link> property. This is because the default property of <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> is its data property, and any items added to this list for an <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> are automatically added to its list of <db:link xlink:href="qml-qtquick-item.xml#children-prop">children</db:link>.</db:para>
<db:para>Default properties can be useful for reassigning the children of an item. See the <db:link xlink:href="qtquick-customitems-tabwidget-example.xml">TabWidget Example</db:link>, which uses a default property to automatically reassign children of the TabWidget as children of an inner <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link>. See also <db:link xlink:href="qtquick-codesamples.xml#extending-qml">Extending QML</db:link>.</db:para>
</db:section>
<db:section xml:id="read-only-properties">
<db:title>Read-Only Properties</db:title>
<db:para>An object declaration may define a read-only property using the readonly keyword, with the following syntax:</db:para>
<db:programlisting language="cpp">readonly property &amp;lt;propertyType&amp;gt; &amp;lt;propertyName&amp;gt; : &amp;lt;initialValue&amp;gt;
</db:programlisting>
<db:para>Read-only properties must be assigned a value on initialization. After a read-only property is initialized, it no longer possible to give it a value, whether from imperative code or otherwise.</db:para>
<db:para>For example, the code in the Component.onCompleted block below is invalid:</db:para>
<db:programlisting language="qml">Item {
    readonly property int someNumber: 10

    Component.onCompleted: someNumber = 20  // doesn't work, causes an error
}
</db:programlisting>
<db:note>
<db:para>A read-only property cannot also be a <db:link xlink:href="qtqml-syntax-objectattributes.xml#default-properties">default</db:link> property.</db:para>
</db:note>
</db:section>
<db:section xml:id="property-modifier-objects">
<db:title>Property Modifier Objects</db:title>
<db:para>Properties can have <db:link xlink:href="qtqml-cppintegration-definetypes.xml#property-modifier-types">property value modifier objects</db:link> associated with them. The syntax for declaring an instance of a property modifier type associated with a particular property is as follows:</db:para>
<db:programlisting language="cpp">&amp;lt;PropertyModifierTypeName&amp;gt; on &amp;lt;propertyName&amp;gt; {
    // attributes of the object instance
}
</db:programlisting>
<db:para>It is important to note that the above syntax is in fact an <db:link xlink:href="qtqml-syntax-basics.xml#object-declarations">object declaration</db:link> which will instantiate an object which acts on a pre-existing property.</db:para>
<db:para>Certain property modifier types may only be applicable to specific property types, however this is not enforced by the language. For example, the NumberAnimation type provided by QtQuick will only animate numeric-type (such as int or real) properties. Attempting to use a NumberAnimation with non-numeric property will not result in an error, however the non-numeric property will not be animated. The behavior of a property modifier type when associated with a particular property type is defined by its implementation.</db:para>
</db:section>
</db:section>
<db:section xml:id="signal-attributes">
<db:title>Signal Attributes</db:title>
<db:para>A signal is a notification from an object that some event has occurred: for example, a property has changed, an animation has started or stopped, or when an image has been downloaded. The <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> type, for example, has a <db:link xlink:href="qml-qtquick-mousearea.xml#clicked-signal">clicked</db:link> signal that is emitted when the user clicks within the mouse area.</db:para>
<db:para>An object can be notified through a <db:link xlink:href="qtqml-syntax-objectattributes.xml#signal-handler-attributes">signal handler</db:link> whenever a particular signal is emitted. A signal handler is declared with the syntax <db:emphasis>on&lt;Signal&gt;</db:emphasis> where <db:emphasis>&lt;Signal&gt;</db:emphasis> is the name of the signal, with the first letter capitalized. The signal handler must be declared within the definition of the object that emits the signal, and the handler should contain the block of JavaScript code to be executed when the signal handler is invoked.</db:para>
<db:para>For example, the <db:emphasis>onClicked</db:emphasis> signal handler below is declared within the <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> object definition, and is invoked when the <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> is clicked, causing a console message to be printed:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Item {
    width: 100; height: 100

    MouseArea {
        anchors.fill: parent
        onClicked: {
            console.log(&quot;Click!&quot;)
        }
    }
}
</db:programlisting>
<db:section xml:id="defining-signal-attributes">
<db:title>Defining Signal Attributes</db:title>
<db:para>A signal may be defined for a type in C++ by registering a <db:link xlink:href="qobject.xml#Q_SIGNAL">Q_SIGNAL</db:link> of a class which is then registered with the QML type system. Alternatively, a custom signal for an object type may be defined in an object declaration in a QML document with the following syntax:</db:para>
<db:programlisting language="cpp">signal &amp;lt;signalName&amp;gt;[([&amp;lt;type&amp;gt; &amp;lt;parameter name&amp;gt;[, ...]])]
</db:programlisting>
<db:para>Attempting to declare two signals or methods with the same name in the same type block is an error. However, a new signal may reuse the name of an existing signal on the type. (This should be done with caution, as the existing signal may be hidden and become inaccessible.)</db:para>
<db:para>Here are three examples of signal declarations:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Item {
    signal clicked
    signal hovered()
    signal actionPerformed(string action, var actionResult)
}
</db:programlisting>
<db:para>If the signal has no parameters, the &quot;()&quot; brackets are optional. If parameters are used, the parameter types must be declared, as for the string and var arguments for the actionPerformed signal above. The allowed parameter types are the same as those listed under <db:link xlink:href="qtqml-syntax-objectattributes.xml#defining-property-attributes">Defining Property Attributes</db:link> on this page.</db:para>
<db:para>To emit a signal, invoke it as a method. Any relevant <db:link xlink:href="qtqml-syntax-objectattributes.xml#signal-handler-attributes">signal handlers</db:link> will be invoked when the signal is emitted, and handlers can use the defined signal argument names to access the respective arguments.</db:para>
</db:section>
<db:section xml:id="property-change-signals">
<db:title>Property Change Signals</db:title>
<db:para>QML types also provide built-in <db:emphasis>property change signals</db:emphasis> that are emitted whenever a property value changes, as previously described in the section on <db:link xlink:href="qtqml-syntax-objectattributes.xml#property-attributes">property attributes</db:link>. See the upcoming section on <db:link xlink:href="qtqml-syntax-signals.xml#property-change-signal-handlers">property change signal handlers</db:link> for more information about why these signals are useful, and how to use them.</db:para>
</db:section>
</db:section>
<db:section xml:id="signal-handler-attributes">
<db:title>Signal Handler Attributes</db:title>
<db:para>Signal handlers are a special sort of <db:link xlink:href="qtqml-syntax-objectattributes.xml#method-attributes">method attribute</db:link>, where the method implementation is invoked by the QML engine whenever the associated signal is emitted. Adding a signal to an object definition in QML will automatically add an associated signal handler to the object definition, which has, by default, an empty implementation. Clients can provide an implementation, to implement program logic.</db:para>
<db:para>Consider the following SquareButton type, whose definition is provided in the SquareButton.qml file as shown below, with signals activated and deactivated:</db:para>
<db:programlisting language="qml">// SquareButton.qml
Rectangle {
    id: root

    signal activated(real xPosition, real yPosition)
    signal deactivated

    property int side: 100
    width: side; height: side

    MouseArea {
        anchors.fill: parent
        onPressed: root.activated(mouse.x, mouse.y)
        onReleased: root.deactivated()
    }
}
</db:programlisting>
<db:para>These signals could be received by any SquareButton objects in another QML file in the same directory, where implementations for the signal handlers are provided by the client:</db:para>
<db:programlisting language="qml">// myapplication.qml
SquareButton {
    onActivated: console.log(&quot;Activated at &quot; + xPosition + &quot;,&quot; + yPosition)
    onDeactivated: console.log(&quot;Deactivated!&quot;)
}
</db:programlisting>
<db:para>See the <db:link xlink:href="qtqml-syntax-signals.xml">Signal and Handler Event System</db:link> for more details on use of signals.</db:para>
<db:section xml:id="property-change-signal-handlers">
<db:title>Property Change Signal Handlers</db:title>
<db:para>Signal handlers for property change signal take the syntax form <db:emphasis>on&lt;Property&gt;Changed</db:emphasis> where <db:emphasis>&lt;Property&gt;</db:emphasis> is the name of the property, with the first letter capitalized. For example, although the <db:link xlink:href="qml-qtquick-textinput.xml">TextInput</db:link> type documentation does not document a textChanged signal, this signal is implicitly available through the fact that <db:link xlink:href="qml-qtquick-textinput.xml">TextInput</db:link> has a <db:link xlink:href="qml-qtquick-textinput.xml#text-prop">text</db:link> property and so it is possible to write an onTextChanged signal handler to be called whenever this property changes:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

TextInput {
    text: &quot;Change this!&quot;

    onTextChanged: console.log(&quot;Text has changed to:&quot;, text)
}
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="method-attributes">
<db:title>Method Attributes</db:title>
<db:para>A method of an object type is a function which may be called to perform some processing or trigger further events. A method can be connected to a signal so that it is automatically invoked whenever the signal is emitted. See <db:link xlink:href="qtqml-syntax-signals.xml">Signal and Handler Event System</db:link> for more details.</db:para>
<db:section xml:id="defining-method-attributes">
<db:title>Defining Method Attributes</db:title>
<db:para>A method may be defined for a type in C++ by tagging a function of a class which is then registered with the QML type system with <db:link xlink:href="qobject.xml#Q_INVOKABLE">Q_INVOKABLE</db:link> or by registering it as a <db:link xlink:href="qobject.xml#Q_SLOT">Q_SLOT</db:link> of the class. Alternatively, a custom method can be added to an object declaration in a QML document with the following syntax:</db:para>
<db:programlisting language="cpp">function &amp;lt;functionName&amp;gt;([&amp;lt;parameterName&amp;gt;[, ...]]) { &amp;lt;body&amp;gt; }
</db:programlisting>
<db:para>Methods can be added to a QML type in order to define standalone, reusable blocks of JavaScript code. These methods can be invoked either internally or by external objects.</db:para>
<db:para>Unlike signals, method parameter types do not have to be declared as they default to the var type.</db:para>
<db:para>Attempting to declare two methods or signals with the same name in the same type block is an error. However, a new method may reuse the name of an existing method on the type. (This should be done with caution, as the existing method may be hidden and become inaccessible.)</db:para>
<db:para>Below is a <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link> with a calculateHeight() method that is called when assigning the height value:</db:para>
<db:programlisting language="qml">import QtQuick 2.0
Rectangle {
    id: rect

    function calculateHeight() {
        return rect.width / 2;
    }

    width: 100
    height: calculateHeight()
}
</db:programlisting>
<db:para>If the method has parameters, they are accessible by name within the method. Below, when the <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> is clicked it invokes the moveTo() method which can then refer to the received newX and newY parameters to reposition the text:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Item {
    width: 200; height: 200

    MouseArea {
        anchors.fill: parent
        onClicked: label.moveTo(mouse.x, mouse.y)
    }

    Text {
        id: label

        function moveTo(newX, newY) {
            label.x = newX;
            label.y = newY;
        }

        text: &quot;Move me!&quot;
    }
}
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="attached-properties-and-attached-signal-handlers">
<db:title>Attached Properties and Attached Signal Handlers</db:title>
<db:para><db:emphasis>Attached properties</db:emphasis> and <db:emphasis>attached signal handlers</db:emphasis> are mechanisms that enable objects to be annotated with extra properties or signal handlers that are otherwise unavailable to the object. In particular, they allow objects to access properties or signals that are specifically relevant to the individual object.</db:para>
<db:para>A QML type implementation may choose to <db:link xlink:href="qtqml-cppintegration-definetypes.xml#providing-attached-properties">create an <db:emphasis>attaching type</db:emphasis> in C++</db:link> with particular properties and signals. Instances of this type can then be created and <db:emphasis>attached</db:emphasis> to specific objects at run time, allowing those objects to access the properties and signals of the attaching type. These are accessed by prefixing the properties and respective signal handlers with the name of the attaching type.</db:para>
<db:para>References to attached properties and handlers take the following syntax form:</db:para>
<db:programlisting language="cpp">&amp;lt;AttachingType&amp;gt;.&amp;lt;propertyName&amp;gt;
&amp;lt;AttachingType&amp;gt;.on&amp;lt;SignalName&amp;gt;
</db:programlisting>
<db:para>For example, the <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> type has an attached property <db:link xlink:href="qml-qtquick-listview.xml#isCurrentItem-attached-prop">ListView.isCurrentItem</db:link> that is available to each delegate object in a <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link>. This can be used by each individual delegate object to determine whether it is the currently selected item in the view:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

ListView {
    width: 240; height: 320
    model: 3
    delegate: Rectangle {
        width: 100; height: 30
        color: ListView.isCurrentItem ? &quot;red&quot; : &quot;yellow&quot;
    }
}
</db:programlisting>
<db:para>In this case, the name of the <db:emphasis>attaching type</db:emphasis> is ListView and the property in question is isCurrentItem, hence the attached property is referred to as ListView.isCurrentItem.</db:para>
<db:para>An attached signal handler is referred to in the same way. For example, the <db:link xlink:href="qml-qtqml-component.xml#completed-signal">Component.onCompleted</db:link> attached signal handler is commonly used to execute some JavaScript code when a component's creation process has been completed. In the example below, once the <db:link xlink:href="qml-qtqml-models-listmodel.xml">ListModel</db:link> has been fully created, its Component.onCompleted signal handler will automatically be invoked to populate the model:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

ListView {
    width: 240; height: 320
    model: ListModel {
        id: listModel
        Component.onCompleted: {
            for (var i = 0; i &amp;lt; 10; i++)
                listModel.append({&quot;Name&quot;: &quot;Item &quot; + i})
        }
    }
    delegate: Text { text: index }
}
</db:programlisting>
<db:para>Since the name of the <db:emphasis>attaching type</db:emphasis> is Component and that type has a <db:link xlink:href="qml-qtqml-component.xml#completed-signal">completed</db:link> signal, the attached signal handler is referred to as Component.onCompleted.</db:para>
<db:section xml:id="a-note-about-accessing-attached-properties-and-signal-handlers">
<db:title>A Note About Accessing Attached Properties and Signal Handlers</db:title>
<db:para>A common error is to assume that attached properties and signal handlers are directly accessible from the children of the object to which these attributes have been attached. This is not the case. The instance of the <db:emphasis>attaching type</db:emphasis> is only attached to specific objects, not to the object and all of its children.</db:para>
<db:para>For example, below is a modified version of the earlier example involving attached properties. This time, the delegate is an <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> and the colored <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link> is a child of that item:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

ListView {
    width: 240; height: 320
    model: 3
    delegate: Item {
        width: 100; height: 30

        Rectangle {
            width: 100; height: 30
            color: ListView.isCurrentItem ? &quot;red&quot; : &quot;yellow&quot;    // WRONG! This won't work.
        }
    }
}
</db:programlisting>
<db:para>This does not work as expected because ListView.isCurrentItem is attached <db:emphasis>only</db:emphasis> to the root delegate object, and not its children. Since the <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link> is a child of the delegate, rather than being the delegate itself, it cannot access the isCurrentItem attached property as ListView.isCurrentItem. So instead, the rectangle should access isCurrentItem through the root delegate:</db:para>
<db:programlisting language="qml">ListView {
    //....
    delegate: Item {
        id: delegateItem
        width: 100; height: 30

        Rectangle {
            width: 100; height: 30
            color: delegateItem.ListView.isCurrentItem ? &quot;red&quot; : &quot;yellow&quot;   // correct
        }
    }
}
</db:programlisting>
<db:para>Now delegateItem.ListView.isCurrentItem correctly refers to the isCurrentItem attached property of the delegate.</db:para>
</db:section>
</db:section>
<db:section xml:id="enumeration-attributes">
<db:title>Enumeration Attributes</db:title>
<db:para>Enumerations provide a fixed set of named choices. They can be declared in QML using the enum keyword:</db:para>
<db:programlisting language="qml">// MyText.qml
Text {
    enum TextType {
        Normal,
        Heading
    }
}
</db:programlisting>
<db:para>As shown above, enumeration types (e.g. TextType) and values (e.g. Normal) must begin with an uppercase letter.</db:para>
<db:para>Values are referred to via &lt;Type&gt;.&lt;EnumerationType&gt;.&lt;Value&gt; or &lt;Type&gt;.&lt;Value&gt;.</db:para>
<db:programlisting language="qml">// MyText.qml
Text {
    enum TextType {
        Normal,
        Heading
    }

    property int textType: MyText.TextType.Normal

    font.bold: textType == MyText.TextType.Heading
    font.pixelSize: textType == MyText.TextType.Heading ? 24 : 12
}
</db:programlisting>
<db:para>More information on enumeration usage in QML can be found in the <db:link xlink:href="qtqml-typesystem-basictypes.xml">QML Basic Types</db:link> <db:link xlink:href="qml-enumeration.xml">enumeration</db:link> documentation.</db:para>
<db:para>The ability to declare enumerations in QML was introduced in Qt 5.10.</db:para>
</db:section>
</db:section>
</db:article>
