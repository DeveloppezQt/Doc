<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Building a reusable QML module</db:title>
<db:productname>QtCMake</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Using Qt with CMake</db:titleabbrev>
<db:extendedlink xlink:type="extended"><db:link xlink:to="cmake-build-qml-application.xml" xlink:type="arc" xlink:arcrole="prev" xlink:title="Building a QML application"/></db:extendedlink>
<db:extendedlink xlink:type="extended"><db:link xlink:to="cmake-build-on-cmdline.xml" xlink:type="arc" xlink:arcrole="next" xlink:title="Building projects on the command line"/></db:extendedlink>
<db:abstract>
<db:para>Using Qt with CMake.</db:para></db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The example below demonstrates how to create a library which exposes C++ to QML. The directory structure for the example looks like this:</db:para>
<db:programlisting language="cpp" role="bad">├── CMakeLists.txt
└── example
    └── mylib
        ├── CMakeLists.txt
        ├── mytype.cpp
        ├── mytype.h
</db:programlisting>
<db:para>The toplevel <db:code>CMakeLists.txt</db:code> file does some basic setup using <db:link xlink:href="qt-standard-project-setup.xml">qt_standard_project_setup</db:link>, and then uses <db:code>add_subdirectory</db:code> to include the one in mylib:</db:para>
<db:programlisting language="cpp">cmake_minimum_required(VERSION 3.16)

project(qmlmodule VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Qt6 REQUIRED COMPONENTS Qml)
qt_standard_project_setup(REQUIRES 6.5)

add_subdirectory(example/mylib)
</db:programlisting>
<db:para>The subdirectories are structured to correspond to the QML module’s URI, but with the dots replaced by slashes. That’s the same logic the engine uses when it searches for a module in the <db:link xlink:href="qtqml-syntax-imports.xml">import paths</db:link>. Following this subdirectory structure helps tooling.</db:para>
<db:para><db:code>mytype.h</db:code> declares a class and uses the <db:link xlink:href="qtqml-cppintegration-definetypes.xml#registering-c-types-with-the-qml-type-system">declarative registration macros</db:link> to expose it to the engine.</db:para>
<db:para>In the subdirectory’s <db:code>CMakeLists.txt</db:code> we call <db:link xlink:href="qt-add-qml-module.xml#qt6-add-qml-module">qt_add_qml_module</db:link>. Compared to <db:link xlink:href="cmake-build-qml-application.xml">Building a QML application</db:link>, the invocation is slightly different:</db:para>
<db:programlisting language="cpp">qt_add_qml_module(mylib
    URI example.mylib
    VERSION 1.0
    SOURCES
        mytype.h mytype.cpp
    QML_FILES
        MyQmlType.qml
)
</db:programlisting>
<db:para>The target for <db:code>mylib</db:code> has not been created before. When the target passed to <db:code>qt6_add_qml_module</db:code> does not exist, it automatically creates a library target. This avoids a separate call to <db:link xlink:href="qt-add-library.xml">qt_add_library</db:link>. To register QML types defined in C++, add their header and source files as arguments to the SOURCES parameter.</db:para>
<db:para>When the project is built, in addition to the library, a QML plugin is also built. The plugin's auto-generated class extends from <db:link xlink:href="qqmlengineextensionplugin.xml">QQmlEngineExtensionPlugin</db:link>. The mylib library itself already contains the code to register the types with the engine. However, that is only useful in cases where we can link against the library. To make the module usable in a QML file loaded by <db:code>qml</db:code>, the <db:link xlink:href="qtquick-qml-runtime.xml#qml-runtime-tool">QML Runtime Tool</db:link>, a plugin is needed that can be loaded. The plugin is then responsible for actually linking against the library, and ensuring that the types get registered.</db:para>
<db:para>Note that the automatic plugin generation is only possible if the module does not do anything besides registering the types. If it needs to do something more advanced like registering an image provider in <db:code>initializeEngine</db:code>, you still need to manually write the plugin. <db:link xlink:href="qt-add-qml-module.xml#qt6-add-qml-module">qt6_add_qml_module</db:link> has support for this with <db:code>NO_GENERATE_PLUGIN_SOURCE</db:code>.</db:para>
<db:para>Also, following the directory layout convention helps tooling. That layout is mirrored in the build directory. Which means that you can pass the path to your build directory to the QML tool (via the <db:code>-I</db:code> flag), and it will find the plugin.</db:para>
</db:article>
