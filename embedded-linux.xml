<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt for Embedded Linux</db:title>
<db:productname>QtDoc</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Provides information about Embedded Linux support in Qt.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Since the Qt 5.0 release, Qt no longer contains its own window system (QWS) implementation. For single-process use cases, the <db:link xlink:href="qpa.xml">Qt Platform Abstraction</db:link> is a superior solution. Multiple graphical processes can be supported through Wayland.</db:para>
<db:para>There are multiple platform plugins that are potentially usable on Embedded Linux systems: EGLFS, LinuxFB, KMS, DirectFB, Wayland. The availability of these depend on the configuration of Qt. The default platform plugin is also device-specific. For instance, on many boards <db:emphasis>eglfs</db:emphasis> is chosen as the default one. If the default is not suitable, the QT_QPA_PLATFORM environment variable parameter can be used to request another plugin. Alternatively, for quick tests, the -platform command-line can be used with the same syntax.</db:para>
<db:section xml:id="configuring-a-specific-device">
<db:title>Configuring a Specific Device</db:title>
<db:para>Building Qt for a given device requires a toolchain and a sysroot. Additionally, some devices require vendor-specific adaptation code for EGL and OpenGL ES 2.0 support. This is not relevant for non-accelerated platforms, for example the ones using the LinuxFB plugin, which is meant for software-based rendering only. This means Qt Quick 2 is not functional in such a setup as it depends on OpenGL for rendering.</db:para>
<db:para>The directory <db:emphasis>qtbase/mkspecs/devices</db:emphasis> contains configuration and graphics adaptation code for a number of devices. For example, the linux-rasp-pi2-g++ mkspec contains build settings such as the optimal compiler and linker flags for the <db:link xlink:href="http://www.raspberrypi.org">Raspberry Pi 2</db:link> device. The mkspec also contains information about either an implementation of the <db:emphasis>eglfs</db:emphasis> hooks (vendor-specific adaptation code), or a reference to the suitable <db:emphasis>eglfs</db:emphasis> device integration plugin. The device is selected through the <db:link xlink:href="configure-options.xml">configure</db:link> tool's -device parameter. The name that follows after this argument must, at least partially, match one of the subdirectories under <db:emphasis>devices</db:emphasis>.</db:para>
<db:para>The following is an example configuration for the Raspberry Pi 2. For most Embedded Linux boards, the configure command looks similar:</db:para>
<db:programlisting language="cpp" role="bad">./configure -release -opengl es2 -device linux-rasp-pi2-g++ -device-option CROSS_COMPILE=$TOOLCHAIN/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf- -sysroot $ROOTFS -prefix /usr/local/qt5
</db:programlisting>
<db:para>The most important parameters are -device and -sysroot. By specifying -sysroot, the include files and libraries used by configure's feature detection tests, as well as Qt itself, is taken from the specified location, instead of the host PC's standard locations. This means that installing development packages on the host machine has no relevance. For example, to get libinput support it is not sufficient or necessary to have the libinput development headers and libraries installed on the host environment. Instead, the headers and the libraries for the target architecture (e.g. ARM) must be present in the sysroot.</db:para>
<db:para>pkg-config is supported also when performing cross-compilation. configure automatically sets PKG_CONFIG_LIBDIR to make pkg-config report compiler and linker settings based on the sysroot instead of the host machine. This usually functions well without any further adjustments. However, environment variables such as PKG_CONFIG_PATH must be unset for the host machine before running configure. Otherwise, the Qt build may attempt to use inappropriate headers and libraries from the host system.</db:para>
<db:para>Specifying -sysroot results in automatically setting the --sysroot argument when invoking the compiler. In some cases this is not desirable and can be disabled by passing -no-gcc-sysroot to configure.</db:para>
<db:para>-prefix, -extprefix and -hostprefix control the intended destination directory of the Qt build. In the above example the ARM build of Qt is expected to be placed in /usr/local/qt5 on the target device. Note that running make install does not deploy anything to the device. Instead, the install step targets the directory specified by extprefix which defaults to sysroot + prefix and is therefore optional. However, in many cases &quot;polluting&quot; the sysroot is not desirable and thus specifying -extprefix becomes important. Finally, -hostprefix allows separating host tools like qmake, rcc, uic from the binaries for the target. When given, such tools will be installed under the specified directory instead of extprefix.</db:para>
<db:para>See <db:link xlink:href="configure-options.xml">Qt Configure Options</db:link> for more information.</db:para>
</db:section>
<db:section xml:id="platform-plugins-for-embedded-linux-devices">
<db:title>Platform Plugins for Embedded Linux Devices</db:title>
<db:section xml:id="eglfs">
<db:title>EGLFS</db:title>
<db:para><db:link xlink:href="http://www.khronos.org/egl">EGL</db:link> is an interface between OpenGL and the native windowing system. Qt can use EGL for context and surface management, however the API contains no platform-specifics: The creation of a <db:emphasis>native window</db:emphasis> (which will not necessarily be an actual window on the screen) must still be done by platform-specific means. Hence the need for the board or GPU-specific adaptation code. Such adaptations are provided either as <db:emphasis>eglfs hooks</db:emphasis>, which can be a single source file compiled into the platform plugin, or as dynamically loaded <db:emphasis>EGL device integration</db:emphasis> plugins.</db:para>
<db:para><db:emphasis>EGLFS</db:emphasis> is a platform plugin for running Qt5 applications on top of EGL and OpenGL ES 2.0 without an actual windowing system (like X11 or Wayland). In addition to Qt Quick 2 and native OpenGL applications, it supports software-rendered windows (for example <db:link xlink:href="qwidget.xml">QWidget</db:link>) too. In the latter case the widgets' contents are rendered using the CPU into images, which are then uploaded into textures and composited by the plugin.</db:para>
<db:para>This is the recommended plugin for modern Embedded Linux devices that include a GPU.</db:para>
<db:para><db:emphasis>EGLFS</db:emphasis> forces the first top-level window (be it either a <db:link xlink:href="qwidget.xml">QWidget</db:link> or a <db:link xlink:href="qquickview.xml">QQuickView</db:link>) to become fullscreen. This window is also chosen to be the <db:emphasis>root</db:emphasis> widget window into which all other top-level widgets (for example dialogs, popup menus or combobox dropdowns) are composited. This is necessary because with <db:emphasis>EGLFS</db:emphasis> there is always exactly one native window and EGL window surface, and these belong to the widget or window that is created first. This approach works well when there is a main window that exists for the entire lifetime of the application and all other widgets are either non top-levels or are created afterwards, once the main window is shown.</db:para>
<db:para>There are further restrictions for OpenGL-based windows. As of Qt 5.3, eglfs supports a single fullscreen GL window (for example, an OpenGL-based <db:link xlink:href="qwindow.xml">QWindow</db:link>, a <db:link xlink:href="qquickview.xml">QQuickView</db:link> or a QGLWidget). Opening additional OpenGL windows or mixing such windows with <db:link xlink:href="qwidget.xml">QWidget</db:link>-based content is not supported and terminates the application with an error message.</db:para>
<db:para>If necessary, eglfs can be configured using the following environment variables:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>QT_QPA_EGLFS_FB - Overrides the framebuffer device. The default is /dev/fb0. On most embedded platforms this is not very relevant because the framebuffer is used only for querying settings like the display dimensions. On certain devices however, this parameter provides the ability to specify the display to be used in multiple display setups, similarly to the fb parameter in LinuxFB.</db:para>
</db:listitem>
<db:listitem>
<db:para>QT_QPA_EGLFS_WIDTH and QT_QPA_EGLFS_HEIGHT - Contain the screen width and height in pixels. While eglfs tries to determine the dimensions from the framebuffer device <db:emphasis>/dev/fb0</db:emphasis>, but this does not work always and manually specifying the sizes may become necessary.</db:para>
</db:listitem>
<db:listitem>
<db:para>QT_QPA_EGLFS_PHYSICAL_WIDTH and QT_QPA_EGLFS_PHYSICAL_HEIGHT - Physical screen width and height in millimeters. On platforms where the framebuffer device <db:emphasis>/dev/fb0</db:emphasis> is not available or the query is not successful, the values are calculated based on a default DPI of 100. This variable can be used to override any such defaults.</db:para>
</db:listitem>
<db:listitem>
<db:para>QT_QPA_EGLFS_DEPTH - Overrides the color depth for the screen. On platforms where the framebuffer device <db:emphasis>/dev/fb0</db:emphasis> is not available or the query is not successful, the default of 32 is used. This variable can be used to override any such defaults. Note that this affects only the color depth value reported by <db:link xlink:href="qscreen.xml">QScreen</db:link>. It has no connection to EGL configurations and the color depth used for OpenGL rendering.</db:para>
</db:listitem>
<db:listitem>
<db:para>QT_QPA_EGLFS_SWAPINTERVAL - By default a swap interval of 1 will be requested. This enables synchronizing to the displays vertical refresh. The value can be overridden with this environment variable. For instance, passing 0 will disable blocking on swap, resulting in running as fast as possible without any synchronization.</db:para>
</db:listitem>
<db:listitem>
<db:para>QT_QPA_EGLFS_FORCEVSYNC - When set, eglfs requests FBIO_WAITFORVSYNC on the framebuffer device.</db:para>
</db:listitem>
<db:listitem>
<db:para>QT_QPA_EGLFS_FORCE888 - When set, the red, green, and blue color channel sizes are ignored whenever creating a new context, window or offscreen surface. Instead, the plugin requests a configuration with 8 bits per channel. This can be helpful on devices where configurations with less than 32 or 24 bits per pixel are chosen by default but are known to be not suitable, for example, due to banding effects. Instead of changing all the applications, this variable provides an easier shortcut to force 24/32 bpp configurations for a given device.</db:para>
</db:listitem>
<db:listitem>
<db:para>QT_QPA_EGLFS_DEBUG - When set, some debugging information is printed on the debug output. For example, the input <db:link xlink:href="qsurfaceformat.xml">QSurfaceFormat</db:link> and the properties of the chosen EGL configuration are printed while creating a new context. Together with Qt Quick's QSG_INFO variable, this can provide useful information for troubleshooting issues related to the EGL configuration.</db:para>
</db:listitem>
<db:listitem>
<db:para>QT_QPA_EGLFS_INTEGRATION - In addition to the compiled-in <db:emphasis>hooks</db:emphasis>, it is also possible to provide device or vendor-specific adaptation in the form of dynamically loaded plugins. This environment variable enforces a specific plugin. For example, setting it to <db:emphasis>eglfs_kms</db:emphasis> uses the KMS/DRM backend. This is only an option when no static or compiled-in hooks were specified in the device makespecs. In practice, the traditional compiled-in hooks are rarely used, almost all backends are now migrated to plugins. The device makespecs still contain a relevant EGLFS_DEVICE_INTEGRATION entry: the name of the preferred backend for that particular device. This is optional, but very useful to avoid the need to set this environment variable in case there are more than one plugins present in the target system. In a desktop environment the KMS or X11 backends are prioritized, depending on the presence of the DISPLAY environment variable. Note that on some boards the special value of none is used instead of an actual plugin. This indicates that no special integration is necessary to use EGL with the framebuffer and so no plugins must be loaded.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In addition to QT_QPA_EGLFS_DEBUG, eglfs also supports the more modern categorized logging system of Qt. The following logging categories are available:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>qt.qpa.egldeviceintegration – Enables logging for dynamically loaded backends. Very useful to check what backend is in use.</db:para>
</db:listitem>
<db:listitem>
<db:para>qt.qpa.input – Enables debug output both from the evdev and libinput input handlers. Very useful to check if a given input device was recognized and opened.</db:para>
</db:listitem>
<db:listitem>
<db:para>qt.qpa.eglfs.kms – Enables verbose logging in the KMS/DRM backend.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="linuxfb">
<db:title>LinuxFB</db:title>
<db:para>This plugin writes directly to the framebuffer. Only software-rendered content is supported. Note that on some setups the display performance is expected to be limited.</db:para>
<db:para>The linuxfb plugin allows specifying additional settings by passing them in the QT_QPA_PLATFORM environment variable or -platform command-line option. For example, QT_QPA_PLATFORM=linuxfb:fb=/dev/fb1 specifies that the framebuffer device /dev/fb1 must be used instead of the default fb0. Multiple settings can be specified by separating them with a colon.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>fb=/dev/fbN - Specifies the framebuffer devices. On multiple display setups this typically allows running the application on different displays. For the time being there is no way to use multiple framebuffers from one Qt application.</db:para>
</db:listitem>
<db:listitem>
<db:para>size=<db:emphasis>&lt;width&gt;</db:emphasis>x<db:emphasis>&lt;height&gt;</db:emphasis> - Specifies the screen size in pixels. The plugin tries to query the display dimensions, both physical and logical, from the framebuffer device. This may not always lead to proper results however, and therefore it may become necessary to explicitly specify the values.</db:para>
</db:listitem>
<db:listitem>
<db:para>mmsize=<db:emphasis>&lt;width&gt;</db:emphasis>x<db:emphasis>&lt;height&gt;</db:emphasis> - Physical width and height in millimeters.</db:para>
</db:listitem>
<db:listitem>
<db:para>offset=<db:emphasis>&lt;width&gt;</db:emphasis>x<db:emphasis>&lt;height&gt;</db:emphasis> - Offset in pixels specifying the top-left corner of the screen. The default position is at (0, 0).</db:para>
</db:listitem>
<db:listitem>
<db:para>nographicsmodeswitch - Do not switch the virtual terminal to graphics mode (KD_GRAPHICS). In addition to switching to graphics mode, the blinking cursor and screen blanking are normally disabled too. When this parameter is set, these are also skipped.</db:para>
</db:listitem>
<db:listitem>
<db:para>tty=/dev/ttyN - Overrides the virtual console. Only used when nographicsmodeswitch is not set.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="input">
<db:title>Input</db:title>
<db:para>When no windowing system is present, the mouse, keyboard, and touch input are read directly via evdev or using helper libraries such as libinput or tslib. Note that this requires that device nodes /dev/input/event* are readable by the user. eglfs and linuxfb have all the input handling code compiled-in.</db:para>
<db:section xml:id="using-libinput">
<db:title>Using libinput</db:title>
<db:para><db:link xlink:href="http://www.freedesktop.org/wiki/Software/libinput">libinput</db:link> is a library to handle input devices. It offers an alternative to the Qt's own evdev input support. To enable using libinput, make sure the development files for libudev and libinput are available when configuring and building Qt. xkbcommon is also necessary if keyboard support is desired. With eglfs and linuxfb no further actions are necessary as these plugins use libinput by default. If libinput support is not available or the environment variable QT_QPA_EGLFS_NO_LIBINPUT is set, Qt's own evdev handlers come in to play.</db:para>
</db:section>
<db:section xml:id="input-on-eglfs-and-linuxfb-without-libinput">
<db:title>Input on eglfs and linuxfb without libinput</db:title>
<db:para>Parameters like the device node name can be set in the environment variables QT_QPA_EVDEV_MOUSE_PARAMETERS, QT_QPA_EVDEV_KEYBOARD_PARAMETERS and QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS. Additionally, the built-in input handlers can be disabled by setting QT_QPA_EGLFS_DISABLE_INPUT or QT_QPA_FB_DISABLE_INPUT to 1. On some touch screens the coordinates must be rotated, which is done by setting QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS to rotate=180.</db:para>
</db:section>
<db:section xml:id="mouse">
<db:title>Mouse</db:title>
<db:para>The mouse cursor shows up whenever QT_QPA_EGLFS_HIDECURSOR (for eglfs) or QT_QPA_FB_HIDECURSOR (for linuxfb) is not set and Qt's libudev-based device discovery reports that at least one mouse is available. When libudev support is not present, the mouse cursor always show up unless explicitly disabled via the environment variable.</db:para>
<db:para>Hot plugging is supported, but only if Qt was configured with libudev support (that is, if the <db:emphasis>libudev</db:emphasis> development headers are present in the sysroot at configure time). This allows connecting or disconnecting an input device while the application is running.</db:para>
</db:section>
<db:section xml:id="keyboard">
<db:title>Keyboard</db:title>
<db:para>The <db:emphasis>evdev</db:emphasis> keyboard handler supports the following extra parameters:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>/dev/input/... - Specifies the name of the input device. When not given, Qt looks for a suitable device either via <db:emphasis>libudev</db:emphasis> or by walking through the available nodes.</db:para>
</db:listitem>
<db:listitem>
<db:para>grab - Enables grabbing the input device.</db:para>
</db:listitem>
<db:listitem>
<db:para>keymap - Specifies the name of a custom keyboard map file.</db:para>
</db:listitem>
<db:listitem>
<db:para>enable-compose - Enables compositing.</db:para>
</db:listitem>
<db:listitem>
<db:para>repeat-delay - Sets a custom key repeat delay.</db:para>
</db:listitem>
<db:listitem>
<db:para>repeat-rate - Sets a custom key repeat rate.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>On Embedded Linux systems that do not have their terminal sessions disabled, the behavior on a key press can be confusing as input event is processed by the Qt application and the tty. To overcome this, the following options are available:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:emphasis>EGLFS</db:emphasis> and <db:emphasis>LinuxFB</db:emphasis> attempt to disable the terminal keyboard on application startup by setting the tty's keyboard mode to K_OFF. This prevents keystrokes from going to the terminal. If the standard behavior needs to be restored for some reason, set the environment variable QT_QPA_ENABLE_TERMINAL_KEYBOARD to 1. Note that this works only when the application is launched from a remote console (for example, via ssh) and the terminal keyboard input remains enabled.</db:para>
</db:listitem>
<db:listitem>
<db:para>An alternative approach is to use the <db:emphasis>evdev</db:emphasis> keyboard handler's grab parameter by passing <db:emphasis>grab=1</db:emphasis> in QT_QPA_EVDEV_KEYBOARD_PARAMETERS. This results in trying to get a grab on the input device. If the grab is successful, no other components in the system receive events from it as long as the Qt application is running. This approach is more suitable for applications started remotely as it does not need access to the tty device.</db:para>
</db:listitem>
<db:listitem>
<db:para>Finally, for many specialized Embedded Linux images it does not make sense to have the standard terminal sessions enabled in the first place. Refer to your build environment's documentation on how to disable them. For example, when generating images using the <db:link xlink:href="http://www.yoctoproject.org">Yocto Project</db:link>, unsetting SYSVINIT_ENABLED_GETTYS results in having no getty process running, and thus no input, on any of the virtual terminals.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>If the default built-in keymap is not sufficient, a different one can be specified either via the keymap parameter or by using the eglfs-specific <db:link xlink:href="qeglfsfunctions.xml#loadKeymap">loadKeymap</db:link>() function. The latter allows switching the keymap at runtime. Note however that this requires using eglfs' built-in keyboard handler; it is not supported when the keyboard handler is loaded via the -plugin command-line parameter.</db:para>
<db:note>
<db:para>Special system key combinations, such as console switching (<db:emphasis>Ctrl+Alt+Fx</db:emphasis>) or zap (<db:emphasis>Ctrl+Alt+Backspace</db:emphasis>) are not currently supported and are ignored.</db:para>
</db:note>
<db:para>To generate a custom keymap, the <db:emphasis>kmap2qmap</db:emphasis> utility can be used. This can be found in the <db:emphasis>qttools</db:emphasis> module. The source files have to be in standard Linux kmap format, which is understood by the kernel's loadkeys command. This means one can use the following sources to generate qmap files:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The <db:link xlink:href="http://lct.sourceforge.net/">Linux Console Tools (LCT)</db:link> project.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="http://www.x.org/">Xorg</db:link> X11 keymaps can be converted to the kmap format with the ckbcomp utility.</db:para>
</db:listitem>
<db:listitem>
<db:para>As kmap files are plain-text files, they can also be hand crafted.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>kmap2qmap is a command line program, that needs at least 2 files as parameters. The last one is the generated .qmap file, while all the others are parsed as input .kmap files. For example:</db:para>
<db:programlisting language="cpp" role="bad">kmap2qmap i386/qwertz/de-latin1-nodeadkeys.kmap include/compose.latin1.inc de-latin1-nodeadkeys.qmap
</db:programlisting>
<db:note>
<db:para>kmap2qmap does not support all the (pseudo) symbols that the Linux kernel supports. When converting a standard keymap, a number of warnings will be shown regarding Show_Registers, Hex_A, and so on; these messages can safely be ignored.</db:para>
</db:note>
</db:section>
<db:section xml:id="touch">
<db:title>Touch</db:title>
<db:para>For some resistive, single-touch touch screens it may be necessary to fall back to using tslib instead of relying on the Linux multi-touch protocol and the event devices. For modern touch screens this is not necessary. tslib support can be enabled by setting the environment variable QT_QPA_EGLFS_TSLIB or QT_QPA_FB_TSLIB to 1. To change the device, set the environment variable TSLIB_TSDEVICE or pass the device name on the command-line. Note that the tslib input handler generates mouse events and supports single touch only, as opposed to evdevtouch which generates true multi-touch <db:link xlink:href="qtouchevent.xml">QTouchEvent</db:link> events too.</db:para>
</db:section>
<db:section xml:id="pen-based-tablets">
<db:title>Pen-based tablets</db:title>
<db:para>The evdevtablet plugin provides basic support for Wacom and similar, pen-based tablets. It generates <db:link xlink:href="qtabletevent.xml">QTabletEvent</db:link> events only. To enable it, pass QT_QPA_GENERIC_PLUGINS=evdevtablet in the environment or, alternatively, pass -plugin evdevtablet argument on the command-line. The plugin can take a device node parameter, for example QT_QPA_GENERIC_PLUGINS=evdevtablet:/dev/event1, in case the Qt's automatic device discovery (based either on <db:emphasis>libudev</db:emphasis> or a walkthrough of /dev/input/event*) is not functional or misbehaving.</db:para>
</db:section>
<db:section xml:id="debugging-input-devices">
<db:title>Debugging Input Devices</db:title>
<db:para>It is possible to print some information to the debug output by enabling the qt.qpa.input logging rule, for example by setting the QT_LOGGING_RULES environment variable to qt.qpa.input=true. This is useful for detecting which device is being used, or to troubleshoot device discovery issues.</db:para>
</db:section>
<db:section xml:id="using-custom-mouse-cursor-images">
<db:title>Using Custom Mouse Cursor Images</db:title>
<db:para>eglfs comes with its own set of 32x32 sized mouse cursor images. If these are not sufficient, a custom cursor atlas can be provided by setting the QT_QPA_EGLFS_CURSOR environment variable to the name of a JSON file. The file can also be embedded into the application via Qt's resource system.</db:para>
<db:para>For example, an embedded cursor atlas with 8 cursor images per row can be specified like the following:</db:para>
<db:programlisting language="cpp" role="bad">{
  &quot;image&quot;: &quot;:/cursor-atlas.png&quot;,
  &quot;cursorsPerRow&quot;: 8,
  &quot;hotSpots&quot;: [
      [7, 2],
      [12, 3],
      [12, 12],
      ...
  ]
}
</db:programlisting>
<db:para>Note that the images are expected to be tightly packed in the atlas: the width and height of the cursors are decided based on the total image size and the cursorsPerRow setting. Atlases have to provide an image for all the supported cursors.</db:para>
</db:section>
</db:section>
<db:section xml:id="display-output">
<db:title>Display Output</db:title>
<db:para>When having multiple displays connected, the level of support for targeting one or more of these from one single Qt application varies between the platform plugins and often depends on the device and its graphics stack.</db:para>
<db:section xml:id="eglfs-with-eglfs-kms-backend">
<db:title>eglfs with eglfs_kms backend</db:title>
<db:para>When the KMS/DRM backend is in use, eglfs reports all available screens in <db:link xlink:href="qguiapplication.xml#screens">QGuiApplication::screens</db:link>(). Applications can target different screens with different windows via <db:link xlink:href="qwindow.xml#setScreen">QWindow::setScreen</db:link>(). Note however that the restriction of one single fullscreen window per screen still applies.</db:para>
<db:para>When getting started with developing on a given embedded device, it is often necessary to verify the behavior of the device and drivers, and that the connected displays are working as they should. One easy way is to use the hellowindow example. Launching it with -platform eglfs --multiscreen --timeout arguments shows a rotating Qt logo on each connected screen for a few seconds.</db:para>
<db:para>The KMS/DRM backend also supports custom configurations via a JSON file. Set the environment variable QT_QPA_EGLFS_KMS_CONFIG to the name of the file to enable this. The file can also be embedded into the application via the Qt resource system. An example configuration is below:</db:para>
<db:programlisting language="cpp" role="bad">{
  &quot;device&quot;: &quot;/dev/dri/card1&quot;,
  &quot;hwcursor&quot;: false,
  &quot;pbuffers&quot;: true,
  &quot;outputs&quot;: [
    {
      &quot;name&quot;: &quot;VGA1&quot;,
      &quot;mode&quot;: &quot;off&quot;
    },
    {
      &quot;name&quot;: &quot;HDMI1&quot;,
      &quot;mode&quot;: &quot;1024x768&quot;
    }
  ]
}
</db:programlisting>
<db:para>Here we configure the specified device so that</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>it will not use the hardware cursor (falls back to rendering the mouse cursor via OpenGL; by default hardware cursors are enabled as they are more efficient),</db:para>
</db:listitem>
<db:listitem>
<db:para>it will back <db:link xlink:href="qoffscreensurface.xml">QOffscreenSurface</db:link> with standard EGL pbuffer surfaces (by default this is disabled and a gbm surface is used instead),</db:para>
</db:listitem>
<db:listitem>
<db:para>output on the VGA connector is disabled, while HDMI is active with a resolution of 1024x768.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Additionally, such a configuration also disables looking for a device via libudev and instead the specified device is used.</db:para>
<db:para>For troubleshooting it might be useful to enable debug logs from the KMS/DRM backend. To do this, enable the categorized logging rule, qt.qpa.eglfs.kms.</db:para>
</db:section>
<db:section xml:id="eglfs-with-eglfs-kms-egldevice-backend">
<db:title>eglfs with eglfs_kms_egldevice backend</db:title>
<db:para>This backend, typically used on Tegra devices, is similar to the KMS/DRM backend mentioned above, except that it relies on the EGLDevice and EGLStream extensions instead of GBM.</db:para>
<db:para>For technical details about this approach, check out <db:link xlink:href="https://wiki.qt.io/Qt_for_Embedded_Linux/XDC2014RitgerEGLNonMesa">this presentation</db:link>.</db:para>
<db:para>As of Qt 5.7 this backend shares many of its internal implementation with the GBM-based backend. This means that multiple screens and the advanced configuration via QT_QPA_EGLFS_KMS_CONFIG are supported. Some settings, like hardware cursors, may not be applicable however.</db:para>
<db:para>By default the backend will find the first available display and pick the EGL layer that corresponds to it. When necessary, this can be overridden by setting the QT_QPA_EGLFS_LAYER_INDEX environment variable to the index of the desired layer. To see which layers are available, and to debug potential startup issues, enable the logging category qt.qpa.eglfs.kms. In some cases it may be necessary to perform a video mode set on application startup even when the screen reports that the desired resolution is already set. This is normally optimized away, but if the screen stays powered down, try setting the environment variable QT_QPA_EGLFS_ALWAYS_SET_MODE to a non-zero value and relaunch the application.</db:para>
</db:section>
<db:section xml:id="eglfs-with-other-backends">
<db:title>eglfs with other backends</db:title>
<db:para>Other backends, that are typically based on targeting the framebuffer or a composition API directly via the vendor's EGL implementation, usually provide limited or no support for multiple displays. On i.MX6-based boards with Vivante GPUs the QT_QPA_EGLFS_FB environment variable can be used to specify the framebuffer to target, similarly to linuxfb. On the Raspberry Pi the QT_QPA_EGLFS_DISPMANX_ID environment variable can be used to specify the screen to output to. The value corresponds to one of the DISPMANX_ID_ constants, refer to the Dispmanx documentation. Note that these approaches, unlike KMS/DRM, will not typically allow to output to multiple screens from the same application. Alternatively, driver-specific environment variables or kernel parameters may also be available as well to control the used framebuffer. Refer to the embedded board's documentation.</db:para>
</db:section>
<db:section xml:id="video-memory">
<db:title>Video Memory</db:title>
<db:para>Systems with a fixed amount of dedicated video memory may need extra care before running Qt application based on Qt Quick or classes like <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link>. The default setting may be insufficient for such applications, especially when they are displayed on a high resolution (for example, full HD) screen. In this case, they may start failing in unexpected ways. It is recommended to ensure that there is at least 128 MB of GPU memory available. For systems that do not have a fixed amount of memory reserved for the GPU this is not an issue.</db:para>
</db:section>
<db:section xml:id="display-output-linuxfb-18">
<db:title>linuxfb</db:title>
<db:para>Use the fb plugin parameter to specify the framebuffer device to use.</db:para>
</db:section>
</db:section>
<db:section xml:id="unix-signal-handlers">
<db:title>Unix Signal Handlers</db:title>
<db:para>The console-oriented platform plugins like eglfs and linuxfb install signal handlers by default to capture interrupt (SIGINT), suspend and continue (SIGTSTP, SIGCONT) and termination (SIGTERM). This way the keyboard, terminal cursor, and possibly other graphics state can be restored when the application terminates or gets suspended due to kill, or Ctrl+C or Ctrl+Z. (although terminating or suspending via the keyboard is only possible when QT_QPA_ENABLE_TERMINAL_KEYBOARD is set, as outlined above in the Input section). However, in some cases capturing SIGINT can be undesirable as it may conflict with remote debugging for instance. Therefore, the environment variable QT_QPA_NO_SIGNAL_HANDLER is provided to opt out from all built-in signal handling.</db:para>
</db:section>
<db:section xml:id="fonts">
<db:title>Fonts</db:title>
<db:para>Qt normally uses fontconfig to provide access to system fonts. If fontconfig is not available, Qt will fall back to using QBasicFontDatabase. In this case, Qt applications will look for fonts in Qt's lib/fonts directory. Qt will automatically detect pre-rendered fonts and TrueType fonts. This directory can be overridden by setting the QT_QPA_FONTDIR environment variable.</db:para>
<db:para>For more information on the supported formats, see <db:link xlink:href="qt-embedded-fonts.xml">Qt for Embedded Linux Fonts</db:link>.</db:para>
<db:note>
<db:para>Qt no longer ships any fonts in the lib/fonts directory. This means that it is up to the platform (the system image) to provide the necessary fonts.</db:para>
</db:note>
</db:section>
<db:section xml:id="platform-plugins-for-windowing-systems-on-embedded-linux-devices">
<db:title>Platform Plugins for Windowing Systems on Embedded Linux Devices</db:title>
<db:section xml:id="xcb">
<db:title>XCB</db:title>
<db:para>This is the X11 plugin used on regular desktop Linux platforms. In some embedded environments, that provide X and the necessary development files for <db:link xlink:href="http://xcb.freedesktop.org">xcb</db:link>, this plugin functions just like it does on a regular PC desktop.</db:para>
<db:note>
<db:para>On some devices there is no EGL and OpenGL support available under X because the EGL implementation is not compatible with Xlib. In this case the XCB plugin is built without EGL support, meaning that Qt Quick 2 or other OpenGL-based applications does not work with this platform plugin. It can still be used however to run software-rendered applications (based on <db:link xlink:href="qwidget.xml">QWidget</db:link> for example).</db:para>
</db:note>
<db:para>As a general rule, the usage of XCB on embedded devices is not advisable. Plugins like eglfs are likely to provide better performance, and hardware acceleration.</db:para>
</db:section>
<db:section xml:id="wayland">
<db:title>Wayland</db:title>
<db:para><db:link xlink:href="http://wayland.freedesktop.org/">Wayland</db:link> is a light-weight windowing system; or more precisely, it is a protocol for clients to talk to a display server.</db:para>
<db:para>The Qt Wayland module provides a wayland platform plugin that allows Qt application to connect to a Wayland compositor.</db:para>
<db:note>
<db:para>You may experience issues with touch screen input while using the <db:link xlink:href="http://wayland.freedesktop.org/">Weston</db:link> reference compositor. Refer to the <db:link xlink:href="https://wiki.qt.io/WestonTouchScreenIssues">Qt Wiki</db:link> for further information.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="related-topics">
<db:title>Related Topics</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="http://doc.qt.io/QtForDeviceCreation">Qt for Device Creation</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="http://doc.qt.io/emulator/index.html">Emulator</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtvirtualkeyboard-index.xml">Qt Virtual Keyboard</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:article>
