<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Using the Meta-Object Compiler (moc)</db:title>
<db:productname>QtDoc</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Reference Documentation.</db:para></db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The Meta-Object Compiler, <db:code>moc</db:code>, is the program that handles <db:link xlink:href="metaobjects.xml">Qt's C++ extensions</db:link>.</db:para>
<db:para>The <db:code>moc</db:code> tool reads a C++ header file. If it finds one or more class declarations that contain the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro, it produces a C++ source file containing the meta-object code for those classes. Among other things, meta-object code is required for the signals and slots mechanism, the run-time type information, and the dynamic property system.</db:para>
<db:para>The C++ source file generated by <db:code>moc</db:code> must be compiled and linked with the implementation of the class.</db:para>
<db:para>If you use <db:link xlink:href="qmake-manual.xml">qmake</db:link> to create your makefiles, build rules will be included that call the moc when required, so you will not need to use the moc directly. For more background information on <db:code>moc</db:code>, see <db:link xlink:href="why-moc.xml">Why Does Qt Use Moc for Signals and Slots?</db:link></db:para>
<db:section xml:id="usage">
<db:title>Usage</db:title>
<db:para><db:code>moc</db:code> is typically used with an input file containing class declarations like this:</db:para>
<db:programlisting language="cpp">class MyClass : public QObject
{
    Q_OBJECT

public:
    MyClass(QObject *parent = 0);
    ~MyClass();

signals:
    void mySignal();

public slots:
    void mySlot();
};
</db:programlisting>
<db:para>In addition to the signals and slots shown above, <db:code>moc</db:code> also implements object properties as in the next example. The <db:link xlink:href="qobject.xml#Q_PROPERTY">Q_PROPERTY</db:link>() macro declares an object property, while <db:link xlink:href="qobject.xml#Q_ENUM">Q_ENUM</db:link>() declares a list of enumeration types within the class to be usable inside the <db:link xlink:href="properties.xml">property system</db:link>.</db:para>
<db:para>In the following example, we declare a property of the enumeration type <db:code>Priority</db:code> that is also called <db:code>priority</db:code> and has a get function <db:code>priority()</db:code> and a set function <db:code>setPriority()</db:code>.</db:para>
<db:programlisting language="cpp">class MyClass : public QObject
{
    Q_OBJECT
    Q_PROPERTY(Priority priority READ priority WRITE setPriority)
    Q_ENUMS(Priority)

public:
    enum Priority { High, Low, VeryHigh, VeryLow };

    MyClass(QObject *parent = 0);
    ~MyClass();

    void setPriority(Priority priority) { m_priority = priority; }
    Priority priority() const { return m_priority; }

private:
    Priority m_priority;
};
</db:programlisting>
<db:para>The Q_FLAGS() macro declares enums that are to be used as flags, i.e. OR'd together. Another macro, <db:link xlink:href="qobject.xml#Q_CLASSINFO">Q_CLASSINFO</db:link>(), allows you to attach additional name/value pairs to the class's meta-object:</db:para>
<db:programlisting language="cpp">class MyClass : public QObject
{
    Q_OBJECT
    Q_CLASSINFO(&quot;Author&quot;, &quot;Oscar Peterson&quot;)
    Q_CLASSINFO(&quot;Status&quot;, &quot;Active&quot;)

public:
    MyClass(QObject *parent = 0);
    ~MyClass();
};
</db:programlisting>
<db:para>The output produced by <db:code>moc</db:code> must be compiled and linked, just like the other C++ code in your program; otherwise, the build will fail in the final link phase. If you use <db:code>qmake</db:code>, this is done automatically. Whenever <db:code>qmake</db:code> is run, it parses the project's header files and generates make rules to invoke <db:code>moc</db:code> for those files that contain a <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro.</db:para>
<db:para>If the class declaration is found in the file <db:code>myclass.h</db:code>, the moc output should be put in a file called <db:code>moc_myclass.cpp</db:code>. This file should then be compiled as usual, resulting in an object file, e.g., <db:code>moc_myclass.obj</db:code> on Windows. This object should then be included in the list of object files that are linked together in the final building phase of the program.</db:para>
</db:section>
<db:section xml:id="writing-make-rules-for-invoking-moc">
<db:title>Writing Make Rules for Invoking <db:code>moc</db:code></db:title>
<db:para>For anything but the simplest test programs, it is recommended that you automate running the <db:code>moc</db:code>. By adding some rules to your program's makefile, <db:code>make</db:code> can take care of running moc when necessary and handling the moc output.</db:para>
<db:para>We recommend using the <db:link xlink:href="qmake-manual.xml">qmake</db:link> makefile generation tool for building your makefiles. This tool generates a makefile that does all the necessary <db:code>moc</db:code> handling.</db:para>
<db:para>If you want to create your makefiles yourself, here are some tips on how to include moc handling.</db:para>
<db:para>For <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> class declarations in header files, here is a useful makefile rule if you only use GNU make:</db:para>
<db:programlisting language="cpp">moc_%.cpp: %.h
        moc $(DEFINES) $(INCPATH) $&amp;lt; -o $@
</db:programlisting>
<db:para>If you want to write portably, you can use individual rules of the following form:</db:para>
<db:programlisting language="cpp">moc_foo.cpp: foo.h
        moc $(DEFINES) $(INCPATH) $&amp;lt; -o $@
</db:programlisting>
<db:para>You must also remember to add <db:code>moc_foo.cpp</db:code> to your <db:code>SOURCES</db:code> (substitute your favorite name) variable and <db:code>moc_foo.o</db:code> or <db:code>moc_foo.obj</db:code> to your <db:code>OBJECTS</db:code> variable.</db:para>
<db:para>Both examples assume that <db:code>$(DEFINES)</db:code> and <db:code>$(INCPATH)</db:code> expand to the define and include path options that are passed to the C++ compiler. These are required by <db:code>moc</db:code> to preprocess the source files.</db:para>
<db:para>While we prefer to name our C++ source files <db:code>.cpp</db:code>, you can use any other extension, such as <db:code>.C</db:code>, <db:code>.cc</db:code>, <db:code>.CC</db:code>, <db:code>.cxx</db:code>, and <db:code>.c++</db:code>, if you prefer.</db:para>
<db:para>For <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> class declarations in implementation (<db:code>.cpp</db:code>) files, we suggest a makefile rule like this:</db:para>
<db:programlisting language="cpp">foo.o: foo.moc

foo.moc: foo.cpp
        moc $(DEFINES) $(INCPATH) -i $&amp;lt; -o $@
</db:programlisting>
<db:para>This guarantees that make will run the moc before it compiles <db:code>foo.cpp</db:code>. You can then put</db:para>
<db:programlisting language="cpp">#include &quot;foo.moc&quot;
</db:programlisting>
<db:para>at the end of <db:code>foo.cpp</db:code>, where all the classes declared in that file are fully known.</db:para>
</db:section>
<db:section xml:id="command-line-options">
<db:title>Command-Line Options</db:title>
<db:para>Here are the command-line options supported by the moc:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Option</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:code>-o&lt;file&gt;</db:code></db:para>
</db:td>
<db:td>
<db:para>Write output to <db:code>&lt;file&gt;</db:code> rather than to standard output.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-f[&lt;file&gt;]</db:code></db:para>
</db:td>
<db:td>
<db:para>Force the generation of an <db:code>#include</db:code> statement in the output. This is the default for header files whose extension starts with <db:code>H</db:code> or <db:code>h</db:code>. This option is useful if you have header files that do not follow the standard naming conventions. The <db:code>&lt;file&gt;</db:code> part is optional.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-i</db:code></db:para>
</db:td>
<db:td>
<db:para>Do not generate an <db:code>#include</db:code> statement in the output. This may be used to run the moc on on a C++ file containing one or more class declarations. You should then <db:code>#include</db:code> the meta-object code in the <db:code>.cpp</db:code> file.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-nw</db:code></db:para>
</db:td>
<db:td>
<db:para>Do not generate any warnings. (Not recommended.)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-p&lt;path&gt;</db:code></db:para>
</db:td>
<db:td>
<db:para>Makes the moc prepend <db:code>&lt;path&gt;/</db:code> to the file name in the generated <db:code>#include</db:code> statement.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-I&lt;dir&gt;</db:code></db:para>
</db:td>
<db:td>
<db:para>Add dir to the include path for header files.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-E</db:code></db:para>
</db:td>
<db:td>
<db:para>Preprocess only; do not generate meta-object code.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-D&lt;macro&gt;[=&lt;def&gt;]</db:code></db:para>
</db:td>
<db:td>
<db:para>Define macro, with optional definition.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-U&lt;macro&gt;</db:code></db:para>
</db:td>
<db:td>
<db:para>Undefine macro.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-M&lt;key=value&gt;</db:code></db:para>
</db:td>
<db:td>
<db:para>Append additional meta data to plugins. If a class has <db:link xlink:href="qtplugin.xml#Q_PLUGIN_METADATA">Q_PLUGIN_METADATA</db:link> specified, the key-value pair will be added to its meta data. This will end up in the Json object that gets resolved for the plugin at run time (accessible from <db:link xlink:href="qpluginloader.xml">QPluginLoader</db:link>). This argument is typically used for tagging static plugins with information resolved by the build system.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>@&lt;file&gt;</db:code></db:para>
</db:td>
<db:td>
<db:para>Read additional command-line options from <db:code>&lt;file&gt;</db:code>. Each line of the file is treated as a single option. Empty lines are ignored. Note that this option is not supported within the options file itself (i.e. an options file can't &quot;include&quot; another file).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-h</db:code></db:para>
</db:td>
<db:td>
<db:para>Display the usage and the list of options.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-v</db:code></db:para>
</db:td>
<db:td>
<db:para>Display <db:code>moc</db:code>'s version number.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:code>-Fdir</db:code></db:para>
</db:td>
<db:td>
<db:para>macOS. Add the framework directory <db:code>dir</db:code> to the head of the list of directories to be searched for header files. These directories are interleaved with those specified by -I options and are scanned in a left-to-right order (see the manpage for gcc). Normally, use -F /Library/Frameworks/</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>You can explicitly tell the moc not to parse parts of a header file. <db:code>moc</db:code> defines the preprocessor symbol <db:code>Q_MOC_RUN</db:code>. Any code surrounded by</db:para>
<db:programlisting language="cpp">#ifndef Q_MOC_RUN
    ...
#endif
</db:programlisting>
<db:para>is skipped by the <db:code>moc</db:code>.</db:para>
</db:section>
<db:section xml:id="diagnostics">
<db:title>Diagnostics</db:title>
<db:para><db:code>moc</db:code> will warn you about a number of dangerous or illegal constructs in the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> class declarations.</db:para>
<db:para>If you get linkage errors in the final building phase of your program, saying that <db:code>YourClass::className()</db:code> is undefined or that <db:code>YourClass</db:code> lacks a vtable, something has been done wrong. Most often, you have forgotten to compile or <db:code>#include</db:code> the moc-generated C++ code, or (in the former case) include that object file in the link command. If you use <db:code>qmake</db:code>, try rerunning it to update your makefile. This should do the trick.</db:para>
</db:section>
<db:section xml:id="limitations">
<db:title>Limitations</db:title>
<db:para><db:code>moc</db:code> does not handle all of C++. The main problem is that class templates cannot have the <db:link xlink:href="qobject.xml#Q_OBJECT">Q_OBJECT</db:link> macro. Here is an example:</db:para>
<db:programlisting language="cpp">class SomeTemplate&amp;lt;int&amp;gt; : public QFrame
{
    Q_OBJECT
    ...

signals:
    void mySignal(int);
};
</db:programlisting>
<db:para>The following constructs are illegal. All of them have alternatives which we think are usually better, so removing these limitations is not a high priority for us.</db:para>
<db:section xml:id="multiple-inheritance-requires-qobject-to-be-first">
<db:title>Multiple Inheritance Requires QObject to Be First</db:title>
<db:para>If you are using multiple inheritance, <db:code>moc</db:code> assumes that the first inherited class is a subclass of <db:link xlink:href="qobject.xml">QObject</db:link>. Also, be sure that only the first inherited class is a <db:link xlink:href="qobject.xml">QObject</db:link>.</db:para>
<db:programlisting language="cpp">// correct
class SomeClass : public QObject, public OtherClass
{
    ...
};
</db:programlisting>
<db:para>Virtual inheritance with <db:link xlink:href="qobject.xml">QObject</db:link> is <db:emphasis>not</db:emphasis> supported.</db:para>
</db:section>
<db:section xml:id="function-pointers-cannot-be-signal-or-slot-parameters">
<db:title>Function Pointers Cannot Be Signal or Slot Parameters</db:title>
<db:para>In most cases where you would consider using function pointers as signal or slot parameters, we think inheritance is a better alternative. Here is an example of illegal syntax:</db:para>
<db:programlisting language="cpp">class SomeClass : public QObject
{
    Q_OBJECT

public slots:
    void apply(void (*apply)(List *, void *), char *); // WRONG
};
</db:programlisting>
<db:para>You can work around this restriction like this:</db:para>
<db:programlisting language="cpp">typedef void (*ApplyFunction)(List *, void *);

class SomeClass : public QObject
{
    Q_OBJECT

public slots:
    void apply(ApplyFunction, char *);
};
</db:programlisting>
<db:para>It may sometimes be even better to replace the function pointer with inheritance and virtual functions.</db:para>
</db:section>
<db:section xml:id="enums-and-typedefs-must-be-fully-qualified-for-signal-and-slot-parameters">
<db:title>Enums and Typedefs Must Be Fully Qualified for Signal and Slot Parameters</db:title>
<db:para>When checking the signatures of its arguments, <db:link xlink:href="qobject.xml#connect">QObject::connect</db:link>() compares the data types literally. Thus, <db:link xlink:href="qt.xml#AlignmentFlag-enum">Alignment</db:link> and <db:link xlink:href="qt.xml#AlignmentFlag-enum">Qt::Alignment</db:link> are treated as two distinct types. To work around this limitation, make sure to fully qualify the data types when declaring signals and slots, and when establishing connections. For example:</db:para>
<db:programlisting language="cpp">class MyClass : public QObject
{
    Q_OBJECT

    enum Error {
        ConnectionRefused,
        RemoteHostClosed,
        UnknownError
    };

signals:
    void stateChanged(MyClass::Error error);
};
</db:programlisting>
</db:section>
<db:section xml:id="nested-classes-cannot-have-signals-or-slots">
<db:title>Nested Classes Cannot Have Signals or Slots</db:title>
<db:para>Here's an example of the offending construct:</db:para>
<db:programlisting language="cpp">class A
{
public:
    class B
    {
        Q_OBJECT

    public slots:   // WRONG
        void b();
    };
};
</db:programlisting>
</db:section>
<db:section xml:id="signal-slot-return-types-cannot-be-references">
<db:title>Signal/Slot return types cannot be references</db:title>
<db:para>Signals and slots can have return types, but signals or slots returning references will be treated as returning void.</db:para>
</db:section>
<db:section xml:id="only-signals-and-slots-may-appear-in-the-keyword-signals-keyword-and-keyword-slots-keyword-sections-of-a-class">
<db:title>Only Signals and Slots May Appear in the <db:code>signals</db:code> and <db:code>slots</db:code> Sections of a Class</db:title>
<db:para><db:code>moc</db:code> will complain if you try to put other constructs in the <db:code>signals</db:code> or <db:code>slots</db:code> sections of a class than signals and slots.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="metaobjects.xml">Meta-Object System</db:link></db:member>
<db:member><db:link xlink:href="signalsandslots.xml">Signals and Slots</db:link></db:member>
<db:member><db:link xlink:href="properties.xml">Qt's Property System</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
