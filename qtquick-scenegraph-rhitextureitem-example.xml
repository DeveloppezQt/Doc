<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Scene Graph - RHI Texture Item</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Shows how to implement a custom <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> that displays a <db:link xlink:href="qrhi.xml">QRhi</db:link>-rendered texture.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/rhitextureitem-example.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:para>This example shows how to implement an item that performs cross-platform, portable 3D rendering into a texture using the <db:link xlink:href="qrhi.xml">QRhi</db:link> APIs and then displays that image.</db:para>
<db:note>
<db:para>This example demonstrates advanced, low-level functionality performing portable, cross-platform 3D rendering, while relying on APIs with limited compatibility guarantee from the Qt Gui module. To be able to use the <db:link xlink:href="qrhi.xml">QRhi</db:link> APIs, the application links to <db:code>Qt::GuiPrivate</db:code> and includes <db:code>&lt;rhi/qrhi.h&gt;</db:code>.</db:para>
</db:note>
<db:section xml:id="comparison-with-other-approaches">
<db:title>Comparison with other approaches</db:title>
<db:para>The <db:link xlink:href="qtquick-scenegraph-rhiunderqml-example.xml">RHI Under QML</db:link> example shows how to implement portable, cross-platform 3D rendering with the <db:link xlink:href="qrhi.xml">QRhi</db:link> APIs in a manner where the custom rendering is issued before the Qt Quick scene graph's own rendering, effectively providing an &quot;underlay&quot;. That approach is efficient since now additional render targets and render passes are needed, the custom rendering is injected in the main render pass before the scene graph's own draw calls.</db:para>
<db:para>In contrast, this example involves a separate render target, a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>, the dimensions of which match the <db:link xlink:href="qquickitem.xml">QQuickItem</db:link>'s size in the scene, and a whole render pass that is used to clear and then draw into that texture. The texture is then sampled in the main render pass and is used to texture a quad, effectively displaying a 2D image.</db:para>
<db:para>Compared to the underlay/overlay approach, this allows displaying, blending, and transforming the flattened 2D image of the 3D rendering anywhere in the Qt Quick scene since here we have a true <db:link xlink:href="qquickitem.xml">QQuickItem</db:link>. This comes at the expense of being more expensive in terms of resources and performance since it involves rendering to a texture first.</db:para>
</db:section>
<db:section xml:id="overview">
<db:title>Overview</db:title>
<db:para>The example is implemented using <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> and <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link>. <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> is a convenience class that can be subclassed to easily and quickly get a fully featured, custom <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> that displays the contents of a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> by using <db:link xlink:href="qsgsimpletexturenode.xml">QSGSimpleTextureNode</db:link> under the hood. The contents of the texture is generated by the application-provided logic implemented in its <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link> subclass.</db:para>
<db:para><db:code>ExampleRhiItem</db:code> is a <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> subclass that offers a few properties, such as <db:code>angle</db:code> and <db:code>backgroundAlpha</db:code>. These are going to be read, written, and animated from QML. In order to support Qt Quick's threaded rendering model, the QQQuickRhiItemRenderer has a virtual <db:link xlink:href="qquickrhiitemrenderer.xml#synchronize">synchronize</db:link>() function that can be reimplemented to safely perform copying of data between the <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> (belonging to the main/GUI thread) and the <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link> (belonging to the render thread, if there is one).</db:para>
<db:programlisting language="cpp">QQuickRhiItemRenderer *ExampleRhiItem::createRenderer()
{
    return new ExampleRhiItemRenderer;
}

void ExampleRhiItem::setAngle(float a)
{
    if (m_angle == a)
        return;

    m_angle = a;
    emit angleChanged();
    update();
}

void ExampleRhiItem::setBackgroundAlpha(float a)
{
    if (m_alpha == a)
        return;

    m_alpha = a;
    emit backgroundAlphaChanged();
    update();
}

void ExampleRhiItemRenderer::synchronize(QQuickRhiItem *rhiItem)
{
    ExampleRhiItem *item = static_cast&lt;ExampleRhiItem *&gt;(rhiItem);
    if (item-&gt;angle() != m_angle)
        m_angle = item-&gt;angle();
    if (item-&gt;backgroundAlpha() != m_alpha)
        m_alpha = item-&gt;backgroundAlpha();
}
</db:programlisting>
<db:para><db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>() is called at least once before the first call to render(), but may in practice be invoked multiple times: if the <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> geometry changes (due to some layout change, resizing the window, etc.), if <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> setting such as the sample count and texture format change, or if the item is reparented so that is belong to a new <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link>, these all trigger calling initialize() again because they imply that one or more of the resources <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link>-managed resources change, which is going to have implications on the subclass as well. The example code here is prepared to handle these special situations (changing <db:link xlink:href="qrhi.xml">QRhi</db:link>, changing sample count, changing texture format). (as it does not hold on to the texture used as the color buffer, the case when the texture is recreated due to a different size needs no special handling)</db:para>
<db:programlisting language="cpp">void ExampleRhiItemRenderer::initialize(QRhiCommandBuffer *cb)
{
    if (m_rhi != rhi()) {
        m_rhi = rhi();
        m_pipeline.reset();
    }

    if (m_sampleCount != renderTarget()-&gt;sampleCount()) {
        m_sampleCount = renderTarget()-&gt;sampleCount();
        m_pipeline.reset();
    }

    QRhiTexture *finalTex = m_sampleCount &gt; 1 ? resolveTexture() : colorTexture();
    if (m_textureFormat != finalTex-&gt;format()) {
        m_textureFormat = finalTex-&gt;format();
        m_pipeline.reset();
    }
</db:programlisting>
<db:para>The rest if initialize() is straightforward <db:link xlink:href="qrhi.xml">QRhi</db:link>-based code.</db:para>
<db:para>The 3D scene uses a perspective projection, which is calculated based on the output size, queried from the <db:link xlink:href="qrhirendertarget.xml">QRhiRenderTarget</db:link> for convenience (because this works regardless of using multisampling or not, whereas accessing <db:link xlink:href="qquickrhiitemrenderer.xml#colorTexture">colorTexture</db:link>() and <db:link xlink:href="qquickrhiitemrenderer.xml#msaaColorBuffer">msaaColorBuffer</db:link>() would need branching logic based on which of the objects happens to be valid)</db:para>
<db:para>Note the usage of <db:link xlink:href="qrhi.xml#clipSpaceCorrMatrix">QRhi::clipSpaceCorrMatrix</db:link>() to cater for the coordinate system differences between 3D graphics APIs.</db:para>
<db:programlisting language="cpp">    if (!m_pipeline) {
        m_vbuf.reset(m_rhi-&gt;newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertexData)));
        m_vbuf-&gt;create();

        m_ubuf.reset(m_rhi-&gt;newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, 64));
        m_ubuf-&gt;create();

        m_srb.reset(m_rhi-&gt;newShaderResourceBindings());
        m_srb-&gt;setBindings({
            QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, m_ubuf.get()),
        });
        m_srb-&gt;create();

        m_pipeline.reset(m_rhi-&gt;newGraphicsPipeline());
        m_pipeline-&gt;setShaderStages({
           { QRhiShaderStage::Vertex, getShader(QLatin1String(&quot;:/scenegraph/rhitextureitem/shaders/color.vert.qsb&quot;)) },
           { QRhiShaderStage::Fragment, getShader(QLatin1String(&quot;:/scenegraph/rhitextureitem/shaders/color.frag.qsb&quot;)) }
        });
        QRhiVertexInputLayout inputLayout;
        inputLayout.setBindings({
            { 5 * sizeof(float) }
        });
        inputLayout.setAttributes({
            { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
            { 0, 1, QRhiVertexInputAttribute::Float3, 2 * sizeof(float) }
        });
        m_pipeline-&gt;setSampleCount(m_sampleCount);
        m_pipeline-&gt;setVertexInputLayout(inputLayout);
        m_pipeline-&gt;setShaderResourceBindings(m_srb.get());
        m_pipeline-&gt;setRenderPassDescriptor(renderTarget()-&gt;renderPassDescriptor());
        m_pipeline-&gt;create();

        QRhiResourceUpdateBatch *resourceUpdates = m_rhi-&gt;nextResourceUpdateBatch();
        resourceUpdates-&gt;uploadStaticBuffer(m_vbuf.get(), vertexData);
        cb-&gt;resourceUpdate(resourceUpdates);
    }

    const QSize outputSize = renderTarget()-&gt;pixelSize();
    m_viewProjection = m_rhi-&gt;clipSpaceCorrMatrix();
    m_viewProjection.perspective(45.0f, outputSize.width() / (float) outputSize.height(), 0.01f, 1000.0f);
    m_viewProjection.translate(0, 0, -4);
</db:programlisting>
<db:para>The implementation of <db:link xlink:href="qquickrhiitemrenderer.xml#render">render</db:link>() records the drawing of a single triangle. The uniform buffer with the 4x4 matrix is updated every time since we expect the rotation angle to change. The clear color has the item-provided background alpha baked in. Remember the need to premultiply the alpha value in the red, green, and blue components as well.</db:para>
<db:programlisting language="cpp">void ExampleRhiItemRenderer::render(QRhiCommandBuffer *cb)
{
    QRhiResourceUpdateBatch *resourceUpdates = m_rhi-&gt;nextResourceUpdateBatch();
    QMatrix4x4 modelViewProjection = m_viewProjection;
    modelViewProjection.rotate(m_angle, 0, 1, 0);
    resourceUpdates-&gt;updateDynamicBuffer(m_ubuf.get(), 0, 64, modelViewProjection.constData());

    // Qt Quick expects premultiplied alpha
    const QColor clearColor = QColor::fromRgbF(0.5f * m_alpha, 0.5f * m_alpha, 0.7f * m_alpha, m_alpha);
    cb-&gt;beginPass(renderTarget(), clearColor, { 1.0f, 0 }, resourceUpdates);

    cb-&gt;setGraphicsPipeline(m_pipeline.get());
    const QSize outputSize = renderTarget()-&gt;pixelSize();
    cb-&gt;setViewport(QRhiViewport(0, 0, outputSize.width(), outputSize.height()));
    cb-&gt;setShaderResources();
    const QRhiCommandBuffer::VertexInput vbufBinding(m_vbuf.get(), 0);
    cb-&gt;setVertexInput(0, 1, &amp;vbufBinding);
    cb-&gt;draw(3);

    cb-&gt;endPass();
}
</db:programlisting>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtdeclarative.git/tree/examples/quick/scenegraph/rhitextureitem?h=6.9">Example project @ code.qt.io</db:link></db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link></db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-rhiunderqml-example.xml">Scene Graph - RHI Under QML</db:link></db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-customrendernode-example.xml">Scene Graph - Custom QSGRenderNode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
