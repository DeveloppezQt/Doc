<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QAtomicInteger Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QAtomicInteger</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.0.4 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> class provides platform-independent atomic operations on integers.</db:para>
<db:para>This class was introduced in Qt 5.3.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QAtomicInteger</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.3</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qatomicint.xml" xlink:role="class">QAtomicInt</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QAtomicInteger is part of <db:simplelist><db:member>thread</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>For atomic operations on pointers, see the <db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link> class.</db:para>
<db:para>An <db:emphasis>atomic</db:emphasis> operation is a complex operation that completes without interruption. The <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> class provides atomic reference counting, test-and-set, fetch-and-store, and fetch-and-add for integers.</db:para>
<db:para>The template parameter <db:code>T</db:code> must be a C++ integer type:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>8-bit: char, signed char, unsigned char, qint8, quint8</db:para>
</db:listitem>
<db:listitem>
<db:para>16-bit: short, unsigned short, qint16, quint16, char16_t (C++11)</db:para>
</db:listitem>
<db:listitem>
<db:para>32-bit: int, unsigned int, qint32, quint32, char32_t (C++11)</db:para>
</db:listitem>
<db:listitem>
<db:para>64-bit: long long, unsigned long long, qint64, quint64</db:para>
</db:listitem>
<db:listitem>
<db:para>platform-specific size: long, unsigned long</db:para>
</db:listitem>
<db:listitem>
<db:para>pointer size: qintptr, quintptr, qptrdiff</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Of the list above, only the 32-bit- and pointer-sized instantiations are guaranteed to work on all platforms. Support for other sizes depends on the compiler and processor architecture the code is being compiled for. To test whether the other types are supported, check the macro <db:code>Q_ATOMIC_INT\e{nn}_IS_SUPPORTED</db:code>, where <db:code>\e{nn}</db:code> is the number of bits desired.</db:para>
<db:section xml:id="the-atomic-api">
<db:title>The Atomic API</db:title>
<db:section xml:id="reference-counting">
<db:title>Reference counting</db:title>
<db:para>The <db:link xlink:href="qatomicinteger.xml#ref">ref</db:link>() and <db:link xlink:href="qatomicinteger.xml#deref">deref</db:link>() functions provide an efficient reference counting API. The return value of these functions are used to indicate when the last reference has been released. These functions allow you to implement your own implicitly shared classes.</db:para>
<db:programlisting language="cpp">MySharedType &amp;amp;MySharedType::operator=(const MySharedType &amp;amp;other)
{
    (void) other.data-&amp;gt;atomicInt.ref();
    if (!data-&amp;gt;atomicInt.deref()) {
        // The last reference has been released
        delete d;
    }
    d = other.d;
    return *this;
}
</db:programlisting>
</db:section>
<db:section xml:id="memory-ordering">
<db:title>Memory ordering</db:title>
<db:para><db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> provides several implementations of the atomic test-and-set, fetch-and-store, and fetch-and-add functions. Each implementation defines a memory ordering semantic that describes how memory accesses surrounding the atomic instruction are executed by the processor. Since many modern architectures allow out-of-order execution and memory ordering, using the correct semantic is necessary to ensure that your application functions properly on all processors.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Relaxed - memory ordering is unspecified, leaving the compiler and processor to freely reorder memory accesses.</db:para>
</db:listitem>
<db:listitem>
<db:para>Acquire - memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
</db:listitem>
<db:listitem>
<db:para>Release - memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
</db:listitem>
<db:listitem>
<db:para>Ordered - the same Acquire and Release semantics combined.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="test-and-set">
<db:title>Test-and-set</db:title>
<db:para>If the current value of the <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> is an expected value, the test-and-set functions assign a new value to the <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and return true. If values are <db:code role="parameter">not</db:code> the same, these functions do nothing and return false. This operation equates to the following code:</db:para>
<db:programlisting language="cpp">if (currentValue == expectedValue) {
    currentValue = newValue;
    return true;
}
return false;
</db:programlisting>
<db:para>There are 4 test-and-set functions: <db:link xlink:href="qatomicinteger.xml#testAndSetRelaxed">testAndSetRelaxed</db:link>(), <db:link xlink:href="qatomicinteger.xml#testAndSetAcquire">testAndSetAcquire</db:link>(), <db:link xlink:href="qatomicinteger.xml#testAndSetRelease">testAndSetRelease</db:link>(), and <db:link xlink:href="qatomicinteger.xml#testAndSetOrdered">testAndSetOrdered</db:link>(). See above for an explanation of the different memory ordering semantics.</db:para>
</db:section>
<db:section xml:id="fetch-and-store">
<db:title>Fetch-and-store</db:title>
<db:para>The atomic fetch-and-store functions read the current value of the <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then assign a new value, returning the original value. This operation equates to the following code:</db:para>
<db:programlisting language="cpp">int originalValue = currentValue;
currentValue = newValue;
return originalValue;
</db:programlisting>
<db:para>There are 4 fetch-and-store functions: <db:link xlink:href="qatomicinteger.xml#fetchAndStoreRelaxed">fetchAndStoreRelaxed</db:link>(), <db:link xlink:href="qatomicinteger.xml#fetchAndStoreAcquire">fetchAndStoreAcquire</db:link>(), <db:link xlink:href="qatomicinteger.xml#fetchAndStoreRelease">fetchAndStoreRelease</db:link>(), and <db:link xlink:href="qatomicinteger.xml#fetchAndStoreOrdered">fetchAndStoreOrdered</db:link>(). See above for an explanation of the different memory ordering semantics.</db:para>
</db:section>
<db:section xml:id="fetch-and-add">
<db:title>Fetch-and-add</db:title>
<db:para>The atomic fetch-and-add functions read the current value of the <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then add the given value to the current value, returning the original value. This operation equates to the following code:</db:para>
<db:programlisting language="cpp">int originalValue = currentValue;
currentValue += valueToAdd;
return originalValue;
</db:programlisting>
<db:para>There are 4 fetch-and-add functions: <db:link xlink:href="qatomicinteger.xml#fetchAndAddRelaxed">fetchAndAddRelaxed</db:link>(), <db:link xlink:href="qatomicinteger.xml#fetchAndAddAcquire">fetchAndAddAcquire</db:link>(), <db:link xlink:href="qatomicinteger.xml#fetchAndAddRelease">fetchAndAddRelease</db:link>(), and <db:link xlink:href="qatomicinteger.xml#fetchAndAddOrdered">fetchAndAddOrdered</db:link>(). See above for an explanation of the different memory ordering semantics.</db:para>
</db:section>
</db:section>
<db:section xml:id="feature-tests-for-the-atomic-api">
<db:title>Feature Tests for the Atomic API</db:title>
<db:para>Providing a platform-independent atomic API that works on all processors is challenging. The API provided by <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> is guaranteed to work atomically on all processors. However, since not all processors implement support for every operation provided by <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>, it is necessary to expose information about the processor.</db:para>
<db:para>You can check at compile time which features are supported on your hardware using various macros. These will tell you if your hardware always, sometimes, or does not support a particular operation. The macros have the form Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_<db:emphasis>OPERATION</db:emphasis>_IS_<db:emphasis>HOW</db:emphasis>_NATIVE. <db:emphasis>nn</db:emphasis> is the size of the integer (in bits), <db:emphasis>OPERATION</db:emphasis> is one of <db:link xlink:href="qatomicinteger.xml#reference-counting">REFERENCE_COUNTING</db:link>, <db:link xlink:href="qatomicpointer.xml#test-and-set">TEST_AND_SET</db:link>, <db:link xlink:href="qatomicpointer.xml#fetch-and-store">FETCH_AND_STORE</db:link>, or <db:link xlink:href="qatomicpointer.xml#fetch-and-add">FETCH_AND_ADD</db:link>, and <db:emphasis>HOW</db:emphasis> is one of ALWAYS, SOMETIMES, or NOT. There will always be exactly one defined macro per operation. For example, if Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_ALWAYS_NATIVE is defined, neither Q_ATOMIC_INT_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE nor Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_NOT_NATIVE will be defined.</db:para>
<db:para>An operation that completes in constant time is said to be wait-free. Such operations are not implemented using locks or loops of any kind. For atomic operations that are always supported, and that are wait-free, Qt defines the Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_<db:emphasis>OPERATION</db:emphasis>_IS_WAIT_FREE in addition to the Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_<db:emphasis>OPERATION</db:emphasis>_IS_ALWAYS_NATIVE.</db:para>
<db:para>In cases where an atomic operation is only supported in newer generations of the processor, <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> also provides a way to check at runtime what your hardware supports with the <db:link xlink:href="qatomicinteger.xml#isReferenceCountingNative">isReferenceCountingNative</db:link>(), <db:link xlink:href="qatomicinteger.xml#isTestAndSetNative">isTestAndSetNative</db:link>(), <db:link xlink:href="qatomicinteger.xml#isFetchAndStoreNative">isFetchAndStoreNative</db:link>(), and <db:link xlink:href="qatomicinteger.xml#isFetchAndAddNative">isFetchAndAddNative</db:link>() functions. Wait-free implementations can be detected using the <db:link xlink:href="qatomicinteger.xml#isReferenceCountingWaitFree">isReferenceCountingWaitFree</db:link>(), <db:link xlink:href="qatomicinteger.xml#isTestAndSetWaitFree">isTestAndSetWaitFree</db:link>(), <db:link xlink:href="qatomicinteger.xml#isFetchAndStoreWaitFree">isFetchAndStoreWaitFree</db:link>(), and <db:link xlink:href="qatomicinteger.xml#isFetchAndAddWaitFree">isFetchAndAddWaitFree</db:link>() functions.</db:para>
<db:para>Below is a complete list of all feature macros for <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_REFERENCE_COUNTING_IS_ALWAYS_NATIVE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_REFERENCE_COUNTING_IS_NOT_NATIVE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_REFERENCE_COUNTING_IS_WAIT_FREE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_TEST_AND_SET_IS_ALWAYS_NATIVE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_TEST_AND_SET_IS_SOMETIMES_NATIVE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_TEST_AND_SET_IS_NOT_NATIVE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_TEST_AND_SET_IS_WAIT_FREE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_FETCH_AND_STORE_IS_NOT_NATIVE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_FETCH_AND_STORE_IS_WAIT_FREE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_FETCH_AND_ADD_IS_NOT_NATIVE</db:para>
</db:listitem>
<db:listitem>
<db:para>Q_ATOMIC_INT<db:emphasis>nn</db:emphasis>_FETCH_AND_ADD_IS_WAIT_FREE</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For compatibility with previous versions of Qt, macros with an empty <db:emphasis>nn</db:emphasis> are equivalent to the 32-bit macros. For example, Q_ATOMIC_INT_REFERENCE_COUNTING_IS_WAIT_FREE is the same as Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_WAIT_FREE.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicpointer.xml">QAtomicPointer</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QAtomicInteger">
<db:title>QAtomicInteger::QAtomicInteger(T <db:emphasis>value</db:emphasis> = 0)</db:title>
<db:constructorsynopsis>
<db:methodname>QAtomicInteger</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>value</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QAtomicInteger(T value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> with the given <db:code role="parameter">value</db:code>.</db:para>
</db:section>
<db:section xml:id="QAtomicInteger-1">
<db:title>QAtomicInteger::QAtomicInteger(const QAtomicInteger&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QAtomicInteger</db:methodname>
<db:methodparam>
<db:type>const QAtomicInteger&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QAtomicInteger(const QAtomicInteger&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
</db:section>
<db:section xml:id="deref">
<db:title>bool QAtomicInteger::deref()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>deref</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool deref()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically decrements the value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>. Returns <db:code>true</db:code> if the new value is non-zero, false otherwise.</db:para>
<db:para>This function uses <db:emphasis>ordered</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#ref">ref</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#operator--">operator--</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndAddAcquire">
<db:title>T QAtomicInteger::fetchAndAddAcquire(T <db:emphasis>valueToAdd</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndAddAcquire</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToAdd</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndAddAcquire(T valueToAdd)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-add.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then adds <db:code role="parameter">valueToAdd</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>acquire</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-2b-eq">operator+=</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndSubAcquire">fetchAndSubAcquire</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndAddOrdered">
<db:title>T QAtomicInteger::fetchAndAddOrdered(T <db:emphasis>valueToAdd</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndAddOrdered</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToAdd</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndAddOrdered(T valueToAdd)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-add.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then adds <db:code role="parameter">valueToAdd</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>ordered</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-2b-eq">operator+=</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndSubOrdered">fetchAndSubOrdered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndAddRelaxed">
<db:title>T QAtomicInteger::fetchAndAddRelaxed(T <db:emphasis>valueToAdd</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndAddRelaxed</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToAdd</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndAddRelaxed(T valueToAdd)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-add.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then adds <db:code role="parameter">valueToAdd</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>relaxed</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, leaving the compiler and processor to freely reorder memory accesses.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-2b-eq">operator+=</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndSubRelaxed">fetchAndSubRelaxed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndAddRelease">
<db:title>T QAtomicInteger::fetchAndAddRelease(T <db:emphasis>valueToAdd</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndAddRelease</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToAdd</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndAddRelease(T valueToAdd)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-add.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then adds <db:code role="parameter">valueToAdd</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>release</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-2b-eq">operator+=</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndSubRelease">fetchAndSubRelease</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndAndAcquire">
<db:title>[since 5.3] T QAtomicInteger::fetchAndAndAcquire(T <db:emphasis>valueToAnd</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndAndAcquire</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToAnd</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndAndAcquire(T valueToAnd)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-and.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-ANDs <db:code role="parameter">valueToAnd</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>acquire</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-and-eq">operator&amp;=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndAndOrdered">
<db:title>[since 5.3] T QAtomicInteger::fetchAndAndOrdered(T <db:emphasis>valueToAnd</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndAndOrdered</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToAnd</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndAndOrdered(T valueToAnd)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-and.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-ANDs <db:code role="parameter">valueToAnd</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>ordered</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-and-eq">operator&amp;=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndAndRelaxed">
<db:title>[since 5.3] T QAtomicInteger::fetchAndAndRelaxed(T <db:emphasis>valueToAnd</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndAndRelaxed</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToAnd</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndAndRelaxed(T valueToAnd)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-and.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-ANDs <db:code role="parameter">valueToAnd</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>relaxed</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, leaving the compiler and processor to freely reorder memory accesses.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-and-eq">operator&amp;=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndAndRelease">
<db:title>[since 5.3] T QAtomicInteger::fetchAndAndRelease(T <db:emphasis>valueToAnd</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndAndRelease</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToAnd</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndAndRelease(T valueToAnd)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-and.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-ANDs <db:code role="parameter">valueToAnd</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>release</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-and-eq">operator&amp;=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndOrAcquire">
<db:title>[since 5.3] T QAtomicInteger::fetchAndOrAcquire(T <db:emphasis>valueToOr</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndOrAcquire</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToOr</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndOrAcquire(T valueToOr)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-or.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-ORs <db:code role="parameter">valueToOr</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>acquire</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-7c-eq">operator|=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndOrOrdered">
<db:title>[since 5.3] T QAtomicInteger::fetchAndOrOrdered(T <db:emphasis>valueToOr</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndOrOrdered</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToOr</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndOrOrdered(T valueToOr)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-or.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-ORs <db:code role="parameter">valueToOr</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>ordered</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-7c-eq">operator|=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndOrRelaxed">
<db:title>[since 5.3] T QAtomicInteger::fetchAndOrRelaxed(T <db:emphasis>valueToOr</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndOrRelaxed</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToOr</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndOrRelaxed(T valueToOr)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-or.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-ORs <db:code role="parameter">valueToOr</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>relaxed</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, leaving the compiler and processor to freely reorder memory accesses.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-7c-eq">operator|=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndOrRelease">
<db:title>[since 5.3] T QAtomicInteger::fetchAndOrRelease(T <db:emphasis>valueToOr</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndOrRelease</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToOr</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndOrRelease(T valueToOr)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-or.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-ORs <db:code role="parameter">valueToOr</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>release</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-7c-eq">operator|=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndStoreAcquire">
<db:title>T QAtomicInteger::fetchAndStoreAcquire(T <db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndStoreAcquire</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndStoreAcquire(T newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-store.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then assigns it the <db:code role="parameter">newValue</db:code>, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>acquire</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
</db:section>
<db:section xml:id="fetchAndStoreOrdered">
<db:title>T QAtomicInteger::fetchAndStoreOrdered(T <db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndStoreOrdered</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndStoreOrdered(T newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-store.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then assigns it the <db:code role="parameter">newValue</db:code>, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>ordered</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</db:para>
</db:section>
<db:section xml:id="fetchAndStoreRelaxed">
<db:title>T QAtomicInteger::fetchAndStoreRelaxed(T <db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndStoreRelaxed</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndStoreRelaxed(T newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-store.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then assigns it the <db:code role="parameter">newValue</db:code>, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>relaxed</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, leaving the compiler and processor to freely reorder memory accesses.</db:para>
</db:section>
<db:section xml:id="fetchAndStoreRelease">
<db:title>T QAtomicInteger::fetchAndStoreRelease(T <db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndStoreRelease</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndStoreRelease(T newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-store.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then assigns it the <db:code role="parameter">newValue</db:code>, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>release</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
</db:section>
<db:section xml:id="fetchAndSubAcquire">
<db:title>[since 5.3] T QAtomicInteger::fetchAndSubAcquire(T <db:emphasis>valueToSub</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndSubAcquire</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToSub</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndSubAcquire(T valueToSub)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-sub.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then subtracts <db:code role="parameter">valueToSub</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>acquire</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator--eq">operator-=</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndAddAcquire">fetchAndAddAcquire</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndSubOrdered">
<db:title>[since 5.3] T QAtomicInteger::fetchAndSubOrdered(T <db:emphasis>valueToSub</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndSubOrdered</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToSub</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndSubOrdered(T valueToSub)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-sub.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then subtracts <db:code role="parameter">valueToSub</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>ordered</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator--eq">operator-=</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndAddOrdered">fetchAndAddOrdered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndSubRelaxed">
<db:title>[since 5.3] T QAtomicInteger::fetchAndSubRelaxed(T <db:emphasis>valueToSub</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndSubRelaxed</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToSub</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndSubRelaxed(T valueToSub)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-sub.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then subtracts <db:code role="parameter">valueToSub</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>relaxed</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, leaving the compiler and processor to freely reorder memory accesses.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator--eq">operator-=</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndAddRelaxed">fetchAndAddRelaxed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndSubRelease">
<db:title>[since 5.3] T QAtomicInteger::fetchAndSubRelease(T <db:emphasis>valueToSub</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndSubRelease</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToSub</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndSubRelease(T valueToSub)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-sub.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then subtracts <db:code role="parameter">valueToSub</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>release</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator--eq">operator-=</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndAddRelease">fetchAndAddRelease</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndXorAcquire">
<db:title>[since 5.3] T QAtomicInteger::fetchAndXorAcquire(T <db:emphasis>valueToXor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndXorAcquire</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToXor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndXorAcquire(T valueToXor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-xor.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-XORs <db:code role="parameter">valueToXor</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>acquire</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-5e-eq">operator^=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndXorOrdered">
<db:title>[since 5.3] T QAtomicInteger::fetchAndXorOrdered(T <db:emphasis>valueToXor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndXorOrdered</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToXor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndXorOrdered(T valueToXor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-xor.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-XORs <db:code role="parameter">valueToXor</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>ordered</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-5e-eq">operator^=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndXorRelaxed">
<db:title>[since 5.3] T QAtomicInteger::fetchAndXorRelaxed(T <db:emphasis>valueToXor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndXorRelaxed</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToXor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndXorRelaxed(T valueToXor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-xor.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-XORs <db:code role="parameter">valueToXor</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>relaxed</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, leaving the compiler and processor to freely reorder memory accesses.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-5e-eq">operator^=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fetchAndXorRelease">
<db:title>[since 5.3] T QAtomicInteger::fetchAndXorRelease(T <db:emphasis>valueToXor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>fetchAndXorRelease</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>valueToXor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T fetchAndXorRelease(T valueToXor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic fetch-and-xor.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-XORs <db:code role="parameter">valueToXor</db:code> to the current value, returning the original value.</db:para>
<db:para>This function uses <db:emphasis>release</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#operator-5e-eq">operator^=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isFetchAndAddNative">
<db:title>[static constexpr] bool QAtomicInteger::isFetchAndAddNative()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFetchAndAddNative</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFetchAndAddNative()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if fetch-and-add is implemented using atomic processor instructions, false otherwise.</db:para>
</db:section>
<db:section xml:id="isFetchAndAddWaitFree">
<db:title>[static constexpr] bool QAtomicInteger::isFetchAndAddWaitFree()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFetchAndAddWaitFree</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFetchAndAddWaitFree()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if atomic fetch-and-add is wait-free, false otherwise.</db:para>
</db:section>
<db:section xml:id="isFetchAndStoreNative">
<db:title>[static constexpr] bool QAtomicInteger::isFetchAndStoreNative()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFetchAndStoreNative</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFetchAndStoreNative()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if fetch-and-store is implemented using atomic processor instructions, false otherwise.</db:para>
</db:section>
<db:section xml:id="isFetchAndStoreWaitFree">
<db:title>[static constexpr] bool QAtomicInteger::isFetchAndStoreWaitFree()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFetchAndStoreWaitFree</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFetchAndStoreWaitFree()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if atomic fetch-and-store is wait-free, false otherwise.</db:para>
</db:section>
<db:section xml:id="isReferenceCountingNative">
<db:title>[static constexpr] bool QAtomicInteger::isReferenceCountingNative()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isReferenceCountingNative</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isReferenceCountingNative()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if reference counting is implemented using atomic processor instructions, false otherwise.</db:para>
</db:section>
<db:section xml:id="isReferenceCountingWaitFree">
<db:title>[static constexpr] bool QAtomicInteger::isReferenceCountingWaitFree()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isReferenceCountingWaitFree</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isReferenceCountingWaitFree()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if atomic reference counting is wait-free, false otherwise.</db:para>
</db:section>
<db:section xml:id="isTestAndSetNative">
<db:title>[static constexpr] bool QAtomicInteger::isTestAndSetNative()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isTestAndSetNative</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isTestAndSetNative()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if test-and-set is implemented using atomic processor instructions, false otherwise.</db:para>
</db:section>
<db:section xml:id="isTestAndSetWaitFree">
<db:title>[static constexpr] bool QAtomicInteger::isTestAndSetWaitFree()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isTestAndSetWaitFree</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isTestAndSetWaitFree()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if atomic test-and-set is wait-free, false otherwise.</db:para>
</db:section>
<db:section xml:id="loadAcquire">
<db:title>T QAtomicInteger::loadAcquire() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>loadAcquire</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T loadAcquire() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically loads the value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> using the &quot;Acquire&quot; memory ordering. The value is not modified in any way, but note that there's no guarantee that it remains so.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#storeRelaxed">storeRelaxed</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#loadRelaxed">loadRelaxed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="loadRelaxed">
<db:title>[since 5.14] T QAtomicInteger::loadRelaxed() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>loadRelaxed</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T loadRelaxed() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically loads the value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> using relaxed memory ordering. The value is not modified in any way, but note that there's no guarantee that it remains so.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#storeRelaxed">storeRelaxed</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#loadAcquire">loadAcquire</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ref">
<db:title>bool QAtomicInteger::ref()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>ref</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool ref()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically increments the value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>. Returns <db:code>true</db:code> if the new value is non-zero, false otherwise.</db:para>
<db:para>This function uses <db:emphasis>ordered</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#deref">deref</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#operator-2b-2b">operator++</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="storeRelaxed">
<db:title>[since 5.14] void QAtomicInteger::storeRelaxed(T <db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>storeRelaxed</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void storeRelaxed(T newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically stores the <db:code role="parameter">newValue</db:code> value into this atomic type, using relaxed memory ordering.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#storeRelease">storeRelease</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#loadRelaxed">loadRelaxed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="storeRelease">
<db:title>void QAtomicInteger::storeRelease(T <db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>storeRelease</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void storeRelease(T newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically stores the <db:code role="parameter">newValue</db:code> value into this atomic type, using the &quot;Release&quot; memory ordering.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#storeRelaxed">storeRelaxed</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#loadAcquire">loadAcquire</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="testAndSetAcquire">
<db:title>bool QAtomicInteger::testAndSetAcquire(T <db:emphasis>expectedValue</db:emphasis>, T <db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>testAndSetAcquire</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>expectedValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool testAndSetAcquire(T expectedValue, T newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic test-and-set.</db:para>
<db:para>If the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> is the <db:code role="parameter">expectedValue</db:code>, the test-and-set functions assign the <db:code role="parameter">newValue</db:code> to this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and return true. If the values are <db:emphasis>not</db:emphasis> the same, this function does nothing and returns <db:code>false</db:code>.</db:para>
<db:para>This function uses <db:emphasis>acquire</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</db:para>
</db:section>
<db:section xml:id="testAndSetOrdered">
<db:title>bool QAtomicInteger::testAndSetOrdered(T <db:emphasis>expectedValue</db:emphasis>, T <db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>testAndSetOrdered</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>expectedValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool testAndSetOrdered(T expectedValue, T newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic test-and-set.</db:para>
<db:para>If the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> is the <db:code role="parameter">expectedValue</db:code>, the test-and-set functions assign the <db:code role="parameter">newValue</db:code> to this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and return true. If the values are <db:emphasis>not</db:emphasis> the same, this function does nothing and returns <db:code>false</db:code>.</db:para>
<db:para>This function uses <db:emphasis>ordered</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</db:para>
</db:section>
<db:section xml:id="testAndSetRelaxed">
<db:title>bool QAtomicInteger::testAndSetRelaxed(T <db:emphasis>expectedValue</db:emphasis>, T <db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>testAndSetRelaxed</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>expectedValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool testAndSetRelaxed(T expectedValue, T newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic test-and-set.</db:para>
<db:para>If the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> is the <db:code role="parameter">expectedValue</db:code>, the test-and-set functions assign the <db:code role="parameter">newValue</db:code> to this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and return true. If the values are <db:emphasis>not</db:emphasis> the same, this function does nothing and returns <db:code>false</db:code>.</db:para>
<db:para>This function uses <db:emphasis>relaxed</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, leaving the compiler and processor to freely reorder memory accesses.</db:para>
</db:section>
<db:section xml:id="testAndSetRelease">
<db:title>bool QAtomicInteger::testAndSetRelease(T <db:emphasis>expectedValue</db:emphasis>, T <db:emphasis>newValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>testAndSetRelease</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>expectedValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>newValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool testAndSetRelease(T expectedValue, T newValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic test-and-set.</db:para>
<db:para>If the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> is the <db:code role="parameter">expectedValue</db:code>, the test-and-set functions assign the <db:code role="parameter">newValue</db:code> to this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and return true. If the values are <db:emphasis>not</db:emphasis> the same, this function does nothing and returns <db:code>false</db:code>.</db:para>
<db:para>This function uses <db:emphasis>release</db:emphasis> <db:link xlink:href="qatomicinteger.xml#memory-ordering">memory ordering</db:link> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</db:para>
</db:section>
<db:section xml:id="operator-T">
<db:title>[since 5.3] T QAtomicInteger::operator T() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>T</db:type>
<db:methodname>operator T</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T operator T() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically loads the value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> using a sequentially consistent memory ordering if possible; or &quot;Acquire&quot; ordering if not. The value is not modified in any way, but note that there's no guarantee that it remains so.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#loadRelaxed">loadRelaxed</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#loadAcquire">loadAcquire</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-and-eq">
<db:title>[since 5.3] T QAtomicInteger::operator&amp;=(T <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>operator&amp;=</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T operator&amp;=(T value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic add-and-fetch.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-ANDs <db:code role="parameter">value</db:code> to the current value, returning the new value.</db:para>
<db:para>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndAndOrdered">fetchAndAndOrdered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-2b">
<db:title>[since 5.3] T QAtomicInteger::operator++()</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>operator++</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T operator++()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically pre-increments the value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>. Returns the new value of this atomic.</db:para>
<db:para>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#ref">ref</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#operator-2b-2b-1">operator++</db:link>(int)</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#operator--">operator--</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-2b-1">
<db:title>[since 5.3] T QAtomicInteger::operator++(<db:emphasis>int</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>operator++</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T operator++(int)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically post-increments the value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>. Returns the old value of this atomic.</db:para>
<db:para>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#ref">ref</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#operator-2b-2b">operator++</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#operator---1">operator--</db:link>(int)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-2b-eq">
<db:title>[since 5.3] T QAtomicInteger::operator+=(T <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>operator+=</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T operator+=(T value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic add-and-fetch.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then adds <db:code role="parameter">value</db:code> to the current value, returning the new value.</db:para>
<db:para>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndAddOrdered">fetchAndAddOrdered</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#operator--eq">operator-=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator--">
<db:title>[since 5.3] T QAtomicInteger::operator--()</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>operator--</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T operator--()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically pre-decrements the value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>. Returns the new value of this atomic.</db:para>
<db:para>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#deref">deref</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#operator---1">operator--</db:link>(int)</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#operator-2b-2b">operator++</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator---1">
<db:title>[since 5.3] T QAtomicInteger::operator--(<db:emphasis>int</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>operator--</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">T operator--(int)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically post-decrements the value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>. Returns the old value of this atomic.</db:para>
<db:para>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#deref">deref</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#operator--">operator--</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#operator-2b-2b-1">operator++</db:link>(int)</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator--eq">
<db:title>[since 5.3] T QAtomicInteger::operator-=(T <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>operator-=</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T operator-=(T value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic sub-and-fetch.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then subtracts <db:code role="parameter">value</db:code> to the current value, returning the new value.</db:para>
<db:para>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndSubOrdered">fetchAndSubOrdered</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#operator-2b-eq">operator+=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QAtomicInteger&lt;T&gt; &amp;QAtomicInteger::operator=(const QAtomicInteger&lt;T&gt; &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QAtomicInteger&lt;T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QAtomicInteger&lt;T&gt; &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QAtomicInteger&lt;T&gt; &amp; operator=(const QAtomicInteger&lt;T&gt; &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns <db:code role="parameter">other</db:code> to this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and returns a reference to this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>[since 5.3] QAtomicInteger&lt;T&gt; &amp;QAtomicInteger::operator=(<db:emphasis>T</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QAtomicInteger&lt;T&gt; &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QAtomicInteger&lt;T&gt; &amp; operator=(T)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomically stores the other value into this atomic type using a sequentially consistent memory ordering if possible; or &quot;Release&quot; ordering if not. This function returns a reference to this object.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#storeRelaxed">storeRelaxed</db:link>()</db:member>
<db:member><db:link xlink:href="qatomicinteger.xml#storeRelease">storeRelease</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5e-eq">
<db:title>[since 5.3] T QAtomicInteger::operator^=(T <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>operator^=</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T operator^=(T value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic xor-and-fetch.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-XORs <db:code role="parameter">value</db:code> to the current value, returning the new value.</db:para>
<db:para>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndXorOrdered">fetchAndXorOrdered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-7c-eq">
<db:title>[since 5.3] T QAtomicInteger::operator|=(T <db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>T</db:type>
<db:methodname>operator|=</db:methodname>
<db:methodparam>
<db:type>T</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">T operator|=(T value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Atomic or-and-fetch.</db:para>
<db:para>Reads the current value of this <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link> and then bitwise-ORs <db:code role="parameter">value</db:code> to the current value, returning the new value.</db:para>
<db:para>This function uses a sequentially consistent memory ordering if possible; or &quot;Ordered&quot; ordering if not.</db:para>
<db:para>This function was introduced in Qt 5.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qatomicinteger.xml#fetchAndOrOrdered">fetchAndOrOrdered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE">
<db:title>Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined if and only if your processor supports atomic fetch-and-add on integers.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_NOT_NATIVE">
<db:title>Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_NOT_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_NOT_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_NOT_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when the hardware does not support atomic fetch-and-add on integers.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_SOMETIMES_NATIVE">
<db:title>Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when only certain generations of the processor support atomic fetch-and-add on integers. Use the <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>&lt;T&gt;::isFetchAndAddNative() function to check what your processor supports.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_WAIT_FREE">
<db:title>Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_WAIT_FREE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_WAIT_FREE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_WAIT_FREE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined together with <db:link xlink:href="qatomicinteger.xml#Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE">Q_ATOMIC_INTnn_FETCH_AND_ADD_IS_ALWAYS_NATIVE</db:link> to indicate that the atomic fetch-and-add on integers is wait-free.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE">
<db:title>Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined if and only if your processor supports atomic fetch-and-store on integers.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_NOT_NATIVE">
<db:title>Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_NOT_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_NOT_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_NOT_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when the hardware does not support atomic fetch-and-store on integers.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_SOMETIMES_NATIVE">
<db:title>Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when only certain generations of the processor support atomic fetch-and-store on integers. Use the <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>&lt;T&gt;::isFetchAndStoreNative() function to check what your processor supports.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_WAIT_FREE">
<db:title>Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_WAIT_FREE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_WAIT_FREE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_WAIT_FREE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined together with <db:link xlink:href="qatomicinteger.xml#Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE">Q_ATOMIC_INTnn_FETCH_AND_STORE_IS_ALWAYS_NATIVE</db:link> to indicate that the atomic fetch-and-store on integers is wait-free.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_IS_SUPPORTED">
<db:title>Q_ATOMIC_INTnn_IS_SUPPORTED</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_IS_SUPPORTED</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_IS_SUPPORTED</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined if atomic integers of size <db:emphasis>nn</db:emphasis> (in bits) are supported in this compiler / architecture combination. Q_ATOMIC_INT32_IS_SUPPORTED is always defined.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE">
<db:title>Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined if and only if all generations of your processor support atomic reference counting.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_NOT_NATIVE">
<db:title>Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_NOT_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_NOT_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_NOT_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when the hardware does not support atomic reference counting.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE">
<db:title>Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when only certain generations of the processor support atomic reference counting. Use the <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>&lt;T&gt;::isReferenceCountingNative() function to check what your processor supports.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_WAIT_FREE">
<db:title>Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_WAIT_FREE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_WAIT_FREE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_WAIT_FREE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined together with <db:link xlink:href="qatomicinteger.xml#Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE">Q_ATOMIC_INTnn_REFERENCE_COUNTING_IS_ALWAYS_NATIVE</db:link> to indicate that the reference counting is wait-free.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE">
<db:title>Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined if and only if your processor supports atomic test-and-set on integers.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_TEST_AND_SET_IS_NOT_NATIVE">
<db:title>Q_ATOMIC_INTnn_TEST_AND_SET_IS_NOT_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_TEST_AND_SET_IS_NOT_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_TEST_AND_SET_IS_NOT_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when the hardware does not support atomic test-and-set on integers.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_TEST_AND_SET_IS_SOMETIMES_NATIVE">
<db:title>Q_ATOMIC_INTnn_TEST_AND_SET_IS_SOMETIMES_NATIVE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_TEST_AND_SET_IS_SOMETIMES_NATIVE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_TEST_AND_SET_IS_SOMETIMES_NATIVE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined when only certain generations of the processor support atomic test-and-set on integers. Use the <db:link xlink:href="qatomicinteger.xml">QAtomicInteger</db:link>&lt;T&gt;::isTestAndSetNative() function to check what your processor supports.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
<db:section xml:id="Q_ATOMIC_INTnn_TEST_AND_SET_IS_WAIT_FREE">
<db:title>Q_ATOMIC_INTnn_TEST_AND_SET_IS_WAIT_FREE</db:title>
<db:methodsynopsis>
<db:methodname>Q_ATOMIC_INTnn_TEST_AND_SET_IS_WAIT_FREE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">Q_ATOMIC_INTnn_TEST_AND_SET_IS_WAIT_FREE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is defined together with <db:link xlink:href="qatomicinteger.xml#Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE">Q_ATOMIC_INTnn_TEST_AND_SET_IS_ALWAYS_NATIVE</db:link> to indicate that the atomic test-and-set on integers is wait-free.</db:para>
<db:para><db:emphasis>nn</db:emphasis> is the size of the integer, in bits (8, 16, 32 or 64).</db:para>
</db:section>
</db:section>
</db:article>
