<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Bluetooth Tennis Example</db:title>
<db:productname>QtBluetooth</db:productname>
<db:edition>Qt 5.2.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Bluetooth Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Bluetooth Reference Documentation.</db:para></db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Digia.  For licensing terms and
** conditions see http://qt.digia.com/licensing.  For further information
** use the contact form at http://qt.digia.com/contact-us.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Digia gives you certain additional
** rights.  These rights are described in the Digia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3.0 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU General Public License version 3.0 requirements will be
** met: http://www.gnu.org/copyleft/gpl.html.
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;board.h&quot;

#include &lt;QGraphicsItem&gt;
#include &lt;QGraphicsScene&gt;
#include &lt;QDebug&gt;
#include &lt;QTextDocument&gt;
#include &lt;QFontMetrics&gt;
#include &lt;QPropertyAnimation&gt;

const QColor fg = Qt::white;
const QColor bg = Qt::black;

Board::Board(QWidget *parent) :
    QGraphicsView(parent)
{
    scene = new QGraphicsScene(QRect(0, 0, 640, 360), this);

    scene-&gt;setBackgroundBrush(QBrush(bg));

    ball = scene-&gt;addRect(-6, -6, 12, 12, QPen(Qt::SolidLine), QBrush(fg));
    ball-&gt;setPos(Width/2-6, Height/2-6);

    // why is y -1...otherwise we have a gap...
    topWall = scene-&gt;addRect(0, -1, Width, 12, QPen(Qt::SolidLine), QBrush(fg));
    bottomWall = scene-&gt;addRect(0, Height-12, Width, 12, QPen(Qt::SolidLine), QBrush(fg));

    leftPaddle = scene-&gt;addRect(0, 12, 12, Paddle, QPen(Qt::SolidLine), QBrush(fg));
    rightPaddle = scene-&gt;addRect(Width-12, 12, 12, Paddle, QPen(Qt::SolidLine), QBrush(fg));

    QPen p;
    p.setWidth(2);
    p.setStyle(Qt::DotLine);
    p.setBrush(QBrush(fg));
    scene-&gt;addLine(Width/2, 0, Width/2, Height, p);

    QFont f;
    f.setStyleHint(QFont::OldEnglish);
    f.setPixelSize(50);
    f.setBold(true);
    leftScore = scene-&gt;addText(QString(&quot;0&quot;), f);
    leftScore-&gt;setDefaultTextColor(fg);
//    leftScore-&gt;setPos(120, 50);

    rightScore = scene-&gt;addText(QString(&quot;0&quot;), f);
//    rightScore-&gt;setPos(Width-140, 50);
    rightScore-&gt;setDefaultTextColor(fg);
    setScore(0, 0);

    f.setPixelSize(25);
    status = scene-&gt;addText(QString(), f);
    status-&gt;setDefaultTextColor(fg);

    ball-&gt;setCacheMode(QGraphicsItem::DeviceCoordinateCache);
    leftPaddle-&gt;setCacheMode(QGraphicsItem::DeviceCoordinateCache);
    rightPaddle-&gt;setCacheMode(QGraphicsItem::DeviceCoordinateCache);

    icon.load(QString(&quot;:/icons/connect.png&quot;));
    icon = icon.scaled(100, 100, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
    qDebug() &lt;&lt; &quot;icon&quot; &lt;&lt; icon.isNull();
    connectIcon = scene-&gt;addPixmap(icon);
    connectIcon-&gt;setPos(440,200);
    connectIcon-&gt;setAcceptTouchEvents(true);
    connectIcon-&gt;setTransformOriginPoint(50,50);
    connectIcon-&gt;setTransformationMode(Qt::SmoothTransformation);

    connectAnimation = new QPropertyAnimation(this, &quot;connectRotation&quot;);
    connectAnimation-&gt;setDuration(1000);
    connectAnimation-&gt;setLoopCount(-1);
    connectAnimation-&gt;setStartValue(0);
    connectAnimation-&gt;setEndValue(360);

    setCacheMode(QGraphicsView::CacheBackground);
    setViewportUpdateMode(QGraphicsView::BoundingRectViewportUpdate);

//    connect(scene, SIGNAL(changed(QList&lt;QRectF&gt;)), this, SLOT(sceneChanged(QList&lt;QRectF&gt;)));

}
void Board::setBall(int x, int y)
{
    ball-&gt;setPos(x, y);
    checkBall(x, y);
}

void Board::setLeftPaddle(int y)
{
    leftPaddle-&gt;setPos(0, y);
}

void Board::setRightPaddle(int y)
{
    rightPaddle-&gt;setPos(0, y);
}

void Board::sceneChanged(const QList&lt;QRectF&gt; &amp;region)
{
    Q_UNUSED(region);

    QList&lt;QGraphicsItem *&gt;items = scene-&gt;collidingItems(ball);
    while (!items.empty()) {
        QGraphicsItem *i = items.takeFirst();
        if (i == topWall)
            emit ballCollision(Top);
        if (i == bottomWall)
            emit ballCollision(Bottom);
        if (i == leftPaddle)
            emit ballCollision(Left);
        if (i == rightPaddle)
            emit ballCollision(Right);
    }

}

void Board::checkBall(int x, int y)
{
  int ly = leftPaddle-&gt;y();
  int ry = rightPaddle-&gt;y();

  if (x &gt; 646)
      emit scored(Right);
  else if (x &lt; -6)
      emit scored(Left);

  if (y &lt; 18)
      emit ballCollision(Top);
  else if (y &gt; 360-18)
      emit ballCollision(Bottom);

  if ((x &lt; 18) &amp;&amp;
      (y &gt; ly-6) &amp;&amp;
      (y &lt; ly+Paddle+6))
      emit ballCollision(Left);

  if ((x &gt; 640-18) &amp;&amp;
      (y &gt; ry-6) &amp;&amp;
      (y &lt; ry+Paddle+6))
      emit ballCollision(Right);
}

void Board::setScore(int l, int r)
{
    QString left = QString(&quot;%1&quot;).arg(l);
    QString right = QString(&quot;%1&quot;).arg(r);
    leftScore-&gt;document()-&gt;setPlainText(left);
    rightScore-&gt;document()-&gt;setPlainText(right);
    QFontMetrics fm(leftScore-&gt;font());
    leftScore-&gt;setPos(Width/4 - fm.width(left)/2, 50);
    rightScore-&gt;setPos(3*Width/4 - fm.width(right)/2, 50);

}

void Board::setStatus(QString text, int opacity_start, int opacity_end)
{

    status-&gt;document()-&gt;setPlainText(text);
    status-&gt;setPos(24, Height-25-25);
    QPropertyAnimation *a = new QPropertyAnimation(status, &quot;opacity&quot;);
    a-&gt;setDuration(2000);
    a-&gt;setStartValue(opacity_start/100.0);
    a-&gt;setEndValue(opacity_end/100.0);
    a-&gt;start(QAbstractAnimation::DeleteWhenStopped);
}

void Board::setConnectRotation(int rot)
{
    connectIcon-&gt;setRotation(rot);
//    QTransform t;
//    t.rotate(rot);
//    connectIcon-&gt;setPixmap(icon.scaled(100, 100).transformed(t, Qt::SmoothTransformation));
}

void Board::setConnectOpacity(qreal op)
{
    connectIcon-&gt;setOpacity(op);
}

void Board::animateConnect(bool start)
{
    if (start) {
        connectAnimation-&gt;start();
    }
    else {
        connectAnimation-&gt;stop();
        QPropertyAnimation *a = new QPropertyAnimation(this, &quot;connectRotation&quot;);
//        qDebug() &lt;&lt; &quot;currentTime&quot; &lt;&lt; connectAnimation-&gt;currentLoopTime() &lt;&lt; &quot;rotation&quot; &lt;&lt; connectAnimation-&gt;currentValue();
        a-&gt;setDuration(connectAnimation-&gt;currentLoopTime()/2);
        a-&gt;setStartValue(connectAnimation-&gt;currentValue().toInt( ));
        a-&gt;setEndValue(0);
//        a-&gt;setDirection(QAbstractAnimation::Backward);
        a-&gt;start(QAbstractAnimation::DeleteWhenStopped);
    }
}

void Board::fadeConnect(bool out)
{
    qreal start = 100.0;
    qreal end = 0.0;

    if (!out) {
        start = 0.0;
        end = 100.0;
    }

    QPropertyAnimation *a = new QPropertyAnimation(this, &quot;connectOpacity&quot;);
    a-&gt;setDuration(2000);
    a-&gt;setStartValue(start);
    a-&gt;setEndValue(end);
    a-&gt;start(QAbstractAnimation::DeleteWhenStopped);
}

</db:programlisting>
</db:article>
