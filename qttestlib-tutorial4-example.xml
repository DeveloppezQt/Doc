<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Chapter 4: Replaying GUI Events</db:title>
<db:productname>QtTestLib</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Test Reference Documentation</db:titleabbrev>
<db:extendedlink xlink:type="extended"><db:link xlink:to="qttestlib-tutorial3-example.xml" xlink:type="arc" xlink:arcrole="prev" xlink:title="Chapter 3"/></db:extendedlink>
<db:extendedlink xlink:type="extended"><db:link xlink:to="qttestlib-tutorial5-example.xml" xlink:type="arc" xlink:arcrole="next" xlink:title="Chapter 5"/></db:extendedlink>
<db:abstract>
<db:para>How to replay GUI events.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para><db:emphasis role="bold">&lt;Unknown command&gt;<db:code>contentspage</db:code></db:emphasis>{Qt Test Tutorial}{Contents}</db:para>
<db:para>In this chapter, we will show how to simulate a GUI event, and how to store a series of GUI events as well as replay them on a widget.</db:para>
<db:para>The approach to storing a series of events and replaying them is quite similar to the approach explained in <db:link xlink:href="qttestlib-tutorial2-example.xml">chapter 2</db:link>. All you need to do is to add a data function to your test class:</db:para>
<db:programlisting language="cpp">class TestGui: public QObject
{
    Q_OBJECT

private slots:
    void testGui_data();
    void testGui();
};
</db:programlisting>
<db:section xml:id="writing-the-data-function">
<db:title>Writing the Data Function</db:title>
<db:para>As before, a test function's associated data function carries the same name, appended by <db:code>_data</db:code>.</db:para>
<db:programlisting language="cpp">void TestGui::testGui_data()
{
    QTest::addColumn&lt;QTestEventList&gt;(&quot;events&quot;);
    QTest::addColumn&lt;QString&gt;(&quot;expected&quot;);

    QTestEventList list1;
    list1.addKeyClick('a');
    QTest::newRow(&quot;char&quot;) &lt;&lt; list1 &lt;&lt; &quot;a&quot;;

    QTestEventList list2;
    list2.addKeyClick('a');
    list2.addKeyClick(Qt::Key_Backspace);
    QTest::newRow(&quot;there and back again&quot;) &lt;&lt; list2 &lt;&lt; &quot;&quot;;
}
</db:programlisting>
<db:para>First, we define the elements of the table using the QTest::addColumn() function: A list of GUI events, and the expected result of applying the list of events on a <db:link xlink:href="qwidget.xml">QWidget</db:link>. Note that the type of the first element is <db:link xlink:href="qtesteventlist.xml">QTestEventList</db:link>.</db:para>
<db:para>A <db:link xlink:href="qtesteventlist.xml">QTestEventList</db:link> can be populated with GUI events that can be stored as test data for later usage, or be replayed on any <db:link xlink:href="qwidget.xml">QWidget</db:link>.</db:para>
<db:para>In our current data function, we create two <db:link xlink:href="qtesteventlist.xml">QTestEventList</db:link> elements. The first list consists of a single click to the 'a' key. We add the event to the list using the <db:link xlink:href="qtesteventlist.xml#addKeyClick">QTestEventList::addKeyClick</db:link>() function. Then we use the <db:link xlink:href="qtest.xml#newRow">QTest::newRow</db:link>() function to give the data set a name, and stream the event list and the expected result into the table.</db:para>
<db:para>The second list consists of two key clicks: an 'a' with a following 'backspace'. Again we use the <db:link xlink:href="qtesteventlist.xml#addKeyClick">QTestEventList::addKeyClick</db:link>() to add the events to the list, and <db:link xlink:href="qtest.xml#newRow">QTest::newRow</db:link>() to put the event list and the expected result into the table with an associated name.</db:para>
</db:section>
<db:section xml:id="rewriting-the-test-function">
<db:title>Rewriting the Test Function</db:title>
<db:para>Our test can now be rewritten:</db:para>
<db:programlisting language="cpp">void TestGui::testGui()
{
    QFETCH(QTestEventList, events);
    QFETCH(QString, expected);

    QLineEdit lineEdit;

    events.simulate(&amp;lineEdit);

    QCOMPARE(lineEdit.text(), expected);
}
</db:programlisting>
<db:para>The TestGui::testGui() function will be executed two times, once for each entry in the test data that we created in the associated TestGui::testGui_data() function.</db:para>
<db:para>First, we fetch the two elements of the data set using the <db:link xlink:href="qtest.xml#QFETCH">QFETCH</db:link>() macro. <db:link xlink:href="qtest.xml#QFETCH">QFETCH</db:link>() takes two arguments: the data type of the element and the element name. Then we create a <db:link xlink:href="qlineedit.xml">QLineEdit</db:link>, and apply the list of events on that widget using the QTestEventList::simulate() function.</db:para>
<db:para>Finally, we use the <db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>() macro to check if the line edit's text is as expected.</db:para>
<db:para>As before, to make our test case a stand-alone executable, the following two lines are needed:</db:para>
<db:programlisting language="cpp">QTEST_MAIN(TestGui)
#include &quot;testgui.moc&quot;
</db:programlisting>
<db:para>The <db:link xlink:href="qtest.xml#QTEST_MAIN">QTEST_MAIN</db:link>() macro expands to a simple main() method that runs all the test functions, and since both the declaration and the implementation of our test class are in a .cpp file, we also need to include the generated moc file to make Qt's introspection work.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="tutorial4/testgui.cpp">tutorial4/testgui.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tutorial4/tutorial4.pro">tutorial4/tutorial4.pro</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
