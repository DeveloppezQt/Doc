<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Missing type</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Qml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>[missing-type] A type used in a binding or alias was not found.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>This warning category is spelled [missing-type] by qmllint.</db:para>
<db:section xml:id="cannot-deduce-type-of-alias">
<db:title>Cannot deduce type of alias</db:title>
<db:section xml:id="what-happened">
<db:title>What happened?</db:title>
<db:para>An alias property points to a property with a C++ type whose QML counterpart was not found. This can be caused by importing a QML module which do not declare its QML dependencies on other modules.</db:para>
<db:note>
<db:para>If you are importing QML modules with external dependencies, verify that they are actually installed, and that their modules end up in an <db:link xlink:href="qtqml-syntax-imports.xml#qml-import-path">import path</db:link>.</db:para>
</db:note>
<db:para>The warning might also indicate that the type of the property referenced by the alias does not have a QML counterpart. The referenced property type might be missing the <db:link xlink:href="qqmlintegration-h.xml#QML_ELEMENT">QML_ELEMENT</db:link> macro, for example. Refer to <db:link xlink:href="qtqml-cppintegration-definetypes.xml">Defining QML Types from C++</db:link> or <db:link xlink:href="qtqml-cppintegration-overview.xml">Overview - QML and C++ Integration</db:link> in this case.</db:para>
</db:section>
<db:section xml:id="why-is-this-bad">
<db:title>Why is this bad?</db:title>
<db:para>QML tooling is not able to find the QML counterpart of the C++ type: the <db:link xlink:href="qtqml-qtquick-compiler-tech.xml">compiler</db:link> can't compile this property alias to C++ and <db:link xlink:href="qtqml-tooling-qmllint.xml">qmllint</db:link> as well as <db:link xlink:href="qtqml-tooling-qmlls.xml">QML Language Server</db:link> can't analyze this property alias.</db:para>
</db:section>
<db:section xml:id="example">
<db:title>Example</db:title>
<db:para>Let our QML module have one C++ class with a property myProperty:</db:para>
<db:programlisting language="cpp">#include &lt;QQuickItem&gt;
#include &lt;QtQml/qqmlregistration.h&gt;
#include &lt;QObject&gt;

class MyCppObject : public QObject
{
    Q_OBJECT
    QML_ELEMENT
public:
    MyCppObject(QObject *parent = nullptr)
        : QObject(parent)
    {}

    Q_PROPERTY(QQuickItem *myProperty READ myProperty WRITE setMyProperty NOTIFY notifyMyProperty)
    QQuickItem *myProperty() { return m_myProperty; }
    void setMyProperty(QQuickItem *item) { emit notifyMyProperty(); m_myProperty = item; }

private:
    QQuickItem *m_myProperty;

signals:
    void notifyMyProperty();
};
</db:programlisting>
<db:para>with following CMakeLists.txt:</db:para>
<db:programlisting language="cpp" role="bad">project(mymodule VERSION 0.1 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD_REQUIRED ON)
find_package(Qt6 6.5 REQUIRED COMPONENTS Quick)
qt_standard_project_setup(REQUIRES 6.5)

qt_add_executable(appmymodule
    main.cpp
)

qt_add_qml_module(appmymodule
    URI mymodule
    VERSION 1.0
    QML_FILES Main.qml HelloWorld.qml
    SOURCES mycppobject.cpp mycppobject.h
)

target_link_libraries(appmymodule
 PRIVATE Qt6::Quick
)
</db:programlisting>
<db:para>The C++ dependency Quick was declared, such that this class can compile and the QQuickItem include can be found. Also, mymodule does not have any dependency on QtQuick.</db:para>
<db:para>Now, let's try to use myProperty in an alias in QML. The program will run but QML tooling like the <db:link xlink:href="qtqml-qtquick-compiler-tech.xml">compiler</db:link>, for example, will complain about the usage of myProperty:</db:para>
<db:programlisting language="qml">import mymodule

MyCppObject {
    id: root

    property alias myAlias: root.myProperty // not ok: Cannot deduce type of alias [missing-type]
}
</db:programlisting>
<db:para>The reason for the warning message is that in the QML code, the type QQuickItem of myProperty and its QML counterpart Item are not known, even if you have import QtQuick in your QML file. This is because the same type can be exposed multiple times with different attributes in different modules: mymodule actually has to be precise about the QML type of myProperty.</db:para>
<db:para>To fix this warning, add the dependency in the CMakeLists.txt:</db:para>
<db:programlisting language="cpp" role="bad">qt_add_qml_module(mymodule
    URI mymodule
    ...
    # declarare QML dependency to QtQuick module
    DEPENDENCIES QtQuick
    ...
)
</db:programlisting>
<db:para>Now, the warning should be gone!</db:para>
<db:para><db:emphasis role="bold">See also</db:emphasis> <db:link xlink:href="qt-add-qml-module.xml#declaring-module-dependencies">Declaring module dependencies</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="no-type-found-for-property">
<db:title>No type found for property</db:title>
<db:section xml:id="no-type-found-for-property-what-happened-5">
<db:title>What happened?</db:title>
<db:para>A binding was set on a property whose QML type was not found. This can be caused by a QML module which does not declare its QML dependencies on other modules.</db:para>
<db:note>
<db:para>If you are importing QML modules with external dependencies, verify that they are actually installed, and that their modules end up in an <db:link xlink:href="qtqml-syntax-imports.xml#qml-import-path">import path</db:link>.</db:para>
</db:note>
<db:para>The warning might also indicate that the type of the property does not have a QML counterpart. The property type might be missing the <db:link xlink:href="qqmlintegration-h.xml#QML_ELEMENT">QML_ELEMENT</db:link> macro, for example. Refer to <db:link xlink:href="qtqml-cppintegration-definetypes.xml">Defining QML Types from C++</db:link> or <db:link xlink:href="qtqml-cppintegration-overview.xml">Overview - QML and C++ Integration</db:link> in this case.</db:para>
</db:section>
<db:section xml:id="no-type-found-for-property-why-is-this-bad-6">
<db:title>Why is this bad?</db:title>
<db:para>QML tooling is not able to find the QML counterpart of the C++ type: the <db:link xlink:href="qtqml-qtquick-compiler-tech.xml">compiler</db:link> can't compile this property binding to C++ and <db:link xlink:href="qtqml-tooling-qmllint.xml">qmllint</db:link> as well as <db:link xlink:href="qtqml-tooling-qmlls.xml">QML Language Server</db:link> can't analyze this property binding.</db:para>
</db:section>
<db:section xml:id="no-type-found-for-property-example-7">
<db:title>Example</db:title>
<db:para>Let our QML module have a C++ class with two properties, myProperty and myProperty2:</db:para>
<db:programlisting language="cpp">#include &lt;QQuickItem&gt;
#include &lt;QtQml/qqmlregistration.h&gt;
#include &lt;QObject&gt;

class MyCppObject : public QObject
{
    Q_OBJECT
    QML_ELEMENT
public:
    MyCppObject(QObject *parent = nullptr)
     : QObject(parent)
    {}

    Q_PROPERTY(QQuickItem *myProperty READ myProperty WRITE setMyProperty NOTIFY notifyMyProperty)
    QQuickItem *myProperty() { return m_myProperty; }
    void setMyProperty(QQuickItem *item) { emit notifyMyProperty(); m_myProperty = item; }

    Q_PROPERTY(QQuickItem *myProperty2 READ myProperty2 WRITE setMyProperty2 NOTIFY notifyMyProperty2)
    QQuickItem *myProperty2() { return m_myProperty2; }
    void setMyProperty2(QQuickItem *item) { emit notifyMyProperty2(); m_myProperty2 = item; }

private:
    QQuickItem *m_myProperty;
    QQuickItem *m_myProperty2;

signals:
    void notifyMyProperty();
    void notifyMyProperty2();
};
</db:programlisting>
<db:para>with following CMakeLists.txt:</db:para>
<db:programlisting language="cpp" role="bad">project(mymodule VERSION 0.1 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD_REQUIRED ON)
find_package(Qt6 6.5 REQUIRED COMPONENTS Quick)
qt_standard_project_setup(REQUIRES 6.5)

qt_add_executable(appmymodule
    main.cpp
)

qt_add_qml_module(appmymodule
    URI mymodule
    VERSION 1.0
    QML_FILES Main.qml HelloWorld.qml
    SOURCES mycppobject.cpp mycppobject.h
)

target_link_libraries(appmymodule
 PRIVATE Qt6::Quick
)
</db:programlisting>
<db:para>The C++ dependency Quick was declared, such that this class can compile and the QQuickItem include can be found. Also, mymodule does not have any dependency on QtQuick.</db:para>
<db:para>Now, let's try to bind myProperty2 to myProperty in an alias in QML. The program will run but QML tooling like the <db:link xlink:href="qtqml-qtquick-compiler-tech.xml">compiler</db:link>, for example, will complain about the usage of myProperty:</db:para>
<db:programlisting language="qml">import mymodule

MyCppObject {
    id: root

    myProperty: myProperty2 // not ok: No type found for property &quot;myProperty&quot;. [missing-type]
}
</db:programlisting>
<db:para>The reason for the warning message is that in the QML code, the type QQuickItem of myProperty and its QML counterpart Item are not known: the dependency 'QtQuick' of mymodule was not declared in the CMakeLists.txt.</db:para>
<db:para>To fix this warning, add the dependency in the CMakeLists.txt:</db:para>
<db:programlisting language="cpp" role="bad">qt_add_qml_module(mymodule
    URI mymodule
    ...
    # declarare QML dependency to QtQuick module
    DEPENDENCIES QtQuick
    ...
)
</db:programlisting>
<db:para>Now, the warning should be gone!</db:para>
<db:para><db:emphasis role="bold">See also</db:emphasis> <db:link xlink:href="qt-add-qml-module.xml#declaring-module-dependencies">Declaring module dependencies</db:link>.</db:para>
</db:section>
</db:section>
</db:article>
