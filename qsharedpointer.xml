<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSharedPointer Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QSharedPointer</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> class holds a strong reference to a shared pointer.</db:para>
<db:para>This class was introduced in Qt 4.5.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSharedPointer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.5</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> is an automatic, shared pointer in C++. It behaves exactly like a normal pointer for normal purposes, including respect for constness.</db:para>
<db:para><db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> will delete the pointer it is holding when it goes out of scope, provided no other <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> objects are referencing it.</db:para>
<db:para>A <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> object can be created from a normal pointer, another <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> object or by promoting a <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link> object to a strong reference.</db:para>
<db:section xml:id="thread-safety">
<db:title>Thread-Safety</db:title>
<db:para><db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> and <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link> are thread-safe and operate atomically on the pointer value. Different threads can also access the <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> or <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link> pointing to the same object at the same time without need for locking mechanisms.</db:para>
<db:para>It should be noted that, while the pointer value can be accessed in this manner, <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> and <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link> provide no guarantee about the object being pointed to. Thread-safety and reentrancy rules for that object still apply.</db:para>
</db:section>
<db:section xml:id="other-pointer-classes">
<db:title>Other Pointer Classes</db:title>
<db:para>Qt also provides two other pointer wrapper classes: <db:link xlink:href="qpointer.xml">QPointer</db:link> and <db:link xlink:href="qshareddatapointer.xml">QSharedDataPointer</db:link>. They are incompatible with one another, since each has its very different use case.</db:para>
<db:para><db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> holds a shared pointer by means of an external reference count (i.e., a reference counter placed outside the object). Like its name indicates, the pointer value is shared among all instances of <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> and <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link>. The contents of the object pointed to by the pointer should not be considered shared, however: there is only one object. For that reason, <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> does not provide a way to detach or make copies of the pointed object.</db:para>
<db:para><db:link xlink:href="qshareddatapointer.xml">QSharedDataPointer</db:link>, on the other hand, holds a pointer to shared data (i.e., a class derived from <db:link xlink:href="qshareddata.xml">QSharedData</db:link>). It does so by means of an internal reference count, placed in the <db:link xlink:href="qshareddata.xml">QSharedData</db:link> base class. This class can, therefore, detach based on the type of access made to the data being guarded: if it's a non-const access, it creates a copy atomically for the operation to complete.</db:para>
<db:para><db:link xlink:href="qexplicitlyshareddatapointer.xml">QExplicitlySharedDataPointer</db:link> is a variant of <db:link xlink:href="qshareddatapointer.xml">QSharedDataPointer</db:link>, except that it only detaches if QExplicitlySharedDataPointer::detach() is explicitly called (hence the name).</db:para>
<db:para><db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link> simply holds a pointer to a heap allocated object and deletes it in its destructor. This class is useful when an object needs to be heap allocated and deleted, but no more. <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link> is lightweight, it makes no use of additional structure or reference counting.</db:para>
<db:para>Finally, <db:link xlink:href="qpointer.xml">QPointer</db:link> holds a pointer to a <db:link xlink:href="qobject.xml">QObject</db:link>-derived object, but it does so weakly. <db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link> has the same functionality, but its use for that function is deprecated.</db:para>
</db:section>
<db:section xml:id="optional-pointer-tracking">
<db:title>Optional Pointer Tracking</db:title>
<db:para>A feature of <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> that can be enabled at compile-time for debugging purposes is a pointer tracking mechanism. When enabled, <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> registers in a global set all the pointers that it tracks. This allows one to catch mistakes like assigning the same pointer to two <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> objects.</db:para>
<db:para>This function is enabled by defining the <db:code>QT_SHAREDPOINTER_TRACK_POINTERS</db:code> macro before including the <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> header.</db:para>
<db:para>It is safe to use this feature even with code compiled without the feature. <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link> will ensure that the pointer is removed from the tracker even from code compiled without pointer tracking.</db:para>
<db:para>Note, however, that the pointer tracking feature has limitations on multiple- or virtual-inheritance (that is, in cases where two different pointer addresses can refer to the same object). In that case, if a pointer is cast to a different type and its value changes, <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link>'s pointer tracking mechanism may fail to detect that the object being tracked is the same.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshareddatapointer.xml">QSharedDataPointer</db:link></db:member>
<db:member><db:link xlink:href="qweakpointer.xml">QWeakPointer</db:link></db:member>
<db:member><db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:article>
