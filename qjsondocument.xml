<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QJsonDocument Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.2.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> class provides a way to read and write JSON documents.</db:para>
<db:para>This class was introduced in Qt 5.0.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QJsonDocument</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QJsonDocument is part of <db:simplelist><db:member><db:link xlink:href="json.xml">JSON Support in Qt</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> is a class that wraps a complete JSON document and can read and write this document both from a UTF-8 encoded text based representation as well as Qt's own binary format.</db:para>
<db:para>A JSON document can be converted from its text-based representation to a <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> using <db:link xlink:href="qjsondocument.xml#fromJson">QJsonDocument::fromJson</db:link>(). <db:link xlink:href="qjsondocument.xml#toJson">toJson</db:link>() converts it back to text. The parser is very fast and efficient and converts the JSON to the binary representation used by Qt.</db:para>
<db:para>Validity of the parsed document can be queried with !<db:link xlink:href="qjsondocument.xml#isNull">isNull</db:link>()</db:para>
<db:para>A document can be queried as to whether it contains an array or an object using <db:link xlink:href="qjsondocument.xml#isArray">isArray</db:link>() and <db:link xlink:href="qjsondocument.xml#isObject">isObject</db:link>(). The array or object contained in the document can be retrieved using <db:link xlink:href="qjsondocument.xml#array">array</db:link>() or <db:link xlink:href="qjsondocument.xml#object">object</db:link>() and then read or manipulated.</db:para>
<db:para>A document can also be created from a stored binary representation using <db:link xlink:href="qjsondocument.xml#fromBinaryData">fromBinaryData</db:link>() or <db:link xlink:href="qjsondocument.xml#fromRawData">fromRawData</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="json.xml">JSON Support in Qt</db:link></db:member>
<db:member><db:link xlink:href="qtcore-savegame-example.xml">JSON Save Game Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="DataValidation-enum">
<db:title>enum QJsonDocument::DataValidation</db:title>
<db:para>This value is used to tell <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> whether to validate the binary data when converting to a <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> using <db:link xlink:href="qjsondocument.xml#fromBinaryData">fromBinaryData</db:link>() or <db:link xlink:href="qjsondocument.xml#fromRawData">fromRawData</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link></db:emphasis>::Validate</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Validate the data before using it. This is the default.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link></db:emphasis>::BypassValidation</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Bypasses data validation. Only use if you received the data from a trusted place and know it's valid, as using of invalid data can crash the application.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="JsonFormat-enum">
<db:title>enum QJsonDocument::JsonFormat</db:title>
<db:para>This value defines the format of the JSON byte array produced when converting to a <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> using <db:link xlink:href="qjsondocument.xml#toJson">toJson</db:link>().</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link></db:emphasis>::Indented</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Defines human readable output as follows:</db:para>
<db:programlisting language="cpp">{
    &quot;Array&quot;: [
        true,
        999,
        &quot;string&quot;
    ],
    &quot;Key&quot;: &quot;Value&quot;,
    &quot;null&quot;: null
}
</db:programlisting>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link></db:emphasis>::Compact</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Defines a compact output as follows:</db:para>
<db:programlisting language="cpp">{&quot;Array&quot;: [true,999,&quot;string&quot;],&quot;Key&quot;: &quot;Value&quot;,&quot;null&quot;: null}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QJsonDocument">
<db:title>QJsonDocument::QJsonDocument()</db:title>
<db:para>Constructs an empty and invalid document.</db:para>
</db:section>
<db:section xml:id="QJsonDocument-1">
<db:title>[explicit] QJsonDocument::QJsonDocument(const QJsonArray &amp;<db:emphasis>array</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> from <db:code role="parameter">array</db:code>.</db:para>
</db:section>
<db:section xml:id="QJsonDocument-2">
<db:title>QJsonDocument::QJsonDocument(const QJsonDocument &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Creates a copy of the <db:code role="parameter">other</db:code> document.</db:para>
</db:section>
<db:section xml:id="dtor.QJsonDocument">
<db:title>[noexcept] QJsonDocument::~QJsonDocument()</db:title>
<db:para>Deletes the document.</db:para>
<db:para>Binary data set with <db:link xlink:href="qjsondocument.xml#fromRawData">fromRawData</db:link> is not freed.</db:para>
</db:section>
<db:section xml:id="array">
<db:title>QJsonArray QJsonDocument::array() const</db:title>
<db:para>Returns the <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link> contained in the document.</db:para>
<db:para>Returns an empty array if the document contains an object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsondocument.xml#isArray">isArray</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#object">object</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#setArray">setArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromBinaryData">
<db:title>[static] QJsonDocument QJsonDocument::fromBinaryData(const QByteArray &amp;<db:emphasis>data</db:emphasis>, QJsonDocument::DataValidation <db:emphasis>validation</db:emphasis> = Validate)</db:title>
<db:para>Creates a <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> from <db:code role="parameter">data</db:code>.</db:para>
<db:para><db:code role="parameter">validation</db:code> decides whether the data is checked for validity before being used. By default the data is validated. If the <db:code role="parameter">data</db:code> is not valid, the method returns a null document.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsondocument.xml#toBinaryData">toBinaryData</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#fromRawData">fromRawData</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#DataValidation-enum">DataValidation</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromJson">
<db:title>[static] QJsonDocument QJsonDocument::fromJson(const QByteArray &amp;<db:emphasis>json</db:emphasis>, QJsonParseError *<db:emphasis>error</db:emphasis> = 0)</db:title>
<db:para>Parses a UTF-8 encoded JSON document and creates a <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> from it.</db:para>
<db:para><db:code role="parameter">json</db:code> contains the json document to be parsed.</db:para>
<db:para>The optional <db:code role="parameter">error</db:code> variable can be used to pass in a <db:link xlink:href="qjsonparseerror.xml">QJsonParseError</db:link> data structure that will contain information about possible errors encountered during parsing.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsondocument.xml#toJson">toJson</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonparseerror.xml">QJsonParseError</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromRawData">
<db:title>[static] QJsonDocument QJsonDocument::fromRawData(const char *<db:emphasis>data</db:emphasis>, int <db:emphasis>size</db:emphasis>, QJsonDocument::DataValidation <db:emphasis>validation</db:emphasis> = Validate)</db:title>
<db:para>Creates a <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> that uses the first <db:code role="parameter">size</db:code> bytes from <db:code role="parameter">data</db:code>. It assumes <db:code role="parameter">data</db:code> contains a binary encoded JSON document. The created document does not take ownership of <db:code role="parameter">data</db:code> and the caller has to guarantee that <db:code role="parameter">data</db:code> will not be deleted or modified as long as any <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link>, <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link> or <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link> still references the data.</db:para>
<db:para><db:code role="parameter">data</db:code> has to be aligned to a 4 byte boundary.</db:para>
<db:para><db:code role="parameter">validation</db:code> decides whether the data is checked for validity before being used. By default the data is validated. If the <db:code role="parameter">data</db:code> is not valid, the method returns a null document.</db:para>
<db:para>Returns a <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> representing the data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsondocument.xml#rawData">rawData</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#fromBinaryData">fromBinaryData</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#DataValidation-enum">DataValidation</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isArray">
<db:title>bool QJsonDocument::isArray() const</db:title>
<db:para>Returns true if the document contains an array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsondocument.xml#array">array</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#isObject">isObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEmpty">
<db:title>bool QJsonDocument::isEmpty() const</db:title>
<db:para>Returns true if the document doesn't contain any data.</db:para>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QJsonDocument::isNull() const</db:title>
<db:para>returns true if this document is null.</db:para>
<db:para>Null documents are documents created through the default constructor.</db:para>
<db:para>Documents created from UTF-8 encoded text or the binary format are validated during parsing. If validation fails, the returned document will also be null.</db:para>
</db:section>
<db:section xml:id="isObject">
<db:title>bool QJsonDocument::isObject() const</db:title>
<db:para>Returns true if the document contains an object.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsondocument.xml#object">object</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#isArray">isArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="object">
<db:title>int QJsonDocument::object() const</db:title>
<db:para>Returns the <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link> contained in the document.</db:para>
<db:para>Returns an empty object if the document contains an array.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsondocument.xml#isObject">isObject</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#array">array</db:link>()</db:member>
<db:member><db:link xlink:href="">setObject()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rawData">
<db:title>const char *QJsonDocument::rawData(int *<db:emphasis>size</db:emphasis>) const</db:title>
<db:para>Returns the raw binary representation of the data <db:code role="parameter">size</db:code> will contain the size of the returned data.</db:para>
<db:para>This method is useful to e.g. stream the JSON document in it's binary form to a file.</db:para>
</db:section>
<db:section xml:id="setArray">
<db:title>void QJsonDocument::setArray(const QJsonArray &amp;<db:emphasis>array</db:emphasis>)</db:title>
<db:para>Sets <db:code role="parameter">array</db:code> as the main object of this document.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">setObject()</db:link></db:member>
<db:member><db:link xlink:href="qjsondocument.xml#array">array</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toBinaryData">
<db:title>QByteArray QJsonDocument::toBinaryData() const</db:title>
<db:para>Returns a binary representation of the document.</db:para>
<db:para>The binary representation is also the native format used internally in Qt, and is very efficient and fast to convert to and from.</db:para>
<db:para>The binary format can be stored on disk and interchanged with other applications or computers. <db:link xlink:href="qjsondocument.xml#fromBinaryData">fromBinaryData</db:link>() can be used to convert it back into a JSON document.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsondocument.xml#fromBinaryData">fromBinaryData</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJson">
<db:title>QByteArray QJsonDocument::toJson(QJsonDocument::JsonFormat <db:emphasis>format</db:emphasis> = Indented) const</db:title>
<db:para>Converts the <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link> to a UTF-8 encoded JSON document in the provided <db:code role="parameter">format</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qjsondocument.xml#fromJson">fromJson</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#JsonFormat-enum">JsonFormat</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toVariant">
<db:title>int QJsonDocument::toVariant() const</db:title>
<db:para>Returns a <db:link xlink:href="qvariant.xml">QVariant</db:link> representing the Json document.</db:para>
<db:para>The returned variant will be a <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> if the document is a <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link> and a <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> if the document is a <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">fromVariant()</db:link></db:member>
<db:member><db:link xlink:href="qjsonvalue.xml#toVariant">QJsonValue::toVariant</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QJsonDocument::operator!=(const QJsonDocument &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>returns true if <db:code role="parameter">other</db:code> is not equal to this document</db:para>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QJsonDocument &amp;QJsonDocument::operator=(const QJsonDocument &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Assigns the <db:code role="parameter">other</db:code> document to this <db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link>. Returns a reference to this object.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QJsonDocument::operator==(const QJsonDocument &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns true if the <db:code role="parameter">other</db:code> document is equal to this document.</db:para>
</db:section>
</db:section>
</db:article>
