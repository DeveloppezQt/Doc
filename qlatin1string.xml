<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QLatin1String Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link> class provides a thin wrapper around an US-ASCII/Latin-1 encoded string literal.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QLatin1String</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QLatin1String is part of <db:simplelist><db:member>string-processing</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Many of <db:link xlink:href="qstring.xml">QString</db:link>'s member functions are overloaded to accept <db:code>const char *</db:code> instead of <db:link xlink:href="qstring.xml">QString</db:link>. This includes the copy constructor, the assignment operator, the comparison operators, and various other functions such as <db:link xlink:href="qstring.xml#insert">insert</db:link>(), <db:link xlink:href="qstring.xml#replace">replace</db:link>(), and <db:link xlink:href="qstring.xml#indexOf">indexOf</db:link>(). These functions are usually optimized to avoid constructing a <db:link xlink:href="qstring.xml">QString</db:link> object for the <db:code>const char *</db:code> data. For example, assuming <db:code>str</db:code> is a <db:link xlink:href="qstring.xml">QString</db:link>,</db:para>
<db:programlisting language="cpp">if (str == &quot;auto&quot; || str == &quot;extern&quot;
        || str == &quot;static&quot; || str == &quot;register&quot;) {
    ...
}
</db:programlisting>
<db:para>is much faster than</db:para>
<db:programlisting language="cpp">if (str == QString(&quot;auto&quot;) || str == QString(&quot;extern&quot;)
        || str == QString(&quot;static&quot;) || str == QString(&quot;register&quot;)) {
    ...
}
</db:programlisting>
<db:para>because it doesn't construct four temporary <db:link xlink:href="qstring.xml">QString</db:link> objects and make a deep copy of the character data.</db:para>
<db:para>Applications that define <db:code>QT_NO_CAST_FROM_ASCII</db:code> (as explained in the <db:link xlink:href="qstring.xml">QString</db:link> documentation) don't have access to <db:link xlink:href="qstring.xml">QString</db:link>'s <db:code>const char *</db:code> API. To provide an efficient way of specifying constant Latin-1 strings, Qt provides the <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>, which is just a very thin wrapper around a <db:code>const char *</db:code>. Using <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>, the example code above becomes</db:para>
<db:programlisting language="cpp">if (str == QLatin1String(&quot;auto&quot;)
        || str == QLatin1String(&quot;extern&quot;)
        || str == QLatin1String(&quot;static&quot;)
        || str == QLatin1String(&quot;register&quot;) {
    ...
}
</db:programlisting>
<db:para>This is a bit longer to type, but it provides exactly the same benefits as the first version of the code, and is faster than converting the Latin-1 strings using <db:link xlink:href="qstring.xml#fromLatin1">QString::fromLatin1</db:link>().</db:para>
<db:para>Thanks to the <db:link xlink:href="qstring.xml">QString</db:link>(<db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>) constructor, <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link> can be used everywhere a <db:link xlink:href="qstring.xml">QString</db:link> is expected. For example:</db:para>
<db:programlisting language="cpp">QLabel *label = new QLabel(QLatin1String(&quot;MOD&quot;), this);
</db:programlisting>
<db:note>
<db:para>If the function you're calling with a <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link> argument isn't actually overloaded to take <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link>, the implicit conversion to <db:link xlink:href="qstring.xml">QString</db:link> will trigger a memory allocation, which is usually what you want to avoid by using <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link> in the first place. In those cases, using <db:link xlink:href="qstring.xml#QStringLiteral">QStringLiteral</db:link> may be the better option.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qstring.xml">QString</db:link></db:member>
<db:member><db:link xlink:href="qlatin1char.xml">QLatin1Char</db:link></db:member>
<db:member><db:link xlink:href="qstring.xml#QStringLiteral">QStringLiteral</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QLatin1String">
<db:title>[noexcept, since 5.6] QLatin1String::QLatin1String()</db:title>
<db:para>Constructs a <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link> object that stores a nullptr.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="QLatin1String-1">
<db:title>[explicit noexcept] QLatin1String::QLatin1String(const QByteArray &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link> object that stores <db:code role="parameter">str</db:code>.</db:para>
<db:para>The string data is <db:emphasis>not</db:emphasis> copied. The caller must be able to guarantee that <db:code role="parameter">str</db:code> will not be deleted or modified as long as the <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link> object exists.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1string.xml#latin1">latin1</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QLatin1String-2">
<db:title>[explicit noexcept] QLatin1String::QLatin1String(const char *<db:emphasis>str</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link> object that stores <db:code role="parameter">str</db:code>.</db:para>
<db:para>The string data is <db:emphasis>not</db:emphasis> copied. The caller must be able to guarantee that <db:code role="parameter">str</db:code> will not be deleted or modified as long as the <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link> object exists.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1string.xml#latin1">latin1</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QLatin1String-3">
<db:title>[explicit noexcept] QLatin1String::QLatin1String(const char *<db:emphasis>str</db:emphasis>, int <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link> object that stores <db:code role="parameter">str</db:code> with <db:code role="parameter">size</db:code>.</db:para>
<db:para>The string data is <db:emphasis>not</db:emphasis> copied. The caller must be able to guarantee that <db:code role="parameter">str</db:code> will not be deleted or modified as long as the <db:link xlink:href="qlatin1string.xml">QLatin1String</db:link> object exists.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlatin1string.xml#latin1">latin1</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>[noexcept] const char *QLatin1String::data() const</db:title>
<db:para>Returns the Latin-1 string stored in this object.</db:para>
</db:section>
<db:section xml:id="latin1">
<db:title>[noexcept] const char *QLatin1String::latin1() const</db:title>
<db:para>Returns the Latin-1 string stored in this object.</db:para>
</db:section>
<db:section xml:id="size">
<db:title>[noexcept] int QLatin1String::size() const</db:title>
<db:para>Returns the size of the Latin-1 string stored in this object.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>[noexcept] bool QLatin1String::operator!=(const QString &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this string is not equal to string <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with <db:link xlink:href="qstring.xml#localeAwareCompare">QString::localeAwareCompare</db:link>().</db:para>
</db:section>
<db:section xml:id="operator-not-eq-1">
<db:title>[since 5.0] bool QLatin1String::operator!=(const QByteArray &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>This function overloads <db:link xlink:href="qlatin1string.xml#operator-not-eq">operator!=</db:link>().</db:para>
<db:para>The <db:code role="parameter">other</db:code> byte array is converted to a <db:link xlink:href="qstring.xml">QString</db:link> using the <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>() function.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="operator-not-eq-2">
<db:title>[since 4.3] bool QLatin1String::operator!=(const char *<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>This function overloads <db:link xlink:href="qlatin1string.xml#operator-not-eq">operator!=</db:link>().</db:para>
<db:para>The <db:code role="parameter">other</db:code> const char pointer is converted to a <db:link xlink:href="qstring.xml">QString</db:link> using the <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>() function.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
</db:section>
<db:section xml:id="operator-lt">
<db:title>[noexcept] bool QLatin1String::operator&lt;(const QString &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this string is lexically less than the <db:code role="parameter">other</db:code> string; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings using the <db:link xlink:href="qstring.xml#localeAwareCompare">QString::localeAwareCompare</db:link>() function.</db:para>
</db:section>
<db:section xml:id="operator-lt-1">
<db:title>[since 5.0] bool QLatin1String::operator&lt;(const QByteArray &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">other</db:code> const char pointer is converted to a <db:link xlink:href="qstring.xml">QString</db:link> using the <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>() function.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="operator-lt-2">
<db:title>[since 4.3] bool QLatin1String::operator&lt;(const char *<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">other</db:code> const char pointer is converted to a <db:link xlink:href="qstring.xml">QString</db:link> using the <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>() function.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq">
<db:title>[noexcept] bool QLatin1String::operator&lt;=(const QString &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this string is lexically less than or equal to string <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with <db:link xlink:href="qstring.xml#localeAwareCompare">QString::localeAwareCompare</db:link>().</db:para>
</db:section>
<db:section xml:id="operator-lt-eq-1">
<db:title>[since 5.0] bool QLatin1String::operator&lt;=(const QByteArray &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">other</db:code> array is converted to a <db:link xlink:href="qstring.xml">QString</db:link> using the <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>() function.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq-2">
<db:title>[since 4.3] bool QLatin1String::operator&lt;=(const char *<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">other</db:code> const char pointer is converted to a <db:link xlink:href="qstring.xml">QString</db:link> using the <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>() function.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>[noexcept] bool QLatin1String::operator==(const QString &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this string is equal to string <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with <db:link xlink:href="qstring.xml#localeAwareCompare">QString::localeAwareCompare</db:link>().</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-1">
<db:title>[since 5.0] bool QLatin1String::operator==(const QByteArray &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">other</db:code> byte array is converted to a <db:link xlink:href="qstring.xml">QString</db:link> using the <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>() function.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-2">
<db:title>[since 4.3] bool QLatin1String::operator==(const char *<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">other</db:code> const char pointer is converted to a <db:link xlink:href="qstring.xml">QString</db:link> using the <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>() function.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
</db:section>
<db:section xml:id="operator-gt">
<db:title>[noexcept] bool QLatin1String::operator&gt;(const QString &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this string is lexically greater than string <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with <db:link xlink:href="qstring.xml#localeAwareCompare">QString::localeAwareCompare</db:link>().</db:para>
</db:section>
<db:section xml:id="operator-gt-1">
<db:title>[since 5.0] bool QLatin1String::operator&gt;(const QByteArray &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">other</db:code> const char pointer is converted to a <db:link xlink:href="qstring.xml">QString</db:link> using the <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>() function.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="operator-gt-2">
<db:title>[since 4.3] bool QLatin1String::operator&gt;(const char *<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">other</db:code> const char pointer is converted to a <db:link xlink:href="qstring.xml">QString</db:link> using the <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>() function.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq">
<db:title>[noexcept] bool QLatin1String::operator&gt;=(const QString &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>Returns <db:code>true</db:code> if this string is lexically greater than or equal to string <db:code role="parameter">other</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with <db:link xlink:href="qstring.xml#localeAwareCompare">QString::localeAwareCompare</db:link>().</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-1">
<db:title>[since 5.0] bool QLatin1String::operator&gt;=(const QByteArray &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">other</db:code> array is converted to a <db:link xlink:href="qstring.xml">QString</db:link> using the <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>() function.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-2">
<db:title>[since 4.3] bool QLatin1String::operator&gt;=(const char *<db:emphasis>other</db:emphasis>) const</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>The <db:code role="parameter">other</db:code> const char pointer is converted to a <db:link xlink:href="qstring.xml">QString</db:link> using the <db:link xlink:href="qstring.xml#fromUtf8">QString::fromUtf8</db:link>() function.</db:para>
<db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through <db:link xlink:href="qobject.xml#tr">QObject::tr</db:link>(), for example.</db:para>
<db:para>This function was introduced in Qt 4.3.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="operator-not-eq-3">
<db:title>[noexcept] bool operator!=(QLatin1String <db:emphasis>s1</db:emphasis>, QLatin1String <db:emphasis>s2</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">s1</db:code> is lexically unequal to string <db:code role="parameter">s2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-3">
<db:title>[noexcept] bool operator&lt;(QLatin1String <db:emphasis>s1</db:emphasis>, QLatin1String <db:emphasis>s2</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">s1</db:code> is lexically smaller than string <db:code role="parameter">s2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-lt-eq-3">
<db:title>[noexcept] bool operator&lt;=(QLatin1String <db:emphasis>s1</db:emphasis>, QLatin1String <db:emphasis>s2</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">s1</db:code> is lexically smaller than or equal to string <db:code role="parameter">s2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq-3">
<db:title>[noexcept] bool operator==(QLatin1String <db:emphasis>s1</db:emphasis>, QLatin1String <db:emphasis>s2</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">s1</db:code> is lexically equal to string <db:code role="parameter">s2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-3">
<db:title>[noexcept] bool operator&gt;(QLatin1String <db:emphasis>s1</db:emphasis>, QLatin1String <db:emphasis>s2</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">s1</db:code> is lexically greater than string <db:code role="parameter">s2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-gt-eq-3">
<db:title>[noexcept] bool operator&gt;=(QLatin1String <db:emphasis>s1</db:emphasis>, QLatin1String <db:emphasis>s2</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if string <db:code role="parameter">s1</db:code> is lexically greater than or equal to string <db:code role="parameter">s2</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
</db:section>
</db:section>
</db:article>
