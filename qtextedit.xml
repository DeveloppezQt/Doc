<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QTextEdit Class</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> class provides a widget that is used to edit and display both plain and rich text.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QTextEdit</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Widgets)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Widgets)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += widgets</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qabstractscrollarea.xml" xlink:role="class">QAbstractScrollArea</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qtextbrowser.xml" xlink:role="class">QTextBrowser</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QTextEdit is part of <db:simplelist><db:member>richtext-processing</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:section xml:id="introduction-and-concepts">
<db:title>Introduction and Concepts</db:title>
<db:para><db:link xlink:href="qtextedit.xml">QTextEdit</db:link> is an advanced WYSIWYG viewer/editor supporting rich text formatting using HTML-style tags, or Markdown format. It is optimized to handle large documents and to respond quickly to user input.</db:para>
<db:para><db:link xlink:href="qtextedit.xml">QTextEdit</db:link> works on paragraphs and characters. A paragraph is a formatted string which is word-wrapped to fit into the width of the widget. By default when reading plain text, one newline signifies a paragraph. A document consists of zero or more paragraphs. The words in the paragraph are aligned in accordance with the paragraph's alignment. Paragraphs are separated by hard line breaks. Each character within a paragraph has its own attributes, for example, font and color.</db:para>
<db:para><db:link xlink:href="qtextedit.xml">QTextEdit</db:link> can display images, lists and tables. If the text is too large to view within the text edit's viewport, scroll bars will appear. The text edit can load both plain text and rich text files. Rich text can be described using a subset of HTML 4 markup; refer to the <db:link xlink:href="richtext-html-subset.xml">Supported HTML Subset</db:link> page for more information.</db:para>
<db:para>If you just need to display a small piece of rich text use <db:link xlink:href="qlabel.xml">QLabel</db:link>.</db:para>
<db:para>The rich text support in Qt is designed to provide a fast, portable and efficient way to add reasonable online help facilities to applications, and to provide a basis for rich text editors. If you find the HTML support insufficient for your needs you may consider the use of Qt WebKit, which provides a full-featured web browser widget.</db:para>
<db:para>The shape of the mouse cursor on a <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> is <db:link xlink:href="qt.xml#CursorShape-enum">Qt::IBeamCursor</db:link> by default. It can be changed through the <db:link xlink:href="qabstractscrollarea.xml#viewport">viewport</db:link>()'s cursor property.</db:para>
</db:section>
<db:section xml:id="using-qtextedit-as-a-display-widget">
<db:title>Using QTextEdit as a Display Widget</db:title>
<db:para><db:link xlink:href="qtextedit.xml">QTextEdit</db:link> can display a large HTML subset, including tables and images.</db:para>
<db:para>The text can be set or replaced using <db:link xlink:href="qtextedit.xml#html-prop">setHtml</db:link>() which deletes any existing text and replaces it with the text passed in the <db:link xlink:href="qtextedit.xml#html-prop">setHtml</db:link>() call. If you call <db:link xlink:href="qtextedit.xml#html-prop">setHtml</db:link>() with legacy HTML, and then call <db:link xlink:href="qtextedit.xml#html-prop">toHtml</db:link>(), the text that is returned may have different markup, but will render the same. The entire text can be deleted with <db:link xlink:href="qtextedit.xml#clear">clear</db:link>().</db:para>
<db:para>Text can also be set or replaced using <db:link xlink:href="qtextedit.xml#markdown-prop">setMarkdown</db:link>(), and the same caveats apply: if you then call <db:link xlink:href="qtextedit.xml#markdown-prop">toMarkdown</db:link>(), the text that is returned may be different, but the meaning is preserved as much as possible. Markdown with some embedded HTML can be parsed, with the same limitations that <db:link xlink:href="qtextedit.xml#html-prop">setHtml</db:link>() has; but <db:link xlink:href="qtextedit.xml#markdown-prop">toMarkdown</db:link>() only writes &quot;pure&quot; Markdown, without any embedded HTML.</db:para>
<db:para>Text itself can be inserted using the <db:link xlink:href="qtextcursor.xml">QTextCursor</db:link> class or using the convenience functions <db:link xlink:href="qtextedit.xml#insertHtml">insertHtml</db:link>(), <db:link xlink:href="qtextedit.xml#insertPlainText">insertPlainText</db:link>(), <db:link xlink:href="qtextedit.xml#append">append</db:link>() or <db:link xlink:href="qtextedit.xml#paste">paste</db:link>(). <db:link xlink:href="qtextcursor.xml">QTextCursor</db:link> is also able to insert complex objects like tables or lists into the document, and it deals with creating selections and applying changes to selected text.</db:para>
<db:para>By default the text edit wraps words at whitespace to fit within the text edit widget. The <db:link xlink:href="qtextedit.xml#lineWrapMode-prop">setLineWrapMode</db:link>() function is used to specify the kind of line wrap you want, or <db:link xlink:href="qtextedit.xml#LineWrapMode-enum">NoWrap</db:link> if you don't want any wrapping. Call <db:link xlink:href="qtextedit.xml#lineWrapMode-prop">setLineWrapMode</db:link>() to set a fixed pixel width <db:link xlink:href="qtextedit.xml#LineWrapMode-enum">FixedPixelWidth</db:link>, or character column (e.g. 80 column) <db:link xlink:href="qtextedit.xml#LineWrapMode-enum">FixedColumnWidth</db:link> with the pixels or columns specified with <db:link xlink:href="qtextedit.xml#lineWrapColumnOrWidth-prop">setLineWrapColumnOrWidth</db:link>(). If you use word wrap to the widget's width <db:link xlink:href="qtextedit.xml#LineWrapMode-enum">WidgetWidth</db:link>, you can specify whether to break on whitespace or anywhere with <db:link xlink:href="qtextedit.xml#wordWrapMode-prop">setWordWrapMode</db:link>().</db:para>
<db:para>The <db:link xlink:href="qtextedit.xml#find">find</db:link>() function can be used to find and select a given string within the text.</db:para>
<db:para>If you want to limit the total number of paragraphs in a <db:link xlink:href="qtextedit.xml">QTextEdit</db:link>, as for example it is often useful in a log viewer, then you can use <db:link xlink:href="qtextdocument.xml">QTextDocument</db:link>'s maximumBlockCount property for that.</db:para>
<db:section xml:id="read-only-key-bindings">
<db:title>Read-only Key Bindings</db:title>
<db:para>When <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Keypresses</db:para>
</db:th>
<db:th>
<db:para>Action</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Up</db:para>
</db:td>
<db:td>
<db:para>Moves one line up.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Down</db:para>
</db:td>
<db:td>
<db:para>Moves one line down.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Left</db:para>
</db:td>
<db:td>
<db:para>Moves one character to the left.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Right</db:para>
</db:td>
<db:td>
<db:para>Moves one character to the right.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>PageUp</db:para>
</db:td>
<db:td>
<db:para>Moves one (viewport) page up.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>PageDown</db:para>
</db:td>
<db:td>
<db:para>Moves one (viewport) page down.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Home</db:para>
</db:td>
<db:td>
<db:para>Moves to the beginning of the text.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>End</db:para>
</db:td>
<db:td>
<db:para>Moves to the end of the text.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Alt+Wheel</db:para>
</db:td>
<db:td>
<db:para>Scrolls the page horizontally (the Wheel is the mouse wheel).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+Wheel</db:para>
</db:td>
<db:td>
<db:para>Zooms the text.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+A</db:para>
</db:td>
<db:td>
<db:para>Selects all text.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The text edit may be able to provide some meta-information. For example, the <db:link xlink:href="qtextedit.xml#documentTitle-prop">documentTitle</db:link>() function will return the text from within HTML &lt;title&gt; tags.</db:para>
<db:note>
<db:para>Zooming into HTML documents only works if the font-size is not set to a fixed size.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="using-qtextedit-as-an-editor">
<db:title>Using QTextEdit as an Editor</db:title>
<db:para>All the information about using <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> as a display widget also applies here.</db:para>
<db:para>The current char format's attributes are set with <db:link xlink:href="qtextedit.xml#setFontItalic">setFontItalic</db:link>(), <db:link xlink:href="qtextedit.xml#setFontWeight">setFontWeight</db:link>(), <db:link xlink:href="qtextedit.xml#setFontUnderline">setFontUnderline</db:link>(), <db:link xlink:href="qtextedit.xml#setFontFamily">setFontFamily</db:link>(), <db:link xlink:href="qtextedit.xml#setFontPointSize">setFontPointSize</db:link>(), <db:link xlink:href="qtextedit.xml#setTextColor">setTextColor</db:link>() and <db:link xlink:href="qtextedit.xml#setCurrentFont">setCurrentFont</db:link>(). The current paragraph's alignment is set with <db:link xlink:href="qtextedit.xml#setAlignment">setAlignment</db:link>().</db:para>
<db:para>Selection of text is handled by the <db:link xlink:href="qtextcursor.xml">QTextCursor</db:link> class, which provides functionality for creating selections, retrieving the text contents or deleting selections. You can retrieve the object that corresponds with the user-visible cursor using the <db:link xlink:href="qtextedit.xml#textCursor">textCursor</db:link>() method. If you want to set a selection in <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> just create one on a <db:link xlink:href="qtextcursor.xml">QTextCursor</db:link> object and then make that cursor the visible cursor using <db:link xlink:href="qtextedit.xml#setTextCursor">setTextCursor</db:link>(). The selection can be copied to the clipboard with <db:link xlink:href="qtextedit.xml#copy">copy</db:link>(), or cut to the clipboard with <db:link xlink:href="qtextedit.xml#cut">cut</db:link>(). The entire text can be selected using <db:link xlink:href="qtextedit.xml#selectAll">selectAll</db:link>().</db:para>
<db:para>When the cursor is moved and the underlying formatting attributes change, the <db:link xlink:href="qtextedit.xml#currentCharFormatChanged">currentCharFormatChanged</db:link>() signal is emitted to reflect the new attributes at the new cursor position.</db:para>
<db:para>The <db:link xlink:href="qtextedit.xml#textChanged">textChanged</db:link>() signal is emitted whenever the text changes (as a result of <db:link xlink:href="qtextedit.xml#setText">setText</db:link>() or through the editor itself).</db:para>
<db:para><db:link xlink:href="qtextedit.xml">QTextEdit</db:link> holds a <db:link xlink:href="qtextdocument.xml">QTextDocument</db:link> object which can be retrieved using the <db:link xlink:href="qtextedit.xml#document-prop">document</db:link>() method. You can also set your own document object using <db:link xlink:href="qtextedit.xml#document-prop">setDocument</db:link>().</db:para>
<db:para><db:link xlink:href="qtextdocument.xml">QTextDocument</db:link> provides an <db:link xlink:href="qtextdocument.xml#modified-prop">isModified</db:link>() function which will return true if the text has been modified since it was either loaded or since the last call to setModified with false as argument. In addition it provides methods for undo and redo.</db:para>
<db:section xml:id="drag-and-drop">
<db:title>Drag and Drop</db:title>
<db:para><db:link xlink:href="qtextedit.xml">QTextEdit</db:link> also supports custom drag and drop behavior. By default, <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> will insert plain text, HTML and rich text when the user drops data of these MIME types onto a document. Reimplement <db:link xlink:href="qtextedit.xml#canInsertFromMimeData">canInsertFromMimeData</db:link>() and <db:link xlink:href="qtextedit.xml#insertFromMimeData">insertFromMimeData</db:link>() to add support for additional MIME types.</db:para>
<db:para>For example, to allow the user to drag and drop an image onto a <db:link xlink:href="qtextedit.xml">QTextEdit</db:link>, you could the implement these functions in the following way:</db:para>
<db:programlisting language="cpp">bool TextEdit::canInsertFromMimeData( const QMimeData *source ) const
{
    if (source-&gt;hasImage())
        return true;
    else
        return QTextEdit::canInsertFromMimeData(source);
}
</db:programlisting>
<db:para>We add support for image MIME types by returning true. For all other MIME types, we use the default implementation.</db:para>
<db:programlisting language="cpp">void TextEdit::insertFromMimeData( const QMimeData *source )
{
    if (source-&gt;hasImage())
    {
        QImage image = qvariant_cast&lt;QImage&gt;(source-&gt;imageData());
        QTextCursor cursor = this-&gt;textCursor();
        QTextDocument *document = this-&gt;document();
        document-&gt;addResource(QTextDocument::ImageResource, QUrl(&quot;image&quot;), image);
        cursor.insertImage(&quot;image&quot;);
    }
}
</db:programlisting>
<db:para>We unpack the image from the <db:link xlink:href="qvariant.xml">QVariant</db:link> held by the MIME source and insert it into the document as a resource.</db:para>
</db:section>
<db:section xml:id="editing-key-bindings">
<db:title>Editing Key Bindings</db:title>
<db:para>The list of key bindings which are implemented for editing:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Keypresses</db:para>
</db:th>
<db:th>
<db:para>Action</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Backspace</db:para>
</db:td>
<db:td>
<db:para>Deletes the character to the left of the cursor.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Delete</db:para>
</db:td>
<db:td>
<db:para>Deletes the character to the right of the cursor.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+C</db:para>
</db:td>
<db:td>
<db:para>Copy the selected text to the clipboard.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+Insert</db:para>
</db:td>
<db:td>
<db:para>Copy the selected text to the clipboard.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+K</db:para>
</db:td>
<db:td>
<db:para>Deletes to the end of the line.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+V</db:para>
</db:td>
<db:td>
<db:para>Pastes the clipboard text into text edit.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Shift+Insert</db:para>
</db:td>
<db:td>
<db:para>Pastes the clipboard text into text edit.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+X</db:para>
</db:td>
<db:td>
<db:para>Deletes the selected text and copies it to the clipboard.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Shift+Delete</db:para>
</db:td>
<db:td>
<db:para>Deletes the selected text and copies it to the clipboard.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+Z</db:para>
</db:td>
<db:td>
<db:para>Undoes the last operation.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+Y</db:para>
</db:td>
<db:td>
<db:para>Redoes the last operation.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Left</db:para>
</db:td>
<db:td>
<db:para>Moves the cursor one character to the left.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+Left</db:para>
</db:td>
<db:td>
<db:para>Moves the cursor one word to the left.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Right</db:para>
</db:td>
<db:td>
<db:para>Moves the cursor one character to the right.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+Right</db:para>
</db:td>
<db:td>
<db:para>Moves the cursor one word to the right.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Up</db:para>
</db:td>
<db:td>
<db:para>Moves the cursor one line up.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Down</db:para>
</db:td>
<db:td>
<db:para>Moves the cursor one line down.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>PageUp</db:para>
</db:td>
<db:td>
<db:para>Moves the cursor one page up.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>PageDown</db:para>
</db:td>
<db:td>
<db:para>Moves the cursor one page down.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Home</db:para>
</db:td>
<db:td>
<db:para>Moves the cursor to the beginning of the line.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+Home</db:para>
</db:td>
<db:td>
<db:para>Moves the cursor to the beginning of the text.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>End</db:para>
</db:td>
<db:td>
<db:para>Moves the cursor to the end of the line.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Ctrl+End</db:para>
</db:td>
<db:td>
<db:para>Moves the cursor to the end of the text.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Alt+Wheel</db:para>
</db:td>
<db:td>
<db:para>Scrolls the page horizontally (the Wheel is the mouse wheel).</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>To select (mark) text hold down the Shift key whilst pressing one of the movement keystrokes, for example, <db:emphasis>Shift+Right</db:emphasis> will select the character to the right, and <db:emphasis>Shift+Ctrl+Right</db:emphasis> will select the word to the right, etc.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextdocument.xml">QTextDocument</db:link></db:member>
<db:member><db:link xlink:href="qtextcursor.xml">QTextCursor</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-richtext-syntaxhighlighter-example.xml">Syntax Highlighter Example</db:link></db:member>
<db:member><db:link xlink:href="richtext.xml">Rich Text Processing</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="AutoFormattingFlag-enum">
<db:title>enum QTextEdit::AutoFormattingFlag</db:title>
<db:bridgehead renderas="sect2">flags QTextEdit::AutoFormatting</db:bridgehead>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtextedit.xml">QTextEdit</db:link></db:emphasis>::AutoNone</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Don't do any automatic formatting.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtextedit.xml">QTextEdit</db:link></db:emphasis>::AutoBulletList</db:code></db:para>
</db:td>
<db:td><db:code>0x00000001</db:code></db:td>
<db:td>
<db:para>Automatically create bullet lists (e.g. when the user enters an asterisk ('*') in the left most column, or presses Enter in an existing list item.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtextedit.xml">QTextEdit</db:link></db:emphasis>::AutoAll</db:code></db:para>
</db:td>
<db:td><db:code>0xffffffff</db:code></db:td>
<db:td>
<db:para>Apply all automatic formatting. Currently only automatic bullet lists are supported.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>AutoFormatting</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;AutoFormattingFlag&gt;. </db:code>It stores an OR combination of <db:code>AutoFormattingFlag</db:code> values.</db:para>
</db:section>
<db:section xml:id="LineWrapMode-enum">
<db:title>enum QTextEdit::LineWrapMode</db:title>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtextedit.xml">QTextEdit</db:link></db:emphasis>::NoWrap</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtextedit.xml">QTextEdit</db:link></db:emphasis>::WidgetWidth</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtextedit.xml">QTextEdit</db:link></db:emphasis>::FixedPixelWidth</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtextedit.xml">QTextEdit</db:link></db:emphasis>::FixedColumnWidth</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="acceptRichText-prop">
<db:title>acceptRichText : bool</db:title>
<db:para>This property holds whether the text edit accepts rich text insertions by the user</db:para>
<db:para>When this property is set to false text edit will accept only plain text input from the user. For example through clipboard or drag and drop.</db:para>
<db:para>This property's default is true.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">acceptRichText</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setAcceptRichText</db:emphasis>(<db:type>bool</db:type> <db:emphasis>accept</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="autoFormatting-prop">
<db:title>autoFormatting : AutoFormatting</db:title>
<db:para>This property holds the enabled set of auto formatting features</db:para>
<db:para>The value can be any combination of the values in the <db:link xlink:href="qtextedit.xml#AutoFormattingFlag-enum">AutoFormattingFlag</db:link> enum. The default is <db:link xlink:href="qtextedit.xml#AutoFormattingFlag-enum">AutoNone</db:link>. Choose <db:link xlink:href="qtextedit.xml#AutoFormattingFlag-enum">AutoAll</db:link> to enable all automatic formatting.</db:para>
<db:para>Currently, the only automatic formatting feature provided is <db:link xlink:href="qtextedit.xml#AutoFormattingFlag-enum">AutoBulletList</db:link>; future versions of Qt may offer more.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qtextedit.xml#AutoFormattingFlag-enum">QTextEdit::AutoFormatting</db:link></db:type> <db:emphasis role="bold">autoFormatting</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setAutoFormatting</db:emphasis>(<db:type><db:link xlink:href="qtextedit.xml#AutoFormattingFlag-enum">QTextEdit::AutoFormatting</db:link></db:type> <db:emphasis>features</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="cursorWidth-prop">
<db:title>cursorWidth : int</db:title>
<db:para>This property specifies the width of the cursor in pixels. The default value is 1.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">cursorWidth</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setCursorWidth</db:emphasis>(<db:type>int</db:type> <db:emphasis>width</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="document-prop">
<db:title>document : QTextDocument*</db:title>
<db:para>This property holds the underlying document of the text editor.</db:para>
<db:note>
<db:para>The editor <db:emphasis>does not take ownership of the document</db:emphasis> unless it is the document's parent object. The parent object of the provided document remains the owner of the object. If the previously assigned document is a child of the editor then it will be deleted.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qtextdocument.xml">QTextDocument</db:link></db:type> *<db:emphasis role="bold">document</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setDocument</db:emphasis>(<db:type><db:link xlink:href="qtextdocument.xml">QTextDocument</db:link></db:type> *<db:emphasis>document</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="documentTitle-prop">
<db:title>documentTitle : QString</db:title>
<db:para>This property holds the title of the document parsed from the text.</db:para>
<db:para>By default, for a newly-created, empty document, this property contains an empty string.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">documentTitle</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setDocumentTitle</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>title</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="html-prop">
<db:title>html : QString</db:title>
<db:para>This property provides an HTML interface to the text of the text edit.</db:para>
<db:para>toHtml() returns the text of the text edit as html.</db:para>
<db:para>setHtml() changes the text of the text edit. Any previous text is removed and the undo/redo history is cleared. The input text is interpreted as rich text in html format. <db:link xlink:href="qtextedit.xml#currentCharFormat">currentCharFormat</db:link>() is also reset, unless <db:link xlink:href="qtextedit.xml#textCursor">textCursor</db:link>() is already at the beginning of the document.</db:para>
<db:note>
<db:para>It is the responsibility of the caller to make sure that the text is correctly decoded when a <db:link xlink:href="qstring.xml">QString</db:link> containing HTML is created and passed to setHtml().</db:para>
</db:note>
<db:para>By default, for a newly-created, empty document, this property contains text to describe an HTML 4.0 document with no body text.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">toHtml</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setHtml</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>text</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qtextedit.xml#textChanged">textChanged</db:link></db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="richtext-html-subset.xml">Supported HTML Subset</db:link></db:member>
<db:member><db:link xlink:href="qtextedit.xml#plainText-prop">plainText</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lineWrapColumnOrWidth-prop">
<db:title>lineWrapColumnOrWidth : int</db:title>
<db:para>This property holds the position (in pixels or columns depending on the wrap mode) where text will be wrapped</db:para>
<db:para>If the wrap mode is <db:link xlink:href="qtextedit.xml#LineWrapMode-enum">FixedPixelWidth</db:link>, the value is the number of pixels from the left edge of the text edit at which text should be wrapped. If the wrap mode is <db:link xlink:href="qtextedit.xml#LineWrapMode-enum">FixedColumnWidth</db:link>, the value is the column number (in character columns) from the left edge of the text edit at which text should be wrapped.</db:para>
<db:para>By default, this property contains a value of 0.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">lineWrapColumnOrWidth</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setLineWrapColumnOrWidth</db:emphasis>(<db:type>int</db:type> <db:emphasis>w</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#lineWrapMode-prop">lineWrapMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lineWrapMode-prop">
<db:title>lineWrapMode : LineWrapMode</db:title>
<db:para>This property holds the line wrap mode</db:para>
<db:para>The default mode is <db:link xlink:href="qtextedit.xml#LineWrapMode-enum">WidgetWidth</db:link> which causes words to be wrapped at the right edge of the text edit. Wrapping occurs at whitespace, keeping whole words intact. If you want wrapping to occur within words use <db:link xlink:href="qtextedit.xml#wordWrapMode-prop">setWordWrapMode</db:link>(). If you set a wrap mode of <db:link xlink:href="qtextedit.xml#LineWrapMode-enum">FixedPixelWidth</db:link> or <db:link xlink:href="qtextedit.xml#LineWrapMode-enum">FixedColumnWidth</db:link> you should also call <db:link xlink:href="qtextedit.xml#lineWrapColumnOrWidth-prop">setLineWrapColumnOrWidth</db:link>() with the width you want.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qtextedit.xml#LineWrapMode-enum">QTextEdit::LineWrapMode</db:link></db:type> <db:emphasis role="bold">lineWrapMode</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setLineWrapMode</db:emphasis>(<db:type><db:link xlink:href="qtextedit.xml#LineWrapMode-enum">QTextEdit::LineWrapMode</db:link></db:type> <db:emphasis>mode</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#lineWrapColumnOrWidth-prop">lineWrapColumnOrWidth</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="markdown-prop">
<db:title>markdown : QString</db:title>
<db:para>This property provides a Markdown interface to the text of the text edit.</db:para>
<db:para>toMarkdown() returns the text of the text edit as &quot;pure&quot; Markdown, without any embedded HTML formatting. Some features that <db:link xlink:href="qtextdocument.xml">QTextDocument</db:link> supports (such as the use of specific colors and named fonts) cannot be expressed in &quot;pure&quot; Markdown, and they will be omitted.</db:para>
<db:para>setMarkdown() changes the text of the text edit. Any previous text is removed and the undo/redo history is cleared. The input text is interpreted as rich text in Markdown format.</db:para>
<db:para>Parsing of HTML included in the <db:code role="parameter">markdown</db:code> string is handled in the same way as in <db:link xlink:href="qtextedit.xml#html-prop">setHtml</db:link>; however, Markdown formatting inside HTML blocks is not supported.</db:para>
<db:para>Some features of the parser can be enabled or disabled via the <db:code role="parameter">features</db:code> argument:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>MarkdownNoHTML</db:para>
</db:td>
<db:td>
<db:para>Any HTML tags in the Markdown text will be discarded</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>MarkdownDialectCommonMark</db:para>
</db:td>
<db:td>
<db:para>The parser supports only the features standardized by CommonMark</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>MarkdownDialectGitHub</db:para>
</db:td>
<db:td>
<db:para>The parser supports the GitHub dialect</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The default is MarkdownDialectGitHub.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">toMarkdown</db:emphasis>(<db:type><db:link xlink:href="qtextdocument.xml#MarkdownFeature-enum">QTextDocument::MarkdownFeatures</db:link></db:type> <db:emphasis>features</db:emphasis> = QTextDocument::MarkdownDialectGitHub) const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setMarkdown</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>markdown</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qtextedit.xml#textChanged">textChanged</db:link></db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#plainText-prop">plainText</db:link></db:member>
<db:member><db:link xlink:href="qtextedit.xml#html-prop">html</db:link></db:member>
<db:member><db:link xlink:href="qtextdocument.xml#toMarkdown">QTextDocument::toMarkdown</db:link>()</db:member>
<db:member><db:link xlink:href="qtextdocument.xml#setMarkdown">QTextDocument::setMarkdown</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="overwriteMode-prop">
<db:title>overwriteMode : bool</db:title>
<db:para>This property holds whether text entered by the user will overwrite existing text</db:para>
<db:para>As with many text editors, the text editor widget can be configured to insert or overwrite existing text with new text entered by the user.</db:para>
<db:para>If this property is true, existing text is overwritten, character-for-character by new text; otherwise, text is inserted at the cursor position, displacing existing text.</db:para>
<db:para>By default, this property is false (new text does not overwrite existing text).</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">overwriteMode</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setOverwriteMode</db:emphasis>(<db:type>bool</db:type> <db:emphasis>overwrite</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="placeholderText-prop">
<db:title>placeholderText : QString</db:title>
<db:para>This property holds the editor placeholder text</db:para>
<db:para>Setting this property makes the editor display a grayed-out placeholder text as long as the <db:link xlink:href="qtextedit.xml#document-prop">document</db:link>() is empty.</db:para>
<db:para>By default, this property contains an empty string.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold">placeholderText</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setPlaceholderText</db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>placeholderText</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#document-prop">document</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="plainText-prop">
<db:title>plainText : QString</db:title>
<db:para>This property holds the text editor's contents as plain text.</db:para>
<db:para>Previous contents are removed and undo/redo history is reset when the property is set. <db:link xlink:href="qtextedit.xml#currentCharFormat">currentCharFormat</db:link>() is also reset, unless <db:link xlink:href="qtextedit.xml#textCursor">textCursor</db:link>() is already at the beginning of the document.</db:para>
<db:para>If the text edit has another content type, it will not be replaced by plain text if you call <db:link xlink:href="qtextedit.xml#toPlainText">toPlainText</db:link>(). The only exception to this is the non-break space, <db:emphasis>nbsp;</db:emphasis>, that will be converted into standard space.</db:para>
<db:para>By default, for an editor with no contents, this property contains an empty string.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> <db:emphasis role="bold"><db:link xlink:href="qtextedit.xml#toPlainText">toPlainText</db:link></db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qtextedit.xml#setPlainText">setPlainText</db:link></db:emphasis>(const <db:type><db:link xlink:href="qstring.xml">QString</db:link></db:type> &amp;<db:emphasis>text</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#html-prop">html</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readOnly-prop">
<db:title>readOnly : bool</db:title>
<db:para>This property holds whether the text edit is read-only</db:para>
<db:para>In a read-only text edit the user can only navigate through the text and select text; modifying the text is not possible.</db:para>
<db:para>This property's default is false.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isReadOnly</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setReadOnly</db:emphasis>(<db:type>bool</db:type> <db:emphasis>ro</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="tabChangesFocus-prop">
<db:title>tabChangesFocus : bool</db:title>
<db:para>This property holds whether <db:guilabel>Tab</db:guilabel> changes focus or is accepted as input</db:para>
<db:para>In some occasions text edits should not allow the user to input tabulators or change indentation using the <db:guilabel>Tab</db:guilabel> key, as this breaks the focus chain. The default is false.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">tabChangesFocus</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setTabChangesFocus</db:emphasis>(<db:type>bool</db:type> <db:emphasis>b</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="tabStopDistance-prop">
<db:title>tabStopDistance : qreal</db:title>
<db:para>This property holds the tab stop distance in pixels</db:para>
<db:para>By default, this property contains a value of 80 pixels.</db:para>
<db:para>Do not set a value less than the <db:link xlink:href="qfontmetrics.xml#horizontalAdvance">horizontalAdvance</db:link>() of the <db:link xlink:href="qchar.xml#SpecialCharacter-enum">QChar::VisualTabCharacter</db:link> character, otherwise the tab-character will be drawn incompletely.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qttypes.xml#qreal-typedef">qreal</db:link></db:type> <db:emphasis role="bold">tabStopDistance</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setTabStopDistance</db:emphasis>(<db:type><db:link xlink:href="qttypes.xml#qreal-typedef">qreal</db:link></db:type> <db:emphasis>distance</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextoption.xml#Flag-enum">QTextOption::ShowTabsAndSpaces</db:link></db:member>
<db:member><db:link xlink:href="qtextdocument.xml#defaultTextOption">QTextDocument::defaultTextOption</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="textInteractionFlags-prop">
<db:title>textInteractionFlags : Qt::TextInteractionFlags</db:title>
<db:para>Specifies how the widget should interact with user input.</db:para>
<db:para>The default value depends on whether the <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> is read-only or editable, and whether it is a <db:link xlink:href="qtextbrowser.xml">QTextBrowser</db:link> or not.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qt.xml#TextInteractionFlag-enum">Qt::TextInteractionFlags</db:link></db:type> <db:emphasis role="bold">textInteractionFlags</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setTextInteractionFlags</db:emphasis>(<db:type><db:link xlink:href="qt.xml#TextInteractionFlag-enum">Qt::TextInteractionFlags</db:link></db:type> <db:emphasis>flags</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="undoRedoEnabled-prop">
<db:title>undoRedoEnabled : bool</db:title>
<db:para>This property holds whether undo and redo are enabled.</db:para>
<db:para>Users are only able to undo or redo actions if this property is true, and if there is an action that can be undone (or redone).</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isUndoRedoEnabled</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setUndoRedoEnabled</db:emphasis>(<db:type>bool</db:type> <db:emphasis>enable</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="wordWrapMode-prop">
<db:title>wordWrapMode : QTextOption::WrapMode</db:title>
<db:para>This property holds the mode <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> will use when wrapping text by words</db:para>
<db:para>By default, this property is set to <db:link xlink:href="qtextoption.xml#WrapMode-enum">QTextOption::WrapAtWordBoundaryOrAnywhere</db:link>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qtextoption.xml#WrapMode-enum">QTextOption::WrapMode</db:link></db:type> <db:emphasis role="bold">wordWrapMode</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setWordWrapMode</db:emphasis>(<db:type><db:link xlink:href="qtextoption.xml#WrapMode-enum">QTextOption::WrapMode</db:link></db:type> <db:emphasis>policy</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextoption.xml#WrapMode-enum">QTextOption::WrapMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QTextEdit">
<db:title>[explicit] QTextEdit::QTextEdit(QWidget *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:para>Constructs an empty <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> with parent <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="QTextEdit-1">
<db:title>[explicit] QTextEdit::QTextEdit(const QString &amp;<db:emphasis>text</db:emphasis>, QWidget *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:para>Constructs a <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> with parent <db:code role="parameter">parent</db:code>. The text edit will display the text <db:code role="parameter">text</db:code>. The text is interpreted as html.</db:para>
</db:section>
<db:section xml:id="dtor.QTextEdit">
<db:title>[virtual noexcept] QTextEdit::~QTextEdit()</db:title>
<db:para>Destructor.</db:para>
</db:section>
<db:section xml:id="alignment">
<db:title>Qt::Alignment QTextEdit::alignment() const</db:title>
<db:para>Returns the alignment of the current paragraph.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setAlignment">setAlignment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="anchorAt">
<db:title>QString QTextEdit::anchorAt(const QPoint &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:para>Returns the reference of the anchor at position <db:code role="parameter">pos</db:code>, or an empty string if no anchor exists at that point.</db:para>
</db:section>
<db:section xml:id="append">
<db:title>void QTextEdit::append(const QString &amp;<db:emphasis>text</db:emphasis>)</db:title>
<db:para>Appends a new paragraph with <db:code role="parameter">text</db:code> to the end of the text edit.</db:para>
<db:note>
<db:para>The new paragraph appended will have the same character format and block format as the current paragraph, determined by the position of the cursor.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#currentCharFormat">currentCharFormat</db:link>()</db:member>
<db:member><db:link xlink:href="qtextcursor.xml#blockFormat">QTextCursor::blockFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="canInsertFromMimeData">
<db:title>[virtual protected] bool QTextEdit::canInsertFromMimeData(const QMimeData *<db:emphasis>source</db:emphasis>) const</db:title>
<db:para>This function returns true if the contents of the MIME data object, specified by <db:code role="parameter">source</db:code>, can be decoded and inserted into the document. It is called for example when during a drag operation the mouse enters this widget and it is necessary to determine whether it is possible to accept the drag and drop operation.</db:para>
<db:para>Reimplement this function to enable drag and drop support for additional MIME types.</db:para>
</db:section>
<db:section xml:id="canPaste">
<db:title>bool QTextEdit::canPaste() const</db:title>
<db:para>Returns whether text can be pasted from the clipboard into the textedit.</db:para>
</db:section>
<db:section xml:id="changeEvent">
<db:title>[override virtual protected] void QTextEdit::changeEvent(QEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qframe.xml#changeEvent" role="function">QFrame::changeEvent(QEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="clear">
<db:title>void QTextEdit::clear()</db:title>
<db:para>Deletes all the text in the text edit.</db:para>
<db:para>Notes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The undo/redo history is also cleared.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtextedit.xml#currentCharFormat">currentCharFormat</db:link>() is reset, unless <db:link xlink:href="qtextedit.xml#textCursor">textCursor</db:link>() is already at the beginning of the document.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#cut">cut</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setPlainText">setPlainText</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#html-prop">setHtml</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="contextMenuEvent">
<db:title>[override virtual protected] void QTextEdit::contextMenuEvent(QContextMenuEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#contextMenuEvent" role="function">QAbstractScrollArea::contextMenuEvent(QContextMenuEvent *e)</db:link>.</db:para>
<db:para>Shows the standard context menu created with <db:link xlink:href="qtextedit.xml#createStandardContextMenu">createStandardContextMenu</db:link>().</db:para>
<db:para>If you do not want the text edit to have a context menu, you can set its <db:link xlink:href="qwidget.xml#contextMenuPolicy-prop">contextMenuPolicy</db:link> to <db:link xlink:href="qt.xml#ContextMenuPolicy-enum">Qt::NoContextMenu</db:link>. If you want to customize the context menu, reimplement this function. If you want to extend the standard context menu, reimplement this function, call <db:link xlink:href="qtextedit.xml#createStandardContextMenu">createStandardContextMenu</db:link>() and extend the menu returned.</db:para>
<db:para>Information about the event is passed in the <db:code role="parameter">event</db:code> object.</db:para>
<db:programlisting language="cpp">void MyTextEdit::contextMenuEvent(QContextMenuEvent *event)
{
    QMenu *menu = createStandardContextMenu();
    menu-&gt;addAction(tr(&quot;My Menu Item&quot;));
    //...
    menu-&gt;exec(event-&gt;globalPos());
    delete menu;
}
</db:programlisting>
</db:section>
<db:section xml:id="copy">
<db:title>void QTextEdit::copy()</db:title>
<db:para>Copies any selected text to the clipboard.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#copyAvailable">copyAvailable</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="copyAvailable">
<db:title>void QTextEdit::copyAvailable(bool <db:emphasis>yes</db:emphasis>)</db:title>
<db:para>This signal is emitted when text is selected or de-selected in the text edit.</db:para>
<db:para>When text is selected this signal will be emitted with <db:code role="parameter">yes</db:code> set to true. If no text has been selected or if the selected text is de-selected this signal is emitted with <db:code role="parameter">yes</db:code> set to false.</db:para>
<db:para>If <db:code role="parameter">yes</db:code> is true then <db:link xlink:href="qtextedit.xml#copy">copy</db:link>() can be used to copy the selection to the clipboard. If <db:code role="parameter">yes</db:code> is false then <db:link xlink:href="qtextedit.xml#copy">copy</db:link>() does nothing.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#selectionChanged">selectionChanged</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createMimeDataFromSelection">
<db:title>[virtual protected] QMimeData *QTextEdit::createMimeDataFromSelection() const</db:title>
<db:para>This function returns a new MIME data object to represent the contents of the text edit's current selection. It is called when the selection needs to be encapsulated into a new <db:link xlink:href="qmimedata.xml">QMimeData</db:link> object; for example, when a drag and drop operation is started, or when data is copied to the clipboard.</db:para>
<db:para>If you reimplement this function, note that the ownership of the returned <db:link xlink:href="qmimedata.xml">QMimeData</db:link> object is passed to the caller. The selection can be retrieved by using the <db:link xlink:href="qtextedit.xml#textCursor">textCursor</db:link>() function.</db:para>
</db:section>
<db:section xml:id="createStandardContextMenu">
<db:title>QMenu *QTextEdit::createStandardContextMenu()</db:title>
<db:para>This function creates the standard context menu which is shown when the user clicks on the text edit with the right mouse button. It is called from the default <db:link xlink:href="qtextedit.xml#contextMenuEvent">contextMenuEvent</db:link>() handler. The popup menu's ownership is transferred to the caller.</db:para>
<db:para>We recommend that you use the createStandardContextMenu(<db:link xlink:href="qpoint.xml">QPoint</db:link>) version instead which will enable the actions that are sensitive to where the user clicked.</db:para>
</db:section>
<db:section xml:id="createStandardContextMenu-1">
<db:title>QMenu *QTextEdit::createStandardContextMenu(const QPoint &amp;<db:emphasis>position</db:emphasis>)</db:title>
<db:para>This function creates the standard context menu which is shown when the user clicks on the text edit with the right mouse button. It is called from the default <db:link xlink:href="qtextedit.xml#contextMenuEvent">contextMenuEvent</db:link>() handler and it takes the <db:code role="parameter">position</db:code> in document coordinates where the mouse click was. This can enable actions that are sensitive to the position where the user clicked. The popup menu's ownership is transferred to the caller.</db:para>
</db:section>
<db:section xml:id="currentCharFormat">
<db:title>QTextCharFormat QTextEdit::currentCharFormat() const</db:title>
<db:para>Returns the char format that is used when inserting new text.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setCurrentCharFormat">setCurrentCharFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentCharFormatChanged">
<db:title>void QTextEdit::currentCharFormatChanged(const QTextCharFormat &amp;<db:emphasis>f</db:emphasis>)</db:title>
<db:para>This signal is emitted if the current character format has changed, for example caused by a change of the cursor position.</db:para>
<db:para>The new format is <db:code role="parameter">f</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setCurrentCharFormat">setCurrentCharFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentFont">
<db:title>QFont QTextEdit::currentFont() const</db:title>
<db:para>Returns the font of the current format.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setCurrentFont">setCurrentFont</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setFontFamily">setFontFamily</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setFontPointSize">setFontPointSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cursorForPosition">
<db:title>QTextCursor QTextEdit::cursorForPosition(const QPoint &amp;<db:emphasis>pos</db:emphasis>) const</db:title>
<db:para>returns a <db:link xlink:href="qtextcursor.xml">QTextCursor</db:link> at position <db:code role="parameter">pos</db:code> (in viewport coordinates).</db:para>
</db:section>
<db:section xml:id="cursorPositionChanged">
<db:title>void QTextEdit::cursorPositionChanged()</db:title>
<db:para>This signal is emitted whenever the position of the cursor changed.</db:para>
</db:section>
<db:section xml:id="cursorRect">
<db:title>QRect QTextEdit::cursorRect() const</db:title>
<db:para>returns a rectangle (in viewport coordinates) that includes the cursor of the text edit.</db:para>
</db:section>
<db:section xml:id="cursorRect-1">
<db:title>QRect QTextEdit::cursorRect(const QTextCursor &amp;<db:emphasis>cursor</db:emphasis>) const</db:title>
<db:para>returns a rectangle (in viewport coordinates) that includes the <db:code role="parameter">cursor</db:code>.</db:para>
</db:section>
<db:section xml:id="cut">
<db:title>void QTextEdit::cut()</db:title>
<db:para>Copies the selected text to the clipboard and deletes it from the text edit.</db:para>
<db:para>If there is no selected text nothing happens.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#copy">copy</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#paste">paste</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dragEnterEvent">
<db:title>[override virtual protected] void QTextEdit::dragEnterEvent(QDragEnterEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#dragEnterEvent" role="function">QAbstractScrollArea::dragEnterEvent(QDragEnterEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="dragLeaveEvent">
<db:title>[override virtual protected] void QTextEdit::dragLeaveEvent(QDragLeaveEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#dragLeaveEvent" role="function">QAbstractScrollArea::dragLeaveEvent(QDragLeaveEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="dragMoveEvent">
<db:title>[override virtual protected] void QTextEdit::dragMoveEvent(QDragMoveEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#dragMoveEvent" role="function">QAbstractScrollArea::dragMoveEvent(QDragMoveEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="dropEvent">
<db:title>[override virtual protected] void QTextEdit::dropEvent(QDropEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#dropEvent" role="function">QAbstractScrollArea::dropEvent(QDropEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="ensureCursorVisible">
<db:title>void QTextEdit::ensureCursorVisible()</db:title>
<db:para>Ensures that the cursor is visible by scrolling the text edit if necessary.</db:para>
</db:section>
<db:section xml:id="extraSelections">
<db:title>QList&lt;QTextEdit::ExtraSelection&gt; QTextEdit::extraSelections() const</db:title>
<db:para>Returns previously set extra selections.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setExtraSelections">setExtraSelections</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="find">
<db:title>bool QTextEdit::find(const QString &amp;<db:emphasis>exp</db:emphasis>, QTextDocument::FindFlags <db:emphasis>options</db:emphasis> = QTextDocument::FindFlags())</db:title>
<db:para>Finds the next occurrence of the string, <db:code role="parameter">exp</db:code>, using the given <db:code role="parameter">options</db:code>. Returns true if <db:code role="parameter">exp</db:code> was found and changes the cursor to select the match; otherwise returns false.</db:para>
</db:section>
<db:section xml:id="find-1">
<db:title>bool QTextEdit::find(const QRegularExpression &amp;<db:emphasis>exp</db:emphasis>, QTextDocument::FindFlags <db:emphasis>options</db:emphasis> = QTextDocument::FindFlags())</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Finds the next occurrence, matching the regular expression, <db:code role="parameter">exp</db:code>, using the given <db:code role="parameter">options</db:code>.</db:para>
<db:para>Returns true if a match was found and changes the cursor to select the match; otherwise returns false.</db:para>
<db:warning>
<db:para>For historical reasons, the case sensitivity option set on <db:code role="parameter">exp</db:code> is ignored. Instead, the <db:code role="parameter">options</db:code> are used to determine if the search is case sensitive or not.</db:para>
</db:warning>
</db:section>
<db:section xml:id="focusInEvent">
<db:title>[override virtual protected] void QTextEdit::focusInEvent(QFocusEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwidget.xml#focusInEvent" role="function">QWidget::focusInEvent(QFocusEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="focusNextPrevChild">
<db:title>[override virtual protected] bool QTextEdit::focusNextPrevChild(bool <db:emphasis>next</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwidget.xml#focusNextPrevChild" role="function">QWidget::focusNextPrevChild(bool next)</db:link>.</db:para>
</db:section>
<db:section xml:id="focusOutEvent">
<db:title>[override virtual protected] void QTextEdit::focusOutEvent(QFocusEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwidget.xml#focusOutEvent" role="function">QWidget::focusOutEvent(QFocusEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="fontFamily">
<db:title>QString QTextEdit::fontFamily() const</db:title>
<db:para>Returns the font family of the current format.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setFontFamily">setFontFamily</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setCurrentFont">setCurrentFont</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setFontPointSize">setFontPointSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fontItalic">
<db:title>bool QTextEdit::fontItalic() const</db:title>
<db:para>Returns true if the font of the current format is italic; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setFontItalic">setFontItalic</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fontPointSize">
<db:title>qreal QTextEdit::fontPointSize() const</db:title>
<db:para>Returns the point size of the font of the current format.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setFontFamily">setFontFamily</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setCurrentFont">setCurrentFont</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setFontPointSize">setFontPointSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fontUnderline">
<db:title>bool QTextEdit::fontUnderline() const</db:title>
<db:para>Returns true if the font of the current format is underlined; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setFontUnderline">setFontUnderline</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fontWeight">
<db:title>int QTextEdit::fontWeight() const</db:title>
<db:para>Returns the font weight of the current format.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setFontWeight">setFontWeight</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setCurrentFont">setCurrentFont</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setFontPointSize">setFontPointSize</db:link>()</db:member>
<db:member><db:link xlink:href="qfont.xml#Weight-enum">QFont::Weight</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="inputMethodEvent">
<db:title>[override virtual protected] void QTextEdit::inputMethodEvent(QInputMethodEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwidget.xml#inputMethodEvent" role="function">QWidget::inputMethodEvent(QInputMethodEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="inputMethodQuery">
<db:title>[override virtual] QVariant QTextEdit::inputMethodQuery(Qt::InputMethodQuery <db:emphasis>property</db:emphasis>) const</db:title>
<db:para>Reimplements: <db:link xlink:href="qwidget.xml#inputMethodQuery" role="function">QWidget::inputMethodQuery(Qt::InputMethodQuery query) const</db:link>.</db:para>
</db:section>
<db:section xml:id="insertFromMimeData">
<db:title>[virtual protected] void QTextEdit::insertFromMimeData(const QMimeData *<db:emphasis>source</db:emphasis>)</db:title>
<db:para>This function inserts the contents of the MIME data object, specified by <db:code role="parameter">source</db:code>, into the text edit at the current cursor position. It is called whenever text is inserted as the result of a clipboard paste operation, or when the text edit accepts data from a drag and drop operation.</db:para>
<db:para>Reimplement this function to enable drag and drop support for additional MIME types.</db:para>
</db:section>
<db:section xml:id="insertHtml">
<db:title>void QTextEdit::insertHtml(const QString &amp;<db:emphasis>text</db:emphasis>)</db:title>
<db:para>Convenience slot that inserts <db:code role="parameter">text</db:code> which is assumed to be of html formatting at the current cursor position.</db:para>
<db:para>It is equivalent to:</db:para>
<db:programlisting language="cpp">edit-&gt;textCursor().insertHtml(fragment);
</db:programlisting>
<db:note>
<db:para>When using this function with a style sheet, the style sheet will only apply to the current block in the document. In order to apply a style sheet throughout a document, use <db:link xlink:href="qtextdocument.xml#defaultStyleSheet-prop">QTextDocument::setDefaultStyleSheet</db:link>() instead.</db:para>
</db:note>
</db:section>
<db:section xml:id="insertPlainText">
<db:title>void QTextEdit::insertPlainText(const QString &amp;<db:emphasis>text</db:emphasis>)</db:title>
<db:para>Convenience slot that inserts <db:code role="parameter">text</db:code> at the current cursor position.</db:para>
<db:para>It is equivalent to</db:para>
<db:programlisting language="cpp">edit-&gt;textCursor().insertText(text);
</db:programlisting>
</db:section>
<db:section xml:id="keyPressEvent">
<db:title>[override virtual protected] void QTextEdit::keyPressEvent(QKeyEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#keyPressEvent" role="function">QAbstractScrollArea::keyPressEvent(QKeyEvent *e)</db:link>.</db:para>
</db:section>
<db:section xml:id="keyReleaseEvent">
<db:title>[override virtual protected] void QTextEdit::keyReleaseEvent(QKeyEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwidget.xml#keyReleaseEvent" role="function">QWidget::keyReleaseEvent(QKeyEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="loadResource">
<db:title>[virtual] QVariant QTextEdit::loadResource(int <db:emphasis>type</db:emphasis>, const QUrl &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:para>Loads the resource specified by the given <db:code role="parameter">type</db:code> and <db:code role="parameter">name</db:code>.</db:para>
<db:para>This function is an extension of <db:link xlink:href="qtextdocument.xml#loadResource">QTextDocument::loadResource</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextdocument.xml#loadResource">QTextDocument::loadResource</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mergeCurrentCharFormat">
<db:title>void QTextEdit::mergeCurrentCharFormat(const QTextCharFormat &amp;<db:emphasis>modifier</db:emphasis>)</db:title>
<db:para>Merges the properties specified in <db:code role="parameter">modifier</db:code> into the current character format by calling <db:link xlink:href="qtextcursor.xml#mergeCharFormat">QTextCursor::mergeCharFormat</db:link> on the editor's cursor. If the editor has a selection then the properties of <db:code role="parameter">modifier</db:code> are directly applied to the selection.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextcursor.xml#mergeCharFormat">QTextCursor::mergeCharFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseDoubleClickEvent">
<db:title>[override virtual protected] void QTextEdit::mouseDoubleClickEvent(QMouseEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#mouseDoubleClickEvent" role="function">QAbstractScrollArea::mouseDoubleClickEvent(QMouseEvent *e)</db:link>.</db:para>
</db:section>
<db:section xml:id="mouseMoveEvent">
<db:title>[override virtual protected] void QTextEdit::mouseMoveEvent(QMouseEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#mouseMoveEvent" role="function">QAbstractScrollArea::mouseMoveEvent(QMouseEvent *e)</db:link>.</db:para>
</db:section>
<db:section xml:id="mousePressEvent">
<db:title>[override virtual protected] void QTextEdit::mousePressEvent(QMouseEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#mousePressEvent" role="function">QAbstractScrollArea::mousePressEvent(QMouseEvent *e)</db:link>.</db:para>
</db:section>
<db:section xml:id="mouseReleaseEvent">
<db:title>[override virtual protected] void QTextEdit::mouseReleaseEvent(QMouseEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#mouseReleaseEvent" role="function">QAbstractScrollArea::mouseReleaseEvent(QMouseEvent *e)</db:link>.</db:para>
</db:section>
<db:section xml:id="moveCursor">
<db:title>void QTextEdit::moveCursor(QTextCursor::MoveOperation <db:emphasis>operation</db:emphasis>, QTextCursor::MoveMode <db:emphasis>mode</db:emphasis> = QTextCursor::MoveAnchor)</db:title>
<db:para>Moves the cursor by performing the given <db:code role="parameter">operation</db:code>.</db:para>
<db:para>If <db:code role="parameter">mode</db:code> is <db:link xlink:href="qtextcursor.xml#MoveMode-enum">QTextCursor::KeepAnchor</db:link>, the cursor selects the text it moves over. This is the same effect that the user achieves when they hold down the Shift key and move the cursor with the cursor keys.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextcursor.xml#movePosition">QTextCursor::movePosition</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="paintEvent">
<db:title>[override virtual protected] void QTextEdit::paintEvent(QPaintEvent *<db:emphasis>event</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#paintEvent" role="function">QAbstractScrollArea::paintEvent(QPaintEvent *event)</db:link>.</db:para>
<db:para>This event handler can be reimplemented in a subclass to receive paint events passed in <db:code role="parameter">event</db:code>. It is usually unnecessary to reimplement this function in a subclass of <db:link xlink:href="qtextedit.xml">QTextEdit</db:link>.</db:para>
<db:note>
<db:para>If you create a <db:link xlink:href="qpainter.xml">QPainter</db:link>, it must operate on the <db:link xlink:href="qabstractscrollarea.xml#viewport">viewport</db:link>().</db:para>
</db:note>
<db:warning>
<db:para>The underlying text document must not be modified from within a reimplementation of this function.</db:para>
</db:warning>
</db:section>
<db:section xml:id="paste">
<db:title>void QTextEdit::paste()</db:title>
<db:para>Pastes the text from the clipboard into the text edit at the current cursor position.</db:para>
<db:para>If there is no text in the clipboard nothing happens.</db:para>
<db:para>To change the behavior of this function, i.e. to modify what <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> can paste and how it is being pasted, reimplement the virtual <db:link xlink:href="qtextedit.xml#canInsertFromMimeData">canInsertFromMimeData</db:link>() and <db:link xlink:href="qtextedit.xml#insertFromMimeData">insertFromMimeData</db:link>() functions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#cut">cut</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#copy">copy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="print">
<db:title>void QTextEdit::print(QPagedPaintDevice *<db:emphasis>printer</db:emphasis>) const</db:title>
<db:para>Convenience function to print the text edit's document to the given <db:code role="parameter">printer</db:code>. This is equivalent to calling the print method on the document directly except that this function also supports <db:link xlink:href="qprinter.xml#PrintRange-enum">QPrinter::Selection</db:link> as print range.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextdocument.xml#print">QTextDocument::print</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="redo">
<db:title>void QTextEdit::redo()</db:title>
<db:para>Redoes the last operation.</db:para>
<db:para>If there is no operation to redo, i.e. there is no redo step in the undo/redo history, nothing happens.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#undo">undo</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="redoAvailable">
<db:title>void QTextEdit::redoAvailable(bool <db:emphasis>available</db:emphasis>)</db:title>
<db:para>This signal is emitted whenever redo operations become available (<db:code role="parameter">available</db:code> is true) or unavailable (<db:code role="parameter">available</db:code> is false).</db:para>
</db:section>
<db:section xml:id="resizeEvent">
<db:title>[override virtual protected] void QTextEdit::resizeEvent(QResizeEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#resizeEvent" role="function">QAbstractScrollArea::resizeEvent(QResizeEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="scrollContentsBy">
<db:title>[override virtual protected] void QTextEdit::scrollContentsBy(int <db:emphasis>dx</db:emphasis>, int <db:emphasis>dy</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#scrollContentsBy" role="function">QAbstractScrollArea::scrollContentsBy(int dx, int dy)</db:link>.</db:para>
</db:section>
<db:section xml:id="scrollToAnchor">
<db:title>void QTextEdit::scrollToAnchor(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:para>Scrolls the text edit so that the anchor with the given <db:code role="parameter">name</db:code> is visible; does nothing if the <db:code role="parameter">name</db:code> is empty, or is already visible, or isn't found.</db:para>
</db:section>
<db:section xml:id="selectAll">
<db:title>void QTextEdit::selectAll()</db:title>
<db:para>Selects all text.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#copy">copy</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#cut">cut</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#textCursor">textCursor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="selectionChanged">
<db:title>void QTextEdit::selectionChanged()</db:title>
<db:para>This signal is emitted whenever the selection changes.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#copyAvailable">copyAvailable</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAlignment">
<db:title>void QTextEdit::setAlignment(Qt::Alignment <db:emphasis>a</db:emphasis>)</db:title>
<db:para>Sets the alignment of the current paragraph to <db:code role="parameter">a</db:code>. Valid alignments are <db:link xlink:href="qt.xml#AlignmentFlag-enum">Qt::AlignLeft</db:link>, <db:link xlink:href="qt.xml#AlignmentFlag-enum">Qt::AlignRight</db:link>, <db:link xlink:href="qt.xml#AlignmentFlag-enum">Qt::AlignJustify</db:link> and <db:link xlink:href="qt.xml#AlignmentFlag-enum">Qt::AlignCenter</db:link> (which centers horizontally).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#alignment">alignment</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCurrentCharFormat">
<db:title>void QTextEdit::setCurrentCharFormat(const QTextCharFormat &amp;<db:emphasis>format</db:emphasis>)</db:title>
<db:para>Sets the char format that is be used when inserting new text to <db:code role="parameter">format</db:code> by calling <db:link xlink:href="qtextcursor.xml#setCharFormat">QTextCursor::setCharFormat</db:link>() on the editor's cursor. If the editor has a selection then the char format is directly applied to the selection.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#currentCharFormat">currentCharFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCurrentFont">
<db:title>void QTextEdit::setCurrentFont(const QFont &amp;<db:emphasis>f</db:emphasis>)</db:title>
<db:para>Sets the font of the current format to <db:code role="parameter">f</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#currentFont">currentFont</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setFontPointSize">setFontPointSize</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setFontFamily">setFontFamily</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setExtraSelections">
<db:title>void QTextEdit::setExtraSelections(const QList&lt;QTextEdit::ExtraSelection&gt; &amp;<db:emphasis>selections</db:emphasis>)</db:title>
<db:para>This function allows temporarily marking certain regions in the document with a given color, specified as <db:code role="parameter">selections</db:code>. This can be useful for example in a programming editor to mark a whole line of text with a given background color to indicate the existence of a breakpoint.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit-extraselection.xml">QTextEdit::ExtraSelection</db:link></db:member>
<db:member><db:link xlink:href="qtextedit.xml#extraSelections">extraSelections</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFontFamily">
<db:title>void QTextEdit::setFontFamily(const QString &amp;<db:emphasis>fontFamily</db:emphasis>)</db:title>
<db:para>Sets the font family of the current format to <db:code role="parameter">fontFamily</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#fontFamily">fontFamily</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setCurrentFont">setCurrentFont</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFontItalic">
<db:title>void QTextEdit::setFontItalic(bool <db:emphasis>italic</db:emphasis>)</db:title>
<db:para>If <db:code role="parameter">italic</db:code> is true, sets the current format to italic; otherwise sets the current format to non-italic.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#fontItalic">fontItalic</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFontPointSize">
<db:title>void QTextEdit::setFontPointSize(qreal <db:emphasis>s</db:emphasis>)</db:title>
<db:para>Sets the point size of the current format to <db:code role="parameter">s</db:code>.</db:para>
<db:para>Note that if <db:code role="parameter">s</db:code> is zero or negative, the behavior of this function is not defined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#fontPointSize">fontPointSize</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setCurrentFont">setCurrentFont</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setFontFamily">setFontFamily</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFontUnderline">
<db:title>void QTextEdit::setFontUnderline(bool <db:emphasis>underline</db:emphasis>)</db:title>
<db:para>If <db:code role="parameter">underline</db:code> is true, sets the current format to underline; otherwise sets the current format to non-underline.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#fontUnderline">fontUnderline</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFontWeight">
<db:title>void QTextEdit::setFontWeight(int <db:emphasis>weight</db:emphasis>)</db:title>
<db:para>Sets the font weight of the current format to the given <db:code role="parameter">weight</db:code>, where the value used is in the range defined by the <db:link xlink:href="qfont.xml#Weight-enum">QFont::Weight</db:link> enum.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#fontWeight">fontWeight</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setCurrentFont">setCurrentFont</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#setFontFamily">setFontFamily</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPlainText">
<db:title>void QTextEdit::setPlainText(const QString &amp;<db:emphasis>text</db:emphasis>)</db:title>
<db:para>Changes the text of the text edit to the string <db:code role="parameter">text</db:code>. Any previous text is removed.</db:para>
<db:para>Notes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code role="parameter">text</db:code> is interpreted as plain text.</db:para>
</db:listitem>
<db:listitem>
<db:para>The undo/redo history is also cleared.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtextedit.xml#currentCharFormat">currentCharFormat</db:link>() is reset, unless <db:link xlink:href="qtextedit.xml#textCursor">textCursor</db:link>() is already at the beginning of the document.</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qtextedit.xml#plainText-prop">plainText</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#toPlainText">toPlainText</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setText">
<db:title>void QTextEdit::setText(const QString &amp;<db:emphasis>text</db:emphasis>)</db:title>
<db:para>Sets the text edit's <db:code role="parameter">text</db:code>. The text can be plain text or HTML and the text edit will try to guess the right format.</db:para>
<db:para>Use <db:link xlink:href="qtextedit.xml#html-prop">setHtml</db:link>() or <db:link xlink:href="qtextedit.xml#setPlainText">setPlainText</db:link>() directly to avoid text edit's guessing.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#toPlainText">toPlainText</db:link>()</db:member>
<db:member><db:link xlink:href="qtextedit.xml#html-prop">toHtml</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setTextBackgroundColor">
<db:title>void QTextEdit::setTextBackgroundColor(const QColor &amp;<db:emphasis>c</db:emphasis>)</db:title>
<db:para>Sets the text background color of the current format to <db:code role="parameter">c</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#textBackgroundColor">textBackgroundColor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setTextColor">
<db:title>void QTextEdit::setTextColor(const QColor &amp;<db:emphasis>c</db:emphasis>)</db:title>
<db:para>Sets the text color of the current format to <db:code role="parameter">c</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#textColor">textColor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setTextCursor">
<db:title>void QTextEdit::setTextCursor(const QTextCursor &amp;<db:emphasis>cursor</db:emphasis>)</db:title>
<db:para>Sets the visible <db:code role="parameter">cursor</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#textCursor">textCursor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="showEvent">
<db:title>[override virtual protected] void QTextEdit::showEvent(<db:emphasis>QShowEvent *</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwidget.xml#showEvent" role="function">QWidget::showEvent(QShowEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="textBackgroundColor">
<db:title>QColor QTextEdit::textBackgroundColor() const</db:title>
<db:para>Returns the text background color of the current format.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setTextBackgroundColor">setTextBackgroundColor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="textChanged">
<db:title>void QTextEdit::textChanged()</db:title>
<db:para>This signal is emitted whenever the document's content changes; for example, when text is inserted or deleted, or when formatting is applied.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qtextedit.xml#html-prop">html</db:link>. </db:para>
<db:para>Notifier signal for property <db:link xlink:href="qtextedit.xml#markdown-prop">markdown</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="textColor">
<db:title>QColor QTextEdit::textColor() const</db:title>
<db:para>Returns the text color of the current format.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setTextColor">setTextColor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="textCursor">
<db:title>QTextCursor QTextEdit::textCursor() const</db:title>
<db:para>Returns a copy of the <db:link xlink:href="qtextcursor.xml">QTextCursor</db:link> that represents the currently visible cursor. Note that changes on the returned cursor do not affect <db:link xlink:href="qtextedit.xml">QTextEdit</db:link>'s cursor; use <db:link xlink:href="qtextedit.xml#setTextCursor">setTextCursor</db:link>() to update the visible cursor.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setTextCursor">setTextCursor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toPlainText">
<db:title>QString QTextEdit::toPlainText() const</db:title>
<db:para><db:link xlink:href="qstring.xml">QString</db:link> QTextEdit::toPlainText() const</db:para>
<db:para>Returns the text of the text edit as plain text.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qtextedit.xml#plainText-prop">plainText</db:link>. </db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#setPlainText">QTextEdit::setPlainText</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="undo">
<db:title>void QTextEdit::undo()</db:title>
<db:para>Undoes the last operation.</db:para>
<db:para>If there is no operation to undo, i.e. there is no undo step in the undo/redo history, nothing happens.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#redo">redo</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="undoAvailable">
<db:title>void QTextEdit::undoAvailable(bool <db:emphasis>available</db:emphasis>)</db:title>
<db:para>This signal is emitted whenever undo operations become available (<db:code role="parameter">available</db:code> is true) or unavailable (<db:code role="parameter">available</db:code> is false).</db:para>
</db:section>
<db:section xml:id="wheelEvent">
<db:title>[override virtual protected] void QTextEdit::wheelEvent(QWheelEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractscrollarea.xml#wheelEvent" role="function">QAbstractScrollArea::wheelEvent(QWheelEvent *e)</db:link>.</db:para>
</db:section>
<db:section xml:id="zoomIn">
<db:title>void QTextEdit::zoomIn(int <db:emphasis>range</db:emphasis> = 1)</db:title>
<db:para>Zooms in on the text by making the base font size <db:code role="parameter">range</db:code> points larger and recalculating all font sizes to be the new size. This does not change the size of any images.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#zoomOut">zoomOut</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="zoomOut">
<db:title>void QTextEdit::zoomOut(int <db:emphasis>range</db:emphasis> = 1)</db:title>
<db:para>Zooms out on the text by making the base font size <db:code role="parameter">range</db:code> points smaller and recalculating all font sizes to be the new size. This does not change the size of any images.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtextedit.xml#zoomIn">zoomIn</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
