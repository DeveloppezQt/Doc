<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Get started with CMake</db:title>
<db:productname>QtCMake</db:productname>
<db:edition>Qt 5.14.2 Reference Documentation</db:edition>
<db:titleabbrev>Using Qt with CMake</db:titleabbrev>
<db:extendedlink xlink:type="extended"><db:link xlink:to="cmake-manual.xml" xlink:type="arc" xlink:arcrole="prev" xlink:title="Build with CMake"/></db:extendedlink>
<db:extendedlink xlink:type="extended"><db:link xlink:to="cmake-variable-reference.xml" xlink:type="arc" xlink:arcrole="next" xlink:title="CMake Variable Reference"/></db:extendedlink>
<db:abstract>
<db:para>Using Qt with CMake.</db:para></db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Start with <db:code>find_package</db:code> to locate the libraries and header files shipped with Qt. Then, you can use these libraries and header files with the <db:code>target_link_libraries</db:code> command to build Qt-based libraries and applications. This command automatically adds the appropriate include directories, compile definitions, the position-independent-code flag, and links to the <db:code>qtmain.lib</db:code> library on Windows, for example.</db:para>
<db:section xml:id="build-a-gui-executable">
<db:title>Build a GUI executable</db:title>
<db:para>To build a helloworld GUI executable, you need the following:</db:para>
<db:programlisting language="cpp">cmake_minimum_required(VERSION 3.1.0)

project(helloworld)

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

if(CMAKE_VERSION VERSION_LESS &quot;3.7.0&quot;)
    set(CMAKE_INCLUDE_CURRENT_DIR ON)
endif()

find_package(Qt5 COMPONENTS Widgets REQUIRED)

add_executable(helloworld
    mainwindow.ui
    mainwindow.cpp
    main.cpp
    resources.qrc
)

target_link_libraries(helloworld Qt5::Widgets)
</db:programlisting>
<db:para>For <db:code>find_package</db:code> to be successful, <db:code>CMake</db:code> must find the Qt installation in one of the following ways:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Set your <db:code>CMAKE_PREFIX_PATH</db:code> environment variable to the Qt 5 installation prefix. This is the recommended way.</db:para>
</db:listitem>
<db:listitem>
<db:para>Set the <db:code>Qt5_DIR</db:code> in the <db:code>CMake</db:code> cache to the location of the <db:code>Qt5Config.cmake</db:code> file.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>The <db:code>CMAKE_AUTOMOC</db:code> setting runs moc automatically when required. For more details, see <db:link xlink:href="https://cmake.org/cmake/help/latest/manual/cmake-qt.7.html#automoc">CMake AUTOMOC documentation</db:link>.</db:para>
</db:section>
<db:section xml:id="imported-targets">
<db:title>Imported targets</db:title>
<db:para>Imported targets are created for each Qt module. In <db:code>CMake</db:code>, commands such as <db:code>target_link_libraries</db:code> use imported target names instead of variables like <db:code>Qt5&lt;Module&gt;_LIBRARIES</db:code>. The actual path to the library can be obtained using the <db:link xlink:href="https://cmake.org/cmake/help/latest/prop_tgt/LOCATION.html">LOCATION property</db:link>, as follows:</db:para>
<db:programlisting language="cpp">find_package(Qt5 COMPONENTS Core REQUIRED)

get_target_property(QtCore_location Qt5::Core LOCATION)
</db:programlisting>
<db:para>However, you rarely need the full location to the library as most <db:code>CMake</db:code> APIs can locate imported targets and use them automatically, instead of the full path. For this purpose, each module in Qt 5 has a library target with the <db:emphasis role="bold">Qt5::&lt;Module&gt;</db:emphasis> naming convention.</db:para>
<db:para>Imported targets are created with the same configurations as when Qt was configured. That is:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If Qt was configured with the <db:code>-debug</db:code> switch, an imported target with the DEBUG configuration is created.</db:para>
</db:listitem>
<db:listitem>
<db:para>If Qt was configured with the <db:code>-release</db:code> switch, an imported target with the RELEASE configuration is created.</db:para>
</db:listitem>
<db:listitem>
<db:para>If Qt was configured with the <db:code>-debug-and-release</db:code> switch, which is the default on Windows, then imported targets are created with both RELEASE and DEBUG configurations.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>If your project has custom <db:code>CMake</db:code> build configurations, you have to map your custom configuration to either the debug or the release Qt configuration.</db:para>
<db:programlisting language="cpp">find_package(Qt5 COMPONENTS Core REQUIRED)

set(CMAKE_CXX_FLAGS_COVERAGE &quot;${CMAKE_CXX_FLAGS_RELEASE} -fprofile-arcs -ftest-coverage&quot;)

# set up a mapping so that the Release configuration for the Qt imported target is
# used in the COVERAGE CMake configuration.
set_target_properties(Qt5::Core PROPERTIES MAP_IMPORTED_CONFIG_COVERAGE &quot;RELEASE&quot;)
</db:programlisting>
<db:para>In <db:code>CMake</db:code>, plugins are also available as <db:code>IMPORTED</db:code> targets. The <db:link xlink:href="qtnetwork-index.xml">Qt Network</db:link>, <db:link xlink:href="qtsql-index.xml">Qt SQL</db:link>, <db:link xlink:href="qtgui-index.xml">Qt GUI</db:link>, and <db:link xlink:href="qtwidgets-index.xml">Qt Widgets</db:link> modules have plugins associated. They provide a list of plugins in the <db:code>Qt5</db:code><db:emphasis>&lt;Module&gt;</db:emphasis><db:code>_PLUGINS</db:code> variable.</db:para>
<db:programlisting language="cpp">foreach(plugin ${Qt5Network_PLUGINS})
  get_target_property(_loc ${plugin} LOCATION)
  message(&quot;Plugin ${plugin} is at location ${_loc}&quot;)
endforeach()
</db:programlisting>
</db:section>
</db:article>
