<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Getting started with CMake</db:title>
<db:productname>QtCMake</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Using Qt with CMake</db:titleabbrev>
<db:extendedlink xlink:type="extended"><db:link xlink:to="cmake-manual.xml" xlink:type="arc" xlink:arcrole="prev" xlink:title="Build with CMake"/></db:extendedlink>
<db:extendedlink xlink:type="extended"><db:link xlink:to="cmake-imported-targets.xml" xlink:type="arc" xlink:arcrole="next" xlink:title="Imported targets"/></db:extendedlink>
<db:abstract>
<db:para>Using Qt with CMake.</db:para></db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para><db:code>CMake</db:code> is a group of tools that allow to build, test, and package applications. Just like Qt, it is available on all major development platforms. It is also supported by various IDE's, including <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>.</db:para>
<db:para>In this section we will show the most basic way to use Qt in a CMake project. We will walk through an example project that is utilizing <db:link xlink:href="qtwidgets-index.xml">Qt Widgets</db:link>.</db:para>
<db:section xml:id="build-a-c-gui-executable">
<db:title>Build a C++ GUI executable</db:title>
<db:para>A <db:code>CMake</db:code> project is defined by files written in the CMake language. The main file is called <db:code>CMakeLists.txt</db:code>, and is usually placed in the same directory as the actual program sources.</db:para>
<db:para>Here is a typical <db:code>CMakeLists.txt</db:code> file for an application written in C++ and using Qt and <db:link xlink:href="qtwidgets-index.xml">Qt Widgets</db:link>:</db:para>
<db:programlisting language="cpp">cmake_minimum_required(VERSION 3.16.0)

project(helloworld VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

find_package(Qt6 COMPONENTS Widgets REQUIRED)

add_executable(helloworld
    mainwindow.ui
    mainwindow.cpp
    main.cpp
    resources.qrc
)

target_link_libraries(helloworld PRIVATE Qt6::Widgets)
</db:programlisting>
<db:para>Let's go through the content.</db:para>
<db:programlisting language="cpp">cmake_minimum_required(VERSION 3.16.0)
</db:programlisting>
<db:para><db:code>cmake_minimum_required()</db:code> specifies the minimum CMake version that the application requires. Qt itself requires at least CMake version 3.16.</db:para>
<db:programlisting language="cpp">project(helloworld VERSION 1.0.0 LANGUAGES CXX)
</db:programlisting>
<db:para><db:code>project()</db:code> sets a project name and the default project version. The <db:code>LANGUAGES</db:code> argument tells CMake that the program is written in C++.</db:para>
<db:programlisting language="cpp">set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
</db:programlisting>
<db:para>Qt 6 requires a compiler supporting C++ version 17 or newer. Enforcing this by setting the <db:code>CMAKE_CXX_STANDARD</db:code>, <db:code>CMAKE_CXX_STANDARD_REQUIRED</db:code> variables will let CMake print an error if the compiler is too old.</db:para>
<db:programlisting language="cpp">set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)
</db:programlisting>
<db:para>Qt applications typically make use of the <db:link xlink:href="moc.xml">Meta-Object Compiler (moc)</db:link>, <db:link xlink:href="rcc.xml">Resource Compiler (rcc)</db:link>, and <db:link xlink:href="uic.xml">User Interface Compiler (uic)</db:link> that come with Qt. Setting the <db:code>CMAKE_AUTOMOC</db:code>, <db:code>CMAKE_AUTORCC</db:code>, and <db:code>CMAKE_AUTOUIC</db:code> variables to <db:code>ON</db:code> will let CMake automatically set up rules so that the respective compilers are called transparently, when required.</db:para>
<db:programlisting language="cpp">find_package(Qt6 COMPONENTS Widgets REQUIRED)
</db:programlisting>
<db:para>This tells CMake to look up Qt 6, and import the <db:code>Widgets</db:code> module. There is no point in continuing if <db:code>CMake</db:code> cannot locate the module, so we do set the <db:code>REQUIRED</db:code> flag to let CMake abort in this case.</db:para>
<db:para>If successful, the module will set some CMake variables documented in <db:link xlink:href="cmake-variable-reference.xml#module-variables">Module variables</db:link>. It furthermore imports the <db:code>Qt6::Widgets</db:code> target that we use below.</db:para>
<db:para>For <db:code>find_package</db:code> to be successful, <db:code>CMake</db:code> must find the Qt installation. There are different ways you can tell <db:code>CMake</db:code> about Qt:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Set the <db:code>CMAKE_PREFIX_PATH</db:code> environment variable to include the Qt 6 installation prefix.</db:para>
</db:listitem>
<db:listitem>
<db:para>Set the CMake cache variable <db:code>CMAKE_PREFIX_PATH</db:code> to include the Qt 6 installation prefix.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>Note that <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link> will handle this transparently for you.</db:para>
<db:programlisting language="cpp">add_executable(helloworld
    mainwindow.ui
    mainwindow.cpp
    main.cpp
    resources.qrc
)
</db:programlisting>
<db:para><db:code>add_executable()</db:code> tells CMake that we want to build an executable (so not a library) called <db:code>helloworld</db:code> as a target. The target should be built from C++ code (<db:code>mainwindow.cpp</db:code>, <db:code>main.cpp</db:code>), a <db:link xlink:href="qtdesigner-index.xml">Qt Designer</db:link> file (<db:code>mainwindow.ui</db:code>), and a <db:link xlink:href="resources.xml">Qt Resource System</db:link> file (<db:code>resources.qrc</db:code>).</db:para>
<db:para>Note that you typically do not list header files here. This is different from <db:link xlink:href="qmake-manual.xml">qmake</db:link>, where header files need to be explicitly listed so that they are processed by the <db:link xlink:href="moc.xml">Meta-Object Compiler (moc)</db:link>.</db:para>
<db:programlisting language="cpp">target_link_libraries(helloworld PRIVATE Qt6::Widgets)
</db:programlisting>
<db:para>Finally, <db:code>target_link_libraries</db:code> tells CMake that the <db:code>helloworld</db:code> executable makes use of <db:link xlink:href="qtwidgets-index.xml">Qt Widgets</db:link> by referencing the <db:code>Qt6::Widgets</db:code> target imported by the <db:code>find_package()</db:code> call above. This will not only add the right arguments to the linker, but also makes sure that the right include directories, compiler definitions are passed to the C++ compiler. The <db:code>PRIVATE</db:code> keyword is not strictly necessary for an executable target, but it is good practice to specify it. If <db:code>helloworld</db:code> was a library rather than an executable, then either <db:code>PRIVATE</db:code> or <db:code>PUBLIC</db:code> should be specified (<db:code>PUBLIC</db:code> if the library mentions anything from <db:code>Qt6::Widgets</db:code> in its headers, <db:code>PRIVATE</db:code> otherwise).</db:para>
</db:section>
<db:section xml:id="further-reading">
<db:title>Further reading</db:title>
<db:para>The official <db:link xlink:href="http://www.cmake.org/cmake/help/documentation.html">CMake Documentation</db:link> is an invaluable source for working with CMake.</db:para>
<db:para>The book <db:link xlink:href="https://crascit.com/professional-cmake/">Professional CMake: A Practical Guide</db:link> provides a great introduction to the most relevant CMake features.</db:para>
</db:section>
</db:article>
