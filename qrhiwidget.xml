<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRhiWidget Class</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> class is a widget for rendering 3D graphics via an accelerated grapics API, such as Vulkan, Metal, or Direct 3D.</db:para>
<db:para>This class was introduced in Qt 6.7.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QRhiWidget</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.7</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Widgets)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Widgets)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += widgets</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qwidget.xml" xlink:role="class">QWidget</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> provides functionality for displaying 3D content rendered through the <db:link xlink:href="qrhi.xml">QRhi</db:link> APIs within a <db:link xlink:href="qwidget.xml">QWidget</db:link>-based application. In many ways it is the portable equivalent of <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> that is not tied to a single 3D graphics API, but rather can function with all the APIs <db:link xlink:href="qrhi.xml">QRhi</db:link> supports (such as, Direct 3D 11/12, Vulkan, Metal, and OpenGL).</db:para>
<db:para><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> is expected to be subclassed. To render into the 2D texture that is implicitly created and managed by the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>, subclasses should reimplement the virtual functions <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() and <db:link xlink:href="qrhiwidget.xml#render">render</db:link>().</db:para>
<db:para>The size of the texture will by default adapt to the size of the widget. If a fixed size is preferred, set a fixed size specified in pixels by calling <db:link xlink:href="qrhiwidget.xml#fixedColorBufferSize-prop">setFixedColorBufferSize</db:link>().</db:para>
<db:para>In addition to the texture serving as the color buffer, a depth/stencil buffer and a render target binding these together is maintained implicitly as well.</db:para>
<db:para>The <db:link xlink:href="qrhi.xml">QRhi</db:link> for the widget's top-level window is configured to use a platform-specific backend and graphics API by default: Metal on macOS and iOS, Direct 3D 11 on Windows, OpenGL otherwise. Call <db:link xlink:href="qrhiwidget.xml#setApi">setApi</db:link>() to override this.</db:para>
<db:note>
<db:para>A single widget window can only use one <db:link xlink:href="qrhi.xml">QRhi</db:link> backend, and so one single 3D graphics API. If two <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> or QQuickWidget widgets in the window's widget hierarchy request different APIs, only one of them will function correctly.</db:para>
</db:note>
<db:note>
<db:para>While <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> is a public Qt API, the <db:link xlink:href="qrhi.xml">QRhi</db:link> family of classes in the Qt Gui module, including <db:link xlink:href="qrhi.xml">QRhi</db:link>, <db:link xlink:href="qshader.xml">QShader</db:link> and <db:link xlink:href="qshaderdescription.xml">QShaderDescription</db:link>, offer limited compatibility guarantees. There are no source or binary compatibility guarantees for these classes, meaning the API is only guaranteed to work with the Qt version the application was developed against. Source incompatible changes are however aimed to be kept at a minimum and will only be made in minor releases (6.7, 6.8, and so on). qrhiwidget.h does not directly include any <db:link xlink:href="qrhi.xml">QRhi</db:link>-related headers. To use those classes when implementing a <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> subclass, link to Qt::GuiPrivate (if using CMake), and include the appropriate headers with the rhi prefix, for example #include &lt;rhi/qrhi.h&gt;.</db:para>
</db:note>
<db:para>An example of a simple <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> subclass rendering a triangle is the following:</db:para>
<db:programlisting language="cpp">class ExampleRhiWidget : public QRhiWidget
{
public:
    ExampleRhiWidget(QWidget *parent = nullptr) : QRhiWidget(parent) { }
    void initialize(QRhiCommandBuffer *cb) override;
    void render(QRhiCommandBuffer *cb) override;
private:
    QRhi *m_rhi = nullptr;
    std::unique_ptr&lt;QRhiBuffer&gt; m_vbuf;
    std::unique_ptr&lt;QRhiBuffer&gt; m_ubuf;
    std::unique_ptr&lt;QRhiShaderResourceBindings&gt; m_srb;
    std::unique_ptr&lt;QRhiGraphicsPipeline&gt; m_pipeline;
    QMatrix4x4 m_viewProjection;
    float m_rotation = 0.0f;
};

float vertexData[] = {
     0.0f,   0.5f,     1.0f, 0.0f, 0.0f,
    -0.5f,  -0.5f,     0.0f, 1.0f, 0.0f,
     0.5f,  -0.5f,     0.0f, 0.0f, 1.0f,
};

QShader getShader(const QString &amp;name)
{
    QFile f(name);
    return f.open(QIODevice::ReadOnly) ? QShader::fromSerialized(f.readAll()) : QShader();
}

void ExampleRhiWidget::initialize(QRhiCommandBuffer *cb)
{
    if (m_rhi != rhi()) {
        m_pipeline.reset();
        m_rhi = rhi();
    }

    if (!m_pipeline) {
        m_vbuf.reset(m_rhi-&gt;newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertexData)));
        m_vbuf-&gt;create();

        m_ubuf.reset(m_rhi-&gt;newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, 64));
        m_ubuf-&gt;create();

        m_srb.reset(m_rhi-&gt;newShaderResourceBindings());
        m_srb-&gt;setBindings({
            QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, m_ubuf.get()),
        });
        m_srb-&gt;create();

        m_pipeline.reset(m_rhi-&gt;newGraphicsPipeline());
        m_pipeline-&gt;setShaderStages({
            { QRhiShaderStage::Vertex, getShader(QLatin1String(&quot;:/shader_assets/color.vert.qsb&quot;)) },
            { QRhiShaderStage::Fragment, getShader(QLatin1String(&quot;:/shader_assets/color.frag.qsb&quot;)) }
        });
        QRhiVertexInputLayout inputLayout;
        inputLayout.setBindings({
            { 5 * sizeof(float) }
        });
        inputLayout.setAttributes({
            { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
            { 0, 1, QRhiVertexInputAttribute::Float3, 2 * sizeof(float) }
        });
        m_pipeline-&gt;setVertexInputLayout(inputLayout);
        m_pipeline-&gt;setShaderResourceBindings(m_srb.get());
        m_pipeline-&gt;setRenderPassDescriptor(renderTarget()-&gt;renderPassDescriptor());
        m_pipeline-&gt;create();

        QRhiResourceUpdateBatch *resourceUpdates = m_rhi-&gt;nextResourceUpdateBatch();
        resourceUpdates-&gt;uploadStaticBuffer(m_vbuf.get(), vertexData);
        cb-&gt;resourceUpdate(resourceUpdates);
    }

    const QSize outputSize = colorTexture()-&gt;pixelSize();
    m_viewProjection = m_rhi-&gt;clipSpaceCorrMatrix();
    m_viewProjection.perspective(45.0f, outputSize.width() / (float) outputSize.height(), 0.01f, 1000.0f);
    m_viewProjection.translate(0, 0, -4);
}

void ExampleRhiWidget::render(QRhiCommandBuffer *cb)
{
    QRhiResourceUpdateBatch *resourceUpdates = m_rhi-&gt;nextResourceUpdateBatch();
    m_rotation += 1.0f;
    QMatrix4x4 modelViewProjection = m_viewProjection;
    modelViewProjection.rotate(m_rotation, 0, 1, 0);
    resourceUpdates-&gt;updateDynamicBuffer(m_ubuf.get(), 0, 64, modelViewProjection.constData());

    const QColor clearColor = QColor::fromRgbF(0.4f, 0.7f, 0.0f, 1.0f);
    cb-&gt;beginPass(renderTarget(), clearColor, { 1.0f, 0 }, resourceUpdates);

    cb-&gt;setGraphicsPipeline(m_pipeline.get());
    const QSize outputSize = colorTexture()-&gt;pixelSize();
    cb-&gt;setViewport(QRhiViewport(0, 0, outputSize.width(), outputSize.height()));
    cb-&gt;setShaderResources();
    const QRhiCommandBuffer::VertexInput vbufBinding(m_vbuf.get(), 0);
    cb-&gt;setVertexInput(0, 1, &amp;vbufBinding);
    cb-&gt;draw(3);

    cb-&gt;endPass();

    update();
}
</db:programlisting>
<db:para>This is a widget that continuously requests updates, throttled by the presentation rate (vsync, depending on the screen refresh rate). If rendering continuously is not desired, the <db:link xlink:href="qwidget.xml#update">update</db:link>() call in <db:link xlink:href="qrhiwidget.xml#render">render</db:link>() should be removed, and rather issued only when updating the rendered content is necessary. For example, if the rotation of the cube should be tied to the value of a <db:link xlink:href="qslider.xml">QSlider</db:link>, then connecting the slider's value change signal to a slot or lambda that forwards the new value and calls <db:link xlink:href="qwidget.xml#update">update</db:link>() is sufficient.</db:para>
<db:para>The vertex and fragment shaders are provided as Vulkan-style GLSL and must be processed first by the Qt shader infrastructure first. This is achieved either by running the qsb command-line tool manually, or by using the <db:link xlink:href="">qt_add_shaders()</db:link> function in CMake. The <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> implementation loads these pre-processed .qsb files that are shipped with the application. See <db:link xlink:href="">Qt Shader Tools</db:link> for more information about Qt's shader translation infrastructure.</db:para>
<db:para>The source code for these shaders could be the following:</db:para>
<db:para>color.vert</db:para>
<db:programlisting language="cpp">#version 440
layout(location = 0) in vec4 position;
layout(location = 1) in vec3 color;
layout(location = 0) out vec3 v_color;
layout(std140, binding = 0) uniform buf {
    mat4 mvp;
};

void main()
{
    v_color = color;
    gl_Position = mvp * position;
}
</db:programlisting>
<db:para>color.frag</db:para>
<db:programlisting language="cpp">#version 440
layout(location = 0) in vec3 v_color;
layout(location = 0) out vec4 fragColor;

void main()
{
    fragColor = vec4(v_color, 1.0);
}
</db:programlisting>
<db:para>The result is a widget that shows the following:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qrhiwidget-intro.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:para>For a complete, minimal, introductory example check out the <db:link xlink:href="qtwidgets-rhi-simplerhiwidget-example.xml">Simple RHI Widget Example</db:link>.</db:para>
<db:para>For an example with more functionality and demonstration of further concepts, see the <db:link xlink:href="qtwidgets-rhi-cuberhiwidget-example.xml">Cube RHI Widget Example</db:link>.</db:para>
<db:para><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> always involves rendering into a backing texture, not directly to the window (the surface or layer provided by the windowing system for the native window). This allows properly compositing the content with the rest of the widget-based UI, and offering a simple and compact API, making it easy to get started. All this comes at the expense of additional resources and a potential effect on performance. This is often perfectly acceptable in practice, but advanced users should keep in mind the pros and cons of the different approaches. Refer to the <db:link xlink:href="qtgui-rhiwindow-example.xml">RHI Window Example</db:link> and compare it with the <db:link xlink:href="qtwidgets-rhi-simplerhiwidget-example.xml">Simple RHI Widget Example</db:link> for details about the two approaches.</db:para>
<db:para>Reparenting a <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> into a widget hierarchy that belongs to a different window (top-level widget), or making the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> itself a top-level (by setting the parent to nullptr), involves changing the associated <db:link xlink:href="qrhi.xml">QRhi</db:link> (and potentially destroying the old one) while the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> continues to stay alive and well. To support this, robust <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> implementations are expected to reimplement the <db:link xlink:href="qrhiwidget.xml#releaseResources">releaseResources</db:link>() virtual function as well, and drop their <db:link xlink:href="qrhi.xml">QRhi</db:link> resources just as they do in the destructor. The <db:link xlink:href="qtwidgets-rhi-cuberhiwidget-example.xml">Cube RHI Widget Example</db:link> demonstrates this in practice.</db:para>
<db:para>While not a primary use case, <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> also allows incorporating rendering code that directly uses a 3D graphics API such as Vulkan, Metal, Direct 3D, or OpenGL. See <db:link xlink:href="qrhicommandbuffer.xml#beginExternal">QRhiCommandBuffer::beginExternal</db:link>() for details on recording native commands within a <db:link xlink:href="qrhi.xml">QRhi</db:link> render pass, as well as <db:link xlink:href="qrhitexture.xml#createFrom">QRhiTexture::createFrom</db:link>() for a way to wrap an existing native texture and then use it with <db:link xlink:href="qrhi.xml">QRhi</db:link> in a subsequent render pass. Note however that the configurability of the underlying graphics API (its device or context features, layers, extensions, etc.) is going to be limited since <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>'s primary goal is to provide an environment suitable for <db:link xlink:href="qrhi.xml">QRhi</db:link>-based rendering code, not to enable arbitrary, potentially complex, foreign rendering engines.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml">QRhi</db:link></db:member>
<db:member><db:link xlink:href="qshader.xml">QShader</db:link></db:member>
<db:member><db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-rhi-simplerhiwidget-example.xml">Simple RHI Widget Example</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-rhi-cuberhiwidget-example.xml">Cube RHI Widget Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Api-enum">
<db:title>enum QRhiWidget::Api</db:title>
<db:para>Specifies the 3D API and <db:link xlink:href="qrhi.xml">QRhi</db:link> backend to use</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link></db:emphasis>::<db:emphasis role="bold">Api</db:emphasis>::Null</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link></db:emphasis>::<db:emphasis role="bold">Api</db:emphasis>::OpenGL</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link></db:emphasis>::<db:emphasis role="bold">Api</db:emphasis>::Metal</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link></db:emphasis>::<db:emphasis role="bold">Api</db:emphasis>::Vulkan</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link></db:emphasis>::<db:emphasis role="bold">Api</db:emphasis>::Direct3D11</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link></db:emphasis>::<db:emphasis role="bold">Api</db:emphasis>::Direct3D12</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml">QRhi</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="TextureFormat-enum">
<db:title>enum QRhiWidget::TextureFormat</db:title>
<db:para>Specifies the format of the texture to which the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> renders.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link></db:emphasis>::<db:emphasis role="bold">TextureFormat</db:emphasis>::RGBA8</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>See <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::RGBA8</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link></db:emphasis>::<db:emphasis role="bold">TextureFormat</db:emphasis>::RGBA16F</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>See <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::RGBA16F</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link></db:emphasis>::<db:emphasis role="bold">TextureFormat</db:emphasis>::RGBA32F</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>See <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::RGBA32F</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link></db:emphasis>::<db:emphasis role="bold">TextureFormat</db:emphasis>::RGB10A2</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>See <db:link xlink:href="qrhitexture.xml#Format-enum">QRhiTexture::RGB10A2</db:link>.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="autoRenderTarget-prop">
<db:title>autoRenderTarget : const bool</db:title>
<db:para>The current setting for automatic depth-stencil buffer and render target maintenance.</db:para>
<db:para>By default the value is true.</db:para>
</db:section>
<db:section xml:id="colorBufferFormat-prop">
<db:title>colorBufferFormat : TextureFormat</db:title>
<db:para>This property controls the texture format of the texture (or renderbuffer) used as the color buffer. The default value is <db:link xlink:href="qrhiwidget.xml#TextureFormat-enum">TextureFormat::RGBA8</db:link>. <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> supports rendering to a subset of the formats supported by <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>. Only formats that are reported as supported from <db:link xlink:href="qrhi.xml#isTextureFormatSupported">QRhi::isTextureFormatSupported</db:link>() should be specified, rendering will not be functional otherwise.</db:para>
<db:note>
<db:para>Setting a new format when the widget is already initialized and has rendered implies that all <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> objects created by the renderer may become unusable, if the associated <db:link xlink:href="qrhirenderpassdescriptor.xml">QRhiRenderPassDescriptor</db:link> is now incompatible due to the different texture format. Similarly to changing <db:link xlink:href="qrhiwidget.xml#sampleCount-prop">sampleCount</db:link> dynamically, this means that <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() or <db:link xlink:href="qrhiwidget.xml#render">render</db:link>() implementations must then take care of releasing the existing pipelines and creating new ones.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qrhiwidget.xml#TextureFormat-enum">QRhiWidget::TextureFormat</db:link></db:type> <db:emphasis role="bold">colorBufferFormat</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setColorBufferFormat</db:emphasis>(<db:type><db:link xlink:href="qrhiwidget.xml#TextureFormat-enum">QRhiWidget::TextureFormat</db:link></db:type> <db:emphasis>format</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">colorBufferFormatChanged</db:emphasis>(<db:type><db:link xlink:href="qrhiwidget.xml#TextureFormat-enum">QRhiWidget::TextureFormat</db:link></db:type> <db:emphasis>format</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="fixedColorBufferSize-prop">
<db:title>fixedColorBufferSize : QSize</db:title>
<db:para>The fixed size, in pixels, of the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>'s associated texture. Relevant when a fixed texture size is desired that does not depend on the widget's size. This size has no effect on the geometry of the widget (its size and placement within the top-level window), which means the texture's content will appear stretched (scaled up) or scaled down onto the widget's area.</db:para>
<db:para>For example, setting a size that is exactly twice the widget's (pixel) size effectively performs 2x supersampling (rendering at twice the resolution and then implicitly scaling down when texturing the quad corresponding to the widget in the window).</db:para>
<db:para>By default the value is a null <db:link xlink:href="qsize.xml">QSize</db:link>. A null or empty <db:link xlink:href="qsize.xml">QSize</db:link> means that the texture's size follows the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>'s size. (texture size = widget size * device pixel ratio).</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsize.xml">QSize</db:link></db:type> <db:emphasis role="bold">fixedColorBufferSize</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setFixedColorBufferSize</db:emphasis>(<db:type><db:link xlink:href="qsize.xml">QSize</db:link></db:type> <db:emphasis>pixelSize</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setFixedColorBufferSize</db:emphasis>(<db:type>int</db:type> <db:emphasis>w</db:emphasis>, <db:type>int</db:type> <db:emphasis>h</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">fixedColorBufferSizeChanged</db:emphasis>(const <db:type><db:link xlink:href="qsize.xml">QSize</db:link></db:type> &amp;<db:emphasis>pixelSize</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="mirrorVertically-prop">
<db:title>mirrorVertically : bool</db:title>
<db:para>When enabled, flips the image around the X axis when compositing the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>'s backing texture with the rest of the widget content in the top-level window.</db:para>
<db:para>The default value is false.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isMirrorVerticallyEnabled</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setMirrorVertically</db:emphasis>(<db:type>bool</db:type> <db:emphasis>enabled</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">mirrorVerticallyChanged</db:emphasis>(<db:type>bool</db:type> <db:emphasis>enabled</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="sampleCount-prop">
<db:title>sampleCount : int</db:title>
<db:para>This property controls for sample count for multisample antialiasing. By default the value is 1 which means MSAA is disabled.</db:para>
<db:para>Valid values are 1, 4, 8, and sometimes 16 and 32. <db:link xlink:href="qrhi.xml#supportedSampleCounts">QRhi::supportedSampleCounts</db:link>() can be used to query the supported sample counts at run time, but typically applications should request 1 (no MSAA), 4x (normal MSAA) or 8x (high MSAA).</db:para>
<db:note>
<db:para>Setting a new value implies that all <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> objects created by the renderer must use the same sample count from then on. Existing <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> objects created with a different sample count must not be used anymore. When the value changes, all color and depth-stencil buffers are destroyed and recreated automatically, and <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() is invoked again. However, when <db:link xlink:href="qrhiwidget.xml#autoRenderTarget-prop">autoRenderTarget</db:link> is false, it will be up to the application to manage this with regards to the depth-stencil buffer or additional color buffers.</db:para>
</db:note>
<db:para>Changing the sample count from the default 1 to a higher value implies that <db:link xlink:href="qrhiwidget.xml#colorTexture">colorTexture</db:link>() becomes nullptr and <db:link xlink:href="qrhiwidget.xml#msaaColorBuffer">msaaColorBuffer</db:link>() starts returning a valid object. Switching back to 1 (or 0), implies the opposite: in the next call to <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() <db:link xlink:href="qrhiwidget.xml#msaaColorBuffer">msaaColorBuffer</db:link>() is going to return nullptr, whereas <db:link xlink:href="qrhiwidget.xml#colorTexture">colorTexture</db:link>() becomes once again valid. In addition, <db:link xlink:href="qrhiwidget.xml#resolveTexture">resolveTexture</db:link>() returns a valid (non-multisample) <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> whenever the sample count is greater than 1 (i.e., MSAA is in use).</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">sampleCount</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setSampleCount</db:emphasis>(<db:type>int</db:type> <db:emphasis>samples</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">sampleCountChanged</db:emphasis>(<db:type>int</db:type> <db:emphasis>samples</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#msaaColorBuffer">msaaColorBuffer</db:link>()</db:member>
<db:member><db:link xlink:href="qrhiwidget.xml#resolveTexture">resolveTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QRhiWidget">
<db:title>[explicit] QRhiWidget::QRhiWidget(QWidget *<db:emphasis>parent</db:emphasis> = nullptr, Qt::WindowFlags <db:emphasis>f</db:emphasis> = {})</db:title>
<db:para>Constructs a widget which is a child of <db:code role="parameter">parent</db:code>, with widget flags set to <db:code role="parameter">f</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QRhiWidget">
<db:title>[override virtual noexcept] QRhiWidget::~QRhiWidget()</db:title>
<db:para>Destructor.</db:para>
</db:section>
<db:section xml:id="api">
<db:title>QRhiWidget::Api QRhiWidget::api() const</db:title>
<db:para>Returns the currently set graphics API (<db:link xlink:href="qrhi.xml">QRhi</db:link> backend).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#setApi">setApi</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="colorTexture">
<db:title>[protected] QRhiTexture *QRhiWidget::colorTexture() const</db:title>
<db:para>Returns the texture serving as the color buffer for the widget.</db:para>
<db:para>Must only be called from <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() and <db:link xlink:href="qrhiwidget.xml#render">render</db:link>().</db:para>
<db:para>Unlike the depth-stencil buffer and the <db:link xlink:href="qrhirendertarget.xml">QRhiRenderTarget</db:link>, this texture is always available and is managed by the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>, independent of the value of <db:link xlink:href="qrhiwidget.xml#autoRenderTarget-prop">autoRenderTarget</db:link>.</db:para>
<db:note>
<db:para>When <db:link xlink:href="qrhiwidget.xml#sampleCount-prop">sampleCount</db:link> is larger than 1, and so multisample antialiasing is enabled, the return value is nullptr. Instead, query the <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> by calling <db:link xlink:href="qrhiwidget.xml#msaaColorBuffer">msaaColorBuffer</db:link>().</db:para>
</db:note>
<db:note>
<db:para>The backing texture size and sample count can also be queried via the <db:link xlink:href="qrhirendertarget.xml">QRhiRenderTarget</db:link> returned from <db:link xlink:href="qrhiwidget.xml#renderTarget">renderTarget</db:link>(). This can be more convenient and compact than querying from the <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> or <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link>, because it works regardless of multisampling is in use or not.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#msaaColorBuffer">msaaColorBuffer</db:link>()</db:member>
<db:member><db:link xlink:href="qrhiwidget.xml#depthStencilBuffer">depthStencilBuffer</db:link>()</db:member>
<db:member><db:link xlink:href="qrhiwidget.xml#renderTarget">renderTarget</db:link>()</db:member>
<db:member><db:link xlink:href="qrhiwidget.xml#resolveTexture">resolveTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="depthStencilBuffer">
<db:title>[protected] QRhiRenderBuffer *QRhiWidget::depthStencilBuffer() const</db:title>
<db:para>Returns the depth-stencil buffer used by the widget's rendering.</db:para>
<db:para>Must only be called from <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() and <db:link xlink:href="qrhiwidget.xml#render">render</db:link>().</db:para>
<db:para>Available only when <db:link xlink:href="qrhiwidget.xml#autoRenderTarget-prop">autoRenderTarget</db:link> is true. Otherwise the returned value is nullptr and it is up the reimplementation of <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() to create and manage a depth-stencil buffer and a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#colorTexture">colorTexture</db:link>()</db:member>
<db:member><db:link xlink:href="qrhiwidget.xml#renderTarget">renderTarget</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="event">
<db:title>[override virtual protected] bool QRhiWidget::event(QEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwidget.xml#event" role="function">QWidget::event(QEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="frameSubmitted">
<db:title>void QRhiWidget::frameSubmitted()</db:title>
<db:para>This signal is emitted after the widget's top-level window has finished composition and has <db:link xlink:href="qrhi.xml#endFrame">submitted a frame</db:link>.</db:para>
</db:section>
<db:section xml:id="grabFramebuffer">
<db:title>QImage QRhiWidget::grabFramebuffer() const</db:title>
<db:para>Renders a new frame, reads the contents of the texture back, and returns it as a <db:link xlink:href="qimage.xml">QImage</db:link>.</db:para>
<db:para>When an error occurs, a null <db:link xlink:href="qimage.xml">QImage</db:link> is returned.</db:para>
<db:para>The returned <db:link xlink:href="qimage.xml">QImage</db:link> will have a format of <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_RGBA8888</db:link>, <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_RGBA16FPx4</db:link>, <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_RGBA32FPx4</db:link>, or <db:link xlink:href="qimage.xml#Format-enum">QImage::Format_BGR30</db:link>, depending on <db:link xlink:href="qrhiwidget.xml#colorBufferFormat-prop">colorBufferFormat</db:link>().</db:para>
<db:para><db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> does not know the renderer's approach to blending and composition, and therefore cannot know if the output has alpha premultiplied in the RGB color values. Thus _Premultiplied <db:link xlink:href="qimage.xml">QImage</db:link> formats are never used for the returned <db:link xlink:href="qimage.xml">QImage</db:link>, even when it would be appropriate. It is up to the caller to reinterpret the resulting data as it sees fit.</db:para>
<db:note>
<db:para>This function can also be called when the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> is not added to a widget hierarchy belonging to an on-screen top-level window. This allows generating an image from a 3D rendering off-screen.</db:para>
</db:note>
<db:para>The function is named grabFramebuffer() for consistency with <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> and QQuickWidget. It is not the only way to get CPU-side image data out of the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>'s content: calling <db:link xlink:href="qwidget.xml#grab">QWidget::grab</db:link>() on a <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>, or an ancestor of it, is functional as well (returning a <db:link xlink:href="qpixmap.xml">QPixmap</db:link>). Besides working directly with <db:link xlink:href="qimage.xml">QImage</db:link>, another advantage of grabFramebuffer() is that it may be slightly more performant, simply because it does not have to go through the rest of <db:link xlink:href="qwidget.xml">QWidget</db:link> infrastructure but can right away trigger rendering a new frame and then do the readback.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#colorBufferFormat-prop">setColorBufferFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="initialize">
<db:title>[virtual protected] void QRhiWidget::initialize(QRhiCommandBuffer *<db:emphasis>cb</db:emphasis>)</db:title>
<db:para>Called when the widget is initialized for the first time, when the associated texture's size, format, or sample count changes, or when the <db:link xlink:href="qrhi.xml">QRhi</db:link> and texture change for any reason. The function is expected to maintain (create if not yet created, adjust and rebuild if the size has changed) the graphics resources used by the rendering code in <db:link xlink:href="qrhiwidget.xml#render">render</db:link>().</db:para>
<db:para>To query the <db:link xlink:href="qrhi.xml">QRhi</db:link>, <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>, and other related objects, call <db:link xlink:href="qrhiwidget.xml#rhi">rhi</db:link>(), <db:link xlink:href="qrhiwidget.xml#colorTexture">colorTexture</db:link>(), <db:link xlink:href="qrhiwidget.xml#depthStencilBuffer">depthStencilBuffer</db:link>(), and <db:link xlink:href="qrhiwidget.xml#renderTarget">renderTarget</db:link>().</db:para>
<db:para>When the widget size changes, the <db:link xlink:href="qrhi.xml">QRhi</db:link> object, the color buffer texture, and the depth stencil buffer objects are all the same instances (so the getters return the same pointers) as before, but the color and depth/stencil buffers will likely have been rebuilt, meaning the size and the underlying native texture resource may be different than in the last invocation.</db:para>
<db:para>Reimplementations should also be prepared that the <db:link xlink:href="qrhi.xml">QRhi</db:link> object and the color buffer texture may change between invocations of this function. One special case where the objects will be different is when performing a <db:link xlink:href="qrhiwidget.xml#grabFramebuffer">grabFramebuffer</db:link>() with a widget that is not yet shown, and then making the widget visible on-screen within a top-level widget. There the grab will happen with a dedicated <db:link xlink:href="qrhi.xml">QRhi</db:link> that is then replaced with the top-level window's associated <db:link xlink:href="qrhi.xml">QRhi</db:link> in subsequent initialize() and <db:link xlink:href="qrhiwidget.xml#render">render</db:link>() invocations. Another, more common case is when the widget is reparented so that it belongs to a new top-level window. In this case the <db:link xlink:href="qrhi.xml">QRhi</db:link> and all related resources managed by the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> will be different instances than before in the subsequent call to this function. Is is then important that all existing <db:link xlink:href="qrhi.xml">QRhi</db:link> resources previously created by the subclass are destroyed because they belong to the previous <db:link xlink:href="qrhi.xml">QRhi</db:link> that should not be used by the widget anymore.</db:para>
<db:para>When <db:link xlink:href="qrhiwidget.xml#autoRenderTarget-prop">autoRenderTarget</db:link> is true, which is the default, a depth-stencil <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> and a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> associated with <db:link xlink:href="qrhiwidget.xml#colorTexture">colorTexture</db:link>() (or <db:link xlink:href="qrhiwidget.xml#msaaColorBuffer">msaaColorBuffer</db:link>()) and the depth-stencil buffer are created and managed automatically. Reimplementations of initialize() and <db:link xlink:href="qrhiwidget.xml#render">render</db:link>() can query those objects via <db:link xlink:href="qrhiwidget.xml#depthStencilBuffer">depthStencilBuffer</db:link>() and <db:link xlink:href="qrhiwidget.xml#renderTarget">renderTarget</db:link>(). When <db:link xlink:href="qrhiwidget.xml#autoRenderTarget-prop">autoRenderTarget</db:link> is set to false, these objects are no longer created and managed automatically. Rather, it will be up the the initialize() implementation to create buffers and set up the render target as it sees fit. When manually managing additional color or depth-stencil attachments for the render target, their size and sample count must always follow the size and sample count of <db:link xlink:href="qrhiwidget.xml#colorTexture">colorTexture</db:link>() / <db:link xlink:href="qrhiwidget.xml#msaaColorBuffer">msaaColorBuffer</db:link>(), otherwise rendering or 3D API validation errors may occur.</db:para>
<db:para>The subclass-created graphics resources are expected to be released in the destructor implementation of the subclass.</db:para>
<db:para><db:code role="parameter">cb</db:code> is the <db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link> for the current frame of the widget. The function is called with a frame being recorded, but without an active render pass. The command buffer is provided primarily to allow enqueuing <db:link xlink:href="qrhicommandbuffer.xml#resourceUpdate">resource updates</db:link> without deferring to <db:link xlink:href="qrhiwidget.xml#render">render</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#render">render</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isDebugLayerEnabled">
<db:title>bool QRhiWidget::isDebugLayerEnabled() const</db:title>
<db:para>Returns true if a debug or validation layer will be requested if applicable to the graphics API in use.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#setDebugLayerEnabled">setDebugLayerEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="msaaColorBuffer">
<db:title>[protected] QRhiRenderBuffer *QRhiWidget::msaaColorBuffer() const</db:title>
<db:para>Returns the renderbuffer serving as the multisample color buffer for the widget.</db:para>
<db:para>Must only be called from <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() and <db:link xlink:href="qrhiwidget.xml#render">render</db:link>().</db:para>
<db:para>When <db:link xlink:href="qrhiwidget.xml#sampleCount-prop">sampleCount</db:link> is larger than 1, and so multisample antialising is enabled, the returned <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> has a matching sample count and serves as the color buffer. Graphics pipelines used to render into this buffer must be created with the same sample count, and the depth-stencil buffer's sample count must match as well. The multisample content is expected to be resolved into the texture returned from <db:link xlink:href="qrhiwidget.xml#resolveTexture">resolveTexture</db:link>(). When <db:link xlink:href="qrhiwidget.xml#autoRenderTarget-prop">autoRenderTarget</db:link> is true, <db:link xlink:href="qrhiwidget.xml#renderTarget">renderTarget</db:link>() is set up automatically to do this, by setting up msaaColorBuffer() as the renderbuffer of color attachment 0 and <db:link xlink:href="qrhiwidget.xml#resolveTexture">resolveTexture</db:link>() as its resolveTexture.</db:para>
<db:para>When MSAA is not in use, the return value is nullptr. Use <db:link xlink:href="qrhiwidget.xml#colorTexture">colorTexture</db:link>() instead then.</db:para>
<db:para>Depending on the underlying 3D graphics API, there may be no practical difference between multisample textures and color renderbuffers with a sample count larger than 1 (<db:link xlink:href="qrhi.xml">QRhi</db:link> may just map both to the same native resource type). Some older APIs however may differentiate between textures and renderbuffers. In order to support OpenGL ES 3.0, where multisample renderbuffers are available, but multisample textures are not, <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> always performs MSAA by using a multisample <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> as the color attachment (and never a multisample <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>).</db:para>
<db:note>
<db:para>The backing texture size and sample count can also be queried via the <db:link xlink:href="qrhirendertarget.xml">QRhiRenderTarget</db:link> returned from <db:link xlink:href="qrhiwidget.xml#renderTarget">renderTarget</db:link>(). This can be more convenient and compact than querying from the <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> or <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link>, because it works regardless of multisampling is in use or not.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#colorTexture">colorTexture</db:link>()</db:member>
<db:member><db:link xlink:href="qrhiwidget.xml#depthStencilBuffer">depthStencilBuffer</db:link>()</db:member>
<db:member><db:link xlink:href="qrhiwidget.xml#renderTarget">renderTarget</db:link>()</db:member>
<db:member><db:link xlink:href="qrhiwidget.xml#resolveTexture">resolveTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="paintEvent">
<db:title>[override virtual protected] void QRhiWidget::paintEvent(QPaintEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwidget.xml#paintEvent" role="function">QWidget::paintEvent(QPaintEvent *event)</db:link>.</db:para>
<db:para>Handles paint events.</db:para>
<db:para>Calling <db:link xlink:href="qwidget.xml#update">QWidget::update</db:link>() will lead to sending a paint event <db:code role="parameter">e</db:code>, and thus invoking this function. The sending of the event is asynchronous and will happen at some point after returning from <db:link xlink:href="qwidget.xml#update">update</db:link>(). This function will then, after some preparation, call the virtual <db:link xlink:href="qrhiwidget.xml#render">render</db:link>() to update the contents of the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>'s associated texture. The widget's top-level window will then composite the texture with the rest of the window.</db:para>
</db:section>
<db:section xml:id="releaseResources">
<db:title>[virtual protected] void QRhiWidget::releaseResources()</db:title>
<db:para>Called when the need to early-release the graphics resources arises.</db:para>
<db:para>This normally does not happen for a <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> that is added to a top-level widget's child hierarchy and it then stays there for the rest of its and the top-level's lifetime. Thus in many cases there is no need to reimplement this function, e.g. because the application only ever has a single top-level widget (native window). However, when reparenting of the widget (or an ancestor of it) is involved, reimplementing this function will become necessary in robust, well-written <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> subclasses.</db:para>
<db:para>When this function is called, the implementation is expected to destroy all <db:link xlink:href="qrhi.xml">QRhi</db:link> resources (<db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link>, <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>, etc. objects), similarly to how it is expected to do this in the destructor. Nulling out, using a smart pointer, or setting a resources-invalid flag is going to be required as well, because <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() will eventually get called afterwards. Note however that deferring the releasing of resources to the subsequent <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() is wrong. If this function is called, the resource must be dropped before returning. Also note that implementing this function does not replace the class destructor (or smart pointers): the graphics resources must still be released in both.</db:para>
<db:para>See the <db:link xlink:href="qtwidgets-rhi-cuberhiwidget-example.xml">Cube RHI Widget Example</db:link> for an example of this in action. There the button that toggles the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> between being a child widget (due to having a parent widget) and being a top-level widget (due to having no parent widget), will trigger invoking this function since the associated top-level widget, native window, and <db:link xlink:href="qrhi.xml">QRhi</db:link> all change during the lifetime of the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>, with the previously used <db:link xlink:href="qrhi.xml">QRhi</db:link> getting destroyed which implies an early-release of the associated resources managed by the still-alive <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>.</db:para>
<db:para>Another case when this function is called is when <db:link xlink:href="qrhiwidget.xml#grabFramebuffer">grabFramebuffer</db:link>() is used with a <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> that is not added to a visible window, i.e. the rendering is performed offscreen. If later on this <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> is made visible, or added to a visible widget hierarchy, the associated <db:link xlink:href="qrhi.xml">QRhi</db:link> will change from the temporary one used for offscreen rendering to the window's dedicated one, thus triggering this function as well.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="render">
<db:title>[virtual protected] void QRhiWidget::render(QRhiCommandBuffer *<db:emphasis>cb</db:emphasis>)</db:title>
<db:para>Called when the widget contents (i.e. the contents of the texture) need updating.</db:para>
<db:para>There is always at least one call to <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() before this function is called.</db:para>
<db:para>To request updates, call <db:link xlink:href="qwidget.xml#update">QWidget::update</db:link>(). Calling <db:link xlink:href="qwidget.xml#update">update</db:link>() from within render() will lead to updating continuously, throttled by vsync.</db:para>
<db:para><db:code role="parameter">cb</db:code> is the <db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link> for the current frame of the widget. The function is called with a frame being recorded, but without an active render pass.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="renderFailed">
<db:title>void QRhiWidget::renderFailed()</db:title>
<db:para>This signal is emitted whenever the widget is supposed to render to its backing texture (either due to a <db:link xlink:href="qwidget.xml#update">widget update</db:link> or due to a call to <db:link xlink:href="qrhiwidget.xml#grabFramebuffer">grabFramebuffer</db:link>()), but there is no <db:link xlink:href="qrhi.xml">QRhi</db:link> for the widget to use, likely due to issues related to graphics configuration.</db:para>
<db:para>This signal may be emitted multiple times when a problem arises. Do not assume it is emitted only once. Connect with <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::SingleShotConnection</db:link> if the error handling code is to be notified only once.</db:para>
</db:section>
<db:section xml:id="renderTarget">
<db:title>[protected] QRhiRenderTarget *QRhiWidget::renderTarget() const</db:title>
<db:para>Returns the render target object that must be used with <db:link xlink:href="qrhicommandbuffer.xml#beginPass">QRhiCommandBuffer::beginPass</db:link>() in reimplementations of <db:link xlink:href="qrhiwidget.xml#render">render</db:link>().</db:para>
<db:para>Must only be called from <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() and <db:link xlink:href="qrhiwidget.xml#render">render</db:link>().</db:para>
<db:para>Available only when <db:link xlink:href="qrhiwidget.xml#autoRenderTarget-prop">autoRenderTarget</db:link> is true. Otherwise the returned value is nullptr and it is up the reimplementation of <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() to create and manage a depth-stencil buffer and a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link>.</db:para>
<db:para>When creating <db:link xlink:href="qrhigraphicspipeline.xml">graphics pipelines</db:link>, a <db:link xlink:href="qrhirenderpassdescriptor.xml">QRhiRenderPassDescriptor</db:link> is needed. This can be queried from the returned <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> by calling <db:link xlink:href="">renderPassDescriptor()</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#colorTexture">colorTexture</db:link>()</db:member>
<db:member><db:link xlink:href="qrhiwidget.xml#depthStencilBuffer">depthStencilBuffer</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="resizeEvent">
<db:title>[override virtual protected] void QRhiWidget::resizeEvent(QResizeEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qwidget.xml#resizeEvent" role="function">QWidget::resizeEvent(QResizeEvent *event)</db:link>.</db:para>
<db:para>Handles resize events that are passed in the <db:code role="parameter">e</db:code> event parameter. Calls the virtual function <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>().</db:para>
<db:note>
<db:para>Avoid overriding this function in derived classes. If that is not feasible, make sure that <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>'s implementation is invoked too. Otherwise the underlying texture object and related resources will not get resized properly and will lead to incorrect rendering.</db:para>
</db:note>
</db:section>
<db:section xml:id="resolveTexture">
<db:title>[protected] QRhiTexture *QRhiWidget::resolveTexture() const</db:title>
<db:para>Returns the non-multisample texture to which the multisample content is resolved.</db:para>
<db:para>The result is nullptr when multisample antialiasing is not enabled.</db:para>
<db:para>Must only be called from <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() and <db:link xlink:href="qrhiwidget.xml#render">render</db:link>().</db:para>
<db:para>With MSAA enabled, this is the texture that gets composited with the rest of the <db:link xlink:href="qwidget.xml">QWidget</db:link> content on-screen. However, the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>'s rendering must target the (multisample) <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> returned from <db:link xlink:href="qrhiwidget.xml#msaaColorBuffer">msaaColorBuffer</db:link>(). When <db:link xlink:href="qrhiwidget.xml#autoRenderTarget-prop">autoRenderTarget</db:link> is true, this is taken care of by the <db:link xlink:href="qrhirendertarget.xml">QRhiRenderTarget</db:link> returned from <db:link xlink:href="qrhiwidget.xml#renderTarget">renderTarget</db:link>(). Otherwise, it is up to the subclass code to correctly configure a render target object with both the color buffer and resolve textures.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#colorTexture">colorTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rhi">
<db:title>[protected] QRhi *QRhiWidget::rhi() const</db:title>
<db:para>Returns the current <db:link xlink:href="qrhi.xml">QRhi</db:link> object.</db:para>
<db:para>Must only be called from <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() and <db:link xlink:href="qrhiwidget.xml#render">render</db:link>().</db:para>
</db:section>
<db:section xml:id="setApi">
<db:title>void QRhiWidget::setApi(QRhiWidget::Api <db:emphasis>api</db:emphasis>)</db:title>
<db:para>Sets the graphics API and <db:link xlink:href="qrhi.xml">QRhi</db:link> backend to use to <db:code role="parameter">api</db:code>.</db:para>
<db:warning>
<db:para>This function must be called early enough, before the widget is added to a widget hierarchy and displayed on screen. For example, aim to call the function for the subclass constructor. If called too late, the function will have no effect.</db:para>
</db:warning>
<db:para>The default value depends on the platform: Metal on macOS and iOS, Direct 3D 11 on Windows, OpenGL otherwise.</db:para>
<db:para>The <db:code role="parameter">api</db:code> can only be set once for the widget and its top-level window, once it is done and takes effect, the window can only use that API and <db:link xlink:href="qrhi.xml">QRhi</db:link> backend to render. Attempting to set another value, or to add another <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> with a different <db:code role="parameter">api</db:code> will not function as expected.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#colorBufferFormat-prop">setColorBufferFormat</db:link>()</db:member>
<db:member><db:link xlink:href="qrhiwidget.xml#setDebugLayerEnabled">setDebugLayerEnabled</db:link>()</db:member>
<db:member><db:link xlink:href="qrhiwidget.xml#api">api</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAutoRenderTarget">
<db:title>[protected] void QRhiWidget::setAutoRenderTarget(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:para>Controls if a depth-stencil <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> and a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> is created and maintained automatically by the widget. The default value is true.</db:para>
<db:para>In automatic mode, the size and sample count of the depth-stencil buffer follows the color buffer texture's settings. In non-automatic mode, <db:link xlink:href="qrhiwidget.xml#renderTarget">renderTarget</db:link>() and <db:link xlink:href="qrhiwidget.xml#depthStencilBuffer">depthStencilBuffer</db:link>() always return nullptr and it is then up to the application's implementation of <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>() to take care of setting up and managing these objects.</db:para>
<db:para>Call this function with <db:code role="parameter">enabled</db:code> set to false early on, for example in the derived class' constructor, to disable the automatic mode.</db:para>
</db:section>
<db:section xml:id="setDebugLayerEnabled">
<db:title>void QRhiWidget::setDebugLayerEnabled(bool <db:emphasis>enable</db:emphasis>)</db:title>
<db:para>Requests the debug or validation layer of the underlying graphics API when <db:code role="parameter">enable</db:code> is true.</db:para>
<db:warning>
<db:para>This function must be called early enough, before the widget is added to a widget hierarchy and displayed on screen. For example, aim to call the function for the subclass constructor. If called too late, the function will have no effect.</db:para>
</db:warning>
<db:para>Applicable for Vulkan and Direct 3D.</db:para>
<db:para>By default this is disabled.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhiwidget.xml#setApi">setApi</db:link>()</db:member>
<db:member><db:link xlink:href="qrhiwidget.xml#isDebugLayerEnabled">isDebugLayerEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
