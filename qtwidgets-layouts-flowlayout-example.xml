<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>Flow Layout Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Flow Layout example demonstrates a custom layout that arranges child widgets from left to right and top to bottom in a top-level widget.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:alt>Screenshot of the Flow Layout example</db:alt>
<db:imageobject>
<db:imagedata fileref="images/flowlayout-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The items are first laid out horizontally and then vertically when each line in the layout runs out of space.</db:para>
<db:para>The Flowlayout class mainly uses <db:link xlink:href="qlayout.xml">QLayout</db:link> and <db:link xlink:href="qwidgetitem.xml">QWidgetItem</db:link>, while the Window uses <db:link xlink:href="qwidget.xml">QWidget</db:link> and <db:link xlink:href="qlabel.xml">QLabel</db:link>. We will only document the definition and implementation of <db:code>FlowLayout</db:code> below.</db:para>
<db:section xml:id="flowlayout-class-definition">
<db:title>FlowLayout Class Definition</db:title>
<db:para>The <db:code>FlowLayout</db:code> class inherits <db:link xlink:href="qlayout.xml">QLayout</db:link>. It is a custom layout class that arranges its child widgets horizontally and vertically.</db:para>
<db:programlisting language="cpp">class FlowLayout : public QLayout
{
public:
    explicit FlowLayout(QWidget *parent, int margin = -1, int hSpacing = -1, int vSpacing = -1);
    explicit FlowLayout(int margin = -1, int hSpacing = -1, int vSpacing = -1);
    ~FlowLayout();

    void addItem(QLayoutItem *item);
    int horizontalSpacing() const;
    int verticalSpacing() const;
    Qt::Orientations expandingDirections() const;
    bool hasHeightForWidth() const;
    int heightForWidth(int) const;
    int count() const;
    QLayoutItem *itemAt(int index) const;
    QSize minimumSize() const;
    void setGeometry(const QRect &amp;rect);
    QSize sizeHint() const;
    QLayoutItem *takeAt(int index);

private:
    int doLayout(const QRect &amp;rect, bool testOnly) const;
    int smartSpacing(QStyle::PixelMetric pm) const;

    QList&lt;QLayoutItem *&gt; itemList;
    int m_hSpace;
    int m_vSpace;
};
</db:programlisting>
<db:para>We reimplement functions inherited from <db:link xlink:href="qlayout.xml">QLayout</db:link>. These functions add items to the layout and handle their orientation and geometry.</db:para>
<db:para>We also declare two private methods, <db:code>doLayout()</db:code> and <db:code>smartSpacing()</db:code>. <db:code>doLayout()</db:code> lays out the layout items, while the <db:code>smartSpacing()</db:code> function calculates the spacing between them.</db:para>
</db:section>
<db:section xml:id="flowlayout-class-implementation">
<db:title>FlowLayout Class Implementation</db:title>
<db:para>We start off by looking at the constructor:</db:para>
<db:programlisting language="cpp">FlowLayout::FlowLayout(QWidget *parent, int margin, int hSpacing, int vSpacing)
    : QLayout(parent), m_hSpace(hSpacing), m_vSpace(vSpacing)
{
    setContentsMargins(margin, margin, margin, margin);
}

FlowLayout::FlowLayout(int margin, int hSpacing, int vSpacing)
    : m_hSpace(hSpacing), m_vSpace(vSpacing)
{
    setContentsMargins(margin, margin, margin, margin);
}
</db:programlisting>
<db:para>In the constructor we call <db:code>setContentsMargins()</db:code> to set the left, top, right and bottom margin. By default, <db:link xlink:href="qlayout.xml">QLayout</db:link> uses values provided by the current style (see <db:link xlink:href="qstyle.xml#PixelMetric-enum">QStyle::PixelMetric</db:link>).</db:para>
<db:programlisting language="cpp">FlowLayout::~FlowLayout()
{
    QLayoutItem *item;
    while ((item = takeAt(0)))
        delete item;
}
</db:programlisting>
<db:para>In this example we reimplement <db:code>addItem()</db:code>, which is a pure virtual function. When using <db:code>addItem()</db:code> the ownership of the layout items is transferred to the layout, and it is therefore the layout's responsibility to delete them.</db:para>
<db:programlisting language="cpp">void FlowLayout::addItem(QLayoutItem *item)
{
    itemList.append(item);
}
</db:programlisting>
<db:para><db:code>addItem()</db:code> is implemented to add items to the layout.</db:para>
<db:programlisting language="cpp">int FlowLayout::horizontalSpacing() const
{
    if (m_hSpace &gt;= 0) {
        return m_hSpace;
    } else {
        return smartSpacing(QStyle::PM_LayoutHorizontalSpacing);
    }
}

int FlowLayout::verticalSpacing() const
{
    if (m_vSpace &gt;= 0) {
        return m_vSpace;
    } else {
        return smartSpacing(QStyle::PM_LayoutVerticalSpacing);
    }
}
</db:programlisting>
<db:para>We implement <db:code>horizontalSpacing()</db:code> and <db:code>verticalSpacing()</db:code> to get hold of the spacing between the widgets inside the layout. If the value is less than or equal to 0, this value will be used. If not, <db:code>smartSpacing()</db:code> will be called to calculate the spacing.</db:para>
<db:programlisting language="cpp">int FlowLayout::count() const
{
    return itemList.size();
}

QLayoutItem *FlowLayout::itemAt(int index) const
{
    return itemList.value(index);
}

QLayoutItem *FlowLayout::takeAt(int index)
{
    if (index &gt;= 0 &amp;&amp; index &lt; itemList.size())
        return itemList.takeAt(index);
    else
        return 0;
}
</db:programlisting>
<db:para>We then implement <db:code>count()</db:code> to return the number of items in the layout. To navigate the list of items we use <db:code>itemAt()</db:code> and takeAt() to remove and return items from the list. If an item is removed, the remaining items will be renumbered. All three functions are pure virtual functions from <db:link xlink:href="qlayout.xml">QLayout</db:link>.</db:para>
<db:programlisting language="cpp">Qt::Orientations FlowLayout::expandingDirections() const
{
    return 0;
}
</db:programlisting>
<db:para><db:code>expandingDirections()</db:code> returns the <db:link xlink:href="qt.xml#Orientation-enum">Qt::Orientation</db:link>s in which the layout can make use of more space than its <db:code>sizeHint()</db:code>.</db:para>
<db:programlisting language="cpp">bool FlowLayout::hasHeightForWidth() const
{
    return true;
}

int FlowLayout::heightForWidth(int width) const
{
    int height = doLayout(QRect(0, 0, width, 0), true);
    return height;
}
</db:programlisting>
<db:para>To adjust to widgets of which height is dependent on width, we implement <db:code>heightForWidth()</db:code>. The function <db:code>hasHeightForWidth()</db:code> is used to test for this dependency, and <db:code>heightForWidth()</db:code> passes the width on to <db:code>doLayout()</db:code> which in turn uses the width as an argument for the layout rect, i.e., the bounds in which the items are laid out. This rect does not include the layout margin().</db:para>
<db:programlisting language="cpp">void FlowLayout::setGeometry(const QRect &amp;rect)
{
    QLayout::setGeometry(rect);
    doLayout(rect, false);
}

QSize FlowLayout::sizeHint() const
{
    return minimumSize();
}

QSize FlowLayout::minimumSize() const
{
    QSize size;
    QLayoutItem *item;
    foreach (item, itemList)
        size = size.expandedTo(item-&gt;minimumSize());

    size += QSize(2*margin(), 2*margin());
    return size;
}
</db:programlisting>
<db:para><db:code>setGeometry()</db:code> is normally used to do the actual layout, i.e., calculate the geometry of the layout's items. In this example, it calls <db:code>doLayout()</db:code> and passes the layout rect.</db:para>
<db:para><db:code>sizeHint()</db:code> returns the preferred size of the layout and <db:code>minimumSize()</db:code> returns the minimum size of the layout.</db:para>
<db:programlisting language="cpp">int FlowLayout::doLayout(const QRect &amp;rect, bool testOnly) const
{
    int left, top, right, bottom;
    getContentsMargins(&amp;left, &amp;top, &amp;right, &amp;bottom);
    QRect effectiveRect = rect.adjusted(+left, +top, -right, -bottom);
    int x = effectiveRect.x();
    int y = effectiveRect.y();
    int lineHeight = 0;
</db:programlisting>
<db:para><db:code>doLayout()</db:code> handles the layout if <db:code>horizontalSpacing()</db:code> or <db:code>verticalSpacing()</db:code> don't return the default value. It uses <db:code>getContentsMargins()</db:code> to calculate the area available to the layout items.</db:para>
<db:programlisting language="cpp">    QLayoutItem *item;
    foreach (item, itemList) {
        QWidget *wid = item-&gt;widget();
        int spaceX = horizontalSpacing();
        if (spaceX == -1)
            spaceX = wid-&gt;style()-&gt;layoutSpacing(
                QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Horizontal);
        int spaceY = verticalSpacing();
        if (spaceY == -1)
            spaceY = wid-&gt;style()-&gt;layoutSpacing(
                QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Vertical);
</db:programlisting>
<db:para>It then sets the proper amount of spacing for each widget in the layout, based on the current style.</db:para>
<db:programlisting language="cpp">        int nextX = x + item-&gt;sizeHint().width() + spaceX;
        if (nextX - spaceX &gt; effectiveRect.right() &amp;&amp; lineHeight &gt; 0) {
            x = effectiveRect.x();
            y = y + lineHeight + spaceY;
            nextX = x + item-&gt;sizeHint().width() + spaceX;
            lineHeight = 0;
        }

        if (!testOnly)
            item-&gt;setGeometry(QRect(QPoint(x, y), item-&gt;sizeHint()));

        x = nextX;
        lineHeight = qMax(lineHeight, item-&gt;sizeHint().height());
    }
    return y + lineHeight - rect.y() + bottom;
}
</db:programlisting>
<db:para>The position of each item in the layout is then calculated by adding the items width and the line height to the initial x and y coordinates. This in turn lets us find out whether the next item will fit on the current line or if it must be moved down to the next. We also find the height of the current line based on the widgets height.</db:para>
<db:programlisting language="cpp">int FlowLayout::smartSpacing(QStyle::PixelMetric pm) const
{
    QObject *parent = this-&gt;parent();
    if (!parent) {
        return -1;
    } else if (parent-&gt;isWidgetType()) {
        QWidget *pw = static_cast&lt;QWidget *&gt;(parent);
        return pw-&gt;style()-&gt;pixelMetric(pm, 0, pw);
    } else {
        return static_cast&lt;QLayout *&gt;(parent)-&gt;spacing();
    }
}
</db:programlisting>
<db:para><db:code>smartSpacing()</db:code> is designed to get the default spacing for either the top-level layouts or the sublayouts. The default spacing for top-level layouts, when the parent is a <db:link xlink:href="qwidget.xml">QWidget</db:link>, will be determined by querying the style. The default spacing for sublayouts, when the parent is a <db:link xlink:href="qlayout.xml">QLayout</db:link>, will be determined by querying the spacing of the parent layout.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="layouts/flowlayout/flowlayout.cpp">layouts/flowlayout/flowlayout.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="layouts/flowlayout/flowlayout.h">layouts/flowlayout/flowlayout.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="layouts/flowlayout/flowlayout.pro">layouts/flowlayout/flowlayout.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="layouts/flowlayout/main.cpp">layouts/flowlayout/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="layouts/flowlayout/window.cpp">layouts/flowlayout/window.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="layouts/flowlayout/window.h">layouts/flowlayout/window.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
