<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QQuickRhiItem Class</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> class is a portable alternative to <db:link xlink:href="qquickframebufferobject.xml">QQuickFramebufferObject</db:link> that is not tied to OpenGL, but rather allows integrating rendering with the <db:link xlink:href="qrhi.xml">QRhi</db:link> APIs with Qt Quick.</db:para>
<db:para><db:emphasis role="bold">This class is under development and is subject to change.</db:emphasis></db:para>
<db:para>This class was introduced in Qt 6.7.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QQuickRhiItem</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.7</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Quick)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Quick)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += quick</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qquickitem.xml" xlink:role="class">QQuickItem</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Status</db:term>
<db:listitem>
<db:para>Preliminary</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:para><db:emphasis role="bold">This class is under development and is subject to change.</db:emphasis></db:para>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:note>
<db:para><db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> is in tech preview in Qt 6.7. <db:emphasis role="bold">The API is under development and subject to change.</db:emphasis></db:para>
</db:note>
<db:para><db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> is effectively the counterpart of <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> in the world of Qt Quick. Both of these are meant to be subclassed, and they both enable recording <db:link xlink:href="qrhi.xml">QRhi</db:link>-based rendering that targets an offscreen color buffer. The resulting 2D image is then composited with the rest of the Qt Quick scene.</db:para>
<db:note>
<db:para>While <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> is a public Qt API, the <db:link xlink:href="qrhi.xml">QRhi</db:link> family of classes in the Qt Gui module, including <db:link xlink:href="qshader.xml">QShader</db:link> and <db:link xlink:href="qshaderdescription.xml">QShaderDescription</db:link>, offer limited compatibility guarantees. There are no source or binary compatibility guarantees for these classes, meaning the API is only guaranteed to work with the Qt version the application was developed against. Source incompatible changes are however aimed to be kept at a minimum and will only be made in minor releases (6.7, 6.8, and so on). <db:code>qquickrhiitem.h</db:code> does not directly include any <db:link xlink:href="qrhi.xml">QRhi</db:link>-related headers. To use those classes when implementing a <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> subclass, link to <db:code>Qt::GuiPrivate</db:code> (if using CMake), and include the appropriate headers with the <db:code>rhi</db:code> prefix, for example <db:code>#include &lt;rhi/qrhi.h&gt;</db:code>.</db:para>
</db:note>
<db:para><db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> is a replacement for the legacy <db:link xlink:href="qquickframebufferobject.xml">QQuickFramebufferObject</db:link> class. The latter is inherently tied to OpenGL / OpenGL ES, whereas <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> works with the <db:link xlink:href="qrhi.xml">QRhi</db:link> classes, allowing to run the same rendering code with Vulkan, Metal, Direct 3D 11/12, and OpenGL / OpenGL ES. Conceptually and functionally they are very close, and migrating from <db:link xlink:href="qquickframebufferobject.xml">QQuickFramebufferObject</db:link> to <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> is straightforward. <db:link xlink:href="qquickframebufferobject.xml">QQuickFramebufferObject</db:link> continues to be available to ensure compatibility for existing application code that works directly with the OpenGL API.</db:para>
<db:note>
<db:para><db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> will not be functional when using the <db:code>software</db:code> adaptation of the Qt Quick scene graph.</db:para>
</db:note>
<db:para>On most platforms, the scene graph rendering, and thus the rendering performed by the <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> will occur on a <db:link xlink:href="qtquick-visualcanvas-scenegraph.xml#scene-graph-and-rendering">dedicated thread</db:link>. For this reason, the <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> class enforces a strict separation between the item implementation (the <db:link xlink:href="qquickitem.xml">QQuickItem</db:link> subclass) and the actual rendering logic. All item logic, such as properties and UI-related helper functions exposed to QML must be located in the <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> subclass. Everything that relates to rendering must be located in the <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link> class. To avoid race conditions and read/write issues from two threads it is important that the renderer and the item never read or write shared variables. Communication between the item and the renderer should primarily happen via the QQuickRhiItem::synchronize() function. This function will be called on the render thread while the GUI thread is blocked. Using queued connections or events for communication between item and renderer is also possible.</db:para>
<db:para>Applications must subclass both <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> and <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link>. The pure virtual <db:link xlink:href="qquickrhiitem.xml#createRenderer">createRenderer</db:link>() function must be reimplemented to return a new instance of the <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link> subclass.</db:para>
<db:para>As with <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>, <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> automatically managed the color buffer, which is a 2D texture (<db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>) normally, or a <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> when multisampling is in use. (some 3D APIs differentiate between textures and renderbuffers, while with some others the underlying native resource is the same; renderbuffers are used mainly to allow multisampling with OpenGL ES 3.0)</db:para>
<db:para>The size of the texture will by default adapt to the size of the item (with the <db:link xlink:href="qquickwindow.xml#effectiveDevicePixelRatio">device pixel ratio</db:link> taken into account). If the item size changes, the texture is recreated with the correct size. If a fixed size is preferred, set <db:link xlink:href="qquickrhiitem.xml#fixedColorBufferWidth-prop">fixedColorBufferWidth</db:link> and <db:link xlink:href="qquickrhiitem.xml#fixedColorBufferHeight-prop">fixedColorBufferHeight</db:link> to non-zero values.</db:para>
<db:para><db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> is a <db:link xlink:href="qsgtextureprovider.xml">texture provider</db:link> and can be used directly in <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffects</db:link> and other classes that consume texture providers.</db:para>
<db:para>While not a primary use case, <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> also allows incorporating rendering code that directly uses a 3D graphics API such as Vulkan, Metal, Direct 3D, or OpenGL. See <db:link xlink:href="qrhicommandbuffer.xml#beginExternal">QRhiCommandBuffer::beginExternal</db:link>() for details on recording native commands within a <db:link xlink:href="qrhi.xml">QRhi</db:link> render pass, as well as <db:link xlink:href="qrhitexture.xml#createFrom">QRhiTexture::createFrom</db:link>() for a way to wrap an existing native texture and then use it with <db:link xlink:href="qrhi.xml">QRhi</db:link> in a subsequent render pass. See also <db:link xlink:href="qquickgraphicsconfiguration.xml">QQuickGraphicsConfiguration</db:link> regarding configuring the native 3D API environment (e.g. device extensions) and note that the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> can be associated with a custom <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> by calling <db:link xlink:href="qwindow.xml#setVulkanInstance">QWindow::setVulkanInstance</db:link>() early enough.</db:para>
<db:note>
<db:para><db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> always uses the same <db:link xlink:href="qrhi.xml">QRhi</db:link> instance the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> uses (and by extension, the same OpenGL context, Vulkan device, etc.). To choose which underlying 3D graphics API is used, call <db:link xlink:href="qquickwindow.xml#setGraphicsApi">setGraphicsApi</db:link>() on the <db:link xlink:href="qquickwindow.xml">QQuickWindow</db:link> early enough. Changing it is not possible once the scene graph has initialized, and all <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> instances in the scene will render using the same 3D API.</db:para>
</db:note>
<db:section xml:id="a-simple-example">
<db:title>A simple example</db:title>
<db:para>Take the following subclass of <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link>. It is shown here in complete form. It renders a single triangle with a perspective projection, where the triangle is rotated based on the <db:code>angle</db:code> property of the custom item. (meaning it can be driven for example with animations such as <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link> from QML)</db:para>
<db:programlisting language="cpp">class ExampleRhiItemRenderer : public QQuickRhiItemRenderer
{
public:
    void initialize(QRhiCommandBuffer *cb) override;
    void synchronize(QQuickRhiItem *item) override;
    void render(QRhiCommandBuffer *cb) override;

private:
    QRhi *m_rhi = nullptr;
    std::unique_ptr&lt;QRhiBuffer&gt; m_vbuf;
    std::unique_ptr&lt;QRhiBuffer&gt; m_ubuf;
    std::unique_ptr&lt;QRhiShaderResourceBindings&gt; m_srb;
    std::unique_ptr&lt;QRhiGraphicsPipeline&gt; m_pipeline;
    QMatrix4x4 m_viewProjection;
    float m_angle = 0.0f;
};

class ExampleRhiItem : public QQuickRhiItem
{
    Q_OBJECT
    QML_NAMED_ELEMENT(ExampleRhiItem)
    Q_PROPERTY(float angle READ angle WRITE setAngle NOTIFY angleChanged)

public:
    QQuickRhiItemRenderer *createRenderer() override;

    float angle() const { return m_angle; }
    void setAngle(float a);

signals:
    void angleChanged();

private:
    float m_angle = 0.0f;
};

QQuickRhiItemRenderer *ExampleRhiItem::createRenderer()
{
    return new ExampleRhiItemRenderer;
}

void ExampleRhiItem::setAngle(float a)
{
    if (m_angle == a)
        return;

    m_angle = a;
    emit angleChanged();
    update();
}

void ExampleRhiItemRenderer::synchronize(QQuickRhiItem *rhiItem)
{
    ExampleRhiItem *item = static_cast&lt;ExampleRhiItem *&gt;(rhiItem);
    if (item-&gt;angle() != m_angle)
        m_angle = item-&gt;angle();
}

static QShader getShader(const QString &amp;name)
{
    QFile f(name);
    return f.open(QIODevice::ReadOnly) ? QShader::fromSerialized(f.readAll()) : QShader();
}

static float vertexData[] = {
    0.0f,   0.5f,   1.0f, 0.0f, 0.0f,
    -0.5f,  -0.5f,   0.0f, 1.0f, 0.0f,
    0.5f,  -0.5f,   0.0f, 0.0f, 1.0f,
};

void ExampleRhiItemRenderer::initialize(QRhiCommandBuffer *cb)
{
    if (m_rhi != rhi()) {
        m_pipeline.reset();
        m_rhi = rhi();
    }

    if (!m_pipeline) {
        m_vbuf.reset(m_rhi-&gt;newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertexData)));
        m_vbuf-&gt;create();

        m_ubuf.reset(m_rhi-&gt;newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, 64));
        m_ubuf-&gt;create();

        m_srb.reset(m_rhi-&gt;newShaderResourceBindings());
        m_srb-&gt;setBindings({
            QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, m_ubuf.get()),
        });
        m_srb-&gt;create();

        m_pipeline.reset(m_rhi-&gt;newGraphicsPipeline());
        m_pipeline-&gt;setShaderStages({
            { QRhiShaderStage::Vertex, getShader(QLatin1String(&quot;:/shaders/color.vert.qsb&quot;)) },
            { QRhiShaderStage::Fragment, getShader(QLatin1String(&quot;:/shaders/color.frag.qsb&quot;)) }
        });
        QRhiVertexInputLayout inputLayout;
        inputLayout.setBindings({
            { 5 * sizeof(float) }
        });
        inputLayout.setAttributes({
            { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
            { 0, 1, QRhiVertexInputAttribute::Float3, 2 * sizeof(float) }
        });
        m_pipeline-&gt;setVertexInputLayout(inputLayout);
        m_pipeline-&gt;setShaderResourceBindings(m_srb.get());
        m_pipeline-&gt;setRenderPassDescriptor(renderTarget()-&gt;renderPassDescriptor());
        m_pipeline-&gt;create();

        QRhiResourceUpdateBatch *resourceUpdates = m_rhi-&gt;nextResourceUpdateBatch();
        resourceUpdates-&gt;uploadStaticBuffer(m_vbuf.get(), vertexData);
        cb-&gt;resourceUpdate(resourceUpdates);
    }

    const QSize outputSize = renderTarget()-&gt;pixelSize();
    m_viewProjection = m_rhi-&gt;clipSpaceCorrMatrix();
    m_viewProjection.perspective(45.0f, outputSize.width() / (float) outputSize.height(), 0.01f, 1000.0f);
    m_viewProjection.translate(0, 0, -4);
}

void ExampleRhiItemRenderer::render(QRhiCommandBuffer *cb)
{
    QRhiResourceUpdateBatch *resourceUpdates = m_rhi-&gt;nextResourceUpdateBatch();
    QMatrix4x4 modelViewProjection = m_viewProjection;
    modelViewProjection.rotate(m_angle, 0, 1, 0);
    resourceUpdates-&gt;updateDynamicBuffer(m_ubuf.get(), 0, 64, modelViewProjection.constData());

    const QColor clearColor = QColor::fromRgbF(0.4f, 0.7f, 0.0f, 1.0f);
    cb-&gt;beginPass(renderTarget(), clearColor, { 1.0f, 0 }, resourceUpdates);

    cb-&gt;setGraphicsPipeline(m_pipeline.get());
    const QSize outputSize = renderTarget()-&gt;pixelSize();
    cb-&gt;setViewport(QRhiViewport(0, 0, outputSize.width(), outputSize.height()));
    cb-&gt;setShaderResources();
    const QRhiCommandBuffer::VertexInput vbufBinding(m_vbuf.get(), 0);
    cb-&gt;setVertexInput(0, 1, &amp;vbufBinding);
    cb-&gt;draw(3);

    cb-&gt;endPass();
}
</db:programlisting>
<db:para>It is notable that this simple class is almost exactly the same as the code shown in the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> introduction. The vertex and fragment shaders are the same as well. These are provided as Vulkan-style GLSL source code and must be processed first by the Qt shader infrastructure first. This is achieved either by running the <db:code>qsb</db:code> command-line tool manually, or by using the <db:link xlink:href="">qt_add_shaders()</db:link> function in CMake. The <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> loads these pre-processed <db:code>.qsb</db:code> files that are shipped with the application. See <db:link xlink:href="">Qt Shader Tools</db:link> for more information about Qt's shader translation infrastructure.</db:para>
<db:para><db:code>color.vert</db:code></db:para>
<db:programlisting language="cpp">#version 440
layout(location = 0) in vec4 position;
layout(location = 1) in vec3 color;
layout(location = 0) out vec3 v_color;
layout(std140, binding = 0) uniform buf {
    mat4 mvp;
};

void main()
{
    v_color = color;
    gl_Position = mvp * position;
}
</db:programlisting>
<db:para><db:code>color.frag</db:code></db:para>
<db:programlisting language="cpp">#version 440
layout(location = 0) in vec3 v_color;
layout(location = 0) out vec4 fragColor;

void main()
{
    fragColor = vec4(v_color, 1.0);
}
</db:programlisting>
<db:para>Once exposed to QML (note the <db:code>QML_NAMED_ELEMENT</db:code>), our custom item can be instantiated in any scene. (after importing the appropriate <db:code>URI</db:code> specified for <db:link xlink:href="qt-add-qml-module.xml">qt_add_qml_module</db:link> in the CMake project)</db:para>
<db:programlisting language="cpp">ExampleRhiItem {
    anchors.fill: parent
    anchors.margins: 10
    NumberAnimation on angle { from: 0; to: 360; duration: 5000; loops: Animation.Infinite }
}
</db:programlisting>
<db:para>See <db:link xlink:href="qtquick-scenegraph-rhitextureitem-example.xml">Scene Graph - RHI Texture Item</db:link> for a more complex example.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link></db:member>
<db:member><db:link xlink:href="qtquick-scenegraph-rhitextureitem-example.xml">Scene Graph - RHI Texture Item</db:link></db:member>
<db:member><db:link xlink:href="qrhi.xml">QRhi</db:link></db:member>
<db:member><db:link xlink:href="qtquick-visualcanvas-scenegraph.xml#scene-graph-and-rendering">Scene Graph and Rendering</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="alphaBlending-prop">
<db:title>alphaBlending : bool</db:title>
<db:para>Controls if blending is always enabled when drawing the quad textured with the content generated by the <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> and its renderer.</db:para>
<db:para>The default value is <db:code>false</db:code>. This is for performance reasons: if semi-transparency is not involved, because the <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link> clears to an opaque color and never renders fragments with alpha smaller than 1, then there is no point in enabling blending.</db:para>
<db:para>If the <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link> subclass renders with semi-transparency involved, set this property to true.</db:para>
<db:note>
<db:para>Under certain conditions blending is still going to happen regardless of the value of this property. For example, if the item's <db:link xlink:href="qquickitem.xml#opacity-prop">opacity</db:link> (more precisely, the combined opacity inherited from the parent chain) is smaller than 1, blending will be automatically enabled even when this property is set to false.</db:para>
</db:note>
<db:note>
<db:para>The Qt Quick scene graph relies on and expect pre-multiplied alpha. For example, if the intention is to clear the background in the renderer to an alpha value of 0.5, then make sure to multiply the red, green, and blue clear color values with 0.5 as well. Otherwise the blending results will be incorrect.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">alphaBlending</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setAlphaBlending</db:emphasis>(<db:type>bool</db:type> <db:emphasis>enable</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">alphaBlendingChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="colorBufferFormat-prop">
<db:title>colorBufferFormat : TextureFormat</db:title>
<db:para>This property controls the texture format for the texture used as the color buffer. The default value is TextureFormat::RGBA8. <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> supports rendering to a subset of the formats supported by <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>. Only formats that are reported as supported from <db:link xlink:href="qrhi.xml#isTextureFormatSupported">QRhi::isTextureFormatSupported</db:link>() should be specified, rendering will not be functional otherwise.</db:para>
<db:note>
<db:para>Setting a new format when the item and its renderer are already initialized and have rendered implies that all <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> objects created by the renderer may become unusable, if the associated <db:link xlink:href="qrhirenderpassdescriptor.xml">QRhiRenderPassDescriptor</db:link> is now incompatible due to the different texture format. Similarly to changing <db:link xlink:href="qquickrhiitem.xml#sampleCount-prop">sampleCount</db:link> dynamically, this means that initialize() or render() implementations must then take care of releasing the existing pipelines and creating new ones.</db:para>
</db:note>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>QQuickRhiItem::TextureFormat</db:type> <db:emphasis role="bold">colorBufferFormat</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setColorBufferFormat</db:emphasis>(<db:type>QQuickRhiItem::TextureFormat</db:type> <db:emphasis>format</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">colorBufferFormatChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="effectiveColorBufferSize-prop">
<db:title>[read-only] effectiveColorBufferSize : const QSize</db:title>
<db:para>This property exposes the size, in pixels, of the underlying color buffer (the <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> or <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link>). It is provided for use on the GUI (main) thread, in QML bindings or JavaScript.</db:para>
<db:note>
<db:para><db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link> implementations, operating on the scene graph render thread, should not use this property. Those should rather query the size from the <db:link xlink:href="qquickrhiitemrenderer.xml#renderTarget">render target</db:link>.</db:para>
</db:note>
<db:note>
<db:para>The value becomes available asynchronously from the main thread's perspective in the sense that the value changes when rendering happens on the render thread. This means that this property is useful mainly in QML bindings. Application code must not assume that the value is up to date already when the <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> object is constructed.</db:para>
</db:note>
<db:para>This is a read-only property.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qsize.xml">QSize</db:link></db:type> <db:emphasis role="bold">effectiveColorBufferSize</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">effectiveColorBufferSizeChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="fixedColorBufferHeight-prop">
<db:title>fixedColorBufferHeight : int</db:title>
<db:para>The fixed height, in pixels, of the item's associated texture. Relevant when a fixed texture size is desired that does not depend on the item's size. This size has no effect on the geometry of the item (its size and placement within the scene), which means the texture's content will appear stretched (scaled up) or scaled down onto the item's area.</db:para>
<db:para>For example, setting a size that is exactly twice the item's (pixel) size effectively performs 2x supersampling (rendering at twice the resolution and then implicitly scaling down when texturing the quad corresponding to the item in the scene).</db:para>
<db:para>By default the value is <db:code>0</db:code>. A value of 0 means that texture's size follows the item's size. (<db:code>texture size</db:code> = <db:code>item size</db:code> * <db:code>device pixel ratio</db:code>).</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">fixedColorBufferHeight</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setFixedColorBufferHeight</db:emphasis>(<db:type>int</db:type> <db:emphasis>height</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">fixedColorBufferHeightChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="fixedColorBufferWidth-prop">
<db:title>fixedColorBufferWidth : int</db:title>
<db:para>The fixed width, in pixels, of the item's associated texture or renderbuffer. Relevant when a fixed color buffer size is desired that does not depend on the item's size. This size has no effect on the geometry of the item (its size and placement within the scene), which means the texture's content will appear stretched (scaled up) or scaled down onto the item's area.</db:para>
<db:para>For example, setting a size that is exactly twice the item's (pixel) size effectively performs 2x supersampling (rendering at twice the resolution and then implicitly scaling down when texturing the quad corresponding to the item in the scene).</db:para>
<db:para>By default the value is <db:code>0</db:code>. A value of 0 means that texture's size follows the item's size. (<db:code>texture size</db:code> = <db:code>item size</db:code> * <db:code>device pixel ratio</db:code>).</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">fixedColorBufferWidth</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setFixedColorBufferWidth</db:emphasis>(<db:type>int</db:type> <db:emphasis>width</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">fixedColorBufferWidthChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="mirrorVertically-prop">
<db:title>mirrorVertically : bool</db:title>
<db:para>This property controls if texture UVs are flipped when drawing the textured quad. It has no effect on the contents of the offscreen color buffer and the rendering implemented by the <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link>.</db:para>
<db:para>The default value is <db:code>false</db:code>.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isMirrorVerticallyEnabled</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setMirrorVertically</db:emphasis>(<db:type>bool</db:type> <db:emphasis>enable</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">mirrorVerticallyChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="sampleCount-prop">
<db:title>sampleCount : int</db:title>
<db:para>This property controls for sample count for multisample antialiasing. By default the value is <db:code>1</db:code> which means MSAA is disabled.</db:para>
<db:para>Valid values are 1, 4, 8, and sometimes 16 and 32. <db:link xlink:href="qrhi.xml#supportedSampleCounts">QRhi::supportedSampleCounts</db:link>() can be used to query the supported sample counts at run time, but typically applications should request 1 (no MSAA), 4x (normal MSAA) or 8x (high MSAA).</db:para>
<db:note>
<db:para>Setting a new value implies that all <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> objects created by the renderer must use the same sample count from then on. Existing <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> objects created with a different sample count must not be used anymore. When the value changes, all color and depth-stencil buffers are destroyed and recreated automatically, and <db:link xlink:href="qquickrhiitemrenderer.xml#initialize">initialize</db:link>() is invoked again. However, when <db:link xlink:href="qquickrhiitem.xml#isAutoRenderTargetEnabled">isAutoRenderTargetEnabled</db:link>() is <db:code>false</db:code>, it will be up to the application to manage this with regards to the depth-stencil buffer or additional color buffers.</db:para>
</db:note>
<db:para>Changing the sample count from the default 1 to a higher value implies that <db:link xlink:href="qquickrhiitemrenderer.xml#colorTexture">colorTexture</db:link>() becomes <db:code>nullptr</db:code> and <db:link xlink:href="qquickrhiitemrenderer.xml#msaaColorBuffer">msaaColorBuffer</db:link>() starts returning a valid object. Switching back to 1 (or 0), implies the opposite: in the next call to initialize() msaaColorBuffer() is going to return <db:code>nullptr</db:code>, whereas colorTexture() becomes once again valid. In addition, <db:link xlink:href="qquickrhiitemrenderer.xml#resolveTexture">resolveTexture</db:link>() returns a valid (non-multisample) <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> whenever the sample count is greater than 1 (i.e., MSAA is in use).</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">sampleCount</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setSampleCount</db:emphasis>(<db:type>int</db:type> <db:emphasis>samples</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">sampleCountChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#msaaColorBuffer">QQuickRhiItemRenderer::msaaColorBuffer</db:link>()</db:member>
<db:member><db:link xlink:href="qquickrhiitemrenderer.xml#resolveTexture">QQuickRhiItemRenderer::resolveTexture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QQuickRhiItem">
<db:title>[explicit] QQuickRhiItem::QQuickRhiItem(QQuickItem *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:para>Constructs a new <db:link xlink:href="qquickrhiitem.xml">QQuickRhiItem</db:link> with the given <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QQuickRhiItem">
<db:title>[override virtual noexcept] QQuickRhiItem::~QQuickRhiItem()</db:title>
<db:para>Destructor.</db:para>
</db:section>
<db:section xml:id="createRenderer">
<db:title>[pure virtual protected] QQuickRhiItemRenderer *QQuickRhiItem::createRenderer()</db:title>
<db:para>Reimplement this function to create and return a new instance of a <db:link xlink:href="qquickrhiitemrenderer.xml">QQuickRhiItemRenderer</db:link> subclass.</db:para>
<db:para>This function will be called on the rendering thread while the GUI thread is blocked.</db:para>
</db:section>
<db:section xml:id="event">
<db:title>[override virtual protected] bool QQuickRhiItem::event(QEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qquickitem.xml#event" role="function">QQuickItem::event(QEvent *ev)</db:link>.</db:para>
</db:section>
<db:section xml:id="geometryChange">
<db:title>[override virtual protected] void QQuickRhiItem::geometryChange(const QRectF &amp;<db:emphasis>newGeometry</db:emphasis>, const QRectF &amp;<db:emphasis>oldGeometry</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qquickitem.xml#geometryChange" role="function">QQuickItem::geometryChange(const QRectF &amp;newGeometry, const QRectF &amp;oldGeometry)</db:link>.</db:para>
</db:section>
<db:section xml:id="isAutoRenderTargetEnabled">
<db:title>[protected] bool QQuickRhiItem::isAutoRenderTargetEnabled() const</db:title>
<db:para>Returns the current automatic depth-stencil buffer and render target management setting.</db:para>
<db:para>By default this value is <db:code>true</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qquickrhiitem.xml#setAutoRenderTarget">setAutoRenderTarget</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isTextureProvider">
<db:title>[override virtual] bool QQuickRhiItem::isTextureProvider() const</db:title>
<db:para>Reimplements: <db:link xlink:href="qquickitem.xml#isTextureProvider" role="function">QQuickItem::isTextureProvider() const</db:link>.</db:para>
</db:section>
<db:section xml:id="releaseResources">
<db:title>[override virtual protected] void QQuickRhiItem::releaseResources()</db:title>
<db:para>Reimplements: <db:link xlink:href="qquickitem.xml#releaseResources" role="function">QQuickItem::releaseResources()</db:link>.</db:para>
</db:section>
<db:section xml:id="setAutoRenderTarget">
<db:title>[protected] void QQuickRhiItem::setAutoRenderTarget(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:para>Controls if a depth-stencil <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> and a <db:link xlink:href="qrhitexturerendertarget.xml">QRhiTextureRenderTarget</db:link> is created and maintained automatically by the item. The default value is <db:code>true</db:code>. Call this function early on, for example from the derived class' constructor, with <db:code role="parameter">enabled</db:code> set to <db:code>false</db:code> to disable this.</db:para>
<db:para>In automatic mode, the size and sample count of the depth-stencil buffer follows the color buffer texture's settings. In non-automatic mode, renderTarget() and depthStencilBuffer() always return <db:code>nullptr</db:code> and it is then up to the application's implementation of initialize() to take care of setting up and managing these objects.</db:para>
</db:section>
<db:section xml:id="textureProvider">
<db:title>[override virtual] QSGTextureProvider *QQuickRhiItem::textureProvider() const</db:title>
<db:para>Reimplements: <db:link xlink:href="qquickitem.xml#textureProvider" role="function">QQuickItem::textureProvider() const</db:link>.</db:para>
</db:section>
</db:section>
</db:article>
