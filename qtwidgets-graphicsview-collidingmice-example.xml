<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Colliding Mice Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.13.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Demonstrates how to animate items on a graphics view.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The Colliding Mice example shows how to use the Graphics View framework to implement animated items and detect collision between items.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/collidingmice-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Graphics View provides the QGraphicsScene class for managing and interacting with a large number of custom-made 2D graphical items derived from the QGraphicsItem class, and a QGraphicsView widget for visualizing the items, with support for zooming and rotation.</db:para>
<db:para>The example consists of an item class and a main function: the <db:code>Mouse</db:code> class represents the individual mice extending QGraphicsItem, and the <db:code>main()</db:code> function provides the main application window.</db:para>
<db:para>We will first review the <db:code>Mouse</db:code> class to see how to animate items and detect item collisions, and then we will review the <db:code>main()</db:code> function to see how to put the items into a scene and how to implement the corresponding view.</db:para>
<db:section xml:id="mouse-class-definition">
<db:title>Mouse Class Definition</db:title>
<db:para>The <db:code>mouse</db:code> class inherits from QGraphicsItem. The QGraphicsItem class is the base class for all graphical items in the Graphics View framework, and provides a light-weight foundation for writing your own custom items.</db:para>
<db:programlisting language="cpp">class Mouse : public QGraphicsItem
{
public:
    Mouse();

    QRectF boundingRect() const override;
    QPainterPath shape() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option,
               QWidget *widget) override;

protected:
    void advance(int step) override;

private:
    qreal angle;
    qreal speed;
    qreal mouseEyeDirection;
    QColor color;
};
</db:programlisting>
<db:para>When writing a custom graphics item, you must implement QGraphicsItem's two pure virtual public functions: <db:link xlink:href="">boundingRect()</db:link>, which returns an estimate of the area painted by the item, and <db:link xlink:href="">paint()</db:link>, which implements the actual painting. In addition, we reimplement the <db:link xlink:href="">shape()</db:link> and <db:link xlink:href="">advance()</db:link>. We reimplement <db:link xlink:href="">shape()</db:link> to return an accurate shape of our mouse item; the default implementation simply returns the item's bounding rectangle. We reimplement <db:link xlink:href="">advance()</db:link> to handle the animation so it all happens on one update.</db:para>
</db:section>
<db:section xml:id="mouse-class-definition">
<db:title>Mouse Class Definition</db:title>
<db:para>When constructing a mouse item, we first ensure that all the item's private variables are properly initialized:</db:para>
<db:programlisting language="cpp">Mouse::Mouse()
    : angle(0), speed(0), mouseEyeDirection(0),
      color(QRandomGenerator::global()-&amp;gt;bounded(256), QRandomGenerator::global()-&amp;gt;bounded(256), QRandomGenerator::global()-&amp;gt;bounded(256))
{
    setRotation(QRandomGenerator::global()-&amp;gt;bounded(360 * 16));
}
</db:programlisting>
<db:para>To calculate the various components of the mouse's color, we use <db:link xlink:href="qrandomgenerator.xml">QRandomGenerator</db:link>.</db:para>
<db:para>Then we call the <db:link xlink:href="">setRotation()</db:link> function inherited from QGraphicsItem. Items live in their own local coordinate system. Their coordinates are usually centered around (0, 0), and this is also the center for all transformations. By calling the item's <db:link xlink:href="">setRotation()</db:link> function we alter the direction in which the mouse will start moving.</db:para>
<db:para>When the QGraphicsScene decides to advance the scene by a frame, it will call QGraphicsItem::advance() on each of the items. This enables us to animate our mouse using our reimplementation of the advance() function.</db:para>
<db:programlisting language="cpp">void Mouse::advance(int step)
{
    if (!step)
        return;
    QLineF lineToCenter(QPointF(0, 0), mapFromScene(0, 0));
    if (lineToCenter.length() &amp;gt; 150) {
        qreal angleToCenter = std::atan2(lineToCenter.dy(), lineToCenter.dx());
        angleToCenter = normalizeAngle((Pi - angleToCenter) + Pi / 2);

        if (angleToCenter &amp;lt; Pi &amp;amp;&amp;amp; angleToCenter &amp;gt; Pi / 4) {
            // Rotate left
            angle += (angle &amp;lt; -Pi / 2) ? 0.25 : -0.25;
        } else if (angleToCenter &amp;gt;= Pi &amp;amp;&amp;amp; angleToCenter &amp;lt; (Pi + Pi / 2 + Pi / 4)) {
            // Rotate right
            angle += (angle &amp;lt; Pi / 2) ? 0.25 : -0.25;
        }
    } else if (::sin(angle) &amp;lt; 0) {
        angle += 0.25;
    } else if (::sin(angle) &amp;gt; 0) {
        angle -= 0.25;
    }
</db:programlisting>
<db:para>First, we don't bother doing any advance if the step is <db:code>0</db:code>. This is because advance() is called twice: once with step == <db:code>0</db:code>, indicating that items are about to advance, and then with step == <db:code>1</db:code> for the actual advance. We also ensure that the mouse stays within a circle with a radius of 150 pixels.</db:para>
<db:para>Note the <db:link xlink:href="">mapFromScene()</db:link> function provided by QGraphicsItem. This function maps a position given in <db:emphasis>scene</db:emphasis> coordinates, to the item's coordinate system.</db:para>
<db:programlisting language="cpp">    const QList&amp;lt;QGraphicsItem *&amp;gt; dangerMice = scene()-&amp;gt;items(QPolygonF()
                           &amp;lt;&amp;lt; mapToScene(0, 0)
                           &amp;lt;&amp;lt; mapToScene(-30, -50)
                           &amp;lt;&amp;lt; mapToScene(30, -50));

    for (const QGraphicsItem *item : dangerMice) {
        if (item == this)
            continue;

        QLineF lineToMouse(QPointF(0, 0), mapFromItem(item, 0, 0));
        qreal angleToMouse = std::atan2(lineToMouse.dy(), lineToMouse.dx());
        angleToMouse = normalizeAngle((Pi - angleToMouse) + Pi / 2);

        if (angleToMouse &amp;gt;= 0 &amp;amp;&amp;amp; angleToMouse &amp;lt; Pi / 2) {
            // Rotate right
            angle += 0.5;
        } else if (angleToMouse &amp;lt;= TwoPi &amp;amp;&amp;amp; angleToMouse &amp;gt; (TwoPi - Pi / 2)) {
            // Rotate left
            angle -= 0.5;
        }
    }

    if (dangerMice.size() &amp;gt; 1 &amp;amp;&amp;amp; QRandomGenerator::global()-&amp;gt;bounded(10) == 0) {
        if (QRandomGenerator::global()-&amp;gt;bounded(1))
            angle += QRandomGenerator::global()-&amp;gt;bounded(1 / 500.0);
        else
            angle -= QRandomGenerator::global()-&amp;gt;bounded(1 / 500.0);
    }
</db:programlisting>
<db:para>Then we try to avoid colliding with other mice.</db:para>
<db:programlisting language="cpp">    speed += (-50 + QRandomGenerator::global()-&amp;gt;bounded(100)) / 100.0;

    qreal dx = ::sin(angle) * 10;
    mouseEyeDirection = (qAbs(dx / 5) &amp;lt; 1) ? 0 : dx / 5;

    setRotation(rotation() + dx);
    setPos(mapToParent(0, -(3 + sin(speed) * 3)));
}
</db:programlisting>
<db:para>Finally, we calculate the mouse's speed and its eye direction (for use when painting the mouse), and set its new position.</db:para>
<db:para>The position of an item describes its origin (local coordinate (0, 0)) in the parent coordinates. The <db:link xlink:href="">QGraphicsItem::setPos()</db:link> function sets the position of the item to the given position in the parent's coordinate system. For items with no parent, the given position is interpreted as scene coordinates. QGraphicsItem also provides a <db:link xlink:href="">mapToParent()</db:link> function to map a position given in item coordinates to the parent's coordinate system. If the item has no parent, the position will be mapped to the scene's coordinate system instead.</db:para>
<db:para>Then it is time to provide an implementation for the pure virtual functions inherited from QGraphicsItem. Let's first take a look at the <db:link xlink:href="">boundingRect()</db:link> function:</db:para>
<db:programlisting language="cpp">QRectF Mouse::boundingRect() const
{
    qreal adjust = 0.5;
    return QRectF(-18 - adjust, -22 - adjust,
                  36 + adjust, 60 + adjust);
}
</db:programlisting>
<db:para>The <db:link xlink:href="">boundingRect()</db:link> function defines the outer bounds of the item as a rectangle. Note that the Graphics View framework uses the bounding rectangle to determine whether the item requires redrawing, so all painting must be done inside this rectangle.</db:para>
<db:programlisting language="cpp">void Mouse::paint(QPainter *painter, const QStyleOptionGraphicsItem *, QWidget *)
{
    // Body
    painter-&amp;gt;setBrush(color);
    painter-&amp;gt;drawEllipse(-10, -20, 20, 40);

    // Eyes
    painter-&amp;gt;setBrush(Qt::white);
    painter-&amp;gt;drawEllipse(-10, -17, 8, 8);
    painter-&amp;gt;drawEllipse(2, -17, 8, 8);

    // Nose
    painter-&amp;gt;setBrush(Qt::black);
    painter-&amp;gt;drawEllipse(QRectF(-2, -22, 4, 4));

    // Pupils
    painter-&amp;gt;drawEllipse(QRectF(-8.0 + mouseEyeDirection, -17, 4, 4));
    painter-&amp;gt;drawEllipse(QRectF(4.0 + mouseEyeDirection, -17, 4, 4));

    // Ears
    painter-&amp;gt;setBrush(scene()-&amp;gt;collidingItems(this).isEmpty() ? Qt::darkYellow : Qt::red);
    painter-&amp;gt;drawEllipse(-17, -12, 16, 16);
    painter-&amp;gt;drawEllipse(1, -12, 16, 16);

    // Tail
    QPainterPath path(QPointF(0, 20));
    path.cubicTo(-5, 22, -5, 22, 0, 25);
    path.cubicTo(5, 27, 5, 32, 0, 30);
    path.cubicTo(-5, 32, -5, 42, 0, 35);
    painter-&amp;gt;setBrush(Qt::NoBrush);
    painter-&amp;gt;drawPath(path);
}
</db:programlisting>
<db:para>The Graphics View framework calls the <db:link xlink:href="">paint()</db:link> function to paint the contents of the item; the function paints the item in local coordinates.</db:para>
<db:para>Note the painting of the ears: whenever a mouse item collides with other mice items its ears are filled with red; otherwise they are filled with dark yellow. We use the QGraphicsScene::collidingItems() function to check if there are any colliding mice. The actual collision detection is handled by the Graphics View framework using shape-shape intersection. All we have to do is to ensure that the QGraphicsItem::shape() function returns an accurate shape for our item:</db:para>
<db:programlisting language="cpp">QPainterPath Mouse::shape() const
{
    QPainterPath path;
    path.addRect(-10, -20, 20, 40);
    return path;
}
</db:programlisting>
<db:para>Because the complexity of arbitrary shape-shape intersection grows with an order of magnitude when the shapes are complex, this operation can be noticably time consuming. An alternative approach is to reimplement the <db:link xlink:href="">collidesWithItem()</db:link> function to provide your own custom item and shape collision algorithm.</db:para>
<db:para>This completes the <db:code>Mouse</db:code> class implementation; it is now ready for use. Let's take a look at the <db:code>main()</db:code> function to see how to implement a scene for the mice and a view for displaying the contents of the scene.</db:para>
</db:section>
<db:section xml:id="the-main-function">
<db:title>The Main() Function</db:title>
<db:para>The <db:code>main()</db:code> function provides the main application window, as well as creating the items, their scene, and a corresponding view.</db:para>
<db:programlisting language="cpp">int main(int argc, char **argv)
{
    QApplication app(argc, argv);
</db:programlisting>
<db:para>First, we create an application object and create the scene:</db:para>
<db:programlisting language="cpp">    QGraphicsScene scene;
    scene.setSceneRect(-300, -300, 600, 600);
</db:programlisting>
<db:para>The QGraphicsScene class serves as a container for QGraphicsItems. It also provides functionality that lets you efficiently determine the location of items as well as determining which items are visible within an arbitrary area on the scene.</db:para>
<db:para>When creating a scene it is recommended to set the scene's rectangle; the rectangle that defines the extent of the scene. It is primarily used by QGraphicsView to determine the view's default scrollable area, and by QGraphicsScene to manage item indexing. If not explicitly set, the scene's default rectangle will be the largest bounding rectangle of all the items on the scene since the scene was created. This means that the rectangle will grow when items are added or moved in the scene, but it will never shrink.</db:para>
<db:programlisting language="cpp">    scene.setItemIndexMethod(QGraphicsScene::NoIndex);
</db:programlisting>
<db:para>The item index function is used to speed up item discovery. NoIndex implies that item location is of linear complexity, as all items on the scene are searched. Adding, moving and removing items, however, is done in constant time. This approach is ideal for dynamic scenes, where many items are added, moved or removed continuously. The alternative is BspTreeIndex, which makes use of a binary search to achieve item location algorithms that are of an order closer to logarithmic complexity.</db:para>
<db:programlisting language="cpp">    for (int i = 0; i &amp;lt; MouseCount; ++i) {
        Mouse *mouse = new Mouse;
        mouse-&amp;gt;setPos(::sin((i * 6.28) / MouseCount) * 200,
                      ::cos((i * 6.28) / MouseCount) * 200);
        scene.addItem(mouse);
    }
</db:programlisting>
<db:para>Then we add the mice to the scene.</db:para>
<db:programlisting language="cpp">    QGraphicsView view(&amp;amp;scene);
    view.setRenderHint(QPainter::Antialiasing);
    view.setBackgroundBrush(QPixmap(&quot;:/images/cheese.jpg&quot;));
</db:programlisting>
<db:para>To be able to view the scene, we must also create a QGraphicsView widget. The QGraphicsView class visualizes the contents of a scene in a scrollable viewport. We also ensure that the contents are rendered using antialiasing, and we create the cheese background by setting the view's background brush.</db:para>
<db:para>The image used for the background is stored as a binary file in the application's executable using Qt's <db:link xlink:href="resources.xml">resource system</db:link>. The QPixmap constructor accepts both file names that refer to actual files on disk and file names that refer to the application's embedded resources.</db:para>
<db:programlisting language="cpp">    view.setCacheMode(QGraphicsView::CacheBackground);
    view.setViewportUpdateMode(QGraphicsView::BoundingRectViewportUpdate);
    view.setDragMode(QGraphicsView::ScrollHandDrag);
</db:programlisting>
<db:para>Then we set the cache mode; QGraphicsView can cache pre-rendered content in a pixmap, which is then drawn onto the viewport. The purpose of such caching is to speed up the total rendering time for areas that are slow to render, for example: texture, gradient, and alpha blended backgrounds. The CacheMode property holds which parts of the view are cached, and the CacheBackground flag enables caching of the view's background.</db:para>
<db:para>By setting the dragMode property, we define what should happen when the user clicks on the scene background and drags the mouse. The ScrollHandDrag flag makes the cursor change into a pointing hand, and dragging the mouse around will scroll the scrollbars.</db:para>
<db:programlisting language="cpp">    view.setWindowTitle(QT_TRANSLATE_NOOP(QGraphicsView, &quot;Colliding Mice&quot;));
    view.resize(400, 300);
    view.show();

    QTimer timer;
    QObject::connect(&amp;amp;timer, &amp;amp;QTimer::timeout, &amp;amp;scene, &amp;amp;QGraphicsScene::advance);
    timer.start(1000 / 33);

    return app.exec();
}
</db:programlisting>
<db:para>In the end, we set the application window's title and size before we enter the main event loop using the QApplication::exec() function.</db:para>
<db:para>Finally, we create a QTimer and connect its timeout() signal to the advance() slot of the scene. Every time the timer fires, the scene will advance one frame.</db:para>
<db:para>We then tell the timer to fire every 1000/33 milliseconds. This will give us a frame rate of 30 frames a second, which is fast enough for most animations. Doing the animation with a single timer connection to advance the scene ensures that all the mice are moved at one point and, more importantly, only one update is sent to the screen after all the mice have moved.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/graphicsview/collidingmice?h=5.13">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
