<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSslSocket Class</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> class provides an SSL encrypted socket for both clients and servers.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSslSocket</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Network)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Network)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += network</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qtcpsocket.xml" xlink:role="class">QTcpSocket</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QSslSocket is part of <db:simplelist><db:member><db:link xlink:href="network.xml">Network Programming API</db:link></db:member><db:member>ssl</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> establishes a secure, encrypted TCP connection you can use for transmitting encrypted data. It can operate in both client and server mode, and it supports modern TLS protocols, including TLS 1.3. By default, <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> uses only TLS protocols which are considered to be secure (<db:link xlink:href="qssl.xml#SslProtocol-enum">QSsl::SecureProtocols</db:link>), but you can change the TLS protocol by calling <db:link xlink:href="qsslsocket.xml#setProtocol">setProtocol</db:link>() as long as you do it before the handshake has started.</db:para>
<db:para>SSL encryption operates on top of the existing TCP stream after the socket enters the ConnectedState. There are two simple ways to establish a secure connection using <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link>: With an immediate SSL handshake, or with a delayed SSL handshake occurring after the connection has been established in unencrypted mode.</db:para>
<db:para>The most common way to use <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> is to construct an object and start a secure connection by calling <db:link xlink:href="qsslsocket.xml#connectToHostEncrypted">connectToHostEncrypted</db:link>(). This method starts an immediate SSL handshake once the connection has been established.</db:para>
<db:programlisting language="cpp">QSslSocket *socket = new QSslSocket(this);
connect(socket, &amp;QSslSocket::encrypted, this, &amp;Receiver::ready);

socket-&gt;connectToHostEncrypted(&quot;imap.example.com&quot;, 993);
</db:programlisting>
<db:para>As with a plain <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>, <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> enters the HostLookupState, ConnectingState, and finally the ConnectedState, if the connection is successful. The handshake then starts automatically, and if it succeeds, the <db:link xlink:href="qsslsocket.xml#encrypted">encrypted</db:link>() signal is emitted to indicate the socket has entered the encrypted state and is ready for use.</db:para>
<db:para>Note that data can be written to the socket immediately after the return from <db:link xlink:href="qsslsocket.xml#connectToHostEncrypted">connectToHostEncrypted</db:link>() (i.e., before the <db:link xlink:href="qsslsocket.xml#encrypted">encrypted</db:link>() signal is emitted). The data is queued in <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> until after the <db:link xlink:href="qsslsocket.xml#encrypted">encrypted</db:link>() signal is emitted.</db:para>
<db:para>An example of using the delayed SSL handshake to secure an existing connection is the case where an SSL server secures an incoming connection. Suppose you create an SSL server class as a subclass of <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link>. You would override <db:link xlink:href="qtcpserver.xml#incomingConnection">QTcpServer::incomingConnection</db:link>() with something like the example below, which first constructs an instance of <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> and then calls <db:link xlink:href="qsslsocket.xml#setSocketDescriptor">setSocketDescriptor</db:link>() to set the new socket's descriptor to the existing one passed in. It then initiates the SSL handshake by calling <db:link xlink:href="qsslsocket.xml#startServerEncryption">startServerEncryption</db:link>().</db:para>
<db:programlisting language="cpp">void SslServer::incomingConnection(qintptr socketDescriptor)
{
    QSslSocket *serverSocket = new QSslSocket;
    if (serverSocket-&gt;setSocketDescriptor(socketDescriptor)) {
        addPendingConnection(serverSocket);
        connect(serverSocket, &amp;QSslSocket::encrypted, this, &amp;SslServer::ready);
        serverSocket-&gt;startServerEncryption();
    } else {
        delete serverSocket;
    }
}
</db:programlisting>
<db:para>If an error occurs, <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> emits the <db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>() signal. In this case, if no action is taken to ignore the error(s), the connection is dropped. To continue, despite the occurrence of an error, you can call <db:link xlink:href="qsslsocket.xml#ignoreSslErrors">ignoreSslErrors</db:link>(), either from within this slot after the error occurs, or any time after construction of the <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> and before the connection is attempted. This will allow <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> to ignore the errors it encounters when establishing the identity of the peer. Ignoring errors during an SSL handshake should be used with caution, since a fundamental characteristic of secure connections is that they should be established with a successful handshake.</db:para>
<db:para>Once encrypted, you use <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> as a regular <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>. When <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() is emitted, you can call <db:link xlink:href="qiodevice.xml#read">read</db:link>(), <db:link xlink:href="qsslsocket.xml#canReadLine">canReadLine</db:link>() and <db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>(), or <db:link xlink:href="qiodevice.xml#getChar">getChar</db:link>() to read decrypted data from <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link>'s internal buffer, and you can call <db:link xlink:href="qiodevice.xml#write">write</db:link>() or <db:link xlink:href="qiodevice.xml#putChar">putChar</db:link>() to write data back to the peer. <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> will automatically encrypt the written data for you, and emit <db:link xlink:href="qsslsocket.xml#encryptedBytesWritten">encryptedBytesWritten</db:link>() once the data has been written to the peer.</db:para>
<db:para>As a convenience, <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> supports <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>'s blocking functions <db:link xlink:href="qsslsocket.xml#waitForConnected">waitForConnected</db:link>(), <db:link xlink:href="qsslsocket.xml#waitForReadyRead">waitForReadyRead</db:link>(), <db:link xlink:href="qsslsocket.xml#waitForBytesWritten">waitForBytesWritten</db:link>(), and <db:link xlink:href="qsslsocket.xml#waitForDisconnected">waitForDisconnected</db:link>(). It also provides <db:link xlink:href="qsslsocket.xml#waitForEncrypted">waitForEncrypted</db:link>(), which will block the calling thread until an encrypted connection has been established.</db:para>
<db:programlisting language="cpp">QSslSocket socket;
socket.connectToHostEncrypted(&quot;http.example.com&quot;, 443);
if (!socket.waitForEncrypted()) {
    qDebug() &lt;&lt; socket.errorString();
    return false;
}

socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;);
while (socket.waitForReadyRead())
    qDebug() &lt;&lt; socket.readAll().data();
</db:programlisting>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> provides an extensive, easy-to-use API for handling cryptographic ciphers, private keys, and local, peer, and Certification Authority (CA) certificates. It also provides an API for handling errors that occur during the handshake phase.</db:para>
<db:para>The following features can also be customized:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The socket's cryptographic cipher suite can be customized before the handshake phase with <db:link xlink:href="qsslconfiguration.xml#setCiphers">QSslConfiguration::setCiphers</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para>The socket's local certificate and private key can be customized before the handshake phase with <db:link xlink:href="qsslsocket.xml#setLocalCertificate">setLocalCertificate</db:link>() and <db:link xlink:href="qsslsocket.xml#setPrivateKey">setPrivateKey</db:link>().</db:para>
</db:listitem>
<db:listitem>
<db:para>The CA certificate database can be extended and customized with <db:link xlink:href="qsslconfiguration.xml#addCaCertificate">QSslConfiguration::addCaCertificate</db:link>(), <db:link xlink:href="qsslconfiguration.xml#addCaCertificates">QSslConfiguration::addCaCertificates</db:link>().</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>To extend the list of <db:emphasis>default</db:emphasis> CA certificates used by the SSL sockets during the SSL handshake you must update the default configuration, as in the snippet below:</db:para>
<db:programlisting language="cpp">QList&lt;QSslCertificate&gt; certificates = getCertificates();
QSslConfiguration configuration = QSslConfiguration::defaultConfiguration();
configuration.addCaCertificates(certificates);
QSslConfiguration::setDefaultConfiguration(configuration);
</db:programlisting>
<db:note>
<db:para>If available, root certificates on Unix (excluding macOS) will be loaded on demand from the standard certificate directories. If you do not want to load root certificates on demand, you need to call either <db:link xlink:href="qsslconfiguration.xml#defaultConfiguration">QSslConfiguration::defaultConfiguration</db:link>().setCaCertificates() before the first SSL handshake is made in your application (for example, via passing QSslSocket::systemCaCertificates() to it), or call <db:link xlink:href="qsslconfiguration.xml#defaultConfiguration">QSslConfiguration::defaultConfiguration</db:link>()::setCaCertificates() on your <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> instance prior to the SSL handshake.</db:para>
</db:note>
<db:para>For more information about ciphers and certificates, refer to <db:link xlink:href="qsslcipher.xml">QSslCipher</db:link> and <db:link xlink:href="qsslcertificate.xml">QSslCertificate</db:link>.</db:para>
<db:para>This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (<db:link xlink:href="http://www.openssl.org/">http://www.openssl.org/</db:link>).</db:para>
<db:note>
<db:para>Be aware of the difference between the <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>() signal and the <db:link xlink:href="qsslsocket.xml#encryptedBytesWritten">encryptedBytesWritten</db:link>() signal. For a <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>, <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>() will get emitted as soon as data has been written to the TCP socket. For a <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link>, <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>() will get emitted when the data is being encrypted and <db:link xlink:href="qsslsocket.xml#encryptedBytesWritten">encryptedBytesWritten</db:link>() will get emitted as soon as data has been written to the TCP socket.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslcertificate.xml">QSslCertificate</db:link></db:member>
<db:member><db:link xlink:href="qsslcipher.xml">QSslCipher</db:link></db:member>
<db:member><db:link xlink:href="qsslerror.xml">QSslError</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="PeerVerifyMode-enum">
<db:title>enum QSslSocket::PeerVerifyMode</db:title>
<db:para>Describes the peer verification modes for <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link>. The default mode is AutoVerifyPeer, which selects an appropriate mode depending on the socket's QSocket::SslMode.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::VerifyNone</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> will not request a certificate from the peer. You can set this mode if you are not interested in the identity of the other side of the connection. The connection will still be encrypted, and your socket will still send its local certificate to the peer if it's requested.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::QueryPeer</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> will request a certificate from the peer, but does not require this certificate to be valid. This is useful when you want to display peer certificate details to the user without affecting the actual SSL handshake. This mode is the default for servers. Note: In Schannel this value acts the same as VerifyNone.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::VerifyPeer</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> will request a certificate from the peer during the SSL handshake phase, and requires that this certificate is valid. On failure, <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> will emit the <db:link xlink:href="qsslsocket.xml#sslErrors">QSslSocket::sslErrors</db:link>() signal. This mode is the default for clients.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::AutoVerifyPeer</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> will automatically use QueryPeer for server sockets and VerifyPeer for client sockets.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#peerVerifyMode">QSslSocket::peerVerifyMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="SslMode-enum">
<db:title>enum QSslSocket::SslMode</db:title>
<db:para>Describes the connection modes available for <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::UnencryptedMode</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The socket is unencrypted. Its behavior is identical to <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::SslClientMode</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The socket is a client-side SSL socket. It is either already encrypted, or it is in the SSL handshake phase (see <db:link xlink:href="qsslsocket.xml#isEncrypted">QSslSocket::isEncrypted</db:link>()).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::SslServerMode</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The socket is a server-side SSL socket. It is either already encrypted, or it is in the SSL handshake phase (see <db:link xlink:href="qsslsocket.xml#isEncrypted">QSslSocket::isEncrypted</db:link>()).</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QSslSocket">
<db:title>[explicit] QSslSocket::QSslSocket(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:para>Constructs a <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> object. <db:code role="parameter">parent</db:code> is passed to <db:link xlink:href="qobject.xml">QObject</db:link>'s constructor. The new socket's <db:link xlink:href="qsslcipher.xml">cipher</db:link> suite is set to the one returned by the static method defaultCiphers().</db:para>
</db:section>
<db:section xml:id="dtor.QSslSocket">
<db:title>[virtual noexcept] QSslSocket::~QSslSocket()</db:title>
<db:para>Destroys the <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link>.</db:para>
</db:section>
<db:section xml:id="activeBackend">
<db:title>[static, since 6.1] QString QSslSocket::activeBackend()</db:title>
<db:para>Returns the name of the backend that <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> and related classes use. If the active backend was not set explicitly, this function returns the name of a default backend that <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> selects implicitly from the list of available backends.</db:para>
<db:note>
<db:para>When selecting a default backend implicitly, <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> prefers the OpenSSL backend if available. If it's not available, the Schannel backend is implicitly selected on Windows, and Secure Transport on Darwin platforms. Failing these, if a custom TLS backend is found, it is used. If no other backend is found, the &quot;certificate only&quot; backend is selected. For more information about TLS plugins, please see <db:link xlink:href="ssl.xml#enabling-and-disabling-ssl-support-when-building-qt-from-source">Enabling and Disabling SSL Support when Building Qt from Source</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#setActiveBackend">setActiveBackend</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#availableBackends">availableBackends</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="alertReceived">
<db:title>void QSslSocket::alertReceived(QSsl::AlertLevel <db:emphasis>level</db:emphasis>, QSsl::AlertType <db:emphasis>type</db:emphasis>, const QString &amp;<db:emphasis>description</db:emphasis>)</db:title>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> emits this signal if an alert message was received from a peer. <db:code role="parameter">level</db:code> tells if the alert was fatal or it was a warning. <db:code role="parameter">type</db:code> is the code explaining why the alert was sent. When a textual description of the alert message is available, it is supplied in <db:code role="parameter">description</db:code>.</db:para>
<db:note>
<db:para>The signal is mostly for informational and debugging purposes and does not require any handling in the application. If the alert was fatal, underlying backend will handle it and close the connection.</db:para>
</db:note>
<db:note>
<db:para>Not all backends support this functionality.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#alertSent">alertSent</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#AlertLevel-enum">QSsl::AlertLevel</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml#AlertType-enum">QSsl::AlertType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="alertSent">
<db:title>void QSslSocket::alertSent(QSsl::AlertLevel <db:emphasis>level</db:emphasis>, QSsl::AlertType <db:emphasis>type</db:emphasis>, const QString &amp;<db:emphasis>description</db:emphasis>)</db:title>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> emits this signal if an alert message was sent to a peer. <db:code role="parameter">level</db:code> describes if it was a warning or a fatal error. <db:code role="parameter">type</db:code> gives the code of the alert message. When a textual description of the alert message is available, it is supplied in <db:code role="parameter">description</db:code>.</db:para>
<db:note>
<db:para>This signal is mostly informational and can be used for debugging purposes, normally it does not require any actions from the application.</db:para>
</db:note>
<db:note>
<db:para>Not all backends support this functionality.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#alertReceived">alertReceived</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#AlertLevel-enum">QSsl::AlertLevel</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml#AlertType-enum">QSsl::AlertType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="atEnd">
<db:title>[override virtual] bool QSslSocket::atEnd() const</db:title>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#atEnd" role="function">QIODevice::atEnd() const</db:link>.</db:para>
</db:section>
<db:section xml:id="availableBackends">
<db:title>[static, since 6.1] QList&lt;QString&gt; QSslSocket::availableBackends()</db:title>
<db:para>Returns the names of the currently available backends. These names are in lower case, e.g. &quot;openssl&quot;, &quot;securetransport&quot;, &quot;schannel&quot; (similar to the already existing feature names for TLS backends in Qt).</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#activeBackend">activeBackend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesAvailable">
<db:title>[override virtual] qint64 QSslSocket::bytesAvailable() const</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#bytesAvailable" role="function">QAbstractSocket::bytesAvailable() const</db:link>.</db:para>
<db:para>Returns the number of decrypted bytes that are immediately available for reading.</db:para>
</db:section>
<db:section xml:id="bytesToWrite">
<db:title>[override virtual] qint64 QSslSocket::bytesToWrite() const</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#bytesToWrite" role="function">QAbstractSocket::bytesToWrite() const</db:link>.</db:para>
<db:para>Returns the number of unencrypted bytes that are waiting to be encrypted and written to the network.</db:para>
</db:section>
<db:section xml:id="canReadLine">
<db:title>[override virtual] bool QSslSocket::canReadLine() const</db:title>
<db:para>Reimplements: <db:link xlink:href="qiodevice.xml#canReadLine" role="function">QIODevice::canReadLine() const</db:link>.</db:para>
<db:para>Returns true if you can read one while line (terminated by a single ASCII '\n' character) of decrypted characters; otherwise, false is returned.</db:para>
</db:section>
<db:section xml:id="close">
<db:title>[override virtual] void QSslSocket::close()</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#close" role="function">QAbstractSocket::close()</db:link>.</db:para>
</db:section>
<db:section xml:id="connectToHostEncrypted">
<db:title>void QSslSocket::connectToHostEncrypted(const QString &amp;<db:emphasis>hostName</db:emphasis>, quint16 <db:emphasis>port</db:emphasis>, QIODeviceBase::OpenMode <db:emphasis>mode</db:emphasis> = ReadWrite, QAbstractSocket::NetworkLayerProtocol <db:emphasis>protocol</db:emphasis> = AnyIPProtocol)</db:title>
<db:para>Starts an encrypted connection to the device <db:code role="parameter">hostName</db:code> on <db:code role="parameter">port</db:code>, using <db:code role="parameter">mode</db:code> as the <db:link xlink:href="qiodevicebase.xml#OpenModeFlag-enum">OpenMode</db:link>. This is equivalent to calling <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>() to establish the connection, followed by a call to <db:link xlink:href="qsslsocket.xml#startClientEncryption">startClientEncryption</db:link>(). The <db:code role="parameter">protocol</db:code> parameter can be used to specify which network protocol to use (eg. IPv4 or IPv6).</db:para>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> first enters the HostLookupState. Then, after entering either the event loop or one of the waitFor...() functions, it enters the ConnectingState, emits <db:link xlink:href="qabstractsocket.xml#connected">connected</db:link>(), and then initiates the SSL client handshake. At each state change, <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> emits signal <db:link xlink:href="qabstractsocket.xml#stateChanged">stateChanged</db:link>().</db:para>
<db:para>After initiating the SSL client handshake, if the identity of the peer can't be established, signal <db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>() is emitted. If you want to ignore the errors and continue connecting, you must call <db:link xlink:href="qsslsocket.xml#ignoreSslErrors">ignoreSslErrors</db:link>(), either from inside a slot function connected to the <db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>() signal, or prior to entering encrypted mode. If <db:link xlink:href="qsslsocket.xml#ignoreSslErrors">ignoreSslErrors</db:link>() is not called, the connection is dropped, signal <db:link xlink:href="qabstractsocket.xml#disconnected">disconnected</db:link>() is emitted, and <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> returns to the UnconnectedState.</db:para>
<db:para>If the SSL handshake is successful, <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> emits <db:link xlink:href="qsslsocket.xml#encrypted">encrypted</db:link>().</db:para>
<db:programlisting language="cpp">QSslSocket socket;
connect(&amp;socket, &amp;QSslSocket::encrypted, receiver, &amp;Receiver::socketEncrypted);

socket.connectToHostEncrypted(&quot;imap&quot;, 993);
socket-&gt;write(&quot;1 CAPABILITY\r\n&quot;);
</db:programlisting>
<db:note>
<db:para>The example above shows that text can be written to the socket immediately after requesting the encrypted connection, before the <db:link xlink:href="qsslsocket.xml#encrypted">encrypted</db:link>() signal has been emitted. In such cases, the text is queued in the object and written to the socket <db:emphasis>after</db:emphasis> the connection is established and the <db:link xlink:href="qsslsocket.xml#encrypted">encrypted</db:link>() signal has been emitted.</db:para>
</db:note>
<db:para>The default for <db:code role="parameter">mode</db:code> is <db:link xlink:href="qiodevicebase.xml#OpenModeFlag-enum">ReadWrite</db:link>.</db:para>
<db:para>If you want to create a <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> on the server side of a connection, you should instead call <db:link xlink:href="qsslsocket.xml#startServerEncryption">startServerEncryption</db:link>() upon receiving the incoming connection through <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#startClientEncryption">startClientEncryption</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#waitForConnected">waitForConnected</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#waitForEncrypted">waitForEncrypted</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectToHostEncrypted-1">
<db:title>void QSslSocket::connectToHostEncrypted(const QString &amp;<db:emphasis>hostName</db:emphasis>, quint16 <db:emphasis>port</db:emphasis>, const QString &amp;<db:emphasis>sslPeerName</db:emphasis>, QIODeviceBase::OpenMode <db:emphasis>mode</db:emphasis> = ReadWrite, QAbstractSocket::NetworkLayerProtocol <db:emphasis>protocol</db:emphasis> = AnyIPProtocol)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>In addition to the original behaviour of <db:link xlink:href="qsslsocket.xml#connectToHostEncrypted">connectToHostEncrypted</db:link>, this overloaded method enables the usage of a different hostname (<db:code role="parameter">sslPeerName</db:code>) for the certificate validation instead of the one used for the TCP connection (<db:code role="parameter">hostName</db:code>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#connectToHostEncrypted">connectToHostEncrypted</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="continueInterruptedHandshake">
<db:title>[since 6.0] void QSslSocket::continueInterruptedHandshake()</db:title>
<db:para>If an application wants to conclude a handshake even after receiving <db:link xlink:href="qsslsocket.xml#handshakeInterruptedOnError">handshakeInterruptedOnError</db:link>() signal, it must call this function. This call must be done from a slot function attached to the signal. The signal-slot connection must be direct.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#handshakeInterruptedOnError">handshakeInterruptedOnError</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setHandshakeMustInterruptOnError">QSslConfiguration::setHandshakeMustInterruptOnError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="encrypted">
<db:title>void QSslSocket::encrypted()</db:title>
<db:para>This signal is emitted when <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> enters encrypted mode. After this signal has been emitted, <db:link xlink:href="qsslsocket.xml#isEncrypted">QSslSocket::isEncrypted</db:link>() will return true, and all further transmissions on the socket will be encrypted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#connectToHostEncrypted">QSslSocket::connectToHostEncrypted</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#isEncrypted">QSslSocket::isEncrypted</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="encryptedBytesAvailable">
<db:title>qint64 QSslSocket::encryptedBytesAvailable() const</db:title>
<db:para>Returns the number of encrypted bytes that are awaiting decryption. Normally, this function will return 0 because <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> decrypts its incoming data as soon as it can.</db:para>
</db:section>
<db:section xml:id="encryptedBytesToWrite">
<db:title>qint64 QSslSocket::encryptedBytesToWrite() const</db:title>
<db:para>Returns the number of encrypted bytes that are waiting to be written to the network.</db:para>
</db:section>
<db:section xml:id="encryptedBytesWritten">
<db:title>void QSslSocket::encryptedBytesWritten(qint64 <db:emphasis>written</db:emphasis>)</db:title>
<db:para>This signal is emitted when <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> writes its encrypted data to the network. The <db:code role="parameter">written</db:code> parameter contains the number of bytes that were successfully written.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml#bytesWritten">QIODevice::bytesWritten</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="handshakeInterruptedOnError">
<db:title>void QSslSocket::handshakeInterruptedOnError(const QSslError &amp;<db:emphasis>error</db:emphasis>)</db:title>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> emits this signal if a certificate verification error was found and if early error reporting was enabled in <db:link xlink:href="qsslconfiguration.xml">QSslConfiguration</db:link>. An application is expected to inspect the <db:code role="parameter">error</db:code> and decide if it wants to continue the handshake, or abort it and send an alert message to the peer. The signal-slot connection must be direct.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#continueInterruptedHandshake">continueInterruptedHandshake</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setHandshakeMustInterruptOnError">QSslConfiguration::setHandshakeMustInterruptOnError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ignoreSslErrors">
<db:title>void QSslSocket::ignoreSslErrors()</db:title>
<db:para>This slot tells <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> to ignore errors during <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link>'s handshake phase and continue connecting. If you want to continue with the connection even if errors occur during the handshake phase, then you must call this slot, either from a slot connected to <db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>(), or before the handshake phase. If you don't call this slot, either in response to errors or before the handshake, the connection will be dropped after the <db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>() signal has been emitted.</db:para>
<db:para>If there are no errors during the SSL handshake phase (i.e., the identity of the peer is established with no problems), <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> will not emit the <db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>() signal, and it is unnecessary to call this function.</db:para>
<db:warning>
<db:para>Be sure to always let the user inspect the errors reported by the <db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>() signal, and only call this method upon confirmation from the user that proceeding is ok. If there are unexpected errors, the connection should be aborted. Calling this method without inspecting the actual errors will most likely pose a security risk for your application. Use it with great care!</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ignoreSslErrors-1">
<db:title>void QSslSocket::ignoreSslErrors(const QList&lt;QSslError&gt; &amp;<db:emphasis>errors</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>This method tells <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> to ignore only the errors given in <db:code role="parameter">errors</db:code>.</db:para>
<db:note>
<db:para>Because most SSL errors are associated with a certificate, for most of them you must set the expected certificate this SSL error is related to. If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</db:para>
</db:note>
<db:programlisting language="cpp">QList&lt;QSslCertificate&gt; cert = QSslCertificate::fromPath(&quot;server-certificate.pem&quot;_L1);
QSslError error(QSslError::SelfSignedCertificate, cert.at(0));
QList&lt;QSslError&gt; expectedSslErrors;
expectedSslErrors.append(error);

QSslSocket socket;
socket.ignoreSslErrors(expectedSslErrors);
socket.connectToHostEncrypted(&quot;server.tld&quot;, 443);
</db:programlisting>
<db:para>Multiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#sslHandshakeErrors">sslHandshakeErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="implementedClasses">
<db:title>[static, since 6.1] QList&lt;QSsl::ImplementedClass&gt; QSslSocket::implementedClasses(const QString &amp;<db:emphasis>backendName</db:emphasis> = {})</db:title>
<db:para>This function returns backend-specific classes implemented by the backend named <db:code role="parameter">backendName</db:code>. An empty <db:code role="parameter">backendName</db:code> is understood as a query about the currently active backend.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#ImplementedClass-enum">QSsl::ImplementedClass</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml#activeBackend">activeBackend</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#isClassImplemented">isClassImplemented</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isClassImplemented">
<db:title>[static, since 6.1] bool QSslSocket::isClassImplemented(QSsl::ImplementedClass <db:emphasis>cl</db:emphasis>, const QString &amp;<db:emphasis>backendName</db:emphasis> = {})</db:title>
<db:para>Returns true if a class <db:code role="parameter">cl</db:code> is implemented by the backend named <db:code role="parameter">backendName</db:code>. An empty <db:code role="parameter">backendName</db:code> is understood as a query about the currently active backend.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#implementedClasses">implementedClasses</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isEncrypted">
<db:title>bool QSslSocket::isEncrypted() const</db:title>
<db:para>Returns true if the socket is encrypted; otherwise, false is returned.</db:para>
<db:para>An encrypted socket encrypts all data that is written by calling <db:link xlink:href="qiodevice.xml#write">write</db:link>() or <db:link xlink:href="qiodevice.xml#putChar">putChar</db:link>() before the data is written to the network, and decrypts all incoming data as the data is received from the network, before you call <db:link xlink:href="qiodevice.xml#read">read</db:link>(), <db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>() or <db:link xlink:href="qiodevice.xml#getChar">getChar</db:link>().</db:para>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> emits <db:link xlink:href="qsslsocket.xml#encrypted">encrypted</db:link>() when it enters encrypted mode.</db:para>
<db:para>You can call <db:link xlink:href="qsslsocket.xml#sessionCipher">sessionCipher</db:link>() to find which cryptographic cipher is used to encrypt and decrypt your data.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#mode">mode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isFeatureSupported">
<db:title>[static, since 6.1] bool QSslSocket::isFeatureSupported(QSsl::SupportedFeature <db:emphasis>ft</db:emphasis>, const QString &amp;<db:emphasis>backendName</db:emphasis> = {})</db:title>
<db:para>Returns true if a feature <db:code role="parameter">ft</db:code> is supported by a backend named <db:code role="parameter">backendName</db:code>. An empty <db:code role="parameter">backendName</db:code> is understood as a query about the currently active backend.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#SupportedFeature-enum">QSsl::SupportedFeature</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml#supportedFeatures">supportedFeatures</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isProtocolSupported">
<db:title>[static, since 6.1] bool QSslSocket::isProtocolSupported(QSsl::SslProtocol <db:emphasis>protocol</db:emphasis>, const QString &amp;<db:emphasis>backendName</db:emphasis> = {})</db:title>
<db:para>Returns true if <db:code role="parameter">protocol</db:code> is supported by a backend named <db:code role="parameter">backendName</db:code>. An empty <db:code role="parameter">backendName</db:code> is understood as a query about the currently active backend.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#supportedProtocols">supportedProtocols</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="localCertificate">
<db:title>QSslCertificate QSslSocket::localCertificate() const</db:title>
<db:para>Returns the socket's local <db:link xlink:href="qsslcertificate.xml">certificate</db:link>, or an empty certificate if no local certificate has been assigned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#setLocalCertificate">setLocalCertificate</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#privateKey">privateKey</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="localCertificateChain">
<db:title>QList&lt;QSslCertificate&gt; QSslSocket::localCertificateChain() const</db:title>
<db:para>Returns the socket's local <db:link xlink:href="qsslcertificate.xml">certificate</db:link> chain, or an empty list if no local certificates have been assigned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#setLocalCertificateChain">setLocalCertificateChain</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mode">
<db:title>QSslSocket::SslMode QSslSocket::mode() const</db:title>
<db:para>Returns the current mode for the socket; either <db:link xlink:href="qsslsocket.xml#SslMode-enum">UnencryptedMode</db:link>, where <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> behaves identially to <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>, or one of <db:link xlink:href="qsslsocket.xml#SslMode-enum">SslClientMode</db:link> or <db:link xlink:href="qsslsocket.xml#SslMode-enum">SslServerMode</db:link>, where the client is either negotiating or in encrypted mode.</db:para>
<db:para>When the mode changes, <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> emits <db:link xlink:href="qsslsocket.xml#modeChanged">modeChanged</db:link>()</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#SslMode-enum">SslMode</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="modeChanged">
<db:title>void QSslSocket::modeChanged(QSslSocket::SslMode <db:emphasis>mode</db:emphasis>)</db:title>
<db:para>This signal is emitted when <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> changes from <db:link xlink:href="qsslsocket.xml#SslMode-enum">QSslSocket::UnencryptedMode</db:link> to either <db:link xlink:href="qsslsocket.xml#SslMode-enum">QSslSocket::SslClientMode</db:link> or <db:link xlink:href="qsslsocket.xml#SslMode-enum">QSslSocket::SslServerMode</db:link>. <db:code role="parameter">mode</db:code> is the new mode.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#mode">QSslSocket::mode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newSessionTicketReceived">
<db:title>void QSslSocket::newSessionTicketReceived()</db:title>
<db:para>If TLS 1.3 protocol was negotiated during a handshake, <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> emits this signal after receiving NewSessionTicket message. Session and session ticket's lifetime hint are updated in the socket's configuration. The session can be used for session resumption (and a shortened handshake) in future TLS connections.</db:para>
<db:note>
<db:para>This functionality enabled only with OpenSSL backend and requires OpenSSL v 1.1.1 or above.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#sslConfiguration">QSslSocket::sslConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#sessionTicket">QSslConfiguration::sessionTicket</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#sessionTicketLifeTimeHint">QSslConfiguration::sessionTicketLifeTimeHint</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ocspResponses">
<db:title>QList&lt;QOcspResponse&gt; QSslSocket::ocspResponses() const</db:title>
<db:para>This function returns Online Certificate Status Protocol responses that a server may send during a TLS handshake using OCSP stapling. The list is empty if no definitive response or no response at all was received.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#setOcspStaplingEnabled">QSslConfiguration::setOcspStaplingEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerCertificate">
<db:title>QSslCertificate QSslSocket::peerCertificate() const</db:title>
<db:para>Returns the peer's digital certificate (i.e., the immediate certificate of the host you are connected to), or a null certificate, if the peer has not assigned a certificate.</db:para>
<db:para>The peer certificate is checked automatically during the handshake phase, so this function is normally used to fetch the certificate for display or for connection diagnostic purposes. It contains information about the peer, including its host name, the certificate issuer, and the peer's public key.</db:para>
<db:para>Because the peer certificate is set during the handshake phase, it is safe to access the peer certificate from a slot connected to the <db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>() signal or the <db:link xlink:href="qsslsocket.xml#encrypted">encrypted</db:link>() signal.</db:para>
<db:para>If a null certificate is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</db:para>
<db:para>If you want to check the peer's complete chain of certificates, use <db:link xlink:href="qsslsocket.xml#peerCertificateChain">peerCertificateChain</db:link>() to get them all at once.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#peerCertificateChain">peerCertificateChain</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerCertificateChain">
<db:title>QList&lt;QSslCertificate&gt; QSslSocket::peerCertificateChain() const</db:title>
<db:para>Returns the peer's chain of digital certificates, or an empty list of certificates.</db:para>
<db:para>Peer certificates are checked automatically during the handshake phase. This function is normally used to fetch certificates for display, or for performing connection diagnostics. Certificates contain information about the peer and the certificate issuers, including host name, issuer names, and issuer public keys.</db:para>
<db:para>The peer certificates are set in <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> during the handshake phase, so it is safe to call this function from a slot connected to the <db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>() signal or the <db:link xlink:href="qsslsocket.xml#encrypted">encrypted</db:link>() signal.</db:para>
<db:para>If an empty list is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</db:para>
<db:para>If you want to get only the peer's immediate certificate, use <db:link xlink:href="qsslsocket.xml#peerCertificate">peerCertificate</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#peerCertificate">peerCertificate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerVerifyDepth">
<db:title>int QSslSocket::peerVerifyDepth() const</db:title>
<db:para>Returns the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, or 0 (the default) if no maximum depth has been set, indicating that the whole certificate chain should be checked.</db:para>
<db:para>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#setPeerVerifyDepth">setPeerVerifyDepth</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#peerVerifyMode">peerVerifyMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerVerifyError">
<db:title>void QSslSocket::peerVerifyError(const QSslError &amp;<db:emphasis>error</db:emphasis>)</db:title>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The <db:code role="parameter">error</db:code> is usually an indication that <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> is unable to securely identify the peer.</db:para>
<db:para>This signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> will proceed to emitting <db:link xlink:href="qsslsocket.xml#sslErrors">QSslSocket::sslErrors</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerVerifyMode">
<db:title>QSslSocket::PeerVerifyMode QSslSocket::peerVerifyMode() const</db:title>
<db:para>Returns the socket's verify mode. This mode decides whether <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</db:para>
<db:para>The default mode is <db:link xlink:href="qsslsocket.xml#PeerVerifyMode-enum">AutoVerifyPeer</db:link>, which tells <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> to use <db:link xlink:href="qsslsocket.xml#PeerVerifyMode-enum">VerifyPeer</db:link> for clients and <db:link xlink:href="qsslsocket.xml#PeerVerifyMode-enum">QueryPeer</db:link> for servers.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#setPeerVerifyMode">setPeerVerifyMode</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#peerVerifyDepth">peerVerifyDepth</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#mode">mode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="peerVerifyName">
<db:title>QString QSslSocket::peerVerifyName() const</db:title>
<db:para>Returns the different hostname for the certificate validation, as set by <db:link xlink:href="qsslsocket.xml#setPeerVerifyName">setPeerVerifyName</db:link> or by <db:link xlink:href="qsslsocket.xml#connectToHostEncrypted">connectToHostEncrypted</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#setPeerVerifyName">setPeerVerifyName</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#connectToHostEncrypted">connectToHostEncrypted</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="preSharedKeyAuthenticationRequired">
<db:title>void QSslSocket::preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator *<db:emphasis>authenticator</db:emphasis>)</db:title>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> emits this signal when it negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</db:para>
<db:para>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <db:code role="parameter">authenticator</db:code> object according to their needs.</db:para>
<db:note>
<db:para>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</db:para>
</db:note>
<db:note>
<db:para>The <db:code role="parameter">authenticator</db:code> object is owned by the socket and must not be deleted by the application.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslpresharedkeyauthenticator.xml">QSslPreSharedKeyAuthenticator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="privateKey">
<db:title>QSslKey QSslSocket::privateKey() const</db:title>
<db:para>Returns this socket's private key.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#setPrivateKey">setPrivateKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#localCertificate">localCertificate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="protocol">
<db:title>QSsl::SslProtocol QSslSocket::protocol() const</db:title>
<db:para>Returns the socket's SSL protocol. By default, <db:link xlink:href="qssl.xml#SslProtocol-enum">QSsl::SecureProtocols</db:link> is used.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#setProtocol">setProtocol</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readData">
<db:title>[override virtual protected] qint64 QSslSocket::readData(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxlen</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#readData" role="function">QAbstractSocket::readData(char *data, qint64 maxSize)</db:link>.</db:para>
</db:section>
<db:section xml:id="resume">
<db:title>[override virtual] void QSslSocket::resume()</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#resume" role="function">QAbstractSocket::resume()</db:link>.</db:para>
<db:para>Continues data transfer on the socket after it has been paused. If &quot;setPauseMode(<db:link xlink:href="qabstractsocket.xml#PauseMode-enum">QAbstractSocket::PauseOnSslErrors</db:link>);&quot; has been called on this socket and a <db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>() signal is received, calling this method is necessary for the socket to continue.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#pauseMode">QAbstractSocket::pauseMode</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setPauseMode">QAbstractSocket::setPauseMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sessionCipher">
<db:title>QSslCipher QSslSocket::sessionCipher() const</db:title>
<db:para>Returns the socket's cryptographic <db:link xlink:href="qsslcipher.xml">cipher</db:link>, or a null cipher if the connection isn't encrypted. The socket's cipher for the session is set during the handshake phase. The cipher is used to encrypt and decrypt data transmitted through the socket.</db:para>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> also provides functions for setting the ordered list of ciphers from which the handshake phase will eventually select the session cipher. This ordered list must be in place before the handshake phase begins.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslconfiguration.xml#ciphers">QSslConfiguration::ciphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setCiphers">QSslConfiguration::setCiphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setCiphers">QSslConfiguration::setCiphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#ciphers">QSslConfiguration::ciphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#supportedCiphers">QSslConfiguration::supportedCiphers</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sessionProtocol">
<db:title>QSsl::SslProtocol QSslSocket::sessionProtocol() const</db:title>
<db:para>Returns the socket's SSL/TLS protocol or UnknownProtocol if the connection isn't encrypted. The socket's protocol for the session is set during the handshake phase.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#protocol">protocol</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#setProtocol">setProtocol</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setActiveBackend">
<db:title>[static, since 6.1] bool QSslSocket::setActiveBackend(const QString &amp;<db:emphasis>backendName</db:emphasis>)</db:title>
<db:para>Returns true if a backend with name <db:code role="parameter">backendName</db:code> was set as active backend. <db:code role="parameter">backendName</db:code> must be one of names returned by <db:link xlink:href="qsslsocket.xml#availableBackends">availableBackends</db:link>().</db:para>
<db:note>
<db:para>An application cannot mix different backends simultaneously. This implies that a non-default backend must be selected prior to any use of <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> or related classes, e.g. <db:link xlink:href="qsslcertificate.xml">QSslCertificate</db:link> or <db:link xlink:href="qsslkey.xml">QSslKey</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#activeBackend">activeBackend</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#availableBackends">availableBackends</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setLocalCertificate">
<db:title>void QSslSocket::setLocalCertificate(const QSslCertificate &amp;<db:emphasis>certificate</db:emphasis>)</db:title>
<db:para>Sets the socket's local certificate to <db:code role="parameter">certificate</db:code>. The local certificate is necessary if you need to confirm your identity to the peer. It is used together with the private key; if you set the local certificate, you must also set the private key.</db:para>
<db:para>The local certificate and private key are always necessary for server sockets, but are also rarely used by client sockets if the server requires the client to authenticate.</db:para>
<db:note>
<db:para>Secure Transport SSL backend on macOS may update the default keychain (the default is probably your login keychain) by importing your local certificates and keys. This can also result in system dialogs showing up and asking for permission when your application is using these private keys. If such behavior is undesired, set the QT_SSL_USE_TEMPORARY_KEYCHAIN environment variable to a non-zero value; this will prompt <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> to use its own temporary keychain.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#localCertificate">localCertificate</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#setPrivateKey">setPrivateKey</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setLocalCertificate-1">
<db:title>void QSslSocket::setLocalCertificate(const QString &amp;<db:emphasis>path</db:emphasis>, QSsl::EncodingFormat <db:emphasis>format</db:emphasis> = QSsl::Pem)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Sets the socket's local <db:link xlink:href="qsslcertificate.xml">certificate</db:link> to the first one found in file <db:code role="parameter">path</db:code>, which is parsed according to the specified <db:code role="parameter">format</db:code>.</db:para>
</db:section>
<db:section xml:id="setLocalCertificateChain">
<db:title>void QSslSocket::setLocalCertificateChain(const QList&lt;QSslCertificate&gt; &amp;<db:emphasis>localChain</db:emphasis>)</db:title>
<db:para>Sets the certificate chain to be presented to the peer during the SSL handshake to be <db:code role="parameter">localChain</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#localCertificateChain">localCertificateChain</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setLocalCertificateChain">QSslConfiguration::setLocalCertificateChain</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPeerVerifyDepth">
<db:title>void QSslSocket::setPeerVerifyDepth(int <db:emphasis>depth</db:emphasis>)</db:title>
<db:para>Sets the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, to <db:code role="parameter">depth</db:code>. Setting a depth of 0 means that no maximum depth is set, indicating that the whole certificate chain should be checked.</db:para>
<db:para>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#peerVerifyDepth">peerVerifyDepth</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#setPeerVerifyMode">setPeerVerifyMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPeerVerifyMode">
<db:title>void QSslSocket::setPeerVerifyMode(QSslSocket::PeerVerifyMode <db:emphasis>mode</db:emphasis>)</db:title>
<db:para>Sets the socket's verify mode to <db:code role="parameter">mode</db:code>. This mode decides whether <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</db:para>
<db:para>The default mode is <db:link xlink:href="qsslsocket.xml#PeerVerifyMode-enum">AutoVerifyPeer</db:link>, which tells <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> to use <db:link xlink:href="qsslsocket.xml#PeerVerifyMode-enum">VerifyPeer</db:link> for clients and <db:link xlink:href="qsslsocket.xml#PeerVerifyMode-enum">QueryPeer</db:link> for servers.</db:para>
<db:para>Setting this mode after encryption has started has no effect on the current connection.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#peerVerifyMode">peerVerifyMode</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#setPeerVerifyDepth">setPeerVerifyDepth</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#mode">mode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPeerVerifyName">
<db:title>void QSslSocket::setPeerVerifyName(const QString &amp;<db:emphasis>hostName</db:emphasis>)</db:title>
<db:para>Sets a different host name, given by <db:code role="parameter">hostName</db:code>, for the certificate validation instead of the one used for the TCP connection.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#peerVerifyName">peerVerifyName</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#connectToHostEncrypted">connectToHostEncrypted</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPrivateKey">
<db:title>void QSslSocket::setPrivateKey(const QSslKey &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Sets the socket's private <db:link xlink:href="qsslkey.xml">key</db:link> to <db:code role="parameter">key</db:code>. The private key and the local <db:link xlink:href="qsslcertificate.xml">certificate</db:link> are used by clients and servers that must prove their identity to SSL peers.</db:para>
<db:para>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#privateKey">privateKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#setLocalCertificate">setLocalCertificate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPrivateKey-1">
<db:title>void QSslSocket::setPrivateKey(const QString &amp;<db:emphasis>fileName</db:emphasis>, QSsl::KeyAlgorithm <db:emphasis>algorithm</db:emphasis> = QSsl::Rsa, QSsl::EncodingFormat <db:emphasis>format</db:emphasis> = QSsl::Pem, const QByteArray &amp;<db:emphasis>passPhrase</db:emphasis> = QByteArray())</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Reads the string in file <db:code role="parameter">fileName</db:code> and decodes it using a specified <db:code role="parameter">algorithm</db:code> and encoding <db:code role="parameter">format</db:code> to construct an <db:link xlink:href="qsslkey.xml">SSL key</db:link>. If the encoded key is encrypted, <db:code role="parameter">passPhrase</db:code> is used to decrypt it.</db:para>
<db:para>The socket's private key is set to the constructed key. The private key and the local <db:link xlink:href="qsslcertificate.xml">certificate</db:link> are used by clients and servers that must prove their identity to SSL peers.</db:para>
<db:para>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#privateKey">privateKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#setLocalCertificate">setLocalCertificate</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProtocol">
<db:title>void QSslSocket::setProtocol(QSsl::SslProtocol <db:emphasis>protocol</db:emphasis>)</db:title>
<db:para>Sets the socket's SSL protocol to <db:code role="parameter">protocol</db:code>. This will affect the next initiated handshake; calling this function on an already-encrypted socket will not affect the socket's protocol.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#protocol">protocol</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setReadBufferSize">
<db:title>[override virtual] void QSslSocket::setReadBufferSize(qint64 <db:emphasis>size</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#setReadBufferSize" role="function">QAbstractSocket::setReadBufferSize(qint64 size)</db:link>.</db:para>
<db:para>Sets the size of <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link>'s internal read buffer to be <db:code role="parameter">size</db:code> bytes.</db:para>
</db:section>
<db:section xml:id="setSocketDescriptor">
<db:title>[override virtual] bool QSslSocket::setSocketDescriptor(qintptr <db:emphasis>socketDescriptor</db:emphasis>, QAbstractSocket::SocketState <db:emphasis>state</db:emphasis> = ConnectedState, QIODeviceBase::OpenMode <db:emphasis>openMode</db:emphasis> = ReadWrite)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#setSocketDescriptor" role="function">QAbstractSocket::setSocketDescriptor(qintptr socketDescriptor, QAbstractSocket::SocketState socketState, QIODeviceBase::OpenMode openMode)</db:link>.</db:para>
<db:para>Initializes <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> with the native socket descriptor <db:code role="parameter">socketDescriptor</db:code>. Returns true if <db:code role="parameter">socketDescriptor</db:code> is accepted as a valid socket descriptor; otherwise returns false. The socket is opened in the mode specified by <db:code role="parameter">openMode</db:code>, and enters the socket state specified by <db:code role="parameter">state</db:code>.</db:para>
<db:note>
<db:para>It is not possible to initialize two sockets with the same native socket descriptor.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#socketDescriptor">socketDescriptor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSocketOption">
<db:title>[override virtual] void QSslSocket::setSocketOption(QAbstractSocket::SocketOption <db:emphasis>option</db:emphasis>, const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#setSocketOption" role="function">QAbstractSocket::setSocketOption(QAbstractSocket::SocketOption option, const QVariant &amp;value)</db:link>.</db:para>
<db:para>Sets the given <db:code role="parameter">option</db:code> to the value described by <db:code role="parameter">value</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#socketOption">socketOption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSslConfiguration">
<db:title>void QSslSocket::setSslConfiguration(const QSslConfiguration &amp;<db:emphasis>configuration</db:emphasis>)</db:title>
<db:para>Sets the socket's SSL configuration to be the contents of <db:code role="parameter">configuration</db:code>. This function sets the local certificate, the ciphers, the private key and the CA certificates to those stored in <db:code role="parameter">configuration</db:code>.</db:para>
<db:para>It is not possible to set the SSL-state related fields.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#sslConfiguration">sslConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#setLocalCertificate">setLocalCertificate</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#setPrivateKey">setPrivateKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setCaCertificates">QSslConfiguration::setCaCertificates</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#setCiphers">QSslConfiguration::setCiphers</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="skipData">
<db:title>[override virtual protected] qint64 QSslSocket::skipData(qint64 <db:emphasis>maxSize</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#skipData" role="function">QAbstractSocket::skipData(qint64 maxSize)</db:link>.</db:para>
</db:section>
<db:section xml:id="socketOption">
<db:title>[override virtual] QVariant QSslSocket::socketOption(QAbstractSocket::SocketOption <db:emphasis>option</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#socketOption" role="function">QAbstractSocket::socketOption(QAbstractSocket::SocketOption option)</db:link>.</db:para>
<db:para>Returns the value of the <db:code role="parameter">option</db:code> option.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#setSocketOption">setSocketOption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslConfiguration">
<db:title>QSslConfiguration QSslSocket::sslConfiguration() const</db:title>
<db:para>Returns the socket's SSL configuration state. The default SSL configuration of a socket is to use the default ciphers, default CA certificates, no local private key or certificate.</db:para>
<db:para>The SSL configuration also contains fields that can change with time without notice.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#setSslConfiguration">setSslConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#localCertificate">localCertificate</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#peerCertificate">peerCertificate</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#peerCertificateChain">peerCertificateChain</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#sessionCipher">sessionCipher</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#privateKey">privateKey</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#ciphers">QSslConfiguration::ciphers</db:link>()</db:member>
<db:member><db:link xlink:href="qsslconfiguration.xml#caCertificates">QSslConfiguration::caCertificates</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslErrors">
<db:title>void QSslSocket::sslErrors(const QList&lt;QSslError&gt; &amp;<db:emphasis>errors</db:emphasis>)</db:title>
<db:para><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted.</db:para>
<db:para>If you want to continue connecting despite the errors that have occurred, you must call <db:link xlink:href="qsslsocket.xml#ignoreSslErrors">QSslSocket::ignoreSslErrors</db:link>() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call <db:link xlink:href="qsslsocket.xml#sslHandshakeErrors">sslHandshakeErrors</db:link>().</db:para>
<db:para><db:code role="parameter">errors</db:code> contains one or more errors that prevent <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> from verifying the identity of the peer.</db:para>
<db:note>
<db:para>You cannot use <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::QueuedConnection</db:link> when connecting to this signal, or calling <db:link xlink:href="qsslsocket.xml#ignoreSslErrors">QSslSocket::ignoreSslErrors</db:link>() will have no effect.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#peerVerifyError">peerVerifyError</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslHandshakeErrors">
<db:title>QList&lt;QSslError&gt; QSslSocket::sslHandshakeErrors() const</db:title>
<db:para>Returns a list of the last SSL errors that occurred. This is the same list as <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link> passes via the <db:link xlink:href="qsslsocket.xml#sslErrors">sslErrors</db:link>() signal. If the connection has been encrypted with no errors, this function will return an empty list.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#connectToHostEncrypted">connectToHostEncrypted</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslLibraryBuildVersionNumber">
<db:title>[static] long QSslSocket::sslLibraryBuildVersionNumber()</db:title>
<db:para>Returns the version number of the SSL library in use at compile time. If no SSL support is available then this will return -1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#sslLibraryVersionNumber">sslLibraryVersionNumber</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslLibraryBuildVersionString">
<db:title>[static] QString QSslSocket::sslLibraryBuildVersionString()</db:title>
<db:para>Returns the version string of the SSL library in use at compile time. If no SSL support is available then this will return an empty value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#sslLibraryVersionString">sslLibraryVersionString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslLibraryVersionNumber">
<db:title>[static] long QSslSocket::sslLibraryVersionNumber()</db:title>
<db:para>Returns the version number of the SSL library in use. Note that this is the version of the library in use at run-time not compile time. If no SSL support is available then this will return -1.</db:para>
</db:section>
<db:section xml:id="sslLibraryVersionString">
<db:title>[static] QString QSslSocket::sslLibraryVersionString()</db:title>
<db:para>Returns the version string of the SSL library in use. Note that this is the version of the library in use at run-time not compile time. If no SSL support is available then this will return an empty value.</db:para>
</db:section>
<db:section xml:id="startClientEncryption">
<db:title>void QSslSocket::startClientEncryption()</db:title>
<db:para>Starts a delayed SSL handshake for a client connection. This function can be called when the socket is in the <db:link xlink:href="qabstractsocket.xml#SocketState-enum">ConnectedState</db:link> but still in the <db:link xlink:href="qsslsocket.xml#SslMode-enum">UnencryptedMode</db:link>. If it is not yet connected, or if it is already encrypted, this function has no effect.</db:para>
<db:para>Clients that implement STARTTLS functionality often make use of delayed SSL handshakes. Most other clients can avoid calling this function directly by using <db:link xlink:href="qsslsocket.xml#connectToHostEncrypted">connectToHostEncrypted</db:link>() instead, which automatically performs the handshake.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#connectToHostEncrypted">connectToHostEncrypted</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#startServerEncryption">startServerEncryption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startServerEncryption">
<db:title>void QSslSocket::startServerEncryption()</db:title>
<db:para>Starts a delayed SSL handshake for a server connection. This function can be called when the socket is in the <db:link xlink:href="qabstractsocket.xml#SocketState-enum">ConnectedState</db:link> but still in <db:link xlink:href="qsslsocket.xml#SslMode-enum">UnencryptedMode</db:link>. If it is not connected or it is already encrypted, the function has no effect.</db:para>
<db:para>For server sockets, calling this function is the only way to initiate the SSL handshake. Most servers will call this function immediately upon receiving a connection, or as a result of having received a protocol-specific command to enter SSL mode (e.g, the server may respond to receiving the string &quot;STARTTLS\r\n&quot; by calling this function).</db:para>
<db:para>The most common way to implement an SSL server is to create a subclass of <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> and reimplement <db:link xlink:href="qtcpserver.xml#incomingConnection">QTcpServer::incomingConnection</db:link>(). The returned socket descriptor is then passed to <db:link xlink:href="qsslsocket.xml#setSocketDescriptor">QSslSocket::setSocketDescriptor</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#connectToHostEncrypted">connectToHostEncrypted</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#startClientEncryption">startClientEncryption</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportedFeatures">
<db:title>[static, since 6.1] QList&lt;QSsl::SupportedFeature&gt; QSslSocket::supportedFeatures(const QString &amp;<db:emphasis>backendName</db:emphasis> = {})</db:title>
<db:para>This function returns features supported by a backend named <db:code role="parameter">backendName</db:code>. An empty <db:code role="parameter">backendName</db:code> is understood as a query about the currently active backend.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#SupportedFeature-enum">QSsl::SupportedFeature</db:link></db:member>
<db:member><db:link xlink:href="qsslsocket.xml#activeBackend">activeBackend</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportedProtocols">
<db:title>[static, since 6.1] QList&lt;QSsl::SslProtocol&gt; QSslSocket::supportedProtocols(const QString &amp;<db:emphasis>backendName</db:emphasis> = {})</db:title>
<db:para>If a backend with name <db:code role="parameter">backendName</db:code> is available, this function returns the list of TLS protocol versions supported by this backend. An empty <db:code role="parameter">backendName</db:code> is understood as a query about the currently active backend. Otherwise, this function returns an empty list.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#availableBackends">availableBackends</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#activeBackend">activeBackend</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#isProtocolSupported">isProtocolSupported</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportsSsl">
<db:title>[static] bool QSslSocket::supportsSsl()</db:title>
<db:para>Returns true if this platform supports SSL; otherwise, returns false. If the platform doesn't support SSL, the socket will fail in the connection phase.</db:para>
</db:section>
<db:section xml:id="waitForBytesWritten">
<db:title>[override virtual] bool QSslSocket::waitForBytesWritten(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#waitForBytesWritten" role="function">QAbstractSocket::waitForBytesWritten(int msecs)</db:link>.</db:para>
</db:section>
<db:section xml:id="waitForConnected">
<db:title>[override virtual] bool QSslSocket::waitForConnected(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#waitForConnected" role="function">QAbstractSocket::waitForConnected(int msecs)</db:link>.</db:para>
<db:para>Waits until the socket is connected, or <db:code role="parameter">msecs</db:code> milliseconds, whichever happens first. If the connection has been established, this function returns true; otherwise it returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#waitForConnected">QAbstractSocket::waitForConnected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForDisconnected">
<db:title>[override virtual] bool QSslSocket::waitForDisconnected(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#waitForDisconnected" role="function">QAbstractSocket::waitForDisconnected(int msecs)</db:link>.</db:para>
<db:para>Waits until the socket has disconnected or <db:code role="parameter">msecs</db:code> milliseconds, whichever comes first. If the connection has been disconnected, this function returns true; otherwise it returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#waitForDisconnected">QAbstractSocket::waitForDisconnected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForEncrypted">
<db:title>bool QSslSocket::waitForEncrypted(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:para>Waits until the socket has completed the SSL handshake and has emitted <db:link xlink:href="qsslsocket.xml#encrypted">encrypted</db:link>(), or <db:code role="parameter">msecs</db:code> milliseconds, whichever comes first. If <db:link xlink:href="qsslsocket.xml#encrypted">encrypted</db:link>() has been emitted, this function returns true; otherwise (e.g., the socket is disconnected, or the SSL handshake fails), false is returned.</db:para>
<db:para>The following example waits up to one second for the socket to be encrypted:</db:para>
<db:programlisting language="cpp">socket-&gt;connectToHostEncrypted(&quot;imap&quot;, 993);
if (socket-&gt;waitForEncrypted(1000))
    qDebug(&quot;Encrypted!&quot;);
</db:programlisting>
<db:para>If msecs is -1, this function will not time out.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#startClientEncryption">startClientEncryption</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#startServerEncryption">startServerEncryption</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#encrypted">encrypted</db:link>()</db:member>
<db:member><db:link xlink:href="qsslsocket.xml#isEncrypted">isEncrypted</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="waitForReadyRead">
<db:title>[override virtual] bool QSslSocket::waitForReadyRead(int <db:emphasis>msecs</db:emphasis> = 30000)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#waitForReadyRead" role="function">QAbstractSocket::waitForReadyRead(int msecs)</db:link>.</db:para>
</db:section>
<db:section xml:id="writeData">
<db:title>[override virtual protected] qint64 QSslSocket::writeData(const char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>len</db:emphasis>)</db:title>
<db:para>Reimplements: <db:link xlink:href="qabstractsocket.xml#writeData" role="function">QAbstractSocket::writeData(const char *data, qint64 size)</db:link>.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="AlertLevel-enum">
<db:title>[since 6.0] enum AlertLevel</db:title>
<db:para>Describes the level of an alert message</db:para>
<db:para>This enum describes the level of an alert message that was sent or received.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertLevel</db:emphasis>::Warning</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Non-fatal alert message</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertLevel</db:emphasis>::Fatal</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Fatal alert message, the underlying backend will handle such an alert properly and close the connection.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertLevel</db:emphasis>::Unknown</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>An alert of unknown level of severity.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="AlertType-enum">
<db:title>[since 6.0] enum AlertType</db:title>
<db:para>Enumerates possible codes that an alert message can have</db:para>
<db:para>See <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc8446#section-6">RFC 8446, section 6</db:link> for the possible values and their meaning.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::CloseNotify</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>,</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::UnexpectedMessage</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::BadRecordMac</db:code></db:para>
</db:td>
<db:td><db:code>20</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::RecordOverflow</db:code></db:para>
</db:td>
<db:td><db:code>22</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::DecompressionFailure</db:code></db:para>
</db:td>
<db:td><db:code>30</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::HandshakeFailure</db:code></db:para>
</db:td>
<db:td><db:code>40</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::NoCertificate</db:code></db:para>
</db:td>
<db:td><db:code>41</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::BadCertificate</db:code></db:para>
</db:td>
<db:td><db:code>42</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::UnsupportedCertificate</db:code></db:para>
</db:td>
<db:td><db:code>43</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::CertificateRevoked</db:code></db:para>
</db:td>
<db:td><db:code>44</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::CertificateExpired</db:code></db:para>
</db:td>
<db:td><db:code>45</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::CertificateUnknown</db:code></db:para>
</db:td>
<db:td><db:code>46</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::IllegalParameter</db:code></db:para>
</db:td>
<db:td><db:code>47</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::UnknownCa</db:code></db:para>
</db:td>
<db:td><db:code>48</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::AccessDenied</db:code></db:para>
</db:td>
<db:td><db:code>49</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::DecodeError</db:code></db:para>
</db:td>
<db:td><db:code>50</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::DecryptError</db:code></db:para>
</db:td>
<db:td><db:code>51</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::ExportRestriction</db:code></db:para>
</db:td>
<db:td><db:code>60</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::ProtocolVersion</db:code></db:para>
</db:td>
<db:td><db:code>70</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::InsufficientSecurity</db:code></db:para>
</db:td>
<db:td><db:code>71</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::InternalError</db:code></db:para>
</db:td>
<db:td><db:code>80</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::InappropriateFallback</db:code></db:para>
</db:td>
<db:td><db:code>86</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::UserCancelled</db:code></db:para>
</db:td>
<db:td><db:code>90</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::NoRenegotiation</db:code></db:para>
</db:td>
<db:td><db:code>100</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::MissingExtension</db:code></db:para>
</db:td>
<db:td><db:code>109</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::UnsupportedExtension</db:code></db:para>
</db:td>
<db:td><db:code>110</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::CertificateUnobtainable</db:code></db:para>
</db:td>
<db:td><db:code>111</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::UnrecognizedName</db:code></db:para>
</db:td>
<db:td><db:code>112</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::BadCertificateStatusResponse</db:code></db:para>
</db:td>
<db:td><db:code>113</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::BadCertificateHashValue</db:code></db:para>
</db:td>
<db:td><db:code>114</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::UnknownPskIdentity</db:code></db:para>
</db:td>
<db:td><db:code>115</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::CertificateRequired</db:code></db:para>
</db:td>
<db:td><db:code>116</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::NoApplicationProtocol</db:code></db:para>
</db:td>
<db:td><db:code>120</db:code></db:td>
<db:td/>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">AlertType</db:emphasis>::UnknownAlertMessage</db:code></db:para>
</db:td>
<db:td><db:code>255</db:code></db:td>
<db:td/>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="ImplementedClass-enum">
<db:title>[since 6.1] enum ImplementedClass</db:title>
<db:para>Enumerates classes that a TLS backend implements</db:para>
<db:para>In <db:link xlink:href="qtnetwork-module.xml">QtNetwork</db:link>, some classes have backend-specific implementation and thus can be left unimplemented. Enumerators in this enum indicate, which class has a working implementation in the backend.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">ImplementedClass</db:emphasis>::Key</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Class <db:link xlink:href="qsslkey.xml">QSslKey</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">ImplementedClass</db:emphasis>::Certificate</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Class <db:link xlink:href="qsslcertificate.xml">QSslCertificate</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">ImplementedClass</db:emphasis>::Socket</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Class <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">ImplementedClass</db:emphasis>::DiffieHellman</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>Class <db:link xlink:href="qssldiffiehellmanparameters.xml">QSslDiffieHellmanParameters</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">ImplementedClass</db:emphasis>::EllipticCurve</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>Class <db:link xlink:href="qsslellipticcurve.xml">QSslEllipticCurve</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">ImplementedClass</db:emphasis>::Dtls</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>Class <db:link xlink:href="qdtls.xml">QDtls</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">ImplementedClass</db:emphasis>::DtlsCookie</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>Class <db:link xlink:href="qdtlsclientverifier.xml">QDtlsClientVerifier</db:link>.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced in Qt 6.1.</db:para>
</db:section>
<db:section xml:id="SupportedFeature-enum">
<db:title>[since 6.1] enum SupportedFeature</db:title>
<db:para>Enumerates possible features that a TLS backend supports</db:para>
<db:para>In <db:link xlink:href="qtnetwork-module.xml">QtNetwork</db:link> TLS-related classes have public API, that may be left unimplemented by some backend, for example, our SecureTransport backend does not support server-side ALPN. Enumerators from SupportedFeature enum indicate that a particular feature is supported.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">SupportedFeature</db:emphasis>::CertificateVerification</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Indicates that <db:link xlink:href="qsslcertificate.xml#verify">QSslCertificate::verify</db:link>() is implemented by the backend.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">SupportedFeature</db:emphasis>::ClientSideAlpn</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Client-side ALPN (Application Layer Protocol Negotiation).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">SupportedFeature</db:emphasis>::ServerSideAlpn</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Server-side ALPN.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">SupportedFeature</db:emphasis>::Ocsp</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>OCSP stapling (Online Certificate Status Protocol).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">SupportedFeature</db:emphasis>::Psk</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>Pre-shared keys.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">SupportedFeature</db:emphasis>::SessionTicket</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>Session tickets.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qsslsocket.xml">QSslSocket</db:link></db:emphasis>::<db:emphasis role="bold">SupportedFeature</db:emphasis>::Alerts</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>Information about alert messages sent and received.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced in Qt 6.1.</db:para>
</db:section>
</db:section>
</db:article>
