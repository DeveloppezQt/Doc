<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QAxFactory Class</db:title>
<db:productname>ActiveQt</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>ActiveQt</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> class defines a factory for the creation of COM components.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QAxFactory</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS AxServer)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::AxServer)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += axserver</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Implement this factory once in your COM server to provide information about the components the server can create. Subclass <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> and implement the pure virtual functions in any implementation file (e.g. main.cpp), and export the factory using the <db:code>QAXFACTORY_EXPORT()</db:code> macro.</db:para>
<db:programlisting language="cpp">QStringList ActiveQtFactory::featureList() const
{
    QStringList list;
    list &amp;lt;&amp;lt; &quot;ActiveX1&quot;;
    list &amp;lt;&amp;lt; &quot;ActiveX2&quot;;
    return list;
}

QObject *ActiveQtFactory::createObject(const QString &amp;amp;key)
{
    if (key == &quot;ActiveX1&quot;)
        return new ActiveX1(parent);
    if (key == &quot;ActiveX2&quot;)
        return new ActiveX2(parent);
    return 0;
}

const QMetaObject *ActiveQtFactory::metaObject(const QString &amp;amp;key) const
{
    if (key == &quot;ActiveX1&quot;)
        return &amp;amp;ActiveX1::staticMetaObject;
    if (key == &quot;ActiveX2&quot;)
        return &amp;amp;ActiveX2::staticMetaObject;
}

QUuid ActiveQtFactory::classID(const QString &amp;amp;key) const
{
    if (key == &quot;ActiveX1&quot;)
        return &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;;
    ...
    return QUuid();
}

QUuid ActiveQtFactory::interfaceID(const QString &amp;amp;key) const
{
    if (key == &quot;ActiveX1&quot;)
        return &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;;
    ...
    return QUuid();
}

QUuid ActiveQtFactory::eventsID(const QString &amp;amp;key) const
{
    if (key == &quot;ActiveX1&quot;)
        return &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;;
    ...
    return QUuid();
}

QAXFACTORY_EXPORT(
    ActiveQtFactory,                          // factory class
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // type library ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;  // application ID
)
</db:programlisting>
<db:para>If you use the <db:code>Q_CLASSINFO()</db:code> macro to provide the unique identifiers or other attributes for your class you can use the <db:code>QAXFACTORY_BEGIN()</db:code>, <db:code>QAXCLASS()</db:code> and <db:code>QAXFACTORY_END()</db:code> macros to expose one or more classes as COM objects.</db:para>
<db:programlisting language="cpp">QAXFACTORY_BEGIN(
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // type library ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;  // application ID
)
    QAXCLASS(Class1)
    QAXCLASS(Class2)
QAXFACTORY_END()
</db:programlisting>
<db:para>Only one <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> implementation may be instantiated and exported by an ActiveX server application. This instance is accessible through the global qAxFactory() function.</db:para>
<db:para>A factory can also reimplement the <db:link xlink:href="qaxfactory.xml#registerClass">registerClass</db:link>() and <db:link xlink:href="qaxfactory.xml#unregisterClass">unregisterClass</db:link>() functions to set additional flags for an ActiveX control in the registry. To limit the number of methods or properties a widget class exposes from its parent classes reimplement <db:link xlink:href="qaxfactory.xml#exposeToSuperClass">exposeToSuperClass</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxaggregated.xml">QAxAggregated</db:link></db:member>
<db:member><db:link xlink:href="qaxbindable.xml">QAxBindable</db:link></db:member>
<db:member><db:link xlink:href="activeqt-index.xml">ActiveQt Framework</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ServerType-enum">
<db:title>enum QAxFactory::ServerType</db:title>
<db:enumsynopsis>
<db:enumname>ServerType</db:enumname>
<db:enumitem>
<db:enumidentifier>SingleInstance</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MultipleInstances</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum specifies the different types of servers that can be started with <db:link xlink:href="qaxfactory.xml#startServer">startServer</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qaxfactory.xml">QAxFactory</db:link></db:emphasis>::SingleInstance</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The server process can create only one instance of each exported class. COM starts a new process for each request. This is typically used in servers that export only one creatable class.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qaxfactory.xml">QAxFactory</db:link></db:emphasis>::MultipleInstances</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The server can create multiple instances of each exported class. This is the default. All instances will live in the same thread, and will share static resources.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QAxFactory-2">
<db:title>QAxFactory::QAxFactory(const QUuid &amp;<db:emphasis>libid</db:emphasis>, const QUuid &amp;<db:emphasis>appid</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QAxFactory</db:methodname>
<db:methodparam>
<db:type>const QUuid &amp;</db:type>
<db:parameter>libid</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QUuid &amp;</db:type>
<db:parameter>appid</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QAxFactory(const QUuid &amp;libid, const QUuid &amp;appid)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> object that returns <db:code role="parameter">libid</db:code> and <db:code role="parameter">appid</db:code> in the implementation of the respective interface functions.</db:para>
</db:section>
<db:section xml:id="dtor.QAxFactory">
<db:title>[override virtual] QAxFactory::~QAxFactory()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QAxFactory</db:methodname>
<db:void/>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QAxFactory() override</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> object.</db:para>
</db:section>
<db:section xml:id="appID">
<db:title>[virtual] QUuid QAxFactory::appID() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QUuid</db:type>
<db:methodname>appID</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUuid appID() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return the ActiveX server's application identifier.</db:para>
</db:section>
<db:section xml:id="classID">
<db:title>[virtual] QUuid QAxFactory::classID(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QUuid</db:type>
<db:methodname>classID</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUuid classID(const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return the class identifier for each <db:code role="parameter">key</db:code> returned by the <db:link xlink:href="qaxfactory.xml#featureList">featureList</db:link>() implementation, or an empty <db:link xlink:href="quuid.xml">QUuid</db:link> if this factory doesn't support the value of <db:code role="parameter">key</db:code>.</db:para>
<db:para>The default implementation interprets <db:code role="parameter">key</db:code> as the class name, and returns the value of the <db:link xlink:href="qobject.xml#Q_CLASSINFO">Q_CLASSINFO</db:link>() entry &quot;ClassID&quot;.</db:para>
</db:section>
<db:section xml:id="createObject">
<db:title>[pure virtual] QObject *QAxFactory::createObject(const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QObject *</db:type>
<db:methodname>createObject</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QObject * createObject(const QString &amp;key) = 0</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return a new object for <db:code role="parameter">key</db:code>, or 0 if this factory doesn't support the value of <db:code role="parameter">key</db:code>.</db:para>
<db:para>If the object returned is a <db:link xlink:href="qwidget.xml">QWidget</db:link> it will be exposed as an ActiveX control, otherwise the returned object will be exposed as a simple COM object.</db:para>
</db:section>
<db:section xml:id="createObjectWrapper">
<db:title>[virtual] bool QAxFactory::createObjectWrapper(QObject *<db:emphasis>object</db:emphasis>, IDispatch **<db:emphasis>wrapper</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>bool</db:type>
<db:methodname>createObjectWrapper</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>IDispatch **</db:type>
<db:parameter>wrapper</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool createObjectWrapper(QObject *object, IDispatch **wrapper)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to provide the COM object for <db:code role="parameter">object</db:code> in <db:code role="parameter">wrapper</db:code>. Return true if the function was successful; otherwise return false.</db:para>
<db:para>The default implementation creates a generic automation wrapper based on the meta object information of <db:code role="parameter">object</db:code>.</db:para>
</db:section>
<db:section xml:id="eventsID">
<db:title>[virtual] QUuid QAxFactory::eventsID(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QUuid</db:type>
<db:methodname>eventsID</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUuid eventsID(const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return the identifier of the event interface for each <db:code role="parameter">key</db:code> returned by the <db:link xlink:href="qaxfactory.xml#featureList">featureList</db:link>() implementation, or an empty <db:link xlink:href="quuid.xml">QUuid</db:link> if this factory doesn't support the value of <db:code role="parameter">key</db:code>.</db:para>
<db:para>The default implementation interprets <db:code role="parameter">key</db:code> as the class name, and returns the value of the <db:link xlink:href="qobject.xml#Q_CLASSINFO">Q_CLASSINFO</db:link>() entry &quot;EventsID&quot;.</db:para>
</db:section>
<db:section xml:id="exposeToSuperClass">
<db:title>[virtual] QString QAxFactory::exposeToSuperClass(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>exposeToSuperClass</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString exposeToSuperClass(const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return the name of the super class of <db:code role="parameter">key</db:code> up to which methods and properties should be exposed by the ActiveX control.</db:para>
<db:para>The default implementation interprets <db:code role="parameter">key</db:code> as the class name, and returns the value of the <db:code>Q_CLASSINFO()</db:code> entry &quot;ToSuperClass&quot;. If no such value is set the null-string is returned, and the functions and properties of all the super classes including <db:link xlink:href="qwidget.xml">QWidget</db:link> will be exposed.</db:para>
<db:para>To only expose the functions and properties of the class itself, reimplement this function to return <db:code role="parameter">key</db:code>.</db:para>
</db:section>
<db:section xml:id="featureList">
<db:title>[pure virtual] QStringList QAxFactory::featureList() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>featureList</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList featureList() const = 0</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return a list of the widgets (class names) supported by this factory.</db:para>
</db:section>
<db:section xml:id="hasStockEvents">
<db:title>[virtual] bool QAxFactory::hasStockEvents(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasStockEvents</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasStockEvents(const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return true if the ActiveX control <db:code role="parameter">key</db:code> should support the standard ActiveX events</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Click</db:para>
</db:listitem>
<db:listitem>
<db:para>DblClick</db:para>
</db:listitem>
<db:listitem>
<db:para>KeyDown</db:para>
</db:listitem>
<db:listitem>
<db:para>KeyPress</db:para>
</db:listitem>
<db:listitem>
<db:para>KeyUp</db:para>
</db:listitem>
<db:listitem>
<db:para>MouseDown</db:para>
</db:listitem>
<db:listitem>
<db:para>MouseUp</db:para>
</db:listitem>
<db:listitem>
<db:para>MouseMove</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The default implementation interprets <db:code role="parameter">key</db:code> as the class name, and returns true if the value of the <db:code>Q_CLASSINFO()</db:code> entry &quot;StockEvents&quot; is &quot;yes&quot;. Otherwise this function returns false.</db:para>
</db:section>
<db:section xml:id="interfaceID">
<db:title>[virtual] QUuid QAxFactory::interfaceID(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QUuid</db:type>
<db:methodname>interfaceID</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUuid interfaceID(const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return the interface identifier for each <db:code role="parameter">key</db:code> returned by the <db:link xlink:href="qaxfactory.xml#featureList">featureList</db:link>() implementation, or an empty <db:link xlink:href="quuid.xml">QUuid</db:link> if this factory doesn't support the value of <db:code role="parameter">key</db:code>.</db:para>
<db:para>The default implementation interprets <db:code role="parameter">key</db:code> as the class name, and returns the value of the <db:link xlink:href="qobject.xml#Q_CLASSINFO">Q_CLASSINFO</db:link>() entry &quot;InterfaceID&quot;.</db:para>
</db:section>
<db:section xml:id="isServer">
<db:title>[static] bool QAxFactory::isServer()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>isServer</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isServer()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the application has been started (by COM) as an ActiveX server, otherwise returns false.</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    if (!QAxFactory::isServer()) {
        // initialize for stand-alone execution
    }
    return app.exec();
}
</db:programlisting>
</db:section>
<db:section xml:id="isService">
<db:title>[virtual] bool QAxFactory::isService() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isService</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isService() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return true if the server is running as a persistent service (e.g. an NT service) and should not terminate even when all objects provided have been released.</db:para>
<db:para>The default implementation returns false.</db:para>
</db:section>
<db:section xml:id="metaObject">
<db:title>[pure virtual] const QMetaObject *QAxFactory::metaObject(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>const QMetaObject *</db:type>
<db:methodname>metaObject</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QMetaObject * metaObject(const QString &amp;key) const = 0</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return the <db:link xlink:href="qmetaobject.xml">QMetaObject</db:link> corresponding to <db:code role="parameter">key</db:code>, or 0 if this factory doesn't support the value of <db:code role="parameter">key</db:code>.</db:para>
</db:section>
<db:section xml:id="registerActiveObject">
<db:title>[static] bool QAxFactory::registerActiveObject(QObject *<db:emphasis>object</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>registerActiveObject</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool registerActiveObject(QObject *object)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers the <db:link xlink:href="qobject.xml">QObject</db:link> <db:code role="parameter">object</db:code> with COM as a running object, and returns true if the registration succeeded, otherwise returns false. The object is unregistered automatically when it is destroyed.</db:para>
<db:para>This function should only be called if the application has been started by the user (i.e. not by COM to respond to a request), and only for one object, usually the toplevel object of the application's object hierarchy.</db:para>
<db:para>This function does nothing and returns false if the object's class info for &quot;RegisterObject&quot; is not set to &quot;yes&quot;, or if the server is an in-process server.</db:para>
</db:section>
<db:section xml:id="registerClass">
<db:title>[virtual] void QAxFactory::registerClass(const QString &amp;<db:emphasis>key</db:emphasis>, QSettings *<db:emphasis>settings</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>registerClass</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSettings *</db:type>
<db:parameter>settings</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void registerClass(const QString &amp;key, QSettings *settings) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers additional values for the class <db:code role="parameter">key</db:code> in the system registry using the <db:code role="parameter">settings</db:code> object. The standard values have already been registered by the framework, but additional values, e.g. implemented categories, can be added in an implementation of this function.</db:para>
<db:programlisting language="cpp">settings-&amp;gt;setValue(&quot;/CLSID/&quot; + classID(key)
                   + &quot;/Implemented Categories/&quot;
                   + &quot;/{00000000-0000-0000-000000000000}/.&quot;,
                   QString());
</db:programlisting>
<db:para>If you reimplement this function you must also reimplement <db:link xlink:href="qaxfactory.xml#unregisterClass">unregisterClass</db:link>() to remove the additional registry values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsettings.xml">QSettings</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="serverDirPath">
<db:title>[static] QString QAxFactory::serverDirPath()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QString</db:type>
<db:methodname>serverDirPath</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString serverDirPath()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the directory that contains the server binary.</db:para>
<db:para>For out-of-process servers this is the same as <db:link xlink:href="qcoreapplication.xml#applicationDirPath">QCoreApplication::applicationDirPath</db:link>(). For in-process servers that function returns the directory that contains the hosting application.</db:para>
</db:section>
<db:section xml:id="serverFilePath">
<db:title>[static] QString QAxFactory::serverFilePath()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QString</db:type>
<db:methodname>serverFilePath</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString serverFilePath()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the file path of the server binary.</db:para>
<db:para>For out-of-process servers this is the same as <db:link xlink:href="qcoreapplication.xml#applicationFilePath">QCoreApplication::applicationFilePath</db:link>(). For in-process servers that function returns the file path of the hosting application.</db:para>
</db:section>
<db:section xml:id="startServer">
<db:title>[static] bool QAxFactory::startServer(QAxFactory::ServerType <db:emphasis>type</db:emphasis> = MultipleInstances)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>startServer</db:methodname>
<db:methodparam>
<db:type>QAxFactory::ServerType</db:type>
<db:parameter>type</db:parameter>
<db:initializer>MultipleInstances</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool startServer(QAxFactory::ServerType type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Starts the COM server with <db:code role="parameter">type</db:code> and returns true if successful, otherwise returns false.</db:para>
<db:para>Calling this function if the server is already running (or for an in-process server) does nothing and returns true.</db:para>
<db:para>The server is started automatically with <db:code role="parameter">type</db:code> set to <db:code>MultipleInstances</db:code> if the server executable has been started with the <db:code>-activex</db:code> command line parameter. To switch to <db:link xlink:href="qaxfactory.xml#ServerType-enum">SingleInstance</db:link>, call</db:para>
<db:programlisting language="cpp">if (QAxFactory::isServer()) {
    QAxFactory::stopServer();
    QAxFactory::startServer(QAxFactory::SingleInstance);
}
</db:programlisting>
<db:para>in your own main() entry point function.</db:para>
</db:section>
<db:section xml:id="stayTopLevel">
<db:title>[virtual] bool QAxFactory::stayTopLevel(const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>stayTopLevel</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool stayTopLevel(const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return true if the ActiveX control <db:code role="parameter">key</db:code> should be a top level window, e.g. a dialog. The default implementation returns false.</db:para>
</db:section>
<db:section xml:id="stopServer">
<db:title>[static] bool QAxFactory::stopServer()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>stopServer</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool stopServer()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Stops the COM server and returns true if successful, otherwise returns false.</db:para>
<db:para>Calling this function if the server is not running (or for an in-process server) does nothing and returns true.</db:para>
<db:para>Stopping the server will not invalidate existing objects, but no new objects can be created from the existing server process. Usually COM will start a new server process if additional objects are requested.</db:para>
<db:para>The server is stopped automatically when the main() function returns.</db:para>
</db:section>
<db:section xml:id="typeLibID">
<db:title>[virtual] QUuid QAxFactory::typeLibID() const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>QUuid</db:type>
<db:methodname>typeLibID</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUuid typeLibID() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return the ActiveX server's type library identifier.</db:para>
</db:section>
<db:section xml:id="unregisterClass">
<db:title>[virtual] void QAxFactory::unregisterClass(const QString &amp;<db:emphasis>key</db:emphasis>, QSettings *<db:emphasis>settings</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>unregisterClass</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSettings *</db:type>
<db:parameter>settings</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void unregisterClass(const QString &amp;key, QSettings *settings) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Unregisters any additional values for the class <db:code role="parameter">key</db:code> from the system registry using the <db:code role="parameter">settings</db:code> object.</db:para>
<db:programlisting language="cpp">settings-&amp;gt;remove(&quot;/CLSID/&quot; + classID(key)
                 + &quot;/Implemented Categories&quot;
                 + &quot;/{00000000-0000-0000-000000000000}/.&quot;);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxfactory.xml#registerClass">registerClass</db:link>()</db:member>
<db:member><db:link xlink:href="qsettings.xml">QSettings</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="validateLicenseKey">
<db:title>[virtual] bool QAxFactory::validateLicenseKey(const QString &amp;<db:emphasis>key</db:emphasis>, const QString &amp;<db:emphasis>licenseKey</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>validateLicenseKey</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>licenseKey</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool validateLicenseKey(const QString &amp;key, const QString &amp;licenseKey) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplement this function to return true if <db:code role="parameter">licenseKey</db:code> is a valid license for the class <db:code role="parameter">key</db:code>, or if the current machine is licensed.</db:para>
<db:para>The default implementation returns true if the class <db:code role="parameter">key</db:code> is not licensed (ie. no <db:code>Q_CLASSINFO()</db:code> attribute &quot;LicenseKey&quot;), or if <db:code role="parameter">licenseKey</db:code> matches the value of the &quot;LicenseKey&quot; attribute, or if the machine is licensed through a .LIC file with the same filename as this COM server.</db:para>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QAXCLASS">
<db:title>QAXCLASS(<db:emphasis>Class</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QAXCLASS</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Class</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QAXCLASS(Class)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro adds a creatable COM class <db:code role="parameter">Class</db:code> to the <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> declared with the <db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>() macro.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXTYPE">QAXTYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_END">QAXFACTORY_END</db:link>()</db:member>
<db:member><db:link xlink:href="qobject.xml#Q_CLASSINFO">Q_CLASSINFO</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QAXFACTORY_BEGIN">
<db:title>QAXFACTORY_BEGIN(<db:emphasis>IDTypeLib</db:emphasis>, <db:emphasis>IDApp</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QAXFACTORY_BEGIN</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>IDTypeLib</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>IDApp</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QAXFACTORY_BEGIN(IDTypeLib, IDApp)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro can be used to export multiple <db:link xlink:href="qobject.xml">QObject</db:link> classes through an implicitly declared <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> implementation. All <db:link xlink:href="qobject.xml">QObject</db:link> classes have to declare the ClassID, InterfaceID and EventsID (if applicable) through the <db:link xlink:href="qobject.xml#Q_CLASSINFO">Q_CLASSINFO</db:link>() macro. All declarations will be in a type library with the id <db:code role="parameter">IDTypeLib</db:code>, and if the server is an executable server then it will have the application id <db:code role="parameter">IDApp</db:code>.</db:para>
<db:para>This macro needs to be used together with the <db:link xlink:href="qaxfactory.xml#QAXCLASS">QAXCLASS</db:link>(), <db:link xlink:href="qaxfactory.xml#QAXTYPE">QAXTYPE</db:link>() and <db:link xlink:href="qaxfactory.xml#QAXFACTORY_END">QAXFACTORY_END</db:link>() macros.</db:para>
<db:programlisting language="cpp">QAXFACTORY_BEGIN(
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // type library ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;  // application ID
)
    QAXCLASS(Class1)
    QAXCLASS(Class2)
QAXFACTORY_END()
</db:programlisting>
</db:section>
<db:section xml:id="QAXFACTORY_END">
<db:title>QAXFACTORY_END</db:title>
<db:methodsynopsis>
<db:methodname>QAXFACTORY_END</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QAXFACTORY_END</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Completes the <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> declaration started with the <db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>() macro.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXCLASS">QAXCLASS</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXTYPE">QAXTYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QAXFACTORY_EXPORT">
<db:title>QAXFACTORY_EXPORT(<db:emphasis>Class</db:emphasis>, <db:emphasis>LibID</db:emphasis>, <db:emphasis>AppID</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QAXFACTORY_EXPORT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Class</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>LibID</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>AppID</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QAXFACTORY_EXPORT(Class, LibID, AppID)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro can be used to export a <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> implementation <db:code role="parameter">Class</db:code> from a COM server. All declarations will be in a type library with the id <db:code role="parameter">LibID</db:code>, and if the server is an executable server then it will have the application id <db:code role="parameter">AppID</db:code>.</db:para>
<db:programlisting language="cpp">QAXFACTORY_EXPORT(
    MyFactory,                                // factory class
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // type library ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;  // application ID
)
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QAXTYPE">
<db:title>QAXTYPE(<db:emphasis>Class</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QAXTYPE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Class</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QAXTYPE(Class)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro adds a non-creatable COM class <db:code role="parameter">Class</db:code> to the <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> declared with the <db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>(). The class <db:code role="parameter">Class</db:code> can be used in APIs of other COM classes exported through QAXTYPE() or <db:link xlink:href="qaxfactory.xml#QAXCLASS">QAXCLASS</db:link>().</db:para>
<db:para>Instances of type <db:code role="parameter">Class</db:code> can only be retrieved using APIs of already instantiated objects.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXCLASS">QAXCLASS</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_END">QAXFACTORY_END</db:link>()</db:member>
<db:member><db:link xlink:href="qobject.xml#Q_CLASSINFO">Q_CLASSINFO</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QAxFactory</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-macro-documentation">
<db:title>Obsolete Macro Documentation</db:title>
<db:section xml:id="QAXFACTORY_DEFAULT">
<db:title>QAXFACTORY_DEFAULT(<db:emphasis>Class</db:emphasis>, <db:emphasis>ClassID</db:emphasis>, <db:emphasis>InterfaceID</db:emphasis>, <db:emphasis>EventID</db:emphasis>, <db:emphasis>LibID</db:emphasis>, <db:emphasis>AppID</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QAXFACTORY_DEFAULT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>Class</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>ClassID</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>InterfaceID</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>EventID</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>LibID</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>AppID</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QAXFACTORY_DEFAULT(Class, ClassID, InterfaceID, EventID, LibID, AppID)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This macro can be used to export a single <db:link xlink:href="qobject.xml">QObject</db:link> subclass <db:code role="parameter">Class</db:code> a this COM server through an implicitly declared <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> implementation.</db:para>
<db:para>This macro exports the class <db:code role="parameter">Class</db:code> as a COM coclass with the CLSID <db:code role="parameter">ClassID</db:code>. The properties and slots will be declared through a COM interface with the IID <db:code role="parameter">InterfaceID</db:code>, and signals will be declared through a COM event interface with the IID <db:code role="parameter">EventID</db:code>. All declarations will be in a type library with the id <db:code role="parameter">LibID</db:code>, and if the server is an executable server then it will have the application id <db:code role="parameter">AppID</db:code>.</db:para>
<db:programlisting language="cpp">#include &amp;lt;qaxfactory.h&amp;gt;

#include &quot;theactivex.h&quot;

QAXFACTORY_DEFAULT(
    TheActiveX,                               // widget class
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // class ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // interface ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // event interface ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // type library ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;  // application ID
)
</db:programlisting>
<db:note>
<db:para>This class has been deprecated in favor of <db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_EXPORT">QAXFACTORY_EXPORT</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
