<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QAxFactory Class</db:title>
<db:productname>ActiveQt</db:productname>
<db:edition>Qt 5.2.1 Reference Documentation</db:edition>
<db:titleabbrev>ActiveQt</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> class defines a factory for the creation of COM components.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QAxFactory</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += axserver</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Implement this factory once in your COM server to provide information about the components the server can create. Subclass <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> and implement the pure virtual functions in any implementation file (e.g. main.cpp), and export the factory using the <db:code>QAXFACTORY_EXPORT()</db:code> macro.</db:para>
<db:programlisting language="cpp">QStringList ActiveQtFactory::featureList() const
{
    QStringList list;
    list &lt;&lt; &quot;ActiveX1&quot;;
    list &lt;&lt; &quot;ActiveX2&quot;;
    return list;
}

QObject *ActiveQtFactory::createObject(const QString &amp;key)
{
    if (key == &quot;ActiveX1&quot;)
        return new ActiveX1(parent);
    if (key == &quot;ActiveX2&quot;)
        return new ActiveX2(parent);
    return 0;
}

const QMetaObject *ActiveQtFactory::metaObject(const QString &amp;key) const
{
    if (key == &quot;ActiveX1&quot;)
        return &amp;ActiveX1::staticMetaObject;
    if (key == &quot;ActiveX2&quot;)
        return &amp;ActiveX2::staticMetaObject;
}

QUuid ActiveQtFactory::classID(const QString &amp;key) const
{
    if (key == &quot;ActiveX1&quot;)
        return &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;;
    ...
    return QUuid();
}

QUuid ActiveQtFactory::interfaceID(const QString &amp;key) const
{
    if (key == &quot;ActiveX1&quot;)
        return &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;;
    ...
    return QUuid();
}

QUuid ActiveQtFactory::eventsID(const QString &amp;key) const
{
    if (key == &quot;ActiveX1&quot;)
        return &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;;
    ...
    return QUuid();
}

QAXFACTORY_EXPORT(
    ActiveQtFactory,                          // factory class
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // type library ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;  // application ID
)
</db:programlisting>
<db:para>If you use the <db:code>Q_CLASSINFO()</db:code> macro to provide the unique identifiers or other attributes for your class you can use the <db:code>QAXFACTORY_BEGIN()</db:code>, <db:code>QAXCLASS()</db:code> and <db:code>QAXFACTORY_END()</db:code> macros to expose one or more classes as COM objects.</db:para>
<db:programlisting language="cpp">QAXFACTORY_BEGIN(
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // type library ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;  // application ID
)
    QAXCLASS(Class1)
    QAXCLASS(Class2)
QAXFACTORY_END()
</db:programlisting>
<db:para>If your server supports just a single COM object, you can use a default factory implementation through the <db:code>QAXFACTORY_DEFAULT()</db:code> macro.</db:para>
<db:programlisting language="cpp">#include &lt;qapplication.h&gt;
#include &lt;qaxfactory.h&gt;

#include &quot;theactivex.h&quot;

QAXFACTORY_DEFAULT(
    TheActiveX,                           // widget class
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // class ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // interface ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // event interface ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // type library ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;  // application ID
)
</db:programlisting>
<db:para>Only one <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> implementation may be instantiated and exported by an ActiveX server application. This instance is accessible through the global qAxFactory() function.</db:para>
<db:para>A factory can also reimplement the <db:link xlink:href="qaxfactory.xml#registerClass">registerClass</db:link>() and <db:link xlink:href="qaxfactory.xml#unregisterClass">unregisterClass</db:link>() functions to set additional flags for an ActiveX control in the registry. To limit the number of methods or properties a widget class exposes from its parent classes reimplement <db:link xlink:href="qaxfactory.xml#exposeToSuperClass">exposeToSuperClass</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxaggregated.xml">QAxAggregated</db:link></db:member>
<db:member><db:link xlink:href="qaxbindable.xml">QAxBindable</db:link></db:member>
<db:member><db:link xlink:href="activeqt-index.xml#activeqt-framework">ActiveQt Framework</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ServerType-enum">
<db:title>enum QAxFactory::ServerType</db:title>
<db:para>This enum specifies the different types of servers that can be started with <db:link xlink:href="qaxfactory.xml#startServer">startServer</db:link>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qaxfactory.xml">QAxFactory</db:link></db:emphasis>::SingleInstance</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The server process can create only one instance of each exported class. COM starts a new process for each request. This is typically used in servers that export only one creatable class.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qaxfactory.xml">QAxFactory</db:link></db:emphasis>::MultipleInstances</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The server can create multiple instances of each exported class. This is the default. All instances will live in the same thread, and will share static resources.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QAxFactory">
<db:title>QAxFactory::QAxFactory(const QUuid &amp;<db:emphasis>libid</db:emphasis>, const QUuid &amp;<db:emphasis>appid</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> object that returns <db:code role="parameter">libid</db:code> and <db:code role="parameter">appid</db:code> in the implementation of the respective interface functions.</db:para>
</db:section>
<db:section xml:id="dtor.QAxFactory">
<db:title>[virtual noexcept] QAxFactory::~QAxFactory()</db:title>
<db:para>Destroys the <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> object.</db:para>
</db:section>
<db:section xml:id="appID">
<db:title>[virtual] QUuid QAxFactory::appID() const</db:title>
<db:para>Reimplement this function to return the ActiveX server's application identifier.</db:para>
</db:section>
<db:section xml:id="classID">
<db:title>[virtual] QUuid QAxFactory::classID(const int &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Reimplement this function to return the class identifier for each <db:code role="parameter">key</db:code> returned by the <db:link xlink:href="qaxfactory.xml#featureList">featureList</db:link>() implementation, or an empty QUuid if this factory doesn't support the value of <db:code role="parameter">key</db:code>.</db:para>
<db:para>The default implementation interprets <db:code role="parameter">key</db:code> as the class name, and returns the value of the Q_CLASSINFO() entry &quot;ClassID&quot;.</db:para>
</db:section>
<db:section xml:id="createObject">
<db:title>int *QAxFactory::createObject(const int &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Reimplement this function to return a new object for <db:code role="parameter">key</db:code>, or 0 if this factory doesn't support the value of <db:code role="parameter">key</db:code>.</db:para>
<db:para>If the object returned is a QWidget it will be exposed as an ActiveX control, otherwise the returned object will be exposed as a simple COM object.</db:para>
</db:section>
<db:section xml:id="createObjectWrapper">
<db:title>[virtual] bool QAxFactory::createObjectWrapper(int *<db:emphasis>object</db:emphasis>, IDispatch **<db:emphasis>wrapper</db:emphasis>)</db:title>
<db:para>Reimplement this function to provide the COM object for <db:code role="parameter">object</db:code> in <db:code role="parameter">wrapper</db:code>. Return true if the function was successful; otherwise return false.</db:para>
<db:para>The default implementation creates a generic automation wrapper based on the meta object information of <db:code role="parameter">object</db:code>.</db:para>
</db:section>
<db:section xml:id="eventsID">
<db:title>[virtual] QUuid QAxFactory::eventsID(const int &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Reimplement this function to return the identifier of the event interface for each <db:code role="parameter">key</db:code> returned by the <db:link xlink:href="qaxfactory.xml#featureList">featureList</db:link>() implementation, or an empty QUuid if this factory doesn't support the value of <db:code role="parameter">key</db:code>.</db:para>
<db:para>The default implementation interprets <db:code role="parameter">key</db:code> as the class name, and returns the value of the Q_CLASSINFO() entry &quot;EventsID&quot;.</db:para>
</db:section>
<db:section xml:id="exposeToSuperClass">
<db:title>int QAxFactory::exposeToSuperClass(const int &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Reimplement this function to return the name of the super class of <db:code role="parameter">key</db:code> up to which methods and properties should be exposed by the ActiveX control.</db:para>
<db:para>The default implementation interprets <db:code role="parameter">key</db:code> as the class name, and returns the value of the <db:code>Q_CLASSINFO()</db:code> entry &quot;ToSuperClass&quot;. If no such value is set the null-string is returned, and the functions and properties of all the super classes including QWidget will be exposed.</db:para>
<db:para>To only expose the functions and properties of the class itself, reimplement this function to return <db:code role="parameter">key</db:code>.</db:para>
</db:section>
<db:section xml:id="featureList">
<db:title>int QAxFactory::featureList() const</db:title>
<db:para>Reimplement this function to return a list of the widgets (class names) supported by this factory.</db:para>
</db:section>
<db:section xml:id="hasStockEvents">
<db:title>[virtual] bool QAxFactory::hasStockEvents(const int &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Reimplement this function to return true if the ActiveX control <db:code role="parameter">key</db:code> should support the standard ActiveX events</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Click</db:para>
</db:listitem>
<db:listitem>
<db:para>DblClick</db:para>
</db:listitem>
<db:listitem>
<db:para>KeyDown</db:para>
</db:listitem>
<db:listitem>
<db:para>KeyPress</db:para>
</db:listitem>
<db:listitem>
<db:para>KeyUp</db:para>
</db:listitem>
<db:listitem>
<db:para>MouseDown</db:para>
</db:listitem>
<db:listitem>
<db:para>MouseUp</db:para>
</db:listitem>
<db:listitem>
<db:para>MouseMove</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The default implementation interprets <db:code role="parameter">key</db:code> as the class name, and returns true if the value of the <db:code>Q_CLASSINFO()</db:code> entry &quot;StockEvents&quot; is &quot;yes&quot;. Otherwise this function returns false.</db:para>
</db:section>
<db:section xml:id="interfaceID">
<db:title>[virtual] QUuid QAxFactory::interfaceID(const int &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Reimplement this function to return the interface identifier for each <db:code role="parameter">key</db:code> returned by the <db:link xlink:href="qaxfactory.xml#featureList">featureList</db:link>() implementation, or an empty QUuid if this factory doesn't support the value of <db:code role="parameter">key</db:code>.</db:para>
<db:para>The default implementation interprets <db:code role="parameter">key</db:code> as the class name, and returns the value of the Q_CLASSINFO() entry &quot;InterfaceID&quot;.</db:para>
</db:section>
<db:section xml:id="isServer">
<db:title>[static] bool QAxFactory::isServer()</db:title>
<db:para>Returns true if the application has been started (by COM) as an ActiveX server, otherwise returns false.</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    if (!QAxFactory::isServer()) {
        // initialize for stand-alone execution
    }
    return app.exec();
}
</db:programlisting>
</db:section>
<db:section xml:id="isService">
<db:title>[virtual] bool QAxFactory::isService() const</db:title>
<db:para>Reimplement this function to return true if the server is running as a persistent service (e.g. an NT service) and should not terminate even when all objects provided have been released.</db:para>
<db:para>The default implementation returns false.</db:para>
</db:section>
<db:section xml:id="metaObject">
<db:title>const int *QAxFactory::metaObject(const int &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Reimplement this function to return the QMetaObject corresponding to <db:code role="parameter">key</db:code>, or 0 if this factory doesn't support the value of <db:code role="parameter">key</db:code>.</db:para>
</db:section>
<db:section xml:id="registerActiveObject">
<db:title>[static] bool QAxFactory::registerActiveObject(int *<db:emphasis>object</db:emphasis>)</db:title>
<db:para>Registers the QObject <db:code role="parameter">object</db:code> with COM as a running object, and returns true if the registration succeeded, otherwise returns false. The object is unregistered automatically when it is destroyed.</db:para>
<db:para>This function should only be called if the application has been started by the user (i.e. not by COM to respond to a request), and only for one object, usually the toplevel object of the application's object hierarchy.</db:para>
<db:para>This function does nothing and returns false if the object's class info for &quot;RegisterObject&quot; is not set to &quot;yes&quot;, or if the server is an in-process server.</db:para>
</db:section>
<db:section xml:id="registerClass">
<db:title>[virtual] void QAxFactory::registerClass(const int &amp;<db:emphasis>key</db:emphasis>, QSettings *<db:emphasis>settings</db:emphasis>) const</db:title>
<db:para>Registers additional values for the class <db:code role="parameter">key</db:code> in the system registry using the <db:code role="parameter">settings</db:code> object. The standard values have already been registered by the framework, but additional values, e.g. implemented categories, can be added in an implementation of this function.</db:para>
<db:programlisting language="cpp">settings-&gt;setValue(&quot;/CLSID/&quot; + classID(key)
                   + &quot;/Implemented Categories/&quot;
                   + &quot;/{00000000-0000-0000-000000000000}/.&quot;,
                   QString());
</db:programlisting>
<db:para>If you reimplement this function you must also reimplement <db:link xlink:href="qaxfactory.xml#unregisterClass">unregisterClass</db:link>() to remove the additional registry values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>QSettings</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="serverDirPath">
<db:title>[static] int QAxFactory::serverDirPath()</db:title>
<db:para>Returns the directory that contains the server binary.</db:para>
<db:para>For out-of-process servers this is the same as QApplication::applicationDirPath(). For in-process servers that function returns the directory that contains the hosting application.</db:para>
</db:section>
<db:section xml:id="serverFilePath">
<db:title>[static] int QAxFactory::serverFilePath()</db:title>
<db:para>Returns the file path of the server binary.</db:para>
<db:para>For out-of-process servers this is the same as QApplication::applicationFilePath(). For in-process servers that function returns the file path of the hosting application.</db:para>
</db:section>
<db:section xml:id="startServer">
<db:title>[static] bool QAxFactory::startServer(QAxFactory::ServerType <db:emphasis>type</db:emphasis> = MultipleInstances)</db:title>
<db:para>Starts the COM server with <db:code role="parameter">type</db:code> and returns true if successful, otherwise returns false.</db:para>
<db:para>Calling this function if the server is already running (or for an in-process server) does nothing and returns true.</db:para>
<db:para>The server is started automatically with <db:code role="parameter">type</db:code> set to <db:code>MultipleInstances</db:code> if the server executable has been started with the <db:code>-activex</db:code> command line parameter. To switch to <db:link xlink:href="qaxfactory.xml#ServerType-enum">SingleInstance</db:link>, call</db:para>
<db:programlisting language="cpp">if (QAxFactory::isServer()) {
    QAxFactory::stopServer();
    QAxFactory::startServer(QAxFactory::SingleInstance);
}
</db:programlisting>
<db:para>in your own main() entry point function.</db:para>
</db:section>
<db:section xml:id="stayTopLevel">
<db:title>[virtual] bool QAxFactory::stayTopLevel(const int &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Reimplement this function to return true if the ActiveX control <db:code role="parameter">key</db:code> should be a top level window, e.g. a dialog. The default implementation returns false.</db:para>
</db:section>
<db:section xml:id="stopServer">
<db:title>[static] bool QAxFactory::stopServer()</db:title>
<db:para>Stops the COM server and returns true if successful, otherwise returns false.</db:para>
<db:para>Calling this function if the server is not running (or for an in-process server) does nothing and returns true.</db:para>
<db:para>Stopping the server will not invalidate existing objects, but no new objects can be created from the existing server process. Usually COM will start a new server process if additional objects are requested.</db:para>
<db:para>The server is stopped automatically when the main() function returns.</db:para>
</db:section>
<db:section xml:id="typeLibID">
<db:title>[virtual] QUuid QAxFactory::typeLibID() const</db:title>
<db:para>Reimplement this function to return the ActiveX server's type library identifier.</db:para>
</db:section>
<db:section xml:id="unregisterClass">
<db:title>[virtual] void QAxFactory::unregisterClass(const int &amp;<db:emphasis>key</db:emphasis>, QSettings *<db:emphasis>settings</db:emphasis>) const</db:title>
<db:para>Unregisters any additional values for the class <db:code role="parameter">key</db:code> from the system registry using the <db:code role="parameter">settings</db:code> object.</db:para>
<db:programlisting language="cpp">settings-&gt;remove(&quot;/CLSID/&quot; + classID(key)
                 + &quot;/Implemented Categories&quot;
                 + &quot;/{00000000-0000-0000-000000000000}/.&quot;);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxfactory.xml#registerClass">registerClass</db:link>()</db:member>
<db:member>QSettings</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="validateLicenseKey">
<db:title>[virtual] bool QAxFactory::validateLicenseKey(const int &amp;<db:emphasis>key</db:emphasis>, const int &amp;<db:emphasis>licenseKey</db:emphasis>) const</db:title>
<db:para>Reimplement this function to return true if <db:code role="parameter">licenseKey</db:code> is a valid license for the class <db:code role="parameter">key</db:code>, or if the current machine is licensed.</db:para>
<db:para>The default implementation returns true if the class <db:code role="parameter">key</db:code> is not licensed (ie. no <db:code>Q_CLASSINFO()</db:code> attribute &quot;LicenseKey&quot;), or if <db:code role="parameter">licenseKey</db:code> matches the value of the &quot;LicenseKey&quot; attribute, or if the machine is licensed through a .LIC file with the same filename as this COM server.</db:para>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QAXCLASS">
<db:title>QAXCLASS(<db:emphasis>Class</db:emphasis>)</db:title>
<db:para>This macro adds a creatable COM class <db:code role="parameter">Class</db:code> to the <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> declared with the <db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>() macro.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXTYPE">QAXTYPE</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_END">QAXFACTORY_END</db:link>()</db:member>
<db:member><db:link xlink:href="">Q_CLASSINFO()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QAXFACTORY_BEGIN">
<db:title>QAXFACTORY_BEGIN(<db:emphasis>IDTypeLib</db:emphasis>, <db:emphasis>IDApp</db:emphasis>)</db:title>
<db:para>This macro can be used to export multiple QObject classes through an implicitly declared <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> implementation. All QObject classes have to declare the ClassID, InterfaceID and EventsID (if applicable) through the Q_CLASSINFO() macro. All declarations will be in a type library with the id <db:code role="parameter">IDTypeLib</db:code>, and if the server is an executable server then it will have the application id <db:code role="parameter">IDApp</db:code>.</db:para>
<db:para>This macro needs to be used together with the <db:link xlink:href="qaxfactory.xml#QAXCLASS">QAXCLASS</db:link>(), <db:link xlink:href="qaxfactory.xml#QAXTYPE">QAXTYPE</db:link>() and <db:link xlink:href="qaxfactory.xml#QAXFACTORY_END">QAXFACTORY_END</db:link>() macros.</db:para>
<db:programlisting language="cpp">QAXFACTORY_BEGIN(
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // type library ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;  // application ID
)
    QAXCLASS(Class1)
    QAXCLASS(Class2)
QAXFACTORY_END()
</db:programlisting>
</db:section>
<db:section xml:id="QAXFACTORY_DEFAULT">
<db:title>QAXFACTORY_DEFAULT(<db:emphasis>Class</db:emphasis>, <db:emphasis>ClassID</db:emphasis>, <db:emphasis>InterfaceID</db:emphasis>, <db:emphasis>EventID</db:emphasis>, <db:emphasis>LibID</db:emphasis>, <db:emphasis>AppID</db:emphasis>)</db:title>
<db:para>This macro can be used to export a single QObject subclass <db:code role="parameter">Class</db:code> a this COM server through an implicitly declared <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> implementation.</db:para>
<db:para>This macro exports the class <db:code role="parameter">Class</db:code> as a COM coclass with the CLSID <db:code role="parameter">ClassID</db:code>. The properties and slots will be declared through a COM interface with the IID <db:code role="parameter">InterfaceID</db:code>, and signals will be declared through a COM event interface with the IID <db:code role="parameter">EventID</db:code>. All declarations will be in a type library with the id <db:code role="parameter">LibID</db:code>, and if the server is an executable server then it will have the application id <db:code role="parameter">AppID</db:code>.</db:para>
<db:programlisting language="cpp">#include &lt;qaxfactory.h&gt;

#include &quot;theactivex.h&quot;

QAXFACTORY_DEFAULT(
    TheActiveX,                           // widget class
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // class ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // interface ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // event interface ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // type library ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;  // application ID
)
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_EXPORT">QAXFACTORY_EXPORT</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QAXFACTORY_END">
<db:title>QAXFACTORY_END</db:title>
<db:para>Completes the <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> declaration started with the <db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>() macro.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXCLASS">QAXCLASS</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXTYPE">QAXTYPE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QAXFACTORY_EXPORT">
<db:title>QAXFACTORY_EXPORT(<db:emphasis>Class</db:emphasis>, <db:emphasis>LibID</db:emphasis>, <db:emphasis>AppID</db:emphasis>)</db:title>
<db:para>This macro can be used to export a <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> implementation <db:code role="parameter">Class</db:code> from a COM server. All declarations will be in a type library with the id <db:code role="parameter">LibID</db:code>, and if the server is an executable server then it will have the application id <db:code role="parameter">AppID</db:code>.</db:para>
<db:programlisting language="cpp">QAXFACTORY_EXPORT(
    MyFactory,                                // factory class
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;, // type library ID
    &quot;{01234567-89AB-CDEF-0123-456789ABCDEF}&quot;  // application ID
)
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QAXTYPE">
<db:title>QAXTYPE(<db:emphasis>Class</db:emphasis>)</db:title>
<db:para>This macro adds a non-creatable COM class <db:code role="parameter">Class</db:code> to the <db:link xlink:href="qaxfactory.xml">QAxFactory</db:link> declared with the <db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>(). The class <db:code role="parameter">Class</db:code> can be used in APIs of other COM classes exported through QAXTYPE() or <db:link xlink:href="qaxfactory.xml#QAXCLASS">QAXCLASS</db:link>().</db:para>
<db:para>Instances of type <db:code role="parameter">Class</db:code> can only be retrieved using APIs of already instantiated objects.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_BEGIN">QAXFACTORY_BEGIN</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXCLASS">QAXCLASS</db:link>()</db:member>
<db:member><db:link xlink:href="qaxfactory.xml#QAXFACTORY_END">QAXFACTORY_END</db:link>()</db:member>
<db:member><db:link xlink:href="">Q_CLASSINFO()</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
