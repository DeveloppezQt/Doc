<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Coffee Machine</db:title>
<db:productname>QtDoc</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A Qt Quick application with a state-based custom user interface.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/coffee_machine_overview.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="coffee-machine-example-overview">
<db:title>Coffee Machine example overview</db:title>
<db:para>This app demonstrates a cross platform, multi screen size and responsive way of implementing a typical user interface for product ordering.</db:para>
<db:section xml:id="selecting-a-recipe">
<db:title>Selecting a recipe</db:title>
<db:figure>
<db:title>The coffee selection</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/coffee_machine_selection.png"/>
</db:imageobject>
</db:mediaobject>
</db:figure>
<db:para>The coffee machine application lets you choose a type of coffee and indicates how many coffees of that type you have left to order.</db:para>
</db:section>
<db:section xml:id="coffee-customization">
<db:title>Coffee customization</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/coffee_machine_modify.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Once a recipe is selected, the app displays what ratio the coffee blend will contain of:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>brewed coffee</db:para>
</db:listitem>
<db:listitem>
<db:para>hot milk</db:para>
</db:listitem>
<db:listitem>
<db:para>milk foam</db:para>
</db:listitem>
<db:listitem>
<db:para>sugar</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>This can be modified using sliders.</db:para>
</db:section>
<db:section xml:id="displaying-the-brewing-status">
<db:title>Displaying the brewing status</db:title>
<db:para>Once the user has acknowledged that the cup is in the machine the brew starts.</db:para>
<db:para>When the brew has been started, the app shows an animated display of the brewing process.</db:para>
</db:section>
<db:section xml:id="coffee-is-ready">
<db:title>Coffee is ready</db:title>
<db:para>Once the brewing process has ended, the app shows coffee cup with the desired coffee mix in it for a few seconds before returning to the starting page.</db:para>
</db:section>
</db:section>
<db:section xml:id="how-it-works">
<db:title>How it works</db:title>
<db:para>Here we discuss how these features are implemented.</db:para>
<db:section xml:id="adapting-to-screen-sizes-and-orientation">
<db:title>Adapting to screen sizes and orientation</db:title>
<db:para>The application window root object has initial values for height and width, which will be used as the window size on desktop platforms. The default <db:link xlink:href="qwindow.xml#Visibility-enum">QWindow::AutomaticVisibility</db:link> ensures that the window will be shown as maximized or fullscreen on platforms that require it, such as mobile platforms.</db:para>
<db:programlisting language="qml">ApplicationWindow {
    visible: true
    width: 1000
    height: 600
    title: qsTr(&quot;Coffee&quot;)
</db:programlisting>
<db:para>From there child objects of the ApplicationWindow fetch the size of the ApplicationWindow to determine their own sizes accordingly.</db:para>
<db:para>The app uses <db:link xlink:href="qml-qtquick-layouts-gridlayout.xml">GridLayout</db:link> throughout the application page components to easily adapt to changes in screen orientation.</db:para>
</db:section>
<db:section xml:id="navigating-through-the-app-pages">
<db:title>Navigating through the app pages</db:title>
<db:para>The application uses <db:link xlink:href="qml-qtquick-controls-stackview.xml">StackView</db:link> QML type to display different pages of the app. The StackView handling the different page components is implemented in ApplicationFlowForm.ui.qml.</db:para>
<db:para>Navigating from one page to next triggers a state change in ApplicationFlow.qml where the needed property changes are handled by <db:link xlink:href="qml-qtquick-propertychanges.xml">PropertyChanges</db:link> QML type:</db:para>
<db:programlisting language="qml">states: [
    State {
        name: &quot;Home&quot;
        PropertyChanges {
            target: toolbar
            backButton.opacity: 0
            backButton.enabled: false
            themeButton.opacity: 0
            themeButton.enabled: false
            logo.sourceSize.width: 70
            logo.sourceSize.height: 50
        }
</db:programlisting>
<db:para>The animations happening during these state changes are implemented with <db:link xlink:href="qml-qtquick-transition.xml">Transition</db:link> and <db:link xlink:href="qml-qtquick-propertyanimation.xml">PropertyAnimation</db:link> inside the StackView component in ApplicationFLowForm.ui.qml.</db:para>
</db:section>
<db:section xml:id="implementing-start-page">
<db:title>Implementing start page</db:title>
<db:para>The application starts by showing the Home page to the user as the initial item in the <db:link xlink:href="qml-qtquick-controls-stackview.xml">StackView</db:link>:</db:para>
<db:programlisting language="qml">StackView {
    id: stack
    anchors.top: parent.top
    anchors.bottom: parent.bottom
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.topMargin: parent.height / 20
    initialItem: Home {
        id: home
        visible: true
        state: applicationFlow.mode
    }
    pushEnter: Transition {
        PropertyAnimation {
            property: &quot;x&quot;
            from: stack.width
            to: 0
            duration: 400
        }
    }
</db:programlisting>
<db:para>The Home component is structured by placing <db:link xlink:href="qml-qtquick-item.xml">Item</db:link> component as the root object with state machine and appropriate property aliases, followed by <db:link xlink:href="qml-qtquick-layouts-gridlayout.xml">GridLayout</db:link>. This same kind of structuring will be used in all of the app page components.</db:para>
<db:para>The Home page displays an image of a coffee cup with Qt logo on top, Coffee Machine as a title, caption with some catchy briefing on what the user can expect and a getStartedButton button.</db:para>
<db:para>The user can move forward by pressing the getStartedButton, the button onClicked function is implemented ApplicationFlow.qml:</db:para>
<db:programlisting language="qml">home.getStartedbutton.onClicked: {
    applicationFlow.state = &quot;Coffee-selection&quot;
    stack.push(choosingCoffee)
}
</db:programlisting>
<db:para>This will trigger the state change to &quot;Coffee-selection&quot; in ApplicationFlow.qml and push the choosingCoffee component on top of the Home component in <db:link xlink:href="qml-qtquick-controls-stackview.xml">StackView</db:link>.</db:para>
</db:section>
<db:section xml:id="implementing-coffee-selection">
<db:title>Implementing coffee selection</db:title>
<db:para>On the Coffee Selection page ChoosingCoffee.qml is displayed, here the user sees 4 different coffee options to choose from. These options are displayed as CoffeeCards which are located inside the <db:link xlink:href="qml-qtquick-layouts-gridlayout.xml">GridLayout</db:link> in ChoosingCoffee.qml:</db:para>
<db:programlisting language="qml">GridLayout {
    id: cards
    anchors.horizontalCenter: parent.horizontalCenter
    anchors.top: parent.top
    rowSpacing: 20
    columnSpacing: 20
    CoffeeCard {
        id: cappuccino
        coffeeName: &quot;Cappuccino&quot;
        ingredients: &quot;Milk, Espresso, Foam&quot;
        time: 2
        cupsLeft: applicationFlow.cappuccinos
    }
    CoffeeCard {
        id: latte
        coffeeName: &quot;Latte&quot;
        ingredients: &quot;Coffee, Foam&quot;
        time: 3
        cupsLeft: applicationFlow.lattes
    }
    CoffeeCard {
        id: espresso
        coffeeName: &quot;Espresso&quot;
        ingredients: &quot;Milk, Espresso&quot;
        time: 2
        cupsLeft: applicationFlow.espressos
    }
    CoffeeCard {
        id: macchiato
        coffeeName: &quot;Macchiato&quot;
        ingredients: &quot;Milk foam, Espresso&quot;
        time: 4
        cupsLeft: applicationFlow.macchiatos
    }
}
</db:programlisting>
<db:para>The implementation of the CoffeeCard is located CoffeeCard.qml.</db:para>
<db:para>These cards may be displayed in either grid or in a row type of way depending on the available screen width and height properties that the ApplicationWindow root object follows and passes down to the ChoosingCoffee.qml and to the <db:link xlink:href="qml-qtquick-layouts-gridlayout.xml">GridLayout</db:link> in there through the state machine.</db:para>
<db:para>CoffeeCards vary in their names, brewing times, ingredients and how many cups there are available at the moment.</db:para>
<db:para>On this page the user can also change the application theme for the first time by pressing the little sun looking icon button from the upper right corner of the screen. Pressing the theme button calls themeButton function in ApplicationFlow.qml:</db:para>
<db:programlisting language="qml">function themeButton() {
    if (Colors.currentTheme == Colors.dark) {
        Colors.currentTheme = Colors.light
    } else {
        Colors.currentTheme = Colors.dark
    }
}
</db:programlisting>
<db:para>The function changes the currentTheme property of Colors.qml and colors change throughout the app by property bindings automatically. All the colors used in app are located in Colors.qml.</db:para>
<db:para>If theme is switched to light theme the theme changing icon button icon turns to represent a half moon.</db:para>
<db:para>Pressing on any of the coffee cards triggers a state change inside <db:link xlink:href="qml-qtquick-controls-abstractbutton.xml">AbstractButton</db:link> in CoffeeCard.qml which then triggers <db:link xlink:href="qml-qtquick-numberanimation.xml">NumberAnimation</db:link> through <db:link xlink:href="qml-qtquick-transition.xml">Transition</db:link>:</db:para>
<db:programlisting language="qml">AbstractButton {
    width: parent.width - 2
    height: parent.height - 2
    anchors.horizontalCenter: parent.horizontalCenter
    anchors.verticalCenter: parent.verticalCenter
    id: button
    hoverEnabled: true
    checkable: true
    enabled: (cupsLeft != 0) ? true : false
    transitions: Transition {
        NumberAnimation {
            properties: &quot;scale&quot;
            duration: 50
            easing.type: Easing.InOutQuad
        }
    }
</db:programlisting>
<db:para>This will scale the selected coffee card down to smaller size and turns the edges of the card to green giving user the expression that the coffee was indeed selected.</db:para>
<db:para>Every coffee cards button property alias onClicked function binds to a function located in ApplicationFlow.qml. When user presses any of the coffee cards the function with a name correlating with the chosen coffee option gets called. The function will set the state of ApplicationFlow.qml to Settings , push a new component to the <db:link xlink:href="qml-qtquick-controls-stackview.xml">StackView</db:link> and set the ingredient properties accordingly.</db:para>
</db:section>
<db:section xml:id="implementing-coffee-settings">
<db:title>Implementing coffee settings</db:title>
<db:para>On this page the user can customize their coffee option to match their preference by adjusting custom <db:link xlink:href="qml-qtquick-controls-slider.xml">Slider</db:link> QML types. Changing the value of sliders will affect the liquid levels seen inside the coffee cup, this is made possible by binding the height of the liquid images inside Cup.qml to the values of corresponding sliders.</db:para>
<db:para>The values of the sliders will be stored to property variables in ApplicationFLow.qml through onValueChanged function.</db:para>
<db:programlisting language="qml">coffeeSlider.onValueChanged: {
    applicationFlow.coffeeAmount = coffeeSlider.value
}
</db:programlisting>
<db:para>Clicking on Start button changes the state of ApplicationFlow.qml to &quot;Insert&quot;, and the app displays the Insert.qml.</db:para>
</db:section>
<db:section xml:id="implementing-insert-cup">
<db:title>Implementing insert cup</db:title>
<db:para>On this page the user is instructed to insert their cup on to the machine before the brewing process can start.</db:para>
<db:para>Pressing the Continue button will move app to Progress page.</db:para>
</db:section>
<db:section xml:id="implementing-brewing-coffee">
<db:title>Implementing brewing coffee</db:title>
<db:para>Progress page displays a coffee cup and progress bar that will both in their own way signal the brewing process in real time.</db:para>
<db:para>The coffee cup here once filled will display the exact same configuration as the user selected on Settings page, this is made sure by binding the Cup property variables to the saved corresponding values in ApplicationFlow.qml.</db:para>
<db:para>The animation for filling the coffee cup happens with state engines <db:link xlink:href="qml-qtquick-transition.xml">Transition</db:link> and <db:link xlink:href="qml-qtquick-smoothedanimation.xml">SmoothedAnimation</db:link>.</db:para>
<db:programlisting language="qml">Cup {
    id: cup
    Layout.alignment: Qt.AlignHCenter | Qt.AlignTop
    state: &quot;0&quot;
}
</db:programlisting>
<db:para>The progress bar animation is implemented with <db:link xlink:href="qml-qtquick-behavior.xml">Behavior</db:link>.</db:para>
<db:programlisting language="qml">Behavior on greenBar.width {
    SmoothedAnimation {
        easing.type: Easing.Linear
        velocity: (contentItem.width / brewTime) * 1000
    }
}
</db:programlisting>
<db:para><db:link xlink:href="qml-qtqml-timer.xml">Timer</db:link> will take care of updating the application state once the brewing is done.</db:para>
<db:programlisting language="qml">Timer {
    id: timer
    interval: brewTime
    running: true
    onTriggered: {
        applicationFlow.onFinished()
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="implementing-coffee-ready">
<db:title>Implementing coffee ready</db:title>
<db:para>Ready page displays a coffee cup filled with whatever configuration the user selected with a &quot;Your coffee is ready&quot; text and a check icon.</db:para>
<db:para>When this page is displayed a <db:link xlink:href="qml-qtqml-timer.xml">Timer</db:link> starts running and once the interval set is reached user is directed back to Home.qml.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtdoc.git/tree/examples/demos/coffee?h=6.7">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
