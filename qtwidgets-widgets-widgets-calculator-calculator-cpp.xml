<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Calculator Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The example shows how to use signals and slots to implement the functionality of a calculator widget, and how to use <db:link xlink:href="qgridlayout.xml">QGridLayout</db:link> to place child widgets in a grid.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &amp;lt;QtWidgets&amp;gt;

#include &amp;lt;cmath&amp;gt;

#include &quot;button.h&quot;
#include &quot;calculator.h&quot;

Calculator::Calculator(QWidget *parent)
    : QWidget(parent)
{
    sumInMemory = 0.0;
    sumSoFar = 0.0;
    factorSoFar = 0.0;
    waitingForOperand = true;

    display = new QLineEdit(&quot;0&quot;);
    display-&amp;gt;setReadOnly(true);
    display-&amp;gt;setAlignment(Qt::AlignRight);
    display-&amp;gt;setMaxLength(15);

    QFont font = display-&amp;gt;font();
    font.setPointSize(font.pointSize() + 8);
    display-&amp;gt;setFont(font);

    for (int i = 0; i &amp;lt; NumDigitButtons; ++i) {
        digitButtons[i] = createButton(QString::number(i), SLOT(digitClicked()));
    }

    Button *pointButton = createButton(tr(&quot;.&quot;), SLOT(pointClicked()));
    Button *changeSignButton = createButton(tr(&quot;\302\261&quot;), SLOT(changeSignClicked()));

    Button *backspaceButton = createButton(tr(&quot;Backspace&quot;), SLOT(backspaceClicked()));
    Button *clearButton = createButton(tr(&quot;Clear&quot;), SLOT(clear()));
    Button *clearAllButton = createButton(tr(&quot;Clear All&quot;), SLOT(clearAll()));

    Button *clearMemoryButton = createButton(tr(&quot;MC&quot;), SLOT(clearMemory()));
    Button *readMemoryButton = createButton(tr(&quot;MR&quot;), SLOT(readMemory()));
    Button *setMemoryButton = createButton(tr(&quot;MS&quot;), SLOT(setMemory()));
    Button *addToMemoryButton = createButton(tr(&quot;M+&quot;), SLOT(addToMemory()));

    Button *divisionButton = createButton(tr(&quot;\303\267&quot;), SLOT(multiplicativeOperatorClicked()));
    Button *timesButton = createButton(tr(&quot;\303\227&quot;), SLOT(multiplicativeOperatorClicked()));
    Button *minusButton = createButton(tr(&quot;-&quot;), SLOT(additiveOperatorClicked()));
    Button *plusButton = createButton(tr(&quot;+&quot;), SLOT(additiveOperatorClicked()));

    Button *squareRootButton = createButton(tr(&quot;Sqrt&quot;), SLOT(unaryOperatorClicked()));
    Button *powerButton = createButton(tr(&quot;x\302\262&quot;), SLOT(unaryOperatorClicked()));
    Button *reciprocalButton = createButton(tr(&quot;1/x&quot;), SLOT(unaryOperatorClicked()));
    Button *equalButton = createButton(tr(&quot;=&quot;), SLOT(equalClicked()));

    QGridLayout *mainLayout = new QGridLayout;
    mainLayout-&amp;gt;setSizeConstraint(QLayout::SetFixedSize);
    mainLayout-&amp;gt;addWidget(display, 0, 0, 1, 6);
    mainLayout-&amp;gt;addWidget(backspaceButton, 1, 0, 1, 2);
    mainLayout-&amp;gt;addWidget(clearButton, 1, 2, 1, 2);
    mainLayout-&amp;gt;addWidget(clearAllButton, 1, 4, 1, 2);

    mainLayout-&amp;gt;addWidget(clearMemoryButton, 2, 0);
    mainLayout-&amp;gt;addWidget(readMemoryButton, 3, 0);
    mainLayout-&amp;gt;addWidget(setMemoryButton, 4, 0);
    mainLayout-&amp;gt;addWidget(addToMemoryButton, 5, 0);

    for (int i = 1; i &amp;lt; NumDigitButtons; ++i) {
        int row = ((9 - i) / 3) + 2;
        int column = ((i - 1) % 3) + 1;
        mainLayout-&amp;gt;addWidget(digitButtons[i], row, column);
    }

    mainLayout-&amp;gt;addWidget(digitButtons[0], 5, 1);
    mainLayout-&amp;gt;addWidget(pointButton, 5, 2);
    mainLayout-&amp;gt;addWidget(changeSignButton, 5, 3);

    mainLayout-&amp;gt;addWidget(divisionButton, 2, 4);
    mainLayout-&amp;gt;addWidget(timesButton, 3, 4);
    mainLayout-&amp;gt;addWidget(minusButton, 4, 4);
    mainLayout-&amp;gt;addWidget(plusButton, 5, 4);

    mainLayout-&amp;gt;addWidget(squareRootButton, 2, 5);
    mainLayout-&amp;gt;addWidget(powerButton, 3, 5);
    mainLayout-&amp;gt;addWidget(reciprocalButton, 4, 5);
    mainLayout-&amp;gt;addWidget(equalButton, 5, 5);
    setLayout(mainLayout);

    setWindowTitle(tr(&quot;Calculator&quot;));
}

void Calculator::digitClicked()
{
    Button *clickedButton = qobject_cast&amp;lt;Button *&amp;gt;(sender());
    int digitValue = clickedButton-&amp;gt;text().toInt();
    if (display-&amp;gt;text() == &quot;0&quot; &amp;amp;&amp;amp; digitValue == 0.0)
        return;

    if (waitingForOperand) {
        display-&amp;gt;clear();
        waitingForOperand = false;
    }
    display-&amp;gt;setText(display-&amp;gt;text() + QString::number(digitValue));
}

void Calculator::unaryOperatorClicked()
{
    Button *clickedButton = qobject_cast&amp;lt;Button *&amp;gt;(sender());
    QString clickedOperator = clickedButton-&amp;gt;text();
    double operand = display-&amp;gt;text().toDouble();
    double result = 0.0;

    if (clickedOperator == tr(&quot;Sqrt&quot;)) {
        if (operand &amp;lt; 0.0) {
            abortOperation();
            return;
        }
        result = std::sqrt(operand);
    } else if (clickedOperator == tr(&quot;x\302\262&quot;)) {
        result = std::pow(operand, 2.0);
    } else if (clickedOperator == tr(&quot;1/x&quot;)) {
        if (operand == 0.0) {
            abortOperation();
            return;
        }
        result = 1.0 / operand;
    }
    display-&amp;gt;setText(QString::number(result));
    waitingForOperand = true;
}

void Calculator::additiveOperatorClicked()
{
    Button *clickedButton = qobject_cast&amp;lt;Button *&amp;gt;(sender());
    QString clickedOperator = clickedButton-&amp;gt;text();
    double operand = display-&amp;gt;text().toDouble();

    if (!pendingMultiplicativeOperator.isEmpty()) {
        if (!calculate(operand, pendingMultiplicativeOperator)) {
            abortOperation();
            return;
        }
        display-&amp;gt;setText(QString::number(factorSoFar));
        operand = factorSoFar;
        factorSoFar = 0.0;
        pendingMultiplicativeOperator.clear();
    }

    if (!pendingAdditiveOperator.isEmpty()) {
        if (!calculate(operand, pendingAdditiveOperator)) {
            abortOperation();
            return;
        }
        display-&amp;gt;setText(QString::number(sumSoFar));
    } else {
        sumSoFar = operand;
    }

    pendingAdditiveOperator = clickedOperator;
    waitingForOperand = true;
}

void Calculator::multiplicativeOperatorClicked()
{
    Button *clickedButton = qobject_cast&amp;lt;Button *&amp;gt;(sender());
    QString clickedOperator = clickedButton-&amp;gt;text();
    double operand = display-&amp;gt;text().toDouble();

    if (!pendingMultiplicativeOperator.isEmpty()) {
        if (!calculate(operand, pendingMultiplicativeOperator)) {
            abortOperation();
            return;
        }
        display-&amp;gt;setText(QString::number(factorSoFar));
    } else {
        factorSoFar = operand;
    }

    pendingMultiplicativeOperator = clickedOperator;
    waitingForOperand = true;
}

void Calculator::equalClicked()
{
    double operand = display-&amp;gt;text().toDouble();

    if (!pendingMultiplicativeOperator.isEmpty()) {
        if (!calculate(operand, pendingMultiplicativeOperator)) {
            abortOperation();
            return;
        }
        operand = factorSoFar;
        factorSoFar = 0.0;
        pendingMultiplicativeOperator.clear();
    }
    if (!pendingAdditiveOperator.isEmpty()) {
        if (!calculate(operand, pendingAdditiveOperator)) {
            abortOperation();
            return;
        }
        pendingAdditiveOperator.clear();
    } else {
        sumSoFar = operand;
    }

    display-&amp;gt;setText(QString::number(sumSoFar));
    sumSoFar = 0.0;
    waitingForOperand = true;
}

void Calculator::pointClicked()
{
    if (waitingForOperand)
        display-&amp;gt;setText(&quot;0&quot;);
    if (!display-&amp;gt;text().contains('.'))
        display-&amp;gt;setText(display-&amp;gt;text() + tr(&quot;.&quot;));
    waitingForOperand = false;
}

void Calculator::changeSignClicked()
{
    QString text = display-&amp;gt;text();
    double value = text.toDouble();

    if (value &amp;gt; 0.0) {
        text.prepend(tr(&quot;-&quot;));
    } else if (value &amp;lt; 0.0) {
        text.remove(0, 1);
    }
    display-&amp;gt;setText(text);
}

void Calculator::backspaceClicked()
{
    if (waitingForOperand)
        return;

    QString text = display-&amp;gt;text();
    text.chop(1);
    if (text.isEmpty()) {
        text = &quot;0&quot;;
        waitingForOperand = true;
    }
    display-&amp;gt;setText(text);
}

void Calculator::clear()
{
    if (waitingForOperand)
        return;

    display-&amp;gt;setText(&quot;0&quot;);
    waitingForOperand = true;
}

void Calculator::clearAll()
{
    sumSoFar = 0.0;
    factorSoFar = 0.0;
    pendingAdditiveOperator.clear();
    pendingMultiplicativeOperator.clear();
    display-&amp;gt;setText(&quot;0&quot;);
    waitingForOperand = true;
}

void Calculator::clearMemory()
{
    sumInMemory = 0.0;
}

void Calculator::readMemory()
{
    display-&amp;gt;setText(QString::number(sumInMemory));
    waitingForOperand = true;
}

void Calculator::setMemory()
{
    equalClicked();
    sumInMemory = display-&amp;gt;text().toDouble();
}

void Calculator::addToMemory()
{
    equalClicked();
    sumInMemory += display-&amp;gt;text().toDouble();
}
Button *Calculator::createButton(const QString &amp;amp;text, const char *member)
{
    Button *button = new Button(text);
    connect(button, SIGNAL(clicked()), this, member);
    return button;
}

void Calculator::abortOperation()
{
    clearAll();
    display-&amp;gt;setText(tr(&quot;####&quot;));
}

bool Calculator::calculate(double rightOperand, const QString &amp;amp;pendingOperator)
{
    if (pendingOperator == tr(&quot;+&quot;)) {
        sumSoFar += rightOperand;
    } else if (pendingOperator == tr(&quot;-&quot;)) {
        sumSoFar -= rightOperand;
    } else if (pendingOperator == tr(&quot;\303\227&quot;)) {
        factorSoFar *= rightOperand;
    } else if (pendingOperator == tr(&quot;\303\267&quot;)) {
        if (rightOperand == 0.0)
            return false;
        factorSoFar /= rightOperand;
    }
    return true;
}

</db:programlisting>
</db:article>
