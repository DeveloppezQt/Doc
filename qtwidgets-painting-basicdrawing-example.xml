<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Basic Drawing Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Basic Drawing example shows how to display basic graphics primitives in a variety of styles using the <db:link xlink:href="qpainter.xml">QPainter</db:link> class.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para><db:link xlink:href="qpainter.xml">QPainter</db:link> performs low-level painting on widgets and other paint devices. The class can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a &quot;natural&quot; coordinate system, but it can in addition do view and world transformation.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/basicdrawing-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The example provides a render area, displaying the currently active shape, and lets the user manipulate the rendered shape and its appearance using the <db:link xlink:href="qpainter.xml">QPainter</db:link> parameters: The user can change the active shape (<db:guilabel>Shape</db:guilabel>), and modify the <db:link xlink:href="qpainter.xml">QPainter</db:link>'s pen (<db:guilabel>Pen Width</db:guilabel>, <db:guilabel>Pen Style</db:guilabel>, <db:guilabel>Pen Cap</db:guilabel>, <db:guilabel>Pen Join</db:guilabel>), brush (<db:guilabel>Brush Style</db:guilabel>) and render hints (<db:guilabel>Antialiasing</db:guilabel>). In addition the user can rotate a shape (<db:guilabel>Transformations</db:guilabel>); behind the scenes we use <db:link xlink:href="qpainter.xml">QPainter</db:link>'s ability to manipulate the coordinate system to perform the rotation.</db:para>
<db:para>The Basic Drawing example consists of two classes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>RenderArea is a custom widget that renders multiple copies of the currently active shape.</db:para>
</db:listitem>
<db:listitem>
<db:para>Window is the application's main window displaying a RenderArea widget in addition to several parameter widgets.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>First we will review the Window class, then we will take a look at the RenderArea class.</db:para>
<db:section xml:id="window-class-definition">
<db:title>Window Class Definition</db:title>
<db:para>The Window class inherits <db:link xlink:href="qwidget.xml">QWidget</db:link>, and is the application's main window displaying a RenderArea widget in addition to several parameter widgets.</db:para>
<db:programlisting language="cpp">class Window : public QWidget
{
    Q_OBJECT

public:
    Window();

private slots:
    void shapeChanged();
    void penChanged();
    void brushChanged();

private:
    RenderArea *renderArea;
    QLabel *shapeLabel;
    QLabel *penWidthLabel;
    QLabel *penStyleLabel;
    QLabel *penCapLabel;
    QLabel *penJoinLabel;
    QLabel *brushStyleLabel;
    QLabel *otherOptionsLabel;
    QComboBox *shapeComboBox;
    QSpinBox *penWidthSpinBox;
    QComboBox *penStyleComboBox;
    QComboBox *penCapComboBox;
    QComboBox *penJoinComboBox;
    QComboBox *brushStyleComboBox;
    QCheckBox *antialiasingCheckBox;
    QCheckBox *transformationsCheckBox;
};
</db:programlisting>
<db:para>We declare the various widgets, and three private slots updating the RenderArea widget: The shapeChanged() slot updates the RenderArea widget when the user changes the currently active shape. We call the penChanged() slot when either of the <db:link xlink:href="qpainter.xml">QPainter</db:link>'s pen parameters changes. And the brushChanged() slot updates the RenderArea widget when the user changes the painter's brush style.</db:para>
</db:section>
<db:section xml:id="window-class-implementation">
<db:title>Window Class Implementation</db:title>
<db:para>In the constructor we create and initialize the various widgets appearing in the main application window.</db:para>
<db:programlisting language="cpp">Window::Window()
{
    renderArea = new RenderArea;

    shapeComboBox = new QComboBox;
    shapeComboBox-&amp;gt;addItem(tr(&quot;Polygon&quot;), RenderArea::Polygon);
    shapeComboBox-&amp;gt;addItem(tr(&quot;Rectangle&quot;), RenderArea::Rect);
    shapeComboBox-&amp;gt;addItem(tr(&quot;Rounded Rectangle&quot;), RenderArea::RoundedRect);
    shapeComboBox-&amp;gt;addItem(tr(&quot;Ellipse&quot;), RenderArea::Ellipse);
    shapeComboBox-&amp;gt;addItem(tr(&quot;Pie&quot;), RenderArea::Pie);
    shapeComboBox-&amp;gt;addItem(tr(&quot;Chord&quot;), RenderArea::Chord);
    shapeComboBox-&amp;gt;addItem(tr(&quot;Path&quot;), RenderArea::Path);
    shapeComboBox-&amp;gt;addItem(tr(&quot;Line&quot;), RenderArea::Line);
    shapeComboBox-&amp;gt;addItem(tr(&quot;Polyline&quot;), RenderArea::Polyline);
    shapeComboBox-&amp;gt;addItem(tr(&quot;Arc&quot;), RenderArea::Arc);
    shapeComboBox-&amp;gt;addItem(tr(&quot;Points&quot;), RenderArea::Points);
    shapeComboBox-&amp;gt;addItem(tr(&quot;Text&quot;), RenderArea::Text);
    shapeComboBox-&amp;gt;addItem(tr(&quot;Pixmap&quot;), RenderArea::Pixmap);

    shapeLabel = new QLabel(tr(&quot;&amp;amp;Shape:&quot;));
    shapeLabel-&amp;gt;setBuddy(shapeComboBox);
</db:programlisting>
<db:para>First we create the RenderArea widget that will render the currently active shape. Then we create the <db:guilabel>Shape</db:guilabel> combobox, and add the associated items (i.e. the different shapes a <db:link xlink:href="qpainter.xml">QPainter</db:link> can draw).</db:para>
<db:programlisting language="cpp">    penWidthSpinBox = new QSpinBox;
    penWidthSpinBox-&amp;gt;setRange(0, 20);
    penWidthSpinBox-&amp;gt;setSpecialValueText(tr(&quot;0 (cosmetic pen)&quot;));

    penWidthLabel = new QLabel(tr(&quot;Pen &amp;amp;Width:&quot;));
    penWidthLabel-&amp;gt;setBuddy(penWidthSpinBox);
</db:programlisting>
<db:para><db:link xlink:href="qpainter.xml">QPainter</db:link>'s pen is a <db:link xlink:href="qpen.xml">QPen</db:link> object; the <db:link xlink:href="qpen.xml">QPen</db:link> class defines how a painter should draw lines and outlines of shapes. A pen has several properties: Width, style, cap and join.</db:para>
<db:para>A pen's width can be <db:emphasis>zero</db:emphasis> or greater, but the most common width is zero. Note that this doesn't mean 0 pixels, but implies that the shape is drawn as smoothly as possible although perhaps not mathematically correct.</db:para>
<db:para>We create a <db:link xlink:href="qspinbox.xml">QSpinBox</db:link> for the <db:guilabel>Pen Width</db:guilabel> parameter.</db:para>
<db:programlisting language="cpp">    penStyleComboBox = new QComboBox;
    penStyleComboBox-&amp;gt;addItem(tr(&quot;Solid&quot;), static_cast&amp;lt;int&amp;gt;(Qt::SolidLine));
    penStyleComboBox-&amp;gt;addItem(tr(&quot;Dash&quot;), static_cast&amp;lt;int&amp;gt;(Qt::DashLine));
    penStyleComboBox-&amp;gt;addItem(tr(&quot;Dot&quot;), static_cast&amp;lt;int&amp;gt;(Qt::DotLine));
    penStyleComboBox-&amp;gt;addItem(tr(&quot;Dash Dot&quot;), static_cast&amp;lt;int&amp;gt;(Qt::DashDotLine));
    penStyleComboBox-&amp;gt;addItem(tr(&quot;Dash Dot Dot&quot;), static_cast&amp;lt;int&amp;gt;(Qt::DashDotDotLine));
    penStyleComboBox-&amp;gt;addItem(tr(&quot;None&quot;), static_cast&amp;lt;int&amp;gt;(Qt::NoPen));

    penStyleLabel = new QLabel(tr(&quot;&amp;amp;Pen Style:&quot;));
    penStyleLabel-&amp;gt;setBuddy(penStyleComboBox);

    penCapComboBox = new QComboBox;
    penCapComboBox-&amp;gt;addItem(tr(&quot;Flat&quot;), Qt::FlatCap);
    penCapComboBox-&amp;gt;addItem(tr(&quot;Square&quot;), Qt::SquareCap);
    penCapComboBox-&amp;gt;addItem(tr(&quot;Round&quot;), Qt::RoundCap);

    penCapLabel = new QLabel(tr(&quot;Pen &amp;amp;Cap:&quot;));
    penCapLabel-&amp;gt;setBuddy(penCapComboBox);

    penJoinComboBox = new QComboBox;
    penJoinComboBox-&amp;gt;addItem(tr(&quot;Miter&quot;), Qt::MiterJoin);
    penJoinComboBox-&amp;gt;addItem(tr(&quot;Bevel&quot;), Qt::BevelJoin);
    penJoinComboBox-&amp;gt;addItem(tr(&quot;Round&quot;), Qt::RoundJoin);

    penJoinLabel = new QLabel(tr(&quot;Pen &amp;amp;Join:&quot;));
    penJoinLabel-&amp;gt;setBuddy(penJoinComboBox);
</db:programlisting>
<db:para>The pen style defines the line type. The default style is solid (<db:link xlink:href="qt.xml#PenStyle-enum">Qt::SolidLine</db:link>). Setting the style to none (<db:link xlink:href="qt.xml#PenStyle-enum">Qt::NoPen</db:link>) tells the painter to not draw lines or outlines. The pen cap defines how the end points of lines are drawn. And the pen join defines how two lines join when multiple connected lines are drawn. The cap and join only apply to lines with a width of 1 pixel or greater.</db:para>
<db:para>We create <db:link xlink:href="qcombobox.xml">QComboBox</db:link>es for each of the <db:guilabel>Pen Style</db:guilabel>, <db:guilabel>Pen Cap</db:guilabel> and <db:guilabel>Pen Join</db:guilabel> parameters, and adds the associated items (i.e the values of the <db:link xlink:href="qt.xml#PenStyle-enum">Qt::PenStyle</db:link>, <db:link xlink:href="qt.xml#PenCapStyle-enum">Qt::PenCapStyle</db:link> and <db:link xlink:href="qt.xml#PenJoinStyle-enum">Qt::PenJoinStyle</db:link> enums respectively).</db:para>
<db:programlisting language="cpp">    brushStyleComboBox = new QComboBox;
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Linear Gradient&quot;),
            static_cast&amp;lt;int&amp;gt;(Qt::LinearGradientPattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Radial Gradient&quot;),
            static_cast&amp;lt;int&amp;gt;(Qt::RadialGradientPattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Conical Gradient&quot;),
            static_cast&amp;lt;int&amp;gt;(Qt::ConicalGradientPattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Texture&quot;), static_cast&amp;lt;int&amp;gt;(Qt::TexturePattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Solid&quot;), static_cast&amp;lt;int&amp;gt;(Qt::SolidPattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Horizontal&quot;), static_cast&amp;lt;int&amp;gt;(Qt::HorPattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Vertical&quot;), static_cast&amp;lt;int&amp;gt;(Qt::VerPattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Cross&quot;), static_cast&amp;lt;int&amp;gt;(Qt::CrossPattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Backward Diagonal&quot;), static_cast&amp;lt;int&amp;gt;(Qt::BDiagPattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Forward Diagonal&quot;), static_cast&amp;lt;int&amp;gt;(Qt::FDiagPattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Diagonal Cross&quot;), static_cast&amp;lt;int&amp;gt;(Qt::DiagCrossPattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Dense 1&quot;), static_cast&amp;lt;int&amp;gt;(Qt::Dense1Pattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Dense 2&quot;), static_cast&amp;lt;int&amp;gt;(Qt::Dense2Pattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Dense 3&quot;), static_cast&amp;lt;int&amp;gt;(Qt::Dense3Pattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Dense 4&quot;), static_cast&amp;lt;int&amp;gt;(Qt::Dense4Pattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Dense 5&quot;), static_cast&amp;lt;int&amp;gt;(Qt::Dense5Pattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Dense 6&quot;), static_cast&amp;lt;int&amp;gt;(Qt::Dense6Pattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;Dense 7&quot;), static_cast&amp;lt;int&amp;gt;(Qt::Dense7Pattern));
    brushStyleComboBox-&amp;gt;addItem(tr(&quot;None&quot;), static_cast&amp;lt;int&amp;gt;(Qt::NoBrush));

    brushStyleLabel = new QLabel(tr(&quot;&amp;amp;Brush:&quot;));
    brushStyleLabel-&amp;gt;setBuddy(brushStyleComboBox);
</db:programlisting>
<db:para>The <db:link xlink:href="qbrush.xml">QBrush</db:link> class defines the fill pattern of shapes drawn by a <db:link xlink:href="qpainter.xml">QPainter</db:link>. The default brush style is <db:link xlink:href="qt.xml#BrushStyle-enum">Qt::NoBrush</db:link>. This style tells the painter to not fill shapes. The standard style for filling is <db:link xlink:href="qt.xml#BrushStyle-enum">Qt::SolidPattern</db:link>.</db:para>
<db:para>We create a <db:link xlink:href="qcombobox.xml">QComboBox</db:link> for the <db:guilabel>Brush Style</db:guilabel> parameter, and add the associated items (i.e. the values of the <db:link xlink:href="qt.xml#BrushStyle-enum">Qt::BrushStyle</db:link> enum).</db:para>
<db:programlisting language="cpp">    otherOptionsLabel = new QLabel(tr(&quot;Options:&quot;));
    antialiasingCheckBox = new QCheckBox(tr(&quot;&amp;amp;Antialiasing&quot;));
</db:programlisting>
<db:para>Antialiasing is a feature that &quot;smoothes&quot; the pixels to create more even and less jagged lines, and can be applied using <db:link xlink:href="qpainter.xml">QPainter</db:link>'s render hints. <db:link xlink:href="qpainter.xml#RenderHint-enum">QPainter::RenderHints</db:link> are used to specify flags to <db:link xlink:href="qpainter.xml">QPainter</db:link> that may or may not be respected by any given engine.</db:para>
<db:para>We simply create a <db:link xlink:href="qcheckbox.xml">QCheckBox</db:link> for the <db:guilabel>Antialiasing</db:guilabel> option.</db:para>
<db:programlisting language="cpp">    transformationsCheckBox = new QCheckBox(tr(&quot;&amp;amp;Transformations&quot;));
</db:programlisting>
<db:para>The <db:guilabel>Transformations</db:guilabel> option implies a manipulation of the coordinate system that will appear as if the rendered shape is rotated in three dimensions.</db:para>
<db:para>We use the <db:link xlink:href="qpainter.xml#translate">QPainter::translate</db:link>(), <db:link xlink:href="qpainter.xml#rotate">QPainter::rotate</db:link>() and <db:link xlink:href="qpainter.xml#scale">QPainter::scale</db:link>() functions to implement this feature represented in the main application window by a simple <db:link xlink:href="qcheckbox.xml">QCheckBox</db:link>.</db:para>
<db:programlisting language="cpp">    connect(shapeComboBox, &amp;amp;QComboBox::activated,
            this, &amp;amp;Window::shapeChanged);
    connect(penWidthSpinBox, &amp;amp;QSpinBox::valueChanged,
            this, &amp;amp;Window::penChanged);
    connect(penStyleComboBox, &amp;amp;QComboBox::activated,
            this, &amp;amp;Window::penChanged);
    connect(penCapComboBox, &amp;amp;QComboBox::activated,
            this, &amp;amp;Window::penChanged);
    connect(penJoinComboBox, &amp;amp;QComboBox::activated,
            this, &amp;amp;Window::penChanged);
    connect(brushStyleComboBox, &amp;amp;QComboBox::activated,
            this, &amp;amp;Window::brushChanged);
    connect(antialiasingCheckBox, &amp;amp;QAbstractButton::toggled,
            renderArea, &amp;amp;RenderArea::setAntialiased);
    connect(transformationsCheckBox, &amp;amp;QAbstractButton::toggled,
            renderArea, &amp;amp;RenderArea::setTransformed);
</db:programlisting>
<db:para>Then we connect the parameter widgets with their associated slots using the static <db:link xlink:href="qobject.xml#connect">QObject::connect</db:link>() function, ensuring that the RenderArea widget is updated whenever the user changes the shape, or any of the other parameters.</db:para>
<db:programlisting language="cpp">    QGridLayout *mainLayout = new QGridLayout;
    mainLayout-&amp;gt;setColumnStretch(0, 1);
    mainLayout-&amp;gt;setColumnStretch(3, 1);
    mainLayout-&amp;gt;addWidget(renderArea, 0, 0, 1, 4);
    mainLayout-&amp;gt;addWidget(shapeLabel, 2, 0, Qt::AlignRight);
    mainLayout-&amp;gt;addWidget(shapeComboBox, 2, 1);
    mainLayout-&amp;gt;addWidget(penWidthLabel, 3, 0, Qt::AlignRight);
    mainLayout-&amp;gt;addWidget(penWidthSpinBox, 3, 1);
    mainLayout-&amp;gt;addWidget(penStyleLabel, 4, 0, Qt::AlignRight);
    mainLayout-&amp;gt;addWidget(penStyleComboBox, 4, 1);
    mainLayout-&amp;gt;addWidget(penCapLabel, 3, 2, Qt::AlignRight);
    mainLayout-&amp;gt;addWidget(penCapComboBox, 3, 3);
    mainLayout-&amp;gt;addWidget(penJoinLabel, 2, 2, Qt::AlignRight);
    mainLayout-&amp;gt;addWidget(penJoinComboBox, 2, 3);
    mainLayout-&amp;gt;addWidget(brushStyleLabel, 4, 2, Qt::AlignRight);
    mainLayout-&amp;gt;addWidget(brushStyleComboBox, 4, 3);
    mainLayout-&amp;gt;addWidget(otherOptionsLabel, 5, 0, Qt::AlignRight);
    mainLayout-&amp;gt;addWidget(antialiasingCheckBox, 5, 1, 1, 1, Qt::AlignRight);
    mainLayout-&amp;gt;addWidget(transformationsCheckBox, 5, 2, 1, 2, Qt::AlignRight);
    setLayout(mainLayout);

    shapeChanged();
    penChanged();
    brushChanged();
    antialiasingCheckBox-&amp;gt;setChecked(true);

    setWindowTitle(tr(&quot;Basic Drawing&quot;));
}
</db:programlisting>
<db:para>Finally, we add the various widgets to a layout, and call the shapeChanged(), penChanged(), and brushChanged() slots to initialize the application. We also turn on antialiasing.</db:para>
<db:programlisting language="cpp">void Window::shapeChanged()
{
    RenderArea::Shape shape = RenderArea::Shape(shapeComboBox-&amp;gt;itemData(
            shapeComboBox-&amp;gt;currentIndex(), IdRole).toInt());
    renderArea-&amp;gt;setShape(shape);
}
</db:programlisting>
<db:para>The shapeChanged() slot is called whenever the user changes the currently active shape.</db:para>
<db:para>First we retrieve the shape the user has chosen using the <db:link xlink:href="qcombobox.xml#itemData">QComboBox::itemData</db:link>() function. This function returns the data for the given role in the given index in the combobox. We use <db:link xlink:href="qcombobox.xml#currentIndex-prop">QComboBox::currentIndex</db:link>() to retrieve the index of the shape, and the role is defined by the <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::ItemDataRole</db:link> enum; IdRole is an alias for <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::UserRole</db:link>.</db:para>
<db:para>Note that <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::UserRole</db:link> is only the first role that can be used for application-specific purposes. If you need to store different data in the same index, you can use different roles by simply incrementing the value of <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::UserRole</db:link>, for example: '<db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::UserRole</db:link> + 1' and '<db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::UserRole</db:link> + 2'. However, it is a good programming practice to give each role their own name: 'myFirstRole = <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::UserRole</db:link> + 1' and 'mySecondRole = <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::UserRole</db:link> + 2'. Even though we only need a single role in this particular example, we add the following line of code to the beginning of the window.cpp file.</db:para>
<db:programlisting language="cpp">const int IdRole = Qt::UserRole;
</db:programlisting>
<db:para>The <db:link xlink:href="qcombobox.xml#itemData">QComboBox::itemData</db:link>() function returns the data as a <db:link xlink:href="qvariant.xml">QVariant</db:link>, so we need to cast the data to RenderArea::Shape. If there is no data for the given role, the function returns QVariant::Invalid.</db:para>
<db:para>In the end we call the RenderArea::setShape() slot to update the RenderArea widget.</db:para>
<db:programlisting language="cpp">void Window::penChanged()
{
    int width = penWidthSpinBox-&amp;gt;value();
    Qt::PenStyle style = Qt::PenStyle(penStyleComboBox-&amp;gt;itemData(
            penStyleComboBox-&amp;gt;currentIndex(), IdRole).toInt());
    Qt::PenCapStyle cap = Qt::PenCapStyle(penCapComboBox-&amp;gt;itemData(
            penCapComboBox-&amp;gt;currentIndex(), IdRole).toInt());
    Qt::PenJoinStyle join = Qt::PenJoinStyle(penJoinComboBox-&amp;gt;itemData(
            penJoinComboBox-&amp;gt;currentIndex(), IdRole).toInt());

    renderArea-&amp;gt;setPen(QPen(Qt::blue, width, style, cap, join));
}
</db:programlisting>
<db:para>We call the penChanged() slot whenever the user changes any of the pen parameters. Again we use the <db:link xlink:href="qcombobox.xml#itemData">QComboBox::itemData</db:link>() function to retrieve the parameters, and then we call the RenderArea::setPen() slot to update the RenderArea widget.</db:para>
<db:programlisting language="cpp">void Window::brushChanged()
{
    Qt::BrushStyle style = Qt::BrushStyle(brushStyleComboBox-&amp;gt;itemData(
</db:programlisting>
<db:para>The brushChanged() slot is called whenever the user changes the brush parameter which we retrieve using the <db:link xlink:href="qcombobox.xml#itemData">QComboBox::itemData</db:link>() function as before.</db:para>
<db:programlisting language="cpp">    if (style == Qt::LinearGradientPattern) {
        QLinearGradient linearGradient(0, 0, 100, 100);
        linearGradient.setColorAt(0.0, Qt::white);
        linearGradient.setColorAt(0.2, Qt::green);
        linearGradient.setColorAt(1.0, Qt::black);
        renderArea-&amp;gt;setBrush(linearGradient);
</db:programlisting>
<db:para>If the brush parameter is a gradient fill, special actions are required.</db:para>
<db:para>The <db:link xlink:href="qgradient.xml">QGradient</db:link> class is used in combination with <db:link xlink:href="qbrush.xml">QBrush</db:link> to specify gradient fills. Qt currently supports three types of gradient fills: linear, radial and conical. Each of these is represented by a subclass of <db:link xlink:href="qgradient.xml">QGradient</db:link>: <db:link xlink:href="qlineargradient.xml">QLinearGradient</db:link>, <db:link xlink:href="qradialgradient.xml">QRadialGradient</db:link> and <db:link xlink:href="qconicalgradient.xml">QConicalGradient</db:link>.</db:para>
<db:para>So if the brush style is <db:link xlink:href="qt.xml#BrushStyle-enum">Qt::LinearGradientPattern</db:link>, we first create a <db:link xlink:href="qlineargradient.xml">QLinearGradient</db:link> object with interpolation area between the coordinates passed as arguments to the constructor. The positions are specified using logical coordinates. Then we set the gradient's colors using the <db:link xlink:href="qgradient.xml#setColorAt">QGradient::setColorAt</db:link>() function. The colors is defined using stop points which are composed by a position (between 0 and 1) and a <db:link xlink:href="qcolor.xml">QColor</db:link>. The set of stop points describes how the gradient area should be filled. A gradient can have an arbitrary number of stop points.</db:para>
<db:para>In the end we call RenderArea::setBrush() slot to update the RenderArea widget's brush with the <db:link xlink:href="qlineargradient.xml">QLinearGradient</db:link> object.</db:para>
<db:programlisting language="cpp">    } else if (style == Qt::RadialGradientPattern) {
        QRadialGradient radialGradient(50, 50, 50, 70, 70);
        radialGradient.setColorAt(0.0, Qt::white);
        radialGradient.setColorAt(0.2, Qt::green);
        radialGradient.setColorAt(1.0, Qt::black);
        renderArea-&amp;gt;setBrush(radialGradient);
    } else if (style == Qt::ConicalGradientPattern) {
        QConicalGradient conicalGradient(50, 50, 150);
        conicalGradient.setColorAt(0.0, Qt::white);
        conicalGradient.setColorAt(0.2, Qt::green);
        conicalGradient.setColorAt(1.0, Qt::black);
        renderArea-&amp;gt;setBrush(conicalGradient);
</db:programlisting>
<db:para>A similar pattern of actions, as the one used for <db:link xlink:href="qlineargradient.xml">QLinearGradient</db:link>, is used in the cases of <db:link xlink:href="qt.xml#BrushStyle-enum">Qt::RadialGradientPattern</db:link> and <db:link xlink:href="qt.xml#BrushStyle-enum">Qt::ConicalGradientPattern</db:link>.</db:para>
<db:para>The only difference is the arguments passed to the constructor: Regarding the <db:link xlink:href="qradialgradient.xml">QRadialGradient</db:link> constructor the first argument is the center, and the second the radial gradient's radius. The third argument is optional, but can be used to define the focal point of the gradient inside the circle (the default focal point is the circle center). Regarding the <db:link xlink:href="qconicalgradient.xml">QConicalGradient</db:link> constructor, the first argument specifies the center of the conical, and the second specifies the start angle of the interpolation.</db:para>
<db:programlisting language="cpp">    } else if (style == Qt::TexturePattern) {
        renderArea-&amp;gt;setBrush(QBrush(QPixmap(&quot;:/images/brick.png&quot;)));
</db:programlisting>
<db:para>If the brush style is <db:link xlink:href="qt.xml#BrushStyle-enum">Qt::TexturePattern</db:link> we create a <db:link xlink:href="qbrush.xml">QBrush</db:link> from a <db:link xlink:href="qpixmap.xml">QPixmap</db:link>. Then we call RenderArea::setBrush() slot to update the RenderArea widget with the newly created brush.</db:para>
<db:programlisting language="cpp">    } else {
        renderArea-&amp;gt;setBrush(QBrush(Qt::green, style));
    }
}
</db:programlisting>
<db:para>Otherwise we simply create a brush with the given style and a green color, and then call RenderArea::setBrush() slot to update the RenderArea widget with the newly created brush.</db:para>
</db:section>
<db:section xml:id="renderarea-class-definition">
<db:title>RenderArea Class Definition</db:title>
<db:para>The RenderArea class inherits <db:link xlink:href="qwidget.xml">QWidget</db:link>, and renders multiple copies of the currently active shape using a <db:link xlink:href="qpainter.xml">QPainter</db:link>.</db:para>
<db:programlisting language="cpp">class RenderArea : public QWidget
{
    Q_OBJECT

public:
    enum Shape { Line, Points, Polyline, Polygon, Rect, RoundedRect, Ellipse, Arc,
                 Chord, Pie, Path, Text, Pixmap };

    explicit RenderArea(QWidget *parent = nullptr);

    QSize minimumSizeHint() const override;
    QSize sizeHint() const override;

public slots:
    void setShape(Shape shape);
    void setPen(const QPen &amp;amp;pen);
    void setBrush(const QBrush &amp;amp;brush);
    void setAntialiased(bool antialiased);
    void setTransformed(bool transformed);

protected:
    void paintEvent(QPaintEvent *event) override;

private:
    Shape shape;
    QPen pen;
    QBrush brush;
    bool antialiased;
    bool transformed;
    QPixmap pixmap;
};
</db:programlisting>
<db:para>First we define a public Shape enum to hold the different shapes that can be rendered by the widget (i.e the shapes that can be rendered by a <db:link xlink:href="qpainter.xml">QPainter</db:link>). Then we reimplement the constructor as well as two of <db:link xlink:href="qwidget.xml">QWidget</db:link>'s public functions: <db:link xlink:href="qwidget.xml#minimumSizeHint-prop">minimumSizeHint</db:link>() and <db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link>().</db:para>
<db:para>We also reimplement the <db:link xlink:href="qwidget.xml#paintEvent">QWidget::paintEvent</db:link>() function to be able to draw the currently active shape according to the specified parameters.</db:para>
<db:para>We declare several private slots: The setShape() slot changes the RenderArea's shape, the setPen() and setBrush() slots modify the widget's pen and brush, and the setAntialiased() and setTransformed() slots modify the widget's respective properties.</db:para>
</db:section>
<db:section xml:id="renderarea-class-implementation">
<db:title>RenderArea Class Implementation</db:title>
<db:para>In the constructor we initialize some of the widget's variables.</db:para>
<db:programlisting language="cpp">RenderArea::RenderArea(QWidget *parent)
    : QWidget(parent)
{
    shape = Polygon;
    antialiased = false;
    transformed = false;
    pixmap.load(&quot;:/images/qt-logo.png&quot;);

    setBackgroundRole(QPalette::Base);
    setAutoFillBackground(true);
}
</db:programlisting>
<db:para>We set its shape to be a <db:guilabel>Polygon</db:guilabel>, its antialiased property to be false and we load an image into the widget's pixmap variable. In the end we set the widget's background role, defining the brush from the widget's <db:link xlink:href="qwidget.xml#palette-prop">palette</db:link> that will be used to render the background. <db:link xlink:href="qpalette.xml#ColorRole-enum">QPalette::Base</db:link> is typically white.</db:para>
<db:programlisting language="cpp">QSize RenderArea::sizeHint() const
{
    return QSize(400, 200);
}
</db:programlisting>
<db:para>The RenderArea inherits <db:link xlink:href="qwidget.xml">QWidget</db:link>'s <db:link xlink:href="qwidget.xml#sizeHint-prop">sizeHint</db:link> property holding the recommended size for the widget. If the value of this property is an invalid size, no size is recommended.</db:para>
<db:para>The default implementation of the <db:link xlink:href="qwidget.xml#sizeHint-prop">QWidget::sizeHint</db:link>() function returns an invalid size if there is no layout for the widget, and returns the layout's preferred size otherwise.</db:para>
<db:para>Our reimplementation of the function returns a <db:link xlink:href="qsize.xml">QSize</db:link> with a 400 pixels width and a 200 pixels height.</db:para>
<db:programlisting language="cpp">QSize RenderArea::minimumSizeHint() const
{
    return QSize(100, 100);
}
</db:programlisting>
<db:para>RenderArea also inherits <db:link xlink:href="qwidget.xml">QWidget</db:link>'s <db:link xlink:href="qwidget.xml#minimumSizeHint-prop">minimumSizeHint</db:link> property holding the recommended minimum size for the widget. Again, if the value of this property is an invalid size, no size is recommended.</db:para>
<db:para>The default implementation of <db:link xlink:href="qwidget.xml#minimumSizeHint-prop">QWidget::minimumSizeHint</db:link>() returns an invalid size if there is no layout for the widget, and returns the layout's minimum size otherwise.</db:para>
<db:para>Our reimplementation of the function returns a <db:link xlink:href="qsize.xml">QSize</db:link> with a 100 pixels width and a 100 pixels height.</db:para>
<db:programlisting language="cpp">void RenderArea::setShape(Shape shape)
{
    this-&amp;gt;shape = shape;
    update();
}

void RenderArea::setPen(const QPen &amp;amp;pen)
{
    this-&amp;gt;pen = pen;
    update();
}

void RenderArea::setBrush(const QBrush &amp;amp;brush)
{
    this-&amp;gt;brush = brush;
    update();
}
</db:programlisting>
<db:para>The public setShape(), setPen() and setBrush() slots are called whenever we want to modify a RenderArea widget's shape, pen or brush. We set the shape, pen or brush according to the slot parameter, and call <db:link xlink:href="qwidget.xml#update">QWidget::update</db:link>() to make the changes visible in the RenderArea widget.</db:para>
<db:para>The <db:link xlink:href="qwidget.xml#update">QWidget::update</db:link>() slot does not cause an immediate repaint; instead it schedules a paint event for processing when Qt returns to the main event loop.</db:para>
<db:programlisting language="cpp">void RenderArea::setAntialiased(bool antialiased)
{
    this-&amp;gt;antialiased = antialiased;
    update();
}

void RenderArea::setTransformed(bool transformed)
{
    this-&amp;gt;transformed = transformed;
    update();
}
</db:programlisting>
<db:para>With the setAntialiased() and setTransformed() slots we change the state of the properties according to the slot parameter, and call the <db:link xlink:href="qwidget.xml#update">QWidget::update</db:link>() slot to make the changes visible in the RenderArea widget.</db:para>
<db:programlisting language="cpp">void RenderArea::paintEvent(QPaintEvent * /* event */)
{
    static const QPoint points[4] = {
        QPoint(10, 80),
        QPoint(20, 10),
        QPoint(80, 30),
        QPoint(90, 70)
    };

    QRect rect(10, 20, 80, 60);

    QPainterPath path;
    path.moveTo(20, 80);
    path.lineTo(20, 30);
    path.cubicTo(80, 0, 50, 50, 80, 80);

    int startAngle = 20 * 16;
    int arcLength = 120 * 16;
</db:programlisting>
<db:para>Then we reimplement the <db:link xlink:href="qwidget.xml#paintEvent">QWidget::paintEvent</db:link>() function. The first thing we do is to create the graphical objects we will need to draw the various shapes.</db:para>
<db:para>We create a vector of four <db:link xlink:href="qpoint.xml">QPoint</db:link>s. We use this vector to render the <db:guilabel>Points</db:guilabel>, <db:guilabel>Polyline</db:guilabel> and <db:guilabel>Polygon</db:guilabel> shapes. Then we create a <db:link xlink:href="qrect.xml">QRect</db:link>, defining a rectangle in the plane, which we use as the bounding rectangle for all the shapes excluding the <db:guilabel>Path</db:guilabel> and the <db:guilabel>Pixmap</db:guilabel>.</db:para>
<db:para>We also create a <db:link xlink:href="qpainterpath.xml">QPainterPath</db:link>. The <db:link xlink:href="qpainterpath.xml">QPainterPath</db:link> class provides a container for painting operations, enabling graphical shapes to be constructed and reused. A painter path is an object composed of a number of graphical building blocks, such as rectangles, ellipses, lines, and curves. For more information about the <db:link xlink:href="qpainterpath.xml">QPainterPath</db:link> class, see the <db:link xlink:href="qtwidgets-painting-painterpaths-example.xml">Painter Paths</db:link> example. In this example, we create a painter path composed of one straight line and a Bezier curve.</db:para>
<db:para>In addition we define a start angle and an arc length that we will use when drawing the <db:guilabel>Arc</db:guilabel>, <db:guilabel>Chord</db:guilabel> and <db:guilabel>Pie</db:guilabel> shapes.</db:para>
<db:programlisting language="cpp">    QPainter painter(this);
    painter.setPen(pen);
    painter.setBrush(brush);
    if (antialiased)
        painter.setRenderHint(QPainter::Antialiasing, true);
</db:programlisting>
<db:para>We create a <db:link xlink:href="qpainter.xml">QPainter</db:link> for the RenderArea widget, and set the painters pen and brush according to the RenderArea's pen and brush. If the <db:guilabel>Antialiasing</db:guilabel> parameter option is checked, we also set the painter's render hints. <db:link xlink:href="qpainter.xml#RenderHint-enum">QPainter::Antialiasing</db:link> indicates that the engine should antialias edges of primitives if possible.</db:para>
<db:programlisting language="cpp">    for (int x = 0; x &amp;lt; width(); x += 100) {
        for (int y = 0; y &amp;lt; height(); y += 100) {
            painter.save();
            painter.translate(x, y);
</db:programlisting>
<db:para>Finally, we render the multiple copies of the RenderArea's shape. The number of copies is depending on the size of the RenderArea widget, and we calculate their positions using two for loops and the widgets height and width.</db:para>
<db:para>For each copy we first save the current painter state (pushes the state onto a stack). Then we translate the coordinate system, using the <db:link xlink:href="qpainter.xml#translate">QPainter::translate</db:link>() function, to the position determined by the variables of the for loops. If we omit this translation of the coordinate system all the copies of the shape will be rendered on top of each other in the top left cormer of the RenderArea widget.</db:para>
<db:programlisting language="cpp">            if (transformed) {
                painter.translate(50, 50);
                painter.rotate(60.0);
                painter.scale(0.6, 0.9);
                painter.translate(-50, -50);
            }
</db:programlisting>
<db:para>If the <db:guilabel>Transformations</db:guilabel> parameter option is checked, we do an additional translation of the coordinate system before we rotate the coordinate system 60 degrees clockwise using the <db:link xlink:href="qpainter.xml#rotate">QPainter::rotate</db:link>() function and scale it down in size using the <db:link xlink:href="qpainter.xml#scale">QPainter::scale</db:link>() function. In the end we translate the coordinate system back to where it was before we rotated and scaled it.</db:para>
<db:para>Now, when rendering the shape, it will appear as if it was rotated in three dimensions.</db:para>
<db:programlisting language="cpp">            switch (shape) {
            case Line:
                painter.drawLine(rect.bottomLeft(), rect.topRight());
                break;
            case Points:
                painter.drawPoints(points, 4);
                break;
            case Polyline:
                painter.drawPolyline(points, 4);
                break;
            case Polygon:
                painter.drawPolygon(points, 4);
                break;
            case Rect:
                painter.drawRect(rect);
                break;
            case RoundedRect:
                painter.drawRoundedRect(rect, 25, 25, Qt::RelativeSize);
                break;
            case Ellipse:
                painter.drawEllipse(rect);
                break;
            case Arc:
                painter.drawArc(rect, startAngle, arcLength);
                break;
            case Chord:
                painter.drawChord(rect, startAngle, arcLength);
                break;
            case Pie:
                painter.drawPie(rect, startAngle, arcLength);
                break;
            case Path:
                painter.drawPath(path);
                break;
            case Text:
                painter.drawText(rect,
                                 Qt::AlignCenter,
                                 tr(&quot;Qt by\nThe Qt Company&quot;));
                break;
            case Pixmap:
                painter.drawPixmap(10, 10, pixmap);
            }
</db:programlisting>
<db:para>Next, we identify the RenderArea's shape, and render it using the associated <db:link xlink:href="qpainter.xml">QPainter</db:link> drawing function:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawLine">QPainter::drawLine</db:link>(),</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawPoints">QPainter::drawPoints</db:link>(),</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawPolyline">QPainter::drawPolyline</db:link>(),</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawPolygon">QPainter::drawPolygon</db:link>(),</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawRect">QPainter::drawRect</db:link>(),</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawRoundedRect">QPainter::drawRoundedRect</db:link>(),</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawEllipse">QPainter::drawEllipse</db:link>(),</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawArc">QPainter::drawArc</db:link>(),</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawChord">QPainter::drawChord</db:link>(),</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawPie">QPainter::drawPie</db:link>(),</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawPath">QPainter::drawPath</db:link>(),</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawText">QPainter::drawText</db:link>() or</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpainter.xml#drawPixmap">QPainter::drawPixmap</db:link>()</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Before we started rendering, we saved the current painter state (pushes the state onto a stack). The rationale for this is that we calculate each shape copy's position relative to the same point in the coordinate system. When translating the coordinate system, we lose the knowledge of this point unless we save the current painter state <db:emphasis>before</db:emphasis> we start the translating process.</db:para>
<db:programlisting language="cpp">            painter.restore();
        }
    }

    painter.setRenderHint(QPainter::Antialiasing, false);
    painter.setPen(palette().dark().color());
    painter.setBrush(Qt::NoBrush);
    painter.drawRect(QRect(0, 0, width() - 1, height() - 1));
}
</db:programlisting>
<db:para>Then, when we are finished rendering a copy of the shape we can restore the original painter state, with its associated coordinate system, using the <db:link xlink:href="qpainter.xml#restore">QPainter::restore</db:link>() function. In this way we ensure that the next shape copy will be rendered in the correct position.</db:para>
<db:para>We could translate the coordinate system back using <db:link xlink:href="qpainter.xml#translate">QPainter::translate</db:link>() instead of saving the painter state. But since we in addition to translating the coordinate system (when the <db:guilabel>Transformation</db:guilabel> parameter option is checked) both rotate and scale the coordinate system, the easiest solution is to save the current painter state.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/painting/basicdrawing?h=6.7">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
