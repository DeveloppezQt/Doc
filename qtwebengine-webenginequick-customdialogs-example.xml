<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>WebEngine Qt Quick Custom Dialogs Example</db:title>
<db:productname>QtWebEngine</db:productname>
<db:edition>Qt 6.4.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt WebEngine Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Customizes UI elements of Qt WebEngine's dialogs.</db:para>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customdialogs.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>A web page might request dialogs for various purposes, such as authentication, picking colors, choosing files, and responding to JavaScript alerts, confirmation requests, and prompts.</db:para>
<db:para><db:emphasis>Custom Dialogs</db:emphasis> demonstrates how to use <db:link xlink:href="qml-qtwebengine-webengine.xml">WebEngine</db:link> dialog request objects to implement custom dialogs for use instead of the default dialogs.</db:para>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:guilabel>Welcome</db:guilabel> mode and select the example from <db:guilabel>Examples</db:guilabel>. For more information, visit <db:link xlink:href="https://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="ui-elements-of-webengineview">
<db:title>UI Elements of WebEngineView</db:title>
<db:para>In this example, we create a simple <db:code>index.html</db:code> page that contains buttons and text fields for triggering a context menu and the following dialogs:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>HTTP Authentication Dialog</db:para>
</db:listitem>
<db:listitem>
<db:para>Proxy Authentication Dialog</db:para>
</db:listitem>
<db:listitem>
<db:para>JavaScript Alert, Confirm, and Prompt Dialogs</db:para>
</db:listitem>
<db:listitem>
<db:para>Color Picker Dialog</db:para>
</db:listitem>
<db:listitem>
<db:para>File Picker Dialog</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="triggering-dialogs">
<db:title>Triggering Dialogs</db:title>
<db:para>As mentioned, the <db:code>index.html</db:code> file is responsible for triggering the dialogs from the side of HTML and JavaScript. Additionally, the example program starts a localhost TCP server returning the mocked HTTP responses needed to trigger proxy and HTTP authentication dialogs.</db:para>
</db:section>
<db:section xml:id="custom-dialogs">
<db:title>Custom Dialogs</db:title>
<db:para>The custom dialogs are just <db:emphasis>Qt Quick Designer UI Forms</db:emphasis> without any business logic. The point here is to present the glue code that is required to display the custom dialog for a particular web engine dialog or a menu request.</db:para>
</db:section>
<db:section xml:id="creating-the-main-window">
<db:title>Creating the Main Window</db:title>
<db:para>In <db:code>main.cpp</db:code>, we initialize the <db:link xlink:href="qml-qtwebengine-webengine.xml">WebEngine</db:link> the same way as in the <db:link xlink:href="qtwebengine-webenginequick-minimal-example.xml">WebEngine Qt Quick Minimal Example</db:link>:</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QCoreApplication::setOrganizationName(&quot;QtExamples&quot;);
    QtWebEngineQuick::initialize();

    QGuiApplication app(argc, argv);

    QQmlApplicationEngine engine;
    Server *server = new Server(&amp;amp;engine);

    engine.load(QUrl(QStringLiteral(&quot;qrc:/main.qml&quot;)));
    QTimer::singleShot(0, server, &amp;amp;Server::run);

    QNetworkProxy proxy;
    proxy.setType(QNetworkProxy::HttpProxy);
    proxy.setHostName(&quot;localhost&quot;);
    proxy.setPort(5555);
    QNetworkProxy::setApplicationProxy(proxy);

    return app.exec();
}
</db:programlisting>
<db:para>In addition, we set up a proxy and a TCP server to be able to simulate proxy and HTTP authetication requests.</db:para>
<db:para>In <db:code>main.qml</db:code>, we create a top level window, which contains a <db:link xlink:href="qml-qtquick-controls2-stackview.xml">StackView</db:link> with a SwitchButton and a <db:link xlink:href="qml-qtwebview-webview.xml">WebView</db:link>:</db:para>
<db:programlisting language="cpp">import QtQuick.Window

Window {
    id: mainWindow
    width: 800
    height: 610
    visible: true

    StackView {
        id: stackView
        anchors.fill: parent
        focus: true
        initialItem: Item {
            id: main
            width: mainWindow.width
            height: mainWindow.height
            ColumnLayout {
                anchors.fill: parent
                SwitchButton {
                    id: switcher
                    Layout.fillWidth: true
                }
                WebView {
                    id: webView
                    useDefaultDialogs: switcher.checked
                    Layout.fillWidth: true
                    Layout.fillHeight: true
                }
            }
        }

        function closeForm()
        {
            pop(main);
            // reset url in case of proxy error
            webView.url = &quot;qrc:/index.html&quot;
        }

        function openForm(form)
        {
            push(form.item, form.properties);
            currentItem.closeForm.connect(closeForm);
        }

    }

    Component.onCompleted: {
        webView.openForm.connect(stackView.openForm);
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="handling-web-engine-requests">
<db:title>Handling Web Engine Requests</db:title>
<db:para>In this example, we implement the handling of the following web engine requests:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qml-qtwebengine-contextmenurequest.xml">ContextMenuRequest</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtwebengine-authenticationdialogrequest.xml">AuthenticationDialogRequest</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtwebengine-javascriptdialogrequest.xml">JavaScriptDialogRequest</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtwebengine-colordialogrequest.xml">ColorDialogRequest</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtwebengine-filedialogrequest.xml">FileDialogRequest</db:link></db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="context-menu-requests">
<db:title>Context Menu Requests</db:title>
<db:para><db:link xlink:href="qml-qtwebengine-contextmenurequest.xml">ContextMenuRequest</db:link> is a request object that is passed as a parameter of the <db:link xlink:href="qml-qtwebengine-webengineview.xml#contextMenuRequested-signal">WebEngineView::contextMenuRequested</db:link> signal. We use the <db:code>onContextMenuRequested</db:code> signal handler to handle requests for <db:code>#openMenu</db:code> URL links:</db:para>
<db:programlisting language="cpp">WebEngineView {
    ...
    onContextMenuRequested: function(request) {
        // we only show menu for links with #openMenu
        if (!request.linkUrl.toString().endsWith(&quot;#openMenu&quot;)) {
            request.accepted = true;
            return;
        }
        // return early to show default menu
        if (useDefaultDialogs)
            return;

        request.accepted = true;
        openForm({item: Qt.resolvedUrl(&quot;forms/Menu.qml&quot;),
                     properties: {&quot;request&quot;: request}});
    }
    ...
                     properties: {&quot;request&quot;: request}});
</db:programlisting>
<db:para>The first text field from the top on our page triggers the request. Next, we check whether we should use the default menu. If not, we accept the request and switch the view to show the <db:code>MenuForm</db:code>:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customdialogs-menu.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">MenuForm {
    property QtObject request
    signal closeForm()

    followLink.onClicked: closeForm()
    back.onClicked: closeForm()
    forward.onClicked: closeForm()
    reload.onClicked: closeForm()
    copyLinkUrl.onClicked: closeForm()
    saveLink.onClicked: closeForm()
    close.onClicked: closeForm()

    Component.onCompleted: {
        back.btnEnable = false;
        forward.btnEnable = false;
    }
}
</db:programlisting>
<db:para>To keep things simple, we do not provide any logic on component completion, and we simply close the form on any action.</db:para>
</db:section>
<db:section xml:id="tooltip-requests">
<db:title>Tooltip Requests</db:title>
<db:para><db:link xlink:href="qml-qtwebengine-tooltiprequest.xml">TooltipRequest</db:link> is a request object that is passed as a parameter of the <db:link xlink:href="qml-qtwebengine-webengineview.xml#tooltipRequested-signal">WebEngineView::tooltipRequested</db:link> signal. We use the <db:code>onTooltipRequested</db:code> signal handler to handle requests for custom tooltip menus at specific positions:</db:para>
<db:programlisting language="cpp">WebEngineView {
    ...
    onTooltipRequested: function(request) {
        if (useDefaultDialogs)
            return;

        if (request.type == TooltipRequest.Show) {
            tooltip.visible = true;
            tooltip.x = request.x;
            tooltip.y = request.y;
            tooltip.text = request.text;
        } else {
            tooltip.visible = false;
        }

        request.accepted = true;
    }
    ...
                     properties: {&quot;request&quot;: request}});
</db:programlisting>
<db:para>The second text field from the top on our page triggers the request. Next, we check whether we should use the default menu. If not, we accept the request and show a custom QML element as tooltip:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customdialogs-tooltip.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">    Rectangle {
        id: tooltip
        width: 200
        height: 30
        z: 50
        visible: false
        color: &quot;gray&quot;
        border.color: &quot;black&quot;
        border.width: 2
        radius: 3

        property string text: &quot;&quot;

        Text {
            x: 0
            y: 0
            color: &quot;#ffffff&quot;
            text: parent.text
            font.pointSize: 12
            anchors.horizontalCenter: parent.horizontalCenter
            anchors.verticalCenter: parent.verticalCenter
            font.bold: false
        }
</db:programlisting>
</db:section>
<db:section xml:id="authentication-dialog-requests">
<db:title>Authentication Dialog Requests</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customdialogs-auth1.png"/>
</db:imageobject>
</db:mediaobject>
<db:para><db:link xlink:href="qml-qtwebengine-authenticationdialogrequest.xml">AuthenticationDialogRequest</db:link> is a request object that is passed as a parameter of the <db:link xlink:href="qml-qtwebengine-webengineview.xml#authenticationDialogRequested-signal">WebEngineView::authenticationDialogRequested</db:link> signal:</db:para>
<db:programlisting language="cpp">WebEngineView {
    ...
    onAuthenticationDialogRequested: function(request) {
        if (useDefaultDialogs) {
            // do not show proxy error page
            view.url = &quot;qrc:/index.html&quot;
            return;
        }
        request.accepted = true;
        openForm({item: Qt.resolvedUrl(&quot;forms/Authentication.qml&quot;),
                     properties: {&quot;request&quot;: request}});
    ...
                     properties: {&quot;request&quot;: request}});
</db:programlisting>
<db:para>We use the <db:code>onAuthenticationDialogRequested</db:code> signal handler to check whether we should use the default authentication dialog. If not, we accept the request and switch the view to show the <db:code>AuthenticationForm</db:code>:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customdialogs-auth2.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">AuthenticationForm {
    property QtObject request
    signal closeForm()

    cancelButton.onClicked: {
        request.dialogReject();
        closeForm();
    }

    loginButton.onClicked: {
        request.dialogReject();
        closeForm();
    }

    Component.onCompleted: {
        switch (request.type) {
        case  AuthenticationDialogRequest.AuthenticationTypeHTTP:
            console.log(&quot;HTTP Authentication Required. Host says: &quot; + request.realm);
            break;
        case  AuthenticationDialogRequest.AuthenticationTypeProxy:
            console.log(&quot;Proxy Authentication Required for: &quot; + request.proxyHost);
            break;
        }
    }
}
</db:programlisting>
<db:para>On component completion, we log the request type. The user can fill in the credentials and click <db:guilabel>Login</db:guilabel>. We provide <db:code>onClicked</db:code> handlers to accept or reject the authentication dialog. The TCP server on localhost does not handle real authentication, and therefore we call <db:code>rejectDialog()</db:code> instead of <db:code>acceptDialog()</db:code> also for the login button <db:code>clicked</db:code> signal.</db:para>
</db:section>
<db:section xml:id="javascript-dialog-requests">
<db:title>JavaScript Dialog Requests</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customdialogs-prompt1.png"/>
</db:imageobject>
</db:mediaobject>
<db:para><db:link xlink:href="qml-qtwebengine-javascriptdialogrequest.xml">JavaScriptDialogRequest</db:link> is a request object that is passed as a parameter of the <db:link xlink:href="qml-qtwebengine-webengineview.xml#javaScriptDialogRequested-signal">WebEngineView::javaScriptDialogRequested</db:link> signal:</db:para>
<db:programlisting language="cpp">WebEngineView {
    ...
    onJavaScriptDialogRequested: function(request) {
        if (useDefaultDialogs)
            return;

        request.accepted = true;
        openForm({item: Qt.resolvedUrl(&quot;forms/JavaScript.qml&quot;),
                     properties: {&quot;request&quot;: request}});
    }
    ...
                     properties: {&quot;request&quot;: request}});
</db:programlisting>
<db:para>We use the <db:code>onJavaScriptDialogRequested</db:code> signal handler to check whether we should use the default JavaScript dialog. If not, we accept the request and switch the view to show the <db:code>JavaScriptForm</db:code>:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customdialogs-prompt2.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">JavaScriptForm {
    property QtObject request
    signal closeForm()

    cancelButton.onClicked: {
        request.dialogReject();
        closeForm();
    }

    okButton.onClicked: {
        request.dialogAccept(prompt.text);
        closeForm();
    }

    Component.onCompleted: {
        switch (request.type) {
        case JavaScriptDialogRequest.DialogTypeAlert:
            cancelButton.visible = false;
            title = qsTr(&quot;Alert&quot;);
            message = request.message;
            prompt.text = &quot;&quot;;
            prompt.visible = false;
            break;
        case JavaScriptDialogRequest.DialogTypeConfirm:
            title = qsTr(&quot;Confirm&quot;);
            message = request.message;
            prompt.text = &quot;&quot;;
            prompt.visible = false;
            break;
        case JavaScriptDialogRequest.DialogTypePrompt:
            title = qsTr(&quot;Prompt&quot;);
            message = request.message;
            prompt.text = request.defaultText;
            prompt.visible = true;
            break;
        }
    }
}
</db:programlisting>
<db:para>On component completion, we customize the form based on the request type. For a JavaScript prompt dialog we use <db:code>dialogAccept()</db:code> with the <db:code>prompt.text</db:code> argument.</db:para>
</db:section>
<db:section xml:id="color-dialog-requests">
<db:title>Color Dialog Requests</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customdialogs-color1.png"/>
</db:imageobject>
</db:mediaobject>
<db:para><db:link xlink:href="qml-qtwebengine-colordialogrequest.xml">ColorDialogRequest</db:link> is a request object that is passed as a parameter of the <db:link xlink:href="qml-qtwebengine-webengineview.xml#colorDialogRequested-signal">WebEngineView::colorDialogRequested</db:link> signal:</db:para>
<db:programlisting language="cpp">WebEngineView {
    ...
    onColorDialogRequested: function(request) {
        if (useDefaultDialogs)
            return;

        request.accepted = true;
        openForm({item: Qt.resolvedUrl(&quot;forms/ColorPicker.qml&quot;),
                     properties: {&quot;request&quot;: request}});
    }
    ...
                     properties: {&quot;request&quot;: request}});
</db:programlisting>
<db:para>We use the <db:code>onColorDialogRequested</db:code> signal handler to check whether we should use the default color picker dialog. If not, we accept the request and switch the view to show the <db:code>ColorPickerForm</db:code>:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customdialogs-color2.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">ColorPickerForm {
    property QtObject request
    signal closeForm()

    okButton.onClicked: {
        request.dialogAccept(colorPicker.color);
        closeForm();
    }

    cancelButton.onClicked: {
        request.dialogReject();
        closeForm();
    }

    function createCallback(color) {
        return function() { colorPicker.color = color };
    }

    Component.onCompleted:{
        for (var i = 0; i &amp;lt; grid.children.length; i++) {
            var cell = grid.children[i];
            cell.clicked.connect(createCallback(cell.color));
        }
        colorPicker.color = request.color;
    }
}
</db:programlisting>
<db:para>On component completion, we create callbacks for all the color cells. When the user selects the color and clicks <db:code>OK</db:code>, we pass the selected color to the <db:code>dialogAccept()</db:code> method.</db:para>
</db:section>
<db:section xml:id="file-dialog-requests">
<db:title>File Dialog Requests</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customdialogs-file1.png"/>
</db:imageobject>
</db:mediaobject>
<db:para><db:link xlink:href="qml-qtwebengine-filedialogrequest.xml">FileDialogRequest</db:link> is a request object that is passed as a parameter of the <db:link xlink:href="qml-qtwebengine-webengineview.xml#fileDialogRequested-signal">WebEngineView::fileDialogRequested</db:link> signal:</db:para>
<db:programlisting language="cpp">WebEngineView {
    ...
    onFileDialogRequested: function(request) {
        if (useDefaultDialogs)
            return;

        request.accepted = true;
        openForm({item: Qt.resolvedUrl(&quot;forms/FilePicker.qml&quot;),
                     properties: {&quot;request&quot;: request}});

    }

    onTouchSelectionMenuRequested: function(request) {
        if (useDefaultDialogs)
            return;

        request.accepted = true;
        openForm({item: Qt.resolvedUrl(&quot;forms/TouchSelectionMenu.qml&quot;),
                     properties: {&quot;request&quot;: request}});
</db:programlisting>
<db:para>We use the <db:code>onFileDialogRequested</db:code> signal handler to check whether we should use the default file picker dialog. If not, we accept the request and switch the view to show the <db:code>FilePickerForm</db:code>:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/customdialogs-file2.png"/>
</db:imageobject>
</db:mediaobject>
<db:programlisting language="cpp">FilePickerForm {
    property QtObject request
    property string selectedFile
    signal closeForm()

    cancelButton.onClicked: {
        request.dialogReject();
        closeForm();
    }

    okButton.onClicked: {
        request.dialogAccept('/' + selectedFile);
        closeForm();
    }

    function createCallback(fileIndex) {
        return function() {
            for (var i = 0; i &amp;lt; files.children.length; i++) {
                var file = files.children[i];
                if (i === fileIndex) {
                    selectedFile = file.text;
                    file.selected = true;
                } else {
                    file.selected = false;
                }
            }
        }
    }

    Component.onCompleted: {
        selectedFile = request.defaultFileName;
        for (var i = 0; i &amp;lt; files.children.length; i++) {
            var file = files.children[i];
            file.clicked.connect(createCallback(i));
            if (file.text === selectedFile)
                file.selected = true;
        }
    }
</db:programlisting>
<db:para>On component completion, we create callbacks for selecting files. When the user selects a file and clicks <db:code>OK</db:code>, we pass the selected file to the <db:code>dialogAccept</db:code> method.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtwebengine.git/tree/examples/webenginequick/customdialogs?h=6.4">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
