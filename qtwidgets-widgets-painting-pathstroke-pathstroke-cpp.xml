<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Path Stroking</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Path Stroking example shows various types of pens that can be used with <db:link xlink:href="qpainter.xml">QPainter</db:link>.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the demonstration applications of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;arthurstyle.h&quot;
#include &quot;arthurwidgets.h&quot;
#include &quot;pathstroke.h&quot;

#include &amp;lt;stdio.h&amp;gt;

extern void draw_round_rect(QPainter *p, const QRect &amp;amp;bounds, int radius);

PathStrokeControls::PathStrokeControls(QWidget* parent, PathStrokeRenderer* renderer, bool smallScreen)
      : QWidget(parent)
{
    m_renderer = renderer;

    if (smallScreen)
        layoutForSmallScreens();
    else
        layoutForDesktop();
}

void PathStrokeControls::createCommonControls(QWidget* parent)
{
    m_capGroup = new QGroupBox(parent);
    m_capGroup-&amp;gt;setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Fixed);
    QRadioButton *flatCap = new QRadioButton(m_capGroup);
    QRadioButton *squareCap = new QRadioButton(m_capGroup);
    QRadioButton *roundCap = new QRadioButton(m_capGroup);
    m_capGroup-&amp;gt;setTitle(tr(&quot;Cap Style&quot;));
    flatCap-&amp;gt;setText(tr(&quot;Flat&quot;));
    squareCap-&amp;gt;setText(tr(&quot;Square&quot;));
    roundCap-&amp;gt;setText(tr(&quot;Round&quot;));
    flatCap-&amp;gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    squareCap-&amp;gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    roundCap-&amp;gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);

    m_joinGroup = new QGroupBox(parent);
    m_joinGroup-&amp;gt;setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Fixed);
    QRadioButton *bevelJoin = new QRadioButton(m_joinGroup);
    QRadioButton *miterJoin = new QRadioButton(m_joinGroup);
    QRadioButton *svgMiterJoin = new QRadioButton(m_joinGroup);
    QRadioButton *roundJoin = new QRadioButton(m_joinGroup);
    m_joinGroup-&amp;gt;setTitle(tr(&quot;Join Style&quot;));
    bevelJoin-&amp;gt;setText(tr(&quot;Bevel&quot;));
    miterJoin-&amp;gt;setText(tr(&quot;Miter&quot;));
    svgMiterJoin-&amp;gt;setText(tr(&quot;SvgMiter&quot;));
    roundJoin-&amp;gt;setText(tr(&quot;Round&quot;));

    m_styleGroup = new QGroupBox(parent);
    m_styleGroup-&amp;gt;setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Fixed);
    QRadioButton *solidLine = new QRadioButton(m_styleGroup);
    QRadioButton *dashLine = new QRadioButton(m_styleGroup);
    QRadioButton *dotLine = new QRadioButton(m_styleGroup);
    QRadioButton *dashDotLine = new QRadioButton(m_styleGroup);
    QRadioButton *dashDotDotLine = new QRadioButton(m_styleGroup);
    QRadioButton *customDashLine = new QRadioButton(m_styleGroup);
    m_styleGroup-&amp;gt;setTitle(tr(&quot;Pen Style&quot;));

    QPixmap line_solid(&quot;:res/images/line_solid.png&quot;);
    solidLine-&amp;gt;setIcon(line_solid);
    solidLine-&amp;gt;setIconSize(line_solid.size());
    QPixmap line_dashed(&quot;:res/images/line_dashed.png&quot;);
    dashLine-&amp;gt;setIcon(line_dashed);
    dashLine-&amp;gt;setIconSize(line_dashed.size());
    QPixmap line_dotted(&quot;:res/images/line_dotted.png&quot;);
    dotLine-&amp;gt;setIcon(line_dotted);
    dotLine-&amp;gt;setIconSize(line_dotted.size());
    QPixmap line_dash_dot(&quot;:res/images/line_dash_dot.png&quot;);
    dashDotLine-&amp;gt;setIcon(line_dash_dot);
    dashDotLine-&amp;gt;setIconSize(line_dash_dot.size());
    QPixmap line_dash_dot_dot(&quot;:res/images/line_dash_dot_dot.png&quot;);
    dashDotDotLine-&amp;gt;setIcon(line_dash_dot_dot);
    dashDotDotLine-&amp;gt;setIconSize(line_dash_dot_dot.size());
    customDashLine-&amp;gt;setText(tr(&quot;Custom&quot;));

    int fixedHeight = bevelJoin-&amp;gt;sizeHint().height();
    solidLine-&amp;gt;setFixedHeight(fixedHeight);
    dashLine-&amp;gt;setFixedHeight(fixedHeight);
    dotLine-&amp;gt;setFixedHeight(fixedHeight);
    dashDotLine-&amp;gt;setFixedHeight(fixedHeight);
    dashDotDotLine-&amp;gt;setFixedHeight(fixedHeight);

    m_pathModeGroup = new QGroupBox(parent);
    m_pathModeGroup-&amp;gt;setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Fixed);
    QRadioButton *curveMode = new QRadioButton(m_pathModeGroup);
    QRadioButton *lineMode = new QRadioButton(m_pathModeGroup);
    m_pathModeGroup-&amp;gt;setTitle(tr(&quot;Line Style&quot;));
    curveMode-&amp;gt;setText(tr(&quot;Curves&quot;));
    lineMode-&amp;gt;setText(tr(&quot;Lines&quot;));

    // Layouts
    QVBoxLayout *capGroupLayout = new QVBoxLayout(m_capGroup);
    capGroupLayout-&amp;gt;addWidget(flatCap);
    capGroupLayout-&amp;gt;addWidget(squareCap);
    capGroupLayout-&amp;gt;addWidget(roundCap);

    QVBoxLayout *joinGroupLayout = new QVBoxLayout(m_joinGroup);
    joinGroupLayout-&amp;gt;addWidget(bevelJoin);
    joinGroupLayout-&amp;gt;addWidget(miterJoin);
    joinGroupLayout-&amp;gt;addWidget(svgMiterJoin);
    joinGroupLayout-&amp;gt;addWidget(roundJoin);

    QVBoxLayout *styleGroupLayout = new QVBoxLayout(m_styleGroup);
    styleGroupLayout-&amp;gt;addWidget(solidLine);
    styleGroupLayout-&amp;gt;addWidget(dashLine);
    styleGroupLayout-&amp;gt;addWidget(dotLine);
    styleGroupLayout-&amp;gt;addWidget(dashDotLine);
    styleGroupLayout-&amp;gt;addWidget(dashDotDotLine);
    styleGroupLayout-&amp;gt;addWidget(customDashLine);

    QVBoxLayout *pathModeGroupLayout = new QVBoxLayout(m_pathModeGroup);
    pathModeGroupLayout-&amp;gt;addWidget(curveMode);
    pathModeGroupLayout-&amp;gt;addWidget(lineMode);

    // Connections
    connect(flatCap, SIGNAL(clicked()), m_renderer, SLOT(setFlatCap()));
    connect(squareCap, SIGNAL(clicked()), m_renderer, SLOT(setSquareCap()));
    connect(roundCap, SIGNAL(clicked()), m_renderer, SLOT(setRoundCap()));

    connect(bevelJoin, SIGNAL(clicked()), m_renderer, SLOT(setBevelJoin()));
    connect(miterJoin, SIGNAL(clicked()), m_renderer, SLOT(setMiterJoin()));
    connect(svgMiterJoin, SIGNAL(clicked()), m_renderer, SLOT(setSvgMiterJoin()));
    connect(roundJoin, SIGNAL(clicked()), m_renderer, SLOT(setRoundJoin()));

    connect(curveMode, SIGNAL(clicked()), m_renderer, SLOT(setCurveMode()));
    connect(lineMode, SIGNAL(clicked()), m_renderer, SLOT(setLineMode()));

    connect(solidLine, SIGNAL(clicked()), m_renderer, SLOT(setSolidLine()));
    connect(dashLine, SIGNAL(clicked()), m_renderer, SLOT(setDashLine()));
    connect(dotLine, SIGNAL(clicked()), m_renderer, SLOT(setDotLine()));
    connect(dashDotLine, SIGNAL(clicked()), m_renderer, SLOT(setDashDotLine()));
    connect(dashDotDotLine, SIGNAL(clicked()), m_renderer, SLOT(setDashDotDotLine()));
    connect(customDashLine, SIGNAL(clicked()), m_renderer, SLOT(setCustomDashLine()));

    // Set the defaults:
    flatCap-&amp;gt;setChecked(true);
    bevelJoin-&amp;gt;setChecked(true);
    curveMode-&amp;gt;setChecked(true);
    solidLine-&amp;gt;setChecked(true);
}

void PathStrokeControls::layoutForDesktop()
{
    QGroupBox *mainGroup = new QGroupBox(this);
    mainGroup-&amp;gt;setFixedWidth(180);
    mainGroup-&amp;gt;setTitle(tr(&quot;Path Stroking&quot;));

    createCommonControls(mainGroup);

    QGroupBox* penWidthGroup = new QGroupBox(mainGroup);
    QSlider *penWidth = new QSlider(Qt::Horizontal, penWidthGroup);
    penWidth-&amp;gt;setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
    penWidthGroup-&amp;gt;setTitle(tr(&quot;Pen Width&quot;));
    penWidth-&amp;gt;setRange(0, 500);

    QPushButton *animated = new QPushButton(mainGroup);
    animated-&amp;gt;setText(tr(&quot;Animate&quot;));
    animated-&amp;gt;setCheckable(true);

    QPushButton *showSourceButton = new QPushButton(mainGroup);
    showSourceButton-&amp;gt;setText(tr(&quot;Show Source&quot;));
#if QT_CONFIG(opengl)
    QPushButton *enableOpenGLButton = new QPushButton(mainGroup);
    enableOpenGLButton-&amp;gt;setText(tr(&quot;Use OpenGL&quot;));
    enableOpenGLButton-&amp;gt;setCheckable(true);
    enableOpenGLButton-&amp;gt;setChecked(m_renderer-&amp;gt;usesOpenGL());
#endif
    QPushButton *whatsThisButton = new QPushButton(mainGroup);
    whatsThisButton-&amp;gt;setText(tr(&quot;What's This?&quot;));
    whatsThisButton-&amp;gt;setCheckable(true);

    // Layouts:
    QVBoxLayout *penWidthLayout = new QVBoxLayout(penWidthGroup);
    penWidthLayout-&amp;gt;addWidget(penWidth);

    QVBoxLayout * mainLayout = new QVBoxLayout(this);
    mainLayout-&amp;gt;setMargin(0);
    mainLayout-&amp;gt;addWidget(mainGroup);

    QVBoxLayout *mainGroupLayout = new QVBoxLayout(mainGroup);
    mainGroupLayout-&amp;gt;setMargin(3);
    mainGroupLayout-&amp;gt;addWidget(m_capGroup);
    mainGroupLayout-&amp;gt;addWidget(m_joinGroup);
    mainGroupLayout-&amp;gt;addWidget(m_styleGroup);
    mainGroupLayout-&amp;gt;addWidget(penWidthGroup);
    mainGroupLayout-&amp;gt;addWidget(m_pathModeGroup);
    mainGroupLayout-&amp;gt;addWidget(animated);
    mainGroupLayout-&amp;gt;addStretch(1);
    mainGroupLayout-&amp;gt;addWidget(showSourceButton);
#if QT_CONFIG(opengl)
    mainGroupLayout-&amp;gt;addWidget(enableOpenGLButton);
#endif
    mainGroupLayout-&amp;gt;addWidget(whatsThisButton);

    // Set up connections
    connect(animated, SIGNAL(toggled(bool)), m_renderer, SLOT(setAnimation(bool)));

    connect(penWidth, SIGNAL(valueChanged(int)), m_renderer, SLOT(setPenWidth(int)));

    connect(showSourceButton, SIGNAL(clicked()), m_renderer, SLOT(showSource()));
#if QT_CONFIG(opengl)
    connect(enableOpenGLButton, SIGNAL(clicked(bool)), m_renderer, SLOT(enableOpenGL(bool)));
#endif
    connect(whatsThisButton, SIGNAL(clicked(bool)), m_renderer, SLOT(setDescriptionEnabled(bool)));
    connect(m_renderer, SIGNAL(descriptionEnabledChanged(bool)),
            whatsThisButton, SLOT(setChecked(bool)));

    // Set the defaults
    animated-&amp;gt;setChecked(true);
    penWidth-&amp;gt;setValue(50);

}

void PathStrokeControls::layoutForSmallScreens()
{
    createCommonControls(this);

    m_capGroup-&amp;gt;layout()-&amp;gt;setMargin(0);
    m_joinGroup-&amp;gt;layout()-&amp;gt;setMargin(0);
    m_styleGroup-&amp;gt;layout()-&amp;gt;setMargin(0);
    m_pathModeGroup-&amp;gt;layout()-&amp;gt;setMargin(0);

    QPushButton* okBtn = new QPushButton(tr(&quot;OK&quot;), this);
    okBtn-&amp;gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    okBtn-&amp;gt;setMinimumSize(100,okBtn-&amp;gt;minimumSize().height());

    QPushButton* quitBtn = new QPushButton(tr(&quot;Quit&quot;), this);
    quitBtn-&amp;gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    quitBtn-&amp;gt;setMinimumSize(100, okBtn-&amp;gt;minimumSize().height());

    QLabel *penWidthLabel = new QLabel(tr(&quot; Width:&quot;));
    QSlider *penWidth = new QSlider(Qt::Horizontal, this);
    penWidth-&amp;gt;setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
    penWidth-&amp;gt;setRange(0, 500);

#if QT_CONFIG(opengl)
    QPushButton *enableOpenGLButton = new QPushButton(this);
    enableOpenGLButton-&amp;gt;setText(tr(&quot;Use OpenGL&quot;));
    enableOpenGLButton-&amp;gt;setCheckable(true);
    enableOpenGLButton-&amp;gt;setChecked(m_renderer-&amp;gt;usesOpenGL());
#endif

    // Layouts:
    QHBoxLayout *penWidthLayout = new QHBoxLayout(0);
    penWidthLayout-&amp;gt;addWidget(penWidthLabel, 0, Qt::AlignRight);
    penWidthLayout-&amp;gt;addWidget(penWidth);

    QVBoxLayout *leftLayout = new QVBoxLayout(0);
    leftLayout-&amp;gt;addWidget(m_capGroup);
    leftLayout-&amp;gt;addWidget(m_joinGroup);
#if QT_CONFIG(opengl)
    leftLayout-&amp;gt;addWidget(enableOpenGLButton);
#endif
    leftLayout-&amp;gt;addLayout(penWidthLayout);

    QVBoxLayout *rightLayout = new QVBoxLayout(0);
    rightLayout-&amp;gt;addWidget(m_styleGroup);
    rightLayout-&amp;gt;addWidget(m_pathModeGroup);

    QGridLayout *mainLayout = new QGridLayout(this);
    mainLayout-&amp;gt;setMargin(0);

    // Add spacers around the form items so we don't look stupid at higher resolutions
    mainLayout-&amp;gt;addItem(new QSpacerItem(0,0), 0, 0, 1, 4);
    mainLayout-&amp;gt;addItem(new QSpacerItem(0,0), 1, 0, 2, 1);
    mainLayout-&amp;gt;addItem(new QSpacerItem(0,0), 1, 3, 2, 1);
    mainLayout-&amp;gt;addItem(new QSpacerItem(0,0), 3, 0, 1, 4);

    mainLayout-&amp;gt;addLayout(leftLayout, 1, 1);
    mainLayout-&amp;gt;addLayout(rightLayout, 1, 2);
    mainLayout-&amp;gt;addWidget(quitBtn, 2, 1, Qt::AlignHCenter | Qt::AlignTop);
    mainLayout-&amp;gt;addWidget(okBtn, 2, 2, Qt::AlignHCenter | Qt::AlignTop);

#if QT_CONFIG(opengl)
    connect(enableOpenGLButton, SIGNAL(clicked(bool)), m_renderer, SLOT(enableOpenGL(bool)));
#endif

    connect(penWidth, SIGNAL(valueChanged(int)), m_renderer, SLOT(setPenWidth(int)));
    connect(quitBtn, SIGNAL(clicked()), this, SLOT(emitQuitSignal()));
    connect(okBtn, SIGNAL(clicked()), this, SLOT(emitOkSignal()));

    m_renderer-&amp;gt;setAnimation(true);
    penWidth-&amp;gt;setValue(50);
}

void PathStrokeControls::emitQuitSignal()
{
    emit quitPressed();
}

void PathStrokeControls::emitOkSignal()
{
    emit okPressed();
}

PathStrokeWidget::PathStrokeWidget(bool smallScreen)
{
    setWindowTitle(tr(&quot;Path Stroking&quot;));

    // Widget construction and property setting
    m_renderer = new PathStrokeRenderer(this, smallScreen);

    m_controls = new PathStrokeControls(0, m_renderer, smallScreen);

    // Layouting
    QHBoxLayout *viewLayout = new QHBoxLayout(this);
    viewLayout-&amp;gt;addWidget(m_renderer);

    if (!smallScreen)
        viewLayout-&amp;gt;addWidget(m_controls);

    m_renderer-&amp;gt;loadSourceFile(&quot;:res/pathstroke/pathstroke.cpp&quot;);
    m_renderer-&amp;gt;loadDescription(&quot;:res/pathstroke/pathstroke.html&quot;);

    connect(m_renderer, SIGNAL(clicked()), this, SLOT(showControls()));
    connect(m_controls, SIGNAL(okPressed()), this, SLOT(hideControls()));
    connect(m_controls, SIGNAL(quitPressed()), QApplication::instance(), SLOT(quit()));
}

void PathStrokeWidget::showControls()
{
    m_controls-&amp;gt;showFullScreen();
}

void PathStrokeWidget::hideControls()
{
    m_controls-&amp;gt;hide();
}

void PathStrokeWidget::setStyle( QStyle * style )
{
    QWidget::setStyle(style);
    if (m_controls != 0)
    {
        m_controls-&amp;gt;setStyle(style);

        QList&amp;lt;QWidget *&amp;gt; widgets = m_controls-&amp;gt;findChildren&amp;lt;QWidget *&amp;gt;();
        foreach (QWidget *w, widgets)
            w-&amp;gt;setStyle(style);
    }
}

PathStrokeRenderer::PathStrokeRenderer(QWidget *parent, bool smallScreen)
    : ArthurFrame(parent)
{
    m_smallScreen = smallScreen;
    m_pointSize = 10;
    m_activePoint = -1;
    m_capStyle = Qt::FlatCap;
    m_joinStyle = Qt::BevelJoin;
    m_pathMode = CurveMode;
    m_penWidth = 1;
    m_penStyle = Qt::SolidLine;
    m_wasAnimated = true;
    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    setAttribute(Qt::WA_AcceptTouchEvents);
}

void PathStrokeRenderer::paint(QPainter *painter)
{
    if (m_points.isEmpty())
        initializePoints();

    painter-&amp;gt;setRenderHint(QPainter::Antialiasing);

    QPalette pal = palette();
    painter-&amp;gt;setPen(Qt::NoPen);

    // Construct the path
    QPainterPath path;
    path.moveTo(m_points.at(0));

    if (m_pathMode == LineMode) {
        for (int i=1; i&amp;lt;m_points.size(); ++i)
            path.lineTo(m_points.at(i));
    } else {
        int i=1;
        while (i + 2 &amp;lt; m_points.size()) {
            path.cubicTo(m_points.at(i), m_points.at(i+1), m_points.at(i+2));
            i += 3;
        }
        while (i &amp;lt; m_points.size()) {
            path.lineTo(m_points.at(i));
            ++i;
        }
    }

    // Draw the path
    {
        QColor lg = Qt::red;

        // The &quot;custom&quot; pen
        if (m_penStyle == Qt::NoPen) {
            QPainterPathStroker stroker;
            stroker.setWidth(m_penWidth);
            stroker.setJoinStyle(m_joinStyle);
            stroker.setCapStyle(m_capStyle);

            QVector&amp;lt;qreal&amp;gt; dashes;
            qreal space = 4;
            dashes &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; space
                   &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; space
                   &amp;lt;&amp;lt; 9 &amp;lt;&amp;lt; space
                   &amp;lt;&amp;lt; 27 &amp;lt;&amp;lt; space
                   &amp;lt;&amp;lt; 9 &amp;lt;&amp;lt; space
                   &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; space;
            stroker.setDashPattern(dashes);
            QPainterPath stroke = stroker.createStroke(path);
            painter-&amp;gt;fillPath(stroke, lg);

        } else {
            QPen pen(lg, m_penWidth, m_penStyle, m_capStyle, m_joinStyle);
            painter-&amp;gt;strokePath(path, pen);
        }
    }

    if (1) {
        // Draw the control points
        painter-&amp;gt;setPen(QColor(50, 100, 120, 200));
        painter-&amp;gt;setBrush(QColor(200, 200, 210, 120));
        for (int i=0; i&amp;lt;m_points.size(); ++i) {
            QPointF pos = m_points.at(i);
            painter-&amp;gt;drawEllipse(QRectF(pos.x() - m_pointSize,
                                       pos.y() - m_pointSize,
                                       m_pointSize*2, m_pointSize*2));
        }
        painter-&amp;gt;setPen(QPen(Qt::lightGray, 0, Qt::SolidLine));
        painter-&amp;gt;setBrush(Qt::NoBrush);
        painter-&amp;gt;drawPolyline(m_points);
    }

}

void PathStrokeRenderer::initializePoints()
{
    const int count = 7;
    m_points.clear();
    m_vectors.clear();

    QMatrix m;
    qreal rot = 360.0 / count;
    QPointF center(width() / 2, height() / 2);
    QMatrix vm;
    vm.shear(2, -1);
    vm.scale(3, 3);

    for (int i=0; i&amp;lt;count; ++i) {
        m_vectors &amp;lt;&amp;lt; QPointF(.1f, .25f) * (m * vm);
        m_points &amp;lt;&amp;lt; QPointF(0, 100) * m + center;
        m.rotate(rot);
    }
}

void PathStrokeRenderer::updatePoints()
{
    qreal pad = 10;
    qreal left = pad;
    qreal right = width() - pad;
    qreal top = pad;
    qreal bottom = height() - pad;

    Q_ASSERT(m_points.size() == m_vectors.size());
    for (int i=0; i&amp;lt;m_points.size(); ++i) {
        QPointF pos = m_points.at(i);
        QPointF vec = m_vectors.at(i);
        pos += vec;
        if (pos.x() &amp;lt; left || pos.x() &amp;gt; right) {
            vec.setX(-vec.x());
            pos.setX(pos.x() &amp;lt; left ? left : right);
        } if (pos.y() &amp;lt; top || pos.y() &amp;gt; bottom) {
            vec.setY(-vec.y());
            pos.setY(pos.y() &amp;lt; top ? top : bottom);
        }
        m_points[i] = pos;
        m_vectors[i] = vec;
    }
    update();
}

void PathStrokeRenderer::mousePressEvent(QMouseEvent *e)
{
    if (!m_fingerPointMapping.isEmpty())
        return;
    setDescriptionEnabled(false);
    m_activePoint = -1;
    qreal distance = -1;
    for (int i=0; i&amp;lt;m_points.size(); ++i) {
        qreal d = QLineF(e-&amp;gt;pos(), m_points.at(i)).length();
        if ((distance &amp;lt; 0 &amp;amp;&amp;amp; d &amp;lt; 8 * m_pointSize) || d &amp;lt; distance) {
            distance = d;
            m_activePoint = i;
        }
    }

    if (m_activePoint != -1) {
        m_wasAnimated = m_timer.isActive();
        setAnimation(false);
        mouseMoveEvent(e);
    }

    // If we're not running in small screen mode, always assume we're dragging
    m_mouseDrag = !m_smallScreen;
    m_mousePress = e-&amp;gt;pos();
}

void PathStrokeRenderer::mouseMoveEvent(QMouseEvent *e)
{
    if (!m_fingerPointMapping.isEmpty())
        return;
    // If we've moved more then 25 pixels, assume user is dragging
    if (!m_mouseDrag &amp;amp;&amp;amp; QPoint(m_mousePress - e-&amp;gt;pos()).manhattanLength() &amp;gt; 25)
        m_mouseDrag = true;

    if (m_mouseDrag &amp;amp;&amp;amp; m_activePoint &amp;gt;= 0 &amp;amp;&amp;amp; m_activePoint &amp;lt; m_points.size()) {
        m_points[m_activePoint] = e-&amp;gt;pos();
        update();
    }
}

void PathStrokeRenderer::mouseReleaseEvent(QMouseEvent *)
{
    if (!m_fingerPointMapping.isEmpty())
        return;
    m_activePoint = -1;
    setAnimation(m_wasAnimated);

    if (!m_mouseDrag &amp;amp;&amp;amp; m_smallScreen)
        emit clicked();
}

void PathStrokeRenderer::timerEvent(QTimerEvent *e)
{
    if (e-&amp;gt;timerId() == m_timer.timerId()) {
        updatePoints();
    } // else if (e-&amp;gt;timerId() == m_fpsTimer.timerId()) {
//         emit frameRate(m_frameCount);
//         m_frameCount = 0;
//     }
}

bool PathStrokeRenderer::event(QEvent *e)
{
    bool touchBegin = false;
    switch (e-&amp;gt;type()) {
    case QEvent::TouchBegin:
        touchBegin = true;
        Q_FALLTHROUGH();
    case QEvent::TouchUpdate:
    {
        const QTouchEvent *const event = static_cast&amp;lt;const QTouchEvent*&amp;gt;(e);
        const QList&amp;lt;QTouchEvent::TouchPoint&amp;gt; points = event-&amp;gt;touchPoints();
        foreach (const QTouchEvent::TouchPoint &amp;amp;touchPoint, points) {
            const int id = touchPoint.id();
            switch (touchPoint.state()) {
            case Qt::TouchPointPressed:
            {
                // find the point, move it
                QSet&amp;lt;int&amp;gt; activePoints = QSet&amp;lt;int&amp;gt;::fromList(m_fingerPointMapping.values());
                int activePoint = -1;
                qreal distance = -1;
                const int pointsCount = m_points.size();
                for (int i=0; i&amp;lt;pointsCount; ++i) {
                    if (activePoints.contains(i))
                        continue;

                    qreal d = QLineF(touchPoint.pos(), m_points.at(i)).length();
                    if ((distance &amp;lt; 0 &amp;amp;&amp;amp; d &amp;lt; 12 * m_pointSize) || d &amp;lt; distance) {
                        distance = d;
                        activePoint = i;
                    }
                }
                if (activePoint != -1) {
                    m_fingerPointMapping.insert(touchPoint.id(), activePoint);
                    m_points[activePoint] = touchPoint.pos();
                }
                break;
            }
            case Qt::TouchPointReleased:
            {
                // move the point and release
                QHash&amp;lt;int,int&amp;gt;::iterator it = m_fingerPointMapping.find(id);
                m_points[it.value()] = touchPoint.pos();
                m_fingerPointMapping.erase(it);
                break;
            }
            case Qt::TouchPointMoved:
            {
                // move the point
                const int pointIdx = m_fingerPointMapping.value(id, -1);
                if (pointIdx &amp;gt;= 0)
                    m_points[pointIdx] = touchPoint.pos();
                break;
            }
            default:
                break;
            }
        }
        if (m_fingerPointMapping.isEmpty()) {
            e-&amp;gt;ignore();
            return false;
        } else {
            if (touchBegin) {
                m_wasAnimated = m_timer.isActive();
                setAnimation(false);
            }
            update();
            return true;
        }
    }
        break;
    case QEvent::TouchEnd:
        if (m_fingerPointMapping.isEmpty()) {
            e-&amp;gt;ignore();
            return false;
        }
        m_fingerPointMapping.clear();
        setAnimation(m_wasAnimated);
        return true;
        break;
    default:
        break;
    }
    return QWidget::event(e);
}

void PathStrokeRenderer::setAnimation(bool animation)
{
    m_timer.stop();
//     m_fpsTimer.stop();

    if (animation) {
        m_timer.start(25, this);
//         m_fpsTimer.start(1000, this);
//         m_frameCount = 0;
    }
}

</db:programlisting>
</db:article>
