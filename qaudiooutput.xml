<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QAudioOutput Class</db:title>
<db:productname>QtMultimedia</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Multimedia Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qaudiooutput.xml">QAudioOutput</db:link> class provides an interface for sending audio data to an audio output device.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QAudioOutput</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += multimedia</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QAudioOutput is part of <db:simplelist><db:member>multimedia</db:member><db:member>multimedia_audio</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>You can construct an audio output with the system's <db:link xlink:href="qaudiodeviceinfo.xml#defaultOutputDevice">default audio output device</db:link>. It is also possible to create <db:link xlink:href="qaudiooutput.xml">QAudioOutput</db:link> with a specific <db:link xlink:href="qaudiodeviceinfo.xml">QAudioDeviceInfo</db:link>. When you create the audio output, you should also send in the <db:link xlink:href="qaudioformat.xml">QAudioFormat</db:link> to be used for the playback (see the <db:link xlink:href="qaudioformat.xml">QAudioFormat</db:link> class description for details).</db:para>
<db:para>To play a file:</db:para>
<db:para>Starting to play an audio stream is simply a matter of calling <db:link xlink:href="qaudiooutput.xml#start">start</db:link>() with a <db:link xlink:href="qiodevice.xml">QIODevice</db:link>. <db:link xlink:href="qaudiooutput.xml">QAudioOutput</db:link> will then fetch the data it needs from the io device. So playing back an audio file is as simple as:</db:para>
<db:programlisting language="cpp">QFile sourceFile;   // class member.
QAudioOutput* audio; // class member.
{
    sourceFile.setFileName(&quot;/tmp/test.raw&quot;);
    sourceFile.open(QIODevice::ReadOnly);

    QAudioFormat format;
    // Set up the format, eg.
    format.setSampleRate(8000);
    format.setChannelCount(1);
    format.setSampleSize(8);
    format.setCodec(&quot;audio/pcm&quot;);
    format.setByteOrder(QAudioFormat::LittleEndian);
    format.setSampleType(QAudioFormat::UnSignedInt);

    QAudioDeviceInfo info(QAudioDeviceInfo::defaultOutputDevice());
    if (!info.isFormatSupported(format)) {
        qWarning() &lt;&lt; &quot;Raw audio format not supported by backend, cannot play audio.&quot;;
        return;
    }

    audio = new QAudioOutput(format, this);
    connect(audio, SIGNAL(stateChanged(QAudio::State)), this, SLOT(handleStateChanged(QAudio::State)));
    audio-&gt;start(&amp;sourceFile);
}
</db:programlisting>
<db:para>The file will start playing assuming that the audio system and output device support it. If you run out of luck, check what's up with the <db:link xlink:href="qaudiooutput.xml#error">error</db:link>() function.</db:para>
<db:para>After the file has finished playing, we need to stop the device:</db:para>
<db:programlisting language="cpp">void AudioOutputExample::handleStateChanged(QAudio::State newState)
{
    switch (newState) {
        case QAudio::IdleState:
            // Finished playing (no more data)
            audio-&gt;stop();
            sourceFile.close();
            delete audio;
            break;

        case QAudio::StoppedState:
            // Stopped for other reasons
            if (audio-&gt;error() != QAudio::NoError) {
                // Error handling
            }
            break;

        default:
            // ... other cases as appropriate
            break;
    }
}
</db:programlisting>
<db:para>At any given time, the <db:link xlink:href="qaudiooutput.xml">QAudioOutput</db:link> will be in one of four states: active, suspended, stopped, or idle. These states are described by the <db:link xlink:href="qaudio.xml#State-enum">QAudio::State</db:link> enum. State changes are reported through the <db:link xlink:href="qaudiooutput.xml#stateChanged">stateChanged</db:link>() signal. You can use this signal to, for instance, update the GUI of the application; the mundane example here being changing the state of a <db:code>play/pause</db:code> button. You request a state change directly with <db:link xlink:href="qaudiooutput.xml#suspend">suspend</db:link>(), <db:link xlink:href="qaudiooutput.xml#stop">stop</db:link>(), <db:link xlink:href="qaudiooutput.xml#reset">reset</db:link>(), <db:link xlink:href="qaudiooutput.xml#resume">resume</db:link>(), and <db:link xlink:href="qaudiooutput.xml#start">start</db:link>().</db:para>
<db:para>While the stream is playing, you can set a notify interval in milliseconds with <db:link xlink:href="qaudiooutput.xml#setNotifyInterval">setNotifyInterval</db:link>(). This interval specifies the time between two emissions of the <db:link xlink:href="qaudiooutput.xml#notify">notify</db:link>() signal. This is relative to the position in the stream, i.e., if the <db:link xlink:href="qaudiooutput.xml">QAudioOutput</db:link> is in the SuspendedState or the IdleState, the <db:link xlink:href="qaudiooutput.xml#notify">notify</db:link>() signal is not emitted. A typical use-case would be to update a <db:link xlink:href="qslider.xml">slider</db:link> that allows seeking in the stream. If you want the time since playback started regardless of which states the audio output has been in, <db:link xlink:href="qaudiooutput.xml#elapsedUSecs">elapsedUSecs</db:link>() is the function for you.</db:para>
<db:para>If an error occurs, you can fetch the <db:link xlink:href="qaudio.xml#Error-enum">error type</db:link> with the <db:link xlink:href="qaudiooutput.xml#error">error</db:link>() function. Please see the <db:link xlink:href="qaudio.xml#Error-enum">QAudio::Error</db:link> enum for a description of the possible errors that are reported. When an error is encountered, the state changes to <db:link xlink:href="qaudio.xml#State-enum">QAudio::StoppedState</db:link>. You can check for errors by connecting to the <db:link xlink:href="qaudiooutput.xml#stateChanged">stateChanged</db:link>() signal:</db:para>
<db:programlisting language="cpp">void AudioOutputExample::handleStateChanged(QAudio::State newState)
{
    switch (newState) {
        case QAudio::IdleState:
            // Finished playing (no more data)
            audio-&gt;stop();
            sourceFile.close();
            delete audio;
            break;

        case QAudio::StoppedState:
            // Stopped for other reasons
            if (audio-&gt;error() != QAudio::NoError) {
                // Error handling
            }
            break;

        default:
            // ... other cases as appropriate
            break;
    }
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaudioinput.xml">QAudioInput</db:link></db:member>
<db:member><db:link xlink:href="qaudiodeviceinfo.xml">QAudioDeviceInfo</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QAudioOutput">
<db:title>[explicit] QAudioOutput::QAudioOutput(const QAudioFormat &amp;<db:emphasis>format</db:emphasis> = QAudioFormat(), QObject *<db:emphasis>parent</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Construct a new audio output and attach it to <db:code role="parameter">parent</db:code>. The default audio output device is used with the output <db:code role="parameter">format</db:code> parameters.</db:para>
</db:section>
<db:section xml:id="QAudioOutput-1">
<db:title>[explicit] QAudioOutput::QAudioOutput(const QAudioDeviceInfo &amp;<db:emphasis>audioDevice</db:emphasis>, const QAudioFormat &amp;<db:emphasis>format</db:emphasis> = QAudioFormat(), QObject *<db:emphasis>parent</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Construct a new audio output and attach it to <db:code role="parameter">parent</db:code>. The device referenced by <db:code role="parameter">audioDevice</db:code> is used with the output <db:code role="parameter">format</db:code> parameters.</db:para>
</db:section>
<db:section xml:id="dtor.QAudioOutput">
<db:title>[virtual noexcept] QAudioOutput::~QAudioOutput()</db:title>
<db:para>Destroys this audio output.</db:para>
<db:para>This will release any system resources used and free any buffers.</db:para>
</db:section>
<db:section xml:id="bufferSize">
<db:title>int QAudioOutput::bufferSize() const</db:title>
<db:para>Returns the audio buffer size in bytes.</db:para>
<db:para>If called before <db:link xlink:href="qaudiooutput.xml#start">start</db:link>(), returns platform default value. If called before <db:link xlink:href="qaudiooutput.xml#start">start</db:link>() but <db:link xlink:href="qaudiooutput.xml#setBufferSize">setBufferSize</db:link>() was called prior, returns value set by <db:link xlink:href="qaudiooutput.xml#setBufferSize">setBufferSize</db:link>(). If called after <db:link xlink:href="qaudiooutput.xml#start">start</db:link>(), returns the actual buffer size being used. This may not be what was set previously by <db:link xlink:href="qaudiooutput.xml#setBufferSize">setBufferSize</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaudiooutput.xml#setBufferSize">setBufferSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="bytesFree">
<db:title>int QAudioOutput::bytesFree() const</db:title>
<db:para>Returns the number of free bytes available in the audio buffer.</db:para>
<db:note>
<db:para>The returned value is only valid while in <db:link xlink:href="qaudio.xml#State-enum">QAudio::ActiveState</db:link> or <db:link xlink:href="qaudio.xml#State-enum">QAudio::IdleState</db:link> state, otherwise returns zero.</db:para>
</db:note>
</db:section>
<db:section xml:id="category">
<db:title>QString QAudioOutput::category() const</db:title>
<db:para>Returns the audio category of this audio stream.</db:para>
<db:para>Some platforms can group audio streams into categories and manage their volumes independently, or display them in a system mixer control. You can set this property to allow the platform to distinguish the purpose of your streams.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaudiooutput.xml#setCategory">setCategory</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="elapsedUSecs">
<db:title>qint64 QAudioOutput::elapsedUSecs() const</db:title>
<db:para>Returns the microseconds since <db:link xlink:href="qaudiooutput.xml#start">start</db:link>() was called, including time in Idle and Suspend states.</db:para>
</db:section>
<db:section xml:id="error">
<db:title>QAudio::Error QAudioOutput::error() const</db:title>
<db:para>Returns the error state.</db:para>
</db:section>
<db:section xml:id="format">
<db:title>QAudioFormat QAudioOutput::format() const</db:title>
<db:para>Returns the <db:link xlink:href="qaudioformat.xml">QAudioFormat</db:link> being used.</db:para>
</db:section>
<db:section xml:id="notify">
<db:title>void QAudioOutput::notify()</db:title>
<db:para>This signal is emitted when a certain interval of milliseconds of audio data has been processed. The interval is set by <db:link xlink:href="qaudiooutput.xml#setNotifyInterval">setNotifyInterval</db:link>().</db:para>
</db:section>
<db:section xml:id="notifyInterval">
<db:title>int QAudioOutput::notifyInterval() const</db:title>
<db:para>Returns the notify interval in milliseconds.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaudiooutput.xml#setNotifyInterval">setNotifyInterval</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="periodSize">
<db:title>int QAudioOutput::periodSize() const</db:title>
<db:para>Returns the period size in bytes. This is the amount of data required each period to prevent buffer underrun, and to ensure uninterrupted playback.</db:para>
<db:note>
<db:para>It is recommended to provide at least enough data for a full period with each write operation.</db:para>
</db:note>
</db:section>
<db:section xml:id="processedUSecs">
<db:title>qint64 QAudioOutput::processedUSecs() const</db:title>
<db:para>Returns the amount of audio data processed since <db:link xlink:href="qaudiooutput.xml#start">start</db:link>() was called (in microseconds).</db:para>
</db:section>
<db:section xml:id="reset">
<db:title>void QAudioOutput::reset()</db:title>
<db:para>Drops all audio data in the buffers, resets buffers to zero.</db:para>
</db:section>
<db:section xml:id="resume">
<db:title>void QAudioOutput::resume()</db:title>
<db:para>Resumes processing audio data after a <db:link xlink:href="qaudiooutput.xml#suspend">suspend</db:link>().</db:para>
<db:para>Sets <db:link xlink:href="qaudiooutput.xml#error">error</db:link>() to <db:link xlink:href="qaudio.xml#Error-enum">QAudio::NoError</db:link>. Sets <db:link xlink:href="qaudiooutput.xml#state">state</db:link>() to <db:link xlink:href="qaudio.xml#State-enum">QAudio::ActiveState</db:link> if you previously called start(<db:link xlink:href="qiodevice.xml">QIODevice</db:link>*). Sets <db:link xlink:href="qaudiooutput.xml#state">state</db:link>() to <db:link xlink:href="qaudio.xml#State-enum">QAudio::IdleState</db:link> if you previously called <db:link xlink:href="qaudiooutput.xml#start">start</db:link>(). emits <db:link xlink:href="qaudiooutput.xml#stateChanged">stateChanged</db:link>() signal.</db:para>
</db:section>
<db:section xml:id="setBufferSize">
<db:title>void QAudioOutput::setBufferSize(int <db:emphasis>value</db:emphasis>)</db:title>
<db:para>Sets the audio buffer size to <db:code role="parameter">value</db:code> in bytes.</db:para>
<db:note>
<db:para>This function can be called anytime before <db:link xlink:href="qaudiooutput.xml#start">start</db:link>(). Calls to this are ignored after <db:link xlink:href="qaudiooutput.xml#start">start</db:link>(). It should not be assumed that the buffer size set is the actual buffer size used - call <db:link xlink:href="qaudiooutput.xml#bufferSize">bufferSize</db:link>() anytime after <db:link xlink:href="qaudiooutput.xml#start">start</db:link>() to return the actual buffer size being used.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaudiooutput.xml#bufferSize">bufferSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCategory">
<db:title>void QAudioOutput::setCategory(const QString &amp;<db:emphasis>category</db:emphasis>)</db:title>
<db:para>Sets the audio category of this audio stream to <db:code role="parameter">category</db:code>.</db:para>
<db:para>Some platforms can group audio streams into categories and manage their volumes independently, or display them in a system mixer control. You can set this property to allow the platform to distinguish the purpose of your streams.</db:para>
<db:para>Not all platforms support audio stream categorization. In this case, the function call will be ignored.</db:para>
<db:para>Changing an audio output stream's category while it is opened will not take effect until it is reopened.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaudiooutput.xml#category">category</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNotifyInterval">
<db:title>void QAudioOutput::setNotifyInterval(int <db:emphasis>ms</db:emphasis>)</db:title>
<db:para>Sets the interval for <db:link xlink:href="qaudiooutput.xml#notify">notify</db:link>() signal to be emitted. This is based on the <db:code role="parameter">ms</db:code> of audio data processed, not on wall clock time. The minimum resolution of the timer is platform specific and values should be checked with <db:link xlink:href="qaudiooutput.xml#notifyInterval">notifyInterval</db:link>() to confirm the actual value being used.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaudiooutput.xml#notifyInterval">notifyInterval</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setVolume">
<db:title>void QAudioOutput::setVolume(qreal <db:emphasis>volume</db:emphasis>)</db:title>
<db:para>Sets the volume. Where <db:code role="parameter">volume</db:code> is between 0.0 and 1.0 inclusive. Note: Adjustments to the volume will change the volume of this audio stream, not the global volume.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaudiooutput.xml#volume">volume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="start">
<db:title>QIODevice *QAudioOutput::start()</db:title>
<db:para>Returns a pointer to the internal <db:link xlink:href="qiodevice.xml">QIODevice</db:link> being used to transfer data to the system's audio output. The device will already be open and <db:link xlink:href="qiodevice.xml#write">write</db:link>() can write data directly to it.</db:para>
<db:note>
<db:para>The pointer will become invalid after the stream is stopped or if you start another stream.</db:para>
</db:note>
<db:para>If the <db:link xlink:href="qaudiooutput.xml">QAudioOutput</db:link> is able to access the system's audio device, <db:link xlink:href="qaudiooutput.xml#state">state</db:link>() returns <db:link xlink:href="qaudio.xml#State-enum">QAudio::IdleState</db:link>, <db:link xlink:href="qaudiooutput.xml#error">error</db:link>() returns <db:link xlink:href="qaudio.xml#Error-enum">QAudio::NoError</db:link> and the <db:link xlink:href="qaudiooutput.xml#stateChanged">stateChanged</db:link>() signal is emitted.</db:para>
<db:para>If a problem occurs during this process, <db:link xlink:href="qaudiooutput.xml#error">error</db:link>() returns <db:link xlink:href="qaudio.xml#Error-enum">QAudio::OpenError</db:link>, <db:link xlink:href="qaudiooutput.xml#state">state</db:link>() returns <db:link xlink:href="qaudio.xml#State-enum">QAudio::StoppedState</db:link> and the <db:link xlink:href="qaudiooutput.xml#stateChanged">stateChanged</db:link>() signal is emitted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml">QIODevice</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="start-1">
<db:title>void QAudioOutput::start(QIODevice *<db:emphasis>device</db:emphasis>)</db:title>
<db:para>Starts transferring audio data from the <db:code role="parameter">device</db:code> to the system's audio output. The <db:code role="parameter">device</db:code> must have been opened in the <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">ReadOnly</db:link> or <db:link xlink:href="qiodevice.xml#OpenModeFlag-enum">ReadWrite</db:link> modes.</db:para>
<db:para>If the <db:link xlink:href="qaudiooutput.xml">QAudioOutput</db:link> is able to successfully output audio data, <db:link xlink:href="qaudiooutput.xml#state">state</db:link>() returns <db:link xlink:href="qaudio.xml#State-enum">QAudio::ActiveState</db:link>, <db:link xlink:href="qaudiooutput.xml#error">error</db:link>() returns <db:link xlink:href="qaudio.xml#Error-enum">QAudio::NoError</db:link> and the <db:link xlink:href="qaudiooutput.xml#stateChanged">stateChanged</db:link>() signal is emitted.</db:para>
<db:para>If a problem occurs during this process, <db:link xlink:href="qaudiooutput.xml#error">error</db:link>() returns <db:link xlink:href="qaudio.xml#Error-enum">QAudio::OpenError</db:link>, <db:link xlink:href="qaudiooutput.xml#state">state</db:link>() returns <db:link xlink:href="qaudio.xml#State-enum">QAudio::StoppedState</db:link> and the <db:link xlink:href="qaudiooutput.xml#stateChanged">stateChanged</db:link>() signal is emitted.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qiodevice.xml">QIODevice</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="state">
<db:title>QAudio::State QAudioOutput::state() const</db:title>
<db:para>Returns the state of audio processing.</db:para>
</db:section>
<db:section xml:id="stateChanged">
<db:title>void QAudioOutput::stateChanged(QAudio::State <db:emphasis>state</db:emphasis>)</db:title>
<db:para>This signal is emitted when the device <db:code role="parameter">state</db:code> has changed. This is the current state of the audio output.</db:para>
</db:section>
<db:section xml:id="stop">
<db:title>void QAudioOutput::stop()</db:title>
<db:para>Stops the audio output, detaching from the system resource.</db:para>
<db:para>Sets <db:link xlink:href="qaudiooutput.xml#error">error</db:link>() to <db:link xlink:href="qaudio.xml#Error-enum">QAudio::NoError</db:link>, <db:link xlink:href="qaudiooutput.xml#state">state</db:link>() to <db:link xlink:href="qaudio.xml#State-enum">QAudio::StoppedState</db:link> and emit <db:link xlink:href="qaudiooutput.xml#stateChanged">stateChanged</db:link>() signal.</db:para>
</db:section>
<db:section xml:id="suspend">
<db:title>void QAudioOutput::suspend()</db:title>
<db:para>Stops processing audio data, preserving buffered audio data.</db:para>
<db:para>Sets <db:link xlink:href="qaudiooutput.xml#error">error</db:link>() to <db:link xlink:href="qaudio.xml#Error-enum">QAudio::NoError</db:link>, <db:link xlink:href="qaudiooutput.xml#state">state</db:link>() to <db:link xlink:href="qaudio.xml#State-enum">QAudio::SuspendedState</db:link> and emits <db:link xlink:href="qaudiooutput.xml#stateChanged">stateChanged</db:link>() signal.</db:para>
</db:section>
<db:section xml:id="volume">
<db:title>qreal QAudioOutput::volume() const</db:title>
<db:para>Returns the volume between 0.0 and 1.0 inclusive.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qaudiooutput.xml#setVolume">setVolume</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
