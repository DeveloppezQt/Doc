<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QtConcurrent Namespace</db:title>
<db:productname>QtConcurrent</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Concurrent Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qtconcurrent-module.xml">QtConcurrent</db:link> namespace provides high-level APIs that make it possible to write multi-threaded programs without using low-level threading primitives.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QtConcurrent</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Concurrent)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Concurrent)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += concurrent</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QtConcurrent is part of <db:simplelist><db:member>thread</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>See the <db:link xlink:href="qtconcurrent-index.xml">Qt Concurrent</db:link> module documentation for an overview of available functions, or see below for detailed information on each function.</db:para>
</db:section>
<db:section xml:id="classes">
<db:title>Classes</db:title>
<db:section>
<db:title>class <db:link xlink:href="qtconcurrent-qtaskbuilder.xml" xlink:role="class">QTaskBuilder</db:link></db:title>
<db:para>The <db:link xlink:href="qtconcurrent-qtaskbuilder.xml">QTaskBuilder</db:link> class is used for adjusting task parameters.</db:para>
</db:section>
</db:section>
<db:section xml:id="type-documentation">
<db:title>Type Documentation</db:title>
<db:section xml:id="FutureResult-enum">
<db:title>enum QtConcurrent::FutureResult</db:title>
<db:enumsynopsis>
<db:enumname>FutureResult</db:enumname>
<db:enumitem>
<db:enumidentifier>Ignore</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum type is used to invoke a special overload of <db:link xlink:href="qtconcurrent-qtaskbuilder.xml#spawn">QtConcurrent::QTaskBuilder::spawn</db:link>(QtConcurrent::FutureResult) that doesn't return a future object.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtconcurrent.xml">QtConcurrent</db:link></db:emphasis>::<db:emphasis role="bold">FutureResult</db:emphasis>::Ignore</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>An auxiliary tag which introduced to improve code readability.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="InvokeResultType-typedef">
<db:title>[alias] InvokeResultType</db:title>
<db:typedefsynopsis>
<db:typedefname>InvokeResultType</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>The simplified definition of this type looks like this:</db:para>
<db:programlisting language="cpp">template &amp;lt;class Task, class ...Args&amp;gt;
using InvokeResultType = std::invoke_result_t&amp;lt;std::decay_t&amp;lt;Task&amp;gt;, std::decay_t&amp;lt;Args&amp;gt;...&amp;gt;;
</db:programlisting>
<db:para>The real implementation also contains a compile-time check for whether the task can be invoked with the specified arguments or not.</db:para>
</db:section>
<db:section xml:id="ReduceOption-enum">
<db:title>enum QtConcurrent::ReduceOption</db:title>
<db:bridgehead renderas="sect2">flags QtConcurrent::ReduceOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>ReduceOption</db:enumname>
<db:enumitem>
<db:enumidentifier>UnorderedReduce</db:enumidentifier>
<db:enumvalue>0x1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>OrderedReduce</db:enumidentifier>
<db:enumvalue>0x2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SequentialReduce</db:enumidentifier>
<db:enumvalue>0x4</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QtConcurrent::ReduceOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum specifies the order of which results from the map or filter function are passed to the reduce function.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtconcurrent.xml">QtConcurrent</db:link></db:emphasis>::UnorderedReduce</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>Reduction is done in an arbitrary order.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtconcurrent.xml">QtConcurrent</db:link></db:emphasis>::OrderedReduce</db:code></db:para>
</db:td>
<db:td><db:code>0x2</db:code></db:td>
<db:td>
<db:para>Reduction is done in the order of the original sequence.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtconcurrent.xml">QtConcurrent</db:link></db:emphasis>::SequentialReduce</db:code></db:para>
</db:td>
<db:td><db:code>0x4</db:code></db:td>
<db:td>
<db:para>Reduction is done sequentially: only one thread will enter the reduce function at a time. (Parallel reduction might be supported in a future version of Qt Concurrent.)</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>ReduceOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;ReduceOption&gt;. </db:code>It stores an OR combination of <db:code>ReduceOption</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="function-documentation">
<db:title>Function Documentation</db:title>
<db:section xml:id="blockingFilter">
<db:title>void QtConcurrent::blockingFilter(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>blockingFilter</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void blockingFilter(QThreadPool *pool, Sequence &amp;sequence, KeepFunctor &amp;&amp;filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, the item is kept in <db:code role="parameter">sequence</db:code>; otherwise, the item is removed from <db:code role="parameter">sequence</db:code>.</db:para>
<db:para>Note that this method doesn't have an overload working with iterators, because it invalidates the iterators of the sequence it operates on.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFilter-1">
<db:title>void QtConcurrent::blockingFilter(Sequence &amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>blockingFilter</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void blockingFilter(Sequence &amp;sequence, KeepFunctor &amp;&amp;filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, the item is kept in <db:code role="parameter">sequence</db:code>; otherwise, the item is removed from <db:code role="parameter">sequence</db:code>.</db:para>
<db:para>Note that this method doesn't have an overload working with iterators, because it invalidates the iterators of the sequence it operates on.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFiltered">
<db:title>std::decay_t&lt;Sequence&gt; QtConcurrent::blockingFiltered(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>std::decay_t&lt;Sequence&gt;</db:type>
<db:methodname>blockingFiltered</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">std::decay_t&lt;Sequence&gt; blockingFiltered(QThreadPool *pool, Sequence &amp;&amp;sequence, KeepFunctor &amp;&amp;filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code> and returns a new Sequence of kept items. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, a copy of the item is put in the new Sequence. Otherwise, the item will <db:emphasis>not</db:emphasis> appear in the new Sequence.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filtered">filtered</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFiltered-1">
<db:title>std::decay_t&lt;Sequence&gt; QtConcurrent::blockingFiltered(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>std::decay_t&lt;Sequence&gt;</db:type>
<db:methodname>blockingFiltered</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">std::decay_t&lt;Sequence&gt; blockingFiltered(Sequence &amp;&amp;sequence, KeepFunctor &amp;&amp;filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code> and returns a new Sequence of kept items. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, a copy of the item is put in the new Sequence. Otherwise, the item will <db:emphasis>not</db:emphasis> appear in the new Sequence.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filtered">filtered</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFiltered-2">
<db:title>OutputSequence QtConcurrent::blockingFiltered(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>OutputSequence</db:type>
<db:methodname>blockingFiltered</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">OutputSequence blockingFiltered(QThreadPool *pool, Iterator begin, Iterator end, KeepFunctor &amp;&amp;filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> and returns a new Sequence of kept items. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, a copy of the item is put in the new Sequence. Otherwise, the item will <db:emphasis>not</db:emphasis> appear in the new Sequence.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filtered">filtered</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFiltered-3">
<db:title>OutputSequence QtConcurrent::blockingFiltered(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>OutputSequence</db:type>
<db:methodname>blockingFiltered</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">OutputSequence blockingFiltered(Iterator begin, Iterator end, KeepFunctor &amp;&amp;filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> and returns a new Sequence of kept items. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, a copy of the item is put in the new Sequence. Otherwise, the item will <db:emphasis>not</db:emphasis> appear in the new Sequence.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filtered">filtered</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFilteredReduced">
<db:title>ResultType QtConcurrent::blockingFilteredReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingFilteredReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingFilteredReduced(QThreadPool *pool, Sequence &amp;&amp;sequence, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filteredReduced">filteredReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFilteredReduced-1">
<db:title>ResultType QtConcurrent::blockingFilteredReduced(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingFilteredReduced</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingFilteredReduced(Sequence &amp;&amp;sequence, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filteredReduced">filteredReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFilteredReduced-2">
<db:title>ResultType QtConcurrent::blockingFilteredReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingFilteredReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingFilteredReduced(QThreadPool *pool, Sequence &amp;&amp;sequence, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filteredReduced">filteredReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFilteredReduced-3">
<db:title>ResultType QtConcurrent::blockingFilteredReduced(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingFilteredReduced</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingFilteredReduced(Sequence &amp;&amp;sequence, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filteredReduced">filteredReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFilteredReduced-4">
<db:title>ResultType QtConcurrent::blockingFilteredReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingFilteredReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingFilteredReduced(QThreadPool *pool, Iterator begin, Iterator end, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, the <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filteredReduced">filteredReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFilteredReduced-5">
<db:title>ResultType QtConcurrent::blockingFilteredReduced(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingFilteredReduced</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingFilteredReduced(Iterator begin, Iterator end, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, the <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filteredReduced">filteredReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFilteredReduced-6">
<db:title>ResultType QtConcurrent::blockingFilteredReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingFilteredReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingFilteredReduced(QThreadPool *pool, Iterator begin, Iterator end, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, the <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filteredReduced">filteredReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFilteredReduced-7">
<db:title>ResultType QtConcurrent::blockingFilteredReduced(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingFilteredReduced</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                         | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingFilteredReduced(Iterator begin, Iterator end, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, the <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filteredReduced">filteredReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMap">
<db:title>void QtConcurrent::blockingMap(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>blockingMap</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void blockingMap(QThreadPool *pool, Sequence &amp;&amp;sequence, MapFunctor function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item in <db:code role="parameter">sequence</db:code>. All calls to <db:code role="parameter">function</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The <db:code role="parameter">function</db:code> takes a reference to the item, so that any modifications done to the item will appear in <db:code role="parameter">sequence</db:code>.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMap-1">
<db:title>void QtConcurrent::blockingMap(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>blockingMap</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void blockingMap(Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item in <db:code role="parameter">sequence</db:code>. The <db:code role="parameter">function</db:code> takes a reference to the item, so that any modifications done to the item will appear in <db:code role="parameter">sequence</db:code>.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMap-2">
<db:title>void QtConcurrent::blockingMap(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>blockingMap</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void blockingMap(QThreadPool *pool, Iterator begin, Iterator end, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. All calls to <db:code role="parameter">function</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The <db:code role="parameter">function</db:code> takes a reference to the item, so that any modifications done to the item will appear in the sequence which the iterators belong to.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMap-3">
<db:title>void QtConcurrent::blockingMap(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>blockingMap</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void blockingMap(Iterator begin, Iterator end, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. The <db:code role="parameter">function</db:code> takes a reference to the item, so that any modifications done to the item will appear in the sequence which the iterators belong to.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMapped">
<db:title>OutputSequence QtConcurrent::blockingMapped(QThreadPool *<db:emphasis>pool</db:emphasis>, InputSequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>OutputSequence</db:type>
<db:methodname>blockingMapped</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InputSequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">OutputSequence blockingMapped(QThreadPool *pool, InputSequence &amp;&amp;sequence, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item in <db:code role="parameter">sequence</db:code> and returns an OutputSequence containing the results. All calls to <db:code role="parameter">function</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The type of the results will match the type returned by the MapFunctor.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#mapped">mapped</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMapped-1">
<db:title>OutputSequence QtConcurrent::blockingMapped(InputSequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>OutputSequence</db:type>
<db:methodname>blockingMapped</db:methodname>
<db:methodparam>
<db:type>InputSequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">OutputSequence blockingMapped(InputSequence &amp;&amp;sequence, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item in <db:code role="parameter">sequence</db:code> and returns an OutputSequence containing the results. The type of the results will match the type returned by the MapFunctor.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#mapped">mapped</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMapped-2">
<db:title>Sequence QtConcurrent::blockingMapped(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>Sequence</db:type>
<db:methodname>blockingMapped</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">Sequence blockingMapped(QThreadPool *pool, Iterator begin, Iterator end, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> and returns a container with the results. All calls to <db:code role="parameter">function</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. You can specify the type of container as the a template argument, like this:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; ints = QtConcurrent::blockingMapped&amp;lt;QList&amp;lt;int&amp;gt; &amp;gt;(beginIterator, endIterator, fn);
</db:programlisting>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#mapped">mapped</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMapped-3">
<db:title>Sequence QtConcurrent::blockingMapped(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>Sequence</db:type>
<db:methodname>blockingMapped</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">Sequence blockingMapped(Iterator begin, Iterator end, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> and returns a container with the results. You can specify the type of container as the a template argument, like this:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; ints = QtConcurrent::blockingMapped&amp;lt;QList&amp;lt;int&amp;gt; &amp;gt;(beginIterator, endIterator, fn);
</db:programlisting>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#mapped">mapped</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMappedReduced">
<db:title>ResultType QtConcurrent::blockingMappedReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingMappedReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingMappedReduced(QThreadPool *pool, Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. All calls to <db:code role="parameter">mapFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is determined by <db:code role="parameter">reduceOptions</db:code>.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#mapped">mapped</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMappedReduced-1">
<db:title>ResultType QtConcurrent::blockingMappedReduced(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingMappedReduced</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingMappedReduced(Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is determined by <db:code role="parameter">reduceOptions</db:code>.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#mapped">mapped</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMappedReduced-2">
<db:title>ResultType QtConcurrent::blockingMappedReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingMappedReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingMappedReduced(QThreadPool *pool, Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. All calls to <db:code role="parameter">mapFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is determined by <db:code role="parameter">reduceOptions</db:code>.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#mapped">mapped</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMappedReduced-3">
<db:title>ResultType QtConcurrent::blockingMappedReduced(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingMappedReduced</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingMappedReduced(Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is determined by <db:code role="parameter">reduceOptions</db:code>.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#mapped">mapped</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMappedReduced-4">
<db:title>ResultType QtConcurrent::blockingMappedReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingMappedReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingMappedReduced(QThreadPool *pool, Iterator begin, Iterator end, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. All calls to <db:code role="parameter">mapFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#blockingMappedReduced">blockingMappedReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMappedReduced-5">
<db:title>ResultType QtConcurrent::blockingMappedReduced(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingMappedReduced</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingMappedReduced(Iterator begin, Iterator end, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#blockingMappedReduced">blockingMappedReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMappedReduced-6">
<db:title>ResultType QtConcurrent::blockingMappedReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingMappedReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingMappedReduced(QThreadPool *pool, Iterator begin, Iterator end, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. All calls to <db:code role="parameter">mapFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#blockingMappedReduced">blockingMappedReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMappedReduced-7">
<db:title>ResultType QtConcurrent::blockingMappedReduced(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingMappedReduced</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                       | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingMappedReduced(Iterator begin, Iterator end, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#blockingMappedReduced">blockingMappedReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filter">
<db:title>QFuture&lt;void&gt; QtConcurrent::filter(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;void&gt;</db:type>
<db:methodname>filter</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;void&gt; filter(QThreadPool *pool, Sequence &amp;sequence, KeepFunctor &amp;&amp;filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, the item is kept in <db:code role="parameter">sequence</db:code>; otherwise, the item is removed from <db:code role="parameter">sequence</db:code>.</db:para>
<db:para>Note that this method doesn't have an overload working with iterators, because it invalidates the iterators of the sequence it operates on.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filter-1">
<db:title>QFuture&lt;void&gt; QtConcurrent::filter(Sequence &amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;void&gt;</db:type>
<db:methodname>filter</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;void&gt; filter(Sequence &amp;sequence, KeepFunctor &amp;&amp;filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, the item is kept in <db:code role="parameter">sequence</db:code>; otherwise, the item is removed from <db:code role="parameter">sequence</db:code>.</db:para>
<db:para>Note that this method doesn't have an overload working with iterators, because it invalidates the iterators of the sequence it operates on.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filtered">
<db:title>QFuture&lt;typename std::decay_t&lt;Sequence&gt;::value_type&gt; QtConcurrent::filtered(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;typename std::decay_t&lt;Sequence&gt;::value_type&gt;</db:type>
<db:methodname>filtered</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;typename std::decay_t&lt;Sequence&gt;::value_type&gt; filtered(QThreadPool *pool, Sequence &amp;&amp;sequence, KeepFunctor &amp;&amp;filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code> and returns a new Sequence of kept items. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, a copy of the item is put in the new Sequence. Otherwise, the item will <db:emphasis>not</db:emphasis> appear in the new Sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filtered-1">
<db:title>QFuture&lt;typename std::decay_t&lt;Sequence&gt;::value_type&gt; QtConcurrent::filtered(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;typename std::decay_t&lt;Sequence&gt;::value_type&gt;</db:type>
<db:methodname>filtered</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;typename std::decay_t&lt;Sequence&gt;::value_type&gt; filtered(Sequence &amp;&amp;sequence, KeepFunctor &amp;&amp;filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code> and returns a new Sequence of kept items. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, a copy of the item is put in the new Sequence. Otherwise, the item will <db:emphasis>not</db:emphasis> appear in the new Sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filtered-2">
<db:title>QFuture&lt;typename qValueType&lt;Iterator&gt;::value_type&gt; QtConcurrent::filtered(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;typename qValueType&lt;Iterator&gt;::value_type&gt;</db:type>
<db:methodname>filtered</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;typename qValueType&lt;Iterator&gt;::value_type&gt; filtered(QThreadPool *pool, Iterator begin, Iterator end, KeepFunctor &amp;&amp;filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> and returns a new Sequence of kept items. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, a copy of the item is put in the new Sequence. Otherwise, the item will <db:emphasis>not</db:emphasis> appear in the new Sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filtered-3">
<db:title>QFuture&lt;typename qValueType&lt;Iterator&gt;::value_type&gt; QtConcurrent::filtered(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;typename qValueType&lt;Iterator&gt;::value_type&gt;</db:type>
<db:methodname>filtered</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;typename qValueType&lt;Iterator&gt;::value_type&gt; filtered(Iterator begin, Iterator end, KeepFunctor &amp;&amp;filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> and returns a new Sequence of kept items. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, a copy of the item is put in the new Sequence. Otherwise, the item will <db:emphasis>not</db:emphasis> appear in the new Sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filteredReduced">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::filteredReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>filteredReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; filteredReduced(QThreadPool *pool, Sequence &amp;&amp;sequence, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filteredReduced-1">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::filteredReduced(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>filteredReduced</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; filteredReduced(Sequence &amp;&amp;sequence, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filteredReduced-2">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::filteredReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>filteredReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; filteredReduced(QThreadPool *pool, Sequence &amp;&amp;sequence, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filteredReduced-3">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::filteredReduced(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>filteredReduced</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; filteredReduced(Sequence &amp;&amp;sequence, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filteredReduced-4">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::filteredReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>filteredReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; filteredReduced(QThreadPool *pool, Iterator begin, Iterator end, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, the <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filteredReduced-5">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::filteredReduced(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>filteredReduced</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; filteredReduced(Iterator begin, Iterator end, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, the <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filteredReduced-6">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::filteredReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>filteredReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; filteredReduced(QThreadPool *pool, Iterator begin, Iterator end, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. All calls to <db:code role="parameter">filterFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, the <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filteredReduced-7">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::filteredReduced(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor &amp;&amp;<db:emphasis>filterFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>filteredReduced</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor &amp;&amp;</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                          | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; filteredReduced(Iterator begin, Iterator end, KeepFunctor &amp;&amp;filterFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, the <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="map">
<db:title>QFuture&lt;void&gt; QtConcurrent::map(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;void&gt;</db:type>
<db:methodname>map</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;void&gt; map(QThreadPool *pool, Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item in <db:code role="parameter">sequence</db:code>. All calls to <db:code role="parameter">function</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The <db:code role="parameter">function</db:code> takes a reference to the item, so that any modifications done to the item will appear in <db:code role="parameter">sequence</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="map-1">
<db:title>QFuture&lt;void&gt; QtConcurrent::map(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;void&gt;</db:type>
<db:methodname>map</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;void&gt; map(Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item in <db:code role="parameter">sequence</db:code>. The <db:code role="parameter">function</db:code> takes a reference to the item, so that any modifications done to the item will appear in <db:code role="parameter">sequence</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="map-2">
<db:title>QFuture&lt;void&gt; QtConcurrent::map(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;void&gt;</db:type>
<db:methodname>map</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;void&gt; map(QThreadPool *pool, Iterator begin, Iterator end, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. All calls to <db:code role="parameter">function</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The <db:code role="parameter">function</db:code> takes a reference to the item, so that any modifications done to the item will appear in the sequence which the iterators belong to.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="map-3">
<db:title>QFuture&lt;void&gt; QtConcurrent::map(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;void&gt;</db:type>
<db:methodname>map</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;void&gt; map(Iterator begin, Iterator end, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. The <db:code role="parameter">function</db:code> takes a reference to the item, so that any modifications done to the item will appear in the sequence which the iterators belong to.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapped">
<db:title>QFuture&lt;QtPrivate::MapResultType&lt;Sequence, MapFunctor&gt;&gt; QtConcurrent::mapped(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;QtPrivate::MapResultType&lt;Sequence, MapFunctor&gt;&gt;</db:type>
<db:methodname>mapped</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;QtPrivate::MapResultType&lt;Sequence, MapFunctor&gt;&gt; mapped(QThreadPool *pool, Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item in <db:code role="parameter">sequence</db:code> and returns a future with each mapped item as a result. All calls to <db:code role="parameter">function</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. You can use <db:link xlink:href="qfuture-const-iterator.xml">QFuture::const_iterator</db:link> or <db:link xlink:href="qfutureiterator.xml">QFutureIterator</db:link> to iterate through the results.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapped-1">
<db:title>QFuture&lt;QtPrivate::MapResultType&lt;Sequence, MapFunctor&gt;&gt; QtConcurrent::mapped(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;QtPrivate::MapResultType&lt;Sequence, MapFunctor&gt;&gt;</db:type>
<db:methodname>mapped</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;QtPrivate::MapResultType&lt;Sequence, MapFunctor&gt;&gt; mapped(Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item in <db:code role="parameter">sequence</db:code> and returns a future with each mapped item as a result. You can use <db:link xlink:href="qfuture-const-iterator.xml">QFuture::const_iterator</db:link> or <db:link xlink:href="qfutureiterator.xml">QFutureIterator</db:link> to iterate through the results.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapped-2">
<db:title>QFuture&lt;QtPrivate::MapResultType&lt;Iterator, MapFunctor&gt;&gt; QtConcurrent::mapped(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;QtPrivate::MapResultType&lt;Iterator, MapFunctor&gt;&gt;</db:type>
<db:methodname>mapped</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;QtPrivate::MapResultType&lt;Iterator, MapFunctor&gt;&gt; mapped(QThreadPool *pool, Iterator begin, Iterator end, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> and returns a future with each mapped item as a result. All calls to <db:code role="parameter">function</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. You can use <db:link xlink:href="qfuture-const-iterator.xml">QFuture::const_iterator</db:link> or <db:link xlink:href="qfutureiterator.xml">QFutureIterator</db:link> to iterate through the results.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapped-3">
<db:title>QFuture&lt;QtPrivate::MapResultType&lt;Iterator, MapFunctor&gt;&gt; QtConcurrent::mapped(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;QtPrivate::MapResultType&lt;Iterator, MapFunctor&gt;&gt;</db:type>
<db:methodname>mapped</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;QtPrivate::MapResultType&lt;Iterator, MapFunctor&gt;&gt; mapped(Iterator begin, Iterator end, MapFunctor &amp;&amp;function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> and returns a future with each mapped item as a result. You can use <db:link xlink:href="qfuture-const-iterator.xml">QFuture::const_iterator</db:link> or <db:link xlink:href="qfutureiterator.xml">QFutureIterator</db:link> to iterate through the results.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mappedReduced">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::mappedReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>mappedReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; mappedReduced(QThreadPool *pool, Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. All calls to <db:code role="parameter">mapFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is determined by <db:code role="parameter">reduceOptions</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mappedReduced-1">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::mappedReduced(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>mappedReduced</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; mappedReduced(Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is determined by <db:code role="parameter">reduceOptions</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mappedReduced-2">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::mappedReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>mappedReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; mappedReduced(QThreadPool *pool, Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. All calls to <db:code role="parameter">mapFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is determined by <db:code role="parameter">reduceOptions</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mappedReduced-3">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::mappedReduced(Sequence &amp;&amp;<db:emphasis>sequence</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>mappedReduced</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;&amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; mappedReduced(Sequence &amp;&amp;sequence, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is determined by <db:code role="parameter">reduceOptions</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mappedReduced-4">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::mappedReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>mappedReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; mappedReduced(QThreadPool *pool, Iterator begin, Iterator end, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. All calls to <db:code role="parameter">mapFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. By default, the order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined.</db:para>
<db:note>
<db:para><db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link> results in the ordered reduction.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mappedReduced-5">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::mappedReduced(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>mappedReduced</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; mappedReduced(Iterator begin, Iterator end, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. By default, the order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined.</db:para>
<db:note>
<db:para><db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link> results in the ordered reduction.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mappedReduced-6">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::mappedReduced(QThreadPool *<db:emphasis>pool</db:emphasis>, Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>mappedReduced</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; mappedReduced(QThreadPool *pool, Iterator begin, Iterator end, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. All calls to <db:code role="parameter">mapFunction</db:code> are invoked from the threads taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. By default, the order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined.</db:para>
<db:note>
<db:para><db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link> results in the ordered reduction.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mappedReduced-7">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::mappedReduced(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor &amp;&amp;<db:emphasis>mapFunction</db:emphasis>, ReduceFunctor &amp;&amp;<db:emphasis>reduceFunction</db:emphasis>, InitialValueType &amp;&amp;<db:emphasis>initialValue</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>mappedReduced</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor &amp;&amp;</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor &amp;&amp;</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>InitialValueType &amp;&amp;</db:type>
<db:parameter>initialValue</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce
                                                                        | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; mappedReduced(Iterator begin, Iterator end, MapFunctor &amp;&amp;mapFunction, ReduceFunctor &amp;&amp;reduceFunction, InitialValueType &amp;&amp;initialValue, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>. The result value is initialized to <db:code role="parameter">initialValue</db:code> when the function is called, and the first call to <db:code role="parameter">reduceFunction</db:code> will operate on this value.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. By default, the order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined.</db:para>
<db:note>
<db:para><db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link> results in the ordered reduction.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="run">
<db:title>QFuture&lt;T&gt; QtConcurrent::run(Function <db:emphasis>function</db:emphasis>, <db:emphasis>...</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>run</db:methodname>
<db:methodparam>
<db:type>Function</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>...</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; run(Function function, ...)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Equivalent to</db:para>
<db:programlisting language="cpp">QtConcurrent::run(QThreadPool::globalInstance(), function, ...);
</db:programlisting>
<db:para>Runs <db:code role="parameter">function</db:code> in a separate thread. The thread is taken from the global <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link>. Note that <db:code role="parameter">function</db:code> may not run immediately; <db:code role="parameter">function</db:code> will only be run once a thread becomes available.</db:para>
<db:para>In <db:link xlink:href="qtconcurrentrun.xml#concurrent-run-basic-mode">basic mode</db:link> T is the same type as the return value of <db:code role="parameter">function</db:code>. Non-void return values can be accessed via the <db:link xlink:href="qfuture.xml#result">QFuture::result</db:link>() function.</db:para>
<db:para>In <db:link xlink:href="qtconcurrentrun.xml#concurrent-run-basic-mode">basic mode</db:link> the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned can only be used to query for the running/finished status and the return value of the function. In particular, canceling or pausing can be issued only if the computations behind the future has not been started.</db:para>
<db:para>In <db:link xlink:href="qtconcurrentrun.xml#concurrent-run-with-promise">run with promise mode</db:link>, the <db:code role="parameter">function</db:code> is expected to return void and must take an additional argument of <db:code>QPromise&lt;T&gt; &amp;</db:code> type, placed as a first argument in function's argument list. T is the result type and it is the same for the returned <db:code>QFuture&lt;T&gt;</db:code>.</db:para>
<db:para>In <db:link xlink:href="qtconcurrentrun.xml#concurrent-run-with-promise">run with promise mode</db:link>, similar to <db:emphasis>basic</db:emphasis> mode, the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned can be used to query for the running/finished status and the value reported by the function. In addition, it may be used for suspending or canceling the running task, fetching multiple results from the called <db:code role="parameter">function</db:code> or monitoring progress reported by the <db:code role="parameter">function</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentrun.xml#concurrent-run-basic-mode">Concurrent Run (basic mode)</db:link></db:member>
<db:member><db:link xlink:href="qtconcurrentrun.xml#concurrent-run-with-promise">Concurrent Run With Promise</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="run-1">
<db:title>[since 5.4] QFuture&lt;T&gt; QtConcurrent::run(QThreadPool *<db:emphasis>pool</db:emphasis>, Function <db:emphasis>function</db:emphasis>, <db:emphasis>...</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>run</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Function</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>...</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; run(QThreadPool *pool, Function function, ...)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Runs <db:code role="parameter">function</db:code> in a separate thread. The thread is taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. Note that <db:code role="parameter">function</db:code> may not run immediately; <db:code role="parameter">function</db:code> will only be run once a thread becomes available.</db:para>
<db:para>In <db:link xlink:href="qtconcurrentrun.xml#concurrent-run-basic-mode">basic mode</db:link> T is the same type as the return value of <db:code role="parameter">function</db:code>. Non-void return values can be accessed via the <db:link xlink:href="qfuture.xml#result">QFuture::result</db:link>() function.</db:para>
<db:para>In <db:link xlink:href="qtconcurrentrun.xml#concurrent-run-basic-mode">basic mode</db:link> the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned can only be used to query for the running/finished status and the return value of the function. In particular, canceling or pausing can be issued only if the computations behind the future has not been started.</db:para>
<db:para>In <db:link xlink:href="qtconcurrentrun.xml#concurrent-run-with-promise">run with promise mode</db:link>, the <db:code role="parameter">function</db:code> is expected to return void and must take an additional argument of <db:code>QPromise&lt;T&gt; &amp;</db:code> type, placed as a first argument in function's argument list. T is the result type and it is the same for the returned <db:code>QFuture&lt;T&gt;</db:code>.</db:para>
<db:para>In <db:link xlink:href="qtconcurrentrun.xml#concurrent-run-with-promise">run with promise mode</db:link>, similar to <db:emphasis>basic</db:emphasis> mode, the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned can be used to query for the running/finished status and the value reported by the function. In addition, it may be used for suspending or canceling the running task, fetching multiple results from the called <db:code role="parameter">function</db:code> or monitoring progress reported by the <db:code role="parameter">function</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentrun.xml#concurrent-run-basic-mode">Concurrent Run (basic mode)</db:link></db:member>
<db:member><db:link xlink:href="qtconcurrentrun.xml#concurrent-run-with-promise">Concurrent Run With Promise</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="task">
<db:title>[since 6.0] QTaskBuilder&lt;Task&gt; QtConcurrent::task(Task &amp;&amp;<db:emphasis>task</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QTaskBuilder&lt;Task&gt;</db:type>
<db:methodname>task</db:methodname>
<db:methodparam>
<db:type>Task &amp;&amp;</db:type>
<db:parameter>task</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QTaskBuilder&lt;Task&gt; task(Task &amp;&amp;task)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates an instance of <db:link xlink:href="qtconcurrent-qtaskbuilder.xml">QtConcurrent::QTaskBuilder</db:link>. This object can be used to adjust some parameters and run <db:code role="parameter">task</db:code> in a separate thread.</db:para>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrenttask.xml">Concurrent Task</db:link></db:member>
<db:member><db:link xlink:href="qtconcurrent-qtaskbuilder.xml">QtConcurrent::QTaskBuilder</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
