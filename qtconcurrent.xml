<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QtConcurrent Namespace</db:title>
<db:productname>QtConcurrent</db:productname>
<db:edition>Qt 5.11.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Concurrent Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qtconcurrent-module.xml">QtConcurrent</db:link> namespace provides high-level APIs that make it possible to write multi-threaded programs without using low-level threading primitives.</db:para>
<db:para>This namespace was introduced in Qt 4.4.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QtConcurrent</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.4</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += concurrent</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QtConcurrent is part of <db:simplelist><db:member>thread</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>See the <db:link xlink:href="qtconcurrent-index.xml">Qt Concurrent</db:link> module documentation for an overview of available functions, or see below for detailed information on each function.</db:para>
</db:section>
<db:section xml:id="type-documentation">
<db:title>Type Documentation</db:title>
<db:section xml:id="ReduceOption-enum">
<db:title>enum QtConcurrent::ReduceOption</db:title>
<db:bridgehead renderas="sect2">flags QtConcurrent::ReduceOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>ReduceOption</db:enumname>
<db:enumitem>
<db:enumidentifier>UnorderedReduce</db:enumidentifier>
<db:enumvalue>0x1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>OrderedReduce</db:enumidentifier>
<db:enumvalue>0x2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SequentialReduce</db:enumidentifier>
<db:enumvalue>0x4</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QtConcurrent::ReduceOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum specifies the order of which results from the map or filter function are passed to the reduce function.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtconcurrent.xml">QtConcurrent</db:link></db:emphasis>::UnorderedReduce</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>Reduction is done in an arbitrary order.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtconcurrent.xml">QtConcurrent</db:link></db:emphasis>::OrderedReduce</db:code></db:para>
</db:td>
<db:td><db:code>0x2</db:code></db:td>
<db:td>
<db:para>Reduction is done in the order of the original sequence.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtconcurrent.xml">QtConcurrent</db:link></db:emphasis>::SequentialReduce</db:code></db:para>
</db:td>
<db:td><db:code>0x4</db:code></db:td>
<db:td>
<db:para>Reduction is done sequentially: only one thread will enter the reduce function at a time. (Parallel reduction might be supported in a future version of Qt Concurrent.)</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>ReduceOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;ReduceOption&gt;. </db:code>It stores an OR combination of <db:code>ReduceOption</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="function-documentation">
<db:title>Function Documentation</db:title>
<db:section xml:id="blockingFilter">
<db:title>void QtConcurrent::blockingFilter(Sequence &amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor <db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>blockingFilter</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void blockingFilter(Sequence &amp;sequence, KeepFunctor filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, the item is kept in <db:code role="parameter">sequence</db:code>; otherwise, the item is removed from <db:code role="parameter">sequence</db:code>.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFiltered">
<db:title>Sequence QtConcurrent::blockingFiltered(const Sequence &amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor <db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>Sequence</db:type>
<db:methodname>blockingFiltered</db:methodname>
<db:methodparam>
<db:type>const Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">Sequence blockingFiltered(const Sequence &amp;sequence, KeepFunctor filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code> and returns a new Sequence of kept items. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, a copy of the item is put in the new Sequence. Otherwise, the item will <db:emphasis>not</db:emphasis> appear in the new Sequence.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filtered">filtered</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFiltered-1">
<db:title>OutputSequence QtConcurrent::blockingFiltered(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor <db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>OutputSequence</db:type>
<db:methodname>blockingFiltered</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">OutputSequence blockingFiltered(Iterator begin, Iterator end, KeepFunctor filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> and returns a new Sequence of kept items. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, a copy of the item is put in the new Sequence. Otherwise, the item will <db:emphasis>not</db:emphasis> appear in the new Sequence.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filtered">filtered</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFilteredReduced">
<db:title>ResultType QtConcurrent::blockingFilteredReduced(const Sequence &amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor <db:emphasis>filterFunction</db:emphasis>, ReduceFunctor <db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingFilteredReduced</db:methodname>
<db:methodparam>
<db:type>const Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingFilteredReduced(const Sequence &amp;sequence, KeepFunctor filterFunction, ReduceFunctor reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filteredReduced">filteredReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingFilteredReduced-1">
<db:title>ResultType QtConcurrent::blockingFilteredReduced(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor <db:emphasis>filterFunction</db:emphasis>, ReduceFunctor <db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingFilteredReduced</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingFilteredReduced(Iterator begin, Iterator end, KeepFunctor filterFunction, ReduceFunctor reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, the <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#filteredReduced">filteredReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMap">
<db:title>void QtConcurrent::blockingMap(Sequence &amp;<db:emphasis>sequence</db:emphasis>, MapFunctor <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>blockingMap</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void blockingMap(Sequence &amp;sequence, MapFunctor function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item in <db:code role="parameter">sequence</db:code>. The <db:code role="parameter">function</db:code> is passed a reference to the item, so that any modifications done to the item will appear in <db:code role="parameter">sequence</db:code>.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMap-1">
<db:title>void QtConcurrent::blockingMap(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>blockingMap</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void blockingMap(Iterator begin, Iterator end, MapFunctor function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. The <db:code role="parameter">function</db:code> is passed a reference to the item, so that any modifications done to the item will appear in the sequence which the iterators belong to.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#map">map</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMapped">
<db:title>OutputSequence QtConcurrent::blockingMapped(const InputSequence &amp;<db:emphasis>sequence</db:emphasis>, MapFunctor <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>OutputSequence</db:type>
<db:methodname>blockingMapped</db:methodname>
<db:methodparam>
<db:type>const InputSequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">OutputSequence blockingMapped(const InputSequence &amp;sequence, MapFunctor function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item in <db:code role="parameter">sequence</db:code> and returns an OutputSequence containing the results. The type of the results will match the type returned my the MapFunctor.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#mapped">mapped</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMapped-1">
<db:title>Sequence QtConcurrent::blockingMapped(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>Sequence</db:type>
<db:methodname>blockingMapped</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">Sequence blockingMapped(Iterator begin, Iterator end, MapFunctor function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> and returns a container with the results. Specify the type of container as the a template argument, like this:</db:para>
<db:programlisting language="cpp">QList&amp;lt;int&amp;gt; ints = QtConcurrent::blockingMapped&amp;lt;QList&amp;lt;int&amp;gt; &amp;gt;(beginIterator, endIterator, fn);
</db:programlisting>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#mapped">mapped</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMappedReduced">
<db:title>ResultType QtConcurrent::blockingMappedReduced(const Sequence &amp;<db:emphasis>sequence</db:emphasis>, MapFunctor <db:emphasis>mapFunction</db:emphasis>, ReduceFunctor <db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingMappedReduced</db:methodname>
<db:methodparam>
<db:type>const Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingMappedReduced(const Sequence &amp;sequence, MapFunctor mapFunction, ReduceFunctor reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is determined by <db:code role="parameter">reduceOptions</db:code>.</db:para>
<db:note>
<db:para>This function will block until all items in the sequence have been processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#mapped">mapped</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="blockingMappedReduced-1">
<db:title>ResultType QtConcurrent::blockingMappedReduced(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor <db:emphasis>mapFunction</db:emphasis>, ReduceFunctor <db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>ResultType</db:type>
<db:methodname>blockingMappedReduced</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">ResultType blockingMappedReduced(Iterator begin, Iterator end, MapFunctor mapFunction, ReduceFunctor reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined.</db:para>
<db:note>
<db:para>This function will block until the iterator reaches the end of the sequence being processed.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrent.xml#blockingMappedReduced">blockingMappedReduced</db:link>()</db:member>
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filter">
<db:title>QFuture&lt;void&gt; QtConcurrent::filter(Sequence &amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor <db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;void&gt;</db:type>
<db:methodname>filter</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;void&gt; filter(Sequence &amp;sequence, KeepFunctor filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, the item is kept in <db:code role="parameter">sequence</db:code>; otherwise, the item is removed from <db:code role="parameter">sequence</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filtered">
<db:title>QFuture&lt;typename Sequence::value_type&gt; QtConcurrent::filtered(const Sequence &amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor <db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;typename Sequence::value_type&gt;</db:type>
<db:methodname>filtered</db:methodname>
<db:methodparam>
<db:type>const Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;typename Sequence::value_type&gt; filtered(const Sequence &amp;sequence, KeepFunctor filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code> and returns a new Sequence of kept items. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, a copy of the item is put in the new Sequence. Otherwise, the item will <db:emphasis>not</db:emphasis> appear in the new Sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filtered-1">
<db:title>QFuture&lt;typename qValueType&lt;Iterator&gt;::value_type&gt; QtConcurrent::filtered(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor <db:emphasis>filterFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;typename qValueType&lt;Iterator&gt;::value_type&gt;</db:type>
<db:methodname>filtered</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;typename qValueType&lt;Iterator&gt;::value_type&gt; filtered(Iterator begin, Iterator end, KeepFunctor filterFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> and returns a new Sequence of kept items. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>, a copy of the item is put in the new Sequence. Otherwise, the item will <db:emphasis>not</db:emphasis> appear in the new Sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filteredReduced">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::filteredReduced(const Sequence &amp;<db:emphasis>sequence</db:emphasis>, KeepFunctor <db:emphasis>filterFunction</db:emphasis>, ReduceFunctor <db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>filteredReduced</db:methodname>
<db:methodparam>
<db:type>const Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; filteredReduced(const Sequence &amp;sequence, KeepFunctor filterFunction, ReduceFunctor reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="filteredReduced-1">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::filteredReduced(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, KeepFunctor <db:emphasis>filterFunction</db:emphasis>, ReduceFunctor <db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>filteredReduced</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>KeepFunctor</db:type>
<db:parameter>filterFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; filteredReduced(Iterator begin, Iterator end, KeepFunctor filterFunction, ReduceFunctor reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">filterFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. If <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code> for an item, that item is then passed to <db:code role="parameter">reduceFunction</db:code>. In other words, the return value is the result of <db:code role="parameter">reduceFunction</db:code> for each item where <db:code role="parameter">filterFunction</db:code> returns <db:code>true</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">filterFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined if <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::UnorderedReduce</db:link>. If <db:code role="parameter">reduceOptions</db:code> is <db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link>, the <db:code role="parameter">reduceFunction</db:code> is called in the order of the original sequence.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentfilter.xml">Concurrent Filter and Filter-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="map">
<db:title>QFuture&lt;void&gt; QtConcurrent::map(Sequence &amp;<db:emphasis>sequence</db:emphasis>, MapFunctor <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;void&gt;</db:type>
<db:methodname>map</db:methodname>
<db:methodparam>
<db:type>Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;void&gt; map(Sequence &amp;sequence, MapFunctor function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item in <db:code role="parameter">sequence</db:code>. The <db:code role="parameter">function</db:code> is passed a reference to the item, so that any modifications done to the item will appear in <db:code role="parameter">sequence</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="map-1">
<db:title>QFuture&lt;void&gt; QtConcurrent::map(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;void&gt;</db:type>
<db:methodname>map</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;void&gt; map(Iterator begin, Iterator end, MapFunctor function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. The <db:code role="parameter">function</db:code> is passed a reference to the item, so that any modifications done to the item will appear in the sequence which the iterators belong to.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapped">
<db:title>QFuture&lt;typename QtPrivate::MapResultType&lt;void, MapFunctor&gt;::ResultType&gt; QtConcurrent::mapped(const Sequence &amp;<db:emphasis>sequence</db:emphasis>, MapFunctor <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;typename QtPrivate::MapResultType&lt;void, MapFunctor&gt;::ResultType&gt;</db:type>
<db:methodname>mapped</db:methodname>
<db:methodparam>
<db:type>const Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;typename QtPrivate::MapResultType&lt;void, MapFunctor&gt;::ResultType&gt; mapped(const Sequence &amp;sequence, MapFunctor function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item in <db:code role="parameter">sequence</db:code> and returns a future with each mapped item as a result. You can use <db:link xlink:href="qfuture-const-iterator.xml">QFuture::const_iterator</db:link> or <db:link xlink:href="qfutureiterator.xml">QFutureIterator</db:link> to iterate through the results.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mapped-1">
<db:title>QFuture&lt;typename QtPrivate::MapResultType&lt;void, MapFunctor&gt;::ResultType&gt; QtConcurrent::mapped(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor <db:emphasis>function</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;typename QtPrivate::MapResultType&lt;void, MapFunctor&gt;::ResultType&gt;</db:type>
<db:methodname>mapped</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;typename QtPrivate::MapResultType&lt;void, MapFunctor&gt;::ResultType&gt; mapped(Iterator begin, Iterator end, MapFunctor function)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">function</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code> and returns a future with each mapped item as a result. You can use <db:link xlink:href="qfuture-const-iterator.xml">QFuture::const_iterator</db:link> or <db:link xlink:href="qfutureiterator.xml">QFutureIterator</db:link> to iterate through the results.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mappedReduced">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::mappedReduced(const Sequence &amp;<db:emphasis>sequence</db:emphasis>, MapFunctor <db:emphasis>mapFunction</db:emphasis>, ReduceFunctor <db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>mappedReduced</db:methodname>
<db:methodparam>
<db:type>const Sequence &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; mappedReduced(const Sequence &amp;sequence, MapFunctor mapFunction, ReduceFunctor reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item in <db:code role="parameter">sequence</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. The order in which <db:code role="parameter">reduceFunction</db:code> is called is determined by <db:code role="parameter">reduceOptions</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mappedReduced-1">
<db:title>QFuture&lt;ResultType&gt; QtConcurrent::mappedReduced(Iterator <db:emphasis>begin</db:emphasis>, Iterator <db:emphasis>end</db:emphasis>, MapFunctor <db:emphasis>mapFunction</db:emphasis>, ReduceFunctor <db:emphasis>reduceFunction</db:emphasis>, QtConcurrent::ReduceOptions <db:emphasis>reduceOptions</db:emphasis> = ReduceOptions(UnorderedReduce | SequentialReduce))</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ResultType&gt;</db:type>
<db:methodname>mappedReduced</db:methodname>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>begin</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Iterator</db:type>
<db:parameter>end</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>MapFunctor</db:type>
<db:parameter>mapFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>ReduceFunctor</db:type>
<db:parameter>reduceFunction</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtConcurrent::ReduceOptions</db:type>
<db:parameter>reduceOptions</db:parameter>
<db:initializer>ReduceOptions(UnorderedReduce | SequentialReduce)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ResultType&gt; mappedReduced(Iterator begin, Iterator end, MapFunctor mapFunction, ReduceFunctor reduceFunction, QtConcurrent::ReduceOptions reduceOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Calls <db:code role="parameter">mapFunction</db:code> once for each item from <db:code role="parameter">begin</db:code> to <db:code role="parameter">end</db:code>. The return value of each <db:code role="parameter">mapFunction</db:code> is passed to <db:code role="parameter">reduceFunction</db:code>.</db:para>
<db:para>Note that while <db:code role="parameter">mapFunction</db:code> is called concurrently, only one thread at a time will call <db:code role="parameter">reduceFunction</db:code>. By default, the order in which <db:code role="parameter">reduceFunction</db:code> is called is undefined.</db:para>
<db:note>
<db:para><db:link xlink:href="qtconcurrent.xml#ReduceOption-enum">QtConcurrent::OrderedReduce</db:link> results in the ordered reduction.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentmap.xml">Concurrent Map and Map-Reduce</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="run">
<db:title>QFuture&lt;T&gt; QtConcurrent::run(Function <db:emphasis>function</db:emphasis>, <db:emphasis>...</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>run</db:methodname>
<db:methodparam>
<db:type>Function</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>...</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; run(Function function, ...)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Equivalent to</db:para>
<db:programlisting language="cpp">QtConcurrent::run(QThreadPool::globalInstance(), function, ...);
</db:programlisting>
<db:para>Runs <db:code role="parameter">function</db:code> in a separate thread. The thread is taken from the global <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link>. Note that <db:code role="parameter">function</db:code> may not run immediately; <db:code role="parameter">function</db:code> will only be run once a thread becomes available.</db:para>
<db:para>T is the same type as the return value of <db:code role="parameter">function</db:code>. Non-void return values can be accessed via the <db:link xlink:href="qfuture.xml#result">QFuture::result</db:link>() function.</db:para>
<db:para>Note that the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned by QtConcurrent::run() does not support canceling, pausing, or progress reporting. The <db:link xlink:href="qfuture.xml">QFuture</db:link> returned can only be used to query for the running/finished status and the return value of the function.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentrun.xml">Concurrent Run</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="run-1">
<db:title>[since 5.4] QFuture&lt;T&gt; QtConcurrent::run(QThreadPool *<db:emphasis>pool</db:emphasis>, Function <db:emphasis>function</db:emphasis>, <db:emphasis>...</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>run</db:methodname>
<db:methodparam>
<db:type>QThreadPool *</db:type>
<db:parameter>pool</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Function</db:type>
<db:parameter>function</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>...</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; run(QThreadPool *pool, Function function, ...)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Runs <db:code role="parameter">function</db:code> in a separate thread. The thread is taken from the <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link> <db:code role="parameter">pool</db:code>. Note that <db:code role="parameter">function</db:code> may not run immediately; <db:code role="parameter">function</db:code> will only be run once a thread becomes available.</db:para>
<db:para>T is the same type as the return value of <db:code role="parameter">function</db:code>. Non-void return values can be accessed via the <db:link xlink:href="qfuture.xml#result">QFuture::result</db:link>() function.</db:para>
<db:para>Note that the <db:link xlink:href="qfuture.xml">QFuture</db:link> returned by QtConcurrent::run() does not support canceling, pausing, or progress reporting. The <db:link xlink:href="qfuture.xml">QFuture</db:link> returned can only be used to query for the running/finished status and the return value of the function.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtconcurrentrun.xml">Concurrent Run</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QtConcurrent</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qtconcurrent.xml">QtConcurrent</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-type-documentation">
<db:title>Obsolete Type Documentation</db:title>
<db:section xml:id="Exception-typedef">
<db:title>QtConcurrent::Exception</db:title>
<db:typedefsynopsis>
<db:typedefname>Exception</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>This typedef is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qexception.xml">QException</db:link> from <db:link xlink:href="qtcore-index.xml">Qt Core</db:link> instead.</db:para>
</db:section>
<db:section xml:id="UnhandledException-typedef">
<db:title>QtConcurrent::UnhandledException</db:title>
<db:typedefsynopsis>
<db:typedefname>UnhandledException</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>This typedef is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qunhandledexception.xml">QUnhandledException</db:link> from <db:link xlink:href="qtcore-index.xml">Qt Core</db:link> instead.</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
