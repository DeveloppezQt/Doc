<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>RHI Window Example</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>This example shows how to create a minimal <db:link xlink:href="qwindow.xml">QWindow</db:link>-based application using <db:link xlink:href="qrhi.xml">QRhi</db:link>.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/rhiwindow_example.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:para>Qt 6.6 starts offering its accelerated 3D API and shader abstraction layer for application use as well. Applications can now use the same 3D graphics classes Qt itself uses to implement the Qt Quick scenegraph or the Qt Quick 3D engine. In earlier Qt versions <db:link xlink:href="qrhi.xml">QRhi</db:link> and the related classes were all private APIs. From 6.6 on these classes are in a similar category as QPA family of classes: neither fully public nor private, but something in-between, with a more limited compatibility promise compared to public APIs. On the other hand, <db:link xlink:href="qrhi.xml">QRhi</db:link> and the related classes now come with full documentation similarly to public APIs.</db:para>
<db:para>There are multiple ways to use <db:link xlink:href="qrhi.xml">QRhi</db:link>, the example here shows the most low-level approach: targeting a <db:link xlink:href="qwindow.xml">QWindow</db:link>, while not using Qt Quick, Qt Quick 3D, or Widgets in any form, and setting up all the rendering and windowing infrastructure in the application.</db:para>
<db:para>In contrast, when writing a QML application with Qt Quick or Qt Quick 3D, and wanting to add <db:link xlink:href="qrhi.xml">QRhi</db:link>-based rendering to it, such an application is going to rely on the window and rendering infrastructure Qt Quick has already initialized, and it is likely going to query an existing <db:link xlink:href="qrhi.xml">QRhi</db:link> instance from the QQuickWindow. There dealing with <db:link xlink:href="qrhi.xml#create">QRhi::create</db:link>(), platform/API specifics such as <db:link xlink:href="qvulkaninstance.xml">Vulkan instances</db:link>, or correctly handling <db:link xlink:href="qexposeevent.xml">expose</db:link> and resize events for the window are all managed by Qt Quick. Whereas in this example, all that is managed and taken care of by the application itself.</db:para>
<db:note>
<db:para>For QWidget-based applications in particular, it should be noted that QWidget::createWindowContainer() allows embedding a <db:link xlink:href="qwindow.xml">QWindow</db:link> (backed by a native window) into the widget-based user interface. Therefore, the <db:code>HelloWindow</db:code> class from this example is reusable in QWidget-based applications, assuming the necessary initialization from <db:code>main()</db:code> is in place as well.</db:para>
</db:note>
<db:section xml:id="A3d-api-support">
<db:title>3D API Support</db:title>
<db:para>The application supports all the current <db:link xlink:href="qrhi.xml#Implementation-enum">QRhi backends</db:link>. When no command-line arguments are specified, platform-specific defaults are used: Direct 3D 11 on Windows, OpenGL on Linux, Metal on macOS/iOS.</db:para>
<db:para>Running with <db:code>--help</db:code> shows the available command-line options:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>-d or –d3d11 for Direct 3D 11</db:para>
</db:listitem>
<db:listitem>
<db:para>-D or –d3d12 for Direct 3D 12</db:para>
</db:listitem>
<db:listitem>
<db:para>-m or –metal for Metal</db:para>
</db:listitem>
<db:listitem>
<db:para>-v or –vulkan for Vulkan</db:para>
</db:listitem>
<db:listitem>
<db:para>-g or –opengl for OpenGL or OpenGL ES</db:para>
</db:listitem>
<db:listitem>
<db:para>-n or –null for the <db:link xlink:href="qrhi.xml#Implementation-enum">Null backend</db:link></db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="build-system-notes">
<db:title>Build System Notes</db:title>
<db:para>This application relies solely on the Qt GUI module. It does not use Qt Widgets or Qt Quick.</db:para>
<db:para>In order to access the RHI APIs, which are available to all Qt applications but come with a limited compatibility promise, the <db:code>target_link_libraries</db:code> CMake command lists <db:code>Qt6::GuiPrivate</db:code>. This is what enables the <db:code>#include &lt;rhi/qrhi.h&gt;</db:code> include statement to compile successfully.</db:para>
</db:section>
<db:section xml:id="features">
<db:title>Features</db:title>
<db:para>The application features:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>A resizable <db:link xlink:href="qwindow.xml">QWindow</db:link>,</db:para>
</db:listitem>
<db:listitem>
<db:para>a swapchain and depth-stencil buffer that properly follows the size of the window,</db:para>
</db:listitem>
<db:listitem>
<db:para>logic to initialize, render, and tear down at the appropriate time based on events such as <db:link xlink:href="qexposeevent.xml">QExposeEvent</db:link> and <db:link xlink:href="qplatformsurfaceevent.xml">QPlatformSurfaceEvent</db:link>,</db:para>
</db:listitem>
<db:listitem>
<db:para>rendering a fullscreen textured quad, using a texture the contents of which is generated in a <db:link xlink:href="qimage.xml">QImage</db:link> via <db:link xlink:href="qpainter.xml">QPainter</db:link> (using the raster paint engine, i.e. the generating of the image's pixel data is all CPU-based, that data is then uploaded into a GPU texture),</db:para>
</db:listitem>
<db:listitem>
<db:para>rendering a triangle with blending and depth testing enabled, using a perspective projection, while applying a model transform that changes on every frame,</db:para>
</db:listitem>
<db:listitem>
<db:para>an efficient, cross-platform render loop using <db:link xlink:href="qwindow.xml#requestUpdate">requestUpdate</db:link>().</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="shaders">
<db:title>Shaders</db:title>
<db:para>The application uses two sets of vertex and fragment shader pairs:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>one for the fullscreen quad, which uses no vertex inputs and the fragment shader samples a texture (<db:code>quad.vert</db:code>, <db:code>quad.frag</db:code>),</db:para>
</db:listitem>
<db:listitem>
<db:para>and another pair for the triangle, where vertex positions and colors are provided in a vertex buffer and a modelview-projection matrix is provided in a uniform buffer (<db:code>color.vert</db:code>, <db:code>color.frag</db:code>).</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The shaders are written as Vulkan-compatible GLSL source code.</db:para>
<db:para>Due to being a Qt GUI module example, this example cannot have a dependency on the <db:link xlink:href="">Qt Shader Tools</db:link> module. This means that CMake helper functions such as <db:code>qt_add_shaders</db:code> are not available for use. Therefore, the example has the pre-processed <db:code>.qsb</db:code> files included in the <db:code>shaders/prebuilt</db:code> folder, and they are simply included within the executable via <db:code>qt_add_resources</db:code>. This approach is not generally recommended for applications, consider rather using <db:link xlink:href="">qt_add_shaders</db:link>, which avoids the need to manually generate and manage the <db:code>.qsb</db:code> files.</db:para>
<db:para>To generate the <db:code>.qsb</db:code> files for this example, the command <db:code>qsb --qt6 color.vert -o prebuilt/color.vert.qsb</db:code> etc. was used. This leads to compiling to <db:link xlink:href="https://www.khronos.org/spir/">SPIR-V</db:link> and than transpiling into GLSL (<db:code>100 es</db:code> and <db:code>120</db:code>), HLSL (5.0), and MSL (1.2). All the shader versions are then packed together into a <db:link xlink:href="qshader.xml">QShader</db:link> and serialized to disk.</db:para>
</db:section>
<db:section xml:id="api-specific-initialization">
<db:title>API-specific Initialization</db:title>
<db:para>For some of the 3D APIs the main() function has to perform the appropriate API-specific initialiation, e.g. to create a <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> when using Vulkan. For OpenGL we have to ensure a depth buffer is available, this is done via <db:link xlink:href="qsurfaceformat.xml">QSurfaceFormat</db:link>. These steps are not in the scope of <db:link xlink:href="qrhi.xml">QRhi</db:link> since <db:link xlink:href="qrhi.xml">QRhi</db:link> backends for OpenGL or Vulkan build on the existing Qt facilities such as <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> or <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link>.</db:para>
<db:programlisting language="cpp">   // For OpenGL, to ensure there is a depth/stencil buffer for the window.
   // With other APIs this is under the application's control (QRhiRenderBuffer etc.)
   // and so no special setup is needed for those.
   QSurfaceFormat fmt;
   fmt.setDepthBufferSize(24);
   fmt.setStencilBufferSize(8);
   // Special case macOS to allow using OpenGL there.
   // (the default Metal is the recommended approach, though)
   // gl_VertexID is a GLSL 130 feature, and so the default OpenGL 2.1 context
   // we get on macOS is not sufficient.
#ifdef Q_OS_MACOS
   fmt.setVersion(4, 1);
   fmt.setProfile(QSurfaceFormat::CoreProfile);
#endif
   QSurfaceFormat::setDefaultFormat(fmt);

   // For Vulkan.
#if QT_CONFIG(vulkan)
   QVulkanInstance inst;
   if (graphicsApi == QRhi::Vulkan) {
       // Request validation, if available. This is completely optional
       // and has a performance impact, and should be avoided in production use.
       inst.setLayers({ &quot;VK_LAYER_KHRONOS_validation&quot; });
       // Play nice with QRhi.
       inst.setExtensions(QRhiVulkanInitParams::preferredInstanceExtensions());
       if (!inst.create()) {
           qWarning(&quot;Failed to create Vulkan instance, switching to OpenGL&quot;);
           graphicsApi = QRhi::OpenGLES2;
       }
   }
#endif
</db:programlisting>
<db:note>
<db:para>For Vulkan, note how <db:link xlink:href="qrhivulkaninitparams.xml#preferredInstanceExtensions">QRhiVulkanInitParams::preferredInstanceExtensions</db:link>() is taken into account to ensure the appropriate extensions are enabled.</db:para>
</db:note>
<db:para><db:code>HelloWindow</db:code> is a subclass of <db:code>RhiWindow</db:code>, which in turn is a <db:link xlink:href="qwindow.xml">QWindow</db:link>. <db:code>RhiWindow</db:code> contains everything needed to manage a resizable window with a swapchain (and depth-stencil buffer), and is potentially reusable in other applications as well. <db:code>HelloWindow</db:code> contains the rendering logic specific to this particular example application.</db:para>
<db:para>In the <db:link xlink:href="qwindow.xml">QWindow</db:link> subclass constructor the surface type is set based on the selected 3D API.</db:para>
<db:programlisting language="cpp">RhiWindow::RhiWindow(QRhi::Implementation graphicsApi)
    : m_graphicsApi(graphicsApi)
{
    switch (graphicsApi) {
    case QRhi::OpenGLES2:
        setSurfaceType(OpenGLSurface);
        break;
    case QRhi::Vulkan:
        setSurfaceType(VulkanSurface);
        break;
    case QRhi::D3D11:
    case QRhi::D3D12:
        setSurfaceType(Direct3DSurface);
        break;
    case QRhi::Metal:
        setSurfaceType(MetalSurface);
        break;
    case QRhi::Null:
        break; // RasterSurface
    }
}
</db:programlisting>
<db:para>Creating and initializing a <db:link xlink:href="qrhi.xml">QRhi</db:link> object is implemented in RhiWindow::init(). Note that this is invoked only when the window is <db:code>renderable</db:code>, which is indicated by an <db:link xlink:href="qexposeevent.xml">expose event</db:link>.</db:para>
<db:para>Depending on which 3D API we use, the appropriate InitParams struct needs to be passed to <db:link xlink:href="qrhi.xml#create">QRhi::create</db:link>(). With OpenGL for example, a <db:link xlink:href="qoffscreensurface.xml">QOffscreenSurface</db:link> (or some other <db:link xlink:href="qsurface.xml">QSurface</db:link>) must be created by the application and provided for use to the <db:link xlink:href="qrhi.xml">QRhi</db:link>. With Vulkan, a successfully initialized <db:link xlink:href="qvulkaninstance.xml">QVulkanInstance</db:link> is required. Others, such as Direct 3D or Metal need no additional information to be able to initialize.</db:para>
<db:programlisting language="cpp">void RhiWindow::init()
{
    if (m_graphicsApi == QRhi::Null) {
        QRhiNullInitParams params;
        m_rhi.reset(QRhi::create(QRhi::Null, &amp;params));
    }

#if QT_CONFIG(opengl)
    if (m_graphicsApi == QRhi::OpenGLES2) {
        m_fallbackSurface.reset(QRhiGles2InitParams::newFallbackSurface());
        QRhiGles2InitParams params;
        params.fallbackSurface = m_fallbackSurface.get();
        params.window = this;
        m_rhi.reset(QRhi::create(QRhi::OpenGLES2, &amp;params));
    }
#endif

#if QT_CONFIG(vulkan)
    if (m_graphicsApi == QRhi::Vulkan) {
        QRhiVulkanInitParams params;
        params.inst = vulkanInstance();
        params.window = this;
        m_rhi.reset(QRhi::create(QRhi::Vulkan, &amp;params));
    }
#endif

#ifdef Q_OS_WIN
    if (m_graphicsApi == QRhi::D3D11) {
        QRhiD3D11InitParams params;
        // Enable the debug layer, if available. This is optional
        // and should be avoided in production builds.
        params.enableDebugLayer = true;
        m_rhi.reset(QRhi::create(QRhi::D3D11, &amp;params));
    } else if (m_graphicsApi == QRhi::D3D12) {
        QRhiD3D12InitParams params;
        // Enable the debug layer, if available. This is optional
        // and should be avoided in production builds.
        params.enableDebugLayer = true;
        m_rhi.reset(QRhi::create(QRhi::D3D12, &amp;params));
    }
#endif

#if QT_CONFIG(metal)
    if (m_graphicsApi == QRhi::Metal) {
        QRhiMetalInitParams params;
        m_rhi.reset(QRhi::create(QRhi::Metal, &amp;params));
    }
#endif

    if (!m_rhi)
        qFatal(&quot;Failed to create RHI backend&quot;);
</db:programlisting>
<db:para>Apart from this, everything else, all the rendering code, is fully cross-platform and has no branching or conditions specific to any of the 3D API.</db:para>
</db:section>
<db:section xml:id="expose-events">
<db:title>Expose Events</db:title>
<db:para>What <db:code>renderable</db:code> exactly means is platform-specific. For example, on macOS a window that is fully obscured (fully behind some other window) is not renderable, whereas on Windows obscuring has no significance. Fortunately, the application needs no special knowledge about this: Qt's platform plugins abstract the differences behind the expose event. However, the <db:link xlink:href="qwindow.xml#exposeEvent">exposeEvent</db:link>() reimplementation also needs to be aware that an empty output size (e.g. width and height of 0) is also something that should be treated as a non-renderable situation. On Windows for example, this is what is going to happen when minimizing the window. Hence the check based on QRhiSwapChain::surfacePixelSize().</db:para>
<db:para>This implementation of expose event handling attempts to be robust, safe, and portable. Qt Quick itself also implements a very similar logic in its render loops.</db:para>
<db:programlisting language="cpp">void RhiWindow::exposeEvent(QExposeEvent *)
{
    // initialize and start rendering when the window becomes usable for graphics purposes
    if (isExposed() &amp;&amp; !m_initialized) {
        init();
        resizeSwapChain();
        m_initialized = true;
    }

    const QSize surfaceSize = m_hasSwapChain ? m_sc-&gt;surfacePixelSize() : QSize();

    // stop pushing frames when not exposed (or size is 0)
    if ((!isExposed() || (m_hasSwapChain &amp;&amp; surfaceSize.isEmpty())) &amp;&amp; m_initialized &amp;&amp; !m_notExposed)
        m_notExposed = true;

    // Continue when exposed again and the surface has a valid size. Note that
    // surfaceSize can be (0, 0) even though size() reports a valid one, hence
    // trusting surfacePixelSize() and not QWindow.
    if (isExposed() &amp;&amp; m_initialized &amp;&amp; m_notExposed &amp;&amp; !surfaceSize.isEmpty()) {
        m_notExposed = false;
        m_newlyExposed = true;
    }

    // always render a frame on exposeEvent() (when exposed) in order to update
    // immediately on window resize.
    if (isExposed() &amp;&amp; !surfaceSize.isEmpty())
        render();
}
</db:programlisting>
<db:para>In RhiWindow::render(), which is invoked in response to the <db:link xlink:href="qevent.xml#Type-enum">UpdateRequest</db:link> event generated by <db:link xlink:href="qwindow.xml#requestUpdate">requestUpdate</db:link>(), the following check is in place, to prevent attempting to render when the swapchain initialization failed, or when the window became non-renderable.</db:para>
<db:programlisting language="cpp">void RhiWindow::render()
{
    if (!m_hasSwapChain || m_notExposed)
        return;
</db:programlisting>
</db:section>
<db:section xml:id="swapchain-depth-stencil-buffer-and-resizing">
<db:title>Swapchain, Depth-Stencil buffer, and Resizing</db:title>
<db:para>To render to the <db:link xlink:href="qwindow.xml">QWindow</db:link>, a <db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link> is needed. In addition, a <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> acting as the depth-stencil buffer is created as well since the application demonstrates how depth testing can be enabled in a graphics pipeline. With some legacy 3D APIs managing the depth/stencil buffer for a window is part of the corresponding windowing system interface API (EGL, WGL, GLX, etc., meaning the depth/stencil buffer is implicitly managed together with the <db:code>window surface</db:code>), whereas with modern APIs managing the depth-stencil buffer for a window-based render target is no different from offscreen render targets. <db:link xlink:href="qrhi.xml">QRhi</db:link> abstracts this, but for best performance it still needs to be indicated that the <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> is <db:link xlink:href="qrhirenderbuffer.xml#Flag-enum">used with together with a QRhiSwapChain</db:link>.</db:para>
<db:para>The <db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link> is associated with the <db:link xlink:href="qwindow.xml">QWindow</db:link> and the depth/stencil buffer.</db:para>
<db:programlisting language="cpp">    std::unique_ptr&lt;QRhiSwapChain&gt; m_sc;
    std::unique_ptr&lt;QRhiRenderBuffer&gt; m_ds;
    std::unique_ptr&lt;QRhiRenderPassDescriptor&gt; m_rp;

    m_sc.reset(m_rhi-&gt;newSwapChain());
    m_ds.reset(m_rhi-&gt;newRenderBuffer(QRhiRenderBuffer::DepthStencil,
                                      QSize(), // no need to set the size here, due to UsedWithSwapChainOnly
                                      1,
                                      QRhiRenderBuffer::UsedWithSwapChainOnly));
    m_sc-&gt;setWindow(this);
    m_sc-&gt;setDepthStencil(m_ds.get());
    m_rp.reset(m_sc-&gt;newCompatibleRenderPassDescriptor());
    m_sc-&gt;setRenderPassDescriptor(m_rp.get());
</db:programlisting>
<db:para>When the window size changes, the swapchain needs to be resized as well. This is implemented in resizeSwapChain().</db:para>
<db:programlisting language="cpp">void RhiWindow::resizeSwapChain()
{
    m_hasSwapChain = m_sc-&gt;createOrResize(); // also handles m_ds

    const QSize outputSize = m_sc-&gt;currentPixelSize();
    m_viewProjection = m_rhi-&gt;clipSpaceCorrMatrix();
    m_viewProjection.perspective(45.0f, outputSize.width() / (float) outputSize.height(), 0.01f, 1000.0f);
    m_viewProjection.translate(0, 0, -4);
}
</db:programlisting>
<db:para>Unlike other <db:link xlink:href="qrhiresource.xml">QRhiResource</db:link> subclasses, <db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link> features slightly different semantics when it comes to its create-function. As the name, <db:link xlink:href="">createOrResize()</db:link>, suggests, this needs to be called whenever it is known that the output window size may be out of sync with what the swapchain was last initialized. The associated <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link> for depth-stencil gets its size set automatically, and <db:link xlink:href="">create()</db:link> is called on it implicitly from the swapchain's createOrResize().</db:para>
<db:para>This is also a convenient place to (re)calculate the projection and view matrices since the perspective projection we set up depends on the output aspect ratio.</db:para>
<db:note>
<db:para>To eliminate coordinate system differences, the <db:link xlink:href="qrhi.xml#clipSpaceCorrMatrix">a backend/API-specific &quot;correction&quot; matrix</db:link> is queried from <db:link xlink:href="qrhi.xml">QRhi</db:link> and baked in to the projection matrix. This is what allows the application to work with OpenGL-style vertex data, assuming a coordinate system with the origin at the bottom-left.</db:para>
</db:note>
<db:para>The resizeSwapChain() function is called from RhiWindow::render() when it is discovered that the currently reported size is not the same anymore as what the swapchain was last initialized with.</db:para>
<db:para>See QRhiSwapChain::currentPixelSize() and QRhiSwapChain::surfacePixelSize() for further details.</db:para>
<db:para>High DPI support is built-in: the sizes, as the naming indicates, are always in pixels, taking the window-specific <db:link xlink:href="qwindow.xml#devicePixelRatio">scale factor</db:link> into account. On the <db:link xlink:href="qrhi.xml">QRhi</db:link> (and 3D API) level there is no concept of high DPI scaling, everything is always in pixels. This means that a <db:link xlink:href="qwindow.xml">QWindow</db:link> with a size() of 1280x720 and a devicePixelRatio() of 2 is a render target (swapchain) with a (pixel) size of 2560x1440.</db:para>
<db:programlisting language="cpp">    // If the window got resized or newly exposed, resize the swapchain. (the
    // newly-exposed case is not actually required by some platforms, but is
    // here for robustness and portability)
    //
    // This (exposeEvent + the logic here) is the only safe way to perform
    // resize handling. Note the usage of the RHI's surfacePixelSize(), and
    // never QWindow::size(). (the two may or may not be the same under the hood,
    // depending on the backend and platform)
    //
    if (m_sc-&gt;currentPixelSize() != m_sc-&gt;surfacePixelSize() || m_newlyExposed) {
        resizeSwapChain();
        if (!m_hasSwapChain)
            return;
        m_newlyExposed = false;
    }
</db:programlisting>
</db:section>
<db:section xml:id="render-loop">
<db:title>Render Loop</db:title>
<db:para>The application renders continuously, throttled by the presentation rate (vsync). This is ensured by calling <db:link xlink:href="qwindow.xml#requestUpdate">requestUpdate</db:link>() from RhiWindow::render() when the currently recorded frame has been submitted.</db:para>
<db:programlisting language="cpp">    m_rhi-&gt;endFrame(m_sc.get());

    // Always request the next frame via requestUpdate(). On some platforms this is backed
    // by a platform-specific solution, e.g. CVDisplayLink on macOS, which is potentially
    // more efficient than a timer, queued metacalls, etc.
    requestUpdate();
}
</db:programlisting>
<db:para>This eventually leads to getting a <db:link xlink:href="qevent.xml#Type-enum">UpdateRequest</db:link> event. This is handled in the reimplementation of event().</db:para>
<db:programlisting language="cpp">bool RhiWindow::event(QEvent *e)
{
    switch (e-&gt;type()) {
    case QEvent::UpdateRequest:
        render();
        break;

    case QEvent::PlatformSurface:
        // this is the proper time to tear down the swapchain (while the native window and surface are still around)
        if (static_cast&lt;QPlatformSurfaceEvent *&gt;(e)-&gt;surfaceEventType() == QPlatformSurfaceEvent::SurfaceAboutToBeDestroyed)
            releaseSwapChain();
        break;

    default:
        break;
    }

    return QWindow::event(e);
}
</db:programlisting>
</db:section>
<db:section xml:id="resource-and-pipeline-setup">
<db:title>Resource and Pipeline Setup</db:title>
<db:para>The application records a single render pass that issues two draw calls, with two different graphics pipelines. One is the &quot;background&quot;, with the texture containing the <db:link xlink:href="qpainter.xml">QPainter</db:link>-generated image, then a single triangle is rendered on top with blending enabled.</db:para>
<db:para>The vertex and uniform buffer used with the triangle is created like this. The size of the uniform buffer is 68 bytes since the shader specific a <db:code>mat4</db:code> and a <db:code>float</db:code> member in the uniform block. Watch out for the <db:link xlink:href="https://registry.khronos.org/OpenGL/specs/gl/glspec45.core.pdf#page=159">std140 layout rules</db:link>. This presents no surprises in this example since the <db:code>float</db:code> member that follows the <db:code>mat4</db:code> has the correct alignment without any additional padding, but it may become relevant in other applications, especially when working with types such as <db:code>vec2</db:code> or <db:code>vec3</db:code>. When in doubt, consider checking the <db:link xlink:href="qshaderdescription.xml">QShaderDescription</db:link> for the <db:link xlink:href="qshader.xml#description">QShader</db:link>, or, what is often more convenient, run the <db:code>qsb</db:code> tool on the <db:code>.qsb</db:code> file with the <db:code>-d</db:code> argument to inspect the metadata in human-readable form. The printed information includes, among other things, the uniform block member offsets, sizes, and the total size in bytes of each uniform block.</db:para>
<db:programlisting language="cpp">void HelloWindow::customInit()
{
    m_initialUpdates = m_rhi-&gt;nextResourceUpdateBatch();

    m_vbuf.reset(m_rhi-&gt;newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertexData)));
    m_vbuf-&gt;create();
    m_initialUpdates-&gt;uploadStaticBuffer(m_vbuf.get(), vertexData);

    static const quint32 UBUF_SIZE = 68;
    m_ubuf.reset(m_rhi-&gt;newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, UBUF_SIZE));
    m_ubuf-&gt;create();
</db:programlisting>
<db:para>The vertex and fragment shaders both need a uniform buffer at binding point 0. This is ensured by the <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> object. The graphics pipeline is then setup with the shaders and a number of additional information. The example also relies on a number of convenient defaults, e.g. the primitive topology is <db:link xlink:href="qrhigraphicspipeline.xml#Topology-enum">Triangles</db:link>, but that is the default, and therefore it is not explicitly set. See <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> for further details.</db:para>
<db:para>In addition to specifying the topology and various state, the pipeline must also be associated with:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The vertex input layout in form of a <db:link xlink:href="qrhivertexinputlayout.xml">QRhiVertexInputLayout</db:link>. This specifies the type and component count for each vertex input location, the total stride in bytes per vertex, and other related data. <db:link xlink:href="qrhivertexinputlayout.xml">QRhiVertexInputLayout</db:link> only holds data, not actual native resources, and is copiable.</db:para>
</db:listitem>
<db:listitem>
<db:para>A valid and successfully initialized <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> object. This describes the layout of the resource bindings (uniform buffers, textures, samplers) the shaders expect. This must either by the <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link> used when recording the draw calls, or another that is <db:link xlink:href="qrhishaderresourcebindings.xml#isLayoutCompatible">layout-compatible with it</db:link>. This simple application takes the former approach.</db:para>
</db:listitem>
<db:listitem>
<db:para>A valid <db:link xlink:href="qrhirenderpassdescriptor.xml">QRhiRenderPassDescriptor</db:link> object. This must be retrieved from, or <db:link xlink:href="">be compatible with</db:link> the render target. The example uses the former, by creating a <db:link xlink:href="qrhirenderpassdescriptor.xml">QRhiRenderPassDescriptor</db:link> object via QRhiSwapChain::newCompatibleRenderPassDescriptor().</db:para>
</db:listitem>
</db:itemizedlist>
<db:programlisting language="cpp">   m_colorTriSrb.reset(m_rhi-&gt;newShaderResourceBindings());
   static const QRhiShaderResourceBinding::StageFlags visibility =
           QRhiShaderResourceBinding::VertexStage | QRhiShaderResourceBinding::FragmentStage;
   m_colorTriSrb-&gt;setBindings({
           QRhiShaderResourceBinding::uniformBuffer(0, visibility, m_ubuf.get())
   });
   m_colorTriSrb-&gt;create();

   m_colorPipeline.reset(m_rhi-&gt;newGraphicsPipeline());
   // Enable depth testing; not quite needed for a simple triangle, but we
   // have a depth-stencil buffer so why not.
   m_colorPipeline-&gt;setDepthTest(true);
   m_colorPipeline-&gt;setDepthWrite(true);
   // Blend factors default to One, OneOneMinusSrcAlpha, which is convenient.
   QRhiGraphicsPipeline::TargetBlend premulAlphaBlend;
   premulAlphaBlend.enable = true;
   m_colorPipeline-&gt;setTargetBlends({ premulAlphaBlend });
   m_colorPipeline-&gt;setShaderStages({
       { QRhiShaderStage::Vertex, getShader(QLatin1String(&quot;:/color.vert.qsb&quot;)) },
       { QRhiShaderStage::Fragment, getShader(QLatin1String(&quot;:/color.frag.qsb&quot;)) }
   });
   QRhiVertexInputLayout inputLayout;
   inputLayout.setBindings({
       { 5 * sizeof(float) }
   });
   inputLayout.setAttributes({
       { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
       { 0, 1, QRhiVertexInputAttribute::Float3, 2 * sizeof(float) }
   });
   m_colorPipeline-&gt;setVertexInputLayout(inputLayout);
   m_colorPipeline-&gt;setShaderResourceBindings(m_colorTriSrb.get());
   m_colorPipeline-&gt;setRenderPassDescriptor(m_rp.get());
   m_colorPipeline-&gt;create();
</db:programlisting>
<db:para>getShader() is a helper function that loads a <db:code>.qsb</db:code> file and deserializes a <db:link xlink:href="qshader.xml">QShader</db:link> from it.</db:para>
<db:programlisting language="cpp">static QShader getShader(const QString &amp;name)
{
    QFile f(name);
    if (f.open(QIODevice::ReadOnly))
        return QShader::fromSerialized(f.readAll());

    return QShader();
}
</db:programlisting>
<db:para>The <db:code>color.vert</db:code> shader specifies the following as the vertex inputs:</db:para>
<db:programlisting language="cpp" role="bad">layout(location = 0) in vec4 position;
layout(location = 1) in vec3 color;
</db:programlisting>
<db:para>The C++ code however provides vertex data as 2 floats for position, with 3 floats for the color interleaved. (<db:code>x</db:code>, <db:code>y</db:code>, <db:code>r</db:code>, <db:code>g</db:code>, <db:code>b</db:code> for each vertex) This is why the stride is <db:code>5 * sizeof(float)</db:code> and the inputs for locations 0 and 1 are specified as <db:code>Float2</db:code> and <db:code>Float3</db:code>, respectively. This is valid, and the <db:code>z</db:code> and <db:code>w</db:code> of the <db:code>vec4</db:code> position will get set automatically.</db:para>
</db:section>
<db:section xml:id="rendering">
<db:title>Rendering</db:title>
<db:para>Recording a frame is started by calling <db:link xlink:href="qrhi.xml#beginFrame">QRhi::beginFrame</db:link>() and finished by calling <db:link xlink:href="qrhi.xml#endFrame">QRhi::endFrame</db:link>().</db:para>
<db:programlisting language="cpp">    QRhi::FrameOpResult result = m_rhi-&gt;beginFrame(m_sc.get());
    if (result == QRhi::FrameOpSwapChainOutOfDate) {
        resizeSwapChain();
        if (!m_hasSwapChain)
            return;
        result = m_rhi-&gt;beginFrame(m_sc.get());
    }
    if (result != QRhi::FrameOpSuccess) {
        qWarning(&quot;beginFrame failed with %d, will retry&quot;, result);
        requestUpdate();
        return;
    }

    customRender();
</db:programlisting>
<db:para>Some of the resources (buffers, textures) have static data in the application, meaning the content never changes. The vertex buffer's content is provided in the initialization step for example, and is not changed afterwards. These data update operations are recorded in <db:code>m_initialUpdates</db:code>. When not yet done, the commands on this resource update batch are merged into the per-frame batch.</db:para>
<db:programlisting language="cpp">void HelloWindow::customRender()
{
    QRhiResourceUpdateBatch *resourceUpdates = m_rhi-&gt;nextResourceUpdateBatch();

    if (m_initialUpdates) {
        resourceUpdates-&gt;merge(m_initialUpdates);
        m_initialUpdates-&gt;release();
        m_initialUpdates = nullptr;
    }
</db:programlisting>
<db:para>Having a per-frame resource update batch is necessary since the uniform buffer contents with the modelview-projection matrix and the opacity changes on every frame.</db:para>
<db:programlisting language="cpp">    m_rotation += 1.0f;
    QMatrix4x4 modelViewProjection = m_viewProjection;
    modelViewProjection.rotate(m_rotation, 0, 1, 0);
    resourceUpdates-&gt;updateDynamicBuffer(m_ubuf.get(), 0, 64, modelViewProjection.constData());
    m_opacity += m_opacityDir * 0.005f;
    if (m_opacity &lt; 0.0f || m_opacity &gt; 1.0f) {
        m_opacityDir *= -1;
        m_opacity = qBound(0.0f, m_opacity, 1.0f);
    }
    resourceUpdates-&gt;updateDynamicBuffer(m_ubuf.get(), 64, 4, &amp;m_opacity);
</db:programlisting>
<db:para>To begin recording the render pass, a <db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link> is queried, and the output size is determined, which will be useful for setting up the viewport and resizing our fullscreen texture, if needed.</db:para>
<db:programlisting language="cpp">    QRhiCommandBuffer *cb = m_sc-&gt;currentFrameCommandBuffer();
    const QSize outputSizeInPixels = m_sc-&gt;currentPixelSize();
</db:programlisting>
<db:para>Starting a render pass implies clearing the render target's color and depth-stencil buffers (unless the render target flags indicate otherwise, but that is only an option for texture-based render targets). Here we specify black for color, 1.0f for depth, and 0 for stencil (unused). The last argument, <db:code>resourceUpdates</db:code>, is what ensures that the data update commands recorded on the batch get committed. Alternatively, we could have used <db:link xlink:href="qrhicommandbuffer.xml#resourceUpdate">QRhiCommandBuffer::resourceUpdate</db:link>() instead. The render pass targets a swapchain, hence calling <db:link xlink:href="qrhiswapchain.xml#currentFrameRenderTarget">currentFrameRenderTarget</db:link>() to get a valid <db:link xlink:href="qrhirendertarget.xml">QRhiRenderTarget</db:link>.</db:para>
<db:programlisting language="cpp">    cb-&gt;beginPass(m_sc-&gt;currentFrameRenderTarget(), Qt::black, { 1.0f, 0 }, resourceUpdates);
</db:programlisting>
<db:para>Recording the draw call for the triangle is straightforward: set the pipeline, set the shader resources, set the vertex/index buffer(s), and record the draw call. Here we use a non-indexed draw with just 3 vertices.</db:para>
<db:programlisting language="cpp">    cb-&gt;setGraphicsPipeline(m_colorPipeline.get());
    cb-&gt;setShaderResources();
    const QRhiCommandBuffer::VertexInput vbufBinding(m_vbuf.get(), 0);
    cb-&gt;setVertexInput(0, 1, &amp;vbufBinding);
    cb-&gt;draw(3);

    cb-&gt;endPass();
</db:programlisting>
<db:para>The <db:link xlink:href="qrhicommandbuffer.xml#setShaderResources">setShaderResources</db:link>() call has no arguments given, which implies using <db:code>m_colorTriSrb</db:code> since that was associated with the active <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> (<db:code>m_colorPipeline</db:code>).</db:para>
<db:para>We will not dive into the details of the rendering of the fullscreen background image. See the example source code for that. It is however worth noting a common pattern for &quot;resizing&quot; a texture or buffer resource. There is no such thing as changing the size of an existing native resource, so changing a texture or buffer size must be followed by a call to create(), to release and recreate the underlying native resources. To ensure that the <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> always has the required size, the application implements the following logic. Note that <db:code>m_texture</db:code> stays valid for the entire lifetime of the window, which means object references to it, e.g. in a <db:link xlink:href="qrhishaderresourcebindings.xml">QRhiShaderResourceBindings</db:link>, continue to be valid all the time. It is only the underlying native resources that come and go over time.</db:para>
<db:para>Note also that we set a device pixel ratio on the image that matches the window that we're drawing into. This ensures that the drawing code can be DPR-agnostic, producing the same layout regardless of the DPR, while also taking advantage of the additional pixels for improved fidelity.</db:para>
<db:programlisting language="cpp">void HelloWindow::ensureFullscreenTexture(const QSize &amp;pixelSize, QRhiResourceUpdateBatch *u)
{
    if (m_texture &amp;&amp; m_texture-&gt;pixelSize() == pixelSize)
        return;

    if (!m_texture)
        m_texture.reset(m_rhi-&gt;newTexture(QRhiTexture::RGBA8, pixelSize));
    else
        m_texture-&gt;setPixelSize(pixelSize);

    m_texture-&gt;create();

    QImage image(pixelSize, QImage::Format_RGBA8888_Premultiplied);
    image.setDevicePixelRatio(devicePixelRatio());
</db:programlisting>
<db:para>Once a <db:link xlink:href="qimage.xml">QImage</db:link> is generated and the <db:link xlink:href="qpainter.xml">QPainter</db:link>-based drawing into it has finished, we use <db:link xlink:href="qrhiresourceupdatebatch.xml#uploadTexture">uploadTexture</db:link>() to record a texture upload on the resource update batch:</db:para>
<db:programlisting language="cpp">    u-&gt;uploadTexture(m_texture.get(), image);
</db:programlisting>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/gui/rhiwindow?h=6.9">Example project @ code.qt.io</db:link></db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml">QRhi</db:link></db:member>
<db:member><db:link xlink:href="qrhiswapchain.xml">QRhiSwapChain</db:link></db:member>
<db:member><db:link xlink:href="qwindow.xml">QWindow</db:link></db:member>
<db:member><db:link xlink:href="qrhicommandbuffer.xml">QRhiCommandBuffer</db:link></db:member>
<db:member><db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link></db:member>
<db:member><db:link xlink:href="qrhibuffer.xml">QRhiBuffer</db:link></db:member>
<db:member><db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
