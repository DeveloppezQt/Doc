<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>CustomMaterial QML Type</db:title>
<db:productname>QtQuick3D</db:productname>
<db:edition>Qt Quick 3D | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Quick 3D Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Base component for creating custom materials used to shade models.</db:para>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Import Statement</db:term>
<db:listitem>
<db:para>import QtQuick3D</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para>Material</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The custom material allows using custom shader code for a material, enabling programmability on graphics shader level. A vertex, fragment, or both shaders can be provided. The <db:link xlink:href="qml-qtquick3d-custommaterial.xml#vertexShader-prop">vertexShader</db:link> and <db:link xlink:href="qml-qtquick3d-custommaterial.xml#fragmentShader-prop">fragmentShader</db:link> properties are URLs, referencing files containing shader snippets, and work very similarly to <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link> or <db:link xlink:href="qml-qtquick-image.xml#source-prop">Image.source</db:link>. Only the <db:code>file</db:code> and <db:code>qrc</db:code> schemes are supported with custom materials. It is also possible to omit the <db:code>file</db:code> scheme, allowing to specify a relative path in a convenient way. Such a path is resolved relative to the component's (the <db:code>.qml</db:code> file's) location.</db:para>
<db:para>For a getting started guide to custom materials, see the page <db:link xlink:href="qtquick3d-custom.xml">Programmable Materials, Effects, Geometry, and Texture data</db:link>.</db:para>
<db:section xml:id="introduction">
<db:title>Introduction</db:title>
<db:para>Consider the following versions of the same scene. On the left, the cylinder is using a built-in, non-programmable material. Such materials are configurable through a wide range of properties, but there is no further control given over the shaders that are generated under the hood. On the right, the same cylinder is now associated with a <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> referencing application-provided vertex and fragment shader snippets. This allows inserting custom, application-specific logic into the vertex shader to transform the geometry, and to determine certain color properties in a custom manner in the fragment shader. As this is a <db:link xlink:href="qml-qtquick3d-custommaterial.xml#shadingMode-prop">shaded</db:link> custom material, the cylinder still participates in the scene lighting normally.</db:para>
<db:informaltable style="generic" width="70%">
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">View3D {
    anchors.fill: parent
    PerspectiveCamera {
        id: camera
        position: Qt.vector3d(0, 0, 600)
    }
    camera: camera
    DirectionalLight {
        position: Qt.vector3d(-500, 500, -100)
        color: Qt.rgba(0.2, 0.2, 0.2, 1.0)
        ambientColor: Qt.rgba(0.1, 0.1, 0.1, 1.0)
    }
    Model {
        source: &quot;#Cylinder&quot;
        eulerRotation: Qt.vector3d(30, 30, 0)
        scale: Qt.vector3d(1.5, 1.5, 1.5)
        materials: [
            DefaultMaterial {
                diffuseColor: Qt.rgba(0, 1, 0, 1)
            }
        ]
    }
}
    </db:programlisting>
</db:td>
<db:td>
<db:programlisting language="qml">View3D {
    anchors.fill: parent
    PerspectiveCamera {
        id: camera
        position: Qt.vector3d(0, 0, 600)
    }
    camera: camera
    DirectionalLight {
        position: Qt.vector3d(-500, 500, -100)
        color: Qt.rgba(0.2, 0.2, 0.2, 1.0)
        ambientColor: Qt.rgba(0.1, 0.1, 0.1, 1.0)
    }
    Model {
        source: &quot;#Cylinder&quot;
        eulerRotation: Qt.vector3d(30, 30, 0)
        scale: Qt.vector3d(1.5, 1.5, 1.5)
        materials: [
            CustomMaterial {
                vertexShader: &quot;material.vert&quot;
                fragmentShader: &quot;material.frag&quot;
                property real uTime
                property real uAmplitude: 50
                NumberAnimation on uTime { from: 0; to: 100; duration: 10000; loops: -1 }
            }
        ]
    }
}
    </db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Let's assume that the shader snippets in <db:code>material.vert</db:code> and <db:code>material.frag</db:code> are the following:</db:para>
<db:informaltable style="generic" width="70%">
<db:tr valign="top">
<db:td>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    VERTEX.x += sin(uTime + VERTEX.y) * uAmplitude;
}
</db:programlisting>
</db:td>
<db:td>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    BASE_COLOR = vec4(0.0, 1.0, 0.0, 1.0);
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Notice how <db:code>uTime</db:code> and <db:code>uAmplitude</db:code> are properties of the <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> element. They can change values and get animated normally, the values will be exposed to the shaders automatically without any further action from the developer.</db:para>
<db:para>The result is a cylinder that animates its vertices:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/custommaterial_cylinder.png"/>
</db:imageobject>
</db:mediaobject>
</db:section>
<db:section xml:id="two-flavors-of-custom-materials">
<db:title>Two flavors of custom materials</db:title>
<db:para>There are two main types of custom materials. This is specified by the <db:link xlink:href="qml-qtquick3d-custommaterial.xml#shadingMode-prop">shadingMode</db:link> property. In <db:link xlink:href="qml-qtquick3d-custommaterial.xml#shadingMode-prop">unshaded</db:link> custom materials the fragment shader outputs a single <db:code>vec4</db:code> color, ignoring lights, light probes, shadowing in the scene. In <db:link xlink:href="qml-qtquick3d-custommaterial.xml#shadingMode-prop">shaded</db:link> materials the shader is expected to implement certain functions and work with built-in variables to take lighting and shadow contribution into account.</db:para>
<db:para>The default choice is typically a shaded material, this is reflected in the default value of the <db:link xlink:href="qml-qtquick3d-custommaterial.xml#shadingMode-prop">shadingMode</db:link> property. This fits materials that needs to transform vertices or other incoming data from the geometry, or determine values like <db:code>BASE_COLOR</db:code> or <db:code>EMISSIVE_COLOR</db:code> in a custom manner, perhaps by sampling <db:code>SCREEN_TEXTURE</db:code> or <db:code>DEPTH_TEXTURE</db:code>, while still reciving light and shadow contributions from the scene. Additionally, such materials can also override and reimplement the equations used to calculate the contributions from directional, point, and other lights. The application-provided shader snippets are heavily amended by the Qt Quick 3D engine under the hood, in order to provide the features, such as lighting, the standard materials have.</db:para>
<db:para>Unshaded materials are useful when the object's appearance is determined completely by the custom shader code. The shaders for such materials receive minimal additions by the engine, and therefore it is completely up to the shader to determine the final fragment color. This gives more freedom, but also limits possiblities to integrate with other elements of the scene, such as lights.</db:para>
<db:note>
<db:para>Shader code is always provided using Vulkan-style GLSL, regardless of the graphics API used by Qt at run time.</db:para>
</db:note>
<db:note>
<db:para>The vertex and fragment shader code provided by the material are not full, complete GLSL shaders on their own. Rather, they provide a set of functions, which are then amended with further shader code by the engine.</db:para>
</db:note>
</db:section>
<db:section xml:id="exposing-data-to-the-shaders">
<db:title>Exposing data to the shaders</db:title>
<db:para>The dynamic properties of the <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> can be changed and animated using QML and Qt Quick facilities, and the values are exposed to the shaders automatically. This in practice is very similar <db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link>. The following list shows how properties are mapped:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>bool, int, real -&gt; bool, int, float</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qcolor.xml">QColor</db:link>, <db:link xlink:href="qml-qtqml-qt.xml#rgba-method">color</db:link> -&gt; vec4, and the color gets converted to linear, assuming sRGB space for the color value specified in QML. The built-in Qt colors, such as <db:code>&quot;green&quot;</db:code> are in sRGB color space as well, and the same conversion is performed for all color properties of <db:link xlink:href="qml-qtquick3d-defaultmaterial.xml">DefaultMaterial</db:link> and <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link>, so this behavior of <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> matches those. Unlike Qt Quick, for Qt Quick 3D linearizing is essential as there will typically be tonemapping performed on the 3D scene.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qrect.xml">QRect</db:link>, <db:link xlink:href="qrectf.xml">QRectF</db:link>, <db:link xlink:href="qml-qtqml-qt.xml#rect-method">rect</db:link> -&gt; vec4</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qpoint.xml">QPoint</db:link>, <db:link xlink:href="qpointf.xml">QPointF</db:link>, <db:link xlink:href="qml-qtqml-qt.xml#point-method">point</db:link>, <db:link xlink:href="qsize.xml">QSize</db:link>, <db:link xlink:href="qsizef.xml">QSizeF</db:link>, <db:link xlink:href="qml-qtqml-qt.xml#size-method">size</db:link> -&gt; vec2</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qvector2d.xml">QVector2D</db:link>, <db:link xlink:href="qml-qtqml-qt.xml#vector2d-method">vector2d</db:link> -&gt; vec2</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qvector3d.xml">QVector3D</db:link>, <db:link xlink:href="qml-qtqml-qt.xml#vector3d-method">vector3d</db:link> -&gt; vec3</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qvector4d.xml">QVector4D</db:link>, <db:link xlink:href="qml-qtqml-qt.xml#vector4d-method">vector4d</db:link> -&gt; vec4</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qmatrix4x4.xml">QMatrix4x4</db:link>, <db:link xlink:href="qml-qtqml-qt.xml#matrix4x4-method">matrix4x4</db:link> -&gt; mat4</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qquaternion.xml">QQuaternion</db:link>, <db:link xlink:href="qml-qtqml-qt.xml#quaternion-method">quaternion</db:link> -&gt; vec4, scalar value is <db:code>w</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick3d-textureinput.xml">TextureInput</db:link> -&gt; sampler2D or samplerCube, depending on whether <db:link xlink:href="qml-qtquick3d-texture.xml">Texture</db:link> or <db:link xlink:href="qml-qtquick3d-cubemaptexture.xml">CubeMapTexture</db:link> is used in the texture property of the <db:link xlink:href="qml-qtquick3d-textureinput.xml">TextureInput</db:link>. Setting the <db:link xlink:href="qml-qtquick3d-textureinput.xml#enabled-prop">enabled</db:link> property to false leads to exposing a dummy texture to the shader, meaning the shaders are still functional but will sample a texture with opaque black image content. Pay attention to the fact that properties for samplers must always reference a <db:link xlink:href="qml-qtquick3d-textureinput.xml">TextureInput</db:link> object, not a <db:link xlink:href="qml-qtquick3d-texture.xml">Texture</db:link> directly. When it comes to the <db:link xlink:href="qml-qtquick3d-texture.xml">Texture</db:link> properties, the source, tiling, and filtering related ones are the only ones that are taken into account implicitly with custom materials, as the rest (such as, UV transformations) is up to the custom shaders to implement as they see fit.</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para>When a uniform referenced in the shader code does not have a corresponding property, it will cause a shader compilation error when processing the material at run time. There are some exceptions to this, such as, sampler uniforms, that get a dummy texture bound when no corresponding QML property is present, but as a general rule, all uniforms and samplers must have a corresponding property declared in the <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> object.</db:para>
</db:note>
</db:section>
<db:section xml:id="unshaded-custom-materials">
<db:title>Unshaded custom materials</db:title>
<db:para>The following is an example of an <db:link xlink:href="qml-qtquick3d-custommaterial.xml#shadingMode-prop">unshaded</db:link> custom material.</db:para>
<db:programlisting language="qml">CustomMaterial {
    // These properties are automatically exposed to the shaders
    property real time: 0.0
    property real amplitude: 5.0
    property real alpha: 1.0
    property TextureInput tex: TextureInput {
        enabled: true
        texture: Texture { source: &quot;image.png&quot; }
    }

    shadingMode: CustomMaterial.Unshaded
    sourceBlend: alpha &amp;lt; 1.0 ? CustomMaterial.SrcAlpha : CustomMaterial.NoBlend
    destinationBlend: alpha &amp;lt; 1.0 ? CustomMaterial.OneMinusSrcAlpha : CustomMaterial.NoBlend
    cullMode: CustomMaterial.BackFaceCulling

    vertexShader: &quot;customshader.vert&quot;
    fragmentShader: &quot;customshader.frag&quot;
}
</db:programlisting>
<db:para>With the above example, the <db:link xlink:href="qml-qtquick3d-custommaterial.xml#shadingMode-prop">unshaded</db:link> vertex and fragment shaders snippets could look like the following. Note how the shaders do not, and must not, declare uniforms or vertex inputs as that is taken care of by Qt when assembling the final shader code.</db:para>
<db:programlisting language="cpp" role="bad">VARYING vec3 pos;
VARYING vec2 texcoord;

void MAIN()
{
    pos = VERTEX;
    pos.x += sin(time * 4.0 + pos.y) * amplitude;
    texcoord = UV0;
    POSITION = MODELVIEWPROJECTION_MATRIX * vec4(pos, 1.0);
}
</db:programlisting>
<db:programlisting language="cpp" role="bad">VARYING vec3 pos;
VARYING vec2 texcoord;

void MAIN()
{
    vec4 c = texture(tex, texcoord);
    FRAGCOLOR = vec4(pos.x * 0.02, pos.y * 0.02, pos.z * 0.02, alpha) * c;
}
</db:programlisting>
<db:para>The following special, uppercase keywords are available:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>MAIN -&gt; the name of the entry point in the vertex or fragment shader snippet must always be <db:code>MAIN</db:code>. Providing this function is mandatory in shader snippets for unshaded custom materials.</db:para>
</db:listitem>
<db:listitem>
<db:para>VARYING -&gt; declares an output from the vertex shader or an input to the fragment shader</db:para>
</db:listitem>
<db:listitem>
<db:para>POSITION -&gt; vec4, the output from the vertex shader</db:para>
</db:listitem>
<db:listitem>
<db:para>FRAGCOLOR -&gt; vec4, the output from the fragment shader. Available only for unshaded custom materials.</db:para>
</db:listitem>
<db:listitem>
<db:para>VERTEX -&gt; vec3, the vertex position in the vertex shader.</db:para>
</db:listitem>
<db:listitem>
<db:para>NORMAL -&gt; vec3, the vertex normal in the vertex shader. When the mesh for the associated model does not provide normals, the value is vec3(0.0).</db:para>
</db:listitem>
<db:listitem>
<db:para>UV0 -&gt; vec2, the first set of texture coordinates in the vertex shader. When the mesh for the associated model does not provide texture coordinates, the value is vec2(0.0).</db:para>
</db:listitem>
<db:listitem>
<db:para>UV1 -&gt; vec2, the second set of texture coordinates in the vertex shader. When the mesh for the associated model does not provide a second set of texture coordinates, the value is vec2(0.0).</db:para>
</db:listitem>
<db:listitem>
<db:para>COLOR -&gt; vec4, the vertex color in the vertex shader. When the mesh for the associated model does not provide per-vertex colors, the value is vec4(1.0).</db:para>
</db:listitem>
<db:listitem>
<db:para>TANGENT -&gt; vec3, tangent in the vertex shader. When the mesh for the associated model does not provide tangent data, the value is vec3(0.0).</db:para>
</db:listitem>
<db:listitem>
<db:para>BINORMAL -&gt; vec3, binormal in the vertex shader. When the mesh for the associated model does not provide binormal data, the value is vec3(0.0).</db:para>
</db:listitem>
<db:listitem>
<db:para>JOINTS -&gt; ivec4, joint indexes in the vertex shader. When the mesh for the associated model does not provide joint indexes data, the value is ivec4(0).</db:para>
</db:listitem>
<db:listitem>
<db:para>WEIGHTS -&gt; vec4, joint weights in the vertex shader. When the mesh for the associated model does not provide joint weights data, the value is vec4(0.0).</db:para>
</db:listitem>
<db:listitem>
<db:para>MORPH_POSITION<db:emphasis>n</db:emphasis> -&gt; vec3, the <db:emphasis>n</db:emphasis>th morph target position in the vertex shader. <db:emphasis>n</db:emphasis>'s range is from 0 to 7. The associated model should provide proper data. For safety, the user can check <db:emphasis role="bold">defined(QT_MORPH_IN_POSITION<db:emphasis>n</db:emphasis>)</db:emphasis> before use it.</db:para>
</db:listitem>
<db:listitem>
<db:para>MORPH_NORMAL<db:emphasis>n</db:emphasis> -&gt; vec3, the <db:emphasis>n</db:emphasis>th morph target normal in the vertex shader. <db:emphasis>n</db:emphasis>'s range is from 0 to 4. The associated model should provide proper data. For safety, the user can check <db:emphasis role="bold">defined(QT_MORPH_IN_NORMAL<db:emphasis>n</db:emphasis>)</db:emphasis> before use it.</db:para>
</db:listitem>
<db:listitem>
<db:para>MORPH_TANGENT<db:emphasis>n</db:emphasis> -&gt; vec3, the <db:emphasis>n</db:emphasis>th morph target tangent in the vertex shader. <db:emphasis>n</db:emphasis>'s range is from 0 to 1. The associated model should provide proper data. For safety, the user can check <db:emphasis role="bold">defined(QT_MORPH_IN_TANGENT<db:emphasis>n</db:emphasis>)</db:emphasis> before use it.</db:para>
</db:listitem>
<db:listitem>
<db:para>MORPH_BINORMAL<db:emphasis>n</db:emphasis> -&gt; vec3, the <db:emphasis>n</db:emphasis>th morph target binormal in the vertex shader. <db:emphasis>n</db:emphasis>'s range is from 0 to 1. The associated model should provide proper data. For safety, the user can check <db:emphasis role="bold">defined(QT_MORPH_IN_BINORMAL<db:emphasis>n</db:emphasis>)</db:emphasis> before use it.</db:para>
</db:listitem>
<db:listitem>
<db:para>MODELVIEWPROJECTION_MATRIX -&gt; mat4, the model-view-projection matrix. Projection matrices always follow OpenGL conventions, with a baked-in transformation for the Y axis direction and clip depth, depending on the graphics API used at run time.</db:para>
</db:listitem>
<db:listitem>
<db:para>VIEWPROJECTION_MATRIX -&gt; mat4, the view-projection matrix</db:para>
</db:listitem>
<db:listitem>
<db:para>PROJECTION_MATRIX -&gt; mat4, the projection matrix</db:para>
</db:listitem>
<db:listitem>
<db:para>INVERSE_PROJECTION_MATRIX -&gt; mat4, the inverse projection matrix</db:para>
</db:listitem>
<db:listitem>
<db:para>VIEW_MATRIX -&gt; mat4, the view (camera) matrix</db:para>
</db:listitem>
<db:listitem>
<db:para>MODEL_MATRIX -&gt; mat4, the model (world) matrix</db:para>
</db:listitem>
<db:listitem>
<db:para>NORMAL_MATRIX -&gt; mat3, the normal matrix (the transpose of the inverse of the top-left 3x3 part of the model matrix)</db:para>
</db:listitem>
<db:listitem>
<db:para>BONE_TRANSFORMS -&gt; mat4[], the array of the model's bone matrixes</db:para>
</db:listitem>
<db:listitem>
<db:para>BONE_NORMAL_TRANSFORMS -&gt; mat3[], the array of the model's bone normal matrixes (the transpose of the inverse of the top-left 3x3 part of the each bone matrixes)</db:para>
</db:listitem>
<db:listitem>
<db:para>MORPH_WEIGHTS -&gt; float[], the array of the morph weights. The associated model should provide proper data. For safety, <db:emphasis role="bold">QT_MORPH_MAX_COUNT</db:emphasis> is defined to the size of this array.</db:para>
</db:listitem>
<db:listitem>
<db:para>CAMERA_POSITION -&gt; vec3, the camera position in world space</db:para>
</db:listitem>
<db:listitem>
<db:para>CAMERA_DIRECTION -&gt; vec3, the camera direction vector</db:para>
</db:listitem>
<db:listitem>
<db:para>CAMERA_PROPERTIES -&gt; vec2, the near and far clip values for the camera</db:para>
</db:listitem>
<db:listitem>
<db:para>POINT_SIZE -&gt; float, writable in the vertex shader only. When rendering geometry with a topology of points, the custom vertex shader must set this to either 1.0 or another value, both in shaded and unshaded custom materials. See <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#pointSize-prop">PrincipledMaterial::pointSize</db:link> for further notes on support for sizes other than 1.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="shaded-custom-materials">
<db:title>Shaded custom materials</db:title>
<db:para>A <db:link xlink:href="qml-qtquick3d-custommaterial.xml#shadingMode-prop">shaded</db:link> material <db:code>augments</db:code> the shader code that would be generated by a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link>. Unlike unshaded materials, that provide almost all logic for the vertex and fragment shader main functions on their own, preventing adding generated code for lighting, shadowing, global illumination, etc., shaded materials let shader generation happen normally, as if the <db:link xlink:href="qml-qtquick3d-custommaterial.xml">CustomMaterial</db:link> was a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link>. The vertex and fragment shader snippets are expected to provide optional functions that are then invoked at certain points, giving them the possibility to customize the colors and other values that are then used for calculating lighting and the final fragment color.</db:para>
<db:para>Rather than implementing just a <db:code>MAIN</db:code> function, the fragment shader for a shaded custom material can implement multiple functions. All functions, including <db:code>MAIN</db:code>, are optional to implement in shaded custom materials. An empty shader snippet, or, even, not specifying the <db:link xlink:href="qml-qtquick3d-custommaterial.xml#vertexShader-prop">vertexShader</db:link> or <db:link xlink:href="qml-qtquick3d-custommaterial.xml#fragmentShader-prop">fragmentShader</db:link> properties at all can be perfectly valid too.</db:para>
<db:section xml:id="vertex-shader-snippets-in-a-shaded-custom-material">
<db:title>Vertex shader snippets in a shaded custom material</db:title>
<db:para>The following functions can be implemented in a vertex shader snippet:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>void MAIN()</db:code> When present, this function is called in order to set the value of <db:code>POSITION</db:code>, the vec4 output from the vertex shader, and, optionally, to modify the values of <db:code>VERTEX</db:code>, <db:code>COLOR</db:code>, <db:code>NORMAL</db:code>, <db:code>UV0</db:code>, <db:code>UV1</db:code>, <db:code>TANGENT</db:code>, <db:code>BINORMAL</db:code>, <db:code>JOINTS</db:code>, and <db:code>WEIGHTS</db:code>. Unlike in unshaded materials, writing to these makes sense because the modified values are then taken into account in the rest of the generated shader code (whereas for unshaded materials there is no additional shader code generated). For example, if the custom vertex shader displaces the vertices or the normals, it will want to store the modified values to <db:code>VERTEX</db:code> or <db:code>NORMAL</db:code>, to achieve correct lighting calculations afterwards. Additionally, the function can write to variables defined with <db:code>VARYING</db:code> in order to pass interpolated data to the fragment shader. When this function or a redefinition of <db:code>POSITION</db:code> is not present, <db:code>POSITION</db:code> is calculated based on <db:code>VERTEX</db:code> and <db:code>MODELVIEWPROJECTION_MATRIX</db:code>, just like a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> would do.</db:para>
<db:para>Example, with relying both on QML properties exposed as uniforms, and also passing data to the fragment shader:</db:para>
<db:programlisting language="cpp" role="bad">VARYING vec3 vNormal;
VARYING vec3 vViewVec;

void MAIN()
{
    VERTEX.x += sin(uTime * 4.0 + VERTEX.y) * uAmplitude;
    vNormal = normalize(NORMAL_MATRIX * NORMAL);
    vViewVec = CAMERA_POSITION - (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
    POSITION = MODELVIEWPROJECTION_MATRIX * vec4(VERTEX, 1.0);
}
</db:programlisting>
<db:note>
<db:para>In the above example, assigning a value to <db:code>POSITION</db:code> is optional as the usage in this case is identical to the default behavior.</db:para>
</db:note>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="fragment-shader-snippets-in-a-shaded-custom-material">
<db:title>Fragment shader snippets in a shaded custom material</db:title>
<db:para>The following functions can be implemented in a fragment shader snippet:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>void MAIN()</db:code> When present, this function is called to set the values of the special writable variables <db:code>BASE_COLOR</db:code>, <db:code>METALNESS</db:code>, <db:code>ROUGHNESS</db:code>, <db:code>SPECULAR_AMOUNT</db:code>, NORMAL, and <db:code>FRESNEL_POWER</db:code>.</db:para>
<db:para>One common use case is to set the value of <db:code>BASE_COLOR</db:code> based on sampling a texture, be it a base color map, <db:code>SCREEN_TEXTURE</db:code>, or some other kind of source. This can be relevant and convenient especially when no custom light processor functions are implemented. Setting <db:code>BASE_COLOR.a</db:code> to something other than the default 1.0 allows affecting the final alpha value of the fragment. (note that this will often require also enabling alpha blending in <db:link xlink:href="qml-qtquick3d-custommaterial.xml#sourceBlend-prop">sourceBlend</db:link> and <db:link xlink:href="qml-qtquick3d-custommaterial.xml#destinationBlend-prop">destinationBlend</db:link>)</db:para>
<db:para>Another scenario is when there is no custom <db:code>SPECULAR_LIGHT</db:code> function provided, or when there is a light probe set in the <db:link xlink:href="qml-qtquick3d-sceneenvironment.xml">SceneEnvironment</db:link>. The metalness, roughness, and other values that affect the specular contribution calculation can be set in <db:code>MAIN</db:code> to their desired custom values.</db:para>
<db:para>The function can write to the following special variables. The values written to these will typically be either hardcoded or be calculated based on QML properties mapped to uniforms. The semantics are identical to <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link>.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec4 <db:code>BASE_COLOR</db:code> - The base color and material alpha value. Corresponds to the <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#baseColor-prop">built-in materials' color property</db:link>. When light processor functions are not implemented, it can be convenient to set a custom base color in <db:code>MAIN</db:code> because that is then taken into account in the default lighting calculations. The default value is <db:code>vec4(1.0)</db:code>, meaning white with an alpha of 1.0. The alpha value effects the final alpha of the fragment. The final alpha value is the object (model) opacity multiplied by the base color alpha. When specifying the value directly in shader code, not relying on uniform values exposed from <db:emphasis role="bold">color</db:emphasis> properties in QML, be aware that it is up to the shader to perform the sRGB to linear conversion, if needed. For example, assuming a <db:code>vec3 color</db:code> and <db:code>float alpha</db:code> this can be achieved like the following:</db:para>
<db:programlisting language="cpp" role="bad">float C1 = 0.305306011;
vec3 C2 = vec3(0.682171111, 0.682171111, 0.682171111);
vec3 C3 = vec3(0.012522878, 0.012522878, 0.012522878);
BASE_COLOR = vec4(rgb * (rgb * (rgb * C1 + C2) + C3), alpha);
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>EMISSIVE_COLOR</db:code> - The color of self-illumination. Corresponds to the built-in materials' emissive color which is combined by <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#emissiveFactor-prop">built-in materials's emissiveFactor property</db:link> and <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#emissiveMap-prop">built-in materials's emissiveMap property</db:link>. The default value is <db:code>vec3(0.0)</db:code>. When specifying the value directly in shader code, not relying on uniform values exposed from <db:emphasis role="bold">color</db:emphasis> properties in QML, be aware that it is up to the shader to perform the sRGB to linear conversion, if needed.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>METALNESS</db:code> Metalness amount in range 0.0 - 1.0. The default value is 0. Must be set to a non-zero value to have effect.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>ROUGHNESS</db:code> Roughness value in range 0.0 - 1.0. The default value is 0.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>FRESNEL_POWER</db:code> Specifies the fresnel power. A typical value, and also the default, is <db:code>5.0</db:code> as that is what a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> would use.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>SPECULAR_AMOUNT</db:code> Specular amount in range 0.0 - 1.0. The default value is <db:code>0.5</db:code>, matching <db:link xlink:href="qml-qtquick3d-principledmaterial.xml#specularAmount-prop">PrincipledMaterial::specularAmount</db:link>. Must be set to a non-zero value to have effect.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>NORMAL</db:code> - The normal that comes from the vertex shader in world space. While this property has the same initial value as <db:code>VAR_WORLD_NORMAL</db:code>, only changing the value of <db:code>NORMAL</db:code> will have an effect on lighting.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>TANGENT</db:code> - The tanget that comes from the vertex shader in world space. This value is potentially adjusted for double-sidedness.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>BINORMAL</db:code> - The binormal that comes from the vertex shader in world space. This value is potentially adjusted for double-sidedness.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec2 <db:code>UV0</db:code> - The first set of texture coordinates from the vertex shader. This property is readonly in the fragment shader.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec2 <db:code>UV1</db:code> - The second set of texture coordinates from the vertex shader. This property is readonly in the fragment shader.</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para>Unlike with unshaded materials, the fragment <db:code>MAIN</db:code> for a shaded material has no direct control over <db:code>FRAGCOLOR</db:code>. Rather, it is the <db:code>DIFFUSE</db:code> and <db:code>SPECULAR</db:code> values written in the light processor functions that decide what the final fragment color is. When a light processor function is not implemented, the relevant default shading calculations are performed as with a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link>, taking <db:code>BASE_COLOR</db:code> and other values from the list above into account.</db:para>
</db:note>
<db:para>An example of a simple, metallic custom material shader could be the following:</db:para>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    METALNESS = 1.0;
    ROUGHNESS = 0.5;
    FRESNEL_POWER = 5.0;
}
</db:programlisting>
<db:para>Another example, where the base color and alpha are set by sampling a texture:</db:para>
<db:programlisting language="cpp" role="bad">VARYING vec2 texcoord;
void MAIN()
{
    BASE_COLOR = texture(uColorMap, texcoord);
}
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>void AMBIENT_LIGHT()</db:code> When present, this function is called once for each fragment. The task of the function is to add the total ambient contribution to a writable special variable <db:code>DIFFUSE</db:code>. It can of course choose to calculate a different value, or not touch <db:code>DIFFUSE</db:code> at all (to ignore ambient lighting completely). When this function is not present at all, the ambient contribution is calculated normally, like a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> would do.</db:para>
<db:para>The function can write to the following special variables:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec3 <db:code>DIFFUSE</db:code> Accumulates the diffuse light contributions, per fragment. The light processor functions will typically add (<db:code>+=</db:code>) to it, since overwriting the value would lose the contribution from other lights.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The function can read the following special variables, in addition to the matrix (such as, <db:code>MODEL_MATRIX</db:code>) and vector (such as, <db:code>CAMERA_POSITION</db:code>) uniforms from the table above:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec3 <db:code>TOTAL_AMBIENT_COLOR</db:code> The total ambient contribution in the scene.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Example:</db:para>
<db:programlisting language="cpp" role="bad">void AMBIENT_LIGHT()
{
    DIFFUSE += TOTAL_AMBIENT_COLOR;
}
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>void DIRECTIONAL_LIGHT()</db:code> When present, this function is called for each active directional light in the scene for each fragment. The task of the function is to add the diffuse contribution to a writable special variable <db:code>DIFFUSE</db:code>. The function can also choose to do nothing, in which case diffuse contributions from directional lights are ignored. When the function is not present at all, the diffuse contributions from directional lights are accumulated normally, like a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> would do.</db:para>
<db:para>The function can write to the following special variables:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec3 <db:code>DIFFUSE</db:code> Accumulates the diffuse light contributions, per fragment. The light processor functions will typically add (<db:code>+=</db:code>) to it, since overwriting the value would lose the contribution from other lights.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The function can read the following special variables, in addition to the matrix (such as, <db:code>MODEL_MATRIX</db:code>) and vector (such as, <db:code>CAMERA_POSITION</db:code>) uniforms from the table above:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec3 <db:code>LIGHT_COLOR</db:code> Diffuse light color.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>SHADOW_CONTRIB</db:code> Shadow contribution, or 1.0 if not shadowed at all or not reciving shadows.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>TO_LIGHT_DIR</db:code> Vector pointing towards the light source.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>NORMAL</db:code> The normal vector in world space.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec4 <db:code>BASE_COLOR</db:code> The base color and material alpha value.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>METALNESS</db:code> The Metalness amount.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>ROUGHNESS</db:code> The Roughness amount.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Example:</db:para>
<db:programlisting language="cpp" role="bad">void DIRECTIONAL_LIGHT()
{
    DIFFUSE += LIGHT_COLOR * SHADOW_CONTRIB * vec3(max(0.0, dot(normalize(VAR_WORLD_NORMAL), TO_LIGHT_DIR)));
}
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>void POINT_LIGHT()</db:code> When present, this function is called for each active point light in the scene for each fragment. The task of the function is to add the diffuse contribution to a writable special variable <db:code>DIFFUSE</db:code>. The function can also choose to do nothing, in which case diffuse contributions from point lights are ignored. When the function is not present at all, the diffuse contributions from point lights are accumulated normally, like a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> would do.</db:para>
<db:para>The function can write to the following special variables:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec3 <db:code>DIFFUSE</db:code> Accumulates the diffuse light contributions, per fragment.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The function can read the following special variables, in addition to the matrix (such as, <db:code>MODEL_MATRIX</db:code>) and vector (such as, <db:code>CAMERA_POSITION</db:code>) uniforms from the table above:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec3 <db:code>LIGHT_COLOR</db:code> Diffuse light color.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>LIGHT_ATTENUATION</db:code> Light attenuation.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>SHADOW_CONTRIB</db:code> Shadow contribution, or 1.0 if not shadowed at all or not reciving shadows.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>TO_LIGHT_DIR</db:code> Vector pointing towards the light source.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>NORMAL</db:code> The normal vector in world space.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec4 <db:code>BASE_COLOR</db:code> The base color and material alpha value.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>METALNESS</db:code> The Metalness amount.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>ROUGHNESS</db:code> The Roughness amount.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Example:</db:para>
<db:programlisting language="cpp" role="bad">void POINT_LIGHT()
{
    DIFFUSE += LIGHT_COLOR * LIGHT_ATTENUATION * SHADOW_CONTRIB * vec3(max(0.0, dot(normalize(VAR_WORLD_NORMAL), TO_LIGHT_DIR)));
}
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>void SPOT_LIGHT()</db:code> When present, this function is called for each active spot light in the scene for each fragment. The task of the function is to add the diffuse contribution to a writable special variable <db:code>DIFFUSE</db:code>. The function can also choose to do nothing, in which case diffuse contributions from spot lights are ignored. When the function is not present at all, the diffuse contributions from spot lights are accumulated normally, like a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> would do.</db:para>
<db:para>The function can write to the following special variables:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec3 <db:code>DIFFUSE</db:code> Accumulates the diffuse light contributions, per fragment.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The function can read the following special variables, in addition to the matrix (such as, <db:code>MODEL_MATRIX</db:code>) and vector (such as, <db:code>CAMERA_POSITION</db:code>) uniforms from the table above:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec3 <db:code>LIGHT_COLOR</db:code> Diffuse light color.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>LIGHT_ATTENUATION</db:code> Light attenuation.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>SHADOW_CONTRIB</db:code> Shadow contribution, or 1.0 if not shadowed at all or not reciving shadows.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>TO_LIGHT_DIR</db:code> Vector pointing towards the light source.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>SPOT_FACTOR</db:code> Spot light factor.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>NORMAL</db:code> The normal vector in world space.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec4 <db:code>BASE_COLOR</db:code> The base color and material alpha value.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>METALNESS</db:code> The Metalness amount.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>ROUGHNESS</db:code> The Roughness amount.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Example:</db:para>
<db:programlisting language="cpp" role="bad">void SPOT_LIGHT()
{
    DIFFUSE += LIGHT_COLOR * LIGHT_ATTENUATION * SPOT_FACTOR * SHADOW_CONTRIB * vec3(max(0.0, dot(normalize(VAR_WORLD_NORMAL), TO_LIGHT_DIR)));
}
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>void SPECULAR_LIGHT()</db:code> When present, this function is called for each active light in the scene for each fragment. The task of the function is to add the specular contribution to a writable special variable <db:code>SPECULAR</db:code>. The function can also choose to do nothing, in which case specular contributions from lights are ignored. When the function is not present at all, the specular contributions from lights are accumulated normally, like a <db:link xlink:href="qml-qtquick3d-principledmaterial.xml">PrincipledMaterial</db:link> would do.</db:para>
<db:para>The function can write to the following special variables:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec3 <db:code>SPECULAR</db:code> Accumulates the specular light contributions, per frament. The light processor functions will typically add (<db:code>+=</db:code>) to it, since overwriting the value would lose the contribution from other lights.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The function can read the following special variables, in addition to the matrix (such as, <db:code>MODEL_MATRIX</db:code>) and vector (such as, <db:code>CAMERA_POSITION</db:code>) uniforms from the table above:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec3 <db:code>LIGHT_COLOR</db:code> Specular light color.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>LIGHT_ATTENUATION</db:code> Light attenuation. For directional lights the value is 1.0. For spot lights the value is the same as <db:code>LIGHT_ATTENUATION * SPOT_FACTOR</db:code> of <db:code>void SPOT_LIGHT()</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>SHADOW_CONTRIB</db:code> Shadow contribution, or 1.0 if not shadowed at all or not reciving shadows.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>FRESNEL_CONTRIB</db:code> Fresnel contribution from built in Fresnel calculation.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>TO_LIGHT_DIR</db:code> Vector pointing towards the light source.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>NORMAL</db:code> The normal vector in world space.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec4 <db:code>BASE_COLOR</db:code> The base color and material alpha value.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>METALNESS</db:code> The Metalness amount.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>ROUGHNESS</db:code> The Roughness amount.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>SPECULAR_AMOUNT</db:code> The specular amount. This value will be between 0.0 and 1.0 will be the same value set in the custom <db:code>MAIN</db:code> function. This value will useful for calculating Fresnel contributions when not using the built-in Fresnel contribution provided by <db:code>FRESNEL_CONTRIB</db:code>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:programlisting language="cpp" role="bad">void SPECULAR_LIGHT()
{
    vec3 H = normalize(VIEW_VECTOR + TO_LIGHT_DIR);
    float cosAlpha = max(0.0, dot(H, normalize(NORMAL)));
    float shine = pow(cosAlpha, exp2(15.0 * (1.0 - ROUGHNESS) + 1.0) * 0.25);
    SPECULAR += shine * LIGHT_COLOR * FRESNEL_CONTRIB * SHADOW_CONTRIB * LIGHT_ATTENUATION;
}
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>void POST_PROCESS()</db:code> When present, this function is called at the end of the fragment pipeline. The task of the function is to finalize <db:code>COLOR_SUM</db:code> with final diffuse, specular and emissive terms. Unlike <db:code>FRAGCOLOR</db:code> for a unshaded material, <db:code>COLOR_SUM</db:code> will be automatically tonemapped before written to the framebuffer. For debugging purposes it is sometimes useful to output a value that should not be treated as a color. To avoid the tonemapping distorting this value it can be disabled by setting the <db:link xlink:href="qml-qtquick3d-sceneenvironment.xml#tonemapMode-prop">tonemapMode</db:link> property to <db:code>TonemapModeNone</db:code></db:para>
<db:para>The function can write to the following special variables:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec4 <db:code>COLOR_SUM</db:code> the output from the fragment shader. The default value is vec4(DIFFUSE.rgb + SPECULAR + EMISSIVE, DIFFUSE.a)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The function can read the following special variables.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec4 <db:code>DIFFUSE</db:code> The final diffuse term of the fragment pipeline.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>SPECULAR</db:code> The final specular term of the fragment pipeline.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>EMISSIVE</db:code> The final emissive term of the fragment pipeline.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec2 <db:code>UV0</db:code> - The first set of texture coordinates from the vertex shader.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec2 <db:code>UV1</db:code> - The second set of texture coordinates from the vertex shader.</db:para>
</db:listitem>
</db:itemizedlist>
<db:programlisting language="cpp" role="bad">void POST_PROCESS()
{
    float center_x = textureSize(SCREEN_TEXTURE, 0).x * 0.5;
    if (gl_FragCoord.x &amp;gt; center_x)
        COLOR_SUM = DIFFUSE;
    else
        COLOR_SUM = vec4(EMISSIVE, DIFFUSE.a);
}
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>void IBL_PROBE()</db:code> When present, this function is called for IBL (Image-Based Lighting). The task of the function is to add both the diffuse and the specular contributions of IBL to writable special variables <db:code>DIFFUSE</db:code> and <db:code>SPECULAR</db:code>.</db:para>
<db:para>The function can write to the following special variables:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec3 <db:code>DIFFUSE</db:code> Accumulates the diffuse light contributions, per fragment.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>SPECULAR</db:code> Accumulates the specular light contributions, per frament.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The function can read the following special variables.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec4 <db:code>BASE_COLOR</db:code> The base color and material alpha value.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>AO_FACTOR</db:code> The screen space occlusion factor.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>SPECULAR_AMOUNT</db:code> The specular amount.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>ROUGHNESS</db:code> The final emissive term of the fragment pipeline.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>NORMAL</db:code> The normal vector in world space.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>VIEW_VECTOR</db:code> Points towards the camera.</db:para>
</db:listitem>
<db:listitem>
<db:para>mat3 <db:code>IBL_ORIENTATION</db:code> The orientation of the light probe. It comes from <db:link xlink:href="qml-qtquick3d-sceneenvironment.xml#probeOrientation-prop">SceneEnvironment::probeOrientation</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:programlisting language="cpp" role="bad">void IBL_PROBE()
{
    vec3 smpDir = IBL_ORIENTATION * NORMAL;
    DIFFUSE += AO_FACTOR * BASE_COLOR.rgb * textureLod(IBL_TEXTURE, smpDir, IBL_MAXMIPMAP).rgb;
}
</db:programlisting>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="custom-variables-between-functions">
<db:title>Custom variables between functions</db:title>
<db:para>Additional variables can be delivered from the MAIN function to the others. The <db:code>SHARED_VARS</db:code> keyword can be used for defining new custom variables. These user-defined variables can be accessed with SHARED.&lt;variable name&gt;.</db:para>
<db:para>For example, a shaded custom material can fetch a shared value in the MAIN and use it in other functions.</db:para>
<db:programlisting language="cpp" role="bad">SHARED_VARS {
    vec3 colorThreshold;
};
void MAIN()
{
    BASE_COLOR = texture(baseColorMap, UV0);
    SHARED.colorThreshold = texture(thresholdMap, UV0).rgb;
}
void DIRECTIONAL_LIGHT()
{
    if (DIFFUSE &amp;gt;= SHARED.colorThreshold) {
        DIFFUSE = SHARED.colorThreshold;
        return;
    }
    DIFFUSE += LIGHT_COLOR * SHADOW_CONTRIB;
}
</db:programlisting>
<db:note>
<db:para>SHARED can be written on all the functions without POST_PROCESS but it is safe to write it on MAIN and read on the other functions.</db:para>
</db:note>
<db:note>
<db:para>A recommended use case to write SHARED on LIGHT functions is reseting it on MAIN first and then accumulating it on each LIGHT functions.</db:para>
</db:note>
<db:programlisting language="cpp" role="bad">SHARED_VARS {
    float sheenIntensity;
    float sheenRoughness;
    vec3 sheenColor;
    vec3 outSheenColor;
};
void MAIN()
{
    ...
    vec4 tex = texture(uSheenMap, UV0);
    SHARED.sheenColor = tex.rgb;
    SHARED.sheenIntensity = tex.a;
    SHARED.sheenRoughness = uSheenRoughness;
    SHARED.outSheenColor = vec3(0.0);
}
void SPECULAR_LIGHT()
{
    SHARED.outSheenColor += ...;
}
void POST_PROCESS()
{
    COLOR_SUM = DIFFUSE + SPECULAR + EMISSIVE + SHARED.outSheenColor;
}
</db:programlisting>
<db:note>
<db:para>MAIN is called before others, and POST_PROCESS after all others, but that there is no guarantee for any other ordering for light processors.</db:para>
</db:note>
</db:section>
<db:section xml:id="additional-special-keywords">
<db:title>Additional special keywords</db:title>
<db:para>The custom fragment shader code can freely access uniforms (such as, <db:code>CAMERA_DIRECTION</db:code> or <db:code>CAMERA_POSITION</db:code>), and varyings passed on from the custom vertex shader. Additionally, there are a number of built-in varyings available as special keywords. Some of these are optional in the sense that a vertex <db:code>MAIN</db:code> could calculate and pass on these on its own, but to reduce duplicated data fragment shaders can also rely on these built-ins instead. These built-ins are available in light processor functions and in the fragment MAIN.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>vec3 <db:code>VAR_WORLD_NORMAL</db:code> - Interpolated normal transformed by <db:code>NORMAL_MATRIX</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>VAR_WORLD_TANGENT</db:code> - Interpolated tangent transformed by <db:code>MODEL_MATRIX</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>VAR_WORLD_BINORMAL</db:code> - Interpolated binormal transformed by <db:code>MODEL_MATRIX</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>NORMAL</db:code> - Unlike <db:code>VAR_WORLD_NORMAL</db:code>, which is the interpolated normal as-is, this value is potentially adjusted for double-sidedness: when rendering with culling disabled, the normal will get inverted as necessary. Therefore lighting and other calculations are recommended to use <db:code>NORMAL</db:code> instead of <db:code>VAR_WORLD_NORMAL</db:code> in order behave correctly with all culling modes.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>TANGENT</db:code> - Like <db:code>NORMAL</db:code>, this value is potentially adjusted for double-sidedness: when rendering with culling disabled, the tangent will get inverted as necessary.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>BINORMAL</db:code> - Like <db:code>NORMAL</db:code>, this value is potentially adjusted for double-sidedness: when rendering with culling disabled, the binormal will get inverted as necessary.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>VAR_WORLD_POSITION</db:code> - Interpolated world space vertex position (<db:code>(MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz</db:code>)</db:para>
</db:listitem>
<db:listitem>
<db:para>vec4 <db:code>VAR_COLOR</db:code> - The interpolated vertex color when colors are provided in the mesh. <db:code>vec4(1.0)</db:code> otherwise.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec3 <db:code>VIEW_VECTOR</db:code> - Points towards the camera. This is effectively the <db:code>CAMERA_POSITION - VAR_WORLD_POSITION</db:code> vector normalized.</db:para>
</db:listitem>
<db:listitem>
<db:para>vec4 <db:code>FRAGCOORD</db:code> - Contains the window-relative coordinates of the current fragment.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>FRAMEBUFFER_Y_UP</db:code> - The value is <db:code>1</db:code> when the Y axis points up in the coordinate system for framebuffers (textures), meaning <db:code>(0, 0)</db:code> is the bottom-left corner. The value is <db:code>-1</db:code> when the Y axis points down, <db:code>(0, 0)</db:code> being the top-left corner. Such differences in the underlying graphics APIs do not concern most custom materials. One notable exception is sampling <db:code>SCREEN_TEXTURE</db:code> with texture coordinates <db:emphasis role="bold">not</db:emphasis> based on <db:code>FRAGCOORD</db:code>. As the orientation of <db:code>SCREEN_TEXTURE</db:code> is tied to the underlying graphics API by nature, using texture coordinates from a mesh may need appropriate adjustments to the Y coordinate.</db:para>
<db:para>For example, the following fragment shader, suitable for Rectangle or Cube meshes, will display the opaque objects from the scene on the model:</db:para>
<db:programlisting language="cpp" role="bad">VARYING vec2 texcoord;
void MAIN()
{
    vec2 screencoord = texcoord;
    if (FRAMEBUFFER_Y_UP &amp;lt; 0.0) // effectively: if not OpenGL
        screencoord.y = 1.0 - screencoord.y;
    BASE_COLOR = texture(SCREEN_TEXTURE, screencoord);
}
</db:programlisting>
<db:para>When sampling textures other than <db:code>SCREEN_TEXTURE</db:code> and <db:code>DEPTH_TEXTURE</db:code>, or when <db:code>FRAGCOORD</db:code> is used to calculate the texture coordinate (which would be the typical use case for accessing the screen and depth textures), such an adjustment is not necessary.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>NDC_Y_UP</db:code> - The value is <db:code>1</db:code> when the Y axis points up in normalized device coordinate space, and <db:code>-1</db:code> when the Y axis points down. Y pointing down is the case when rendering happens with Vulkan. Most materials do not need to be concerned by this, but being able to branch based on this can become useful in certain advanced use cases.</db:para>
</db:listitem>
<db:listitem>
<db:para>float <db:code>NEAR_CLIP_VALUE</db:code> - The value is <db:code>-1</db:code> for when the clipping plane range's starts at <db:code>-1</db:code> and goes to <db:code>1</db:code>. This is true when using OpenGL for rendering. For other rendering backends the value of this property will be <db:code>0</db:code> meaning the clipping plane range is <db:code>0</db:code> to <db:code>1</db:code>. This value is useful with certain techniques involving the <db:code>DEPTH_TEXTURE</db:code></db:para>
<db:para>For example, the following fragment shader demonstrates a technique for reconstructing the position of a value from the depth buffer to determine the distance from the current position being rendered. When used in combination with <db:code>INVERSE_PROJECTION_MATRIX</db:code> the value of depth needs to be in normalized device coordinates so it is important to make sure that the range of depth value reflects that. When the <db:code>NEAR_CLIP_VALUE</db:code> is <db:code>-1</db:code> then the depth value gets scaled to be between <db:code>-1</db:code> and <db:code>1</db:code>.</db:para>
<db:programlisting language="cpp" role="bad">void MAIN() {
    vec2 screen_uv = FRAGCOORD.xy / vec2(textureSize(SCREEN_TEXTURE, 0));
    float depth = texture(DEPTH_TEXTURE, screen_uv).r;

    if (NEAR_CLIP_VALUE &amp;lt; 0.0) // effectively: if opengl
        depth = depth * 2.0 - 1.0;

    vec4 unproject = INVERSE_PROJECTION_MATRIX * vec4(screen_uv, depth, 1.0);
    depth = (unproject.xyz / unproject.w).z;
    float viewVectorZ = (VIEW_MATRIX * vec4(VAR_WORLD_POSITION, 1.0)).z;
    depth = viewVectorZ - depth;

    BASE_COLOR = vec4(depth, depth, depth, 1.0);
}
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para>float <db:code>IBL_EXPOSE</db:code> - The amount of light emitted by the light probe. It comes from <db:link xlink:href="qml-qtquick3d-sceneenvironment.xml#probeExposure-prop">SceneEnvironment::probeExposure</db:link>.</db:para>
<db:programlisting language="cpp" role="bad">DIFFUSE += AO_FACTOR * IBL_EXPOSE * BASE_COLOR.rgb * textureLod(IBL_TEXTURE, NORMAL, IBL_MAXMIPMAP).rgb;
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para>float <db:code>IBL_HORIZON</db:code> - The horizontal cut-off value of reflections from the lower half environment. It comes from <db:link xlink:href="qml-qtquick3d-sceneenvironment.xml#probeHorizon-prop">Horizon Cut-Off</db:link> but remapped to [-1, 0).</db:para>
<db:programlisting language="cpp" role="bad">vec3 diffuse += AO_FACTOR * IBL_EXPOSE * BASE_COLOR.rgb * textureLod(IBL_TEXTURE, NORMAL, IBL_MAXMIPMAP).rgb;
if (IBL_HORIZON &amp;gt; -1.0) {
    float ctr = 0.5 + 0.5 * IBL_HORIZON;
    float vertWt = smoothstep(ctr * 0.25, ctr + 0.25, NORMAL.y);
    float wtScaled = mix(1.0, vertWt, IBL_HORIZON + 1.0);
    diffuse *= wtScaled;
}
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para>float <db:code>IBL_MAXMIPMAP</db:code> - The maximum mipmap level of IBL_TEXTURE.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="instancing">
<db:title>Instancing</db:title>
<db:para>When doing instanced rendering, some of the keywords above do not apply. The following keywords are only available with instancing:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>INSTANCE_MODEL_MATRIX</db:code> -&gt; mat4, replacement for <db:code>MODEL_MATRIX</db:code>, including the instancing transformation.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>INSTANCE_MODELVIEWPROJECTION_MATRIX</db:code> -&gt; mat4, replacement for <db:code>MODELVIEWPROJECTION_MATRIX</db:code>, including the instancing transformation.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>INSTANCE_COLOR</db:code> -&gt; vec4, the instance color: to be combined with <db:code>COLOR</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>INSTANCE_DATA</db:code> -&gt; vec4, instance custom data.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>INSTANCE_INDEX</db:code> -&gt; int, the instance number, and index into the instancing table.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="screen-depth-and-other-textures">
<db:title>Screen, depth, and other textures</db:title>
<db:para>The rendering pipeline can expose a number of textures to the custom material shaders with content from special render passes. This applies both to shaded and unshaded custom materials.</db:para>
<db:para>For example, a shader may want access to a depth texture that contains the depth buffer contents for the opaque objects in the scene. This is achieved by sampling <db:code>DEPTH_TEXTURE</db:code>. Such a texture is not normally generated, unless there is a real need for it. Therefore, the presence of the following keywords in the vertex or fragment shader also acts as a toggle for opting in to the - potentially expensive - passes for generating the texture in question. (of course, it could be that some of these become already enabled due to other settings, such as the ambient occlusion parameters in <db:link xlink:href="qml-qtquick3d-sceneenvironment.xml">SceneEnvironment</db:link> or due to a post-processing effect relying on the depth texture, in which case the textures in question are generated regardless of the custom material and so sampling these special textures in the material comes at no extra cost apart from the texture access itself)</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>SCREEN_TEXTURE</db:code> - When present, a texture (sampler2D) with the color buffer from a rendering pass containing the contents of the scene excluding any transparent materials or any materials also using the SCREEN_TEXTURE is exposed to the shader under this name. The texture can be used for techniques that require the contents of the framebuffer they are being rendered to. The SCREEN_TEXTURE texture uses the same clear mode as the <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link>. The size of these textures matches the size of the <db:link xlink:href="qml-qtquick3d-view3d.xml">View3D</db:link> in pixels. For example, a fragment shader could contain the following:</db:para>
<db:programlisting language="cpp" role="bad">vec2 uv = FRAGCOORD.xy / vec2(textureSize(SCREEN_TEXTURE, 0));
vec2 displace = vec2(0.1);
vec4 c = texture(SCREEN_TEXTURE, uv + displace);
</db:programlisting>
<db:para>Be aware that using <db:code>SCREEN_TEXTURE</db:code> requires appropriate, conscious design of the scene. Objects using such materials have to be positioned carefully, typically above all other objects that are expected to be visible in the texture. Objects that employ semi-transparency in some form are never part of the <db:code>SCREEN_TEXTURE</db:code>. Often <db:code>SCREEN_TEXTURE</db:code> will be used in combination with <db:code>BASE_COLOR</db:code> in <db:code>MAIN</db:code>. For example, the following custom fragment shader applies an emboss effect, while keeping fragments not touched by opaque objects transparent. This assumes that the object with the material is placed in the front, and that it has blending enabled.</db:para>
<db:programlisting language="cpp" role="bad">void MAIN()
{
    vec2 size = vec2(textureSize(SCREEN_TEXTURE, 0));
    vec2 uv = FRAGCOORD.xy / size;

    // basic emboss effect
    vec2 d = vec2(1.0 / size.x, 1.0 / size.y);
    vec4 diff = texture(SCREEN_TEXTURE, uv + d) - texture(SCREEN_TEXTURE, uv - d);
    float c = (diff.x + diff.y + diff.z) + 0.5;

    float alpha = texture(SCREEN_TEXTURE, uv).a;
    BASE_COLOR = vec4(vec3(c), alpha);
}
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>SCREEN_MIP_TEXTURE</db:code> - Identical to <db:code>SCREEN_TEXTURE</db:code> in most ways, the difference being that this texture has mipmaps generated. This can be an expensive feature performance-wise, depending on the screen size, and due to having to generate the mipmaps every time the scene is rendered. Therefore, prefer using <db:code>SCREEN_TEXTURE</db:code> always, unless a technique relying on the texture mip levels (e.g. using <db:code>textureLod</db:code> in the shader) is implemented by the custom material.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>DEPTH_TEXTURE</db:code> - When present, a texture (sampler2D) with the (non-linearized) depth buffer contents is exposed to the shader under this name. Only opaque objects are included. For example, a fragment shader could contain the following:</db:para>
<db:programlisting language="cpp" role="bad">ivec2 dtSize = textureSize(DEPTH_TEXTURE, 0);
vec2 dtUV = (FRAGCOORD.xy) / vec2(dtSize);
vec4 depthSample = texture(DEPTH_TEXTURE, dtUV);
float zNear = CAMERA_PROPERTIES.x;
float zFar = CAMERA_PROPERTIES.y;
float zRange = zFar - zNear;
float z_n = 2.0 * depthSample.r - 1.0;
float d = 2.0 * zNear * zFar / (zFar + zNear - z_n * zRange);
d /= zFar;
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>AO_TEXTURE</db:code> - When present and screen space ambient occlusion is enabled (meaning when the AO strength and distance are both non-zero) in <db:link xlink:href="qml-qtquick3d-sceneenvironment.xml">SceneEnvironment</db:link>, the SSAO texture (sampler2D) is exposed to the shader under this name. Sampling this texture can be useful in unshaded materials. Shaded materials have ambient occlusion support built in. This means that the ambient occlusion factor is taken into account automatically. Whereas in a fragment shader for an unshaded material one could write the following to achieve the same:</db:para>
<db:programlisting language="cpp" role="bad">ivec2 aoSize = textureSize(AO_TEXTURE, 0);
vec2 aoUV = (FRAGCOORD.xy) / vec2(aoSize);
float aoFactor = texture(AO_TEXTURE, aoUV).x;
</db:programlisting>
</db:listitem>
<db:listitem>
<db:para><db:code>IBL_TEXTURE</db:code> - It will not enable any special rendering pass, but it can be used when the material has <db:link xlink:href="qml-qtquick3d-material.xml#lightProbe-prop">Material::lightProbe</db:link> or the model is in the scope of <db:link xlink:href="qml-qtquick3d-sceneenvironment.xml#lightProbe-prop">SceneEnvironment::lightProbe</db:link>.</db:para>
<db:programlisting language="cpp" role="bad">void IBL_PROBE()
{
    DIFFUSE += AO_FACTOR * BASE_COLOR.rgb * textureLod(IBL_TEXTURE, NORMAL, IBL_MAXMIPMAP).rgb;
}
</db:programlisting>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick3d-sceneenvironment.xml#tonemapMode-prop">SceneEnvironment::tonemapMode</db:link></db:member>
<db:member><db:link xlink:href="quick3d-asset-conditioning-ibl.xml">Using Image-Based Lighting</db:link></db:member>
<db:member><db:link xlink:href="qtquick3d-customshaders-example.xml">Qt Quick 3D - Custom Shaders Example</db:link></db:member>
<db:member><db:link xlink:href="qtquick3d-custommaterial-example.xml">Qt Quick 3D - Custom Materials Example</db:link></db:member>
<db:member><db:link xlink:href="qtquick3d-custom.xml">Programmable Materials, Effects, Geometry, and Texture data</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="alwaysDirty-prop">
<db:title>alwaysDirty : bool</db:title>
<db:fieldsynopsis>
<db:type>bool</db:type>
<db:varname>alwaysDirty</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Specifies that the material state is always dirty, which indicates that the material needs to be refreshed every time it is used by the <db:link xlink:href="qtquick3d-qmlmodule.xml">QtQuick3D</db:link>.</db:para>
</db:section>
<db:section xml:id="destinationBlend-prop">
<db:title>destinationBlend : enumeration</db:title>
<db:fieldsynopsis>
<db:type>enumeration</db:type>
<db:varname>destinationBlend</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Specifies the destination blend factor. The default value is <db:code>CustomMaterial.NoBlend</db:code>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>CustomMaterial.NoBlend</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.Zero</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.One</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.SrcColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.OneMinusSrcColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.DstColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.OneMinusDstColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.SrcAlpha</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.OneMinusSrcAlpha</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.DstAlpha</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.OneMinusDstAlpha</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.ConstantColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.OneMinusConstantColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.ConstantAlpha</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.OneMinusConstantAlpha</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.SrcAlphaSaturate</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="fragmentShader-prop">
<db:title>fragmentShader : url</db:title>
<db:fieldsynopsis>
<db:type>url</db:type>
<db:varname>fragmentShader</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Specfies the file with the snippet of custom fragment shader code.</db:para>
<db:para>The value is a URL and must either be a local file or use the qrc scheme to access files embedded via the Qt resource system. Relative file paths (without a scheme) are also accepted, in which case the file is treated as relative to the component (the <db:code>.qml</db:code> file).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick3d-custommaterial.xml#vertexShader-prop">vertexShader</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="lineWidth-prop">
<db:title>lineWidth : real</db:title>
<db:fieldsynopsis>
<db:type>real</db:type>
<db:varname>lineWidth</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property determines the width of the lines rendered, when the geometry is using a primitive type of lines or line strips. The default value is 1.0. This property is not relevant when rendering other types of geometry, such as, triangle meshes.</db:para>
<db:warning>
<db:para>Line widths other than 1 may not be suported at run time, depending on the underlying graphics API. When that is the case, the request to change the width is ignored. For example, none of the following can be expected to support wide lines: Direct3D, Metal, OpenGL with core profile contexts.</db:para>
</db:warning>
<db:note>
<db:para>Unlike the line width, the value of which is part of the graphics pipeline object, the point size for geometries with a topology of points is controlled by the vertex shader (when supported), and has therefore no corresponding QML property.</db:para>
</db:note>
</db:section>
<db:section xml:id="shadingMode-prop">
<db:title>shadingMode : enumeration</db:title>
<db:fieldsynopsis>
<db:type>enumeration</db:type>
<db:varname>shadingMode</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Specifies the type of the material. The default value is Shaded.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>CustomMaterial.Unshaded</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.Shaded</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="sourceBlend-prop">
<db:title>sourceBlend : enumeration</db:title>
<db:fieldsynopsis>
<db:type>enumeration</db:type>
<db:varname>sourceBlend</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Specifies the source blend factor. The default value is <db:code>CustomMaterial.NoBlend</db:code>.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para>CustomMaterial.NoBlend</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.Zero</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.One</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.SrcColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.OneMinusSrcColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.DstColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.OneMinusDstColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.SrcAlpha</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.OneMinusSrcAlpha</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.DstAlpha</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.OneMinusDstAlpha</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.ConstantColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.OneMinusConstantColor</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.ConstantAlpha</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.OneMinusConstantAlpha</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para>CustomMaterial.SrcAlphaSaturate</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="vertexShader-prop">
<db:title>vertexShader : url</db:title>
<db:fieldsynopsis>
<db:type>url</db:type>
<db:varname>vertexShader</db:varname>
<db:modifier>writable</db:modifier>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Specfies the file with the snippet of custom vertex shader code.</db:para>
<db:para>The value is a URL and must either be a local file or use the qrc scheme to access files embedded via the Qt resource system. Relative file paths (without a scheme) are also accepted, in which case the file is treated as relative to the component (the <db:code>.qml</db:code> file).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qml-qtquick3d-custommaterial.xml#fragmentShader-prop">fragmentShader</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
