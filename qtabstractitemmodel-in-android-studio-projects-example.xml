<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Using QtAbstractItemModel in Android Studio Projects</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Shows how to handle complex data types and apply conditional formatting to a table view format using QtAbstractItemModel class and QtModelIndex class.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The Qt Quick for Android API examples are provided as Android Studio projects. The project folders are found in your Qt install location.</db:para>
<db:para>For example, under the default Windows install path, they are found here:</db:para>
<db:programlisting language="cpp" role="bad">C:\Qt\Examples\Qt-/1\platforms\android
</db:programlisting>
<db:section xml:id="overview">
<db:title>Overview</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtabstractitemmodel_portrait.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>This example consists of two projects: an Android Studio project (qtabstractitemmodel_java) and a QML project (qtabstractitemmodel). You can import the QML project into an Android project.</db:para>
<db:para>The example shows how to handle complex data types between Java and QML. It demonstrates how to use the <db:code>QtAbstractItemModel</db:code> and <db:code>QtModelIndex</db:code> Java API classes. In QML, the data usage is demonstrated with the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> item. In Java, data usage is demonstrated with a model of nested ArrayList items for rows and columns. For more information on how QML works, see <db:link xlink:href="qtqml-index.xml">Qt Qml</db:link>.</db:para>
</db:section>
<db:section xml:id="running-the-example">
<db:title>Running the example</db:title>
<db:para>To run this example, you need Android Studio and <db:link xlink:href="">Qt Tools for Android Studio</db:link> on top of a standard Qt for Android installation. Open qtabstractitemmodel_java in Android Studio and follow the instructions in <db:link xlink:href="">Qt Tools for Android Studio</db:link> to import the <db:code>qtabstractitemmodel</db:code>.</db:para>
</db:section>
<db:section xml:id="qml-project">
<db:title>QML project</db:title>
<db:para>On the QML project side, the example uses a <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link> as the root object. The <db:code>dataModel</db:code> property variable holds the data model created and delivered from the Java side.</db:para>
<db:programlisting language="qml">Rectangle {
    id: mainRectangle

    property AbstractItemModel dataModel
</db:programlisting>
<db:para><db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> displays our data model.</db:para>
<db:programlisting language="qml">    TableView {
        id: tableView

        model: mainRectangle.dataModel

        anchors {fill: parent; margins: 20}
        columnSpacing: 4
        rowSpacing: 6
        boundsBehavior: TableView.OvershootBounds
        clip: true

        ScrollBar.vertical: ScrollBar {
           policy: ScrollBar.AsNeeded
        }
        ScrollBar.horizontal: ScrollBar{
           policy: ScrollBar.AsNeeded
        }
</db:programlisting>
<db:para>On the <db:code>delegate</db:code> property, each cell item of the model is defined with a <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link> containing a <db:link xlink:href="qml-qtquick-textedit.xml">TextEdit</db:link>. The text property of the <db:code>TextEdit</db:code> is set using the <db:link xlink:href="qabstractitemmodel.xml#data">QAbstractItemModel::data</db:link>() which returns a value based on the given role and index.</db:para>
<db:para>Calling these methods from QML means the execution takes place in the Qt qtMainLoopThread thread context.</db:para>
<db:programlisting language="qml">        delegate: Rectangle {
            implicitWidth: (tableView.height &gt; tableView.width) ? tableView.width / 10 : tableView.height / 5
            implicitHeight: implicitWidth

            required property var model

            color: &quot;#2CDE85&quot;
            border {color: &quot;#00414A&quot;; width: 2}

            TextEdit {
                // Calls MyDataModel::data to get data based on the roles.
                // Called in Qt qtMainLoopThread thread context.
                //
                // After editing is finished, call MyDataModel::setData()
                // to update the value of selected cell.
                onEditingFinished: parent.model.edit = text

                text: parent.model.display
                font {pixelSize: 26; bold: true}
                padding: 5
                anchors.fill: parent
                wrapMode: TextEdit.Wrap
                horizontalAlignment: TextEdit.AlignHCenter
                verticalAlignment: TextEdit.AlignVCenter
            }
        }
</db:programlisting>
<db:para>In the case of editing the <db:link xlink:href="qml-qtquick-textedit.xml">TextEdit</db:link> field, <db:code>onEditingFinished()</db:code> handler sets the model's <db:code>edit</db:code> role value to the edited text. This calls the <db:link xlink:href="qabstractitemmodel.xml#setData">QAbstractItemModel::setData</db:link>() method, where the edited text of the cell is updated to the corresponding index of the model.</db:para>
<db:para>For more information see <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link>.</db:para>
</db:section>
<db:section xml:id="android-studio-project">
<db:title>Android Studio project</db:title>
<db:para>The Android Studio project (qtabstractitemmodel_java) contains one Activity class <db:code>MainActivity</db:code> and <db:code>MyDataModel</db:code> class.</db:para>
<db:section xml:id="data-model">
<db:title>Data Model</db:title>
<db:para>The data model, <db:code>MyDataModel</db:code>, extends <db:code>QtAbstractItemModel</db:code> class. The <db:code>QtAbstractItemModel</db:code> is a wrapper for <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link>.</db:para>
<db:para>As the methods of <db:code>MyDataModel</db:code> class are called from both, QML and Android sides, the execution occurs in both thread contexts, Qt qtMainLoopThread, and Android main thread contexts. You must ensure synchronization when accessing member variables in methods of the <db:code>MyDataModel</db:code> class.</db:para>
<db:para>First, the example initializes the model with a simple row and column mock data set. Note that this constructor method is called in the Android main thread context.</db:para>
<db:programlisting language="cpp">/*
* Initializes the two-dimensional array list with following content:
* [] [] [] [] 1A 1B 1C 1D
* [] [] [] [] 2A 2B 2C 2D
* [] [] [] [] 3A 3B 3C 3D
* [] [] [] [] 4A 4B 4C 4D
* Threading: called in Android main thread context.
*/
public MyDataModel() {
</db:programlisting>
<db:para>The example overrides the <db:code>QtAbstractItemModel</db:code> methods for different purposes. The columnCount() and rowCount() methods return the count of each in a model. The execution of each rowCount() occurs in both thread contexts, Qt qtMainLoopThread and Android main thread contexts.</db:para>
<db:programlisting language="cpp">/*
* Returns the count of columns.
* Threading: called in Android main thread context.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public int columnCount(QtModelIndex qtModelIndex) {
    return m_columns;
}

/*
* Returns the count of rows.
* Threading: called in Android main thread context.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public int rowCount(QtModelIndex qtModelIndex) {
    return m_dataList.size();
}
</db:programlisting>
<db:para>Method data() provides model data based on the role and index from Java to QML. The roleNames() method returns a hash matching numerical role values to their names as strings; in QML, we use these role names to fetch corresponding data from the model. The index() method returns the new model index. Method parent() should return a parent of the index. Still, as this example focuses on data without parent indices, we override the method and return an empty QtModelIndex(). As the methods are called from QML, the execution occurs in the Qt qtMainLoopThread thread context.</db:para>
<db:programlisting language="cpp">/*
* Returns the data to QML based on the roleNames
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public Object data(QtModelIndex qtModelIndex, int role) {
    if (role == ROLE_DISPLAY) {
        Cell elementForEdit = m_dataList.get(qtModelIndex.row()).get(qtModelIndex.column());
        return elementForEdit.getValue();
    }
    Log.w(TAG, &quot;data(): unrecognized role: &quot; + role);
    return null;
}

/*
* Defines what string i.e. role in QML side gets the data from Java side.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public HashMap&lt;Integer, String&gt; roleNames() {
    HashMap&lt;Integer, String&gt; roles = new HashMap&lt;&gt;();
    roles.put(ROLE_DISPLAY, &quot;display&quot;);
    roles.put(ROLE_EDIT, &quot;edit&quot;);
    return roles;
}

/*
* Returns a new index model.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public QtModelIndex index(int row, int column, QtModelIndex parent) {
    return createIndex(row, column, 0);
}

/*
* Returns a parent model.
* Threading: not used called in this example.
*/
@Override
synchronized public QtModelIndex parent(QtModelIndex qtModelIndex) {
    return new QtModelIndex();
}
</db:programlisting>
<db:para>The example overrides the <db:link xlink:href="qabstractitemmodel.xml#setData">QAbstractItemModel::setData</db:link>() method, which is called when model's data at <db:code>index</db:code> is set from the QML side of the application.</db:para>
<db:programlisting language="cpp">/*
* Gets called when model data is edited from QML side.
* Sets the role data for the item at index to value,
* if given index is valid and if data in given index truly changed.
*/
@Override
synchronized public boolean setData(QtModelIndex index, Object value, int role) {
    Cell cellAtIndex = m_dataList.get(index.row()).get(index.column());
    String cellValueAtIndex = cellAtIndex.getValue();
    if (!index.isValid() || role != ROLE_EDIT
            || Objects.equals(cellValueAtIndex, value.toString())) {
        return false;
    }
    cellAtIndex.setValue(value.toString());
    // Send dataChanged() when data was successfully set.
    dataChanged(index, index, new int[]{role});
    return true;
}
</db:programlisting>
<db:para>The example implements methods on the model side for <db:code>MainActivity</db:code> UI interaction to add and remove rows and columns. Calls begin, end, insert, and remove rows to update model indexes, like beginInsertRow(). Because the example uses the <db:code>QtAbstractItemModel</db:code>, it must call beginInsertRows() and endInsertRows() every time it inserts new rows into the model. The same applies to removal. As the methods are called from the Android side, the execution takes place in the Android main thread context.</db:para>
<db:programlisting language="cpp">/*
* Adds a row.
* Threading: called in Android main thread context.
*/
synchronized public void addRow() {
    if (m_columns &gt; 0 &amp;&amp; m_dataList.size() &lt; MAX_ROWS_AND_COLUMNS) {
        beginInsertRows(new QtModelIndex(), m_dataList.size(), m_dataList.size());
        m_dataList.add(generateNewRow());
        endInsertRows();
    }
}

/*
* Removes a row.
* Threading: called in Android main thread context.
*/
synchronized public void removeRow() {
    if (m_dataList.size() &gt; 1) {
        beginRemoveRows(new QtModelIndex(), m_dataList.size() - 1, m_dataList.size() - 1);
        m_dataList.remove(m_dataList.size() - 1);
        endRemoveRows();
    }
}
</db:programlisting>
<db:para>The example implements methods on the model side for <db:code>MainActivity</db:code> UI interaction to add and remove columns. Calls begin, end, insert, and remove columns to update model indexes, like beginRemoveColumn(). The same context awareness applies as with the add and remove row methods.</db:para>
<db:programlisting language="cpp">/*
* Adds a column.
* Threading: called in Android main thread context.
*/
synchronized public void addColumn() {
    if (!m_dataList.isEmpty() &amp;&amp; m_columns &lt; MAX_ROWS_AND_COLUMNS) {
        beginInsertColumns(new QtModelIndex(), m_columns, m_columns);
        generateNewColumn();
        m_columns += 1;
        endInsertColumns();
    }
}

/*
* Removes a column.
* Threading: called in Android main thread context.
*/
synchronized public void removeColumn() {
    if (m_columns &gt; 1) {
        int columnToRemove = m_columns - 1;
        beginRemoveColumns(new QtModelIndex(), columnToRemove, columnToRemove);
        for (int row = 0; row &lt; m_dataList.size(); row++)
            m_dataList.get(row).remove(columnToRemove);
        m_columns -= 1;
        endRemoveColumns();
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="main-activity">
<db:title>Main Activity</db:title>
<db:para><db:code>MainActivity</db:code> implements the <db:code>QtQmlStatusChangeListener</db:code> interface to get status updates when the QML is loaded. It is also the main Android activity.</db:para>
<db:para>The example creates and initializes the data model. See also <db:link xlink:href="qtquickview-android-class.xml">QtQuickView</db:link></db:para>
<db:programlisting language="cpp">private final MyDataModel m_model = new MyDataModel();
</db:programlisting>
<db:para>The example sets the UI button and its listeners to allow the users to interact with the model via the UI.</db:para>
<db:programlisting language="cpp">/*
* Returns the count of columns.
* Threading: called in Android main thread context.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public int columnCount(QtModelIndex qtModelIndex) {
    return m_columns;
}

/*
* Returns the count of rows.
* Threading: called in Android main thread context.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public int rowCount(QtModelIndex qtModelIndex) {
    return m_dataList.size();
}
</db:programlisting>
<db:para>The example starts loading the QML content. Loading happens in the background until the <db:code>ready</db:code> status is updated.</db:para>
<db:programlisting language="cpp">/*
* Returns the data to QML based on the roleNames
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public Object data(QtModelIndex qtModelIndex, int role) {
    if (role == ROLE_DISPLAY) {
        Cell elementForEdit = m_dataList.get(qtModelIndex.row()).get(qtModelIndex.column());
        return elementForEdit.getValue();
    }
    Log.w(TAG, &quot;data(): unrecognized role: &quot; + role);
    return null;
}

/*
* Defines what string i.e. role in QML side gets the data from Java side.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public HashMap&lt;Integer, String&gt; roleNames() {
    HashMap&lt;Integer, String&gt; roles = new HashMap&lt;&gt;();
    roles.put(ROLE_DISPLAY, &quot;display&quot;);
    roles.put(ROLE_EDIT, &quot;edit&quot;);
    return roles;
}

/*
* Returns a new index model.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public QtModelIndex index(int row, int column, QtModelIndex parent) {
    return createIndex(row, column, 0);
}

/*
* Returns a parent model.
* Threading: not used called in this example.
*/
@Override
synchronized public QtModelIndex parent(QtModelIndex qtModelIndex) {
    return new QtModelIndex();
}
</db:programlisting>
<db:para>The example sets the data model when the QML content is loaded, and the status is ready.</db:para>
<db:programlisting language="cpp">/*
* Gets called when model data is edited from QML side.
* Sets the role data for the item at index to value,
* if given index is valid and if data in given index truly changed.
*/
@Override
synchronized public boolean setData(QtModelIndex index, Object value, int role) {
    Cell cellAtIndex = m_dataList.get(index.row()).get(index.column());
    String cellValueAtIndex = cellAtIndex.getValue();
    if (!index.isValid() || role != ROLE_EDIT
            || Objects.equals(cellValueAtIndex, value.toString())) {
        return false;
    }
    cellAtIndex.setValue(value.toString());
    // Send dataChanged() when data was successfully set.
    dataChanged(index, index, new int[]{role});
    return true;
}
</db:programlisting>
</db:section>
</db:section>
</db:article>
