<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Using QtAbstractItemModel in Android Studio Projects</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Shows how to handle complex data types and apply conditional formatting to a table view format using QtAbstractItemModel class and QtModelIndex class.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="overview">
<db:title>Overview</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qtabstractitemmodel_portrait.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>This example consists of two projects: an Android Studio project (qtabstractitemmodel_java) and a QML project (qtabstractitemmodel). You can import the QML project into an Android project.</db:para>
<db:para>The example shows how to handle complex data types between Java and QML. It demonstrates how to use the <db:code>QtAbstractItemModel</db:code> and <db:code>QtModelIndex</db:code> Java API classes. In QML, the data usage is demonstrated with the <db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> item. In Java, data usage is demonstrated with a model of nested ArrayList items for rows and columns. For more information on how QML works, see <db:link xlink:href="qtqml-index.xml">Qt Qml</db:link>.</db:para>
</db:section>
<db:section xml:id="running-the-example">
<db:title>Running the example</db:title>
<db:para>To run this example, you need Android Studio and <db:link xlink:href="">Qt Tools for Android Studio</db:link> on top of a standard Qt for Android installation. Open qtabstractitemmodel_java in Android Studio and follow the instructions in <db:link xlink:href="">Qt Tools for Android Studio</db:link> to import the <db:code>qtabstractitemmodel</db:code>.</db:para>
</db:section>
<db:section xml:id="qml-project">
<db:title>QML project</db:title>
<db:para>On the QML project side, the example uses a <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link> as the root object. The <db:code>dataModel</db:code> property variable holds the data model created and delivered from the Java side.</db:para>
<db:programlisting language="qml">Rectangle {
    id: mainRectangle

    property AbstractItemModel dataModel
</db:programlisting>
<db:para><db:link xlink:href="qml-qtquick-tableview.xml">TableView</db:link> displays our data model. On the <db:code>delegate</db:code> property, the example defines each cell item of the model with <db:link xlink:href="qml-qtquick-text.xml">Text</db:link>.</db:para>
<db:programlisting language="qml">    TableView {
        id: tableView

        model: mainRectangle.dataModel

        anchors {fill: parent; margins: 20}
        columnSpacing: 4
        rowSpacing: 6
        boundsBehavior: TableView.OvershootBounds
        clip: true

        ScrollBar.vertical: ScrollBar {
           policy: ScrollBar.AsNeeded
        }
        ScrollBar.horizontal: ScrollBar{
           policy: ScrollBar.AsNeeded
        }
</db:programlisting>
<db:para>In the delegate, the example sets the <db:code>row</db:code> and <db:code>column</db:code> properties through the <db:link xlink:href="qabstractitemmodel.xml">QHash&lt;int, QByteArray&gt; QAbstractItemModel::roleNames() const</db:link> and <db:link xlink:href="qabstractitemmodel.xml">QtModelIndex index(int row, int column, QtModelIndex parent)</db:link> and <db:link xlink:href="qabstractitemmodel.xml">Object data(QtModelIndex qtModelIndex, int role) </db:link> methods of the model.</db:para>
<db:para>Calling these methods from QML means the execution takes place in the Qt qtMainLoopThread thread context.</db:para>
<db:para>See <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link> for a detailed description.</db:para>
<db:programlisting language="qml">    TableView {
        id: tableView

        model: mainRectangle.dataModel

        anchors {fill: parent; margins: 20}
        columnSpacing: 4
        rowSpacing: 6
        boundsBehavior: TableView.OvershootBounds
        clip: true

        ScrollBar.vertical: ScrollBar {
           policy: ScrollBar.AsNeeded
        }
        ScrollBar.horizontal: ScrollBar{
           policy: ScrollBar.AsNeeded
        }
</db:programlisting>
</db:section>
<db:section xml:id="android-studio-project">
<db:title>Android Studio project</db:title>
<db:para>The Android Studio project (qtabstractitemmodel_java) contains one Activity class <db:code>MainActivity</db:code> and <db:code>MyDataModel</db:code> class.</db:para>
<db:section xml:id="data-model">
<db:title>Data Model</db:title>
<db:para>The data model, c MyDataModel, extends <db:code>QtAbstractItemModel</db:code> class. The <db:code>QtAbstractItemModel</db:code> is a wrapper for <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link>.</db:para>
<db:para>As the methods of <db:code>MyDataModel</db:code> class are called from both, QML and Android sides, the execution occurs in both thread contexts, Qt qtMainLoopThread, and Android main thread contexts. You must ensure synchronization when accessing member variables in methods of the <db:code>MyDataModel</db:code> class.</db:para>
<db:para>First, the example initializes the model with a simple row and column mock data set. Note that this constructor method is called in the Android main thread context.</db:para>
<db:programlisting language="cpp">/*
* Initializes the two-dimensional array list with following content:
* [] [] [] [] 1A 1B 1C 1D
* [] [] [] [] 2A 2B 2C 2D
* [] [] [] [] 3A 3B 3C 3D
* [] [] [] [] 4A 4B 4C 4D
* Threading: called in Android main thread context.
*/
public MyDataModel() {
</db:programlisting>
<db:para>The example overrides the <db:code>QtAbstractItemModel</db:code> methods for different purposes. The columnCount() and rowCount() methods return the count of each in a model. The execution of each rowCount() occurs in both thread contexts, Qt qtMainLoopThread and Android main thread contexts.</db:para>
<db:programlisting language="cpp">/*
* Returns the count of columns.
* Threading: called in Android main thread context.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public int columnCount(QtModelIndex qtModelIndex) {
    return m_columns;
}

/*
* Returns the count of rows.
* Threading: called in Android main thread context.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public int rowCount(QtModelIndex qtModelIndex) {
    return m_dataList.size();
}
</db:programlisting>
<db:para>Method data() provides model data based on the role and index from Java to QML. The roleNames() method returns a hash matching numerical role values to their names as strings; in QML, we use these role names to fetch corresponding data from the model. The index() method returns the new model index. Method parent() should return a parent of the index. Still, as this example focuses on data without parent indices, we override the method and return an empty QtModelIndex(). As the methods are called from QML, the execution occurs in the Qt qtMainLoopThread thread context.</db:para>
<db:programlisting language="cpp">/*
* Returns the data to QML based on the roleNames
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public Object data(QtModelIndex qtModelIndex, int role) {
    switch (role) {
        case ROLE_ROW:
            Cell elementForRow = m_dataList.get(qtModelIndex.row()).get(qtModelIndex.column());
            String row = String.valueOf(elementForRow.getRow());
            return row;
        case ROLE_COLUMN:
            Cell elementForColumn = m_dataList.get(qtModelIndex.row()).get(qtModelIndex.column());
            String column = elementForColumn.getColumn();
            return column;
        default:
            Log.w(TAG, &quot;data unrecognized role: &quot; + role);
            return null;
    }
}

/*
* Defines what string i.e. role in QML side gets the data from Java side.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public HashMap&lt;Integer, String&gt; roleNames() {
    HashMap&lt;Integer, String&gt; roles = new HashMap&lt;&gt;();
    roles.put(ROLE_ROW, &quot;row&quot;);
    roles.put(ROLE_COLUMN, &quot;column&quot;);
    return roles;
}

/*
* Returns a new index model.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public QtModelIndex index(int row, int column, QtModelIndex parent) {
    return createIndex(row, column, 0);
}

/*
* Returns a parent model.
* Threading: not used called in this example.
*/
@Override
synchronized public QtModelIndex parent(QtModelIndex qtModelIndex) {
    return new QtModelIndex();
}
</db:programlisting>
<db:para>The example implements methods on the model side for <db:code>MainActivity</db:code> UI interaction to add and remove rows and columns. Calls begin, end, insert, and remove rows to update model indexes, like beginInsertRow(). Because the example uses the <db:code>QtAbstractItemModel</db:code>, it must call beginInsertRows() and endInsertRows() every time it inserts new rows into the model. The same applies to removal. As the methods are called from the Android side, the execution takes place in the Android main thread context.</db:para>
<db:programlisting language="cpp">/*
* Adds a row.
* Threading: called in Android main thread context.
*/
synchronized public void addRow() {
    if (m_columns &gt; 0 &amp;&amp; m_dataList.size() &lt; MAX_ROWS_AND_COLUMNS) {
        beginInsertRows(new QtModelIndex(), m_dataList.size(), m_dataList.size());
        m_dataList.add(generateRow());
        endInsertRows();
    }
}

/*
* Removes a row.
* Threading: called in Android main thread context.
*/
synchronized public void removeRow() {
    if (m_dataList.size() &gt; 1) {
        beginRemoveRows(new QtModelIndex(), m_dataList.size() - 1, m_dataList.size() - 1);
        m_dataList.remove(m_dataList.size() - 1);
        endRemoveRows();
    }
}
</db:programlisting>
<db:para>The example implements methods on the model side for <db:code>MainActivity</db:code> UI interaction to add and remove columns. Calls begin, end, insert, and remove columns to update model indexes, like beginRemoveColumn(). The same context awareness applies as with the add and remove row methods.</db:para>
<db:programlisting language="cpp">/*
* Adds a column.
* Threading: called in Android main thread context.
*/
synchronized public void addColumn() {
    if (!m_dataList.isEmpty() &amp;&amp; m_columns &lt; MAX_ROWS_AND_COLUMNS) {
        beginInsertColumns(new QtModelIndex(), m_columns, m_columns);
        generateColumn();
        m_columns += 1;
        endInsertColumns();
    }
}

/*
* Removes a column.
* Threading: called in Android main thread context.
*/
synchronized public void removeColumn() {
    if (m_columns &gt; 1) {
        int columnToRemove = m_columns - 1;
        beginRemoveColumns(new QtModelIndex(), columnToRemove, columnToRemove);
        m_columns -= 1;
        endRemoveColumns();
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="main-activity">
<db:title>Main Activity</db:title>
<db:para><db:code>MainActivity</db:code> implements the <db:code>QtQmlStatusChangeListener</db:code> interface to get status updates when the QML is loaded. It is also the main Android activity.</db:para>
<db:para>The example creates and initializes the data model. See also <db:link xlink:href="qtquickview-android-class.xml">QtQuickView</db:link></db:para>
<db:programlisting language="cpp">private final MyDataModel m_model = new MyDataModel();
</db:programlisting>
<db:para>The example sets the UI button and its listeners to allow the users to interact with the model via the UI.</db:para>
<db:programlisting language="cpp">/*
* Returns the count of columns.
* Threading: called in Android main thread context.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public int columnCount(QtModelIndex qtModelIndex) {
    return m_columns;
}

/*
* Returns the count of rows.
* Threading: called in Android main thread context.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public int rowCount(QtModelIndex qtModelIndex) {
    return m_dataList.size();
}
</db:programlisting>
<db:para>The example starts loading the QML content. Loading happens in the background until the <db:code>ready</db:code> status is updated.</db:para>
<db:programlisting language="cpp">/*
* Returns the data to QML based on the roleNames
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public Object data(QtModelIndex qtModelIndex, int role) {
    switch (role) {
        case ROLE_ROW:
            Cell elementForRow = m_dataList.get(qtModelIndex.row()).get(qtModelIndex.column());
            String row = String.valueOf(elementForRow.getRow());
            return row;
        case ROLE_COLUMN:
            Cell elementForColumn = m_dataList.get(qtModelIndex.row()).get(qtModelIndex.column());
            String column = elementForColumn.getColumn();
            return column;
        default:
            Log.w(TAG, &quot;data unrecognized role: &quot; + role);
            return null;
    }
}

/*
* Defines what string i.e. role in QML side gets the data from Java side.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public HashMap&lt;Integer, String&gt; roleNames() {
    HashMap&lt;Integer, String&gt; roles = new HashMap&lt;&gt;();
    roles.put(ROLE_ROW, &quot;row&quot;);
    roles.put(ROLE_COLUMN, &quot;column&quot;);
    return roles;
}

/*
* Returns a new index model.
* Threading: called in Qt qtMainLoopThread thread context.
*/
@Override
synchronized public QtModelIndex index(int row, int column, QtModelIndex parent) {
    return createIndex(row, column, 0);
}

/*
* Returns a parent model.
* Threading: not used called in this example.
*/
@Override
synchronized public QtModelIndex parent(QtModelIndex qtModelIndex) {
    return new QtModelIndex();
}
</db:programlisting>
<db:para>The example sets the data model when the QML content is loaded, and the status is ready.</db:para>
<db:programlisting language="cpp">/*
* Adds a row.
* Threading: called in Android main thread context.
*/
synchronized public void addRow() {
    if (m_columns &gt; 0 &amp;&amp; m_dataList.size() &lt; MAX_ROWS_AND_COLUMNS) {
        beginInsertRows(new QtModelIndex(), m_dataList.size(), m_dataList.size());
        m_dataList.add(generateRow());
        endInsertRows();
    }
}

/*
* Removes a row.
* Threading: called in Android main thread context.
*/
synchronized public void removeRow() {
    if (m_dataList.size() &gt; 1) {
        beginRemoveRows(new QtModelIndex(), m_dataList.size() - 1, m_dataList.size() - 1);
        m_dataList.remove(m_dataList.size() - 1);
        endRemoveRows();
    }
}
</db:programlisting>
</db:section>
</db:section>
</db:article>
