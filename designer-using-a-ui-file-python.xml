<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Using a Designer UI File in Your Qt for Python Application</db:title>
<db:productname>QtDesigner</db:productname>
<db:edition>Qt 6.7.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Designer Manual</db:titleabbrev>
<db:extendedlink xlink:type="extended"><db:link xlink:to="designer-using-a-ui-file.xml" xlink:type="arc" xlink:arcrole="prev" xlink:title="Using a Designer UI File in Your C++ Application"/></db:extendedlink>
<db:extendedlink xlink:type="extended"><db:link xlink:to="designer-using-custom-widgets.xml" xlink:type="arc" xlink:arcrole="next" xlink:title="Using Custom Widgets with Qt Designer"/></db:extendedlink>
<db:abstract>
<db:para>Qt Designer Manual.</db:para></db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="converting-the-form-to-python-code">
<db:title>Converting the Form to Python Code</db:title>
<db:para>To demonstrate, we use the Qt Widgets animation easing example.</db:para>
<db:para>The application consists of one source file, <db:code>easing.py</db:code>, a UI file <db:code>form.ui</db:code>, a resource file <db:code>easing.qrc</db:code> and the project file, <db:code>easing.pyproject</db:code> file in the YAML format:</db:para>
<db:programlisting language="cpp">{
    &quot;files&quot;: [&quot;easing.qrc&quot;, &quot;ui_form.py&quot;, &quot;easing.py&quot;, &quot;easing_rc.py&quot;,
              &quot;form.ui&quot;]
}
</db:programlisting>
<db:para>The UI file is converted to Python code building the form using the <db:link xlink:href="uic.xml">User Interface Compiler (uic)</db:link>:</db:para>
<db:programlisting language="cpp">uic -g python form.ui &amp;gt; ui_form.py
</db:programlisting>
<db:para>Since the top level widget is named <db:code>Form</db:code>, this results in a Python class named <db:code>Ui_Form</db:code> being generated. It provides a function <db:code>setupUi()</db:code>, taking the widget as parameter, which is called to create the UI elements:</db:para>
<db:programlisting language="cpp">from ui_form import Ui_Form
...
class Window(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super(Window, self).__init__(parent)

        self.m_ui = Ui_Form()
        self.m_ui.setupUi(self)
</db:programlisting>
<db:para>Later on, the widgets can be accessed via the <db:code>Ui_Form</db:code> class:</db:para>
<db:programlisting language="cpp">self.m_ui.graphicsView.setScene(self.m_scene)
</db:programlisting>
<db:para>Besides <db:code>setupUi()</db:code>, <db:code>Ui_Form</db:code> provides another method <db:code>retranslateUi()</db:code>, which can be called in reaction to a <db:link xlink:href="qevent.xml">QEvent</db:link> of type <db:link xlink:href="qevent.xml">QEvent</db:link>.LanguageChange, which indicates a change in the application language.</db:para>
<db:section xml:id="the-uitools-approach">
<db:title>The UiTools Approach</db:title>
<db:para>The <db:link xlink:href="quiloader.xml">QUiLoader</db:link> class provides a form loader object to construct the user interface at runtime. This user interface can be retrieved from any <db:link xlink:href="qiodevice.xml">QIODevice</db:link>, e.g., a <db:link xlink:href="qfile.xml">QFile</db:link> object. The <db:link xlink:href="quiloader.xml#load">QUiLoader::load</db:link>() function constructs the form widget using the user interface description contained in the file.</db:para>
<db:para>It is demonstrated by the uiloader example:</db:para>
<db:programlisting language="cpp">from PySide2.QtUiTools import QUiLoader

if __name__ == '__main__':
    # Some code to obtain the form file name, ui_file_name
    app = QApplication(sys.argv)
    ui_file = QFile(ui_file_name)
    if not ui_file.open(QIODevice.ReadOnly):
        print(&quot;Cannot open {}: {}&quot;.format(ui_file_name, ui_file.errorString()))
        sys.exit(-1)
    loader = QUiLoader()
    widget = loader.load(ui_file, None)
    ui_file.close()
    if not widget:
        print(loader.errorString())
        sys.exit(-1)
    widget.show()
    sys.exit(app.exec_())
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="resource-imports">
<db:title>Resource imports</db:title>
<db:section xml:id="single-directory-usage">
<db:title>Single directory usage</db:title>
<db:para>When using icons from <db:link xlink:href="porting-to-android.xml#the-qt-resource-system">resource files</db:link>, say <db:code>resources.qrc</db:code>, <db:code>uic</db:code> will generate an import of the form:</db:para>
<db:programlisting language="cpp">import resources_rc
</db:programlisting>
<db:para>This assumes that a file <db:code>resources_rc.py</db:code> generated by calling the <db:link xlink:href="rcc.xml">Resource Compiler (rcc)</db:link> tool (passing the <db:code>-g python</db:code> command line option) exists in the same directory as the form source.</db:para>
<db:para><db:code>uic</db:code> has a command line option <db:code>--rc-prefix</db:code> causing the <db:code>rc</db:code> indicator to be prepended:</db:para>
<db:programlisting language="cpp">import rc_resources
</db:programlisting>
<db:para>The command line option <db:code>--from-imports</db:code> causes the imports to be generated relative to '.':</db:para>
<db:programlisting language="cpp">from . import resources_rc
</db:programlisting>
</db:section>
<db:section xml:id="directory-trees">
<db:title>Directory trees</db:title>
<db:para>Some projects have more complicated directory trees, for example:</db:para>
<db:programlisting language="cpp" role="bad">project
    resources   (resources.qrc)
    ui          (.ui files)
</db:programlisting>
<db:para>The resource file is then not in the same directory as the form source and the <db:code>.ui</db:code> files typically have relative paths to the resource files:</db:para>
<db:programlisting language="cpp" role="bad">&amp;lt;include location=&quot;../resources/resources.qrc&quot;/&amp;gt;
</db:programlisting>
<db:para>In this case, the command line option <db:code>--absolute-imports</db:code> can be used to generate an absolute import in Python, resulting in:</db:para>
<db:programlisting language="cpp">import resources.resources_rc
</db:programlisting>
<db:para>based on the assumption that <db:code>.</db:code>. is the root directory of the project contained in the Python import path list.</db:para>
<db:para>For more deeply nested trees, it is possible to use the command line option <db:code>--python-paths &lt;path list&gt;</db:code> to pass a Python import path list. <db:code>uic</db:code> will then try to determine the project root by matching the form file path against the path components.</db:para>
<db:para>If <db:code>--python-paths</db:code> is not given, the environment variable <db:code>PYTHONPATH</db:code> is by default checked.</db:para>
</db:section>
</db:section>
</db:article>
