<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QRegularExpression Class</db:title>
<db:productname>QtCore</db:productname>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> class provides pattern matching using regular expressions.</db:para>
<db:para>This class was introduced in Qt 5.0.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QRegularExpression</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QRegularExpression is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Regular expressions, or <db:emphasis>regexps</db:emphasis>, are a very powerful tool to handle strings and texts. This is useful in many contexts, e.g.,</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para>Validation</db:para>
</db:td>
<db:td>
<db:para>A regexp can test whether a substring meets some criteria, e.g. is an integer or contains no whitespace.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Searching</db:para>
</db:td>
<db:td>
<db:para>A regexp provides more powerful pattern matching than simple substring matching, e.g., match one of the words <db:emphasis>mail</db:emphasis>, <db:emphasis>letter</db:emphasis> or <db:emphasis>correspondence</db:emphasis>, but none of the words <db:emphasis>email</db:emphasis>, <db:emphasis>mailman</db:emphasis>, <db:emphasis>mailer</db:emphasis>, <db:emphasis>letterbox</db:emphasis>, etc.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Search and Replace</db:para>
</db:td>
<db:td>
<db:para>A regexp can replace all occurrences of a substring with a different substring, e.g., replace all occurrences of <db:emphasis>&amp;</db:emphasis> with <db:emphasis>&amp;amp;</db:emphasis> except where the <db:emphasis>&amp;</db:emphasis> is already followed by an <db:emphasis>amp;</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>String Splitting</db:para>
</db:td>
<db:td>
<db:para>A regexp can be used to identify where a string should be split apart, e.g. splitting tab-delimited strings.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This document is by no means a complete reference to pattern matching using regular expressions, and the following parts will require the reader to have some basic knowledge about Perl-like regular expressions and their pattern syntax.</db:para>
<db:para>Good references about regular expressions include:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:emphasis>Mastering Regular Expressions</db:emphasis> (Third Edition) by Jeffrey E. F. Friedl, ISBN 0-596-52812-4;</db:para>
</db:listitem>
<db:listitem>
<db:para>the <db:link xlink:href="http://pcre.org/pcre.txt">pcrepattern(3)</db:link> man page, describing the pattern syntax supported by PCRE (the reference implementation of Perl-compatible regular expressions);</db:para>
</db:listitem>
<db:listitem>
<db:para>the <db:link xlink:href="http://perldoc.perl.org/perlre.html">Perl's regular expression documentation</db:link> and the <db:link xlink:href="http://perldoc.perl.org/perlretut.html">Perl's regular expression tutorial</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="introduction">
<db:title>Introduction</db:title>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> implements Perl-compatible regular expressions. It fully supports Unicode. For an overview of the regular expression syntax supported by <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>, please refer to the aforementioned pcrepattern(3) man page. A regular expression is made up of two things: a <db:emphasis role="bold">pattern string</db:emphasis> and a set of <db:emphasis role="bold">pattern options</db:emphasis> that change the meaning of the pattern string.</db:para>
<db:para>You can set the pattern string by passing a string to the <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> constructor:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;a pattern&quot;);
</db:programlisting>
<db:para>This sets the pattern string to a pattern. You can also use the <db:link xlink:href="qregularexpression.xml#setPattern">setPattern</db:link>() function to set a pattern on an existing <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object:</db:para>
<db:programlisting language="cpp">QRegularExpression re;
re.setPattern(&quot;another pattern&quot;);
</db:programlisting>
<db:para>Note that due to C++ literal strings rules, you must escape all backslashes inside the pattern string with another backslash:</db:para>
<db:programlisting language="cpp">// matches two digits followed by a space and a word
QRegularExpression re(&quot;\\d\\d \\w+&quot;);

// matches a backslash
QRegularExpression re2(&quot;\\\\&quot;);
</db:programlisting>
<db:para>The <db:link xlink:href="qregularexpression.xml#pattern">pattern</db:link>() function returns the pattern that is currently set for a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;a third pattern&quot;);
QString pattern = re.pattern(); // pattern == &quot;a third pattern&quot;
</db:programlisting>
</db:section>
<db:section xml:id="pattern-options">
<db:title>Pattern options</db:title>
<db:para>The meaning of the pattern string can be modified by setting one or more <db:emphasis>pattern options</db:emphasis>. For instance, it is possible to set a pattern to match case insensitively by setting the <db:link xlink:href="qregularexpression.xml#PatternOption-enum">QRegularExpression::CaseInsensitiveOption</db:link>.</db:para>
<db:para>You can set the options by passing them to the <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> constructor, as in:</db:para>
<db:programlisting language="cpp">// matches &quot;Qt rocks&quot;, but also &quot;QT rocks&quot;, &quot;QT ROCKS&quot;, &quot;qT rOcKs&quot;, etc.
QRegularExpression re(&quot;Qt rocks&quot;, QRegularExpression::CaseInsensitiveOption);
</db:programlisting>
<db:para>Alternatively, you can use the <db:link xlink:href="qregularexpression.xml#setPatternOptions">setPatternOptions</db:link>() function on an existing QRegularExpressionObject:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;^\\d+$&quot;);
re.setPatternOptions(QRegularExpression::MultilineOption);
// re matches any line in the subject string that contains only digits (but at least one)
</db:programlisting>
<db:para>It is possible to get the pattern options currently set on a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object by using the <db:link xlink:href="qregularexpression.xml#patternOptions">patternOptions</db:link>() function:</db:para>
<db:programlisting language="cpp">QRegularExpression re = QRegularExpression(&quot;^two.*words$&quot;, QRegularExpression::MultilineOption
                                                           | QRegularExpression::DotMatchesEverythingOption);

QRegularExpression::PatternOptions options = re.patternOptions();
// options == QRegularExpression::MultilineOption | QRegularExpression::DotMatchesEverythingOption
</db:programlisting>
<db:para>Please refer to the <db:link xlink:href="qregularexpression.xml#PatternOption-enum">QRegularExpression::PatternOption</db:link> enum documentation for more information about each pattern option.</db:para>
</db:section>
<db:section xml:id="match-type-and-match-options">
<db:title>Match type and match options</db:title>
<db:para>The last two arguments of the <db:link xlink:href="qregularexpression.xml#match">match</db:link>() and the <db:link xlink:href="qregularexpression.xml#globalMatch">globalMatch</db:link>() functions set the match type and the match options. The match type is a value of the <db:link xlink:href="qregularexpression.xml#MatchType-enum">QRegularExpression::MatchType</db:link> enum; the &quot;traditional&quot; matching algorithm is chosen by using the <db:link xlink:href="qregularexpression.xml#MatchType-enum">NormalMatch</db:link> match type (the default). It is also possible to enable partial matching of the regular expression against a subject string: see the <db:link xlink:href="qregularexpression.xml#partial-matching">partial matching</db:link> section for more details.</db:para>
<db:para>The match options are a set of one or more <db:link xlink:href="qregularexpression.xml#MatchOption-enum">QRegularExpression::MatchOption</db:link> values. They change the way a specific match of a regular expression against a subject string is done. Please refer to the <db:link xlink:href="qregularexpression.xml#MatchOption-enum">QRegularExpression::MatchOption</db:link> enum documentation for more details.</db:para>
</db:section>
<db:section xml:id="normal-matching">
<db:title>Normal matching</db:title>
<db:para>In order to perform a match you can simply invoke the <db:link xlink:href="qregularexpression.xml#match">match</db:link>() function passing a string to match against. We refer to this string as the <db:emphasis>subject string</db:emphasis>. The result of the <db:link xlink:href="qregularexpression.xml#match">match</db:link>() function is a <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object that can be used to inspect the results of the match. For instance:</db:para>
<db:programlisting language="cpp">// match two digits followed by a space and a word
QRegularExpression re(&quot;\\d\\d \\w+&quot;);
QRegularExpressionMatch match = re.match(&quot;abc123 def&quot;);
bool hasMatch = match.hasMatch(); // true
</db:programlisting>
<db:para>If a match is successful, the (implicit) capturing group number 0 can be used to retrieve the substring matched by the entire pattern (see also the section about <db:link xlink:href="qregularexpression.xml#extracting-captured-substrings">extracting captured substrings</db:link>):</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;\\d\\d \\w+&quot;);
QRegularExpressionMatch match = re.match(&quot;abc123 def&quot;);
if (match.hasMatch()) {
    QString matched = match.captured(0); // matched == &quot;23 def&quot;
    // ...
}
</db:programlisting>
<db:para>It's also possible to start a match at an arbitrary offset inside the subject string by passing the offset as an argument of the <db:link xlink:href="qregularexpression.xml#match">match</db:link>() function. In the following example &quot;12 abc&quot; is not matched because the match is started at offset 1:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;\\d\\d \\w+&quot;);
QRegularExpressionMatch match = re.match(&quot;12 abc 45 def&quot;, 1);
if (match.hasMatch()) {
    QString matched = match.captured(0); // matched == &quot;45 def&quot;
    // ...
}
</db:programlisting>
<db:section xml:id="extracting-captured-substrings">
<db:title>Extracting captured substrings</db:title>
<db:para>The <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object contains also information about the substrings captured by the capturing groups in the pattern string. The <db:link xlink:href="qregularexpressionmatch.xml#captured">captured</db:link>() function will return the string captured by the n-th capturing group:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;^(\\d\\d)/(\\d\\d)/(\\d\\d\\d\\d)$&quot;);
QRegularExpressionMatch match = re.match(&quot;08/12/1985&quot;);
if (match.hasMatch()) {
    QString day = match.captured(1); // day == &quot;08&quot;
    QString month = match.captured(2); // month == &quot;12&quot;
    QString year = match.captured(3); // year == &quot;1985&quot;
    // ...
}
</db:programlisting>
<db:para>Capturing groups in the pattern are numbered starting from 1, and the implicit capturing group 0 is used to capture the substring that matched the entire pattern.</db:para>
<db:para>It's also possible to retrieve the starting and the ending offsets (inside the subject string) of each captured substring, by using the <db:link xlink:href="qregularexpressionmatch.xml#capturedStart">capturedStart</db:link>() and the <db:link xlink:href="qregularexpressionmatch.xml#capturedEnd">capturedEnd</db:link>() functions:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;abc(\\d+)def&quot;);
QRegularExpressionMatch match = re.match(&quot;XYZabc123defXYZ&quot;);
if (match.hasMatch()) {
    int startOffset = match.capturedStart(1); // startOffset == 6
    int endOffset = match.capturedEnd(1); // endOffset == 9
    // ...
}
</db:programlisting>
<db:para>All of these functions have an overload taking a <db:link xlink:href="qstring.xml">QString</db:link> as a parameter in order to extract <db:emphasis>named</db:emphasis> captured substrings. For instance:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;^(?&lt;date&gt;\\d\\d)/(?&lt;month&gt;\\d\\d)/(?&lt;year&gt;\\d\\d\\d\\d)$&quot;);
QRegularExpressionMatch match = re.match(&quot;08/12/1985&quot;);
if (match.hasMatch()) {
    QString date = match.captured(&quot;date&quot;); // date == &quot;08&quot;
    QString month = match.captured(&quot;month&quot;); // month == &quot;12&quot;
    QString year = match.captured(&quot;year&quot;); // year == 1985
}
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="global-matching">
<db:title>Global matching</db:title>
<db:para><db:emphasis>Global matching</db:emphasis> is useful to find all the occurrences of a given regular expression inside a subject string. Suppose that we want to extract all the words from a given string, where a word is a substring matching the pattern \w+.</db:para>
<db:para><db:link xlink:href="qregularexpression.xml#globalMatch">QRegularExpression::globalMatch</db:link> returns a <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link>, which is a Java-like forward iterator that can be used to iterate over the results. For instance:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;(\\w+)&quot;);
QRegularExpressionMatchIterator i = re.globalMatch(&quot;the quick fox&quot;);
</db:programlisting>
<db:para>Since it's a Java-like iterator, the <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link> will point immediately before the first result. Every result is returned as a <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object. The <db:link xlink:href="qregularexpressionmatchiterator.xml#hasNext">hasNext</db:link>() function will return true if there's at least one more result, and <db:link xlink:href="qregularexpressionmatchiterator.xml#next">next</db:link>() will return the next result and advance the iterator. Continuing from the previous example:</db:para>
<db:programlisting language="cpp">QStringList words;
while (i.hasNext()) {
    QRegularExpressionMatch match = i.next();
    QString word = match.captured(1);
    words &lt;&lt; word;
}
// words contains &quot;the&quot;, &quot;quick&quot;, &quot;fox&quot;
</db:programlisting>
<db:para>You can also use <db:link xlink:href="qregularexpressionmatchiterator.xml#peekNext">peekNext</db:link>() to get the next result without advancing the iterator.</db:para>
<db:para>It is possible to pass a starting offset and one or more match options to the <db:link xlink:href="qregularexpression.xml#globalMatch">globalMatch</db:link>() function, exactly like normal matching with <db:link xlink:href="qregularexpression.xml#match">match</db:link>().</db:para>
</db:section>
<db:section xml:id="partial-matching">
<db:title>Partial matching</db:title>
<db:para>A <db:emphasis>partial match</db:emphasis> is obtained when the end of the subject string is reached, but more characters are needed to successfully complete the match. Note that a partial match is usually much more inefficient than a normal match because many optimizations of the matching algorithm cannot be employed.</db:para>
<db:para>A partial match must be explicitly requested by specifying a match type of <db:link xlink:href="qregularexpression.xml#MatchType-enum">PartialPreferCompleteMatch</db:link> or <db:link xlink:href="qregularexpression.xml#MatchType-enum">PartialPreferFirstMatch</db:link> when calling <db:link xlink:href="qregularexpression.xml#match">QRegularExpression::match</db:link> or <db:link xlink:href="qregularexpression.xml#globalMatch">QRegularExpression::globalMatch</db:link>. If a partial match is found, then calling the <db:link xlink:href="qregularexpressionmatch.xml#hasMatch">hasMatch</db:link>() function on the <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object returned by <db:link xlink:href="qregularexpression.xml#match">match</db:link>() will return false, but <db:link xlink:href="qregularexpressionmatch.xml#hasPartialMatch">hasPartialMatch</db:link>() will return true.</db:para>
<db:para>When a partial match is found, no captured substrings are returned, and the (implicit) capturing group 0 corresponding to the whole match captures the partially matched substring of the subject string.</db:para>
<db:para>Note that asking for a partial match can still lead to a complete match, if one is found; in this case, <db:link xlink:href="qregularexpressionmatch.xml#hasMatch">hasMatch</db:link>() will return true and <db:link xlink:href="qregularexpressionmatch.xml#hasPartialMatch">hasPartialMatch</db:link>() false. It never happens that a <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> reports both a partial and a complete match.</db:para>
<db:para>Partial matching is mainly useful in two scenarios: validating user input in real time and incremental/multi-segment matching.</db:para>
<db:section xml:id="validating-user-input">
<db:title>Validating user input</db:title>
<db:para>Suppose that we would like the user to input a date in a specific format, for instance &quot;MMM dd, yyyy&quot;. We can check the input validity with a pattern like:</db:para>
<db:para>^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \d\d?, \d\d\d\d$</db:para>
<db:para>(This pattern doesn't catch invalid days, but let's keep it for the example's purposes).</db:para>
<db:para>We would like to validate the input with this regular expression <db:emphasis>while</db:emphasis> the user is typing it, so that we can report an error in the input as soon as it is committed (for instance, the user typed the wrong key). In order to do so we must distinguish three cases:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>the input cannot possibly match the regular expression;</db:para>
</db:listitem>
<db:listitem>
<db:para>the input does match the regular expression;</db:para>
</db:listitem>
<db:listitem>
<db:para>the input does not match the regular expression right now, but it will if more characters will be added to it.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Note that these three cases represent exactly the possible states of a QValidator (see the QValidator::State enum).</db:para>
<db:para>In particular, in the last case we want the regular expression engine to report a partial match: we are successfully matching the pattern against the subject string but the matching cannot continue because the end of the subject is encountered. Notice, however, that the matching algorithm should continue and try all possibilities, and in case a complete (non-partial) match is found, then this one should be reported, and the input string accepted as fully valid.</db:para>
<db:para>This behaviour is implemented by the <db:link xlink:href="qregularexpression.xml#MatchType-enum">PartialPreferCompleteMatch</db:link> match type. For instance:</db:para>
<db:programlisting language="cpp">QString pattern(&quot;^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d?, \\d\\d\\d\\d$&quot;);
QRegularExpression re(pattern);

QString input(&quot;Jan 21,&quot;);
QRegularExpressionMatch match = re.match(input, 0, QRegularExpression::PartialPreferCompleteMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true
</db:programlisting>
<db:para>If matching the same regular expression against the subject string leads to a complete match, it is reported as usual:</db:para>
<db:programlisting language="cpp">QString input(&quot;Dec 8, 1985&quot;);
QRegularExpressionMatch match = re.match(input, 0, QRegularExpression::PartialPreferCompleteMatch);
bool hasMatch = match.hasMatch(); // true
bool hasPartialMatch = match.hasPartialMatch(); // false
</db:programlisting>
<db:para>Another example with a different pattern, showing the behaviour of preferring a complete match over a partial one:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;abc\\w+X|def&quot;);
QRegularExpressionMatch match = re.match(&quot;abcdef&quot;, 0, QRegularExpression::PartialPreferCompleteMatch);
bool hasMatch = match.hasMatch(); // true
bool hasPartialMatch = match.hasPartialMatch(); // false
QString captured = match.captured(0); // captured == &quot;def&quot;
</db:programlisting>
<db:para>In this case, the subpattern abc\\w+X partially matches the subject string; however, the subpattern def matches the subject string completely, and therefore a complete match is reported.</db:para>
<db:para>If multiple partial matches are found when matching (but no complete match), then the <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object will report the first one that is found. For instance:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;abc\\w+X|defY&quot;);
QRegularExpressionMatch match = re.match(&quot;abcdef&quot;, 0, QRegularExpression::PartialPreferCompleteMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true
QString captured = match.captured(0); // captured == &quot;abcdef&quot;
</db:programlisting>
</db:section>
<db:section xml:id="incremental-multi-segment-matching">
<db:title>Incremental/multi-segment matching</db:title>
<db:para>Incremental matching is another use case of partial matching. Suppose that we want to find the occurrences of a regular expression inside a large text (that is, substrings matching the regular expression). In order to do so we would like to &quot;feed&quot; the large text to the regular expression engines in smaller chunks. The obvious problem is what happens if the substring that matches the regular expression spans across two or more chunks.</db:para>
<db:para>In this case, the regular expression engine should report a partial match, so that we can match again adding new data and (eventually) get a complete match. This implies that the regular expression engine may assume that there are other characters <db:emphasis>beyond the end</db:emphasis> of the subject string. This is not to be taken literally â€“ the engine will never try to access any character after the last one in the subject.</db:para>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> implements this behaviour when using the <db:link xlink:href="qregularexpression.xml#MatchType-enum">PartialPreferFirstMatch</db:link> match type. This match type reports a partial match as soon as it is found, and other match alternatives are not tried (even if they could lead to a complete match). For instance:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;abc|ab&quot;);
QRegularExpressionMatch match = re.match(&quot;ab&quot;, 0, QRegularExpression::PartialPreferFirstMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true
</db:programlisting>
<db:para>This happens because when matching the first branch of the alternation operator a partial match is found, and therefore matching stops, without trying the second branch. Another example:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;abc(def)?&quot;);
QRegularExpressionMatch match = re.match(&quot;abc&quot;, 0, QRegularExpression::PartialPreferFirstMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true
</db:programlisting>
<db:para>This shows what could seem a counterintuitve behaviour of quantifiers: since ? is greedy, then the engine tries first to continue the match after having matched &quot;abc&quot;; but then the matching reaches the end of the subject string, and therefore a partial match is reported. This is even more surprising in the following example:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;(abc)*&quot;);
QRegularExpressionMatch match = re.match(&quot;abc&quot;, 0, QRegularExpression::PartialPreferFirstMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true
</db:programlisting>
<db:para>It's easy to understand this behaviour if we remember that the engine expects the subject string to be only a substring of the whole text we're looking for a match into (that is, how we said before, that the engine assumes that there are other characters beyond the end of the subject string).</db:para>
<db:para>Since the * quantifier is greedy, then reporting a complete match could be an error, because after the current subject &quot;abc&quot; there may be other occurrences of &quot;abc&quot;. For instance, the complete text could have been &quot;abcabcX&quot;, and therefore the <db:emphasis>right</db:emphasis> match to report (in the complete text) would have been &quot;abcabc&quot;; by matching only against the leading &quot;abc&quot; we instead get a partial match.</db:para>
</db:section>
</db:section>
<db:section xml:id="error-handling">
<db:title>Error handling</db:title>
<db:para>It is possible for a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object to be invalid because of syntax errors in the pattern string. The <db:link xlink:href="qregularexpression.xml#isValid">isValid</db:link>() function will return true if the regular expression is valid, or false otherwise:</db:para>
<db:programlisting language="cpp">QRegularExpression invalidRe(&quot;(unmatched|parenthesis&quot;);
bool isValid = invalidRe.isValid(); // false
</db:programlisting>
<db:para>You can get more information about the specific error by calling the <db:link xlink:href="qregularexpression.xml#errorString">errorString</db:link>() function; moreover, the <db:link xlink:href="qregularexpression.xml#patternErrorOffset">patternErrorOffset</db:link>() function will return the offset inside the pattern string</db:para>
<db:programlisting language="cpp">QRegularExpression invalidRe(&quot;(unmatched|parenthesis&quot;);
if (!invalidRe.isValid()) {
    QString errorString = invalidRe.errorString(); // errorString == &quot;missing )&quot;
    int errorOffset = invalidRe.patternErrorOffset(); // errorOffset == 22
    // ...
}
</db:programlisting>
<db:para>If a match is attempted with an invalid <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>, then the returned <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object will be invalid as well (that is, its <db:link xlink:href="qregularexpressionmatch.xml#isValid">isValid</db:link>() function will return false). The same applies for attempting a global match.</db:para>
</db:section>
<db:section xml:id="unsupported-perl-compatible-regular-expressions-features">
<db:title>Unsupported Perl-compatible regular expressions features</db:title>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> does not support all the features available in Perl-compatible regular expressions. The most notable one is the fact that duplicated names for capturing groups are not supported, and using them can lead to undefined behaviour.</db:para>
<db:para>This may change in a future version of Qt.</db:para>
</db:section>
<db:section xml:id="notes-for-qregexp-users">
<db:title>Notes for QRegExp users</db:title>
<db:para>The <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> class introduced in Qt 5 is a big improvement upon <db:link xlink:href="qregexp.xml">QRegExp</db:link>, in terms of APIs offered, supported pattern syntax and speed of execution. The biggest difference is that <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> simply holds a regular expression, and it's <db:emphasis>not</db:emphasis> modified when a match is requested. Instead, a <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object is returned, in order to check the result of a match and extract the captured substring. The same applies with global matching and <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link>.</db:para>
<db:para>Other differences are outlined below.</db:para>
<db:section xml:id="exact-matching">
<db:title>Exact matching</db:title>
<db:para><db:link xlink:href="qregexp.xml#exactMatch">QRegExp::exactMatch</db:link>() in Qt 4 served two purposes: it exactly matched a regular expression against a subject string, and it implemented partial matching. In fact, if an exact match was not found, one could still find out how much of the subject string was matched by the regular expression by calling <db:link xlink:href="qregexp.xml#matchedLength">QRegExp::matchedLength</db:link>(). If the returned length was equal to the subject string's length, then one could desume that a partial match was found.</db:para>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> supports partial matching explicitly by means of the appropriate <db:link xlink:href="qregularexpression.xml#MatchType-enum">MatchType</db:link>. If instead you simply want to be sure that the subject string matches the regular expression exactly, you can wrap the pattern between a couple of anchoring expressions. Simply putting the pattern between the ^ and the $ anchors is enough in most cases:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;^this pattern must match exactly$&quot;);
</db:programlisting>
<db:para>However, remember that the $ anchor not only matches at the end of the string, but also at a newline character right before the end of the string; that is, the previous pattern matches against the string &quot;this pattern must match exactly\n&quot;. Also, the behaviour of both the ^ and the $ anchors changes if the MultiLineOption is set either explicitly (as a pattern option) or implicitly (as a directive inside the pattern string).</db:para>
<db:para>Therefore, in the most general case, you should wrap the pattern between the \A and the \z anchors:</db:para>
<db:programlisting language="cpp">QString p(&quot;a .*|pattern&quot;);
QRegularExpression re(&quot;\\A(?:&quot; + p + &quot;)\\z&quot;); // re matches exactly the pattern string p
</db:programlisting>
<db:para>Note the usage of the non-capturing group in order to preserve the meaning of the branch operator inside the pattern.</db:para>
</db:section>
<db:section xml:id="notes-for-qregexp-users-global-matching-13">
<db:title>Global matching</db:title>
<db:para>Due to limitations of the <db:link xlink:href="qregexp.xml">QRegExp</db:link> API it was impossible to implement global matching correctly (that is, like Perl does). In particular, patterns that can match 0 characters (like &quot;a*&quot;) are problematic.</db:para>
<db:para><db:link xlink:href="qregularexpression.xml#globalMatch">QRegularExpression::globalMatch</db:link>() implements Perl global match correctly, and the returned iterator can be used to examine each result.</db:para>
</db:section>
<db:section xml:id="unicode-properties-support">
<db:title>Unicode properties support</db:title>
<db:para>When using <db:link xlink:href="qregexp.xml">QRegExp</db:link>, character classes such as \w, \d, etc. match characters with the corresponding Unicode property: for instance, \d matches any character with the Unicode Nd (decimal digit) property.</db:para>
<db:para>Those character classes only match ASCII characters by default when using <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>: for instance, \d matches exactly a character in the 0-9 ASCII range. It is possible to change this behaviour by using the <db:link xlink:href="qregularexpression.xml#PatternOption-enum">UseUnicodePropertiesOption</db:link> pattern option.</db:para>
</db:section>
<db:section xml:id="wildcard-matching">
<db:title>Wildcard matching</db:title>
<db:para>There is no equivalent of wildcard matching in <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>. Nevertheless, rewriting a regular expression in wildcard syntax to a Perl-compatible regular expression is a very easy task, given the fact that wildcard syntax supported by <db:link xlink:href="qregexp.xml">QRegExp</db:link> is very simple.</db:para>
</db:section>
<db:section xml:id="other-pattern-syntaxes">
<db:title>Other pattern syntaxes</db:title>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> supports only Perl-compatible regular expressions.</db:para>
</db:section>
<db:section xml:id="minimal-matching">
<db:title>Minimal matching</db:title>
<db:para><db:link xlink:href="qregexp.xml#setMinimal">QRegExp::setMinimal</db:link>() implemented minimal matching by simply reversing the greediness of the quantifiers (<db:link xlink:href="qregexp.xml">QRegExp</db:link> did not support lazy quantifiers, like *?, +?, etc.). <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> instead does support greedy, lazy and possessive quantifiers. The <db:link xlink:href="qregularexpression.xml#PatternOption-enum">InvertedGreedinessOption</db:link> pattern option can be useful to emulate the effects of <db:link xlink:href="qregexp.xml#setMinimal">QRegExp::setMinimal</db:link>(): if enabled, it inverts the greediness of quantifiers (greedy ones become lazy and vice versa).</db:para>
</db:section>
<db:section xml:id="caret-modes">
<db:title>Caret modes</db:title>
<db:para>The <db:link xlink:href="qregularexpression.xml#MatchOption-enum">AnchoredMatchOption</db:link> match option can be used to emulate the <db:link xlink:href="qregexp.xml#CaretMode-enum">QRegExp::CaretAtOffset</db:link> behaviour. There is no equivalent for the other <db:link xlink:href="qregexp.xml#CaretMode-enum">QRegExp::CaretMode</db:link> modes.</db:para>
</db:section>
</db:section>
<db:section xml:id="debugging-code-that-uses-qregularexpression">
<db:title>Debugging code that uses QRegularExpression</db:title>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> internally uses a just in time compiler (JIT) to optimize the execution of the matching algorithm. The JIT makes extensive usage of self-modifying code, which can lead debugging tools such as Valgrind to crash. You must enable all checks for self-modifying code if you want to debug programs using <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> (f.i., see Valgrind's --smc-check command line option). The downside of enabling such checks is that your program will run considerably slower.</db:para>
<db:para>To avoid that, the JIT is disabled by default if you compile Qt in debug mode. It is possible to override the default and enable or disable the JIT usage (both in debug or release mode) by setting the QT_ENABLE_REGEXP_JIT environment variable to a non-zero or zero value respectively.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link></db:member>
<db:member><db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="MatchOption-enum">
<db:title>enum QRegularExpression::MatchOption</db:title>
<db:bridgehead renderas="sect2">flags QRegularExpression::MatchOptions</db:bridgehead>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::NoMatchOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0000</db:code></db:td>
<db:td>
<db:para>No match options are set.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::AnchoredMatchOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>The match is constrained to start exactly at the offset passed to <db:link xlink:href="qregularexpression.xml#match">match</db:link>() in order to be successful, even if the pattern string does not contain any metacharacter that anchors the match at that point.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>MatchOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;MatchOption&gt;. </db:code>It stores an OR combination of <db:code>MatchOption</db:code> values.</db:para>
</db:section>
<db:section xml:id="MatchType-enum">
<db:title>enum QRegularExpression::MatchType</db:title>
<db:para>The MatchType enum defines the type of the match that should be attempted against the subject string.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::NormalMatch</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>A normal match is done.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::PartialPreferCompleteMatch</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The pattern string is matched partially against the subject string. If a partial match is found, then it is recorded, and other matching alternatives are tried as usual. If a complete match is then found, then it's preferred to the partial match; in this case only the complete match is reported. If instead no complete match is found (but only the partial one), then the partial one is reported.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::PartialPreferFirstMatch</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The pattern string is matched partially against the subject string. If a partial match is found, then matching stops and the partial match is reported. In this case, other matching alternatives (potentially leading to a complete match) are not tried. Moreover, this match type assumes that the subject string only a substring of a larger text, and that (in this text) there are other characters beyond the end of the subject string. This can lead to surprising results; see the discussion in the <db:link xlink:href="qregularexpression.xml#partial-matching">partial matching</db:link> section for more details.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::NoMatch</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>No matching is done. This value is returned as the match type by a default constructed <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> or <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link>. Using this match type is not very useful for the user, as no matching ever happens. This enum value has been introduced in Qt 5.1.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="PatternOption-enum">
<db:title>enum QRegularExpression::PatternOption</db:title>
<db:bridgehead renderas="sect2">flags QRegularExpression::PatternOptions</db:bridgehead>
<db:para>The PatternOption enum defines modifiers to the way the pattern string should be interpreted, and therefore the way the pattern matches against a subject string.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::NoPatternOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0000</db:code></db:td>
<db:td>
<db:para>No pattern options are set.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::CaseInsensitiveOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>The pattern should match against the subject string in a case insensitive way. This option corresponds to the /i modifier in Perl regular expressions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::DotMatchesEverythingOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0002</db:code></db:td>
<db:td>
<db:para>The dot metacharacter (.) in the pattern string is allowed to match any character in the subject string, including newlines (normally, the dot does not match newlines). This option corresponds to the /s modifier in Perl regular expressions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::MultilineOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0004</db:code></db:td>
<db:td>
<db:para>The caret (^) and the dollar ($) metacharacters in the pattern string are allowed to match, respectively, immediately after and immediately before any newline in the subject string, as well as at the very beginning and at the very end of the subject string. This option corresponds to the /m modifier in Perl regular expressions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::ExtendedPatternSyntaxOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0008</db:code></db:td>
<db:td>
<db:para>Any whitespace in the pattern string which is not escaped and outside a character class is ignored. Moreover, an unescaped sharp (<db:emphasis role="bold">#</db:emphasis>) outside a character class causes all the following characters, until the first newline (included), to be ignored. This can be used to increase the readability of a pattern string as well as put comments inside regular expressions; this is particulary useful if the pattern string is loaded from a file or written by the user, because in C++ code it is always possible to use the rules for string literals to put comments outside the pattern string. This option corresponds to the /x modifier in Perl regular expressions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::InvertedGreedinessOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0010</db:code></db:td>
<db:td>
<db:para>The greediness of the quantifiers is inverted: *, +, ?, {m,n}, etc. become lazy, while their lazy versions (*?, +?, ??, {m,n}?, etc.) become greedy. There is no equivalent for this option in Perl regular expressions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::DontCaptureOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0020</db:code></db:td>
<db:td>
<db:para>The non-named capturing groups do not capture substrings; named capturing groups still work as intended, as well as the implicit capturing group number 0 corresponding to the entire match. There is no equivalent for this option in Perl regular expressions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::UseUnicodePropertiesOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0040</db:code></db:td>
<db:td>
<db:para>The meaning of the \w, \d, etc., character classes, as well as the meaning of their counterparts (\W, \D, etc.), is changed from matching ASCII characters only to matching any character with the corresponding Unicode property. For instance, \d is changed to match any character with the Unicode Nd (decimal digit) property; \w to match any character with either the Unicode L (letter) or N (digit) property, plus underscore, and so on. This option corresponds to the /u modifier in Perl regular expressions.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>PatternOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;PatternOption&gt;. </db:code>It stores an OR combination of <db:code>PatternOption</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QRegularExpression">
<db:title>QRegularExpression::QRegularExpression()</db:title>
<db:para>Constructs a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object with an empty pattern and no pattern options.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#setPatternOptions">setPatternOptions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRegularExpression-2">
<db:title>[explicit] QRegularExpression::QRegularExpression(const QString &amp;<db:emphasis>pattern</db:emphasis>, QRegularExpression::PatternOptions <db:emphasis>options</db:emphasis> = NoPatternOption)</db:title>
<db:para>Constructs a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object using the given <db:code role="parameter">pattern</db:code> as pattern and the <db:code role="parameter">options</db:code> as the pattern options.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#setPatternOptions">setPatternOptions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRegularExpression-1">
<db:title>QRegularExpression::QRegularExpression(const QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object as a copy of <db:code role="parameter">re</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QRegularExpression">
<db:title>[noexcept] QRegularExpression::~QRegularExpression()</db:title>
<db:para>Destroys the <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object.</db:para>
</db:section>
<db:section xml:id="captureCount">
<db:title>int QRegularExpression::captureCount() const</db:title>
<db:para>Returns the number of capturing groups inside the pattern string, or -1 if the regular expression is not valid.</db:para>
<db:note>
<db:para>The implicit capturing group 0 is <db:emphasis>not</db:emphasis> included in the returned number.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QRegularExpression::errorString() const</db:title>
<db:para>Returns a textual description of the error found when checking the validity of the regular expression, or &quot;no error&quot; if no error was found.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#patternErrorOffset">patternErrorOffset</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="escape">
<db:title>[static] QString QRegularExpression::escape(const QString &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:para>Escapes all characters of <db:code role="parameter">str</db:code> so that they no longer have any special meaning when used as a regular expression pattern string, and returns the escaped string. For instance:</db:para>
<db:programlisting language="cpp">QString escaped = QRegularExpression::escape(&quot;a(x) = f(x) + g(x)&quot;);
// escaped == &quot;a\\(x\\)\\ \\=\\ f\\(x\\)\\ \\+\\ g\\(x\\)&quot;
</db:programlisting>
<db:para>This is very convenient in order to build patterns from arbitrary strings:</db:para>
<db:programlisting language="cpp">QString pattern = &quot;(&quot; + QRegularExpression::escape(name) +
                  &quot;|&quot; + QRegularExpression::escape(nickname) + &quot;)&quot;;
QRegularExpression re(pattern);
</db:programlisting>
<db:note>
<db:para>This function implements Perl's quotemeta algorithm and escapes with a backslash all characters in <db:code role="parameter">str</db:code>, except for the characters in the [A-Z], [a-z] and [0-9] ranges, as well as the underscore (_) character. The only difference with Perl is that a literal NUL inside <db:code role="parameter">str</db:code> is escaped with the sequence &quot;\\0&quot; (backslash + '0'), instead of &quot;\\\0&quot; (backslash + NUL).</db:para>
</db:note>
</db:section>
<db:section xml:id="globalMatch">
<db:title>QRegularExpressionMatchIterator QRegularExpression::globalMatch(const QString &amp;<db:emphasis>subject</db:emphasis>, int <db:emphasis>offset</db:emphasis> = 0, QRegularExpression::MatchType <db:emphasis>matchType</db:emphasis> = NormalMatch, QRegularExpression::MatchOptions <db:emphasis>matchOptions</db:emphasis> = NoMatchOption) const</db:title>
<db:para>Attempts to perform a global match of the regular expression against the given <db:code role="parameter">subject</db:code> string, starting at the position <db:code role="parameter">offset</db:code> inside the subject, using a match of type <db:code role="parameter">matchType</db:code> and honoring the given <db:code role="parameter">matchOptions</db:code>.</db:para>
<db:para>The returned <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link> is positioned before the first match result (if any).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link></db:member>
<db:member><db:link xlink:href="qregularexpression.xml#global-matching">global matching</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QRegularExpression::isValid() const</db:title>
<db:para>Returns true if the regular expression is a valid regular expression (that is, it contains no syntax errors, etc.), or false otherwise. Use <db:link xlink:href="qregularexpression.xml#errorString">errorString</db:link>() to obtain a textual description of the error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#errorString">errorString</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#patternErrorOffset">patternErrorOffset</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="match">
<db:title>QRegularExpressionMatch QRegularExpression::match(const QString &amp;<db:emphasis>subject</db:emphasis>, int <db:emphasis>offset</db:emphasis> = 0, QRegularExpression::MatchType <db:emphasis>matchType</db:emphasis> = NormalMatch, QRegularExpression::MatchOptions <db:emphasis>matchOptions</db:emphasis> = NoMatchOption) const</db:title>
<db:para>Attempts to match the regular expression against the given <db:code role="parameter">subject</db:code> string, starting at the position <db:code role="parameter">offset</db:code> inside the subject, using a match of type <db:code role="parameter">matchType</db:code> and honoring the given <db:code role="parameter">matchOptions</db:code>.</db:para>
<db:para>The returned <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object contains the results of the match.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link></db:member>
<db:member><db:link xlink:href="qregularexpression.xml#normal-matching">normal matching</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="namedCaptureGroups">
<db:title>[since 5.1] QStringList QRegularExpression::namedCaptureGroups() const</db:title>
<db:para>Returns a list of <db:link xlink:href="qregularexpression.xml#captureCount">captureCount</db:link>() + 1 elements, containing the names of the named capturing groups in the pattern string. The list is sorted such that the element of the list at position i is the name of the i-th capturing group, if it has a name, or an empty string if that capturing group is unnamed.</db:para>
<db:para>For instance, given the regular expression</db:para>
<db:programlisting language="cpp">(?&lt;day&gt;\d\d)-(?&lt;month&gt;\d\d)-(?&lt;year&gt;\d\d\d\d) (\w+) (?&lt;name&gt;\w+)
</db:programlisting>
<db:para>namedCaptureGroups() will return the following list:</db:para>
<db:programlisting language="cpp">(&quot;&quot;, &quot;day&quot;, &quot;month&quot;, &quot;year&quot;, &quot;&quot;, &quot;name&quot;)
</db:programlisting>
<db:para>which corresponds to the fact that the capturing group #0 (corresponding to the whole match) has no name, the capturing group #1 has name &quot;day&quot;, the capturing group #2 has name &quot;month&quot;, etc.</db:para>
<db:para>If the regular expression is not valid, returns an empty list.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpressionmatch.xml#captured">QRegularExpressionMatch::captured</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#isEmpty">QString::isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pattern">
<db:title>QString QRegularExpression::pattern() const</db:title>
<db:para>Returns the pattern string of the regular expression.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#patternOptions">patternOptions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="patternErrorOffset">
<db:title>int QRegularExpression::patternErrorOffset() const</db:title>
<db:para>Returns the offset, inside the pattern string, at which an error was found when checking the validity of the regular expression. If no error was found, then -1 is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#pattern">pattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="patternOptions">
<db:title>QRegularExpression::PatternOptions QRegularExpression::patternOptions() const</db:title>
<db:para>Returns the pattern options for the regular expression.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#setPatternOptions">setPatternOptions</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#pattern">pattern</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPattern">
<db:title>void QRegularExpression::setPattern(const QString &amp;<db:emphasis>pattern</db:emphasis>)</db:title>
<db:para>Sets the pattern string of the regular expression to <db:code role="parameter">pattern</db:code>. The pattern options are left unchanged.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#pattern">pattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#setPatternOptions">setPatternOptions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPatternOptions">
<db:title>void QRegularExpression::setPatternOptions(QRegularExpression::PatternOptions <db:emphasis>options</db:emphasis>)</db:title>
<db:para>Sets the given <db:code role="parameter">options</db:code> as the pattern options of the regular expression. The pattern string is left unchanged.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#patternOptions">patternOptions</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#setPattern">setPattern</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QRegularExpression::swap(QRegularExpression &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Swaps the regular expression <db:code role="parameter">other</db:code> with this regular expression. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QRegularExpression::operator!=(const QRegularExpression &amp;<db:emphasis>re</db:emphasis>) const</db:title>
<db:para>Returns true if the regular expression is different from <db:code role="parameter">re</db:code>, or false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QRegularExpression &amp;QRegularExpression::operator=(const QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:para>Assigns the regular expression <db:code role="parameter">re</db:code> to this object, and returns a reference to the copy. Both the pattern and the pattern options are copied.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QRegularExpression::operator==(const QRegularExpression &amp;<db:emphasis>re</db:emphasis>) const</db:title>
<db:para>Returns true if the regular expression is equal to <db:code role="parameter">re</db:code>, or false otherwise. Two <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> objects are equal if they have the same pattern string and the same pattern options.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="operator-lt-lt">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:para>Writes the regular expression <db:code role="parameter">re</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt-1">
<db:title>QDebug operator&lt;&lt;(QDebug <db:emphasis>debug</db:emphasis>, QRegularExpression::PatternOptions <db:emphasis>patternOptions</db:emphasis>)</db:title>
<db:para>Writes the pattern options <db:code role="parameter">patternOptions</db:code> into the debug object <db:code role="parameter">debug</db:code> for debugging purposes.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">Debugging Techniques</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt-2">
<db:title>QDebug operator&lt;&lt;(QDebug <db:emphasis>debug</db:emphasis>, const QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:para>Writes the regular expression <db:code role="parameter">re</db:code> into the debug object <db:code role="parameter">debug</db:code> for debugging purposes.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="">Debugging Techniques</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt-14">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:para>Reads a regular expression from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">re</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
