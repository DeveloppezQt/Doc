<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRegularExpression Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.4.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> class provides pattern matching using regular expressions.</db:para>
<db:para>This class was introduced in Qt 5.0.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QRegularExpression</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.0</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QRegularExpression is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Regular expressions, or <db:emphasis>regexps</db:emphasis>, are a very powerful tool to handle strings and texts. This is useful in many contexts, e.g.,</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para>Validation</db:para>
</db:td>
<db:td>
<db:para>A regexp can test whether a substring meets some criteria, e.g. is an integer or contains no whitespace.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Searching</db:para>
</db:td>
<db:td>
<db:para>A regexp provides more powerful pattern matching than simple substring matching, e.g., match one of the words <db:emphasis>mail</db:emphasis>, <db:emphasis>letter</db:emphasis> or <db:emphasis>correspondence</db:emphasis>, but none of the words <db:emphasis>email</db:emphasis>, <db:emphasis>mailman</db:emphasis>, <db:emphasis>mailer</db:emphasis>, <db:emphasis>letterbox</db:emphasis>, etc.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Search and Replace</db:para>
</db:td>
<db:td>
<db:para>A regexp can replace all occurrences of a substring with a different substring, e.g., replace all occurrences of <db:emphasis>&amp;</db:emphasis> with <db:emphasis>&amp;amp;</db:emphasis> except where the <db:emphasis>&amp;</db:emphasis> is already followed by an <db:emphasis>amp;</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>String Splitting</db:para>
</db:td>
<db:td>
<db:para>A regexp can be used to identify where a string should be split apart, e.g. splitting tab-delimited strings.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This document is by no means a complete reference to pattern matching using regular expressions, and the following parts will require the reader to have some basic knowledge about Perl-like regular expressions and their pattern syntax.</db:para>
<db:para>Good references about regular expressions include:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:emphasis>Mastering Regular Expressions</db:emphasis> (Third Edition) by Jeffrey E. F. Friedl, ISBN 0-596-52812-4;</db:para>
</db:listitem>
<db:listitem>
<db:para>the <db:link xlink:href="https://pcre.org/original/doc/html/pcrepattern.html">pcrepattern(3)</db:link> man page, describing the pattern syntax supported by PCRE (the reference implementation of Perl-compatible regular expressions);</db:para>
</db:listitem>
<db:listitem>
<db:para>the <db:link xlink:href="http://perldoc.perl.org/perlre.html">Perl's regular expression documentation</db:link> and the <db:link xlink:href="http://perldoc.perl.org/perlretut.html">Perl's regular expression tutorial</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="introduction">
<db:title>Introduction</db:title>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> implements Perl-compatible regular expressions. It fully supports Unicode. For an overview of the regular expression syntax supported by <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>, please refer to the aforementioned pcrepattern(3) man page. A regular expression is made up of two things: a <db:emphasis role="bold">pattern string</db:emphasis> and a set of <db:emphasis role="bold">pattern options</db:emphasis> that change the meaning of the pattern string.</db:para>
<db:para>You can set the pattern string by passing a string to the <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> constructor:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;a pattern&quot;);
</db:programlisting>
<db:para>This sets the pattern string to a pattern. You can also use the <db:link xlink:href="qregularexpression.xml#setPattern">setPattern</db:link>() function to set a pattern on an existing <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object:</db:para>
<db:programlisting language="cpp">QRegularExpression re;
re.setPattern(&quot;another pattern&quot;);
</db:programlisting>
<db:para>Note that due to C++ literal strings rules, you must escape all backslashes inside the pattern string with another backslash:</db:para>
<db:programlisting language="cpp">// matches two digits followed by a space and a word
QRegularExpression re(&quot;\\d\\d \\w+&quot;);

// matches a backslash
QRegularExpression re2(&quot;\\\\&quot;);
</db:programlisting>
<db:para>Alternatively, you can use a <db:link xlink:href="https://en.cppreference.com/w/cpp/language/string_literal">raw string literal</db:link>, in which case you don't need to escape backslashes in the pattern, all characters between R&quot;(...)&quot; are considered raw characters. As you can see in the following example, this simplifies writing patterns:</db:para>
<db:programlisting language="cpp">// matches two digits followed by a space and a word
QRegularExpression re(R&quot;(\d\d \w+)&quot;);
</db:programlisting>
<db:para>The <db:link xlink:href="qregularexpression.xml#pattern">pattern</db:link>() function returns the pattern that is currently set for a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;a third pattern&quot;);
QString pattern = re.pattern(); // pattern == &quot;a third pattern&quot;
</db:programlisting>
</db:section>
<db:section xml:id="pattern-options">
<db:title>Pattern Options</db:title>
<db:para>The meaning of the pattern string can be modified by setting one or more <db:emphasis>pattern options</db:emphasis>. For instance, it is possible to set a pattern to match case insensitively by setting the <db:link xlink:href="qregularexpression.xml#PatternOption-enum">QRegularExpression::CaseInsensitiveOption</db:link>.</db:para>
<db:para>You can set the options by passing them to the <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> constructor, as in:</db:para>
<db:programlisting language="cpp">// matches &quot;Qt rocks&quot;, but also &quot;QT rocks&quot;, &quot;QT ROCKS&quot;, &quot;qT rOcKs&quot;, etc.
QRegularExpression re(&quot;Qt rocks&quot;, QRegularExpression::CaseInsensitiveOption);
</db:programlisting>
<db:para>Alternatively, you can use the <db:link xlink:href="qregularexpression.xml#setPatternOptions">setPatternOptions</db:link>() function on an existing QRegularExpressionObject:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;^\\d+$&quot;);
re.setPatternOptions(QRegularExpression::MultilineOption);
// re matches any line in the subject string that contains only digits (but at least one)
</db:programlisting>
<db:para>It is possible to get the pattern options currently set on a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object by using the <db:link xlink:href="qregularexpression.xml#patternOptions">patternOptions</db:link>() function:</db:para>
<db:programlisting language="cpp">QRegularExpression re = QRegularExpression(&quot;^two.*words$&quot;, QRegularExpression::MultilineOption
                                                           | QRegularExpression::DotMatchesEverythingOption);

QRegularExpression::PatternOptions options = re.patternOptions();
// options == QRegularExpression::MultilineOption | QRegularExpression::DotMatchesEverythingOption
</db:programlisting>
<db:para>Please refer to the <db:link xlink:href="qregularexpression.xml#PatternOption-enum">QRegularExpression::PatternOption</db:link> enum documentation for more information about each pattern option.</db:para>
</db:section>
<db:section xml:id="match-type-and-match-options">
<db:title>Match Type and Match Options</db:title>
<db:para>The last two arguments of the <db:link xlink:href="qregularexpression.xml#match">match</db:link>() and the <db:link xlink:href="qregularexpression.xml#globalMatch">globalMatch</db:link>() functions set the match type and the match options. The match type is a value of the <db:link xlink:href="qregularexpression.xml#MatchType-enum">QRegularExpression::MatchType</db:link> enum; the &quot;traditional&quot; matching algorithm is chosen by using the <db:link xlink:href="qregularexpression.xml#MatchType-enum">NormalMatch</db:link> match type (the default). It is also possible to enable partial matching of the regular expression against a subject string: see the <db:link xlink:href="qregularexpression.xml#partial-matching">partial matching</db:link> section for more details.</db:para>
<db:para>The match options are a set of one or more <db:link xlink:href="qregularexpression.xml#MatchOption-enum">QRegularExpression::MatchOption</db:link> values. They change the way a specific match of a regular expression against a subject string is done. Please refer to the <db:link xlink:href="qregularexpression.xml#MatchOption-enum">QRegularExpression::MatchOption</db:link> enum documentation for more details.</db:para>
</db:section>
<db:section xml:id="normal-matching">
<db:title>Normal Matching</db:title>
<db:para>In order to perform a match you can simply invoke the <db:link xlink:href="qregularexpression.xml#match">match</db:link>() function passing a string to match against. We refer to this string as the <db:emphasis>subject string</db:emphasis>. The result of the <db:link xlink:href="qregularexpression.xml#match">match</db:link>() function is a <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object that can be used to inspect the results of the match. For instance:</db:para>
<db:programlisting language="cpp">// match two digits followed by a space and a word
QRegularExpression re(&quot;\\d\\d \\w+&quot;);
QRegularExpressionMatch match = re.match(&quot;abc123 def&quot;);
bool hasMatch = match.hasMatch(); // true
</db:programlisting>
<db:para>If a match is successful, the (implicit) capturing group number 0 can be used to retrieve the substring matched by the entire pattern (see also the section about <db:link xlink:href="qregularexpression.xml#extracting-captured-substrings">extracting captured substrings</db:link>):</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;\\d\\d \\w+&quot;);
QRegularExpressionMatch match = re.match(&quot;abc123 def&quot;);
if (match.hasMatch()) {
    QString matched = match.captured(0); // matched == &quot;23 def&quot;
    // ...
}
</db:programlisting>
<db:para>It's also possible to start a match at an arbitrary offset inside the subject string by passing the offset as an argument of the <db:link xlink:href="qregularexpression.xml#match">match</db:link>() function. In the following example &quot;12 abc&quot; is not matched because the match is started at offset 1:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;\\d\\d \\w+&quot;);
QRegularExpressionMatch match = re.match(&quot;12 abc 45 def&quot;, 1);
if (match.hasMatch()) {
    QString matched = match.captured(0); // matched == &quot;45 def&quot;
    // ...
}
</db:programlisting>
<db:section xml:id="extracting-captured-substrings">
<db:title>Extracting captured substrings</db:title>
<db:para>The <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object contains also information about the substrings captured by the capturing groups in the pattern string. The <db:link xlink:href="qregularexpressionmatch.xml#captured">captured</db:link>() function will return the string captured by the n-th capturing group:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;^(\\d\\d)/(\\d\\d)/(\\d\\d\\d\\d)$&quot;);
QRegularExpressionMatch match = re.match(&quot;08/12/1985&quot;);
if (match.hasMatch()) {
    QString day = match.captured(1); // day == &quot;08&quot;
    QString month = match.captured(2); // month == &quot;12&quot;
    QString year = match.captured(3); // year == &quot;1985&quot;
    // ...
}
</db:programlisting>
<db:para>Capturing groups in the pattern are numbered starting from 1, and the implicit capturing group 0 is used to capture the substring that matched the entire pattern.</db:para>
<db:para>It's also possible to retrieve the starting and the ending offsets (inside the subject string) of each captured substring, by using the <db:link xlink:href="qregularexpressionmatch.xml#capturedStart">capturedStart</db:link>() and the <db:link xlink:href="qregularexpressionmatch.xml#capturedEnd">capturedEnd</db:link>() functions:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;abc(\\d+)def&quot;);
QRegularExpressionMatch match = re.match(&quot;XYZabc123defXYZ&quot;);
if (match.hasMatch()) {
    int startOffset = match.capturedStart(1); // startOffset == 6
    int endOffset = match.capturedEnd(1); // endOffset == 9
    // ...
}
</db:programlisting>
<db:para>All of these functions have an overload taking a <db:link xlink:href="qstring.xml">QString</db:link> as a parameter in order to extract <db:emphasis>named</db:emphasis> captured substrings. For instance:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;^(?&amp;lt;date&amp;gt;\\d\\d)/(?&amp;lt;month&amp;gt;\\d\\d)/(?&amp;lt;year&amp;gt;\\d\\d\\d\\d)$&quot;);
QRegularExpressionMatch match = re.match(&quot;08/12/1985&quot;);
if (match.hasMatch()) {
    QString date = match.captured(&quot;date&quot;); // date == &quot;08&quot;
    QString month = match.captured(&quot;month&quot;); // month == &quot;12&quot;
    QString year = match.captured(&quot;year&quot;); // year == 1985
}
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="global-matching">
<db:title>Global Matching</db:title>
<db:para><db:emphasis>Global matching</db:emphasis> is useful to find all the occurrences of a given regular expression inside a subject string. Suppose that we want to extract all the words from a given string, where a word is a substring matching the pattern \w+.</db:para>
<db:para><db:link xlink:href="qregularexpression.xml#globalMatch">QRegularExpression::globalMatch</db:link> returns a <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link>, which is a Java-like forward iterator that can be used to iterate over the results. For instance:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;(\\w+)&quot;);
QRegularExpressionMatchIterator i = re.globalMatch(&quot;the quick fox&quot;);
</db:programlisting>
<db:para>Since it's a Java-like iterator, the <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link> will point immediately before the first result. Every result is returned as a <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object. The <db:link xlink:href="qregularexpressionmatchiterator.xml#hasNext">hasNext</db:link>() function will return true if there's at least one more result, and <db:link xlink:href="qregularexpressionmatchiterator.xml#next">next</db:link>() will return the next result and advance the iterator. Continuing from the previous example:</db:para>
<db:programlisting language="cpp">QStringList words;
while (i.hasNext()) {
    QRegularExpressionMatch match = i.next();
    QString word = match.captured(1);
    words &amp;lt;&amp;lt; word;
}
// words contains &quot;the&quot;, &quot;quick&quot;, &quot;fox&quot;
</db:programlisting>
<db:para>You can also use <db:link xlink:href="qregularexpressionmatchiterator.xml#peekNext">peekNext</db:link>() to get the next result without advancing the iterator.</db:para>
<db:para>It is also possible to simply use the result of <db:link xlink:href="qregularexpression.xml#globalMatch">QRegularExpression::globalMatch</db:link> in a range-based for loop, for instance like this:</db:para>
<db:programlisting language="cpp">// using a raw string literal, R&quot;(raw_characters)&quot;, to be able to use &quot;\w&quot;
// without having to escape the backslash as &quot;\\w&quot;
QRegularExpression re(R&quot;(\w+)&quot;);
QString subject(&quot;the quick fox&quot;);
for (const QRegularExpressionMatch &amp;amp;match : re.globalMatch(subject)) {
    // ...
}
</db:programlisting>
<db:para>It is possible to pass a starting offset and one or more match options to the <db:link xlink:href="qregularexpression.xml#globalMatch">globalMatch</db:link>() function, exactly like normal matching with <db:link xlink:href="qregularexpression.xml#match">match</db:link>().</db:para>
</db:section>
<db:section xml:id="partial-matching">
<db:title>Partial Matching</db:title>
<db:para>A <db:emphasis>partial match</db:emphasis> is obtained when the end of the subject string is reached, but more characters are needed to successfully complete the match. Note that a partial match is usually much more inefficient than a normal match because many optimizations of the matching algorithm cannot be employed.</db:para>
<db:para>A partial match must be explicitly requested by specifying a match type of <db:link xlink:href="qregularexpression.xml#MatchType-enum">PartialPreferCompleteMatch</db:link> or <db:link xlink:href="qregularexpression.xml#MatchType-enum">PartialPreferFirstMatch</db:link> when calling <db:link xlink:href="qregularexpression.xml#match">QRegularExpression::match</db:link> or <db:link xlink:href="qregularexpression.xml#globalMatch">QRegularExpression::globalMatch</db:link>. If a partial match is found, then calling the <db:link xlink:href="qregularexpressionmatch.xml#hasMatch">hasMatch</db:link>() function on the <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object returned by <db:link xlink:href="qregularexpression.xml#match">match</db:link>() will return false, but <db:link xlink:href="qregularexpressionmatch.xml#hasPartialMatch">hasPartialMatch</db:link>() will return true.</db:para>
<db:para>When a partial match is found, no captured substrings are returned, and the (implicit) capturing group 0 corresponding to the whole match captures the partially matched substring of the subject string.</db:para>
<db:para>Note that asking for a partial match can still lead to a complete match, if one is found; in this case, <db:link xlink:href="qregularexpressionmatch.xml#hasMatch">hasMatch</db:link>() will return true and <db:link xlink:href="qregularexpressionmatch.xml#hasPartialMatch">hasPartialMatch</db:link>() false. It never happens that a <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> reports both a partial and a complete match.</db:para>
<db:para>Partial matching is mainly useful in two scenarios: validating user input in real time and incremental/multi-segment matching.</db:para>
<db:section xml:id="validating-user-input">
<db:title>Validating user input</db:title>
<db:para>Suppose that we would like the user to input a date in a specific format, for instance &quot;MMM dd, yyyy&quot;. We can check the input validity with a pattern like:</db:para>
<db:para>^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \d\d?, \d\d\d\d$</db:para>
<db:para>(This pattern doesn't catch invalid days, but let's keep it for the example's purposes).</db:para>
<db:para>We would like to validate the input with this regular expression <db:emphasis>while</db:emphasis> the user is typing it, so that we can report an error in the input as soon as it is committed (for instance, the user typed the wrong key). In order to do so we must distinguish three cases:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>the input cannot possibly match the regular expression;</db:para>
</db:listitem>
<db:listitem>
<db:para>the input does match the regular expression;</db:para>
</db:listitem>
<db:listitem>
<db:para>the input does not match the regular expression right now, but it will if more characters will be added to it.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Note that these three cases represent exactly the possible states of a <db:link xlink:href="qvalidator.xml">QValidator</db:link> (see the <db:link xlink:href="qvalidator.xml#State-enum">QValidator::State</db:link> enum).</db:para>
<db:para>In particular, in the last case we want the regular expression engine to report a partial match: we are successfully matching the pattern against the subject string but the matching cannot continue because the end of the subject is encountered. Notice, however, that the matching algorithm should continue and try all possibilities, and in case a complete (non-partial) match is found, then this one should be reported, and the input string accepted as fully valid.</db:para>
<db:para>This behavior is implemented by the <db:link xlink:href="qregularexpression.xml#MatchType-enum">PartialPreferCompleteMatch</db:link> match type. For instance:</db:para>
<db:programlisting language="cpp">QString pattern(&quot;^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d?, \\d\\d\\d\\d$&quot;);
QRegularExpression re(pattern);

QString input(&quot;Jan 21,&quot;);
QRegularExpressionMatch match = re.match(input, 0, QRegularExpression::PartialPreferCompleteMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true
</db:programlisting>
<db:para>If matching the same regular expression against the subject string leads to a complete match, it is reported as usual:</db:para>
<db:programlisting language="cpp">QString input(&quot;Dec 8, 1985&quot;);
QRegularExpressionMatch match = re.match(input, 0, QRegularExpression::PartialPreferCompleteMatch);
bool hasMatch = match.hasMatch(); // true
bool hasPartialMatch = match.hasPartialMatch(); // false
</db:programlisting>
<db:para>Another example with a different pattern, showing the behavior of preferring a complete match over a partial one:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;abc\\w+X|def&quot;);
QRegularExpressionMatch match = re.match(&quot;abcdef&quot;, 0, QRegularExpression::PartialPreferCompleteMatch);
bool hasMatch = match.hasMatch(); // true
bool hasPartialMatch = match.hasPartialMatch(); // false
QString captured = match.captured(0); // captured == &quot;def&quot;
</db:programlisting>
<db:para>In this case, the subpattern abc\\w+X partially matches the subject string; however, the subpattern def matches the subject string completely, and therefore a complete match is reported.</db:para>
<db:para>If multiple partial matches are found when matching (but no complete match), then the <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object will report the first one that is found. For instance:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;abc\\w+X|defY&quot;);
QRegularExpressionMatch match = re.match(&quot;abcdef&quot;, 0, QRegularExpression::PartialPreferCompleteMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true
QString captured = match.captured(0); // captured == &quot;abcdef&quot;
</db:programlisting>
</db:section>
<db:section xml:id="incremental-multi-segment-matching">
<db:title>Incremental/multi-segment matching</db:title>
<db:para>Incremental matching is another use case of partial matching. Suppose that we want to find the occurrences of a regular expression inside a large text (that is, substrings matching the regular expression). In order to do so we would like to &quot;feed&quot; the large text to the regular expression engines in smaller chunks. The obvious problem is what happens if the substring that matches the regular expression spans across two or more chunks.</db:para>
<db:para>In this case, the regular expression engine should report a partial match, so that we can match again adding new data and (eventually) get a complete match. This implies that the regular expression engine may assume that there are other characters <db:emphasis>beyond the end</db:emphasis> of the subject string. This is not to be taken literally – the engine will never try to access any character after the last one in the subject.</db:para>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> implements this behavior when using the <db:link xlink:href="qregularexpression.xml#MatchType-enum">PartialPreferFirstMatch</db:link> match type. This match type reports a partial match as soon as it is found, and other match alternatives are not tried (even if they could lead to a complete match). For instance:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;abc|ab&quot;);
QRegularExpressionMatch match = re.match(&quot;ab&quot;, 0, QRegularExpression::PartialPreferFirstMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true
</db:programlisting>
<db:para>This happens because when matching the first branch of the alternation operator a partial match is found, and therefore matching stops, without trying the second branch. Another example:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;abc(def)?&quot;);
QRegularExpressionMatch match = re.match(&quot;abc&quot;, 0, QRegularExpression::PartialPreferFirstMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true
</db:programlisting>
<db:para>This shows what could seem a counterintuitive behavior of quantifiers: since ? is greedy, then the engine tries first to continue the match after having matched &quot;abc&quot;; but then the matching reaches the end of the subject string, and therefore a partial match is reported. This is even more surprising in the following example:</db:para>
<db:programlisting language="cpp">QRegularExpression re(&quot;(abc)*&quot;);
QRegularExpressionMatch match = re.match(&quot;abc&quot;, 0, QRegularExpression::PartialPreferFirstMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true
</db:programlisting>
<db:para>It's easy to understand this behavior if we remember that the engine expects the subject string to be only a substring of the whole text we're looking for a match into (that is, how we said before, that the engine assumes that there are other characters beyond the end of the subject string).</db:para>
<db:para>Since the * quantifier is greedy, then reporting a complete match could be an error, because after the current subject &quot;abc&quot; there may be other occurrences of &quot;abc&quot;. For instance, the complete text could have been &quot;abcabcX&quot;, and therefore the <db:emphasis>right</db:emphasis> match to report (in the complete text) would have been &quot;abcabc&quot;; by matching only against the leading &quot;abc&quot; we instead get a partial match.</db:para>
</db:section>
</db:section>
<db:section xml:id="error-handling">
<db:title>Error Handling</db:title>
<db:para>It is possible for a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object to be invalid because of syntax errors in the pattern string. The <db:link xlink:href="qregularexpression.xml#isValid">isValid</db:link>() function will return true if the regular expression is valid, or false otherwise:</db:para>
<db:programlisting language="cpp">QRegularExpression invalidRe(&quot;(unmatched|parenthesis&quot;);
bool isValid = invalidRe.isValid(); // false
</db:programlisting>
<db:para>You can get more information about the specific error by calling the <db:link xlink:href="qregularexpression.xml#errorString">errorString</db:link>() function; moreover, the <db:link xlink:href="qregularexpression.xml#patternErrorOffset">patternErrorOffset</db:link>() function will return the offset inside the pattern string</db:para>
<db:programlisting language="cpp">QRegularExpression invalidRe(&quot;(unmatched|parenthesis&quot;);
if (!invalidRe.isValid()) {
    QString errorString = invalidRe.errorString(); // errorString == &quot;missing )&quot;
    int errorOffset = invalidRe.patternErrorOffset(); // errorOffset == 22
    // ...
}
</db:programlisting>
<db:para>If a match is attempted with an invalid <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>, then the returned <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object will be invalid as well (that is, its <db:link xlink:href="qregularexpressionmatch.xml#isValid">isValid</db:link>() function will return false). The same applies for attempting a global match.</db:para>
</db:section>
<db:section xml:id="unsupported-perl-compatible-regular-expressions-features">
<db:title>Unsupported Perl-compatible Regular Expressions Features</db:title>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> does not support all the features available in Perl-compatible regular expressions. The most notable one is the fact that duplicated names for capturing groups are not supported, and using them can lead to undefined behavior.</db:para>
<db:para>This may change in a future version of Qt.</db:para>
</db:section>
<db:section xml:id="debugging-code-that-uses-qregularexpression">
<db:title>Debugging Code that Uses QRegularExpression</db:title>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> internally uses a just in time compiler (JIT) to optimize the execution of the matching algorithm. The JIT makes extensive usage of self-modifying code, which can lead debugging tools such as Valgrind to crash. You must enable all checks for self-modifying code if you want to debug programs using <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> (for instance, Valgrind's --smc-check command line option). The downside of enabling such checks is that your program will run considerably slower.</db:para>
<db:para>To avoid that, the JIT is disabled by default if you compile Qt in debug mode. It is possible to override the default and enable or disable the JIT usage (both in debug or release mode) by setting the QT_ENABLE_REGEXP_JIT environment variable to a non-zero or zero value respectively.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link></db:member>
<db:member><db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="MatchOption-enum">
<db:title>enum QRegularExpression::MatchOption</db:title>
<db:bridgehead renderas="sect2">flags QRegularExpression::MatchOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>MatchOption</db:enumname>
<db:enumitem>
<db:enumidentifier>NoMatchOption</db:enumidentifier>
<db:enumvalue>0x0000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AnchorAtOffsetMatchOption</db:enumidentifier>
<db:enumvalue>0x0001</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AnchoredMatchOption</db:enumidentifier>
<db:enumvalue>AnchorAtOffsetMatchOption</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DontCheckSubjectStringMatchOption</db:enumidentifier>
<db:enumvalue>0x0002</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QRegularExpression::MatchOptions</db:typedefname>
</db:typedefsynopsis>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::NoMatchOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0000</db:code></db:td>
<db:td>
<db:para>No match options are set.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::AnchoredMatchOption</db:code></db:para>
</db:td>
<db:td><db:code>AnchorAtOffsetMatchOption</db:code></db:td>
<db:td>
<db:para>Use AnchorAtOffsetMatchOption instead.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::AnchorAtOffsetMatchOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>The match is constrained to start exactly at the offset passed to <db:link xlink:href="qregularexpression.xml#match">match</db:link>() in order to be successful, even if the pattern string does not contain any metacharacter that anchors the match at that point. Note that passing this option does not anchor the end of the match to the end of the subject; if you want to fully anchor a regular expression, use <db:link xlink:href="qregularexpression.xml#anchoredPattern">anchoredPattern</db:link>(). This enum value has been introduced in Qt 6.0.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::DontCheckSubjectStringMatchOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0002</db:code></db:td>
<db:td>
<db:para>The subject string is not checked for UTF-16 validity before attempting a match. Use this option with extreme caution, as attempting to match an invalid string may crash the program and/or constitute a security issue. This enum value has been introduced in Qt 5.4.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>MatchOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;MatchOption&gt;. </db:code>It stores an OR combination of <db:code>MatchOption</db:code> values.</db:para>
</db:section>
<db:section xml:id="MatchType-enum">
<db:title>enum QRegularExpression::MatchType</db:title>
<db:enumsynopsis>
<db:enumname>MatchType</db:enumname>
<db:enumitem>
<db:enumidentifier>NormalMatch</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PartialPreferCompleteMatch</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PartialPreferFirstMatch</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NoMatch</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>The MatchType enum defines the type of the match that should be attempted against the subject string.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::NormalMatch</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>A normal match is done.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::PartialPreferCompleteMatch</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The pattern string is matched partially against the subject string. If a partial match is found, then it is recorded, and other matching alternatives are tried as usual. If a complete match is then found, then it's preferred to the partial match; in this case only the complete match is reported. If instead no complete match is found (but only the partial one), then the partial one is reported.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::PartialPreferFirstMatch</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The pattern string is matched partially against the subject string. If a partial match is found, then matching stops and the partial match is reported. In this case, other matching alternatives (potentially leading to a complete match) are not tried. Moreover, this match type assumes that the subject string only a substring of a larger text, and that (in this text) there are other characters beyond the end of the subject string. This can lead to surprising results; see the discussion in the <db:link xlink:href="qregularexpression.xml#partial-matching">partial matching</db:link> section for more details.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::NoMatch</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>No matching is done. This value is returned as the match type by a default constructed <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> or <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link>. Using this match type is not very useful for the user, as no matching ever happens. This enum value has been introduced in Qt 5.1.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="PatternOption-enum">
<db:title>enum QRegularExpression::PatternOption</db:title>
<db:bridgehead renderas="sect2">flags QRegularExpression::PatternOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>PatternOption</db:enumname>
<db:enumitem>
<db:enumidentifier>NoPatternOption</db:enumidentifier>
<db:enumvalue>0x0000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CaseInsensitiveOption</db:enumidentifier>
<db:enumvalue>0x0001</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DotMatchesEverythingOption</db:enumidentifier>
<db:enumvalue>0x0002</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MultilineOption</db:enumidentifier>
<db:enumvalue>0x0004</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExtendedPatternSyntaxOption</db:enumidentifier>
<db:enumvalue>0x0008</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>InvertedGreedinessOption</db:enumidentifier>
<db:enumvalue>0x0010</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DontCaptureOption</db:enumidentifier>
<db:enumvalue>0x0020</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UseUnicodePropertiesOption</db:enumidentifier>
<db:enumvalue>0x0040</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QRegularExpression::PatternOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>The PatternOption enum defines modifiers to the way the pattern string should be interpreted, and therefore the way the pattern matches against a subject string.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::NoPatternOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0000</db:code></db:td>
<db:td>
<db:para>No pattern options are set.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::CaseInsensitiveOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>The pattern should match against the subject string in a case insensitive way. This option corresponds to the /i modifier in Perl regular expressions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::DotMatchesEverythingOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0002</db:code></db:td>
<db:td>
<db:para>The dot metacharacter (.) in the pattern string is allowed to match any character in the subject string, including newlines (normally, the dot does not match newlines). This option corresponds to the /s modifier in Perl regular expressions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::MultilineOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0004</db:code></db:td>
<db:td>
<db:para>The caret (^) and the dollar ($) metacharacters in the pattern string are allowed to match, respectively, immediately after and immediately before any newline in the subject string, as well as at the very beginning and at the very end of the subject string. This option corresponds to the /m modifier in Perl regular expressions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::ExtendedPatternSyntaxOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0008</db:code></db:td>
<db:td>
<db:para>Any whitespace in the pattern string which is not escaped and outside a character class is ignored. Moreover, an unescaped sharp (<db:emphasis role="bold">#</db:emphasis>) outside a character class causes all the following characters, until the first newline (included), to be ignored. This can be used to increase the readability of a pattern string as well as put comments inside regular expressions; this is particularly useful if the pattern string is loaded from a file or written by the user, because in C++ code it is always possible to use the rules for string literals to put comments outside the pattern string. This option corresponds to the /x modifier in Perl regular expressions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::InvertedGreedinessOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0010</db:code></db:td>
<db:td>
<db:para>The greediness of the quantifiers is inverted: *, +, ?, {m,n}, etc. become lazy, while their lazy versions (*?, +?, ??, {m,n}?, etc.) become greedy. There is no equivalent for this option in Perl regular expressions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::DontCaptureOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0020</db:code></db:td>
<db:td>
<db:para>The non-named capturing groups do not capture substrings; named capturing groups still work as intended, as well as the implicit capturing group number 0 corresponding to the entire match. There is no equivalent for this option in Perl regular expressions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::UseUnicodePropertiesOption</db:code></db:para>
</db:td>
<db:td><db:code>0x0040</db:code></db:td>
<db:td>
<db:para>The meaning of the \w, \d, etc., character classes, as well as the meaning of their counterparts (\W, \D, etc.), is changed from matching ASCII characters only to matching any character with the corresponding Unicode property. For instance, \d is changed to match any character with the Unicode Nd (decimal digit) property; \w to match any character with either the Unicode L (letter) or N (digit) property, plus underscore, and so on. This option corresponds to the /u modifier in Perl regular expressions.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>PatternOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;PatternOption&gt;. </db:code>It stores an OR combination of <db:code>PatternOption</db:code> values.</db:para>
</db:section>
<db:section xml:id="WildcardConversionOption-enum">
<db:title>[since 6.0] enum QRegularExpression::WildcardConversionOption</db:title>
<db:bridgehead renderas="sect2">flags QRegularExpression::WildcardConversionOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>WildcardConversionOption</db:enumname>
<db:enumitem>
<db:enumidentifier>DefaultWildcardConversion</db:enumidentifier>
<db:enumvalue>0x0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnanchoredWildcardConversion</db:enumidentifier>
<db:enumvalue>0x1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QRegularExpression::WildcardConversionOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>The WildcardConversionOption enum defines modifiers to the way a wildcard glob pattern gets converted to a regular expression pattern.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::DefaultWildcardConversion</db:code></db:para>
</db:td>
<db:td><db:code>0x0</db:code></db:td>
<db:td>
<db:para>No conversion options are set.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:emphasis>::UnanchoredWildcardConversion</db:code></db:para>
</db:td>
<db:td><db:code>0x1</db:code></db:td>
<db:td>
<db:para>The conversion will not anchor the pattern. This allows for partial string matches of wildcard expressions.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 6.0.</db:para>
<db:para>The <db:code>WildcardConversionOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;WildcardConversionOption&gt;. </db:code>It stores an OR combination of <db:code>WildcardConversionOption</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QRegularExpression">
<db:title>QRegularExpression::QRegularExpression()</db:title>
<db:constructorsynopsis>
<db:methodname>QRegularExpression</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpression()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object with an empty pattern and no pattern options.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#setPatternOptions">setPatternOptions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRegularExpression-1">
<db:title>[explicit] QRegularExpression::QRegularExpression(const QString &amp;<db:emphasis>pattern</db:emphasis>, QRegularExpression::PatternOptions <db:emphasis>options</db:emphasis> = NoPatternOption)</db:title>
<db:constructorsynopsis>
<db:methodname>QRegularExpression</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>pattern</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::PatternOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>NoPatternOption</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpression(const QString &amp;pattern, QRegularExpression::PatternOptions options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object using the given <db:code role="parameter">pattern</db:code> as pattern and the <db:code role="parameter">options</db:code> as the pattern options.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#setPatternOptions">setPatternOptions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRegularExpression-2">
<db:title>QRegularExpression::QRegularExpression(const QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QRegularExpression</db:methodname>
<db:methodparam>
<db:type>const QRegularExpression &amp;</db:type>
<db:parameter>re</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpression(const QRegularExpression &amp;re)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object as a copy of <db:code role="parameter">re</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRegularExpression-3">
<db:title>[since 6.1] QRegularExpression::QRegularExpression(QRegularExpression &amp;&amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QRegularExpression</db:methodname>
<db:methodparam>
<db:type>QRegularExpression &amp;&amp;</db:type>
<db:parameter>re</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpression(QRegularExpression &amp;&amp;re)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object by moving from <db:code role="parameter">re</db:code>.</db:para>
<db:para>Note that a moved-from <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> can only be destroyed or assigned to. The effect of calling other functions than the destructor or one of the assignment operators is undefined.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#operator-eq">operator=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QRegularExpression">
<db:title>QRegularExpression::~QRegularExpression()</db:title>
<db:destructorsynopsis>
<db:methodname>~QRegularExpression</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QRegularExpression()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object.</db:para>
</db:section>
<db:section xml:id="anchoredPattern">
<db:title>[static, since 5.15] QString QRegularExpression::anchoredPattern(QStringView <db:emphasis>expression</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QString</db:type>
<db:methodname>anchoredPattern</db:methodname>
<db:methodparam>
<db:type>QStringView</db:type>
<db:parameter>expression</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString anchoredPattern(QStringView expression)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:code role="parameter">expression</db:code> wrapped between the \A and \z anchors to be used for exact matching.</db:para>
<db:para>This function was introduced in Qt 5.15.</db:para>
</db:section>
<db:section xml:id="anchoredPattern-1">
<db:title>[static, since 5.12] QString QRegularExpression::anchoredPattern(const QString &amp;<db:emphasis>expression</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QString</db:type>
<db:methodname>anchoredPattern</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>expression</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QString anchoredPattern(const QString &amp;expression)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
</db:section>
<db:section xml:id="captureCount">
<db:title>int QRegularExpression::captureCount() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>captureCount</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int captureCount() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the number of capturing groups inside the pattern string, or -1 if the regular expression is not valid.</db:para>
<db:note>
<db:para>The implicit capturing group 0 is <db:emphasis>not</db:emphasis> included in the returned number.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#isValid">isValid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="errorString">
<db:title>QString QRegularExpression::errorString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>errorString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString errorString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a textual description of the error found when checking the validity of the regular expression, or &quot;no error&quot; if no error was found.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#patternErrorOffset">patternErrorOffset</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="escape">
<db:title>[static, since 5.15] QString QRegularExpression::escape(QStringView <db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QString</db:type>
<db:methodname>escape</db:methodname>
<db:methodparam>
<db:type>QStringView</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString escape(QStringView str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Escapes all characters of <db:code role="parameter">str</db:code> so that they no longer have any special meaning when used as a regular expression pattern string, and returns the escaped string. For instance:</db:para>
<db:programlisting language="cpp">QString escaped = QRegularExpression::escape(&quot;a(x) = f(x) + g(x)&quot;);
// escaped == &quot;a\\(x\\)\\ \\=\\ f\\(x\\)\\ \\+\\ g\\(x\\)&quot;
</db:programlisting>
<db:para>This is very convenient in order to build patterns from arbitrary strings:</db:para>
<db:programlisting language="cpp">QString pattern = &quot;(&quot; + QRegularExpression::escape(name) +
                  &quot;|&quot; + QRegularExpression::escape(nickname) + &quot;)&quot;;
QRegularExpression re(pattern);
</db:programlisting>
<db:note>
<db:para>This function implements Perl's quotemeta algorithm and escapes with a backslash all characters in <db:code role="parameter">str</db:code>, except for the characters in the [A-Z], [a-z] and [0-9] ranges, as well as the underscore (_) character. The only difference with Perl is that a literal NUL inside <db:code role="parameter">str</db:code> is escaped with the sequence &quot;\\0&quot; (backslash + '0'), instead of &quot;\\\0&quot; (backslash + NUL).</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.15.</db:para>
</db:section>
<db:section xml:id="escape-1">
<db:title>[static] QString QRegularExpression::escape(const QString &amp;<db:emphasis>str</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QString</db:type>
<db:methodname>escape</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>str</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QString escape(const QString &amp;str)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="fromWildcard">
<db:title>[static, since 6.0] QRegularExpression QRegularExpression::fromWildcard(QStringView <db:emphasis>pattern</db:emphasis>, Qt::CaseSensitivity <db:emphasis>cs</db:emphasis> = Qt::CaseInsensitive, QRegularExpression::WildcardConversionOptions <db:emphasis>options</db:emphasis> = DefaultWildcardConversion)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QRegularExpression</db:type>
<db:methodname>fromWildcard</db:methodname>
<db:methodparam>
<db:type>QStringView</db:type>
<db:parameter>pattern</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::CaseSensitivity</db:type>
<db:parameter>cs</db:parameter>
<db:initializer>Qt::CaseInsensitive</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::WildcardConversionOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>DefaultWildcardConversion</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpression fromWildcard(QStringView pattern, Qt::CaseSensitivity cs, QRegularExpression::WildcardConversionOptions options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a regular expression of the glob pattern <db:code role="parameter">pattern</db:code>. The regular expression will be case sensitive if <db:code role="parameter">cs</db:code> is <db:link xlink:href="qt.xml#CaseSensitivity-enum">Qt::CaseSensitive</db:link>, and converted according to <db:code role="parameter">options</db:code>.</db:para>
<db:para>Equivalent to</db:para>
<db:programlisting language="cpp">auto reOptions = cs == Qt::CaseSensitive ? QRegularExpression::NoPatternOption :
                                           QRegularExpression::CaseInsensitiveOption;
return QRegularExpression(wildcardToRegularExpression(str, options), reOptions);
</db:programlisting>
<db:para>This function was introduced in Qt 6.0.</db:para>
</db:section>
<db:section xml:id="globalMatch">
<db:title>QRegularExpressionMatchIterator QRegularExpression::globalMatch(const QString &amp;<db:emphasis>subject</db:emphasis>, qsizetype <db:emphasis>offset</db:emphasis> = 0, QRegularExpression::MatchType <db:emphasis>matchType</db:emphasis> = NormalMatch, QRegularExpression::MatchOptions <db:emphasis>matchOptions</db:emphasis> = NoMatchOption) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRegularExpressionMatchIterator</db:type>
<db:methodname>globalMatch</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>subject</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>offset</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::MatchType</db:type>
<db:parameter>matchType</db:parameter>
<db:initializer>NormalMatch</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::MatchOptions</db:type>
<db:parameter>matchOptions</db:parameter>
<db:initializer>NoMatchOption</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpressionMatchIterator globalMatch(const QString &amp;subject, qsizetype offset, QRegularExpression::MatchType matchType, QRegularExpression::MatchOptions matchOptions) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to perform a global match of the regular expression against the given <db:code role="parameter">subject</db:code> string, starting at the position <db:code role="parameter">offset</db:code> inside the subject, using a match of type <db:code role="parameter">matchType</db:code> and honoring the given <db:code role="parameter">matchOptions</db:code>.</db:para>
<db:para>The returned <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link> is positioned before the first match result (if any).</db:para>
<db:note>
<db:para>The data referenced by <db:code role="parameter">subject</db:code> should remain valid as long as there are <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> objects using it. At the moment Qt makes a (shallow) copy of the data, but this behavior may change in a future version of Qt.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link></db:member>
<db:member><db:link xlink:href="qregularexpression.xml#global-matching">global matching</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="globalMatch-1">
<db:title>[since 6.0] QRegularExpressionMatchIterator QRegularExpression::globalMatch(QStringView <db:emphasis>subjectView</db:emphasis>, qsizetype <db:emphasis>offset</db:emphasis> = 0, QRegularExpression::MatchType <db:emphasis>matchType</db:emphasis> = NormalMatch, QRegularExpression::MatchOptions <db:emphasis>matchOptions</db:emphasis> = NoMatchOption) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRegularExpressionMatchIterator</db:type>
<db:methodname>globalMatch</db:methodname>
<db:methodparam>
<db:type>QStringView</db:type>
<db:parameter>subjectView</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>offset</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::MatchType</db:type>
<db:parameter>matchType</db:parameter>
<db:initializer>NormalMatch</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::MatchOptions</db:type>
<db:parameter>matchOptions</db:parameter>
<db:initializer>NoMatchOption</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpressionMatchIterator globalMatch(QStringView subjectView, qsizetype offset, QRegularExpression::MatchType matchType, QRegularExpression::MatchOptions matchOptions) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Attempts to perform a global match of the regular expression against the given <db:code role="parameter">subjectView</db:code> string view, starting at the position <db:code role="parameter">offset</db:code> inside the subject, using a match of type <db:code role="parameter">matchType</db:code> and honoring the given <db:code role="parameter">matchOptions</db:code>.</db:para>
<db:para>The returned <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link> is positioned before the first match result (if any).</db:para>
<db:note>
<db:para>The data referenced by <db:code role="parameter">subjectView</db:code> must remain valid as long as there are <db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link> or <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> objects using it.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpressionmatchiterator.xml">QRegularExpressionMatchIterator</db:link></db:member>
<db:member><db:link xlink:href="qregularexpression.xml#global-matching">global matching</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QRegularExpression::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the regular expression is a valid regular expression (that is, it contains no syntax errors, etc.), or false otherwise. Use <db:link xlink:href="qregularexpression.xml#errorString">errorString</db:link>() to obtain a textual description of the error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#errorString">errorString</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#patternErrorOffset">patternErrorOffset</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="match">
<db:title>QRegularExpressionMatch QRegularExpression::match(const QString &amp;<db:emphasis>subject</db:emphasis>, qsizetype <db:emphasis>offset</db:emphasis> = 0, QRegularExpression::MatchType <db:emphasis>matchType</db:emphasis> = NormalMatch, QRegularExpression::MatchOptions <db:emphasis>matchOptions</db:emphasis> = NoMatchOption) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRegularExpressionMatch</db:type>
<db:methodname>match</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>subject</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>offset</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::MatchType</db:type>
<db:parameter>matchType</db:parameter>
<db:initializer>NormalMatch</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::MatchOptions</db:type>
<db:parameter>matchOptions</db:parameter>
<db:initializer>NoMatchOption</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpressionMatch match(const QString &amp;subject, qsizetype offset, QRegularExpression::MatchType matchType, QRegularExpression::MatchOptions matchOptions) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to match the regular expression against the given <db:code role="parameter">subject</db:code> string, starting at the position <db:code role="parameter">offset</db:code> inside the subject, using a match of type <db:code role="parameter">matchType</db:code> and honoring the given <db:code role="parameter">matchOptions</db:code>.</db:para>
<db:para>The returned <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object contains the results of the match.</db:para>
<db:note>
<db:para>The data referenced by <db:code role="parameter">subject</db:code> should remain valid as long as there are <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> objects using it. At the moment Qt makes a (shallow) copy of the data, but this behavior may change in a future version of Qt.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link></db:member>
<db:member><db:link xlink:href="qregularexpression.xml#normal-matching">normal matching</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="match-1">
<db:title>[since 6.0] QRegularExpressionMatch QRegularExpression::match(QStringView <db:emphasis>subjectView</db:emphasis>, qsizetype <db:emphasis>offset</db:emphasis> = 0, QRegularExpression::MatchType <db:emphasis>matchType</db:emphasis> = NormalMatch, QRegularExpression::MatchOptions <db:emphasis>matchOptions</db:emphasis> = NoMatchOption) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRegularExpressionMatch</db:type>
<db:methodname>match</db:methodname>
<db:methodparam>
<db:type>QStringView</db:type>
<db:parameter>subjectView</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>offset</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::MatchType</db:type>
<db:parameter>matchType</db:parameter>
<db:initializer>NormalMatch</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::MatchOptions</db:type>
<db:parameter>matchOptions</db:parameter>
<db:initializer>NoMatchOption</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpressionMatch match(QStringView subjectView, qsizetype offset, QRegularExpression::MatchType matchType, QRegularExpression::MatchOptions matchOptions) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Attempts to match the regular expression against the given <db:code role="parameter">subjectView</db:code> string view, starting at the position <db:code role="parameter">offset</db:code> inside the subject, using a match of type <db:code role="parameter">matchType</db:code> and honoring the given <db:code role="parameter">matchOptions</db:code>.</db:para>
<db:para>The returned <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> object contains the results of the match.</db:para>
<db:note>
<db:para>The data referenced by <db:code role="parameter">subjectView</db:code> must remain valid as long as there are <db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link> objects using it.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpressionmatch.xml">QRegularExpressionMatch</db:link></db:member>
<db:member><db:link xlink:href="qregularexpression.xml#normal-matching">normal matching</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="namedCaptureGroups">
<db:title>[since 5.1] QStringList QRegularExpression::namedCaptureGroups() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>namedCaptureGroups</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList namedCaptureGroups() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list of <db:link xlink:href="qregularexpression.xml#captureCount">captureCount</db:link>() + 1 elements, containing the names of the named capturing groups in the pattern string. The list is sorted such that the element of the list at position i is the name of the i-th capturing group, if it has a name, or an empty string if that capturing group is unnamed.</db:para>
<db:para>For instance, given the regular expression</db:para>
<db:programlisting language="cpp">    (?&amp;lt;day&amp;gt;\d\d)-(?&amp;lt;month&amp;gt;\d\d)-(?&amp;lt;year&amp;gt;\d\d\d\d) (\w+) (?&amp;lt;name&amp;gt;\w+)
</db:programlisting>
<db:para>namedCaptureGroups() will return the following list:</db:para>
<db:programlisting language="cpp">    (&quot;&quot;, &quot;day&quot;, &quot;month&quot;, &quot;year&quot;, &quot;&quot;, &quot;name&quot;)
</db:programlisting>
<db:para>which corresponds to the fact that the capturing group #0 (corresponding to the whole match) has no name, the capturing group #1 has name &quot;day&quot;, the capturing group #2 has name &quot;month&quot;, etc.</db:para>
<db:para>If the regular expression is not valid, returns an empty list.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpressionmatch.xml#captured">QRegularExpressionMatch::captured</db:link>()</db:member>
<db:member><db:link xlink:href="qstring.xml#isEmpty">QString::isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="optimize">
<db:title>[since 5.4] void QRegularExpression::optimize() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>optimize</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void optimize() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compiles the pattern immediately, including JIT compiling it (if the JIT is enabled) for optimization.</db:para>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#debugging-code-that-uses-qregularexpression">Debugging Code that Uses QRegularExpression</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pattern">
<db:title>QString QRegularExpression::pattern() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>pattern</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString pattern() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the pattern string of the regular expression.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#setPattern">setPattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#patternOptions">patternOptions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="patternErrorOffset">
<db:title>qsizetype QRegularExpression::patternErrorOffset() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qsizetype</db:type>
<db:methodname>patternErrorOffset</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qsizetype patternErrorOffset() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the offset, inside the pattern string, at which an error was found when checking the validity of the regular expression. If no error was found, then -1 is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#pattern">pattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#isValid">isValid</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#errorString">errorString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="patternOptions">
<db:title>QRegularExpression::PatternOptions QRegularExpression::patternOptions() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRegularExpression::PatternOptions</db:type>
<db:methodname>patternOptions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpression::PatternOptions patternOptions() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the pattern options for the regular expression.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#setPatternOptions">setPatternOptions</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#pattern">pattern</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPattern">
<db:title>void QRegularExpression::setPattern(const QString &amp;<db:emphasis>pattern</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPattern</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>pattern</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPattern(const QString &amp;pattern)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the pattern string of the regular expression to <db:code role="parameter">pattern</db:code>. The pattern options are left unchanged.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#pattern">pattern</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#setPatternOptions">setPatternOptions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPatternOptions">
<db:title>void QRegularExpression::setPatternOptions(QRegularExpression::PatternOptions <db:emphasis>options</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPatternOptions</db:methodname>
<db:methodparam>
<db:type>QRegularExpression::PatternOptions</db:type>
<db:parameter>options</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPatternOptions(QRegularExpression::PatternOptions options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the given <db:code role="parameter">options</db:code> as the pattern options of the regular expression. The pattern string is left unchanged.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#patternOptions">patternOptions</db:link>()</db:member>
<db:member><db:link xlink:href="qregularexpression.xml#setPattern">setPattern</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QRegularExpression::swap(QRegularExpression &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QRegularExpression &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QRegularExpression &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps the regular expression <db:code role="parameter">other</db:code> with this regular expression. This operation is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="wildcardToRegularExpression">
<db:title>[static, since 5.15] QString QRegularExpression::wildcardToRegularExpression(QStringView <db:emphasis>pattern</db:emphasis>, QRegularExpression::WildcardConversionOptions <db:emphasis>options</db:emphasis> = DefaultWildcardConversion)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QString</db:type>
<db:methodname>wildcardToRegularExpression</db:methodname>
<db:methodparam>
<db:type>QStringView</db:type>
<db:parameter>pattern</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::WildcardConversionOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>DefaultWildcardConversion</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString wildcardToRegularExpression(QStringView pattern, QRegularExpression::WildcardConversionOptions options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a regular expression representation of the given glob <db:code role="parameter">pattern</db:code>. The transformation is targeting file path globbing, which means in particular that path separators receive special treatment. This implies that it is not just a basic translation from &quot;*&quot; to &quot;.*&quot;.</db:para>
<db:programlisting language="cpp">QString wildcard = QRegularExpression::wildcardToRegularExpression(&quot;*.jpeg&quot;);
// Will match files with names like:
//    foo.jpeg
//    f_o_o.jpeg
//    föö.jpeg
</db:programlisting>
<db:para>By default, the returned regular expression is fully anchored. In other words, there is no need of calling <db:link xlink:href="qregularexpression.xml#anchoredPattern">anchoredPattern</db:link>() again on the result. To get a regular expression that is not anchored, pass <db:link xlink:href="qregularexpression.xml#WildcardConversionOption-enum">UnanchoredWildcardConversion</db:link> as the conversion <db:code role="parameter">options</db:code>.</db:para>
<db:para>This implementation follows closely the definition of wildcard for glob patterns:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">c</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Any character represents itself apart from those mentioned below. Thus <db:emphasis role="bold">c</db:emphasis> matches the character <db:emphasis>c</db:emphasis>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">?</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches any single character. It is the same as <db:emphasis role="bold">.</db:emphasis> in full regexps.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">*</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches zero or more of any characters. It is the same as <db:emphasis role="bold">.*</db:emphasis> in full regexps.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">[abc]</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches one character given in the bracket.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">[a-c]</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches one character from the range given in the bracket.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">[!abc]</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches one character that is not given in the bracket. It is the same as <db:emphasis role="bold">[^abc]</db:emphasis> in full regexp.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:emphasis role="bold">[!a-c]</db:emphasis></db:para>
</db:td>
<db:td>
<db:para>Matches one character that is not from the range given in the bracket. It is the same as <db:emphasis role="bold">[^a-c]</db:emphasis> in full regexp.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:note>
<db:para>The backslash (\) character is <db:emphasis>not</db:emphasis> an escape char in this context. In order to match one of the special characters, place it in square brackets (for example, [?]).</db:para>
</db:note>
<db:para>More information about the implementation can be found in:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="https://en.wikipedia.org/wiki/Glob_(programming)">The Wikipedia Glob article</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>man 7 glob</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>This function was introduced in Qt 5.15.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#escape">escape</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="wildcardToRegularExpression-1">
<db:title>[static, since 5.12] QString QRegularExpression::wildcardToRegularExpression(const QString &amp;<db:emphasis>pattern</db:emphasis>, QRegularExpression::WildcardConversionOptions <db:emphasis>options</db:emphasis> = DefaultWildcardConversion)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QString</db:type>
<db:methodname>wildcardToRegularExpression</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>pattern</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::WildcardConversionOptions</db:type>
<db:parameter>options</db:parameter>
<db:initializer>DefaultWildcardConversion</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QString wildcardToRegularExpression(const QString &amp;pattern, QRegularExpression::WildcardConversionOptions options)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QRegularExpression::operator!=(const QRegularExpression &amp;<db:emphasis>re</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QRegularExpression &amp;</db:type>
<db:parameter>re</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QRegularExpression &amp;re) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the regular expression is different from <db:code role="parameter">re</db:code>, or false otherwise.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QRegularExpression &amp;QRegularExpression::operator=(const QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QRegularExpression &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QRegularExpression &amp;</db:type>
<db:parameter>re</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpression &amp; operator=(const QRegularExpression &amp;re)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns the regular expression <db:code role="parameter">re</db:code> to this object, and returns a reference to the copy. Both the pattern and the pattern options are copied.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QRegularExpression &amp;QRegularExpression::operator=(QRegularExpression &amp;&amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QRegularExpression &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QRegularExpression &amp;&amp;</db:type>
<db:parameter>re</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpression &amp; operator=(QRegularExpression &amp;&amp;re)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Move-assigns the regular expression <db:code role="parameter">re</db:code> to this object, and returns a reference to the result. Both the pattern and the pattern options are copied.</db:para>
<db:para>Note that a moved-from <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> can only be destroyed or assigned to. The effect of calling other functions than the destructor or one of the assignment operators is undefined.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QRegularExpression::operator==(const QRegularExpression &amp;<db:emphasis>re</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QRegularExpression &amp;</db:type>
<db:parameter>re</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QRegularExpression &amp;re) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the regular expression is equal to <db:code role="parameter">re</db:code>, or false otherwise. Two <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> objects are equal if they have the same pattern string and the same pattern options.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qregularexpression.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="qHash">
<db:title>[since 5.6] size_t qHash(const QRegularExpression &amp;<db:emphasis>key</db:emphasis>, size_t <db:emphasis>seed</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:type>size_t</db:type>
<db:methodname>qHash</db:methodname>
<db:methodparam>
<db:type>const QRegularExpression &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>size_t</db:type>
<db:parameter>seed</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">size_t qHash(const QRegularExpression &amp;key, size_t seed)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the hash value for <db:code role="parameter">key</db:code>, using <db:code role="parameter">seed</db:code> to seed the calculation.</db:para>
<db:para>This function was introduced in Qt 5.6.</db:para>
</db:section>
<db:section xml:id="operator-lt-lt">
<db:title>QDataStream &amp;operator&lt;&lt;(QDataStream &amp;<db:emphasis>out</db:emphasis>, const QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>out</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRegularExpression &amp;</db:type>
<db:parameter>re</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&lt;&lt;(QDataStream &amp;out, const QRegularExpression &amp;re)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the regular expression <db:code role="parameter">re</db:code> to stream <db:code role="parameter">out</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt-1">
<db:title>QDebug operator&lt;&lt;(QDebug <db:emphasis>debug</db:emphasis>, const QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDebug</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDebug</db:type>
<db:parameter>debug</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRegularExpression &amp;</db:type>
<db:parameter>re</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QDebug operator&lt;&lt;(QDebug debug, const QRegularExpression &amp;re)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the regular expression <db:code role="parameter">re</db:code> into the debug object <db:code role="parameter">debug</db:code> for debugging purposes.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="debug.xml">Debugging Techniques</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt-lt-2">
<db:title>QDebug operator&lt;&lt;(QDebug <db:emphasis>debug</db:emphasis>, QRegularExpression::PatternOptions <db:emphasis>patternOptions</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDebug</db:type>
<db:methodname>operator&lt;&lt;</db:methodname>
<db:methodparam>
<db:type>QDebug</db:type>
<db:parameter>debug</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression::PatternOptions</db:type>
<db:parameter>patternOptions</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QDebug operator&lt;&lt;(QDebug debug, QRegularExpression::PatternOptions patternOptions)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Writes the pattern options <db:code role="parameter">patternOptions</db:code> into the debug object <db:code role="parameter">debug</db:code> for debugging purposes.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="debug.xml">Debugging Techniques</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-gt-gt">
<db:title>QDataStream &amp;operator&gt;&gt;(QDataStream &amp;<db:emphasis>in</db:emphasis>, QRegularExpression &amp;<db:emphasis>re</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QDataStream &amp;</db:type>
<db:methodname>operator&gt;&gt;</db:methodname>
<db:methodparam>
<db:type>QDataStream &amp;</db:type>
<db:parameter>in</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QRegularExpression &amp;</db:type>
<db:parameter>re</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDataStream &amp; operator&gt;&gt;(QDataStream &amp;in, QRegularExpression &amp;re)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reads a regular expression from stream <db:code role="parameter">in</db:code> into <db:code role="parameter">re</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="datastreamformat.xml">Serializing Qt Data Types</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
