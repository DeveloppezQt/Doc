<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>WebEngine Widgets WebUI Example</db:title>
<db:productname>QtWebEngine</db:productname>
<db:edition>Qt 6.4.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt WebEngine Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Displays HTML over a custom scheme.</db:para>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/webui-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para><db:emphasis>WebUI</db:emphasis> demonstrates how to implement a custom scheme in a secure way.</db:para>
<db:para>Aside from the built-in URL schemes, such as <db:code>http</db:code> and <db:code>qrc</db:code>, Qt WebEngine may be extended with <db:emphasis>custom schemes</db:emphasis> by creating <db:emphasis>custom scheme handlers</db:emphasis>. This example shows:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>How to create a custom scheme handler which serves HTML and handles HTML form submissions.</db:para>
</db:listitem>
<db:listitem>
<db:para>How to prevent ordinary web content from accessing the custom scheme.</db:para>
</db:listitem>
<db:listitem>
<db:para>How to prevent any other scheme from submitting HTML form data.</db:para>
</db:listitem>
</db:itemizedlist>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:guilabel>Welcome</db:guilabel> mode and select the example from <db:guilabel>Examples</db:guilabel>. For more information, visit <db:link xlink:href="https://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="overview">
<db:title>Overview</db:title>
<db:para>The example program consists of a single <db:link xlink:href="qwebengineview.xml">QWebEngineView</db:link> showing a simple HTML page loaded from the URL <db:code>webui:about</db:code>, over our custom scheme. Pressing the button at the bottom of the page will trigger an HTML form submission via POST to the same URL, at which point our custom scheme handler will cause the application to exit.</db:para>
<db:para>The program is divided into two parts, the <db:code>main</db:code> function for setting everything up, and the <db:code>WebUiHandler</db:code> class for implementing our custom scheme handler. The <db:code>main</db:code> function is quite short:</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QCoreApplication::setOrganizationName(&quot;QtExamples&quot;);

    WebUiHandler::registerUrlScheme();

    QApplication app(argc, argv);

    QWebEngineProfile profile;

    WebUiHandler handler;
    profile.installUrlSchemeHandler(WebUiHandler::schemeName, &amp;amp;handler);

    QWebEnginePage page(&amp;amp;profile);
    QWebEngineView view;
    view.setPage(&amp;amp;page);
    page.load(WebUiHandler::aboutUrl);
    view.setContextMenuPolicy(Qt::NoContextMenu);
    view.resize(500, 600);
    view.show();

    return app.exec();
}
</db:programlisting>
<db:para>Aside from the relatively standard setup of widgets, two points are noteworthy. First, we call the static method <db:code>WebUiHandler::registerUrlScheme()</db:code> to register our custom scheme with the web engine. Second, we create and install our custom scheme handler <db:code>WebUiHandler</db:code> using <db:link xlink:href="qwebengineprofile.xml#installUrlSchemeHandler">installUrlSchemeHandler</db:link>(). The following sections describe these aspects in more detail.</db:para>
</db:section>
<db:section xml:id="registering-the-scheme">
<db:title>Registering the Scheme</db:title>
<db:para>As custom schemes are integrated directly into the web engine, they do not necessarily need to follow the standard security rules which apply to ordinary web content. Depending on the chosen configuration, content served over a custom scheme may be given access to local resources, be set to ignore Content-Security-Policy rules, or conversely, be denied access to any other content entirely.</db:para>
<db:para>In order to take advantage of these possibilities, the custom scheme must first be registered. This means creating and configuring a <db:link xlink:href="qwebengineurlscheme.xml">QWebEngineUrlScheme</db:link> object and then handing it over to <db:link xlink:href="qwebengineurlscheme.xml#registerScheme">QWebEngineUrlScheme::registerScheme</db:link>(). The example program does exactly this in the static method <db:code>WebUiHandler::registerUrlScheme()</db:code>:</db:para>
<db:programlisting language="cpp">void WebUiHandler::registerUrlScheme()
{
    QWebEngineUrlScheme webUiScheme(schemeName);
    webUiScheme.setFlags(QWebEngineUrlScheme::SecureScheme |
                         QWebEngineUrlScheme::LocalScheme |
                         QWebEngineUrlScheme::LocalAccessAllowed);
    QWebEngineUrlScheme::registerScheme(webUiScheme);
}
</db:programlisting>
<db:para>A custom scheme needs a name, which can be set by passing it to the constructor of <db:code>QWebEngineUrlScheme</db:code> or by calling <db:link xlink:href="qwebengineurlscheme.xml#setName">QWebEngineUrlScheme::setName</db:link>. In the above, the name <db:code>webui</db:code> is set through the constructor. Additionally, we activate the flags <db:link xlink:href="qwebengineurlscheme.xml#Flag-enum">SecureScheme</db:link>, <db:link xlink:href="qwebengineurlscheme.xml#Flag-enum">LocalScheme</db:link> and <db:link xlink:href="qwebengineurlscheme.xml#Flag-enum">LocalAccessAllowed</db:link>. Since our custom scheme handler will not deliver resources received from insecure network connections, we can safely mark it as a <db:code>SecureScheme</db:code>. The <db:code>LocalScheme</db:code> flag prevents content from non-local schemes (such as <db:code>http</db:code>) from interacting with our custom scheme. Without this flag it would be possible, for example, to embed the <db:code>webui:about</db:code> page in an <db:code>&lt;iframe&gt;</db:code> element on a remotely loaded HTML page, perhaps to attempt a phishing attack. We also need the <db:code>LocalAccessAllowed</db:code> flag without which we would not be able to access the <db:code>webui</db:code> scheme from our <db:code>webui:about</db:code> page.</db:para>
<db:para>Earlier we saw that the call to <db:code>WebUiHandler::registerUrlScheme()</db:code> is made already at the top of the <db:code>main</db:code> function. This is so because custom schemes need to be registered as early as possible so that that they can be passed to all subprocesses. Specifically, custom schemes need to be registered before any other Qt WebEngine classes are instantiated by the application.</db:para>
</db:section>
<db:section xml:id="handling-requests">
<db:title>Handling Requests</db:title>
<db:para>A custom scheme handler is, broadly speaking, similar to a web application served over HTTP. However, because custom schemes are integrated directly into the web engine, they have the advantage in terms of efficiency: there's no need for generating and parsing HTTP messages or for transferring data over sockets.</db:para>
<db:para>Implementing a handler means creating a subclass of <db:link xlink:href="qwebengineurlschemehandler.xml">QWebEngineUrlSchemeHandler</db:link>, which is just what is done by the <db:code>WebUiHandler</db:code> class of the example program:</db:para>
<db:programlisting language="cpp">class WebUiHandler : public QWebEngineUrlSchemeHandler
{
    Q_OBJECT
public:
    explicit WebUiHandler(QObject *parent = nullptr);

    void requestStarted(QWebEngineUrlRequestJob *job) override;

    static void registerUrlScheme();

    const static QByteArray schemeName;
    const static QUrl aboutUrl;
};
</db:programlisting>
<db:para>For each request to a <db:code>webui</db:code> URL, the <db:code>WebUiHandler::requestStarted()</db:code> method will be called:</db:para>
<db:programlisting language="cpp">void WebUiHandler::requestStarted(QWebEngineUrlRequestJob *job)
{
    static const QUrl webUiOrigin(QStringLiteral(SCHEMENAME &quot;:&quot;));
    static const QByteArray GET(QByteArrayLiteral(&quot;GET&quot;));
    static const QByteArray POST(QByteArrayLiteral(&quot;POST&quot;));

    QByteArray method = job-&amp;gt;requestMethod();
    QUrl url = job-&amp;gt;requestUrl();
    QUrl initiator = job-&amp;gt;initiator();

    if (method == GET &amp;amp;&amp;amp; url == aboutUrl) {
        QFile *file = new QFile(QStringLiteral(&quot;:/about.html&quot;), job);
        file-&amp;gt;open(QIODevice::ReadOnly);
        job-&amp;gt;reply(QByteArrayLiteral(&quot;text/html&quot;), file);
    } else if (method == POST &amp;amp;&amp;amp; url == aboutUrl &amp;amp;&amp;amp; initiator == webUiOrigin) {
        job-&amp;gt;fail(QWebEngineUrlRequestJob::RequestAborted);
        QApplication::exit();
    } else {
        job-&amp;gt;fail(QWebEngineUrlRequestJob::UrlNotFound);
    }
}
</db:programlisting>
<db:para>The <db:link xlink:href="qwebengineurlrequestjob.xml">QWebEngineUrlRequestJob</db:link> object <db:code>job</db:code> contains the request's attributes and provides methods for replying to the request with a response. Responses are generated asynchronously by reading them from the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> that the application passes to <db:link xlink:href="qwebengineurlrequestjob.xml#reply">reply</db:link>().</db:para>
<db:warning>
<db:para>The <db:code>requestStarted()</db:code> method is not called from the main thread, but from the web engine's IO thread. Care must be taken to synchronize access to any resources on the main thread.</db:para>
</db:warning>
<db:para>Aside from the usual fare of <db:link xlink:href="qwebengineurlrequestjob.xml#requestMethod">requestMethod</db:link> and <db:link xlink:href="qwebengineurlrequestjob.xml#requestUrl">requestUrl</db:link>, there is also the <db:link xlink:href="qwebengineurlrequestjob.xml#initiator">initiator</db:link>, holding the origin of the content which initiated the request. An empty <db:code>initiator</db:code> means the request was initiated directly by the application (via <db:link xlink:href="qwebenginepage.xml#url-prop">QWebEnginePage::setUrl</db:link>(), for example). The special value <db:code>&quot;null&quot;</db:code> corresponds to an opaque origin (a sandboxed <db:code>&lt;iframe&gt;</db:code> element, for example). Otherwise, the <db:code>initiator</db:code> will contain the URL scheme, hostname, and port of the content which initiated the request.</db:para>
<db:para>In this example, the <db:code>initiator</db:code> is used to ensure that <db:code>POST</db:code> requests to <db:code>webui:about</db:code> will only trigger the application's exit if they originate from the <db:code>webui</db:code> scheme. This prevents content loaded over other schemes from triggering the application's exit.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtwebengine.git/tree/examples/webenginewidgets/webui?h=6.4">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
