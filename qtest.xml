<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QTest Namespace</db:title>
<db:productname>QtTestLib</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Test Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qtest.xml">QTest</db:link> namespace contains all the functions and declarations that are related to Qt Test.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QTest</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Test)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Test)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += testlib</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>See the <db:link xlink:href="qtest-overview.xml">Qt Test Overview</db:link> for information about how to write unit tests.</db:para>
</db:section>
<db:section xml:id="classes">
<db:title>Classes</db:title>
<db:section>
<db:title>class <db:link xlink:href="qtest-qtoucheventsequence.xml" xlink:role="class">QTouchEventSequence</db:link></db:title>
<db:para>The <db:link xlink:href="qtest-qtoucheventsequence.xml">QTouchEventSequence</db:link> class is used to simulate a sequence of touch events.</db:para>
</db:section>
</db:section>
<db:section xml:id="type-documentation">
<db:title>Type Documentation</db:title>
<db:section xml:id="KeyAction-enum">
<db:title>enum QTest::KeyAction</db:title>
<db:enumsynopsis>
<db:enumname>KeyAction</db:enumname>
<db:enumitem>
<db:enumidentifier>Press</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Release</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Click</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Shortcut</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes possible actions for key handling.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::Press</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The key is pressed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::Release</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The key is released.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::Click</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The key is clicked (pressed and released).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::Shortcut</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>A shortcut is activated. This value has been added in Qt 5.6.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="MouseAction-enum">
<db:title>enum QTest::MouseAction</db:title>
<db:enumsynopsis>
<db:enumname>MouseAction</db:enumname>
<db:enumitem>
<db:enumidentifier>MousePress</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MouseRelease</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MouseClick</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MouseDClick</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MouseMove</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes possible actions for mouse handling.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::MousePress</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>A mouse button is pressed.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::MouseRelease</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>A mouse button is released.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::MouseClick</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>A mouse button is clicked (pressed and released).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::MouseDClick</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>A mouse button is double clicked (pressed and released twice).</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::MouseMove</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The mouse pointer has moved.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="QBenchmarkMetric-enum">
<db:title>enum QTest::QBenchmarkMetric</db:title>
<db:enumsynopsis>
<db:enumname>QBenchmarkMetric</db:enumname>
<db:enumitem>
<db:enumidentifier>FramesPerSecond</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BitsPerSecond</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BytesPerSecond</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>WalltimeMilliseconds</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CPUTicks</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>InstructionReads</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Events</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>WalltimeNanoseconds</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BytesAllocated</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CPUMigrations</db:enumidentifier>
<db:enumvalue>9</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CPUCycles</db:enumidentifier>
<db:enumvalue>10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BusCycles</db:enumidentifier>
<db:enumvalue>11</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>StalledCycles</db:enumidentifier>
<db:enumvalue>12</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Instructions</db:enumidentifier>
<db:enumvalue>13</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BranchInstructions</db:enumidentifier>
<db:enumvalue>14</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>BranchMisses</db:enumidentifier>
<db:enumvalue>15</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CacheReferences</db:enumidentifier>
<db:enumvalue>16</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CacheReads</db:enumidentifier>
<db:enumvalue>17</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CacheWrites</db:enumidentifier>
<db:enumvalue>18</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CachePrefetches</db:enumidentifier>
<db:enumvalue>19</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CacheMisses</db:enumidentifier>
<db:enumvalue>20</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CacheReadMisses</db:enumidentifier>
<db:enumvalue>21</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CacheWriteMisses</db:enumidentifier>
<db:enumvalue>22</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CachePrefetchMisses</db:enumidentifier>
<db:enumvalue>23</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ContextSwitches</db:enumidentifier>
<db:enumvalue>24</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PageFaults</db:enumidentifier>
<db:enumvalue>25</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MinorPageFaults</db:enumidentifier>
<db:enumvalue>26</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MajorPageFaults</db:enumidentifier>
<db:enumvalue>27</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>AlignmentFaults</db:enumidentifier>
<db:enumvalue>28</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>EmulationFaults</db:enumidentifier>
<db:enumvalue>29</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RefCPUCycles</db:enumidentifier>
<db:enumvalue>30</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum lists all the things that can be benchmarked.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::FramesPerSecond</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Frames per second</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::BitsPerSecond</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Bits per second</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::BytesPerSecond</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Bytes per second</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::WalltimeMilliseconds</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>Clock time in milliseconds</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::WalltimeNanoseconds</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>Clock time in nanoseconds</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::BytesAllocated</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>Memory usage in bytes</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::Events</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>Event count</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::CPUTicks</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>CPU time</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::CPUMigrations</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>Process migrations between CPUs</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::CPUCycles</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>CPU cycles</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::RefCPUCycles</db:code></db:para>
</db:td>
<db:td><db:code>30</db:code></db:td>
<db:td>
<db:para>Reference CPU cycles</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::BusCycles</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>Bus cycles</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::StalledCycles</db:code></db:para>
</db:td>
<db:td><db:code>12</db:code></db:td>
<db:td>
<db:para>Cycles stalled</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::InstructionReads</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>Instruction reads</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::Instructions</db:code></db:para>
</db:td>
<db:td><db:code>13</db:code></db:td>
<db:td>
<db:para>Instructions executed</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::BranchInstructions</db:code></db:para>
</db:td>
<db:td><db:code>14</db:code></db:td>
<db:td>
<db:para>Branch-type instructions</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::BranchMisses</db:code></db:para>
</db:td>
<db:td><db:code>15</db:code></db:td>
<db:td>
<db:para>Branch instructions that were mispredicted</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::CacheReferences</db:code></db:para>
</db:td>
<db:td><db:code>16</db:code></db:td>
<db:td>
<db:para>Cache accesses of any type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::CacheMisses</db:code></db:para>
</db:td>
<db:td><db:code>20</db:code></db:td>
<db:td>
<db:para>Cache misses of any type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::CacheReads</db:code></db:para>
</db:td>
<db:td><db:code>17</db:code></db:td>
<db:td>
<db:para>Cache reads / loads</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::CacheReadMisses</db:code></db:para>
</db:td>
<db:td><db:code>21</db:code></db:td>
<db:td>
<db:para>Cache read / load misses</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::CacheWrites</db:code></db:para>
</db:td>
<db:td><db:code>18</db:code></db:td>
<db:td>
<db:para>Cache writes / stores</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::CacheWriteMisses</db:code></db:para>
</db:td>
<db:td><db:code>22</db:code></db:td>
<db:td>
<db:para>Cache write / store misses</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::CachePrefetches</db:code></db:para>
</db:td>
<db:td><db:code>19</db:code></db:td>
<db:td>
<db:para>Cache prefetches</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::CachePrefetchMisses</db:code></db:para>
</db:td>
<db:td><db:code>23</db:code></db:td>
<db:td>
<db:para>Cache prefetch misses</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::ContextSwitches</db:code></db:para>
</db:td>
<db:td><db:code>24</db:code></db:td>
<db:td>
<db:para>Context switches</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::PageFaults</db:code></db:para>
</db:td>
<db:td><db:code>25</db:code></db:td>
<db:td>
<db:para>Page faults of any type</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::MinorPageFaults</db:code></db:para>
</db:td>
<db:td><db:code>26</db:code></db:td>
<db:td>
<db:para>Minor page faults</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::MajorPageFaults</db:code></db:para>
</db:td>
<db:td><db:code>27</db:code></db:td>
<db:td>
<db:para>Major page faults</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::AlignmentFaults</db:code></db:para>
</db:td>
<db:td><db:code>28</db:code></db:td>
<db:td>
<db:para>Faults caused due to misalignment</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::EmulationFaults</db:code></db:para>
</db:td>
<db:td><db:code>29</db:code></db:td>
<db:td>
<db:para>Faults that needed software emulation</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Note that <db:code>WalltimeNanoseconds</db:code> and <db:code>BytesAllocated</db:code> are only provided for use via <db:link xlink:href="qtest.xml#setBenchmarkResult">setBenchmarkResult</db:link>(), and results in those metrics are not able to be provided automatically by the <db:link xlink:href="qtest.xml">QTest</db:link> framework.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#benchmarkMetricName">QTest::benchmarkMetricName</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#benchmarkMetricUnit">QTest::benchmarkMetricUnit</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="TestFailMode-enum">
<db:title>enum QTest::TestFailMode</db:title>
<db:enumsynopsis>
<db:enumname>TestFailMode</db:enumname>
<db:enumitem>
<db:enumidentifier>Abort</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Continue</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the modes for handling a check, such as by <db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>() or <db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>() macros, that is known to fail. The mode applies regardless of whether the check fails or succeeds.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::Abort</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Aborts the execution of the test. Use this mode when it doesn't make sense to execute the test any further after the problematic check.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtest.xml">QTest</db:link></db:emphasis>::Continue</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Continues execution of the test after the problematic check.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="function-documentation">
<db:title>Function Documentation</db:title>
<db:section xml:id="addColumn">
<db:title>void QTest::addColumn(const char *<db:emphasis>name</db:emphasis>, T *<db:emphasis>dummy</db:emphasis> = 0)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addColumn</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>T *</db:type>
<db:parameter>dummy</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addColumn(const char *name, T *dummy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds a column with type <db:code>T</db:code> to the current test data. <db:code role="parameter">name</db:code> is the name of the column. <db:code role="parameter">dummy</db:code> is a workaround for buggy compilers and can be ignored.</db:para>
<db:para>To populate the column with values, <db:link xlink:href="qtest.xml#newRow">newRow</db:link>() can be used. Use <db:link xlink:href="qtest.xml#QFETCH">QFETCH</db:link>() to fetch the data in the actual test.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">    QTest::addColumn&amp;lt;int&amp;gt;(&quot;intval&quot;);
    QTest::addColumn&amp;lt;QString&amp;gt;(&quot;str&quot;);
    QTest::addColumn&amp;lt;double&amp;gt;(&quot;dbl&quot;);
    QTest::newRow(&quot;row1&quot;) &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &quot;hello&quot; &amp;lt;&amp;lt; 1.5;
</db:programlisting>
<db:para>To add custom types to the testdata, the type must be registered with <db:link xlink:href="qmetatype.xml">QMetaType</db:link> via <db:link xlink:href="qmetatype.xml#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</db:link>().</db:para>
<db:note>
<db:para>This function can only be used called as part of a test's data function that is invoked by the test framework.</db:para>
</db:note>
<db:para>See <db:link xlink:href="qttestlib-tutorial2-example.xml">Data Driven Testing</db:link> for a more extensive example.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#newRow">QTest::newRow</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QFETCH">QFETCH</db:link>()</db:member>
<db:member><db:link xlink:href="qmetatype.xml">QMetaType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="addRow">
<db:title>QTestData &amp;QTest::addRow(const char *<db:emphasis>format</db:emphasis>, <db:emphasis>...</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QTestData &amp;</db:type>
<db:methodname>addRow</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>...</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QTestData &amp; addRow(const char *format, ...)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends a new row to the current test data.</db:para>
<db:para>The function's arguments are passed to <db:link xlink:href="qbytearray.xml#qsnprintf">qsnprintf</db:link>() for formatting according to <db:code role="parameter">format</db:code>. See the <db:link xlink:href="qbytearray.xml#qvsnprintf">qvsnprintf</db:link>() documentation for caveats and limitations.</db:para>
<db:para>The test output will identify the test run with this test data using the name that results from this formatting.</db:para>
<db:para>Returns a QTestData reference that can be used to stream in data, one value for each column in the table.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">    QTest::addColumn&amp;lt;int&amp;gt;(&quot;input&quot;);
    QTest::addColumn&amp;lt;QString&amp;gt;(&quot;output&quot;);
    QTest::addRow(&quot;%d&quot;, 0) &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; QString(&quot;0&quot;);
    QTest::addRow(&quot;%d&quot;, 1) &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; QString(&quot;1&quot;);
</db:programlisting>
<db:note>
<db:para>This function can only be called as part of a test's data function that is invoked by the test framework.</db:para>
</db:note>
<db:para>See <db:link xlink:href="qttestlib-tutorial2-example.xml">Data Driven Testing</db:link> for a more extensive example.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#newRow">newRow</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#addColumn">addColumn</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QFETCH">QFETCH</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="benchmarkMetricName">
<db:title>const char *QTest::benchmarkMetricName(QTest::QBenchmarkMetric <db:emphasis>metric</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>const char *</db:type>
<db:methodname>benchmarkMetricName</db:methodname>
<db:methodparam>
<db:type>QTest::QBenchmarkMetric</db:type>
<db:parameter>metric</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * benchmarkMetricName(QTest::QBenchmarkMetric metric)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the enum value <db:code role="parameter">metric</db:code> as a character string.</db:para>
</db:section>
<db:section xml:id="benchmarkMetricUnit">
<db:title>const char *QTest::benchmarkMetricUnit(QTest::QBenchmarkMetric <db:emphasis>metric</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>const char *</db:type>
<db:methodname>benchmarkMetricUnit</db:methodname>
<db:methodparam>
<db:type>QTest::QBenchmarkMetric</db:type>
<db:parameter>metric</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * benchmarkMetricUnit(QTest::QBenchmarkMetric metric)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the units of measure for the specified <db:code role="parameter">metric</db:code>.</db:para>
</db:section>
<db:section xml:id="createTouchDevice">
<db:title>QPointingDevice *QTest::createTouchDevice(QInputDevice::DeviceType <db:emphasis>devType</db:emphasis> = QInputDevice::DeviceType::TouchScreen, QInputDevice::Capabilities <db:emphasis>caps</db:emphasis> = QInputDevice::Capability::Position)</db:title>
<db:methodsynopsis>
<db:type>QPointingDevice *</db:type>
<db:methodname>createTouchDevice</db:methodname>
<db:methodparam>
<db:type>QInputDevice::DeviceType</db:type>
<db:parameter>devType</db:parameter>
<db:initializer>QInputDevice::DeviceType::TouchScreen</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QInputDevice::Capabilities</db:type>
<db:parameter>caps</db:parameter>
<db:initializer>QInputDevice::Capability::Position</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QPointingDevice * createTouchDevice(QInputDevice::DeviceType devType, QInputDevice::Capabilities caps)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates a dummy touch device of type <db:code role="parameter">devType</db:code> with capabilities <db:code role="parameter">caps</db:code> for simulation of touch events.</db:para>
<db:para>The touch device will be registered with the QPA window system interface, and deleted automatically when the <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link> is deleted. So you should typically use createTouchDevice() to initialize a <db:link xlink:href="qpointingdevice.xml">QPointingDevice</db:link> member variable in your test case class, and use the same instance for all tests.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest-qtoucheventsequence.xml">QTest::QTouchEventSequence</db:link></db:member>
<db:member><db:link xlink:href="qtest.xml#touchEvent">touchEvent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentAppName">
<db:title>const char *QTest::currentAppName()</db:title>
<db:methodsynopsis>
<db:type>const char *</db:type>
<db:methodname>currentAppName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * currentAppName()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name of the binary that is currently executed.</db:para>
</db:section>
<db:section xml:id="currentDataTag">
<db:title>const char *QTest::currentDataTag()</db:title>
<db:methodsynopsis>
<db:type>const char *</db:type>
<db:methodname>currentDataTag</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * currentDataTag()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name of the current test data. If the test doesn't have any assigned testdata, the function returns <db:code>nullptr</db:code>.</db:para>
</db:section>
<db:section xml:id="currentTestFailed">
<db:title>bool QTest::currentTestFailed()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>currentTestFailed</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool currentTestFailed()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the current test function has failed, otherwise false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#currentTestResolved">QTest::currentTestResolved</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentTestFunction">
<db:title>const char *QTest::currentTestFunction()</db:title>
<db:methodsynopsis>
<db:type>const char *</db:type>
<db:methodname>currentTestFunction</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const char * currentTestFunction()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the name of the test function that is currently executed.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">void MyTestClass::cleanup()
{
    if (qstrcmp(QTest::currentTestFunction(), &quot;myDatabaseTest&quot;) == 0) {
        // clean up all database connections
        closeAllDatabases();
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="currentTestResolved">
<db:title>[since 6.5] bool QTest::currentTestResolved()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>currentTestResolved</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool currentTestResolved()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the current test function has failed or skipped.</db:para>
<db:para>This applies if the test has failed or exercised a skip. When it is true, the test function should return early. In particular, the <db:code>QTRY_*</db:code> macros and the test event loop terminate their loops early if executed during the test function (but not its cleanup()). After a test has called a helper function that uses this module's macros, it can use this function to test whether to return early.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#currentTestFailed">QTest::currentTestFailed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="failOnWarning">
<db:title>[since 6.3] void QTest::failOnWarning(const QRegularExpression &amp;<db:emphasis>messagePattern</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>failOnWarning</db:methodname>
<db:methodparam>
<db:type>const QRegularExpression &amp;</db:type>
<db:parameter>messagePattern</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void failOnWarning(const QRegularExpression &amp;messagePattern)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends a test failure to the test log for each warning that matches <db:code role="parameter">messagePattern</db:code>.</db:para>
<db:para>The test function will continue execution when a failure is added. To abort the test instead, you can check <db:link xlink:href="qtest.xml#currentTestFailed">currentTestFailed</db:link>() and return early if it's <db:code>true</db:code>.</db:para>
<db:para>For each warning, the first pattern that matches will cause a failure, and the remaining patterns will be ignored.</db:para>
<db:para>All patterns are cleared at the end of each test function.</db:para>
<db:programlisting language="cpp">void FileTest::loadFiles()
{
    QTest::failOnWarning(QRegularExpression(&quot;^Failed to load&quot;));

    // Each of these will cause a test failure:
    qWarning() &amp;lt;&amp;lt; &quot;Failed to load image&quot;;
    qWarning() &amp;lt;&amp;lt; &quot;Failed to load video&quot;;
}
</db:programlisting>
<db:para>To fail every test that triggers a given warning, pass a suitable regular expression to this function in <db:link xlink:href="qtest-overview.xml#creating-a-test">init()</db:link>:</db:para>
<db:programlisting language="cpp">void FileTest::init()
{
    QTest::failOnWarning(QRegularExpression(&quot;.?&quot;));
}
</db:programlisting>
<db:note>
<db:para><db:link xlink:href="qtest.xml#ignoreMessage">ignoreMessage</db:link>() takes precedence over this function, so any warnings that match a pattern given to both <db:code>ignoreMessage()</db:code> and <db:code>failOnWarning()</db:code> will be ignored.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest-overview.xml#qt-test-environment-variables">QTEST_FATAL_FAIL</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="failOnWarning-1">
<db:title>[since 6.3] void QTest::failOnWarning(const char *<db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>failOnWarning</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void failOnWarning(const char *message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads <db:link xlink:href="qtest.xml#failOnWarning">failOnWarning</db:link>().</db:para>
<db:para>Appends a test failure to the test log if the <db:code role="parameter">message</db:code> is output.</db:para>
<db:para>This function was introduced in Qt 6.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#failOnWarning">failOnWarning</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="ignoreMessage">
<db:title>void QTest::ignoreMessage(QtMsgType <db:emphasis>type</db:emphasis>, const char *<db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>ignoreMessage</db:methodname>
<db:methodparam>
<db:type>QtMsgType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void ignoreMessage(QtMsgType type, const char *message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Ignores messages created by <db:link xlink:href="qtlogging.xml#qDebug">qDebug</db:link>(), <db:link xlink:href="qtlogging.xml#qInfo">qInfo</db:link>() or <db:link xlink:href="qtlogging.xml#qWarning">qWarning</db:link>(). If the <db:code role="parameter">message</db:code> with the corresponding <db:code role="parameter">type</db:code> is outputted, it will be removed from the test log. If the test finished and the <db:code role="parameter">message</db:code> was not outputted, a test failure is appended to the test log.</db:para>
<db:note>
<db:para>Invoking this function will only ignore one message. If the message you want to ignore is output twice, you have to call ignoreMessage() twice, too.</db:para>
</db:note>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QDir dir;
QTest::ignoreMessage(QtWarningMsg, &quot;QDir::mkdir: Empty or null file name(s)&quot;);
dir.mkdir(&quot;&quot;);
</db:programlisting>
<db:para>The example above tests that <db:link xlink:href="qdir.xml#mkdir">QDir::mkdir</db:link>() outputs the right warning when invoked with an invalid file name.</db:para>
</db:section>
<db:section xml:id="ignoreMessage-1">
<db:title>void QTest::ignoreMessage(QtMsgType <db:emphasis>type</db:emphasis>, const QRegularExpression &amp;<db:emphasis>messagePattern</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>ignoreMessage</db:methodname>
<db:methodparam>
<db:type>QtMsgType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QRegularExpression &amp;</db:type>
<db:parameter>messagePattern</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void ignoreMessage(QtMsgType type, const QRegularExpression &amp;messagePattern)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Ignores messages created by <db:link xlink:href="qtlogging.xml#qDebug">qDebug</db:link>(), <db:link xlink:href="qtlogging.xml#qInfo">qInfo</db:link>() or <db:link xlink:href="qtlogging.xml#qWarning">qWarning</db:link>(). If the message matching <db:code role="parameter">messagePattern</db:code> with the corresponding <db:code role="parameter">type</db:code> is outputted, it will be removed from the test log. If the test finished and the message was not outputted, a test failure is appended to the test log.</db:para>
<db:note>
<db:para>Invoking this function will only ignore one message. If the message you want to ignore is output twice, you have to call <db:link xlink:href="qtest.xml#ignoreMessage">ignoreMessage</db:link>() twice, too.</db:para>
</db:note>
</db:section>
<db:section xml:id="keyClick">
<db:title>void QTest::keyClick(QWidget *<db:emphasis>widget</db:emphasis>, Qt::Key <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyClick</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::Key</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyClick(QWidget *widget, Qt::Key key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Simulates clicking of <db:code role="parameter">key</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">widget</db:code>. If <db:code role="parameter">delay</db:code> is larger than 0, the test will wait for <db:code role="parameter">delay</db:code> milliseconds before clicking the key.</db:para>
<db:para>Examples:</db:para>
<db:programlisting language="cpp">QTest::keyClick(myWidget, Qt::Key_Escape);

QTest::keyClick(myWidget, Qt::Key_Escape, Qt::ShiftModifier, 200);
</db:programlisting>
<db:para>The first example above simulates clicking the <db:code>escape</db:code> key on <db:code>myWidget</db:code> without any keyboard modifiers and without delay. The second example simulates clicking <db:code>shift-escape</db:code> on <db:code>myWidget</db:code> following a 200 ms delay of the test.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyClicks">QTest::keyClicks</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyClick-1">
<db:title>void QTest::keyClick(QWindow *<db:emphasis>window</db:emphasis>, Qt::Key <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyClick</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::Key</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyClick(QWindow *window, Qt::Key key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates clicking of <db:code role="parameter">key</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">window</db:code>. If <db:code role="parameter">delay</db:code> is larger than 0, the test will wait for <db:code role="parameter">delay</db:code> milliseconds before clicking the key.</db:para>
<db:para>Examples:</db:para>
<db:programlisting language="cpp">QTest::keyClick(&amp;amp;myWindow, Qt::Key_Escape);
QTest::keyClick(&amp;amp;myWindow, Qt::Key_Escape, Qt::ShiftModifier, 200);
</db:programlisting>
<db:para>The first example above simulates clicking the <db:code>escape</db:code> key on <db:code>myWindow</db:code> without any keyboard modifiers and without delay. The second example simulates clicking <db:code>shift-escape</db:code> on <db:code>myWindow</db:code> following a 200 ms delay of the test.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyClicks">QTest::keyClicks</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyClick-2">
<db:title>void QTest::keyClick(QWindow *<db:emphasis>window</db:emphasis>, char <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyClick</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyClick(QWindow *window, char key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates clicking of <db:code role="parameter">key</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">window</db:code>. If <db:code role="parameter">delay</db:code> is larger than 0, the test will wait for <db:code role="parameter">delay</db:code> milliseconds before clicking the key.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QWidget myWindow;
QTest::keyClick(&amp;amp;myWindow, Qt::Key_Tab);
</db:programlisting>
<db:para>The example above simulates clicking <db:code>a</db:code> on <db:code>myWindow</db:code> without any keyboard modifiers and without delay of the test.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyClicks">QTest::keyClicks</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyClick-3">
<db:title>void QTest::keyClick(QWidget *<db:emphasis>widget</db:emphasis>, char <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyClick</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyClick(QWidget *widget, char key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates clicking of <db:code role="parameter">key</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">widget</db:code>. If <db:code role="parameter">delay</db:code> is larger than 0, the test will wait for <db:code role="parameter">delay</db:code> milliseconds before clicking the key.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QTest::keyClick(myWidget, 'a');
</db:programlisting>
<db:para>The example above simulates clicking <db:code>a</db:code> on <db:code>myWidget</db:code> without any keyboard modifiers and without delay of the test.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyClicks">QTest::keyClicks</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyClicks">
<db:title>void QTest::keyClicks(QWidget *<db:emphasis>widget</db:emphasis>, const QString &amp;<db:emphasis>sequence</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyClicks</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>sequence</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyClicks(QWidget *widget, const QString &amp;sequence, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Simulates clicking a <db:code role="parameter">sequence</db:code> of keys on a <db:code role="parameter">widget</db:code>. Optionally, a keyboard <db:code role="parameter">modifier</db:code> can be specified as well as a <db:code role="parameter">delay</db:code> (in milliseconds) of the test before each key click.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QTest::keyClicks(myWidget, &quot;hello world&quot;);
</db:programlisting>
<db:para>The example above simulates clicking the sequence of keys representing &quot;hello world&quot; on <db:code>myWidget</db:code> without any keyboard modifiers and without delay of the test.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyClick">QTest::keyClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyEvent">
<db:title>void QTest::keyEvent(QTest::KeyAction <db:emphasis>action</db:emphasis>, QWidget *<db:emphasis>widget</db:emphasis>, Qt::Key <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyEvent</db:methodname>
<db:methodparam>
<db:type>QTest::KeyAction</db:type>
<db:parameter>action</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::Key</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyEvent(QTest::KeyAction action, QWidget *widget, Qt::Key key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sends a Qt key event to <db:code role="parameter">widget</db:code> with the given <db:code role="parameter">key</db:code> and an associated <db:code role="parameter">action</db:code>. Optionally, a keyboard <db:code role="parameter">modifier</db:code> can be specified, as well as a <db:code role="parameter">delay</db:code> (in milliseconds) of the test before sending the event.</db:para>
</db:section>
<db:section xml:id="keyEvent-1">
<db:title>void QTest::keyEvent(QTest::KeyAction <db:emphasis>action</db:emphasis>, QWindow *<db:emphasis>window</db:emphasis>, char <db:emphasis>ascii</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyEvent</db:methodname>
<db:methodparam>
<db:type>QTest::KeyAction</db:type>
<db:parameter>action</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ascii</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyEvent(QTest::KeyAction action, QWindow *window, char ascii, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends a Qt key event to <db:code role="parameter">window</db:code> with the given key <db:code role="parameter">ascii</db:code> and an associated <db:code role="parameter">action</db:code>. Optionally, a keyboard <db:code role="parameter">modifier</db:code> can be specified, as well as a <db:code role="parameter">delay</db:code> (in milliseconds) of the test before sending the event.</db:para>
</db:section>
<db:section xml:id="keyEvent-2">
<db:title>void QTest::keyEvent(QTest::KeyAction <db:emphasis>action</db:emphasis>, QWindow *<db:emphasis>window</db:emphasis>, Qt::Key <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyEvent</db:methodname>
<db:methodparam>
<db:type>QTest::KeyAction</db:type>
<db:parameter>action</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::Key</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyEvent(QTest::KeyAction action, QWindow *window, Qt::Key key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends a Qt key event to <db:code role="parameter">window</db:code> with the given <db:code role="parameter">key</db:code> and an associated <db:code role="parameter">action</db:code>. Optionally, a keyboard <db:code role="parameter">modifier</db:code> can be specified, as well as a <db:code role="parameter">delay</db:code> (in milliseconds) of the test before sending the event.</db:para>
</db:section>
<db:section xml:id="keyEvent-3">
<db:title>void QTest::keyEvent(QTest::KeyAction <db:emphasis>action</db:emphasis>, QWidget *<db:emphasis>widget</db:emphasis>, char <db:emphasis>ascii</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyEvent</db:methodname>
<db:methodparam>
<db:type>QTest::KeyAction</db:type>
<db:parameter>action</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>ascii</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyEvent(QTest::KeyAction action, QWidget *widget, char ascii, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends a Qt key event to <db:code role="parameter">widget</db:code> with the given key <db:code role="parameter">ascii</db:code> and an associated <db:code role="parameter">action</db:code>. Optionally, a keyboard <db:code role="parameter">modifier</db:code> can be specified, as well as a <db:code role="parameter">delay</db:code> (in milliseconds) of the test before sending the event.</db:para>
</db:section>
<db:section xml:id="keyPress">
<db:title>void QTest::keyPress(QWidget *<db:emphasis>widget</db:emphasis>, Qt::Key <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyPress</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::Key</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyPress(QWidget *widget, Qt::Key key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Simulates pressing a <db:code role="parameter">key</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">widget</db:code>. If <db:code role="parameter">delay</db:code> is larger than 0, the test will wait for <db:code role="parameter">delay</db:code> milliseconds before pressing the key.</db:para>
<db:note>
<db:para>At some point you should release the key using <db:link xlink:href="qtest.xml#keyRelease">keyRelease</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyRelease">QTest::keyRelease</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#keyClick">QTest::keyClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyPress-1">
<db:title>void QTest::keyPress(QWindow *<db:emphasis>window</db:emphasis>, char <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyPress</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyPress(QWindow *window, char key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates pressing a <db:code role="parameter">key</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">window</db:code>. If <db:code role="parameter">delay</db:code> is larger than 0, the test will wait for <db:code role="parameter">delay</db:code> milliseconds before pressing the key.</db:para>
<db:note>
<db:para>At some point you should release the key using <db:link xlink:href="qtest.xml#keyRelease">keyRelease</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyRelease">QTest::keyRelease</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#keyClick">QTest::keyClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyPress-2">
<db:title>void QTest::keyPress(QWindow *<db:emphasis>window</db:emphasis>, Qt::Key <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyPress</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::Key</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyPress(QWindow *window, Qt::Key key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates pressing a <db:code role="parameter">key</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">window</db:code>. If <db:code role="parameter">delay</db:code> is larger than 0, the test will wait for <db:code role="parameter">delay</db:code> milliseconds before pressing the key.</db:para>
<db:note>
<db:para>At some point you should release the key using <db:link xlink:href="qtest.xml#keyRelease">keyRelease</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyRelease">QTest::keyRelease</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#keyClick">QTest::keyClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyPress-3">
<db:title>void QTest::keyPress(QWidget *<db:emphasis>widget</db:emphasis>, char <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyPress</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyPress(QWidget *widget, char key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates pressing a <db:code role="parameter">key</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">widget</db:code>. If <db:code role="parameter">delay</db:code> is larger than 0, the test will wait for <db:code role="parameter">delay</db:code> milliseconds before pressing the key.</db:para>
<db:note>
<db:para>At some point you should release the key using <db:link xlink:href="qtest.xml#keyRelease">keyRelease</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyRelease">QTest::keyRelease</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#keyClick">QTest::keyClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyRelease">
<db:title>void QTest::keyRelease(QWidget *<db:emphasis>widget</db:emphasis>, Qt::Key <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyRelease</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::Key</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyRelease(QWidget *widget, Qt::Key key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Simulates releasing a <db:code role="parameter">key</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">widget</db:code>. If <db:code role="parameter">delay</db:code> is larger than 0, the test will wait for <db:code role="parameter">delay</db:code> milliseconds before releasing the key.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyPress">QTest::keyPress</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#keyClick">QTest::keyClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyRelease-1">
<db:title>void QTest::keyRelease(QWindow *<db:emphasis>window</db:emphasis>, char <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyRelease</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyRelease(QWindow *window, char key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates releasing a <db:code role="parameter">key</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">window</db:code>. If <db:code role="parameter">delay</db:code> is larger than 0, the test will wait for <db:code role="parameter">delay</db:code> milliseconds before releasing the key.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyClick">QTest::keyClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyRelease-2">
<db:title>void QTest::keyRelease(QWindow *<db:emphasis>window</db:emphasis>, Qt::Key <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyRelease</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::Key</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyRelease(QWindow *window, Qt::Key key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates releasing a <db:code role="parameter">key</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">window</db:code>. If <db:code role="parameter">delay</db:code> is larger than 0, the test will wait for <db:code role="parameter">delay</db:code> milliseconds before releasing the key.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyPress">QTest::keyPress</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#keyClick">QTest::keyClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keyRelease-3">
<db:title>void QTest::keyRelease(QWidget *<db:emphasis>widget</db:emphasis>, char <db:emphasis>key</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = Qt::NoModifier, int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keyRelease</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>char</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>Qt::NoModifier</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void keyRelease(QWidget *widget, char key, Qt::KeyboardModifiers modifier, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates releasing a <db:code role="parameter">key</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">widget</db:code>. If <db:code role="parameter">delay</db:code> is larger than 0, the test will wait for <db:code role="parameter">delay</db:code> milliseconds before releasing the key.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyClick">QTest::keyClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keySequence">
<db:title>void QTest::keySequence(QWindow *<db:emphasis>window</db:emphasis>, const QKeySequence &amp;<db:emphasis>keySequence</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keySequence</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QKeySequence &amp;</db:type>
<db:parameter>keySequence</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void keySequence(QWindow *window, const QKeySequence &amp;keySequence)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates typing of <db:code role="parameter">keySequence</db:code> into a <db:code role="parameter">window</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyClick">QTest::keyClick</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#keyClicks">QTest::keyClicks</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="keySequence-1">
<db:title>void QTest::keySequence(QWidget *<db:emphasis>widget</db:emphasis>, const QKeySequence &amp;<db:emphasis>keySequence</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>keySequence</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QKeySequence &amp;</db:type>
<db:parameter>keySequence</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void keySequence(QWidget *widget, const QKeySequence &amp;keySequence)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates typing of <db:code role="parameter">keySequence</db:code> into a <db:code role="parameter">widget</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#keyClick">QTest::keyClick</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#keyClicks">QTest::keyClicks</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseClick">
<db:title>void QTest::mouseClick(QWidget *<db:emphasis>widget</db:emphasis>, Qt::MouseButton <db:emphasis>button</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = ..., QPoint <db:emphasis>pos</db:emphasis> = QPoint(), int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>mouseClick</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::MouseButton</db:type>
<db:parameter>button</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>...</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QPoint</db:type>
<db:parameter>pos</db:parameter>
<db:initializer>QPoint()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseClick(QWidget *widget, Qt::MouseButton button, Qt::KeyboardModifiers modifier, QPoint pos, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Simulates clicking a mouse <db:code role="parameter">button</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">widget</db:code>. The position of the click is defined by <db:code role="parameter">pos</db:code>; the default position is the center of the widget. If <db:code role="parameter">delay</db:code> is specified, the test will wait for the specified amount of milliseconds before pressing and before releasing the button.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#mousePress">QTest::mousePress</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#mouseRelease">QTest::mouseRelease</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseClick-1">
<db:title>void QTest::mouseClick(QWindow *<db:emphasis>window</db:emphasis>, Qt::MouseButton <db:emphasis>button</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>stateKey</db:emphasis> = ..., QPoint <db:emphasis>pos</db:emphasis> = QPoint(), int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>mouseClick</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::MouseButton</db:type>
<db:parameter>button</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>stateKey</db:parameter>
<db:initializer>...</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QPoint</db:type>
<db:parameter>pos</db:parameter>
<db:initializer>QPoint()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseClick(QWindow *window, Qt::MouseButton button, Qt::KeyboardModifiers stateKey, QPoint pos, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates clicking a mouse <db:code role="parameter">button</db:code> with an optional <db:code role="parameter">stateKey</db:code> modifier on a <db:code role="parameter">window</db:code>. The position of the click is defined by <db:code role="parameter">pos</db:code>; the default position is the center of the window. If <db:code role="parameter">delay</db:code> is specified, the test will wait for the specified amount of milliseconds before pressing and before releasing the button.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#mousePress">QTest::mousePress</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#mouseRelease">QTest::mouseRelease</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseDClick">
<db:title>void QTest::mouseDClick(QWidget *<db:emphasis>widget</db:emphasis>, Qt::MouseButton <db:emphasis>button</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = ..., QPoint <db:emphasis>pos</db:emphasis> = QPoint(), int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>mouseDClick</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::MouseButton</db:type>
<db:parameter>button</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>...</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QPoint</db:type>
<db:parameter>pos</db:parameter>
<db:initializer>QPoint()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseDClick(QWidget *widget, Qt::MouseButton button, Qt::KeyboardModifiers modifier, QPoint pos, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Simulates double clicking a mouse <db:code role="parameter">button</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">widget</db:code>. The position of the click is defined by <db:code role="parameter">pos</db:code>; the default position is the center of the widget. If <db:code role="parameter">delay</db:code> is specified, the test will wait for the specified amount of milliseconds before each press and release.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#mouseClick">QTest::mouseClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseDClick-1">
<db:title>void QTest::mouseDClick(QWindow *<db:emphasis>window</db:emphasis>, Qt::MouseButton <db:emphasis>button</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>stateKey</db:emphasis> = ..., QPoint <db:emphasis>pos</db:emphasis> = QPoint(), int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>mouseDClick</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::MouseButton</db:type>
<db:parameter>button</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>stateKey</db:parameter>
<db:initializer>...</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QPoint</db:type>
<db:parameter>pos</db:parameter>
<db:initializer>QPoint()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseDClick(QWindow *window, Qt::MouseButton button, Qt::KeyboardModifiers stateKey, QPoint pos, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates double clicking a mouse <db:code role="parameter">button</db:code> with an optional <db:code role="parameter">stateKey</db:code> modifier on a <db:code role="parameter">window</db:code>. The position of the click is defined by <db:code role="parameter">pos</db:code>; the default position is the center of the window. If <db:code role="parameter">delay</db:code> is specified, the test will wait for the specified amount of milliseconds before each press and release.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#mouseClick">QTest::mouseClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseMove">
<db:title>void QTest::mouseMove(QWidget *<db:emphasis>widget</db:emphasis>, QPoint <db:emphasis>pos</db:emphasis> = QPoint(), int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>mouseMove</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QPoint</db:type>
<db:parameter>pos</db:parameter>
<db:initializer>QPoint()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseMove(QWidget *widget, QPoint pos, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Moves the mouse pointer to a <db:code role="parameter">widget</db:code>. If <db:code role="parameter">pos</db:code> is not specified, the mouse pointer moves to the center of the widget. If a <db:code role="parameter">delay</db:code> (in milliseconds) is given, the test will wait before moving the mouse pointer.</db:para>
</db:section>
<db:section xml:id="mouseMove-1">
<db:title>void QTest::mouseMove(QWindow *<db:emphasis>window</db:emphasis>, QPoint <db:emphasis>pos</db:emphasis> = QPoint(), int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>mouseMove</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QPoint</db:type>
<db:parameter>pos</db:parameter>
<db:initializer>QPoint()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseMove(QWindow *window, QPoint pos, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Moves the mouse pointer to a <db:code role="parameter">window</db:code>. If <db:code role="parameter">pos</db:code> is not specified, the mouse pointer moves to the center of the window. If a <db:code role="parameter">delay</db:code> (in milliseconds) is given, the test will wait before moving the mouse pointer.</db:para>
</db:section>
<db:section xml:id="mousePress">
<db:title>void QTest::mousePress(QWidget *<db:emphasis>widget</db:emphasis>, Qt::MouseButton <db:emphasis>button</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = ..., QPoint <db:emphasis>pos</db:emphasis> = QPoint(), int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>mousePress</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::MouseButton</db:type>
<db:parameter>button</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>...</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QPoint</db:type>
<db:parameter>pos</db:parameter>
<db:initializer>QPoint()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mousePress(QWidget *widget, Qt::MouseButton button, Qt::KeyboardModifiers modifier, QPoint pos, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Simulates pressing a mouse <db:code role="parameter">button</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">widget</db:code>. The position is defined by <db:code role="parameter">pos</db:code>; the default position is the center of the widget. If <db:code role="parameter">delay</db:code> is specified, the test will wait for the specified amount of milliseconds before the press.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#mouseRelease">QTest::mouseRelease</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#mouseClick">QTest::mouseClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mousePress-1">
<db:title>void QTest::mousePress(QWindow *<db:emphasis>window</db:emphasis>, Qt::MouseButton <db:emphasis>button</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>stateKey</db:emphasis> = ..., QPoint <db:emphasis>pos</db:emphasis> = QPoint(), int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>mousePress</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::MouseButton</db:type>
<db:parameter>button</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>stateKey</db:parameter>
<db:initializer>...</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QPoint</db:type>
<db:parameter>pos</db:parameter>
<db:initializer>QPoint()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void mousePress(QWindow *window, Qt::MouseButton button, Qt::KeyboardModifiers stateKey, QPoint pos, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates pressing a mouse <db:code role="parameter">button</db:code> with an optional <db:code role="parameter">stateKey</db:code> modifier on a <db:code role="parameter">window</db:code>. The position is defined by <db:code role="parameter">pos</db:code>; the default position is the center of the window. If <db:code role="parameter">delay</db:code> is specified, the test will wait for the specified amount of milliseconds before the press.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#mouseRelease">QTest::mouseRelease</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#mouseClick">QTest::mouseClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseRelease">
<db:title>void QTest::mouseRelease(QWidget *<db:emphasis>widget</db:emphasis>, Qt::MouseButton <db:emphasis>button</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>modifier</db:emphasis> = ..., QPoint <db:emphasis>pos</db:emphasis> = QPoint(), int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>mouseRelease</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::MouseButton</db:type>
<db:parameter>button</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>modifier</db:parameter>
<db:initializer>...</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QPoint</db:type>
<db:parameter>pos</db:parameter>
<db:initializer>QPoint()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseRelease(QWidget *widget, Qt::MouseButton button, Qt::KeyboardModifiers modifier, QPoint pos, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Simulates releasing a mouse <db:code role="parameter">button</db:code> with an optional <db:code role="parameter">modifier</db:code> on a <db:code role="parameter">widget</db:code>. The position of the release is defined by <db:code role="parameter">pos</db:code>; the default position is the center of the widget. If <db:code role="parameter">delay</db:code> is specified, the test will wait for the specified amount of milliseconds before releasing the button; otherwise, it will wait for a default amount of time (1 ms), which can be overridden via <db:link xlink:href="qtest-overview.xml#testing-options">command-line arguments</db:link>.</db:para>
<db:note>
<db:para>If you wish to test a double-click by sending events individually, specify a short delay, greater than the default, on both mouse release events. The total of the delays for the press, release, press and release must be less than <db:link xlink:href="qstylehints.xml#mouseDoubleClickInterval-prop">QStyleHints::mouseDoubleClickInterval</db:link>(). But if you don't need to check state between events, it's better to use <db:link xlink:href="qtest.xml#mouseDClick">QTest::mouseDClick</db:link>().</db:para>
</db:note>
<db:programlisting language="cpp">QSignalSpy doubleClickSpy(target, &amp;amp;TargetClass::doubleClicked);
const QPoint p(1, 2);
QTest::mousePress(&amp;amp;myWindow, Qt::LeftButton, Qt::NoModifier, p);
QVERIFY(target.isPressed());
QTest::mouseRelease(&amp;amp;myWindow, Qt::LeftButton, Qt::NoModifier, p, 10);
QCOMPARE(target.isPressed(), false);
QTest::mousePress(&amp;amp;myWindow, Qt::LeftButton, Qt::NoModifier, p, 10);
QCOMPARE(target.pressCount(), 2);
QTest::mouseRelease(&amp;amp;myWindow, Qt::LeftButton, Qt::NoModifier, p, 10);
QCOMPARE(doubleClickSpy.count(), 1);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#mousePress">QTest::mousePress</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#mouseClick">QTest::mouseClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="mouseRelease-1">
<db:title>void QTest::mouseRelease(QWindow *<db:emphasis>window</db:emphasis>, Qt::MouseButton <db:emphasis>button</db:emphasis>, Qt::KeyboardModifiers <db:emphasis>stateKey</db:emphasis> = ..., QPoint <db:emphasis>pos</db:emphasis> = QPoint(), int <db:emphasis>delay</db:emphasis> = -1)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>mouseRelease</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::MouseButton</db:type>
<db:parameter>button</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::KeyboardModifiers</db:type>
<db:parameter>stateKey</db:parameter>
<db:initializer>...</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>QPoint</db:type>
<db:parameter>pos</db:parameter>
<db:initializer>QPoint()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>delay</db:parameter>
<db:initializer>-1</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void mouseRelease(QWindow *window, Qt::MouseButton button, Qt::KeyboardModifiers stateKey, QPoint pos, int delay)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Simulates releasing a mouse <db:code role="parameter">button</db:code> with an optional <db:code role="parameter">stateKey</db:code> modifier on a <db:code role="parameter">window</db:code>. The position of the release is defined by <db:code role="parameter">pos</db:code>; the default position is the center of the window. If <db:code role="parameter">delay</db:code> is specified, the test will wait for the specified amount of milliseconds before releasing the button; otherwise, it will wait for a default amount of time (1 ms), which can be overridden via <db:link xlink:href="qtest-overview.xml#testing-options">command-line arguments</db:link>.</db:para>
<db:note>
<db:para>If you wish to test a double-click by sending events individually, specify a short delay, greater than the default, on both mouse release events. The total of the delays for the press, release, press and release must be less than <db:link xlink:href="qstylehints.xml#mouseDoubleClickInterval-prop">QStyleHints::mouseDoubleClickInterval</db:link>(). But if you don't need to check state between events, it's better to use <db:link xlink:href="qtest.xml#mouseDClick">QTest::mouseDClick</db:link>().</db:para>
</db:note>
<db:programlisting language="cpp">QSignalSpy doubleClickSpy(target, &amp;amp;TargetClass::doubleClicked);
const QPoint p(1, 2);
QTest::mousePress(&amp;amp;myWindow, Qt::LeftButton, Qt::NoModifier, p);
QVERIFY(target.isPressed());
QTest::mouseRelease(&amp;amp;myWindow, Qt::LeftButton, Qt::NoModifier, p, 10);
QCOMPARE(target.isPressed(), false);
QTest::mousePress(&amp;amp;myWindow, Qt::LeftButton, Qt::NoModifier, p, 10);
QCOMPARE(target.pressCount(), 2);
QTest::mouseRelease(&amp;amp;myWindow, Qt::LeftButton, Qt::NoModifier, p, 10);
QCOMPARE(doubleClickSpy.count(), 1);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#mousePress">QTest::mousePress</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#mouseClick">QTest::mouseClick</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="newRow">
<db:title>QTestData &amp;QTest::newRow(const char *<db:emphasis>dataTag</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QTestData &amp;</db:type>
<db:methodname>newRow</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>dataTag</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QTestData &amp; newRow(const char *dataTag)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Appends a new row to the current test data.</db:para>
<db:para>The test output will identify the test run with this test data using the name <db:code role="parameter">dataTag</db:code>.</db:para>
<db:para>Returns a QTestData reference that can be used to stream in data, one value for each column in the table.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">void MyTestClass::addSingleStringRows()
{
    QTest::addColumn&amp;lt;QString&amp;gt;(&quot;aString&quot;);
    QTest::newRow(&quot;just.hello&quot;) &amp;lt;&amp;lt; QString(&quot;hello&quot;);
    QTest::newRow(&quot;a.null.string&quot;) &amp;lt;&amp;lt; QString();
}
</db:programlisting>
<db:note>
<db:para>This function can only be called as part of a test's data function that is invoked by the test framework.</db:para>
</db:note>
<db:para>See <db:link xlink:href="qttestlib-tutorial2-example.xml">Data Driven Testing</db:link> for a more extensive example.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#addRow">addRow</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#addColumn">addColumn</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QFETCH">QFETCH</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qExec">
<db:title>int QTest::qExec(QObject *<db:emphasis>testObject</db:emphasis>, int <db:emphasis>argc</db:emphasis> = 0, char **<db:emphasis>argv</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qExec</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>testObject</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>argc</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>char **</db:type>
<db:parameter>argv</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int qExec(QObject *testObject, int argc, char **argv)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Executes tests declared in <db:code role="parameter">testObject</db:code>. In addition, the private slots <db:code>initTestCase()</db:code>, <db:code>cleanupTestCase()</db:code>, <db:code>init()</db:code> and <db:code>cleanup()</db:code> are executed if they exist. See <db:link xlink:href="qtest-overview.xml#creating-a-test">Creating a Test</db:link> for more details.</db:para>
<db:para>Optionally, the command line arguments <db:code role="parameter">argc</db:code> and <db:code role="parameter">argv</db:code> can be provided. For a list of recognized arguments, read <db:link xlink:href="qtest-overview.xml#qt-test-command-line-arguments">Qt Test Command Line Arguments</db:link>.</db:para>
<db:para>The following example will run all tests in <db:code>MyTestObject</db:code>:</db:para>
<db:programlisting language="cpp">MyTestObject test1;
QTest::qExec(&amp;amp;test1);
</db:programlisting>
<db:para>This function returns 0 if no tests failed, or a value other than 0 if one or more tests failed or in case of unhandled exceptions. (Skipped tests do not influence the return value.)</db:para>
<db:para>For stand-alone test applications, the convenience macro <db:link xlink:href="qtest.xml#QTEST_MAIN">QTEST_MAIN</db:link>() can be used to declare a main() function that parses the command line arguments and executes the tests, avoiding the need to call this function explicitly.</db:para>
<db:para>The return value from this function is also the exit code of the test application when the <db:link xlink:href="qtest.xml#QTEST_MAIN">QTEST_MAIN</db:link>() macro is used.</db:para>
<db:para>For stand-alone test applications, this function should not be called more than once, as command-line options for logging test output to files and executing individual test functions will not behave correctly.</db:para>
<db:note>
<db:para>This function is not reentrant, only one test can run at a time. A test that was executed with qExec() can't run another test via qExec() and threads are not allowed to call qExec() simultaneously.</db:para>
</db:note>
<db:para>If you have programmatically created the arguments, as opposed to getting them from the arguments in <db:code>main()</db:code>, it is likely of interest to use QTest::qExec(<db:link xlink:href="qobject.xml">QObject</db:link> *, const <db:link xlink:href="qstringlist.xml">QStringList</db:link> &amp;) since it is Unicode safe.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QTEST_MAIN">QTEST_MAIN</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTEST_GUILESS_MAIN">QTEST_GUILESS_MAIN</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTEST_APPLESS_MAIN">QTEST_APPLESS_MAIN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qExec-1">
<db:title>int QTest::qExec(QObject *<db:emphasis>testObject</db:emphasis>, const QStringList &amp;<db:emphasis>arguments</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>qExec</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>testObject</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>arguments</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int qExec(QObject *testObject, const QStringList &amp;arguments)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Behaves identically to <db:link xlink:href="qtest.xml#qExec">qExec</db:link>(<db:link xlink:href="qobject.xml">QObject</db:link> *, int, char**) but takes a <db:link xlink:href="qstringlist.xml">QStringList</db:link> of <db:code role="parameter">arguments</db:code> instead of a <db:code>char**</db:code> list.</db:para>
</db:section>
<db:section xml:id="qExtractTestData">
<db:title>QSharedPointer&lt;QTemporaryDir&gt; QTest::qExtractTestData(const QString &amp;<db:emphasis>dirName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QSharedPointer&lt;QTemporaryDir&gt;</db:type>
<db:methodname>qExtractTestData</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>dirName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSharedPointer&lt;QTemporaryDir&gt; qExtractTestData(const QString &amp;dirName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Extracts a directory from resources to disk. The content is extracted recursively to a temporary folder. The extracted content is removed automatically once the last reference to the return value goes out of scope.</db:para>
<db:para><db:code role="parameter">dirName</db:code> is the name of the directory to extract from resources.</db:para>
<db:para>Returns the temporary directory where the data was extracted or null in case of errors.</db:para>
</db:section>
<db:section xml:id="qRegisterTestCase">
<db:title>[since 6.5] void QTest::qRegisterTestCase(const QString &amp;<db:emphasis>name</db:emphasis>, QTest::TestEntryFunction <db:emphasis>entryFunction</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qRegisterTestCase</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QTest::TestEntryFunction</db:type>
<db:parameter>entryFunction</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qRegisterTestCase(const QString &amp;name, QTest::TestEntryFunction entryFunction)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers the test <db:code role="parameter">name</db:code>, with entry function <db:code role="parameter">entryFunction</db:code>, in a central test case registry for the current binary.</db:para>
<db:para>The <db:code role="parameter">name</db:code> will be listed when running the batch test binary with no parameters. Running the test binary with the argv[1] of <db:code role="parameter">name</db:code> will result in <db:code role="parameter">entryFunction</db:code> being called.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
</db:section>
<db:section xml:id="qSleep">
<db:title>void QTest::qSleep(int <db:emphasis>ms</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qSleep</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>ms</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qSleep(int ms)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sleeps for <db:code role="parameter">ms</db:code> milliseconds, blocking execution of the test. qSleep() will not do any event processing and leave your test unresponsive. Network communication might time out while sleeping. Use <db:link xlink:href="qtest.xml#qWait">QTest::qWait</db:link>() to do non-blocking sleeping.</db:para>
<db:para><db:code role="parameter">ms</db:code> must be greater than 0.</db:para>
<db:para><db:emphasis role="bold">Note:</db:emphasis> The qSleep() function calls either <db:code>nanosleep()</db:code> on unix or <db:code>Sleep()</db:code> on windows, so the accuracy of time spent in qSleep() depends on the operating system.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QTest::qSleep(250);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#qWait">QTest::qWait</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qWait">
<db:title>void QTest::qWait(int <db:emphasis>ms</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>qWait</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>ms</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void qWait(int ms)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Waits for <db:code role="parameter">ms</db:code> milliseconds. While waiting, events will be processed and your test will stay responsive to user interface events or network communication.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">    int i = 0;
    while (myNetworkServerNotResponding() &amp;amp;&amp;amp; i++ &amp;lt; 50)
        QTest::qWait(250);
</db:programlisting>
<db:para>The code above will wait until the network server is responding for a maximum of about 12.5 seconds.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#qSleep">QTest::qSleep</db:link>()</db:member>
<db:member><db:link xlink:href="qsignalspy.xml#wait">QSignalSpy::wait</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qWaitFor">
<db:title>bool QTest::qWaitFor(Functor <db:emphasis>predicate</db:emphasis>, int <db:emphasis>timeout</db:emphasis> = 5000)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>qWaitFor</db:methodname>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>predicate</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>timeout</db:parameter>
<db:initializer>5000</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool qWaitFor(Functor predicate, int timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Waits for <db:code role="parameter">timeout</db:code> milliseconds or until the <db:code role="parameter">predicate</db:code> returns true.</db:para>
<db:para>Returns <db:code>true</db:code> if the <db:code role="parameter">predicate</db:code> returned true at any point, otherwise returns <db:code>false</db:code>.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">    MyObject obj;
    obj.startup();
    QTest::qWaitFor([&amp;amp;]() {
        return obj.isReady();
    }, 3000);
</db:programlisting>
<db:para>The code above will wait for the object to become ready, for a maximum of three seconds.</db:para>
</db:section>
<db:section xml:id="qWaitForWindowActive">
<db:title>bool QTest::qWaitForWindowActive(QWindow *<db:emphasis>window</db:emphasis>, int <db:emphasis>timeout</db:emphasis> = 5000)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>qWaitForWindowActive</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>timeout</db:parameter>
<db:initializer>5000</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool qWaitForWindowActive(QWindow *window, int timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code>, if <db:code role="parameter">window</db:code> is active within <db:code role="parameter">timeout</db:code> milliseconds. Otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The method is useful in tests that call <db:link xlink:href="qwindow.xml#show">QWindow::show</db:link>() and rely on the window actually being active (i.e. being visible and having focus) before proceeding.</db:para>
<db:note>
<db:para>The method will time out and return <db:code>false</db:code> if another window prevents <db:code role="parameter">window</db:code> from becoming active.</db:para>
</db:note>
<db:note>
<db:para>Since focus is an exclusive property, <db:code role="parameter">window</db:code> may loose its focus to another window at any time - even after the method has returned <db:code>true</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#qWaitForWindowExposed">qWaitForWindowExposed</db:link>()</db:member>
<db:member><db:link xlink:href="qwindow.xml#isActive">QWindow::isActive</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qWaitForWindowActive-1">
<db:title>bool QTest::qWaitForWindowActive(QWidget *<db:emphasis>widget</db:emphasis>, int <db:emphasis>timeout</db:emphasis> = 5000)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>qWaitForWindowActive</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>timeout</db:parameter>
<db:initializer>5000</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool qWaitForWindowActive(QWidget *widget, int timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">widget</db:code> is active within <db:code role="parameter">timeout</db:code> milliseconds. Otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The method is useful in tests that call <db:link xlink:href="qwidget.xml#show">QWidget::show</db:link>() and rely on the widget actually being active (i.e. being visible and having focus) before proceeding.</db:para>
<db:note>
<db:para>The method will time out and return <db:code>false</db:code> if another window prevents <db:code role="parameter">widget</db:code> from becoming active.</db:para>
</db:note>
<db:note>
<db:para>Since focus is an exclusive property, <db:code role="parameter">widget</db:code> may loose its focus to another window at any time - even after the method has returned <db:code>true</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#qWaitForWindowExposed">qWaitForWindowExposed</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#isActiveWindow-prop">QWidget::isActiveWindow</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qWaitForWindowExposed">
<db:title>bool QTest::qWaitForWindowExposed(QWindow *<db:emphasis>window</db:emphasis>, int <db:emphasis>timeout</db:emphasis> = 5000)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>qWaitForWindowExposed</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>timeout</db:parameter>
<db:initializer>5000</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool qWaitForWindowExposed(QWindow *window, int timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code>, if <db:code role="parameter">window</db:code> is exposed within <db:code role="parameter">timeout</db:code> milliseconds. Otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The method is useful in tests that call <db:link xlink:href="qwindow.xml#show">QWindow::show</db:link>() and rely on the window actually being being visible before proceeding.</db:para>
<db:note>
<db:para>A window mapped to screen may still not be considered exposed, if the window client area is not visible, e.g. because it is completely covered by other windows. In such cases, the method will time out and return <db:code>false</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#qWaitForWindowActive">qWaitForWindowActive</db:link>()</db:member>
<db:member><db:link xlink:href="qwindow.xml#isExposed">QWindow::isExposed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="qWaitForWindowExposed-1">
<db:title>bool QTest::qWaitForWindowExposed(QWidget *<db:emphasis>widget</db:emphasis>, int <db:emphasis>timeout</db:emphasis> = 5000)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>qWaitForWindowExposed</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>timeout</db:parameter>
<db:initializer>5000</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool qWaitForWindowExposed(QWidget *widget, int timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if <db:code role="parameter">widget</db:code> is exposed within <db:code role="parameter">timeout</db:code> milliseconds. Otherwise returns <db:code>false</db:code>.</db:para>
<db:para>The method is useful in tests that call <db:link xlink:href="qwidget.xml#show">QWidget::show</db:link>() and rely on the widget actually being being visible before proceeding.</db:para>
<db:note>
<db:para>A window mapped to screen may still not be considered exposed, if the window client area is not visible, e.g. because it is completely covered by other windows. In such cases, the method will time out and return <db:code>false</db:code>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#qWaitForWindowActive">qWaitForWindowActive</db:link>()</db:member>
<db:member><db:link xlink:href="qwidget.xml#visible-prop">QWidget::isVisible</db:link>()</db:member>
<db:member><db:link xlink:href="qwindow.xml#isExposed">QWindow::isExposed</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setBenchmarkResult">
<db:title>void QTest::setBenchmarkResult(qreal <db:emphasis>result</db:emphasis>, QTest::QBenchmarkMetric <db:emphasis>metric</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setBenchmarkResult</db:methodname>
<db:methodparam>
<db:type>qreal</db:type>
<db:parameter>result</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QTest::QBenchmarkMetric</db:type>
<db:parameter>metric</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setBenchmarkResult(qreal result, QTest::QBenchmarkMetric metric)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the benchmark result for this test function to <db:code role="parameter">result</db:code>.</db:para>
<db:para>Use this function if you want to report benchmark results without using the QBENCHMARK macro. Use <db:code role="parameter">metric</db:code> to specify how Qt Test should interpret the results.</db:para>
<db:para>The context for the result will be the test function name and any data tag from the _data function. This function can only be called once in each test function, subsequent calls will replace the earlier reported results.</db:para>
<db:para>Note that the -iterations command line argument has no effect on test functions without the QBENCHMARK macro.</db:para>
</db:section>
<db:section xml:id="toHexRepresentation">
<db:title>char *QTest::toHexRepresentation(const char *<db:emphasis>ba</db:emphasis>, qsizetype <db:emphasis>length</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toHexRepresentation</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>ba</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>qsizetype</db:type>
<db:parameter>length</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toHexRepresentation(const char *ba, qsizetype length)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to a string that is the string <db:code role="parameter">ba</db:code> represented as a space-separated sequence of hex characters. If the input is considered too long, it is truncated. A trucation is indicated in the returned string as an ellipsis at the end. The caller has ownership of the returned pointer and must ensure it is later passed to operator delete[].</db:para>
<db:para><db:code role="parameter">length</db:code> is the length of the string <db:code role="parameter">ba</db:code>.</db:para>
</db:section>
<db:section xml:id="toString">
<db:title>char *QTest::toString(const T &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const T &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const T &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a textual representation of <db:code role="parameter">value</db:code>. This function is used by <db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>() to output verbose information in case of a test failure.</db:para>
<db:para>You can add specializations or overloads of this function to your test to enable verbose output.</db:para>
<db:note>
<db:para>Starting with Qt 5.5, you should prefer to provide a toString() function in the type's namespace instead of specializing this template. If your code needs to continue to work with the QTestLib from Qt 5.4 or earlier, you need to continue to use specialization.</db:para>
</db:note>
<db:note>
<db:para>The caller of toString() must delete the returned data using <db:code>delete[]</db:code>. Your implementation should return a string created with <db:code>new[]</db:code> or <db:link xlink:href="qbytearray.xml#qstrdup">qstrdup</db:link>(). The easiest way to do so is to create a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> or <db:link xlink:href="qstring.xml">QString</db:link> and call QTest::toString() on it (see second example below).</db:para>
</db:note>
<db:para>Example for specializing (Qt  5.4):</db:para>
<db:programlisting language="cpp">namespace QTest {
    template&amp;lt;&amp;gt;
    char *toString(const MyPoint &amp;amp;point)
    {
        const QByteArray ba(&quot;MyPoint(&quot;
                            + QByteArray::number(point.x()) + &quot;, &quot;
                            + QByteArray::number(point.y()) + ')');
        return qstrdup(ba.data());
    }
}
</db:programlisting>
<db:para>The example above defines a toString() specialization for a class called <db:code>MyPoint</db:code>. Whenever a comparison of two instances of <db:code>MyPoint</db:code> fails, <db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>() will call this function to output the contents of <db:code>MyPoint</db:code> to the test log.</db:para>
<db:para>Same example, but with overloading (Qt  5.5):</db:para>
<db:programlisting language="cpp">namespace {
    char *toString(const MyPoint &amp;amp;point)
    {
        return QTest::toString(&quot;MyPoint(&quot; +
                               QByteArray::number(point.x()) + &quot;, &quot; +
                               QByteArray::number(point.y()) + ')');
    }
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toString-1">
<db:title>char *QTest::toString(const QPair&lt;T1, T2&gt; &amp;<db:emphasis>pair</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QPair&lt;T1, T2&gt; &amp;</db:type>
<db:parameter>pair</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QPair&lt;T1, T2&gt; &amp;pair)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the <db:code role="parameter">pair</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-36">
<db:title>char *QTest::toString(const QVector4D &amp;<db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QVector4D &amp;</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">36</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QVector4D &amp;v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the 4D vector <db:code role="parameter">v</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-37">
<db:title>[since 6.5] char *QTest::toString(const QKeySequence &amp;<db:emphasis>ks</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QKeySequence &amp;</db:type>
<db:parameter>ks</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">37</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QKeySequence &amp;ks)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the key sequence <db:code role="parameter">ks</db:code>.</db:para>
<db:para>This function was introduced in Qt 6.5.</db:para>
</db:section>
<db:section xml:id="toString-38">
<db:title>char *QTest::toString(QSizePolicy::Policy <db:emphasis>p</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>QSizePolicy::Policy</db:type>
<db:parameter>p</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">38</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(QSizePolicy::Policy p)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of policy <db:code role="parameter">p</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-39">
<db:title>char *QTest::toString(QSizePolicy::ControlTypes <db:emphasis>cts</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>QSizePolicy::ControlTypes</db:type>
<db:parameter>cts</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">39</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(QSizePolicy::ControlTypes cts)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of control types <db:code role="parameter">cts</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-40">
<db:title>char *QTest::toString(QSizePolicy::ControlType <db:emphasis>ct</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>QSizePolicy::ControlType</db:type>
<db:parameter>ct</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">40</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(QSizePolicy::ControlType ct)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of control type <db:code role="parameter">ct</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-41">
<db:title>char *QTest::toString(QSizePolicy <db:emphasis>sp</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>QSizePolicy</db:type>
<db:parameter>sp</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">41</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(QSizePolicy sp)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of size policy <db:code role="parameter">sp</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-2">
<db:title>char *QTest::toString(const std::pair&lt;T1, T2&gt; &amp;<db:emphasis>pair</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const std::pair&lt;T1, T2&gt; &amp;</db:type>
<db:parameter>pair</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const std::pair&lt;T1, T2&gt; &amp;pair)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the <db:code role="parameter">pair</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-3">
<db:title>char *QTest::toString(const std::tuple&lt;Types...&gt; &amp;<db:emphasis>tuple</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const std::tuple&lt;Types...&gt; &amp;</db:type>
<db:parameter>tuple</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const std::tuple&lt;Types...&gt; &amp;tuple)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">tuple</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-5">
<db:title>char *QTest::toString(const QStringView &amp;<db:emphasis>string</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QStringView &amp;</db:type>
<db:parameter>string</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QStringView &amp;string)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">string</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-6">
<db:title>char *QTest::toString(const QString &amp;<db:emphasis>string</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>string</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QString &amp;string)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">string</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-7">
<db:title>char *QTest::toString(const QLatin1StringView &amp;<db:emphasis>string</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QLatin1StringView &amp;</db:type>
<db:parameter>string</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QLatin1StringView &amp;string)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">string</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-8">
<db:title>char *QTest::toString(const QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>ba</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">8</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QByteArray &amp;ba)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the byte array <db:code role="parameter">ba</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#toHexRepresentation">QTest::toHexRepresentation</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toString-10">
<db:title>char *QTest::toString(const QTime &amp;<db:emphasis>time</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QTime &amp;</db:type>
<db:parameter>time</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">10</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QTime &amp;time)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">time</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-11">
<db:title>char *QTest::toString(const QDate &amp;<db:emphasis>date</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QDate &amp;</db:type>
<db:parameter>date</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">11</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QDate &amp;date)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">date</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-12">
<db:title>char *QTest::toString(const QDateTime &amp;<db:emphasis>dateTime</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QDateTime &amp;</db:type>
<db:parameter>dateTime</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">12</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QDateTime &amp;dateTime)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the date and time specified by <db:code role="parameter">dateTime</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-13">
<db:title>char *QTest::toString(const QCborError &amp;<db:emphasis>c</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QCborError &amp;</db:type>
<db:parameter>c</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">13</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QCborError &amp;c)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given CBOR error <db:code role="parameter">c</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-14">
<db:title>char *QTest::toString(const QChar &amp;<db:emphasis>character</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QChar &amp;</db:type>
<db:parameter>character</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">14</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QChar &amp;character)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">character</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-16">
<db:title>char *QTest::toString(const QPoint &amp;<db:emphasis>point</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>point</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">16</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QPoint &amp;point)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">point</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-17">
<db:title>char *QTest::toString(const QSize &amp;<db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QSize &amp;</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">17</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QSize &amp;size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">size</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-18">
<db:title>char *QTest::toString(const QRect &amp;<db:emphasis>rectangle</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QRect &amp;</db:type>
<db:parameter>rectangle</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">18</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QRect &amp;rectangle)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">rectangle</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-19">
<db:title>char *QTest::toString(const QPointF &amp;<db:emphasis>point</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QPointF &amp;</db:type>
<db:parameter>point</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">19</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QPointF &amp;point)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">point</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-20">
<db:title>char *QTest::toString(const QSizeF &amp;<db:emphasis>size</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QSizeF &amp;</db:type>
<db:parameter>size</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">20</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QSizeF &amp;size)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">size</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-21">
<db:title>char *QTest::toString(const QRectF &amp;<db:emphasis>rectangle</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QRectF &amp;</db:type>
<db:parameter>rectangle</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">21</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QRectF &amp;rectangle)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">rectangle</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-22">
<db:title>char *QTest::toString(const QUrl &amp;<db:emphasis>url</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">22</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QUrl &amp;url)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">url</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-23">
<db:title>char *QTest::toString(const QUuid &amp;<db:emphasis>uuid</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QUuid &amp;</db:type>
<db:parameter>uuid</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">23</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QUuid &amp;uuid)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">uuid</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-24">
<db:title>char *QTest::toString(const QVariant &amp;<db:emphasis>variant</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>variant</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">24</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QVariant &amp;variant)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the given <db:code role="parameter">variant</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-31">
<db:title>char *QTest::toString(<db:emphasis>std::nullptr_t</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>std::nullptr_t</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">31</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(std::nullptr_t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a string containing <db:code>nullptr</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-34">
<db:title>char *QTest::toString(const QVector2D &amp;<db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QVector2D &amp;</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">34</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QVector2D &amp;v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the 2D vector <db:code role="parameter">v</db:code>.</db:para>
</db:section>
<db:section xml:id="toString-35">
<db:title>char *QTest::toString(const QVector3D &amp;<db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>char *</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QVector3D &amp;</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">35</db:synopsisinfo>
<db:synopsisinfo role="signature">char * toString(const QVector3D &amp;v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a textual representation of the 3D vector <db:code role="parameter">v</db:code>.</db:para>
</db:section>
<db:section xml:id="touchEvent">
<db:title>QTest::QTouchEventWidgetSequence QTest::touchEvent(QWidget *<db:emphasis>widget</db:emphasis>, QPointingDevice *<db:emphasis>device</db:emphasis>, bool <db:emphasis>autoCommit</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:type>QTest::QTouchEventWidgetSequence</db:type>
<db:methodname>touchEvent</db:methodname>
<db:methodparam>
<db:type>QWidget *</db:type>
<db:parameter>widget</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QPointingDevice *</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>autoCommit</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QTest::QTouchEventWidgetSequence touchEvent(QWidget *widget, QPointingDevice *device, bool autoCommit)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates and returns a <db:link xlink:href="qtest-qtoucheventsequence.xml">QTouchEventSequence</db:link> for the <db:code role="parameter">device</db:code> to simulate events for <db:code role="parameter">widget</db:code>.</db:para>
<db:para>When adding touch events to the sequence, <db:code role="parameter">widget</db:code> will also be used to translate the position provided to screen coordinates, unless another widget is provided in the respective calls to press(), move() etc.</db:para>
<db:para>The touch events are committed to the event system when the destructor of the <db:link xlink:href="qtest-qtoucheventsequence.xml">QTouchEventSequence</db:link> is called (ie when the object returned runs out of scope), unless <db:code role="parameter">autoCommit</db:code> is set to false. When <db:code role="parameter">autoCommit</db:code> is false, commit() has to be called manually.</db:para>
<db:para><db:link xlink:href="qtest.xml#createTouchDevice">createTouchDevice</db:link>() can be called to create a test touch device for use with this function.</db:para>
</db:section>
<db:section xml:id="touchEvent-1">
<db:title>QTest::QTouchEventSequence QTest::touchEvent(QWindow *<db:emphasis>window</db:emphasis>, QPointingDevice *<db:emphasis>device</db:emphasis>, bool <db:emphasis>autoCommit</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:type>QTest::QTouchEventSequence</db:type>
<db:methodname>touchEvent</db:methodname>
<db:methodparam>
<db:type>QWindow *</db:type>
<db:parameter>window</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QPointingDevice *</db:type>
<db:parameter>device</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>autoCommit</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QTest::QTouchEventSequence touchEvent(QWindow *window, QPointingDevice *device, bool autoCommit)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates and returns a <db:link xlink:href="qtest-qtoucheventsequence.xml">QTouchEventSequence</db:link> for the <db:code role="parameter">device</db:code> to simulate events for <db:code role="parameter">window</db:code>.</db:para>
<db:para>When adding touch events to the sequence, <db:code role="parameter">window</db:code> will also be used to translate the position provided to screen coordinates, unless another window is provided in the respective calls to press(), move() etc.</db:para>
<db:para>The touch events are committed to the event system when the destructor of the <db:link xlink:href="qtest-qtoucheventsequence.xml">QTouchEventSequence</db:link> is called (ie when the object returned runs out of scope), unless <db:code role="parameter">autoCommit</db:code> is set to false. When <db:code role="parameter">autoCommit</db:code> is false, commit() has to be called manually.</db:para>
<db:para><db:link xlink:href="qtest.xml#createTouchDevice">createTouchDevice</db:link>() can be called to create a test touch device for use with this function.</db:para>
</db:section>
</db:section>
<db:section xml:id="macro-documentation">
<db:title>Macro Documentation</db:title>
<db:section xml:id="QBENCHMARK">
<db:title>QBENCHMARK</db:title>
<db:methodsynopsis>
<db:methodname>QBENCHMARK</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QBENCHMARK</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is used to measure the performance of code within a test. The code to be benchmarked is contained within a code block following this macro.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">void TestBenchmark::simple()
{
    QString str1 = u&quot;This is a test string&quot;_s;
    QString str2 = u&quot;This is a test string&quot;_s;
    QCOMPARE(str1.localeAwareCompare(str2), 0);
    QBENCHMARK {
        str1.localeAwareCompare(str2);
    }
}
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest-overview.xml#creating-a-benchmark">Creating a Benchmark</db:link></db:member>
<db:member><db:link xlink:href="qttestlib-tutorial5-example.xml">Writing a Benchmark</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QBENCHMARK_ONCE">
<db:title>QBENCHMARK_ONCE</db:title>
<db:methodsynopsis>
<db:methodname>QBENCHMARK_ONCE</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">macrowithoutparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QBENCHMARK_ONCE</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QBENCHMARK_ONCE macro is for measuring performance of a code block by running it once.</db:para>
<db:para>This macro is used to measure the performance of code within a test. The code to be benchmarked is contained within a code block following this macro.</db:para>
<db:para>Unlike QBENCHMARK, the contents of the contained code block is only run once. The elapsed time will be reported as &quot;0&quot; if it's to short to be measured by the selected backend. (Use)</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest-overview.xml#creating-a-benchmark">Creating a Benchmark</db:link></db:member>
<db:member><db:link xlink:href="qttestlib-tutorial5-example.xml">Writing a Benchmark</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCOMPARE">
<db:title>QCOMPARE(<db:emphasis>actual</db:emphasis>, <db:emphasis>expected</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QCOMPARE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>actual</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>expected</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QCOMPARE(actual, expected)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QCOMPARE() macro compares an <db:code role="parameter">actual</db:code> value to an <db:code role="parameter">expected</db:code> value using the equality operator. If <db:code role="parameter">actual</db:code> and <db:code role="parameter">expected</db:code> match, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</db:para>
<db:para>Always respect QCOMPARE() parameter semantics. The first parameter passed to it should always be the actual value produced by the code-under-test, while the second parameter should always be the expected value. When the values don't match, QCOMPARE() prints them with the labels <db:emphasis>Actual</db:emphasis> and <db:emphasis>Expected</db:emphasis>. If the parameter order is swapped, debugging a failing test can be confusing and tests expecting zero may fail due to rounding errors.</db:para>
<db:para>QCOMPARE() tries to output the contents of the values if the comparison fails, so it is visible from the test log why the comparison failed.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QCOMPARE(QString(&quot;hello&quot;).toUpper(), QString(&quot;HELLO&quot;));
</db:programlisting>
<db:para>When comparing floating-point types (<db:code>float</db:code>, <db:code>double</db:code>, and <db:code>qfloat16</db:code>), <db:link xlink:href="qtnumeric.xml#qFuzzyCompare-1">qFuzzyCompare</db:link>() is used for finite values. If <db:link xlink:href="qtnumeric.xml#qFuzzyIsNull">qFuzzyIsNull</db:link>() is true for both values, they are also considered equal. Infinities match if they have the same sign, and any NaN as actual value matches with any NaN as expected value (even though NaN != NaN, even when they're identical).</db:para>
<db:para>When comparing <db:link xlink:href="qlist.xml">QList</db:link>, arrays and initializer lists of the value type can be passed as expected value:</db:para>
<db:programlisting language="cpp">    const int expected[] = {8, 10, 12, 16, 20, 24};
    QCOMPARE(QFontDatabase::standardSizes(), expected);
</db:programlisting>
<db:para>Note that using initializer lists requires defining a helper macro to prevent the preprocessor from interpreting the commas as macro argument delimiters:</db:para>
<db:programlisting language="cpp"> #define ARG(...) __VA_ARGS__
     QCOMPARE(QFontDatabase::standardSizes(), ARG({8, 10, 12, 16, 20, 24}));
 #undef ARG
</db:programlisting>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>For your own classes, you can overload <db:link xlink:href="qtest.xml#toString">QTest::toString</db:link>() to format values for output into the test log. Example:</db:para>
<db:programlisting language="cpp">char *toString(const MyType &amp;amp;t)
{
    char *repr = new char[t.reprSize()];
    t.writeRepr(repr);
    return repr;
}
</db:programlisting>
<db:para>The return from <db:code>toString()</db:code> must be a <db:code>new char []</db:code>. That is, it shall be released with <db:code>delete[]</db:code> (rather than <db:code>free()</db:code> or plain <db:code>delete</db:code>) once the calling code is done with it.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE">QTRY_COMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#toString">QTest::toString</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_EQ">QCOMPARE_EQ</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_NE">QCOMPARE_NE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LT">QCOMPARE_LT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LE">QCOMPARE_LE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GT">QCOMPARE_GT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GE">QCOMPARE_GE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCOMPARE_EQ">
<db:title>[since 6.4] QCOMPARE_EQ(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QCOMPARE_EQ</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QCOMPARE_EQ(left, right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QCOMPARE_EQ() macro checks that <db:code role="parameter">left</db:code> is equal to <db:code role="parameter">right</db:code> using the equality operator. If that is true, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</db:para>
<db:para>It is generally similar to calling <db:code>QVERIFY(left == right);</db:code> but prints a formatted error message reporting <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> argument expressions and values in case of failure.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>For your own classes, you can overload <db:link xlink:href="qtest.xml#toString">QTest::toString</db:link>() to format values for output into the test log.</db:para>
<db:note>
<db:para>Unlike <db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>(), this macro does not provide overloads for custom types and pointers. So passing e.g. two <db:code>const char *</db:code> values as parameters will compare <db:emphasis>pointers</db:emphasis>, while <db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>() does a comparison of C-style strings.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_NE">QCOMPARE_NE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LT">QCOMPARE_LT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LE">QCOMPARE_LE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GT">QCOMPARE_GT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GE">QCOMPARE_GE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCOMPARE_GE">
<db:title>[since 6.4] QCOMPARE_GE(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QCOMPARE_GE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QCOMPARE_GE(left, right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QCOMPARE_GE() macro checks that <db:code role="parameter">left</db:code> is at least <db:code role="parameter">right</db:code> using the greater-than-or-equal-to operator. If that is true, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</db:para>
<db:para>It is generally similar to calling <db:code>QVERIFY(left &gt;= right);</db:code> but prints a formatted error message reporting <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> argument expressions and values in case of failure.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>For your own classes, you can overload <db:link xlink:href="qtest.xml#toString">QTest::toString</db:link>() to format values for output into the test log.</db:para>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_EQ">QCOMPARE_EQ</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_NE">QCOMPARE_NE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LT">QCOMPARE_LT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LE">QCOMPARE_LE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GT">QCOMPARE_GT</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCOMPARE_GT">
<db:title>[since 6.4] QCOMPARE_GT(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QCOMPARE_GT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QCOMPARE_GT(left, right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QCOMPARE_GT() macro checks that <db:code role="parameter">left</db:code> is greater than <db:code role="parameter">right</db:code> using the greater-than operator. If that is true, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</db:para>
<db:para>It is generally similar to calling <db:code>QVERIFY(left &gt; right);</db:code> but prints a formatted error message reporting <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> argument expressions and values in case of failure.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>For your own classes, you can overload <db:link xlink:href="qtest.xml#toString">QTest::toString</db:link>() to format values for output into the test log.</db:para>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_EQ">QCOMPARE_EQ</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_NE">QCOMPARE_NE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LT">QCOMPARE_LT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LE">QCOMPARE_LE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GE">QCOMPARE_GE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCOMPARE_LE">
<db:title>[since 6.4] QCOMPARE_LE(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QCOMPARE_LE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QCOMPARE_LE(left, right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QCOMPARE_LE() macro checks that <db:code role="parameter">left</db:code> is at most <db:code role="parameter">right</db:code> using the less-than-or-equal-to operator. If that is true, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</db:para>
<db:para>It is generally similar to calling <db:code>QVERIFY(left &lt;= right);</db:code> but prints a formatted error message reporting <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> argument expressions and values in case of failure.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>For your own classes, you can overload <db:link xlink:href="qtest.xml#toString">QTest::toString</db:link>() to format values for output into the test log.</db:para>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_EQ">QCOMPARE_EQ</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_NE">QCOMPARE_NE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LT">QCOMPARE_LT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GT">QCOMPARE_GT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GE">QCOMPARE_GE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCOMPARE_LT">
<db:title>[since 6.4] QCOMPARE_LT(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QCOMPARE_LT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QCOMPARE_LT(left, right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QCOMPARE_LT() macro checks that <db:code role="parameter">left</db:code> is less than <db:code role="parameter">right</db:code> using the less-than operator. If that is true, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</db:para>
<db:para>It is generally similar to calling <db:code>QVERIFY(left &lt; right);</db:code> but prints a formatted error message reporting <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> argument expressions and values in case of failure.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>For your own classes, you can overload <db:link xlink:href="qtest.xml#toString">QTest::toString</db:link>() to format values for output into the test log.</db:para>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_EQ">QCOMPARE_EQ</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_NE">QCOMPARE_NE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LE">QCOMPARE_LE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GT">QCOMPARE_GT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GE">QCOMPARE_GE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCOMPARE_NE">
<db:title>[since 6.4] QCOMPARE_NE(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QCOMPARE_NE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QCOMPARE_NE(left, right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QCOMPARE_NE() macro checks that <db:code role="parameter">left</db:code> is not equal to <db:code role="parameter">right</db:code> using the inequality operator. If that is true, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</db:para>
<db:para>It is generally similar to calling <db:code>QVERIFY(left != right);</db:code> but prints a formatted error message reporting <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> argument expressions and values in case of failure.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>For your own classes, you can overload <db:link xlink:href="qtest.xml#toString">QTest::toString</db:link>() to format values for output into the test log.</db:para>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_EQ">QCOMPARE_EQ</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LT">QCOMPARE_LT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LE">QCOMPARE_LE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GT">QCOMPARE_GT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GE">QCOMPARE_GE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QEXPECT_FAIL">
<db:title>QEXPECT_FAIL(<db:emphasis>dataIndex</db:emphasis>, <db:emphasis>comment</db:emphasis>, <db:emphasis>mode</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QEXPECT_FAIL</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>dataIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>comment</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>mode</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QEXPECT_FAIL(dataIndex, comment, mode)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QEXPECT_FAIL() macro marks the next <db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>() or <db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>() as an expected failure. Instead of adding a failure to the test log, an expected failure will be reported.</db:para>
<db:para>If a <db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>() or <db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>() is marked as an expected failure, but passes instead, an unexpected pass (XPASS) is written to the test log.</db:para>
<db:para>The parameter <db:code role="parameter">dataIndex</db:code> describes for which entry in the test data the failure is expected. Pass an empty string (<db:code>&quot;&quot;</db:code>) if the failure is expected for all entries or if no test data exists.</db:para>
<db:para><db:code role="parameter">comment</db:code> will be appended to the test log for the expected failure.</db:para>
<db:para><db:code role="parameter">mode</db:code> is a <db:link xlink:href="qtest.xml#TestFailMode-enum">QTest::TestFailMode</db:link> and sets whether the test should continue to execute or not. The <db:code role="parameter">mode</db:code> is applied regardless of whether the expected test failure occurs.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>Example 1:</db:para>
<db:programlisting language="cpp">QEXPECT_FAIL(&quot;&quot;, &quot;Will fix in the next release&quot;, Continue);
QCOMPARE(i, 42);
QCOMPARE(j, 43);
</db:programlisting>
<db:para>In the example above, an expected fail will be written into the test output if the variable <db:code>i</db:code> is not 42. If the variable <db:code>i</db:code> is 42, an unexpected pass is written instead. The QEXPECT_FAIL() has no influence on the second <db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>() statement in the example.</db:para>
<db:para>Example 2:</db:para>
<db:programlisting language="cpp">QEXPECT_FAIL(&quot;data27&quot;, &quot;Oh my, this is soooo broken&quot;, Abort);
QCOMPARE(i, 42);
</db:programlisting>
<db:para>The above testfunction will not continue executing for the test data entry <db:code>data27</db:code> (regardless of the value of <db:code>i</db:code>).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#TestFailMode-enum">QTest::TestFailMode</db:link></db:member>
<db:member><db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QFAIL">
<db:title>QFAIL(<db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QFAIL</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QFAIL(message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro can be used to force a test failure. The test stops executing and the failure <db:code role="parameter">message</db:code> is appended to the test log.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>Example:</db:para>
<db:programlisting language="cpp">if (sizeof(int) != 4)
    QFAIL(&quot;This test has not been ported to this platform yet.&quot;);
</db:programlisting>
</db:section>
<db:section xml:id="QFETCH">
<db:title>QFETCH(<db:emphasis>type</db:emphasis>, <db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QFETCH</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QFETCH(type, name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The fetch macro creates a local variable named <db:code role="parameter">name</db:code> with the type <db:code role="parameter">type</db:code> on the stack. The <db:code role="parameter">name</db:code> and <db:code role="parameter">type</db:code> must match a column from the test's data table. This is asserted and the test will abort if the assertion fails.</db:para>
<db:para>Assuming a test has the following data:</db:para>
<db:programlisting language="cpp">void TestQString::toInt_data()
{
    QTest::addColumn&amp;lt;QString&amp;gt;(&quot;aString&quot;);
    QTest::addColumn&amp;lt;int&amp;gt;(&quot;expected&quot;);

    QTest::newRow(&quot;positive+value&quot;) &amp;lt;&amp;lt; &quot;42&quot; &amp;lt;&amp;lt; 42;
    QTest::newRow(&quot;negative-value&quot;) &amp;lt;&amp;lt; &quot;-42&quot; &amp;lt;&amp;lt; -42;
    QTest::newRow(&quot;zero&quot;) &amp;lt;&amp;lt; &quot;0&quot; &amp;lt;&amp;lt; 0;
}
</db:programlisting>
<db:para>The test data has two elements, a <db:link xlink:href="qstring.xml">QString</db:link> called <db:code>aString</db:code> and an integer called <db:code>expected</db:code>. To fetch these values in the actual test:</db:para>
<db:programlisting language="cpp">void TestQString::toInt()
{
     QFETCH(QString, aString);
     QFETCH(int, expected);

     QCOMPARE(aString.toInt(), expected);
}
</db:programlisting>
<db:para><db:code>aString</db:code> and <db:code>expected</db:code> are variables on the stack that are initialized with the current test data.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework. The test function must have a _data function.</db:para>
</db:note>
</db:section>
<db:section xml:id="QFETCH_GLOBAL">
<db:title>QFETCH_GLOBAL(<db:emphasis>type</db:emphasis>, <db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QFETCH_GLOBAL</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QFETCH_GLOBAL(type, name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro fetches a variable named <db:code role="parameter">name</db:code> with the type <db:code role="parameter">type</db:code> from a row in the global data table. The <db:code role="parameter">name</db:code> and <db:code role="parameter">type</db:code> must match a column in the global data table. This is asserted and the test will abort if the assertion fails.</db:para>
<db:para>Assuming a test has the following data:</db:para>
<db:programlisting language="cpp">void TestQLocale::initTestCase_data()
{
    QTest::addColumn&amp;lt;QLocale&amp;gt;(&quot;locale&quot;);
    QTest::newRow(&quot;C&quot;) &amp;lt;&amp;lt; QLocale::c();
    QTest::newRow(&quot;UKish&quot;) &amp;lt;&amp;lt; QLocale(&quot;en_GB&quot;);
    QTest::newRow(&quot;USAish&quot;) &amp;lt;&amp;lt; QLocale(QLocale::English, QLocale::UnitedStates);
}

void TestQLocale::roundTripInt_data()
{
    QTest::addColumn&amp;lt;int&amp;gt;(&quot;number&quot;);
    QTest::newRow(&quot;zero&quot;) &amp;lt;&amp;lt; 0;
    QTest::newRow(&quot;one&quot;) &amp;lt;&amp;lt; 1;
    QTest::newRow(&quot;two&quot;) &amp;lt;&amp;lt; 2;
    QTest::newRow(&quot;ten&quot;) &amp;lt;&amp;lt; 10;
}
</db:programlisting>
<db:para>The test's own data is a single number per row. In this case, <db:code>initTestCase_data()</db:code> also supplies a locale per row. Therefore, this test will be run with every combination of locale from the latter and number from the former. Thus, with four rows in the global table and three in the local, the test function is run for 12 distinct test-cases (4 * 3 = 12).</db:para>
<db:programlisting language="cpp">void TestQLocale::roundTripInt()
{
    QFETCH_GLOBAL(QLocale, locale);
    QFETCH(int, number);
    bool ok;
    QCOMPARE(locale.toInt(locale.toString(number), &amp;amp;ok), number);
    QVERIFY(ok);
}
</db:programlisting>
<db:para>The locale is read from the global data table using QFETCH_GLOBAL(), and the number is read from the local data table using <db:link xlink:href="qtest.xml#QFETCH">QFETCH</db:link>().</db:para>
<db:note>
<db:para>This macro can only be used in test methods of a class with an <db:code>initTestCase_data()</db:code> method.</db:para>
</db:note>
</db:section>
<db:section xml:id="QFINDTESTDATA">
<db:title>QFINDTESTDATA(<db:emphasis>filename</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QFINDTESTDATA</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>filename</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QFINDTESTDATA(filename)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qstring.xml">QString</db:link> for the testdata file referred to by <db:code role="parameter">filename</db:code>, or an empty <db:link xlink:href="qstring.xml">QString</db:link> if the testdata file could not be found.</db:para>
<db:para>This macro allows the test to load data from an external file without hardcoding an absolute filename into the test, or using relative paths which may be error prone.</db:para>
<db:para>The returned path will be the first path from the following list which resolves to an existing file or directory:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code role="parameter">filename</db:code> relative to <db:link xlink:href="qcoreapplication.xml#applicationDirPath">QCoreApplication::applicationDirPath</db:link>() (only if a <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link> or <db:link xlink:href="qapplication.xml">QApplication</db:link> object has been created).</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code role="parameter">filename</db:code> relative to the test's standard install directory (<db:link xlink:href="qlibraryinfo.xml#LibraryPath-enum">QLibraryInfo::TestsPath</db:link> with the lowercased testcase name appended).</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code role="parameter">filename</db:code> relative to the directory containing the source file from which QFINDTESTDATA is invoked.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>If the named file/directory does not exist at any of these locations, a warning is printed to the test log.</db:para>
<db:para>For example, in this code:</db:para>
<db:programlisting language="cpp">bool tst_MyXmlParser::parse()
{
    MyXmlParser parser;
    QString input = QFINDTESTDATA(&quot;testxml/simple1.xml&quot;);
    QVERIFY(parser.parse(input));
}
</db:programlisting>
<db:para>The testdata file will be resolved as the first existing file from:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>/home/user/build/myxmlparser/tests/tst_myxmlparser/testxml/simple1.xml</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>/usr/local/Qt-5.0.0/tests/tst_myxmlparser/testxml/simple1.xml</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>/home/user/sources/myxmlparser/tests/tst_myxmlparser/testxml/simple1.xml</db:code></db:para>
</db:listitem>
</db:itemizedlist>
<db:para>This allows the test to find its testdata regardless of whether the test has been installed, and regardless of whether the test's build tree is equal to the test's source tree.</db:para>
<db:note>
<db:para>reliable detection of testdata from the source directory requires either that qmake is used, or the <db:code>QT_TESTCASE_BUILDDIR</db:code> macro is defined to point to the working directory from which the compiler is invoked, or only absolute paths to the source files are passed to the compiler. Otherwise, the absolute path of the source directory cannot be determined.</db:para>
</db:note>
<db:note>
<db:para>The <db:code>QT_TESTCASE_BUILDDIR</db:code> macro is also implicitly defined if CMake is used and the <db:link xlink:href="qttest-module.xml">QtTest</db:link> module is linked to the target. You can change the default <db:code>QT_TESTCASE_BUILDDIR</db:code> by setting the QT_TESTCASE_BUILDDIR property on the target.</db:para>
</db:note>
<db:note>
<db:para>For tests that use the <db:link xlink:href="qtest.xml#QTEST_APPLESS_MAIN">QTEST_APPLESS_MAIN</db:link>() macro to generate a <db:code>main()</db:code> function, <db:code>QFINDTESTDATA</db:code> will not attempt to find test data relative to <db:link xlink:href="qcoreapplication.xml#applicationDirPath">QCoreApplication::applicationDirPath</db:link>(). In practice, this means that tests using <db:code>QTEST_APPLESS_MAIN()</db:code> will fail to find their test data if run from a shadow build tree.</db:para>
</db:note>
</db:section>
<db:section xml:id="QSKIP">
<db:title>QSKIP(<db:emphasis>description</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QSKIP</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>description</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QSKIP(description)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If called from a test function, the QSKIP() macro stops execution of the test without adding a failure to the test log. You can use it to skip tests that wouldn't make sense in the current configuration. For example, a test of font rendering may call QSKIP() if the needed fonts are not installed on the test system.</db:para>
<db:para>The text <db:code role="parameter">description</db:code> is appended to the test log and should contain an explanation of why the test couldn't be executed.</db:para>
<db:para>If the test is data-driven, each call to QSKIP() in the test function will skip only the current row of test data, so an unconditional call to QSKIP() will produce one skip message in the test log for each row of test data.</db:para>
<db:para>If called from an <db:code>_data</db:code> function, the QSKIP() macro will stop execution of the <db:code>_data</db:code> function and will prevent execution of the associated test function. This entirely omits a data-driven test. To omit individual rows, make them conditional by using a simple <db:code>if (condition) newRow(...) &lt;&lt; ...</db:code> in the <db:code>_data</db:code> function, instead of using QSKIP() in the test function.</db:para>
<db:para>If called from <db:code>initTestCase_data()</db:code>, the QSKIP() macro will skip all test and <db:code>_data</db:code> functions. If called from <db:code>initTestCase()</db:code> when there is no <db:code>initTestCase_data()</db:code>, or when it only sets up one row, QSKIP() will likewise skip the whole test. However, if <db:code>initTestCase_data()</db:code> contains more than one row, then <db:code>initTestCase()</db:code> is called (followed by each test and finally the wrap-up) once per row of it. Therefore, a call to QSKIP() in <db:code>initTestCase()</db:code> will merely skip all test functions for the current row of global data, set up by <db:code>initTestCase_data()</db:code>.</db:para>
<db:note>
<db:para>This macro can only be used in a test function or <db:code>_data</db:code> function that is invoked by the test framework.</db:para>
</db:note>
<db:para>Example:</db:para>
<db:programlisting language="cpp">if (!QSqlDatabase::drivers().contains(&quot;SQLITE&quot;))
    QSKIP(&quot;This test requires the SQLITE database driver&quot;);
</db:programlisting>
<db:section xml:id="skipping-known-bugs">
<db:title>Skipping Known Bugs</db:title>
<db:para>If a test exposes a known bug that will not be fixed immediately, use the <db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>() macro to document the failure and reference the bug tracking identifier for the known issue. When the test is run, expected failures will be marked as XFAIL in the test output and will not be counted as failures when setting the test program's return code. If an expected failure does not occur, the XPASS (unexpected pass) will be reported in the test output and will be counted as a test failure.</db:para>
<db:para>For known bugs, <db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>() is better than QSKIP() because a developer cannot fix the bug without an XPASS result reminding them that the test needs to be updated too. If QSKIP() is used, there is no reminder to revise or re-enable the test, without which subsequent regressions will not be reported.</db:para>
</db:section>
<db:section>
<db:title>Notes</db:title>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>()</db:member>
<db:member><db:link xlink:href="qttest-best-practices-qdoc.xml#select-appropriate-mechanisms-to-exclude-tests">Select Appropriate Mechanisms to Exclude Tests</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTEST">
<db:title>QTEST(<db:emphasis>actual</db:emphasis>, <db:emphasis>testElement</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTEST</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>actual</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>testElement</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTEST(actual, testElement)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>QTEST() is a convenience macro for <db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>() that compares the value <db:code role="parameter">actual</db:code> with the element <db:code role="parameter">testElement</db:code> from the test's data. If there is no such element, the test asserts.</db:para>
<db:para>Apart from that, QTEST() behaves exactly as <db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>().</db:para>
<db:para>Instead of writing:</db:para>
<db:programlisting language="cpp">QFETCH(QString, myString);
QCOMPARE(QString(&quot;hello&quot;).toUpper(), myString);
</db:programlisting>
<db:para>you can write:</db:para>
<db:programlisting language="cpp">QTEST(QString(&quot;hello&quot;).toUpper(), &quot;myString&quot;);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTEST_APPLESS_MAIN">
<db:title>QTEST_APPLESS_MAIN(<db:emphasis>TestClass</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTEST_APPLESS_MAIN</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>TestClass</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTEST_APPLESS_MAIN(TestClass)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Implements a main() function that executes all tests in <db:code role="parameter">TestClass</db:code>.</db:para>
<db:para>Behaves like <db:link xlink:href="qtest.xml#QTEST_MAIN">QTEST_MAIN</db:link>(), but doesn't instantiate a <db:link xlink:href="qapplication.xml">QApplication</db:link> object. Use this macro for really simple stand-alone non-GUI tests.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QTEST_MAIN">QTEST_MAIN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTEST_GUILESS_MAIN">
<db:title>QTEST_GUILESS_MAIN(<db:emphasis>TestClass</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTEST_GUILESS_MAIN</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>TestClass</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTEST_GUILESS_MAIN(TestClass)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Implements a main() function that instantiates a <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link> object and the <db:code role="parameter">TestClass</db:code>, and executes all tests in the order they were defined. Use this macro to build stand-alone executables.</db:para>
<db:para>Behaves like <db:link xlink:href="qtest.xml#QTEST_MAIN">QTEST_MAIN</db:link>(), but instantiates a <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link> instead of the <db:link xlink:href="qapplication.xml">QApplication</db:link> object. Use this macro if your test case doesn't need functionality offered by <db:link xlink:href="qapplication.xml">QApplication</db:link>, but the event loop is still necessary.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QTEST_MAIN">QTEST_MAIN</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTEST_MAIN">
<db:title>QTEST_MAIN(<db:emphasis>TestClass</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTEST_MAIN</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>TestClass</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTEST_MAIN(TestClass)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Implements a main() function that instantiates an application object and the <db:code role="parameter">TestClass</db:code>, and executes all tests in the order they were defined. Use this macro to build stand-alone executables.</db:para>
<db:para>If <db:code>QT_WIDGETS_LIB</db:code> is defined, the application object will be a <db:link xlink:href="qapplication.xml">QApplication</db:link>, if <db:code>QT_GUI_LIB</db:code> is defined, the application object will be a <db:link xlink:href="qguiapplication.xml">QGuiApplication</db:link>, otherwise it will be a <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link>. If qmake is used and the configuration includes <db:code>QT += widgets</db:code>, then <db:code>QT_WIDGETS_LIB</db:code> will be defined automatically. Similarly, if qmake is used and the configuration includes <db:code>QT += gui</db:code>, then <db:code>QT_GUI_LIB</db:code> will be defined automatically.</db:para>
<db:note>
<db:para>On platforms that have keypad navigation enabled by default, this macro will forcefully disable it if <db:code>QT_WIDGETS_LIB</db:code> is defined. This is done to simplify the usage of key events when writing autotests. If you wish to write a test case that uses keypad navigation, you should enable it either in the <db:code>initTestCase()</db:code> or <db:code>init()</db:code> functions of your test case by calling <db:link xlink:href="qapplication.xml#setNavigationMode">QApplication::setNavigationMode</db:link>().</db:para>
</db:note>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QTEST_MAIN(TestQString)
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QTEST_APPLESS_MAIN">QTEST_APPLESS_MAIN</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTEST_GUILESS_MAIN">QTEST_GUILESS_MAIN</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#qExec">QTest::qExec</db:link>()</db:member>
<db:member><db:link xlink:href="qapplication.xml#setNavigationMode">QApplication::setNavigationMode</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE">
<db:title>QTRY_COMPARE(<db:emphasis>actual</db:emphasis>, <db:emphasis>expected</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>actual</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>expected</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE(actual, expected)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Performs a comparison of the <db:code role="parameter">actual</db:code> and <db:code role="parameter">expected</db:code> values by invoking <db:link xlink:href="qtest.xml#QTRY_COMPARE_WITH_TIMEOUT">QTRY_COMPARE_WITH_TIMEOUT</db:link>() with a timeout of five seconds.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_WITH_TIMEOUT">QTRY_COMPARE_WITH_TIMEOUT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_VERIFY">QTRY_VERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_EQ">
<db:title>[since 6.4] QTRY_COMPARE_EQ(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_EQ</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_EQ(left, right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Performs comparison of <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> values by invoking <db:link xlink:href="qtest.xml#QTRY_COMPARE_EQ_WITH_TIMEOUT">QTRY_COMPARE_EQ_WITH_TIMEOUT</db:link> with a timeout of five seconds.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_EQ">QCOMPARE_EQ</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_EQ_WITH_TIMEOUT">QTRY_COMPARE_EQ_WITH_TIMEOUT</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_EQ_WITH_TIMEOUT">
<db:title>[since 6.4] QTRY_COMPARE_EQ_WITH_TIMEOUT(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>, <db:emphasis>timeout</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_EQ_WITH_TIMEOUT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>timeout</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_EQ_WITH_TIMEOUT(left, right, timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is similar to <db:link xlink:href="qtest.xml#QCOMPARE_EQ">QCOMPARE_EQ</db:link>(), but performs the comparison of the <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> values repeatedly, until either the comparison returns <db:code>true</db:code> or the <db:code role="parameter">timeout</db:code> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_EQ">QCOMPARE_EQ</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_EQ">QTRY_COMPARE_EQ</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_GE">
<db:title>[since 6.4] QTRY_COMPARE_GE(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_GE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_GE(left, right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Performs comparison of <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> values by invoking <db:link xlink:href="qtest.xml#QTRY_COMPARE_GE_WITH_TIMEOUT">QTRY_COMPARE_GE_WITH_TIMEOUT</db:link> with a timeout of five seconds.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GE">QCOMPARE_GE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_GE_WITH_TIMEOUT">QTRY_COMPARE_GE_WITH_TIMEOUT</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_GE_WITH_TIMEOUT">
<db:title>[since 6.4] QTRY_COMPARE_GE_WITH_TIMEOUT(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>, <db:emphasis>timeout</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_GE_WITH_TIMEOUT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>timeout</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_GE_WITH_TIMEOUT(left, right, timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is similar to <db:link xlink:href="qtest.xml#QCOMPARE_GE">QCOMPARE_GE</db:link>(), but performs the comparison of the <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> values repeatedly, until either the comparison returns <db:code>true</db:code> or the <db:code role="parameter">timeout</db:code> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GE">QCOMPARE_GE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_GE">QTRY_COMPARE_GE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_GT">
<db:title>[since 6.4] QTRY_COMPARE_GT(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_GT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_GT(left, right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Performs comparison of <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> values by invoking <db:link xlink:href="qtest.xml#QTRY_COMPARE_GT_WITH_TIMEOUT">QTRY_COMPARE_GT_WITH_TIMEOUT</db:link> with a timeout of five seconds.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GT">QCOMPARE_GT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_GT_WITH_TIMEOUT">QTRY_COMPARE_GT_WITH_TIMEOUT</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_GT_WITH_TIMEOUT">
<db:title>[since 6.4] QTRY_COMPARE_GT_WITH_TIMEOUT(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>, <db:emphasis>timeout</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_GT_WITH_TIMEOUT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>timeout</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_GT_WITH_TIMEOUT(left, right, timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is similar to <db:link xlink:href="qtest.xml#QCOMPARE_GT">QCOMPARE_GT</db:link>(), but performs the comparison of the <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> values repeatedly, until either the comparison returns <db:code>true</db:code> or the <db:code role="parameter">timeout</db:code> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GT">QCOMPARE_GT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_GT">QTRY_COMPARE_GT</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_LE">
<db:title>[since 6.4] QTRY_COMPARE_LE(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_LE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_LE(left, right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Performs comparison of <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> values by invoking <db:link xlink:href="qtest.xml#QTRY_COMPARE_LE_WITH_TIMEOUT">QTRY_COMPARE_LE_WITH_TIMEOUT</db:link> with a timeout of five seconds.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LE">QCOMPARE_LE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_LE_WITH_TIMEOUT">QTRY_COMPARE_LE_WITH_TIMEOUT</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_LE_WITH_TIMEOUT">
<db:title>[since 6.4] QTRY_COMPARE_LE_WITH_TIMEOUT(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>, <db:emphasis>timeout</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_LE_WITH_TIMEOUT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>timeout</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_LE_WITH_TIMEOUT(left, right, timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is similar to <db:link xlink:href="qtest.xml#QCOMPARE_LE">QCOMPARE_LE</db:link>(), but performs the comparison of the <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> values repeatedly, until either the comparison returns <db:code>true</db:code> or the <db:code role="parameter">timeout</db:code> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LE">QCOMPARE_LE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_LE">QTRY_COMPARE_LE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_LT">
<db:title>[since 6.4] QTRY_COMPARE_LT(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_LT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_LT(left, right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Performs comparison of <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> values by invoking <db:link xlink:href="qtest.xml#QTRY_COMPARE_LT_WITH_TIMEOUT">QTRY_COMPARE_LT_WITH_TIMEOUT</db:link> with a timeout of five seconds.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LT">QCOMPARE_LT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_LT_WITH_TIMEOUT">QTRY_COMPARE_LT_WITH_TIMEOUT</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_LT_WITH_TIMEOUT">
<db:title>[since 6.4] QTRY_COMPARE_LT_WITH_TIMEOUT(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>, <db:emphasis>timeout</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_LT_WITH_TIMEOUT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>timeout</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_LT_WITH_TIMEOUT(left, right, timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is similar to <db:link xlink:href="qtest.xml#QCOMPARE_LT">QCOMPARE_LT</db:link>(), but performs the comparison of the <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> values repeatedly, until either the comparison returns <db:code>true</db:code> or the <db:code role="parameter">timeout</db:code> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LT">QCOMPARE_LT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_LT">QTRY_COMPARE_LT</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_NE">
<db:title>[since 6.4] QTRY_COMPARE_NE(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_NE</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_NE(left, right)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Performs comparison of <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> values by invoking <db:link xlink:href="qtest.xml#QTRY_COMPARE_NE_WITH_TIMEOUT">QTRY_COMPARE_NE_WITH_TIMEOUT</db:link> with a timeout of five seconds.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_NE">QCOMPARE_NE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_NE_WITH_TIMEOUT">QTRY_COMPARE_NE_WITH_TIMEOUT</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_NE_WITH_TIMEOUT">
<db:title>[since 6.4] QTRY_COMPARE_NE_WITH_TIMEOUT(<db:emphasis>left</db:emphasis>, <db:emphasis>right</db:emphasis>, <db:emphasis>timeout</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_NE_WITH_TIMEOUT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>left</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>right</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>timeout</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_NE_WITH_TIMEOUT(left, right, timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is similar to <db:link xlink:href="qtest.xml#QCOMPARE_NE">QCOMPARE_NE</db:link>(), but performs the comparison of the <db:code role="parameter">left</db:code> and <db:code role="parameter">right</db:code> values repeatedly, until either the comparison returns <db:code>true</db:code> or the <db:code role="parameter">timeout</db:code> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_NE">QCOMPARE_NE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE_NE">QTRY_COMPARE_NE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_COMPARE_WITH_TIMEOUT">
<db:title>QTRY_COMPARE_WITH_TIMEOUT(<db:emphasis>actual</db:emphasis>, <db:emphasis>expected</db:emphasis>, <db:emphasis>timeout</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_COMPARE_WITH_TIMEOUT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>actual</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>expected</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>timeout</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_COMPARE_WITH_TIMEOUT(actual, expected, timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QTRY_COMPARE_WITH_TIMEOUT() macro is similar to <db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>(), but performs the comparison of the <db:code role="parameter">actual</db:code> and <db:code role="parameter">expected</db:code> values repeatedly, until either the two values are equal or the <db:code role="parameter">timeout</db:code> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE">QTRY_COMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_VERIFY">QTRY_VERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_VERIFY2">
<db:title>QTRY_VERIFY2(<db:emphasis>condition</db:emphasis>, <db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_VERIFY2</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>condition</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_VERIFY2(condition, message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Checks the <db:code role="parameter">condition</db:code> by invoking <db:link xlink:href="qtest.xml#QTRY_VERIFY2_WITH_TIMEOUT">QTRY_VERIFY2_WITH_TIMEOUT</db:link>() with a timeout of five seconds. If <db:code role="parameter">condition</db:code> is then still false, <db:code role="parameter">message</db:code> is output. The <db:code role="parameter">message</db:code> is a plain C string.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QTRY_VERIFY2_WITH_TIMEOUT(list.size() &amp;gt; 2, QByteArray::number(list.size()).constData());
</db:programlisting>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QTRY_VERIFY2_WITH_TIMEOUT">QTRY_VERIFY2_WITH_TIMEOUT</db:link>()</db:member>
<db:member><db:link xlink:href="">QTRY_VERIFY2</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE">QTRY_COMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_VERIFY">
<db:title>QTRY_VERIFY(<db:emphasis>condition</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_VERIFY</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>condition</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_VERIFY(condition)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Checks the <db:code role="parameter">condition</db:code> by invoking <db:link xlink:href="qtest.xml#QTRY_VERIFY_WITH_TIMEOUT">QTRY_VERIFY_WITH_TIMEOUT</db:link>() with a timeout of five seconds.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QTRY_VERIFY_WITH_TIMEOUT">QTRY_VERIFY_WITH_TIMEOUT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_VERIFY2">QTRY_VERIFY2</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE">QTRY_COMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_VERIFY2_WITH_TIMEOUT">
<db:title>QTRY_VERIFY2_WITH_TIMEOUT(<db:emphasis>condition</db:emphasis>, <db:emphasis>message</db:emphasis>, <db:emphasis>timeout</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_VERIFY2_WITH_TIMEOUT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>condition</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>timeout</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_VERIFY2_WITH_TIMEOUT(condition, message, timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QTRY_VERIFY2_WITH_TIMEOUT macro is similar to <db:link xlink:href="qtest.xml#QTRY_VERIFY_WITH_TIMEOUT">QTRY_VERIFY_WITH_TIMEOUT</db:link>() except that it outputs a verbose <db:code role="parameter">message</db:code> when <db:code role="parameter">condition</db:code> is still false after the specified <db:code role="parameter">timeout</db:code> (in milliseconds). The <db:code role="parameter">message</db:code> is a plain C string.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QTRY_VERIFY2_WITH_TIMEOUT(list.size() &amp;gt; 2, QByteArray::number(list.size()).constData(), 10000);
</db:programlisting>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QTRY_VERIFY">QTRY_VERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_VERIFY_WITH_TIMEOUT">QTRY_VERIFY_WITH_TIMEOUT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE">QTRY_COMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QTRY_VERIFY_WITH_TIMEOUT">
<db:title>QTRY_VERIFY_WITH_TIMEOUT(<db:emphasis>condition</db:emphasis>, <db:emphasis>timeout</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QTRY_VERIFY_WITH_TIMEOUT</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>condition</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>timeout</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QTRY_VERIFY_WITH_TIMEOUT(condition, timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QTRY_VERIFY_WITH_TIMEOUT() macro is similar to <db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>(), but checks the <db:code role="parameter">condition</db:code> repeatedly, until either the condition becomes true or the <db:code role="parameter">timeout</db:code> (in milliseconds) is reached. Between each evaluation, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QTRY_VERIFY">QTRY_VERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_VERIFY2_WITH_TIMEOUT">QTRY_VERIFY2_WITH_TIMEOUT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_COMPARE">QTRY_COMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVERIFY2">
<db:title>QVERIFY2(<db:emphasis>condition</db:emphasis>, <db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QVERIFY2</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>condition</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QVERIFY2(condition, message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QVERIFY2() macro behaves exactly like <db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>(), except that it reports a <db:code role="parameter">message</db:code> when <db:code role="parameter">condition</db:code> is false. The <db:code role="parameter">message</db:code> is a plain C string.</db:para>
<db:para>The message can also be obtained from a function call that produces a plain C string, such as <db:link xlink:href="qstring.xml#qPrintable">qPrintable</db:link>() applied to a <db:link xlink:href="qstring.xml">QString</db:link>, which may be built in any of its usual ways, including applying <db:code>.args()</db:code> to format some data.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QVERIFY2(QFileInfo(&quot;file.txt&quot;).exists(), &quot;file.txt does not exist.&quot;);
</db:programlisting>
<db:para>For example, if you have a file object and you are testing its <db:code>open()</db:code> function, you might write a test with a statement like:</db:para>
<db:programlisting language="cpp">bool opened = file.open(QIODevice::WriteOnly);
QVERIFY(opened);
</db:programlisting>
<db:para>If this test fails, it will give no clue as to why the file failed to open:</db:para>
<db:para><db:code>FAIL! : tst_QFile::open_write() 'opened' returned FALSE. ()</db:code></db:para>
<db:para>If there is a more informative error message you could construct from the values being tested, you can use <db:code>QVERIFY2()</db:code> to pass that message along with your test condition, to provide a more informative message on failure:</db:para>
<db:programlisting language="cpp">QVERIFY2(file.open(QIODevice::WriteOnly),
         qPrintable(QString(&quot;open %1: %2&quot;)
                    .arg(file.fileName()).arg(file.errorString())));
</db:programlisting>
<db:para>If this branch is being tested in the Qt CI system, the above detailed failure message will be inserted into the summary posted to the code-review system:</db:para>
<db:para><db:code>FAIL! : tst_QFile::open_write() 'opened' returned FALSE. (open /tmp/qt.a3B42Cd: No space left on device)</db:code></db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QVERIFY">QVERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_EQ">QCOMPARE_EQ</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_NE">QCOMPARE_NE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LT">QCOMPARE_LT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LE">QCOMPARE_LE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GT">QCOMPARE_GT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GE">QCOMPARE_GE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVERIFY">
<db:title>QVERIFY(<db:emphasis>condition</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QVERIFY</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>condition</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QVERIFY(condition)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QVERIFY() macro checks whether the <db:code role="parameter">condition</db:code> is true or not. If it is true, execution continues. If not, a failure is recorded in the test log and the test won't be executed further.</db:para>
<db:para>You can use <db:link xlink:href="qtest.xml#QVERIFY2">QVERIFY2</db:link>() when it is practical and valuable to put additional information into the test failure report.</db:para>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework. For example, the following code shows this macro being used to verify that a <db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link> object is valid:</db:para>
</db:note>
<db:programlisting language="cpp">QVERIFY(spy.isValid());
</db:programlisting>
<db:para>For more information about the failure, use <db:code>QCOMPARE(x, y)</db:code> instead of <db:code>QVERIFY(x == y)</db:code>, because it reports both the expected and actual value when the comparison fails.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtest.xml#QCOMPARE">QCOMPARE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QTRY_VERIFY">QTRY_VERIFY</db:link>()</db:member>
<db:member><db:link xlink:href="qsignalspy.xml">QSignalSpy</db:link></db:member>
<db:member><db:link xlink:href="qtest.xml#QEXPECT_FAIL">QEXPECT_FAIL</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_EQ">QCOMPARE_EQ</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_NE">QCOMPARE_NE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LT">QCOMPARE_LT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_LE">QCOMPARE_LE</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GT">QCOMPARE_GT</db:link>()</db:member>
<db:member><db:link xlink:href="qtest.xml#QCOMPARE_GE">QCOMPARE_GE</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QVERIFY_THROWS_EXCEPTION">
<db:title>[since 6.3] QVERIFY_THROWS_EXCEPTION(<db:emphasis>exceptiontype</db:emphasis>, <db:emphasis>...</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QVERIFY_THROWS_EXCEPTION</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>exceptiontype</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>...</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QVERIFY_THROWS_EXCEPTION(exceptiontype, ...)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QVERIFY_THROWS_EXCEPTION macro executes the expression given in the variadic argument and expects to catch an exception thrown from the expression.</db:para>
<db:para>There are several possible outcomes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If the expression throws an exception that is either the same as <db:code role="parameter">exceptiontype</db:code> or derived from <db:code role="parameter">exceptiontype</db:code>, then execution will continue.</db:para>
</db:listitem>
<db:listitem>
<db:para>Otherwise, if the expression throws no exception, or the exception thrown derives from <db:code>std::exception</db:code>, then a failure will be recorded in the test log and the macro returns early (from enclosing function).</db:para>
</db:listitem>
<db:listitem>
<db:para>If the thrown exception derives neither from <db:code>std::exception</db:code> nor from <db:code role="parameter">exceptiontype</db:code>, a failure will be recorded in the test log, and the exception is re-thrown. This avoids problems with e.g. pthread cancellation exceptions.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The macro uses variadic arguments so the expression can contain commas that the preprocessor considers argument separators, e.g. as in</db:para>
<db:programlisting language="cpp">QVERIFY_THROWS_EXCEPTION(std::bad_alloc,
// macro arguments:      ^ exceptiontype
                         std::vector&amp;lt;std::pair&amp;lt;int, long&amp;gt;&amp;gt;{42'000'000'000, {42, 42L}});
// macro arguments:      \---------- 1 ----------/  \-------- 2 --------/  \3/  \ 4 /
//                       \----------------------- expression -----------------------/
</db:programlisting>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.3.</db:para>
</db:section>
<db:section xml:id="QVERIFY_THROWS_NO_EXCEPTION">
<db:title>[since 6.3] QVERIFY_THROWS_NO_EXCEPTION(<db:emphasis>...</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QVERIFY_THROWS_NO_EXCEPTION</db:methodname>
<db:methodparam>
<db:type>...</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QVERIFY_THROWS_NO_EXCEPTION(...)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>The QVERIFY_THROWS_NO_EXCEPTION macro executes the expression given in its variadic argument and tries to catch any exception thrown from the expression.</db:para>
<db:para>There are several different outcomes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>If the expression does not throw an exception, then execution will continue.</db:para>
</db:listitem>
<db:listitem>
<db:para>Otherwise, if an exception derived from <db:code>std::exception</db:code> is caught, a failure will be recorded in the test log and the macro returns early (implicit return from enclosing function).</db:para>
</db:listitem>
<db:listitem>
<db:para>If an exception not derived from <db:code>std::exception</db:code> is caught, a failure will be recorded in the test log and the exception will be re-thrown. This avoids problems with e.g. pthread cancellation exceptions.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The macro uses variadic arguments so the expression can contain commas that the preprocessor considers argument separators, e.g. as in</db:para>
<db:programlisting language="cpp">QVERIFY_THROWS_NO_EXCEPTION(std::pair&amp;lt;int, long&amp;gt;{42, 42L});
// macro arguments:         \---- 1 ----/  \-- 2 -/  \3 /
</db:programlisting>
<db:note>
<db:para>This macro can only be used in a test function that is invoked by the test framework.</db:para>
</db:note>
<db:para>This macro was introduced in Qt 6.3.</db:para>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QTest</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qtest.xml">QTest</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-macro-documentation">
<db:title>Obsolete Macro Documentation</db:title>
<db:section xml:id="QVERIFY_EXCEPTION_THROWN">
<db:title>QVERIFY_EXCEPTION_THROWN(<db:emphasis>expression</db:emphasis>, <db:emphasis>exceptiontype</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QVERIFY_EXCEPTION_THROWN</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>expression</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type></db:type>
<db:parameter>exceptiontype</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QVERIFY_EXCEPTION_THROWN(expression, exceptiontype)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is deprecated since 6.3. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:code>QVERIFY_THROWS_EXCEPTION(exceptiontype, expression)</db:code> instead.</db:para>
</db:section>
<db:section xml:id="QWARN">
<db:title>QWARN(<db:emphasis>message</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:methodname>QWARN</db:methodname>
<db:methodparam>
<db:type></db:type>
<db:parameter>message</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">macrowithparams</db:synopsisinfo>
<db:synopsisinfo role="signature">QWARN(message)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">thread safe</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This macro is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Use <db:link xlink:href="qtlogging.xml#qWarning">qWarning</db:link>() instead.</db:para>
<db:para>Appends <db:code role="parameter">message</db:code> as a warning to the test log. This macro can be used anywhere in your tests.</db:para>
<db:note>
<db:para>This macro is <db:link xlink:href="threads-reentrancy.xml">thread-safe</db:link>.</db:para>
</db:note>
</db:section>
</db:section>
</db:section>
</db:article>
