<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Textured Surface Example</db:title>
<db:productname>QtDataVisualization</db:productname>
<db:edition>Qt Data Visualization | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Using texture with <db:link xlink:href="q3dsurface.xml">Q3DSurface</db:link>.</db:para>
<db:para>This documentation was introduced in QtDataVisualization 1.2.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The textured surface example shows how to add an image as a texture for a surface. The example shows also how to:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Create a surface series from an image</db:para>
</db:listitem>
<db:listitem>
<db:para>Use custom input handler to enable zooming and panning</db:para>
</db:listitem>
<db:listitem>
<db:para>Highlight an area of the surface</db:para>
</db:listitem>
</db:itemizedlist>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/texturesurface-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="http://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:emphasis role="bold">Welcome</db:emphasis> mode and select the example from <db:emphasis role="bold">Examples</db:emphasis>. For more information, visit <db:link xlink:href="http://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="texture-to-a-surface-series">
<db:title>Texture to a Surface Series</db:title>
<db:para>The image to be set as a texture to a surface can be set using <db:link xlink:href="qsurface3dseries.xml#textureFile-prop">QSurface3DSeries::setTextureFile</db:link>(). In this example we have added a check box to control if the texture is set or not. The following code extract is for reacting to the check box selections. The image in this example is read from the resource file where it is as a JPG file. Setting an empty file with the method clears the texture, and the surface uses the gradients or colors from the theme.</db:para>
<db:programlisting language="cpp">void SurfaceGraph::toggleSurfaceTexture(bool enable)
{
    if (enable)
        m_topography-&amp;gt;setTextureFile(&quot;:/maps/maptexture&quot;);
    else
        m_topography-&amp;gt;setTextureFile(&quot;&quot;);
}
</db:programlisting>
</db:section>
<db:section xml:id="topographic-surface-series">
<db:title>Topographic Surface Series</db:title>
<db:para>The topographic data for this example is obtained from National Land Survey of Finland. It provides a product called <db:code>Elevation Model 2 m</db:code>, which was suitable for our needs. We selected Levi fell to be shown. The accuracy of the data was well beyond our needs and therefore it is compressed and encoded into a PNG file. The height value from the original ASCII data is encoded into RGB format using a multiplier, which you will see later on a code extract. The multiplier is calculated simply by dividing the largest 24 bit value with the highest point in Finland.</db:para>
<db:para>Qt Data Visualization has a special proxy for height map image files, but it converts only one byte values. So to utilize the bigger accuracy on the data from National Land Survey of Finland, we read the data from the PNG file and decode it into <db:link xlink:href="qsurface3dseries.xml">QSurface3DSeries</db:link>. The following code samples show how this is done.</db:para>
<db:para>First the encoding multiplier.</db:para>
<db:programlisting language="cpp">// Value used to encode height data as RGB value on PNG file
const float packingFactor = 11983.0f;
</db:programlisting>
<db:para>And then the actual decoding.</db:para>
<db:programlisting language="cpp">    QImage heightMapImage(file);
    uchar *bits = heightMapImage.bits();
    int imageHeight = heightMapImage.height();
    int imageWidth = heightMapImage.width();
    int widthBits = imageWidth * 4;
    float stepX = width / float(imageWidth);
    float stepZ = height / float(imageHeight);

    QSurfaceDataArray *dataArray = new QSurfaceDataArray;
    dataArray-&amp;gt;reserve(imageHeight);
    for (int i = 0; i &amp;lt; imageHeight; i++) {
        int p = i * widthBits;
        float z = height - float(i) * stepZ;
        QSurfaceDataRow *newRow = new QSurfaceDataRow(imageWidth);
        for (int j = 0; j &amp;lt; imageWidth; j++) {
            uchar aa = bits[p + 0];
            uchar rr = bits[p + 1];
            uchar gg = bits[p + 2];
            uint color = uint((gg &amp;lt;&amp;lt; 16) + (rr &amp;lt;&amp;lt; 8) + aa);
            float y = float(color) / packingFactor;
            (*newRow)[j].setPosition(QVector3D(float(j) * stepX, y, z));
            p = p + 4;
        }
        *dataArray &amp;lt;&amp;lt; newRow;
    }

    dataProxy()-&amp;gt;resetArray(dataArray);
</db:programlisting>
</db:section>
<db:section xml:id="use-custom-input-handler-to-enable-zooming-and-panning">
<db:title>Use Custom Input Handler to Enable Zooming and Panning</db:title>
<db:para>For the panning the implementation is similar to the <db:link xlink:href="qtdatavisualization-draggableaxes-example.xml">Axis Range Dragging With Labels Example</db:link>. The difference is that in this example we follow only dragging of X and Z axis and we don't allow dragging the surface outside the graph. The control for this is very simple and done as on the following example for the X axis.</db:para>
<db:programlisting language="cpp">    case StateDraggingX:
        distance = (move.x() * xMulX - move.y() * xMulY) * m_speedModifier;
        m_axisXMinValue -= distance;
        m_axisXMaxValue -= distance;
        if (m_axisXMinValue &amp;lt; m_areaMinValue) {
            float dist = m_axisXMaxValue - m_axisXMinValue;
            m_axisXMinValue = m_areaMinValue;
            m_axisXMaxValue = m_axisXMinValue + dist;
        }
        if (m_axisXMaxValue &amp;gt; m_areaMaxValue) {
            float dist = m_axisXMaxValue - m_axisXMinValue;
            m_axisXMaxValue = m_areaMaxValue;
            m_axisXMinValue = m_axisXMaxValue - dist;
        }
        m_axisX-&amp;gt;setRange(m_axisXMinValue, m_axisXMaxValue);
        break;
</db:programlisting>
<db:para>For the zooming we catch the <db:code>wheelEvent</db:code> and adjust the X and Y axis ranges according to delta value on <db:link xlink:href="qwheelevent.xml">QWheelEvent</db:link>. The Y axis is also adjusted so that the aspect ratio between Y axis and XZ plane stays the same, and we don't get silly looking graph with height exaggerated too much.</db:para>
<db:programlisting language="cpp">void CustomInputHandler::wheelEvent(QWheelEvent *event)
{
    float delta = float(event-&amp;gt;delta());

    m_axisXMinValue += delta;
    m_axisXMaxValue -= delta;
    m_axisZMinValue += delta;
    m_axisZMaxValue -= delta;
    checkConstraints();

    float y = (m_axisXMaxValue - m_axisXMinValue) * m_aspectRatio;

    m_axisX-&amp;gt;setRange(m_axisXMinValue, m_axisXMaxValue);
    m_axisY-&amp;gt;setRange(100.0f, y);
    m_axisZ-&amp;gt;setRange(m_axisZMinValue, m_axisZMaxValue);
}
</db:programlisting>
<db:para>In this case we want to control the zoom level so that it won't get too near to or far from the surface. For instance, if the value for the X axis gets below the allowed, i.e. zooming gets too far, the value is set to the minimum allowed value. If the range is going to below the range minimum, both ends of the axis are adjusted so that the range stays at the limit.</db:para>
<db:programlisting language="cpp">    if (m_axisXMinValue &amp;lt; m_areaMinValue)
        m_axisXMinValue = m_areaMinValue;
    if (m_axisXMaxValue &amp;gt; m_areaMaxValue)
        m_axisXMaxValue = m_areaMaxValue;
    // Don't allow too much zoom in
    if ((m_axisXMaxValue - m_axisXMinValue) &amp;lt; m_axisXMinRange) {
        float adjust = (m_axisXMinRange - (m_axisXMaxValue - m_axisXMinValue)) / 2.0f;
        m_axisXMinValue -= adjust;
        m_axisXMaxValue += adjust;
    }
</db:programlisting>
</db:section>
<db:section xml:id="highlight-an-area-of-the-surface">
<db:title>Highlight an Area of the Surface</db:title>
<db:para>The main idea on creating a highlight on the surface is to create a copy of the series and add a bit of offset to the y value. On this example the class <db:code>HighlightSeries</db:code> implements the creation of the copy on its <db:code>handlePositionChange</db:code> method. Firstly the <db:code>HighlightSeries</db:code> needs to get the pointer to the original series and then it starts to listen the <db:link xlink:href="qsurface3dseries.xml#selectedPoint-prop">QSurface3DSeries::selectedPointChanged</db:link> signal.</db:para>
<db:programlisting language="cpp">void HighlightSeries::setTopographicSeries(TopographicSeries *series)
{
    m_topographicSeries = series;
    m_srcWidth = m_topographicSeries-&amp;gt;dataProxy()-&amp;gt;array()-&amp;gt;at(0)-&amp;gt;size();
    m_srcHeight = m_topographicSeries-&amp;gt;dataProxy()-&amp;gt;array()-&amp;gt;size();

    QObject::connect(m_topographicSeries, &amp;amp;QSurface3DSeries::selectedPointChanged,
                     this, &amp;amp;HighlightSeries::handlePositionChange);
}
</db:programlisting>
<db:para>When the signal arrives, first thing is to check that the position is valid. Then the ranges for the copied area are calculated and checked that they stay within the bounds. Finally we simply fill the data array of the highlight series with the range from the data array of topography series.</db:para>
<db:programlisting language="cpp">void HighlightSeries::handlePositionChange(const QPoint &amp;amp;position)
{
    m_position = position;

    if (position == invalidSelectionPosition()) {
        setVisible(false);

        return;
    }

    int halfWidth = m_width / 2;
    int halfHeight = m_height / 2;

    int startX = position.y() - halfWidth;
    if (startX &amp;lt; 0 )
        startX = 0;
    int endX = position.y() + halfWidth;
    if (endX &amp;gt; (m_srcWidth - 1))
        endX = m_srcWidth - 1;
    int startZ = position.x() - halfHeight;
    if (startZ &amp;lt; 0 )
        startZ = 0;
    int endZ = position.x() + halfHeight;
    if (endZ &amp;gt; (m_srcHeight - 1))
        endZ = m_srcHeight - 1;

    QSurfaceDataProxy *srcProxy = m_topographicSeries-&amp;gt;dataProxy();
    const QSurfaceDataArray &amp;amp;srcArray = *srcProxy-&amp;gt;array();

    QSurfaceDataArray *dataArray = new QSurfaceDataArray;
    dataArray-&amp;gt;reserve(endZ - startZ);
    for (int i = startZ; i &amp;lt; endZ; i++) {
        QSurfaceDataRow *newRow = new QSurfaceDataRow(endX - startX);
        QSurfaceDataRow *srcRow = srcArray.at(i);
        for (int j = startX, p = 0; j &amp;lt; endX; j++, p++) {
            QVector3D pos = srcRow-&amp;gt;at(j).position();
            (*newRow)[p].setPosition(QVector3D(pos.x(), pos.y() + 0.1f, pos.z()));
        }
        *dataArray &amp;lt;&amp;lt; newRow;
    }

    dataProxy()-&amp;gt;resetArray(dataArray);
    setVisible(true);
}
</db:programlisting>
</db:section>
<db:section xml:id="a-gradient-to-the-highlight-series">
<db:title>A Gradient to the Highlight Series</db:title>
<db:para>Since the <db:code>HighlightSeries</db:code> is <db:link xlink:href="qsurface3dseries.xml">QSurface3DSeries</db:link>, we can use all the decoration methods series can have. In this example we added a gradient to emphasize the elevation. Because the suitable gradient style depends on the range of the Y axis and we change the range when zooming, we need to adjust the gradient color positions as the range change.</db:para>
<db:para>For the gradient color positions we define proportional values.</db:para>
<db:programlisting language="cpp">const float darkRedPos = 1.0f;
const float redPos = 0.8f;
const float yellowPos = 0.6f;
const float greenPos = 0.4f;
const float darkGreenPos = 0.2f;
</db:programlisting>
<db:para>The gradient modification is done on <db:code>handleGradientChange</db:code> method and we connect it to react to changes on Y axis.</db:para>
<db:programlisting language="cpp">    QObject::connect(m_graph-&amp;gt;axisY(), &amp;amp;QValue3DAxis::maxChanged,
                     m_highlight, &amp;amp;HighlightSeries::handleGradientChange);
</db:programlisting>
<db:para>When a change on Y axis max value happens, we calculate the gradient color positions.</db:para>
<db:programlisting language="cpp">void HighlightSeries::handleGradientChange(float value)
{
    float ratio = m_minHeight / value;

    QLinearGradient gr;
    gr.setColorAt(0.0f, Qt::black);
    gr.setColorAt(darkGreenPos * ratio, Qt::darkGreen);
    gr.setColorAt(greenPos * ratio, Qt::green);
    gr.setColorAt(yellowPos * ratio, Qt::yellow);
    gr.setColorAt(redPos * ratio, Qt::red);
    gr.setColorAt(darkRedPos * ratio, Qt::darkRed);

    setBaseGradient(gr);
    setColorStyle(Q3DTheme::ColorStyleRangeGradient);
}
</db:programlisting>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/custominputhandler.cpp">texturesurface/custominputhandler.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/custominputhandler.h">texturesurface/custominputhandler.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/highlightseries.cpp">texturesurface/highlightseries.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/highlightseries.h">texturesurface/highlightseries.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/main.cpp">texturesurface/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/surfacegraph.cpp">texturesurface/surfacegraph.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/surfacegraph.h">texturesurface/surfacegraph.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/texturedsurface.qrc">texturesurface/texturedsurface.qrc</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/texturesurface.pro">texturesurface/texturesurface.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/topographicseries.cpp">texturesurface/topographicseries.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/topographicseries.h">texturesurface/topographicseries.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Images:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/maptexture.jpg">texturesurface/maptexture.jpg</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="texturesurface/topography.png">texturesurface/topography.png</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:section></db:article>
