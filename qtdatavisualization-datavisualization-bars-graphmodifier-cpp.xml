<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Bars Example</db:title>
<db:productname>QtDataVisualization</db:productname>
<db:edition>Qt Data Visualization | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Using <db:link xlink:href="q3dbars.xml">Q3DBars</db:link> in a widget application.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the Qt Data Visualization module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:GPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3 or (at your option) any later version
** approved by the KDE Free Qt Foundation. The licenses are as published by
** the Free Software Foundation and appearing in the file LICENSE.GPL3
** included in the packaging of this file. Please review the following
** information to ensure the GNU General Public License requirements will
** be met: https://www.gnu.org/licenses/gpl-3.0.html.
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;graphmodifier.h&quot;
#include &amp;lt;QtDataVisualization/qcategory3daxis.h&amp;gt;
#include &amp;lt;QtDataVisualization/qvalue3daxis.h&amp;gt;
#include &amp;lt;QtDataVisualization/qbardataproxy.h&amp;gt;
#include &amp;lt;QtDataVisualization/q3dscene.h&amp;gt;
#include &amp;lt;QtDataVisualization/q3dcamera.h&amp;gt;
#include &amp;lt;QtDataVisualization/qbar3dseries.h&amp;gt;
#include &amp;lt;QtDataVisualization/q3dtheme.h&amp;gt;
#include &amp;lt;QtCore/QTime&amp;gt;
#include &amp;lt;QtWidgets/QComboBox&amp;gt;
#include &amp;lt;QtCore/qmath.h&amp;gt;

using namespace QtDataVisualization;

const QString celsiusString = QString(QChar(0xB0)) + &quot;C&quot;;

GraphModifier::GraphModifier(Q3DBars *bargraph)
    : m_graph(bargraph),
      m_xRotation(0.0f),
      m_yRotation(0.0f),
      m_fontSize(30),
      m_segments(4),
      m_subSegments(3),
      m_minval(-20.0f),
      m_maxval(20.0f),
      m_temperatureAxis(new QValue3DAxis),
      m_yearAxis(new QCategory3DAxis),
      m_monthAxis(new QCategory3DAxis),
      m_primarySeries(new QBar3DSeries),
      m_secondarySeries(new QBar3DSeries),
      m_barMesh(QAbstract3DSeries::MeshBevelBar),
      m_smooth(false)
{
    m_graph-&amp;gt;setShadowQuality(QAbstract3DGraph::ShadowQualitySoftMedium);
    m_graph-&amp;gt;activeTheme()-&amp;gt;setBackgroundEnabled(false);
    m_graph-&amp;gt;activeTheme()-&amp;gt;setFont(QFont(&quot;Times New Roman&quot;, m_fontSize));
    m_graph-&amp;gt;activeTheme()-&amp;gt;setLabelBackgroundEnabled(true);
    m_graph-&amp;gt;setMultiSeriesUniform(true);

    m_months &amp;lt;&amp;lt; &quot;January&quot; &amp;lt;&amp;lt; &quot;February&quot; &amp;lt;&amp;lt; &quot;March&quot; &amp;lt;&amp;lt; &quot;April&quot; &amp;lt;&amp;lt; &quot;May&quot; &amp;lt;&amp;lt; &quot;June&quot; &amp;lt;&amp;lt; &quot;July&quot; &amp;lt;&amp;lt; &quot;August&quot; &amp;lt;&amp;lt; &quot;September&quot; &amp;lt;&amp;lt; &quot;October&quot; &amp;lt;&amp;lt; &quot;November&quot; &amp;lt;&amp;lt; &quot;December&quot;;
    m_years &amp;lt;&amp;lt; &quot;2006&quot; &amp;lt;&amp;lt; &quot;2007&quot; &amp;lt;&amp;lt; &quot;2008&quot; &amp;lt;&amp;lt; &quot;2009&quot; &amp;lt;&amp;lt; &quot;2010&quot; &amp;lt;&amp;lt; &quot;2011&quot; &amp;lt;&amp;lt; &quot;2012&quot; &amp;lt;&amp;lt; &quot;2013&quot;;

    m_temperatureAxis-&amp;gt;setTitle(&quot;Average temperature&quot;);
    m_temperatureAxis-&amp;gt;setSegmentCount(m_segments);
    m_temperatureAxis-&amp;gt;setSubSegmentCount(m_subSegments);
    m_temperatureAxis-&amp;gt;setRange(m_minval, m_maxval);
    m_temperatureAxis-&amp;gt;setLabelFormat(QString(QStringLiteral(&quot;%.1f &quot;) + celsiusString));
    m_temperatureAxis-&amp;gt;setLabelAutoRotation(30.0f);
    m_temperatureAxis-&amp;gt;setTitleVisible(true);

    m_yearAxis-&amp;gt;setTitle(&quot;Year&quot;);
    m_yearAxis-&amp;gt;setLabelAutoRotation(30.0f);
    m_yearAxis-&amp;gt;setTitleVisible(true);
    m_monthAxis-&amp;gt;setTitle(&quot;Month&quot;);
    m_monthAxis-&amp;gt;setLabelAutoRotation(30.0f);
    m_monthAxis-&amp;gt;setTitleVisible(true);

    m_graph-&amp;gt;setValueAxis(m_temperatureAxis);
    m_graph-&amp;gt;setRowAxis(m_yearAxis);
    m_graph-&amp;gt;setColumnAxis(m_monthAxis);

    m_primarySeries-&amp;gt;setItemLabelFormat(QStringLiteral(&quot;Oulu - @colLabel @rowLabel: @valueLabel&quot;));
    m_primarySeries-&amp;gt;setMesh(QAbstract3DSeries::MeshBevelBar);
    m_primarySeries-&amp;gt;setMeshSmooth(false);

    m_secondarySeries-&amp;gt;setItemLabelFormat(QStringLiteral(&quot;Helsinki - @colLabel @rowLabel: @valueLabel&quot;));
    m_secondarySeries-&amp;gt;setMesh(QAbstract3DSeries::MeshBevelBar);
    m_secondarySeries-&amp;gt;setMeshSmooth(false);
    m_secondarySeries-&amp;gt;setVisible(false);

    m_graph-&amp;gt;addSeries(m_primarySeries);
    m_graph-&amp;gt;addSeries(m_secondarySeries);

    changePresetCamera();

    resetTemperatureData();

    // Set up property animations for zooming to the selected bar
    Q3DCamera *camera = m_graph-&amp;gt;scene()-&amp;gt;activeCamera();
    m_defaultAngleX = camera-&amp;gt;xRotation();
    m_defaultAngleY = camera-&amp;gt;yRotation();
    m_defaultZoom = camera-&amp;gt;zoomLevel();
    m_defaultTarget = camera-&amp;gt;target();

    m_animationCameraX.setTargetObject(camera);
    m_animationCameraY.setTargetObject(camera);
    m_animationCameraZoom.setTargetObject(camera);
    m_animationCameraTarget.setTargetObject(camera);

    m_animationCameraX.setPropertyName(&quot;xRotation&quot;);
    m_animationCameraY.setPropertyName(&quot;yRotation&quot;);
    m_animationCameraZoom.setPropertyName(&quot;zoomLevel&quot;);
    m_animationCameraTarget.setPropertyName(&quot;target&quot;);

    int duration = 1700;
    m_animationCameraX.setDuration(duration);
    m_animationCameraY.setDuration(duration);
    m_animationCameraZoom.setDuration(duration);
    m_animationCameraTarget.setDuration(duration);

    // The zoom always first zooms out above the graph and then zooms in
    qreal zoomOutFraction = 0.3;
    m_animationCameraX.setKeyValueAt(zoomOutFraction, QVariant::fromValue(0.0f));
    m_animationCameraY.setKeyValueAt(zoomOutFraction, QVariant::fromValue(90.0f));
    m_animationCameraZoom.setKeyValueAt(zoomOutFraction, QVariant::fromValue(50.0f));
    m_animationCameraTarget.setKeyValueAt(zoomOutFraction,
                                          QVariant::fromValue(QVector3D(0.0f, 0.0f, 0.0f)));
}

GraphModifier::~GraphModifier()
{
    delete m_graph;
}

void GraphModifier::resetTemperatureData()
{
    // Set up data
    static const float tempOulu[8][12] = {
        {-6.7f, -11.7f, -9.7f, 3.3f, 9.2f, 14.0f, 16.3f, 17.8f, 10.2f, 2.1f, -2.6f, -0.3f},    // 2006
        {-6.8f, -13.3f, 0.2f, 1.5f, 7.9f, 13.4f, 16.1f, 15.5f, 8.2f, 5.4f, -2.6f, -0.8f},      // 2007
        {-4.2f, -4.0f, -4.6f, 1.9f, 7.3f, 12.5f, 15.0f, 12.8f, 7.6f, 5.1f, -0.9f, -1.3f},      // 2008
        {-7.8f, -8.8f, -4.2f, 0.7f, 9.3f, 13.2f, 15.8f, 15.5f, 11.2f, 0.6f, 0.7f, -8.4f},      // 2009
        {-14.4f, -12.1f, -7.0f, 2.3f, 11.0f, 12.6f, 18.8f, 13.8f, 9.4f, 3.9f, -5.6f, -13.0f},  // 2010
        {-9.0f, -15.2f, -3.8f, 2.6f, 8.3f, 15.9f, 18.6f, 14.9f, 11.1f, 5.3f, 1.8f, -0.2f},     // 2011
        {-8.7f, -11.3f, -2.3f, 0.4f, 7.5f, 12.2f, 16.4f, 14.1f, 9.2f, 3.1f, 0.3f, -12.1f},     // 2012
        {-7.9f, -5.3f, -9.1f, 0.8f, 11.6f, 16.6f, 15.9f, 15.5f, 11.2f, 4.0f, 0.1f, -1.9f}      // 2013
    };

    static const float tempHelsinki[8][12] = {
        {-3.7f, -7.8f, -5.4f, 3.4f, 10.7f, 15.4f, 18.6f, 18.7f, 14.3f, 8.5f, 2.9f, 4.1f},      // 2006
        {-1.2f, -7.5f, 3.1f, 5.5f, 10.3f, 15.9f, 17.4f, 17.9f, 11.2f, 7.3f, 1.1f, 0.5f},       // 2007
        {-0.6f, 1.2f, 0.2f, 6.3f, 10.2f, 13.8f, 18.1f, 15.1f, 10.1f, 9.4f, 2.5f, 0.4f},        // 2008
        {-2.9f, -3.5f, -0.9f, 4.7f, 10.9f, 14.0f, 17.4f, 16.8f, 13.2f, 4.1f, 2.6f, -2.3f},     // 2009
        {-10.2f, -8.0f, -1.9f, 6.6f, 11.3f, 14.5f, 21.0f, 18.8f, 12.6f, 6.1f, -0.5f, -7.3f},   // 2010
        {-4.4f, -9.1f, -2.0f, 5.5f, 9.9f, 15.6f, 20.8f, 17.8f, 13.4f, 8.9f, 3.6f, 1.5f},       // 2011
        {-3.5f, -3.2f, -0.7f, 4.0f, 11.1f, 13.4f, 17.3f, 15.8f, 13.1f, 6.4f, 4.1f, -5.1f},     // 2012
        {-4.8f, -1.8f, -5.0f, 2.9f, 12.8f, 17.2f, 18.0f, 17.1f, 12.5f, 7.5f, 4.5f, 2.3f}       // 2013
    };

    // Create data arrays
    QBarDataArray *dataSet = new QBarDataArray;
    QBarDataArray *dataSet2 = new QBarDataArray;
    QBarDataRow *dataRow;
    QBarDataRow *dataRow2;

    dataSet-&amp;gt;reserve(m_years.size());
    for (int year = 0; year &amp;lt; m_years.size(); year++) {
        // Create a data row
        dataRow = new QBarDataRow(m_months.size());
        dataRow2 = new QBarDataRow(m_months.size());
        for (int month = 0; month &amp;lt; m_months.size(); month++) {
            // Add data to the row
            (*dataRow)[month].setValue(tempOulu[year][month]);
            (*dataRow2)[month].setValue(tempHelsinki[year][month]);
        }
        // Add the row to the set
        dataSet-&amp;gt;append(dataRow);
        dataSet2-&amp;gt;append(dataRow2);
    }

    // Add data to the data proxy (the data proxy assumes ownership of it)
    m_primarySeries-&amp;gt;dataProxy()-&amp;gt;resetArray(dataSet, m_years, m_months);
    m_secondarySeries-&amp;gt;dataProxy()-&amp;gt;resetArray(dataSet2, m_years, m_months);
}

void GraphModifier::changeRange(int range)
{
    if (range &amp;gt;= m_years.count())
        m_yearAxis-&amp;gt;setRange(0, m_years.count() - 1);
    else
        m_yearAxis-&amp;gt;setRange(range, range);
}

void GraphModifier::changeStyle(int style)
{
    QComboBox *comboBox = qobject_cast&amp;lt;QComboBox *&amp;gt;(sender());
    if (comboBox) {
        m_barMesh = QAbstract3DSeries::Mesh(comboBox-&amp;gt;itemData(style).toInt());
        m_primarySeries-&amp;gt;setMesh(m_barMesh);
        m_secondarySeries-&amp;gt;setMesh(m_barMesh);
    }
}

void GraphModifier::changePresetCamera()
{
    m_animationCameraX.stop();
    m_animationCameraY.stop();
    m_animationCameraZoom.stop();
    m_animationCameraTarget.stop();

    // Restore camera target in case animation has changed it
    m_graph-&amp;gt;scene()-&amp;gt;activeCamera()-&amp;gt;setTarget(QVector3D(0.0f, 0.0f, 0.0f));

    static int preset = Q3DCamera::CameraPresetFront;

    m_graph-&amp;gt;scene()-&amp;gt;activeCamera()-&amp;gt;setCameraPreset((Q3DCamera::CameraPreset)preset);

    if (++preset &amp;gt; Q3DCamera::CameraPresetDirectlyBelow)
        preset = Q3DCamera::CameraPresetFrontLow;
}

void GraphModifier::changeTheme(int theme)
{
    Q3DTheme *currentTheme = m_graph-&amp;gt;activeTheme();
    currentTheme-&amp;gt;setType(Q3DTheme::Theme(theme));
    emit backgroundEnabledChanged(currentTheme-&amp;gt;isBackgroundEnabled());
    emit gridEnabledChanged(currentTheme-&amp;gt;isGridEnabled());
    emit fontChanged(currentTheme-&amp;gt;font());
    emit fontSizeChanged(currentTheme-&amp;gt;font().pointSize());
}

void GraphModifier::changeLabelBackground()
{
    m_graph-&amp;gt;activeTheme()-&amp;gt;setLabelBackgroundEnabled(!m_graph-&amp;gt;activeTheme()-&amp;gt;isLabelBackgroundEnabled());
}

void GraphModifier::changeSelectionMode(int selectionMode)
{
    QComboBox *comboBox = qobject_cast&amp;lt;QComboBox *&amp;gt;(sender());
    if (comboBox) {
        int flags = comboBox-&amp;gt;itemData(selectionMode).toInt();
        m_graph-&amp;gt;setSelectionMode(QAbstract3DGraph::SelectionFlags(flags));
    }
}

void GraphModifier::changeFont(const QFont &amp;amp;font)
{
    QFont newFont = font;
    m_graph-&amp;gt;activeTheme()-&amp;gt;setFont(newFont);
}

void GraphModifier::changeFontSize(int fontsize)
{
    m_fontSize = fontsize;
    QFont font = m_graph-&amp;gt;activeTheme()-&amp;gt;font();
    font.setPointSize(m_fontSize);
    m_graph-&amp;gt;activeTheme()-&amp;gt;setFont(font);
}

void GraphModifier::shadowQualityUpdatedByVisual(QAbstract3DGraph::ShadowQuality sq)
{
    int quality = int(sq);
    // Updates the UI component to show correct shadow quality
    emit shadowQualityChanged(quality);
}

void GraphModifier::changeLabelRotation(int rotation)
{
    m_temperatureAxis-&amp;gt;setLabelAutoRotation(float(rotation));
    m_monthAxis-&amp;gt;setLabelAutoRotation(float(rotation));
    m_yearAxis-&amp;gt;setLabelAutoRotation(float(rotation));
}

void GraphModifier::setAxisTitleVisibility(bool enabled)
{
    m_temperatureAxis-&amp;gt;setTitleVisible(enabled);
    m_monthAxis-&amp;gt;setTitleVisible(enabled);
    m_yearAxis-&amp;gt;setTitleVisible(enabled);
}

void GraphModifier::setAxisTitleFixed(bool enabled)
{
    m_temperatureAxis-&amp;gt;setTitleFixed(enabled);
    m_monthAxis-&amp;gt;setTitleFixed(enabled);
    m_yearAxis-&amp;gt;setTitleFixed(enabled);
}

void GraphModifier::zoomToSelectedBar()
{
    m_animationCameraX.stop();
    m_animationCameraY.stop();
    m_animationCameraZoom.stop();
    m_animationCameraTarget.stop();

    Q3DCamera *camera = m_graph-&amp;gt;scene()-&amp;gt;activeCamera();
    float currentX = camera-&amp;gt;xRotation();
    float currentY = camera-&amp;gt;yRotation();
    float currentZoom = camera-&amp;gt;zoomLevel();
    QVector3D currentTarget = camera-&amp;gt;target();

    m_animationCameraX.setStartValue(QVariant::fromValue(currentX));
    m_animationCameraY.setStartValue(QVariant::fromValue(currentY));
    m_animationCameraZoom.setStartValue(QVariant::fromValue(currentZoom));
    m_animationCameraTarget.setStartValue(QVariant::fromValue(currentTarget));

    QPoint selectedBar = m_graph-&amp;gt;selectedSeries()
            ? m_graph-&amp;gt;selectedSeries()-&amp;gt;selectedBar()
            : QBar3DSeries::invalidSelectionPosition();

    if (selectedBar != QBar3DSeries::invalidSelectionPosition()) {
        // Normalize selected bar position within axis range to determine target coordinates
        QVector3D endTarget;
        float xMin = m_graph-&amp;gt;columnAxis()-&amp;gt;min();
        float xRange = m_graph-&amp;gt;columnAxis()-&amp;gt;max() - xMin;
        float zMin = m_graph-&amp;gt;rowAxis()-&amp;gt;min();
        float zRange = m_graph-&amp;gt;rowAxis()-&amp;gt;max() - zMin;
        endTarget.setX((selectedBar.y() - xMin) / xRange * 2.0f - 1.0f);
        endTarget.setZ((selectedBar.x() - zMin) / zRange * 2.0f - 1.0f);

        // Rotate the camera so that it always points approximately to the graph center
        qreal endAngleX = 90.0 - qRadiansToDegrees(qAtan(qreal(endTarget.z() / endTarget.x())));
        if (endTarget.x() &amp;gt; 0.0f)
            endAngleX -= 180.0f;
        float barValue = m_graph-&amp;gt;selectedSeries()-&amp;gt;dataProxy()-&amp;gt;itemAt(selectedBar.x(),
                                                                        selectedBar.y())-&amp;gt;value();
        float endAngleY = barValue &amp;gt;= 0.0f ? 30.0f : -30.0f;
        if (m_graph-&amp;gt;valueAxis()-&amp;gt;reversed())
            endAngleY *= -1.0f;

        m_animationCameraX.setEndValue(QVariant::fromValue(float(endAngleX)));
        m_animationCameraY.setEndValue(QVariant::fromValue(endAngleY));
        m_animationCameraZoom.setEndValue(QVariant::fromValue(250));
        m_animationCameraTarget.setEndValue(QVariant::fromValue(endTarget));
    } else {
        // No selected bar, so return to the default view
        m_animationCameraX.setEndValue(QVariant::fromValue(m_defaultAngleX));
        m_animationCameraY.setEndValue(QVariant::fromValue(m_defaultAngleY));
        m_animationCameraZoom.setEndValue(QVariant::fromValue(m_defaultZoom));
        m_animationCameraTarget.setEndValue(QVariant::fromValue(m_defaultTarget));
    }

    m_animationCameraX.start();
    m_animationCameraY.start();
    m_animationCameraZoom.start();
    m_animationCameraTarget.start();
}

void GraphModifier::changeShadowQuality(int quality)
{
    QAbstract3DGraph::ShadowQuality sq = QAbstract3DGraph::ShadowQuality(quality);
    m_graph-&amp;gt;setShadowQuality(sq);
    emit shadowQualityChanged(quality);
}

void GraphModifier::rotateX(int rotation)
{
    m_xRotation = rotation;
    m_graph-&amp;gt;scene()-&amp;gt;activeCamera()-&amp;gt;setCameraPosition(m_xRotation, m_yRotation);
}

void GraphModifier::rotateY(int rotation)
{
    m_yRotation = rotation;
    m_graph-&amp;gt;scene()-&amp;gt;activeCamera()-&amp;gt;setCameraPosition(m_xRotation, m_yRotation);
}

void GraphModifier::setBackgroundEnabled(int enabled)
{
    m_graph-&amp;gt;activeTheme()-&amp;gt;setBackgroundEnabled(bool(enabled));
}

void GraphModifier::setGridEnabled(int enabled)
{
    m_graph-&amp;gt;activeTheme()-&amp;gt;setGridEnabled(bool(enabled));
}

void GraphModifier::setSmoothBars(int smooth)
{
    m_smooth = bool(smooth);
    m_primarySeries-&amp;gt;setMeshSmooth(m_smooth);
    m_secondarySeries-&amp;gt;setMeshSmooth(m_smooth);
}

void GraphModifier::setSeriesVisibility(int enabled)
{
    m_secondarySeries-&amp;gt;setVisible(bool(enabled));
}

void GraphModifier::setReverseValueAxis(int enabled)
{
    m_graph-&amp;gt;valueAxis()-&amp;gt;setReversed(enabled);
}

void GraphModifier::setReflection(bool enabled)
{
    m_graph-&amp;gt;setReflection(enabled);
}

</db:programlisting>
</db:article>
