<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Remote Objects Source</db:title>
<db:productname>QtRemoteObjects</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Remote Objects Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Introduction to using Source <db:anchor xml:id="source"/>
.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="source-objects">
<db:title>Source Objects</db:title>
<db:para>A Remote Object Source is the <db:link xlink:href="qobject.xml">QObject</db:link> that is responsible for the implementation of the exposed API.</db:para>
<db:para>At a high level, you have a choice of using a <db:link xlink:href="qobject.xml">QObject</db:link> type directly as a source or defining the desired API in a .rep template for use with the <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link> compiler.</db:para>
<db:para>If you already have a fully defined <db:link xlink:href="qobject.xml">QObject</db:link>, it can become a Source simply by passing it to <db:link xlink:href="qremoteobjecthostbase.xml#enableRemoting">QRemoteObjectHostBase::enableRemoting</db:link>(). This lets other processes/devices create a <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link> of the object to interact with (see <db:link xlink:href="qtremoteobjects-interaction.xml#remote-object-interaction">Remote Object Interaction</db:link>). You can then instantiate <db:link xlink:href="qremoteobjectdynamicreplica.xml">QRemoteObjectDynamicReplica</db:link>s of your object.</db:para>
<db:para>Letting <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link> generate a <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> header file for your project (using the <db:link xlink:href="qtremoteobjects-repc.xml#repc-source">REPC_SOURCE</db:link> variable) provides three options for implementing the desired API. If your class name was Foo, the options would be the following (see <db:link xlink:href="qtremoteobjects-repc.xml#the-rep-file-format">The rep file format</db:link> for help in creating a rep file)</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qtremoteobjects-source.xml#typesimplesource">FooSimpleSource</db:link> inheritance</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtremoteobjects-source.xml#typesource">FooSource</db:link> inheritance</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qtremoteobjects-source.xml#typeapi">FooSourceAPI</db:link> usage with your own <db:link xlink:href="qobject.xml">QObject</db:link></db:para>
</db:listitem>
</db:itemizedlist>
<db:anchor xml:id="typesimplesource"/>
<db:para>There is a &lt;Type&gt;SimpleSource class defined in the header, which provides basic getter/setter methods for each property and implements data members of the correct property type in the header. Here &quot;&lt;Type&gt;&quot; represents the class name from the .rep file, so if your class is of type &quot;MyType&quot; in the .rep file, there will be a MyTypeSimpleSource class declared in the generated header file. This is a fast way to get started using the API. To use this class, you need to inherit from this class and implement any defined slots (which are pure virtual in the generated header file). Whatever logic is needed to manage the exposed properties and emit signals would be added to the inheriting class as well.</db:para>
<db:anchor xml:id="typesource"/>
<db:para>If you need to hide the implementation details, you can use the &lt;Type&gt;Source class instead, which is the 2nd class declared in the header file. This class definition does not provide data members, and makes the getter/setter functions pure virtual as well. You have more flexibility in how you implement the class, although you need to write more code.</db:para>
<db:anchor xml:id="typeapi"/>
<db:para>Finally, there is the &lt;Type&gt;SourceAPI class generated in the header. This is a templated class, for use specifically by the templated version of <db:link xlink:href="qremoteobjecthostbase.xml#enableRemoting">QRemoteObjectHostBase::enableRemoting</db:link>(), which allows you to use any <db:link xlink:href="qobject.xml">QObject</db:link> that supports the desired API as the source. You will get compile-time warnings if the class does not provide the correct API, and using this class allows you to hide or convert properties or signal/slot parameters.</db:para>
<db:note>
<db:para>The <db:link xlink:href="qobject.xml">QObject</db:link> API is <db:emphasis role="bold">never</db:emphasis> exposed. For instance, while a <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link> will have a destroyed signal, the destroyed signal of the source is not propagated. The <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> and each <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link> are unique QObjects with their own connections. The API that is exposed is defined by the .rep template used by <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link>, or in the case of raw QObjects, all API elements defined in the inheritance chain from a specific ancestor. Unless you define <db:link xlink:href="qobject.xml#Q_CLASSINFO">Q_CLASSINFO</db:link>(&quot;RemoteObject Type&quot;) in an ancestor, the <db:link xlink:href="qobject.xml">QObject</db:link>'s parent is used. If <db:link xlink:href="qobject.xml#Q_CLASSINFO">Q_CLASSINFO</db:link>(&quot;RemoteObject Type&quot;) is used, that class's API is the lowest level of API used.</db:para>
</db:note>
</db:section>
<db:section xml:id="identifying-sources">
<db:title>Identifying Sources</db:title>
<db:para>Since more than one <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> can be shared by a host node, each <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> requires a name. All <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link> generated headers include a way for the node to determine the class name (<db:link xlink:href="qobject.xml#Q_CLASSINFO">Q_CLASSINFO</db:link> for replica/simplesource/source types, or a static name() function for the SourceAPI type). If you pass your own <db:link xlink:href="qobject.xml">QObject</db:link> type to <db:link xlink:href="qremoteobjecthostbase.xml#enableRemoting">QRemoteObjectHostBase::enableRemoting</db:link>(), the name will be determined using the following logic:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>A name can optionally be passed to <db:link xlink:href="qremoteobjecthostbase.xml#enableRemoting">QRemoteObjectHostBase::enableRemoting</db:link>(). If provided, that name will be used.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the object or any of its ancestors has <db:link xlink:href="qobject.xml#Q_CLASSINFO">Q_CLASSINFO</db:link> of type &quot;RemoteObject Type&quot; defined, the defined type name will be used.</db:para>
</db:listitem>
<db:listitem>
<db:para>Otherwise, the <db:link xlink:href="qobject.xml">QObject</db:link>'s objectName (if set) will be used.</db:para>
</db:listitem>
<db:listitem>
<db:para>If none of the above are available, the call to <db:link xlink:href="qremoteobjecthostbase.xml#enableRemoting">QRemoteObjectHostBase::enableRemoting</db:link>() will fail, returning false.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:article>
