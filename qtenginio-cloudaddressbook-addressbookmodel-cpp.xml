<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Enginio C++ Examples - Cloud Address Book</db:title>
<db:productname>QtEnginio</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Client library for Enginio</db:titleabbrev>
<db:abstract>
<db:para>The Cloud Address Book demonstrates how to use sorting, filtering, and the full text search functionality.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2015 The Qt Company Ltd.
** Contact: http://www.qt.io/licensing/
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** You may use this file under the terms of the BSD license as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &lt;QtCore/qhash.h&gt;
#include &lt;QtCore/qbytearray.h&gt;
#include &lt;QtCore/qjsondocument.h&gt;
#include &lt;QtCore/qjsonvalue.h&gt;
#include &lt;QtCore/qjsonobject.h&gt;
#include &lt;QtCore/qjsonarray.h&gt;

#include &lt;QtGui/qfont.h&gt;

#include &quot;addressbookmodel.h&quot;

AddressBookModel::AddressBookModel(QObject *parent)
    : EnginioModel(parent)
    , _searchReply()
{}

AddressBookModel::~AddressBookModel()
{}

QVariant AddressBookModel::data(const QModelIndex &amp;index, int role) const
{
    if (role == Qt::DisplayRole) {
        // we assume here that column order is constant and it is the same as in AddressBookModel::Roles
        return EnginioModel::data(index, FirstNameRole + index.column()).value&lt;QJsonValue&gt;().toString();
    }
    if (role == Qt::FontRole) {
        // this role is used to mark items found in the full text search.
        QFont font;
        QString id = EnginioModel::data(index, Enginio::IdRole).value&lt;QString&gt;();
        font.setBold(_markedItems.contains(id));
        return font;
    }

    return EnginioModel::data(index, role);
}

bool AddressBookModel::setData(const QModelIndex &amp;index, const QVariant &amp;value, int role)
{
    bool result = role == Qt::EditRole
            ? EnginioModel::setData(this-&gt;index(index.row()), value, FirstNameRole + index.column())
            : EnginioModel::setData(this-&gt;index(index.row()), value, role);

    // if the data was edited, the marked items set may not be valid anymore
    // so we need to clear it.
    if (result)
        _markedItems.clear();
    return result;
}

int AddressBookModel::columnCount(const QModelIndex &amp;parent) const
{
    return parent.isValid() ? 0 : 5;
}

QVariant AddressBookModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (orientation == Qt::Horizontal &amp;&amp; role == Qt::DisplayRole) {
        switch (section) {
        case 0: return QStringLiteral(&quot;First name&quot;);
        case 1: return QStringLiteral(&quot;Last name&quot;);
        case 2: return QStringLiteral(&quot;Email&quot;);
        case 3: return QStringLiteral(&quot;Phone number&quot;);
        case 4: return QStringLiteral(&quot;Address&quot;);
        }
        return QVariant();
    }
    return EnginioModel::headerData(section, orientation, role);
}

QHash&lt;int, QByteArray&gt; AddressBookModel::roleNames() const
{
    QHash&lt;int, QByteArray&gt; roles = EnginioModel::roleNames();
    roles.insert(FirstNameRole, &quot;firstName&quot;);
    roles.insert(LastNameRole, &quot;lastName&quot;);
    roles.insert(EmailRole, &quot;email&quot;);
    roles.insert(PhoneRole, &quot;phone&quot;);
    roles.insert(AddressRole, &quot;address&quot;);
    return roles;
}

void AddressBookModel::newSearch(const QString &amp;search)
{
    if (search.isEmpty())
        return;

    // construct JSON object:
    //    {
    //        &quot;objectTypes&quot;: [&quot;objects.addressbook&quot;],
    //        &quot;search&quot;: { &quot;phrase&quot;: &quot;*PHRASE*&quot;,
    //            &quot;properties&quot;: [&quot;firstName&quot;, &quot;lastName&quot;, &quot;email&quot;, &quot;phone&quot;, &quot;address&quot;]
    //        }
    //    }

    QJsonObject query;
    {
        QJsonArray objectTypes;
        objectTypes.append(QString::fromUtf8(&quot;objects.addressbook&quot;));

        QJsonArray properties;
        properties.append(QString::fromUtf8(&quot;firstName&quot;));
        properties.append(QString::fromUtf8(&quot;lastName&quot;));
        properties.append(QString::fromUtf8(&quot;email&quot;));
        properties.append(QString::fromUtf8(&quot;phone&quot;));
        properties.append(QString::fromUtf8(&quot;address&quot;));

        QJsonObject searchQuery;
        searchQuery.insert(&quot;phrase&quot;, &quot;*&quot; + search + &quot;*&quot;);
        searchQuery.insert(&quot;properties&quot;, properties);

        query.insert(&quot;objectTypes&quot;, objectTypes);
        query.insert(&quot;search&quot;, searchQuery);
    }

    if (_searchReply) {
        // a new search is created before the old one was finished
        // we will not be interested in the results of the old search.
        _searchReply-&gt;disconnect(this);
    }

    _searchReply =  client()-&gt;fullTextSearch(query);
    QObject::connect(_searchReply, &amp;EnginioReply::finished, this, &amp;AddressBookModel::searchResultsArrived);
    QObject::connect(_searchReply, &amp;EnginioReply::finished, _searchReply, &amp;EnginioReply::deleteLater);
}

void AddressBookModel::searchResultsArrived()
{
    // clear old marks.
    _markedItems.clear();

    // update marked ids.
    QJsonArray results = _searchReply-&gt;data()[&quot;results&quot;].toArray();
    foreach (const QJsonValue &amp;value, results) {
        QJsonObject person = value.toObject();
        _markedItems.insert(person[&quot;id&quot;].toString());
    }

    QVector&lt;int&gt; roles;
    roles.append(Qt::FontRole);
    // We do not keep id -&gt; row mapping, therefore it is easier to emit
    // data change signal for all items, even if it is not optimal from
    // the performance point of view.
    emit dataChanged(index(0), index(rowCount() - 1, columnCount() - 1) , roles);

    _searchReply = 0;
    emit searchFinished();
}

</db:programlisting>
</db:article>
