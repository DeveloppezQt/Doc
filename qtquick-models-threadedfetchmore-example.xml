<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Models and Views: Fetch More functionality using a worker thread</db:title>
<db:productname>QtQuick</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Quick Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Demonstrates how to implement fetchMore() in a worker thread while maintaining a responsive UI.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/qml-threadedfetchmore-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>This example shows how to utilize <db:link xlink:href="qabstractitemmodel.xml#fetchMore">QAbstractItemModel::fetchMore</db:link>() with an object moved to a <db:link xlink:href="qthread.xml">QThread</db:link> so that the data fetching does not block the UI. On each call, the <db:code>FetchWorker</db:code> sleeps for 2 seconds, to simulate a slow backend service, before sending more data to the UI thread.</db:para>
<db:section xml:id="basic-functionality">
<db:title>Basic functionality</db:title>
<db:para>While data is being fetched in the worker thread, the model adds a BusyIndicator to the end of list. Once data is successfully fetched, the BusyIndicator is removed, and new items are appended to the list. The <db:link xlink:href="qml-qtquick-listview.xml">ListView</db:link> is used in the typical way, and does not need adjustment to deal with the slow model.</db:para>
</db:section>
<db:section xml:id="responsibilities">
<db:title>Responsibilities</db:title>
<db:para>The item model changes (in this case inserting and removing rows) must happen in the UI thread. The worker thread object slowly constructs DataBlock structs, and emits the <db:code>dataFetched</db:code> signal with a <db:link xlink:href="qlist.xml">QList</db:link> of data blocks as the payload; the signal is sent via a <db:link xlink:href="qt.xml#ConnectionType-enum">Qt::QueuedConnection</db:link> to the ThreadedFetchMoreModel::dataReceived() slot, which appends them to the data list in the UI thread. The UI thread adds a placeholder item to the end of the list before sending the fetchDataBlock() signal to the worker object to kick off the fetching process, and removes the placeholder before appending new items to the list.</db:para>
<db:para>After all available data is fetched, the worker thread object sends the <db:code>noMoreToFetch</db:code> signal to the model; from then on, the canFetchMore() method always returns <db:code>false</db:code>.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtdeclarative.git/tree/examples/quick/models/threadedfetchmore?h=6.9">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
