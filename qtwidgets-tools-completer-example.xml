<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Completer Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.4.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Completer example shows how to provide string-completion facilities for an input widget based on data provided by a model.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/completer-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>This example uses a custom item model, <db:code>FileSystemModel</db:code>, and a QCompleter object. QCompleter is a class that provides completions based on an item model. The type of model, the completion mode, and the case sensitivity can be selected using combo boxes.</db:para>
<db:section xml:id="the-resource-file">
<db:title>The Resource File</db:title>
<db:para>The Completer example requires a resource file in order to store the <db:emphasis>countries.txt</db:emphasis> and <db:emphasis>words.txt</db:emphasis>. The resource file contains the following code:</db:para>
<db:programlisting language="cpp">&lt;!DOCTYPE RCC&gt;&lt;RCC version=&quot;1.0&quot;&gt;
&lt;qresource prefix=&quot;/&quot;&gt;
   &lt;file&gt;resources/countries.txt&lt;/file&gt;
   &lt;file&gt;resources/wordlist.txt&lt;/file&gt;
&lt;/qresource&gt;
&lt;/RCC&gt;

</db:programlisting>
</db:section>
<db:section xml:id="filesystemmodel-class-definition">
<db:title>FileSystemModel Class Definition</db:title>
<db:para>The <db:code>FileSystemModel</db:code> class is a subclass of QFileSystemModel, which provides a data model for the local filesystem.</db:para>
<db:programlisting language="cpp">class FileSystemModel : public QFileSystemModel
{
public:
    FileSystemModel(QObject *parent = 0);
    QVariant data(const QModelIndex &amp;index, int role = Qt::DisplayRole) const Q_DECL_OVERRIDE;
};
</db:programlisting>
<db:para>This class only has a constructor and a <db:code>data()</db:code> function as it is only created to enable <db:code>data()</db:code> to return the entire file path for the display role, unlike QFileSystemModel's <db:code>data()</db:code> function that only returns the folder and not the drive label. This is further explained in <db:code>FileSystemModel</db:code>'s implementation.</db:para>
</db:section>
<db:section xml:id="filesystemmodel-class-implementation">
<db:title>FileSystemModel Class Implementation</db:title>
<db:para>The constructor for the <db:code>FileSystemModel</db:code> class is used to pass <db:code role="parameter">parent</db:code> to QFileSystemModel.</db:para>
<db:programlisting language="cpp">FileSystemModel::FileSystemModel(QObject *parent)
    : QFileSystemModel(parent)
{
}
</db:programlisting>
<db:para>As mentioned earlier, the <db:code>data()</db:code> function is reimplemented in order to get it to return the entire file parth for the display role. For example, with a QFileSystemModel, you will see &quot;Program Files&quot; in the view. However, with <db:code>FileSystemModel</db:code>, you will see &quot;C:\Program Files&quot;.</db:para>
<db:programlisting language="cpp">QVariant FileSystemModel::data(const QModelIndex &amp;index, int role) const
{
    if (role == Qt::DisplayRole &amp;&amp; index.column() == 0) {
        QString path  = QDir::toNativeSeparators(filePath(index));
        if (path.endsWith(QDir::separator()))
            path.chop(1);
        return path;
    }

    return QFileSystemModel::data(index, role);
}

</db:programlisting>
<db:para>The screenshots below illustrate this difference:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/completer-example-qdirmodel.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/completer-example-dirmodel.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:link xlink:href="qt.xml#ItemDataRole-enum">Qt::EditRole</db:link>, which QCompleter uses to look for matches, is left unchanged.</db:para>
</db:section>
<db:section xml:id="mainwindow-class-definition">
<db:title>MainWindow Class Definition</db:title>
<db:para>The <db:code>MainWindow</db:code> class is a subclass of QMainWindow and implements five private slots - <db:code>about()</db:code>, <db:code>changeCase()</db:code>, <db:code>changeMode()</db:code>, <db:code>changeModel()</db:code>, and <db:code>changeMaxVisible()</db:code>.</db:para>
<db:programlisting language="cpp">class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = 0);

private slots:
    void about();
    void changeCase(int);
    void changeMode(int);
    void changeModel();
    void changeMaxVisible(int);
</db:programlisting>
<db:para>Within the <db:code>MainWindow</db:code> class, we have two private functions: <db:code>createMenu()</db:code> and <db:code>modelFromFile()</db:code>. We also declare the private widgets needed - three QComboBox objects, a QCheckBox, a QCompleter, a QLabel, and a QLineEdit.</db:para>
<db:programlisting language="cpp">private:
    void createMenu();
    QAbstractItemModel *modelFromFile(const QString&amp; fileName);

    QComboBox *caseCombo;
    QComboBox *modeCombo;
    QComboBox *modelCombo;
    QSpinBox *maxVisibleSpinBox;
    QCheckBox *wrapCheckBox;
    QCompleter *completer;
    QLabel *contentsLabel;
    QLineEdit *lineEdit;
};
</db:programlisting>
</db:section>
<db:section xml:id="mainwindow-class-implementation">
<db:title>MainWindow Class Implementation</db:title>
<db:para>The constructor of <db:code>MainWindow</db:code> constructs a <db:code>MainWindow</db:code> with a parent widget and initializes the private members. The <db:code>createMenu()</db:code> function is then invoked.</db:para>
<db:para>We set up three QComboBox objects, <db:code>modelComb</db:code>, <db:code>modeCombo</db:code> and <db:code>caseCombo</db:code>. By default, the <db:code>modelCombo</db:code> is set to QFileSystemModel, the <db:code>modeCombo</db:code> is set to &quot;Filtered Popup&quot; and the <db:code>caseCombo</db:code> is set to &quot;Case Insensitive&quot;.</db:para>
<db:programlisting language="cpp">MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), completer(0), lineEdit(0)
{
    createMenu();

    QWidget *centralWidget = new QWidget;

    QLabel *modelLabel = new QLabel;
    modelLabel-&gt;setText(tr(&quot;Model&quot;));

    modelCombo = new QComboBox;
    modelCombo-&gt;addItem(tr(&quot;QFileSytemModel&quot;));
    modelCombo-&gt;addItem(tr(&quot;QFileSytemModel that shows full path&quot;));
    modelCombo-&gt;addItem(tr(&quot;Country list&quot;));
    modelCombo-&gt;addItem(tr(&quot;Word list&quot;));
    modelCombo-&gt;setCurrentIndex(0);

    QLabel *modeLabel = new QLabel;
    modeLabel-&gt;setText(tr(&quot;Completion Mode&quot;));
    modeCombo = new QComboBox;
    modeCombo-&gt;addItem(tr(&quot;Inline&quot;));
    modeCombo-&gt;addItem(tr(&quot;Filtered Popup&quot;));
    modeCombo-&gt;addItem(tr(&quot;Unfiltered Popup&quot;));
    modeCombo-&gt;setCurrentIndex(1);

    QLabel *caseLabel = new QLabel;
    caseLabel-&gt;setText(tr(&quot;Case Sensitivity&quot;));
    caseCombo = new QComboBox;
    caseCombo-&gt;addItem(tr(&quot;Case Insensitive&quot;));
    caseCombo-&gt;addItem(tr(&quot;Case Sensitive&quot;));
    caseCombo-&gt;setCurrentIndex(0);
</db:programlisting>
<db:para>The <db:code>maxVisibleSpinBox</db:code> is created and determines the number of visible item in the completer</db:para>
<db:para>The <db:code>wrapCheckBox</db:code> is then set up. This <db:code>checkBox</db:code> determines if the <db:code>completer</db:code>'s <db:link xlink:href="">setWrapAround()</db:link> property is enabled or disabled.</db:para>
<db:programlisting language="cpp">    QLabel *maxVisibleLabel = new QLabel;
    maxVisibleLabel-&gt;setText(tr(&quot;Max Visible Items&quot;));
    maxVisibleSpinBox = new QSpinBox;
    maxVisibleSpinBox-&gt;setRange(3,25);
    maxVisibleSpinBox-&gt;setValue(10);

    wrapCheckBox = new QCheckBox;
    wrapCheckBox-&gt;setText(tr(&quot;Wrap around completions&quot;));
    wrapCheckBox-&gt;setChecked(true);
</db:programlisting>
<db:para>We instantiate <db:code>contentsLabel</db:code> and set its size policy to fixed. The combo boxes' <db:link xlink:href="">activated()</db:link> signals are then connected to their respective slots.</db:para>
<db:programlisting language="cpp">    contentsLabel = new QLabel;
    contentsLabel-&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);

    connect(modelCombo, SIGNAL(activated(int)), this, SLOT(changeModel()));
    connect(modeCombo, SIGNAL(activated(int)), this, SLOT(changeMode(int)));
    connect(caseCombo, SIGNAL(activated(int)), this, SLOT(changeCase(int)));
    connect(maxVisibleSpinBox, SIGNAL(valueChanged(int)), this, SLOT(changeMaxVisible(int)));
</db:programlisting>
<db:para>The <db:code>lineEdit</db:code> is set up and then we arrange all the widgets using a QGridLayout. The <db:code>changeModel()</db:code> function is called, to initialize the <db:code>completer</db:code>.</db:para>
<db:programlisting language="cpp">    lineEdit = new QLineEdit;

    QGridLayout *layout = new QGridLayout;
    layout-&gt;addWidget(modelLabel, 0, 0); layout-&gt;addWidget(modelCombo, 0, 1);
    layout-&gt;addWidget(modeLabel, 1, 0);  layout-&gt;addWidget(modeCombo, 1, 1);
    layout-&gt;addWidget(caseLabel, 2, 0);  layout-&gt;addWidget(caseCombo, 2, 1);
    layout-&gt;addWidget(maxVisibleLabel, 3, 0); layout-&gt;addWidget(maxVisibleSpinBox, 3, 1);
    layout-&gt;addWidget(wrapCheckBox, 4, 0);
    layout-&gt;addWidget(contentsLabel, 5, 0, 1, 2);
    layout-&gt;addWidget(lineEdit, 6, 0, 1, 2);
    centralWidget-&gt;setLayout(layout);
    setCentralWidget(centralWidget);

    changeModel();

    setWindowTitle(tr(&quot;Completer&quot;));
    lineEdit-&gt;setFocus();
}
</db:programlisting>
<db:para>The <db:code>createMenu()</db:code> function is used to instantiate the QAction objects needed to fill the <db:code>fileMenu</db:code> and <db:code>helpMenu</db:code>. The actions' <db:link xlink:href="">triggered()</db:link> signals are connected to their respective slots.</db:para>
<db:programlisting language="cpp">void MainWindow::createMenu()
{
    QAction *exitAction = new QAction(tr(&quot;Exit&quot;), this);
    QAction *aboutAct = new QAction(tr(&quot;About&quot;), this);
    QAction *aboutQtAct = new QAction(tr(&quot;About Qt&quot;), this);

    connect(exitAction, SIGNAL(triggered()), qApp, SLOT(quit()));
    connect(aboutAct, SIGNAL(triggered()), this, SLOT(about()));
    connect(aboutQtAct, SIGNAL(triggered()), qApp, SLOT(aboutQt()));

    QMenu* fileMenu = menuBar()-&gt;addMenu(tr(&quot;File&quot;));
    fileMenu-&gt;addAction(exitAction);

    QMenu* helpMenu = menuBar()-&gt;addMenu(tr(&quot;About&quot;));
    helpMenu-&gt;addAction(aboutAct);
    helpMenu-&gt;addAction(aboutQtAct);
}
</db:programlisting>
<db:para>The <db:code>modelFromFile()</db:code> function accepts the <db:code role="parameter">fileName</db:code> of a file and processes it depending on its contents.</db:para>
<db:para>We first validate the <db:code>file</db:code> to ensure that it can be opened in QFile::ReadOnly mode. If this is unsuccessful, the function returns an empty QStringListModel.</db:para>
<db:programlisting language="cpp">QAbstractItemModel *MainWindow::modelFromFile(const QString&amp; fileName)
{
    QFile file(fileName);
    if (!file.open(QFile::ReadOnly))
        return new QStringListModel(completer);
</db:programlisting>
<db:para>The mouse cursor is then overridden with <db:link xlink:href="qt.xml#CursorShape-enum">Qt::WaitCursor</db:link> before we fill a <db:link xlink:href="qstringlist.xml">QStringList</db:link> object, <db:code>words</db:code>, with the contents of <db:code>file</db:code>. Once this is done, we restore the mouse cursor.</db:para>
<db:programlisting language="cpp">#ifndef QT_NO_CURSOR
    QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
#endif
    QStringList words;

    while (!file.atEnd()) {
        QByteArray line = file.readLine();
        if (!line.isEmpty())
            words &lt;&lt; line.trimmed();
    }

#ifndef QT_NO_CURSOR
    QApplication::restoreOverrideCursor();
#endif
</db:programlisting>
<db:para>As mentioned earlier, the resources file contains two files - <db:emphasis>countries.txt</db:emphasis> and <db:emphasis>words.txt</db:emphasis>. If the <db:code>file</db:code> read is <db:emphasis>words.txt</db:emphasis>, we return a QStringListModel with <db:code>words</db:code> as its <db:link xlink:href="qstringlist.xml">QStringList</db:link> and <db:code>completer</db:code> as its parent.</db:para>
<db:programlisting language="cpp">    if (!fileName.contains(QLatin1String(&quot;countries.txt&quot;)))
        return new QStringListModel(words, completer);
</db:programlisting>
<db:para>If the <db:code>file</db:code> read is <db:emphasis>countries.txt</db:emphasis>, then we require a QStandardItemModel with <db:code>words.count()</db:code> rows, 2 columns, and <db:code>completer</db:code> as its parent.</db:para>
<db:programlisting language="cpp">    QStandardItemModel *m = new QStandardItemModel(words.count(), 2, completer);
</db:programlisting>
<db:para>A standard line in <db:emphasis>countries.txt</db:emphasis> is:</db:para>
<db:blockquote><db:para>Norway NO</db:para>
</db:blockquote>
<db:para>Hence, to populate the QStandardItemModel object, <db:code>m</db:code>, we have to split the country name and its symbol. Once this is done, we return <db:code>m</db:code>.</db:para>
<db:programlisting language="cpp">    for (int i = 0; i &lt; words.count(); ++i) {
        QModelIndex countryIdx = m-&gt;index(i, 0);
        QModelIndex symbolIdx = m-&gt;index(i, 1);
        QString country = words[i].mid(0, words[i].length() - 2).trimmed();
        QString symbol = words[i].right(2);
        m-&gt;setData(countryIdx, country);
        m-&gt;setData(symbolIdx, symbol);
    }

    return m;
}
</db:programlisting>
<db:para>The <db:code>changeMode()</db:code> function sets the <db:code>completer</db:code>'s mode, depending on the value of <db:code>index</db:code>.</db:para>
<db:programlisting language="cpp">void MainWindow::changeMode(int index)
{
    QCompleter::CompletionMode mode;
    if (index == 0)
        mode = QCompleter::InlineCompletion;
    else if (index == 1)
        mode = QCompleter::PopupCompletion;
    else
        mode = QCompleter::UnfilteredPopupCompletion;

    completer-&gt;setCompletionMode(mode);
}
</db:programlisting>
<db:para>The <db:code>changeModel()</db:code> function changes the item model used based on the model selected by the user.</db:para>
<db:para>A <db:code>switch</db:code> statement is used to change the item model based on the index of <db:code>modelCombo</db:code>. If <db:code>case</db:code> is 0, we use an unsorted QFileSystemModel, providing us with a file path excluding the drive label.</db:para>
<db:programlisting language="cpp">void MainWindow::changeModel()
{
    delete completer;
    completer = new QCompleter(this);
    completer-&gt;setMaxVisibleItems(maxVisibleSpinBox-&gt;value());

    switch (modelCombo-&gt;currentIndex()) {
    default:
    case 0:
        { // Unsorted QFileSystemModel
            QFileSystemModel *fsModel = new QFileSystemModel(completer);
            fsModel-&gt;setRootPath(&quot;&quot;);
            completer-&gt;setModel(fsModel);
            contentsLabel-&gt;setText(tr(&quot;Enter file path&quot;));
        }
        break;
</db:programlisting>
<db:para>Note that we create the model with <db:code>completer</db:code> as the parent as this allows us to replace the model with a new model. The <db:code>completer</db:code> will ensure that the old one is deleted the moment a new model is assigned to it.</db:para>
<db:para>If <db:code>case</db:code> is 1, we use the <db:code>DirModel</db:code> we defined earlier, resulting in full paths for the files.</db:para>
<db:programlisting language="cpp">    case 1:
        {   // FileSystemModel that shows full paths
            FileSystemModel *fsModel = new FileSystemModel(completer);
            completer-&gt;setModel(fsModel);
            fsModel-&gt;setRootPath(&quot;&quot;);
            contentsLabel-&gt;setText(tr(&quot;Enter file path&quot;));
        }
        break;
</db:programlisting>
<db:para>When <db:code>case</db:code> is 2, we attempt to complete names of countries. This requires a QTreeView object, <db:code>treeView</db:code>. The country names are extracted from <db:emphasis>countries.txt</db:emphasis> and set the popup used to display completions to <db:code>treeView</db:code>.</db:para>
<db:programlisting language="cpp">    case 2:
        { // Country List
            completer-&gt;setModel(modelFromFile(&quot;:/resources/countries.txt&quot;));
            QTreeView *treeView = new QTreeView;
            completer-&gt;setPopup(treeView);
            treeView-&gt;setRootIsDecorated(false);
            treeView-&gt;header()-&gt;hide();
            treeView-&gt;header()-&gt;setStretchLastSection(false);
            treeView-&gt;header()-&gt;setSectionResizeMode(0, QHeaderView::Stretch);
            treeView-&gt;header()-&gt;setSectionResizeMode(1, QHeaderView::ResizeToContents);
            contentsLabel-&gt;setText(tr(&quot;Enter name of your country&quot;));
        }
        break;
</db:programlisting>
<db:para>The screenshot below shows the Completer with the country list model.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/completer-example-country.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>If <db:code>case</db:code> is 3, we attempt to complete words. This is done using a QStringListModel that contains data extracted from <db:emphasis>words.txt</db:emphasis>. The model is sorted <db:link xlink:href="">case insensitively</db:link>.</db:para>
<db:para>The screenshot below shows the Completer with the word list model.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/completer-example-word.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Once the model type is selected, we call the <db:code>changeMode()</db:code> function and the <db:code>changeCase()</db:code> function and set the wrap option accordingly. The <db:code>wrapCheckBox</db:code>'s <db:link xlink:href="">clicked()</db:link> signal is connected to the <db:code>completer</db:code>'s <db:link xlink:href="">setWrapAround()</db:link> slot.</db:para>
<db:programlisting language="cpp">    case 3:
        { // Word list
            completer-&gt;setModel(modelFromFile(&quot;:/resources/wordlist.txt&quot;));
            completer-&gt;setModelSorting(QCompleter::CaseInsensitivelySortedModel);
            contentsLabel-&gt;setText(tr(&quot;Enter a word&quot;));
        }
        break;
    }

    changeMode(modeCombo-&gt;currentIndex());
    changeCase(caseCombo-&gt;currentIndex());
    completer-&gt;setWrapAround(wrapCheckBox-&gt;isChecked());
    lineEdit-&gt;setCompleter(completer);
    connect(wrapCheckBox, SIGNAL(clicked(bool)), completer, SLOT(setWrapAround(bool)));
}
</db:programlisting>
<db:para>The <db:code>changeMaxVisible()</db:code> update the maximum number of visible items in the completer.</db:para>
<db:programlisting language="cpp">void MainWindow::changeMaxVisible(int max)
{
    completer-&gt;setMaxVisibleItems(max);
}
</db:programlisting>
<db:para>The <db:code>about()</db:code> function provides a brief description about the example.</db:para>
<db:programlisting language="cpp">void MainWindow::about()
{
    QMessageBox::about(this, tr(&quot;About&quot;), tr(&quot;This example demonstrates the &quot;
        &quot;different features of the QCompleter class.&quot;));
}
</db:programlisting>
</db:section>
<db:section xml:id="main-function">
<db:title><db:code>main()</db:code> Function</db:title>
<db:para>The <db:code>main()</db:code> function instantiates QApplication and <db:code>MainWindow</db:code> and invokes the <db:link xlink:href="">show()</db:link> function.</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    Q_INIT_RESOURCE(completer);

    QApplication app(argc, argv);
    MainWindow window;
    window.show();
    return app.exec();
}
</db:programlisting>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="tools/completer/completer.pro">tools/completer/completer.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tools/completer/completer.qrc">tools/completer/completer.qrc</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tools/completer/fsmodel.cpp">tools/completer/fsmodel.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tools/completer/fsmodel.h">tools/completer/fsmodel.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tools/completer/main.cpp">tools/completer/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tools/completer/mainwindow.cpp">tools/completer/mainwindow.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="tools/completer/mainwindow.h">tools/completer/mainwindow.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
