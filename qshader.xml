<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QShader Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Contains multiple versions of a shader translated to multiple shading languages, together with reflection metadata.</db:para>
<db:para>This class was introduced in Qt 6.6.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QShader</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Gui)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QShader is part of <db:simplelist><db:member><db:link xlink:href="painting-3d.xml">Rendering in 3D</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qshader.xml">QShader</db:link> is the entry point to shader code in the graphics API agnostic Qt world. Instead of using GLSL shader sources, as was the custom with Qt 5.x, new graphics systems with backends for multiple graphics APIs, such as, Vulkan, Metal, Direct3D, and OpenGL, take <db:link xlink:href="qshader.xml">QShader</db:link> as their input whenever a shader needs to be specified.</db:para>
<db:warning>
<db:para>The <db:link xlink:href="qrhi.xml">QRhi</db:link> family of classes in the Qt Gui module, including <db:link xlink:href="qshader.xml">QShader</db:link> and <db:link xlink:href="qshaderdescription.xml">QShaderDescription</db:link>, offer limited compatibility guarantees. There are no source or binary compatibility guarantees for these classes, meaning the API is only guaranteed to work with the Qt version the application was developed against. Source incompatible changes are however aimed to be kept at a minimum and will only be made in minor releases (6.7, 6.8, and so on). To use these classes in an application, link to <db:code>Qt::GuiPrivate</db:code> (if using CMake), and include the headers with the <db:code>rhi</db:code> prefix, for example <db:code>#include &lt;rhi/qshader.h&gt;</db:code>.</db:para>
</db:warning>
<db:para>A <db:link xlink:href="qshader.xml">QShader</db:link> instance is empty and thus invalid by default. To get a useful instance, the two typical methods are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Generate the contents offline, during build time or earlier, using the <db:code>qsb</db:code> command line tool. The result is a binary file that is shipped with the application, read via <db:link xlink:href="qiodevice.xml#readAll">QIODevice::readAll</db:link>(), and then deserialized via <db:link xlink:href="qshader.xml#fromSerialized">fromSerialized</db:link>(). For more information, see QShaderBaker.</db:para>
</db:listitem>
<db:listitem>
<db:para>Generate at run time via QShaderBaker. This is an expensive operation, but allows applications to use user-provided or dynamically generated shader source strings.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>When used together with the Qt Rendering Hardware Interface and its classes, like <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link>, no further action is needed from the application's side as these classes are prepared to consume a <db:link xlink:href="qshader.xml">QShader</db:link> whenever a shader needs to be specified for a given stage of the graphics pipeline.</db:para>
<db:para>Alternatively, applications can access</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>the source or byte code for any of the shading language versions that are included in the <db:link xlink:href="qshader.xml">QShader</db:link>,</db:para>
</db:listitem>
<db:listitem>
<db:para>the name of the entry point for the shader,</db:para>
</db:listitem>
<db:listitem>
<db:para>the reflection metadata containing a description of the shader's inputs, outputs and resources like uniform blocks. This is essential when an application or framework needs to discover the inputs of a shader at runtime due to not having advance knowledge of the vertex attributes or the layout of the uniform buffers used by the shader.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para><db:link xlink:href="qshader.xml">QShader</db:link> makes no assumption about the shading language that was used as the source for generating the various versions and variants that are included in it.</db:para>
<db:para><db:link xlink:href="qshader.xml">QShader</db:link> uses implicit sharing similarly to many core Qt types, and so can be returned or passed by value. Detach happens implicitly when calling a setter.</db:para>
<db:para>For reference, a typical, portable <db:link xlink:href="qrhi.xml">QRhi</db:link> expects that a <db:link xlink:href="qshader.xml">QShader</db:link> suitable for all its backends contains at least the following. (this excludes support for core profile OpenGL contexts, add GLSL 150 or newer for that)</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>SPIR-V 1.0 bytecode suitable for Vulkan 1.0 or newer</db:para>
</db:listitem>
<db:listitem>
<db:para>GLSL/ES 100 source code suitable for OpenGL ES 2.0 or newer</db:para>
</db:listitem>
<db:listitem>
<db:para>GLSL 120 source code suitable for OpenGL 2.1 or newer</db:para>
</db:listitem>
<db:listitem>
<db:para>HLSL Shader Model 5.0 source code or the corresponding DXBC bytecode suitable for Direct3D 11/12</db:para>
</db:listitem>
<db:listitem>
<db:para>Metal Shading Language 1.2 source code or the corresponding bytecode suitable for Metal 1.2 or newer</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>QShaderBaker</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="NativeResourceBindingMap-typedef">
<db:title>[alias] QShader::NativeResourceBindingMap</db:title>
<db:para>Synonym for <db:link xlink:href="qmap.xml">QMap</db:link>&lt;int, <db:link xlink:href="qpair-qtcore-proxy.xml#QPair-typedef">QPair</db:link>&lt;int, int&gt;&gt;.</db:para>
<db:para>The resource binding model <db:link xlink:href="qrhi.xml">QRhi</db:link> assumes is based on SPIR-V. This means that uniform buffers, storage buffers, combined image samplers, and storage images share a common binding point space. The binding numbers in <db:link xlink:href="qshaderdescription.xml">QShaderDescription</db:link> and <db:link xlink:href="qrhishaderresourcebinding.xml">QRhiShaderResourceBinding</db:link> are expected to match the <db:code>binding</db:code> layout qualifier in the Vulkan-compatible GLSL shader.</db:para>
<db:para>Graphics APIs other than Vulkan may use a resource binding model that is not fully compatible with this. The generator of the shader code translated from SPIR-V may choose not to take the SPIR-V binding qualifiers into account, for various reasons. This is the case with the Metal backend of SPIRV-Cross, for example. In addition, even when an automatic, implicit translation is mostly possible (e.g. by using SPIR-V binding points as HLSL resource register indices), assigning resource bindings without being constrained by the SPIR-V binding points can lead to better results.</db:para>
<db:para>Therefore, a <db:link xlink:href="qshader.xml">QShader</db:link> may expose an additional map that describes what the native binding point for a given SPIR-V binding is. The <db:link xlink:href="qrhi.xml">QRhi</db:link> backends, for which this is relevant, are expected to use this map automatically, as appropriate. The value is a pair, because combined image samplers may map to two native resources (a texture and a sampler) in some shading languages. In that case the second value refers to the sampler.</db:para>
<db:note>
<db:para>The native binding may be -1, in case there is no active binding for the resource in the shader. (for example, there is a uniform block declared, but it is not used in the shader code) The map is always complete, meaning there is an entry for all declared uniform blocks, storage blocks, image objects, and combined samplers, but the value will be -1 for those that are not actually referenced in the shader functions.</db:para>
</db:note>
</db:section>
<db:section xml:id="SeparateToCombinedImageSamplerMappingList-typedef">
<db:title>[alias] QShader::SeparateToCombinedImageSamplerMappingList</db:title>
<db:para>Synonym for <db:link xlink:href="qlist.xml">QList</db:link>&lt;<db:link xlink:href="qshader-separatetocombinedimagesamplermapping.xml">QShader::SeparateToCombinedImageSamplerMapping</db:link>&gt;.</db:para>
</db:section>
<db:section xml:id="SerializedFormatVersion-enum">
<db:title>enum QShader::SerializedFormatVersion</db:title>
<db:para>Describes the desired output format when serializing the <db:link xlink:href="qshader.xml">QShader</db:link>.</db:para>
<db:para>The default value for the <db:code>version</db:code> argument of <db:link xlink:href="qshader.xml#serialized">serialized</db:link>() is <db:code>Latest</db:code>. This is sufficient in the vast majority of cases. Specifying another value is needed only when the intention is to generate serialized data that can be loaded by earlier Qt versions. For example, the <db:code>qsb</db:code> tool uses these enum values when the <db:code>--qsbversion</db:code> command-line argument is given.</db:para>
<db:note>
<db:para>Targeting earlier versions will make certain features disfunctional with the generated asset. This is not an issue when using the asset with the specified, older Qt version, given that that Qt version does not have the newer features in newer Qt versions that rely on additional data generated in the <db:link xlink:href="qshader.xml">QShader</db:link> and the serialized data stream, but may become a problem if the generated asset is then used with a newer Qt version.</db:para>
</db:note>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::<db:emphasis role="bold">SerializedFormatVersion</db:emphasis>::Latest</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The current Qt version</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::<db:emphasis role="bold">SerializedFormatVersion</db:emphasis>::Qt_6_5</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Qt 6.5</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::<db:emphasis role="bold">SerializedFormatVersion</db:emphasis>::Qt_6_4</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Qt 6.4</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="Source-enum">
<db:title>enum QShader::Source</db:title>
<db:para>Describes what kind of shader code an entry contains.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::SpirvShader</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>SPIR-V</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::GlslShader</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>GLSL</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::HlslShader</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>HLSL</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::DxbcShader</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>Direct3D bytecode (HLSL compiled by <db:code>fxc</db:code>)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::MslShader</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>Metal Shading Language</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::DxilShader</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>Direct3D bytecode (HLSL compiled by <db:code>dxc</db:code>)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::MetalLibShader</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>Pre-compiled Metal bytecode</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::WgslShader</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>WGSL</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="Stage-enum">
<db:title>enum QShader::Stage</db:title>
<db:para>Describes the stage of the graphics pipeline the shader is suitable for.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::VertexStage</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Vertex shader</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::TessellationControlStage</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Tessellation control (hull) shader</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::TessellationEvaluationStage</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>Tessellation evaluation (domain) shader</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::GeometryStage</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>Geometry shader</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::FragmentStage</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>Fragment (pixel) shader</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::ComputeStage</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>Compute shader</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="Variant-enum">
<db:title>enum QShader::Variant</db:title>
<db:para>Describes what kind of shader code an entry contains.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::StandardShader</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The normal, unmodified version of the shader code.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::BatchableVertexShader</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>Vertex shader rewritten to be suitable for Qt Quick scenegraph batching.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::UInt16IndexedVertexAsComputeShader</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>A vertex shader meant to be used in a Metal pipeline with tessellation in combination with indexed draw calls sourcing index data from a uint16 index buffer. To support the Metal tessellation pipeline, the vertex shader is translated to a compute shader that may be dependent on the index buffer usage in the draw calls (e.g. if the shader is using gl_VertexIndex), hence the need for three dedicated variants.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::UInt32IndexedVertexAsComputeShader</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>A vertex shader meant to be used in a Metal pipeline with tessellation in combination with indexed draw calls sourcing index data from a uint32 index buffer. To support the Metal tessellation pipeline, the vertex shader is translated to a compute shader that may be dependent on the index buffer usage in the draw calls (e.g. if the shader is using gl_VertexIndex), hence the need for three dedicated variants.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qshader.xml">QShader</db:link></db:emphasis>::NonIndexedVertexAsComputeShader</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>A vertex shader meant to be used in a Metal pipeline with tessellation in combination with non-indexed draw calls. To support the Metal tessellation pipeline, the vertex shader is translated to a compute shader that may be dependent on the index buffer usage in the draw calls (e.g. if the shader is using gl_VertexIndex), hence the need for three dedicated variants.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QShader">
<db:title>QShader::QShader()</db:title>
<db:para>Constructs a new, empty (and thus invalid) <db:link xlink:href="qshader.xml">QShader</db:link> instance.</db:para>
</db:section>
<db:section xml:id="QShader-1">
<db:title>QShader::QShader(const QShader &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QShader">
<db:title>[noexcept] QShader::~QShader()</db:title>
<db:para>Destructor.</db:para>
</db:section>
<db:section xml:id="availableShaders">
<db:title>QList&lt;QShaderKey&gt; QShader::availableShaders() const</db:title>
<db:para>Returns the list of available shader versions</db:para>
</db:section>
<db:section xml:id="description">
<db:title>QShaderDescription QShader::description() const</db:title>
<db:para>Returns the reflection metadata for the shader.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#setDescription">setDescription</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromSerialized">
<db:title>[static] QShader QShader::fromSerialized(const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:para>Creates a new <db:link xlink:href="qshader.xml">QShader</db:link> instance from the given <db:code role="parameter">data</db:code>.</db:para>
<db:para>If <db:code role="parameter">data</db:code> cannot be deserialized successfully, the result is a default constructed <db:link xlink:href="qshader.xml">QShader</db:link> for which <db:link xlink:href="qshader.xml#isValid">isValid</db:link>() returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#serialized">serialized</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QShader::isValid() const</db:title>
<db:para>Returns true if the <db:link xlink:href="qshader.xml">QShader</db:link> contains at least one shader version.</db:para>
</db:section>
<db:section xml:id="nativeResourceBindingMap">
<db:title>QShader::NativeResourceBindingMap QShader::nativeResourceBindingMap(const QShaderKey &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns the native binding map for <db:code role="parameter">key</db:code>. The map is empty if no mapping is available for <db:code role="parameter">key</db:code> (for example, because the map is not applicable for the API and shading language described by <db:code role="parameter">key</db:code>).</db:para>
</db:section>
<db:section xml:id="nativeShaderInfo">
<db:title>QShader::NativeShaderInfo QShader::nativeShaderInfo(const QShaderKey &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns the native shader info struct for <db:code role="parameter">key</db:code>, or an empty object if there is no data available for <db:code role="parameter">key</db:code>, for example because such a mapping is not applicable for the shading language or the shader stage.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#setNativeShaderInfo">setNativeShaderInfo</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="removeNativeShaderInfo">
<db:title>void QShader::removeNativeShaderInfo(const QShaderKey &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes the native shader information for <db:code role="parameter">key</db:code>.</db:para>
</db:section>
<db:section xml:id="removeResourceBindingMap">
<db:title>void QShader::removeResourceBindingMap(const QShaderKey &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes the native resource binding map for <db:code role="parameter">key</db:code>.</db:para>
</db:section>
<db:section xml:id="removeSeparateToCombinedImageSamplerMappingList">
<db:title>void QShader::removeSeparateToCombinedImageSamplerMappingList(const QShaderKey &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes the combined image sampler mapping list for <db:code role="parameter">key</db:code>.</db:para>
</db:section>
<db:section xml:id="removeShader">
<db:title>void QShader::removeShader(const QShaderKey &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:para>Removes the source or binary shader code for a given <db:code role="parameter">key</db:code>. Does nothing when not found.</db:para>
</db:section>
<db:section xml:id="separateToCombinedImageSamplerMappingList">
<db:title>QShader::SeparateToCombinedImageSamplerMappingList QShader::separateToCombinedImageSamplerMappingList(const QShaderKey &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns the combined image sampler mapping list for <db:code role="parameter">key</db:code>, or an empty list if there is no data available for <db:code role="parameter">key</db:code>, for example because such a mapping is not applicable for the shading language.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#setSeparateToCombinedImageSamplerMappingList">setSeparateToCombinedImageSamplerMappingList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="serialized">
<db:title>QByteArray QShader::serialized(QShader::SerializedFormatVersion <db:emphasis>version</db:emphasis> = SerializedFormatVersion::Latest) const</db:title>
<db:para>Returns a serialized binary version of all the data held by the <db:link xlink:href="qshader.xml">QShader</db:link>, suitable for writing to files or other I/O devices.</db:para>
<db:para>By default the latest serialization format is used. Use <db:code role="parameter">version</db:code> parameter to serialize for a compatibility Qt version. Only when it is known that the generated data stream must be made compatible with an older Qt version at the expense of making it incompatible with features introduced since that Qt version, should another value (for example, <db:link xlink:href="qshader.xml#SerializedFormatVersion-enum">Qt_6_5</db:link> for Qt 6.5) be used.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#fromSerialized">fromSerialized</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setDescription">
<db:title>void QShader::setDescription(const QShaderDescription &amp;<db:emphasis>desc</db:emphasis>)</db:title>
<db:para>Sets the reflection metadata to <db:code role="parameter">desc</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#description">description</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNativeShaderInfo">
<db:title>void QShader::setNativeShaderInfo(const QShaderKey &amp;<db:emphasis>key</db:emphasis>, const QShader::NativeShaderInfo &amp;<db:emphasis>info</db:emphasis>)</db:title>
<db:para>Stores the given native shader <db:code role="parameter">info</db:code> associated with <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#nativeShaderInfo">nativeShaderInfo</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setResourceBindingMap">
<db:title>void QShader::setResourceBindingMap(const QShaderKey &amp;<db:emphasis>key</db:emphasis>, const QShader::NativeResourceBindingMap &amp;<db:emphasis>map</db:emphasis>)</db:title>
<db:para>Stores the given native resource binding <db:code role="parameter">map</db:code> associated with <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#nativeResourceBindingMap">nativeResourceBindingMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setSeparateToCombinedImageSamplerMappingList">
<db:title>void QShader::setSeparateToCombinedImageSamplerMappingList(const QShaderKey &amp;<db:emphasis>key</db:emphasis>, const QShader::SeparateToCombinedImageSamplerMappingList &amp;<db:emphasis>list</db:emphasis>)</db:title>
<db:para>Stores the given combined image sampler mapping <db:code role="parameter">list</db:code> associated with <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#separateToCombinedImageSamplerMappingList">separateToCombinedImageSamplerMappingList</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setShader">
<db:title>void QShader::setShader(const QShaderKey &amp;<db:emphasis>key</db:emphasis>, const QShaderCode &amp;<db:emphasis>shader</db:emphasis>)</db:title>
<db:para>Stores the source or binary <db:code role="parameter">shader</db:code> code for a given shader version specified by <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#shader">shader</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setStage">
<db:title>void QShader::setStage(QShader::Stage <db:emphasis>stage</db:emphasis>)</db:title>
<db:para>Sets the pipeline <db:code role="parameter">stage</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#stage">stage</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="shader">
<db:title>QShaderCode QShader::shader(const QShaderKey &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:para>Returns the source or binary code for a given shader version specified by <db:code role="parameter">key</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#setShader">setShader</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stage">
<db:title>QShader::Stage QShader::stage() const</db:title>
<db:para>Returns the pipeline stage the shader is meant for.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qshader.xml#setStage">setStage</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QShader &amp;QShader::operator=(const QShader &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:para>Assigns <db:code role="parameter">other</db:code> to this object.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="operator-eq-eq-1">
<db:title>[noexcept] bool operator==(const QShader &amp;<db:emphasis>lhs</db:emphasis>, const QShader &amp;<db:emphasis>rhs</db:emphasis>)</db:title>
<db:para>Returns <db:code>true</db:code> if the two <db:link xlink:href="qshader.xml">QShader</db:link> objects <db:code role="parameter">lhs</db:code> and <db:code role="parameter">rhs</db:code> are equal, meaning they are for the same stage with matching sets of shader source or binary code.</db:para>
</db:section>
</db:section>
</db:article>
