<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt SCXML FTP Client Example</db:title>
<db:productname>QtScxml</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Scxml Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Implements a simple FTP client using a state machine.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para><db:emphasis>FTP Client</db:emphasis> uses Qt SCXML to implement a FTP client that can communicate with a FTP service by sending FTP control messages translated from state machine events and by translating server replies into state machine events. The data received from the FTP server is printed on the console.</db:para>
<db:para><db:link xlink:href="https://tools.ietf.org/html/rfc959">RFC 959</db:link> specifies state charts for the command handling of the FTP client. They can be easily translated into SCXML to benefit from SCXML nested states. Connections between the client and server and data transfer are implemented by using C++. In addition, Qt signals and slots are used.</db:para>
<db:para>The state machine has the following states:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/ftpclient-statechart.png"/>
</db:imageobject>
</db:mediaobject>
<db:itemizedlist>
<db:listitem>
<db:para><db:emphasis>I</db:emphasis> as the initial state.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis>B</db:emphasis> for sending commands.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis>S</db:emphasis> for success.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis>F</db:emphasis> for failure.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis>W</db:emphasis> for waiting for a reply.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:emphasis>P</db:emphasis> for supplying a password upon server request.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The state machine is specified in the <db:emphasis>simpleftp.scxml</db:emphasis> file and compiled into the <db:code>FtpClient</db:code> class that implements the logic of the FTP protocol. It reacts to user input and to replies from the control channel by changing states and sending external events. In addition, we implement a <db:code>FtpControlChannel</db:code> class and a <db:code>FtpDataChannel</db:code> class that handle TCP sockets and servers and convert line endings.</db:para>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="http://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:emphasis role="bold">Welcome</db:emphasis> mode and select the example from <db:emphasis role="bold">Examples</db:emphasis>. For more information, visit <db:link xlink:href="http://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="compiling-the-state-machine">
<db:title>Compiling the State Machine</db:title>
<db:para>We link against the Qt SCXML module by adding the following line to the <db:emphasis>.pro</db:emphasis> file:</db:para>
<db:programlisting language="cpp">QT = core scxml network
</db:programlisting>
<db:para>We then specify the state machine to compile:</db:para>
<db:programlisting language="cpp">STATECHARTS += simpleftp.scxml
</db:programlisting>
<db:para>The Qt SCXML Compiler, <db:code>qscxmlc</db:code>, is run automatically to generate <db:emphasis>ftpclient.h</db:emphasis> and <db:emphasis>ftpclient.cpp</db:emphasis>, and to add them to the <db:code>HEADERS</db:code> and <db:code>SOURCES</db:code> variables for compilation.</db:para>
</db:section>
<db:section xml:id="instantiating-the-state-machine">
<db:title>Instantiating the State Machine</db:title>
<db:para>We instantiate the generated <db:code>FtpClient</db:code> class, as well as the <db:code>FtpDataChannel</db:code> and <db:code>FtpControlChannel</db:code> classes in the <db:emphasis>main.cpp</db:emphasis> file:</db:para>
<db:programlisting language="cpp">#include &quot;ftpcontrolchannel.h&quot;
#include &quot;ftpdatachannel.h&quot;
    ...
int main(int argc, char *argv[])
{
    ...
    QCoreApplication app(argc, argv);
    FtpClient ftpClient;
    FtpDataChannel dataChannel;
    FtpControlChannel controlChannel;
    ...
</db:programlisting>
</db:section>
<db:section xml:id="communicating-with-an-ftp-server">
<db:title>Communicating with an FTP Server</db:title>
<db:para>We print all data retrieved from the server on the console:</db:para>
<db:programlisting language="cpp">    QObject::connect(&amp;amp;dataChannel, &amp;amp;FtpDataChannel::dataReceived,
                     [](const QByteArray &amp;amp;data) {
        std::cout &amp;lt;&amp;lt; data.constData();
    });
</db:programlisting>
<db:para>We translate server replies into state machine events:</db:para>
<db:programlisting language="cpp">    QObject::connect(&amp;amp;controlChannel, &amp;amp;FtpControlChannel::reply, &amp;amp;ftpClient,
                     [&amp;amp;ftpClient](int code, const QString &amp;amp;parameters) {
        ftpClient.submitEvent(QString(&quot;reply.%1xx&quot;)
                              .arg(code / 100), parameters);
    });
</db:programlisting>
<db:para>We translate commands from the state machine into FTP control messages:</db:para>
<db:programlisting language="cpp">    ftpClient.connectToEvent(&quot;submit.cmd&quot;, &amp;amp;controlChannel,
                             [&amp;amp;controlChannel](const QScxmlEvent &amp;amp;event) {
        controlChannel.command(event.name().mid(11).toUtf8(),
                               event.data().toMap()[&quot;params&quot;].toByteArray());
    });
</db:programlisting>
<db:para>We send commands to log into the FTP server as an anonymous user, to announce a port for the data connection, and to retrive a file:</db:para>
<db:programlisting language="cpp">    QList&amp;lt;Command&amp;gt; commands({
        {&quot;cmd.USER&quot;, &quot;anonymous&quot;},// login
        {&quot;cmd.PORT&quot;, &quot;&quot;},         // announce port for data connection,
                                  // args added below.
        {&quot;cmd.RETR&quot;, file}        // retrieve a file
    });
</db:programlisting>
<db:para>We specify that the FTP client should send the next command when entering the <db:emphasis>B</db:emphasis> state:</db:para>
<db:programlisting language="cpp">    ftpClient.connectToState(&quot;B&quot;, QScxmlStateMachine::onEntry([&amp;amp;]() {
        if (commands.isEmpty()) {
            app.quit();
            return;
        }
        Command command = commands.takeFirst();
        qDebug() &amp;lt;&amp;lt; &quot;Posting command&quot; &amp;lt;&amp;lt; command.cmd &amp;lt;&amp;lt; command.args;
        ftpClient.submitEvent(command.cmd, command.args);
    }));
</db:programlisting>
<db:para>We specify that the FTP client should send an empty string as a password if the server asks for one:</db:para>
<db:programlisting language="cpp">    ftpClient.connectToState(&quot;P&quot;, QScxmlStateMachine::onEntry([&amp;amp;ftpClient]() {
        qDebug() &amp;lt;&amp;lt; &quot;Sending password&quot;;
        ftpClient.submitEvent(&quot;cmd.PASS&quot;, QString());
    }));
</db:programlisting>
<db:para>Finally, we connect to the FTP server specified as the first argument of the method and retrieve the file specified as the second argument:</db:para>
<db:programlisting language="cpp">    controlChannel.connectToServer(server);
    QObject::connect(&amp;amp;controlChannel, &amp;amp;FtpControlChannel::opened,
                     [&amp;amp;](const QHostAddress &amp;amp;address, int) {
        dataChannel.listen(address);
        commands[1].args = dataChannel.portspec();
        ftpClient.start();
    });
</db:programlisting>
<db:para>For example, the following invocation prints the specified file from the specified server: <db:code>ftpclient &lt;server&gt; &lt;file&gt;</db:code>.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="ftpclient/ftpclient.pro">ftpclient/ftpclient.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="ftpclient/ftpcontrolchannel.cpp">ftpclient/ftpcontrolchannel.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="ftpclient/ftpcontrolchannel.h">ftpclient/ftpcontrolchannel.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="ftpclient/ftpdatachannel.cpp">ftpclient/ftpdatachannel.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="ftpclient/ftpdatachannel.h">ftpclient/ftpdatachannel.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="ftpclient/main.cpp">ftpclient/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="ftpclient/simpleftp.scxml">ftpclient/simpleftp.scxml</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
