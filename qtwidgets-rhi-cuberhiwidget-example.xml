<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Cube RHI Widget Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Shows how to render a textured cube and integrate with <db:link xlink:href="qpainter.xml">QPainter</db:link> and widgets, using <db:link xlink:href="qrhi.xml">QRhi</db:link> Qt's 3D API and shading language abstraction layer.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:figure>
<db:title>Screenshot of the Cube RHI Widget example</db:title>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/cuberhiwidget-example.jpg"/>
</db:imageobject>
</db:mediaobject>
</db:figure>
<db:para>This example builds on the <db:link xlink:href="qtwidgets-rhi-simplerhiwidget-example.xml">Simple RHI Widget Example</db:link>. While the simple example is intentionally minimal and as compact as possible, rendering only a single triangle with no additional widgets in the window, this application demonstrates:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Having various widgets in the window, some of them controlling data that is consumed by the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> subclass.</db:para>
</db:listitem>
<db:listitem>
<db:para>Instead of continuously requesting updates, the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> here only updates the content in its backing texture when some related data changes.</db:para>
</db:listitem>
<db:listitem>
<db:para>The cube is textured using a <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> that sources its content from a <db:link xlink:href="qimage.xml">QImage</db:link> that contains software-based rendering performed with <db:link xlink:href="qpainter.xml">QPainter</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>The contents of the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> <db:link xlink:href="qwidget.xml#grab">can be read back</db:link> and saved to an image file (e.g. a PNG file).</db:para>
</db:listitem>
<db:listitem>
<db:para>4x multisample antialiasing <db:link xlink:href="qrhiwidget.xml#sampleCount-prop">can be toggled</db:link> at run time. The <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> subclass is prepared to handle the changing sample count correctly.</db:para>
</db:listitem>
<db:listitem>
<db:para>Forcing an <db:link xlink:href="">explicitly specified backing texture size</db:link> can be toggled dynamically and controlled with a slider between 16x16 up to 512x512 pixels.</db:para>
</db:listitem>
<db:listitem>
<db:para>The <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> subclass deals with a changing <db:link xlink:href="qrhi.xml">QRhi</db:link> correctly. This can be seen in action when making the widget top-level (no parent; becomes a separate window) and then reparenting it again into the main window's child hierarchy.</db:para>
</db:listitem>
<db:listitem>
<db:para>Most importantly, some widgets, with semi-transparency even, can be placed on top of the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>, proving that correct stacking and blending is feasible. This is a case where <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link> is superior to embedding a native window, i.e. a <db:link xlink:href="qrhi.xml">QRhi</db:link>-based <db:link xlink:href="qwindow.xml">QWindow</db:link> using <db:link xlink:href="qwidget.xml#createWindowContainer">QWidget::createWindowContainer</db:link>(), because it allows stacking and clipping the same way as any ordinary, software-rendered <db:link xlink:href="qwidget.xml">QWidget</db:link>, whereas native window embedding may, depending on the platform, have various limitations, e.g. often it can be difficult or inefficient to place additional controls on top.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In the reimplementation of <db:link xlink:href="qrhiwidget.xml#initialize">initialize</db:link>(), the first thing to do is to check if the <db:link xlink:href="qrhi.xml">QRhi</db:link> we last worked with is still up-to-date, and if the sample count (for multisample antialiasing) has changed. The former is important because all graphics resources must be released when the <db:link xlink:href="qrhi.xml">QRhi</db:link> changes, whereas with a dynamically changing sample count a similar problem arises specifically for <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> objects as those bake the sample count in. For simplicity, the application handles all such changes the same way, by resetting its scene struct to a default constructed one, which conveniently drops all graphics resources. All resources are then recreated.</db:para>
<db:para>When the backing texture size (so the render target size) changes, no special action is needed, but a signal is emitted for convenience, just so that main() can reposition the overlay label. The 3D API name is also exposed via a signal by querying <db:link xlink:href="qrhi.xml#backendName">QRhi::backendName</db:link>() whenever the <db:link xlink:href="qrhi.xml">QRhi</db:link> changes.</db:para>
<db:para>The implementation has to be aware that multisample antialiasing implies that <db:link xlink:href="qrhiwidget.xml#colorTexture">colorTexture</db:link>() is nullptr, while <db:link xlink:href="qrhiwidget.xml#msaaColorBuffer">msaaColorBuffer</db:link>() is valid. This is the opposite of when MSAA is not in use. The reason for differentiating and using different types (<db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link>, <db:link xlink:href="qrhirenderbuffer.xml">QRhiRenderBuffer</db:link>) is to allow using MSAA with 3D graphics APIs that do not have support for multisample textures, but have support for multisample renderbuffers. An example of this is OpenGL ES 3.0.</db:para>
<db:para>When checking the up-to-date pixel size and sample count, a convenient and compact solution is to query via the <db:link xlink:href="qrhirendertarget.xml">QRhiRenderTarget</db:link>, because this way one does not need to check which of colorTexture() and msaaColorBuffer() are valid.</db:para>
<db:programlisting language="cpp">void ExampleRhiWidget::initialize(QRhiCommandBuffer *)
{
    if (m_rhi != rhi()) {
        m_rhi = rhi();
        scene = {};
        emit rhiChanged(QString::fromUtf8(m_rhi-&gt;backendName()));
    }
    if (m_pixelSize != renderTarget()-&gt;pixelSize()) {
        m_pixelSize = renderTarget()-&gt;pixelSize();
        emit resized();
    }
    if (m_sampleCount != renderTarget()-&gt;sampleCount()) {
        m_sampleCount = renderTarget()-&gt;sampleCount();
        scene = {};
    }
</db:programlisting>
<db:para>The rest is quite self-explanatory. The buffers and pipelines are (re)created, if necessary. The contents of the texture that is used to texture the cube mesh is updated. The scene is rendered using a perspective projection. The view is just a simple translation for now.</db:para>
<db:programlisting language="cpp">    if (!scene.vbuf) {
        initScene();
        updateCubeTexture();
    }

    scene.mvp = m_rhi-&gt;clipSpaceCorrMatrix();
    scene.mvp.perspective(45.0f, m_pixelSize.width() / (float) m_pixelSize.height(), 0.01f, 1000.0f);
    scene.mvp.translate(0, 0, -4);
    updateMvp();
}
</db:programlisting>
<db:para>The function that performs the actual enqueuing of the uniform buffer write is also taking the user-provided rotation into account, thus generating the final modelview-projection matrix.</db:para>
<db:programlisting language="cpp">void ExampleRhiWidget::updateMvp()
{
    QMatrix4x4 mvp = scene.mvp * QMatrix4x4(QQuaternion::fromEulerAngles(QVector3D(30, itemData.cubeRotation, 0)).toRotationMatrix());
    if (!scene.resourceUpdates)
        scene.resourceUpdates = m_rhi-&gt;nextResourceUpdateBatch();
    scene.resourceUpdates-&gt;updateDynamicBuffer(scene.ubuf.get(), 0, 64, mvp.constData());
}
</db:programlisting>
<db:para>Updating the <db:link xlink:href="qrhitexture.xml">QRhiTexture</db:link> that is sampled in the fragment shader when rendering the cube, is quite simple, even though a lot is happening in there: first a <db:link xlink:href="qpainter.xml">QPainter</db:link>-based drawing is generated within a <db:link xlink:href="qimage.xml">QImage</db:link>. This uses the user-provided text. Then the CPU-side pixel data is uploaded to a texture (more precisely, the upload operation is recorded on a <db:link xlink:href="qrhiresourceupdatebatch.xml">QRhiResourceUpdateBatch</db:link>, which is then submitted later in render()).</db:para>
<db:programlisting language="cpp">void ExampleRhiWidget::updateCubeTexture()
{
    QImage image(CUBE_TEX_SIZE, QImage::Format_RGBA8888);
    const QRect r(QPoint(0, 0), CUBE_TEX_SIZE);
    QPainter p(&amp;image);
    p.fillRect(r, QGradient::DeepBlue);
    QFont font;
    font.setPointSize(24);
    p.setFont(font);
    p.drawText(r, itemData.cubeText);
    p.end();

    if (!scene.resourceUpdates)
        scene.resourceUpdates = m_rhi-&gt;nextResourceUpdateBatch();
    scene.resourceUpdates-&gt;uploadTexture(scene.cubeTex.get(), image);
}
</db:programlisting>
<db:para>The graphics resource initialization is simple. There is only a vertex buffer, no index buffer, and a uniform buffer with only a 4x4 matrix in it (16 floats).</db:para>
<db:para>The texture that contains the <db:link xlink:href="qpainter.xml">QPainter</db:link>-generated drawing has a size of 512x512. Note that all sizes (texture sizes, viewports, scissors, texture upload regions, etc.) are always in pixels when working with <db:link xlink:href="qrhi.xml">QRhi</db:link>. To sample this texture in the shader, a <db:link xlink:href="qrhisampler.xml">sampler object</db:link> is needed (irrespective of the fact that <db:link xlink:href="qrhi.xml">QRhi</db:link>-based applications will typically use combined image samplers in the GLSL shader code, which then may be transpiled to separate texture and sampler objects with some shading languages, or may stay a combined texture-sampler object with others, meaning there may not actually be a native sampler object under the hood at run time, depending on the 3D API, but this is all transparent to the application)</db:para>
<db:para>The vertex shader reads from the uniform buffer at binding point 0, therefore scene.ubuf is exposed at that binding location. The fragment shader samples a texture provided at binding point 1, therefore a combined texture-sampler pair is specified for that binding location.</db:para>
<db:para>The <db:link xlink:href="qrhigraphicspipeline.xml">QRhiGraphicsPipeline</db:link> enables depth test/write, and culls backfaces. It also relies on a number of defaults, e.g. the depth comparison function defaults to Less, which is fine for us, and the front face mode is counter-clockwise, which is also good as-is so does not need to be set again.</db:para>
<db:programlisting language="cpp">    scene.vbuf.reset(m_rhi-&gt;newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(cube)));
    scene.vbuf-&gt;create();

    scene.resourceUpdates = m_rhi-&gt;nextResourceUpdateBatch();
    scene.resourceUpdates-&gt;uploadStaticBuffer(scene.vbuf.get(), cube);

    scene.ubuf.reset(m_rhi-&gt;newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, 64));
    scene.ubuf-&gt;create();

    scene.cubeTex.reset(m_rhi-&gt;newTexture(QRhiTexture::RGBA8, CUBE_TEX_SIZE));
    scene.cubeTex-&gt;create();

    scene.sampler.reset(m_rhi-&gt;newSampler(QRhiSampler::Linear, QRhiSampler::Linear, QRhiSampler::None,
                                               QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
    scene.sampler-&gt;create();

    scene.srb.reset(m_rhi-&gt;newShaderResourceBindings());
    scene.srb-&gt;setBindings({
        QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, scene.ubuf.get()),
        QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, scene.cubeTex.get(), scene.sampler.get())
    });
    scene.srb-&gt;create();

    scene.ps.reset(m_rhi-&gt;newGraphicsPipeline());
    scene.ps-&gt;setDepthTest(true);
    scene.ps-&gt;setDepthWrite(true);
    scene.ps-&gt;setCullMode(QRhiGraphicsPipeline::Back);
    scene.ps-&gt;setShaderStages({
        { QRhiShaderStage::Vertex, getShader(QLatin1String(&quot;:/shader_assets/texture.vert.qsb&quot;)) },
        { QRhiShaderStage::Fragment, getShader(QLatin1String(&quot;:/shader_assets/texture.frag.qsb&quot;)) }
    });
    QRhiVertexInputLayout inputLayout;
    // The cube is provided as non-interleaved sets of positions, UVs, normals.
    // Normals are not interesting here, only need the positions and UVs.
    inputLayout.setBindings({
        { 3 * sizeof(float) },
        { 2 * sizeof(float) }
    });
    inputLayout.setAttributes({
        { 0, 0, QRhiVertexInputAttribute::Float3, 0 },
        { 1, 1, QRhiVertexInputAttribute::Float2, 0 }
    });
    scene.ps-&gt;setSampleCount(m_sampleCount);
    scene.ps-&gt;setVertexInputLayout(inputLayout);
    scene.ps-&gt;setShaderResourceBindings(scene.srb.get());
    scene.ps-&gt;setRenderPassDescriptor(renderTarget()-&gt;renderPassDescriptor());
    scene.ps-&gt;create();
</db:programlisting>
<db:para>In the reimplementation of <db:link xlink:href="qrhiwidget.xml#render">render</db:link>(), first the user-provided data is checked. If the <db:link xlink:href="qslider.xml">QSlider</db:link> controlling the rotation has provided a new value, or the <db:link xlink:href="qtextedit.xml">QTextEdit</db:link> with the cube text has changed its text, the graphics resources the contents of which depend on such data get updated.</db:para>
<db:para>Then, a single render pass with a single draw call is recorded. The cube mesh data is provided in a non-interleaved format, hence the need for two vertex input bindings, one is the positions (x, y, z) the other is the UVs (u, v), with a start offset that corresponds to 36 x-y-z float pairs.</db:para>
<db:programlisting language="cpp">void ExampleRhiWidget::render(QRhiCommandBuffer *cb)
{
    if (itemData.cubeRotationDirty) {
        itemData.cubeRotationDirty = false;
        updateMvp();
    }

    if (itemData.cubeTextDirty) {
        itemData.cubeTextDirty = false;
        updateCubeTexture();
    }

    QRhiResourceUpdateBatch *resourceUpdates = scene.resourceUpdates;
    if (resourceUpdates)
        scene.resourceUpdates = nullptr;

    const QColor clearColor = QColor::fromRgbF(0.4f, 0.7f, 0.0f, 1.0f);
    cb-&gt;beginPass(renderTarget(), clearColor, { 1.0f, 0 }, resourceUpdates);

    cb-&gt;setGraphicsPipeline(scene.ps.get());
    cb-&gt;setViewport(QRhiViewport(0, 0, m_pixelSize.width(), m_pixelSize.height()));
    cb-&gt;setShaderResources();
    const QRhiCommandBuffer::VertexInput vbufBindings[] = {
        { scene.vbuf.get(), 0 },
        { scene.vbuf.get(), quint32(36 * 3 * sizeof(float)) }
    };
    cb-&gt;setVertexInput(0, 2, vbufBindings);
    cb-&gt;draw(36);

    cb-&gt;endPass();
}
</db:programlisting>
<db:para>How is the user-provided data sent? Take the rotation for example. main() connects to the <db:link xlink:href="qslider.xml">QSlider</db:link>'s <db:link xlink:href="qabstractslider.xml#valueChanged">valueChanged</db:link> signal. When emitted, the connected lamda calls setCubeRotation() on the ExampleRhiWidget. Here, if the value is different from before, it is stored, and a dirty flag is set. Then, most importantly, <db:link xlink:href="qwidget.xml#update">update</db:link>() is called on the ExampleRhiWidget. This is what triggers rendering a new frame into the <db:link xlink:href="qrhiwidget.xml">QRhiWidget</db:link>'s backing texture. Without this the content of the ExampleRhiWidget would not update when dragging the slider.</db:para>
<db:programlisting language="cpp">    void setCubeTextureText(const QString &amp;s)
    {
        if (itemData.cubeText == s)
            return;
        itemData.cubeText = s;
        itemData.cubeTextDirty = true;
        update();
    }

    void setCubeRotation(float r)
    {
        if (itemData.cubeRotation == r)
            return;
        itemData.cubeRotation = r;
        itemData.cubeRotationDirty = true;
        update();
    }
</db:programlisting>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/rhi/cuberhiwidget?h=6.8">Example project @ code.qt.io</db:link></db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qrhi.xml">QRhi</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-rhi-simplerhiwidget-example.xml">Simple RHI Widget Example</db:link></db:member>
<db:member><db:link xlink:href="qtgui-rhiwindow-example.xml">RHI Window Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
