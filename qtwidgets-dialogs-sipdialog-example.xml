<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>SIP Dialog Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The SIP Dialog example shows how to create a dialog that is aware of the Windows Mobile SIP (Software Input Panel) and reacts to it.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/sipdialog-closed.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
<db:td>
<db:para><db:inlinemediaobject>
<db:imageobject>
<db:imagedata fileref="images/sipdialog-opened.png"/>
</db:imageobject>
</db:inlinemediaobject></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Sometimes it is necessary for a dialog to take the SIP into account, as the SIP may hide important input widgets. The SIP Dialog Example shows how a Dialog object, dialog, can be resized accordingly if the SIP is opened, by embedding the contents of dialog in a <db:link xlink:href="qscrollarea.xml">QScrollArea</db:link>.</db:para>
<db:section xml:id="dialog-class-definition">
<db:title>Dialog Class Definition</db:title>
<db:para>The Dialog class is a subclass of <db:link xlink:href="qdialog.xml">QDialog</db:link> that implements a public slot, desktopResized(), and a public function, reactToSIP(). Also, it holds a private instance of <db:link xlink:href="qrect.xml">QRect</db:link>, desktopGeometry.</db:para>
<db:programlisting language="cpp">class Dialog : public QDialog
{
    Q_OBJECT

public:
    Dialog();
    void reactToSIP();

private:
    QRect desktopGeometry;

public slots:
    void desktopResized(int screen);
};
</db:programlisting>
</db:section>
<db:section xml:id="dialog-class-implementation">
<db:title>Dialog Class Implementation</db:title>
<db:para>In the constructor of Dialog, we start by obtaining the available geometry of the screen with <db:link xlink:href="qdesktopwidget.xml#availableGeometry">availableGeometry</db:link>(). The parameter used is 0 to indicate that we require the primary screen.</db:para>
<db:programlisting language="cpp">Dialog::Dialog()
{
    desktopGeometry = QApplication::desktop()-&gt;availableGeometry(0);

    setWindowTitle(tr(&quot;SIP Dialog Example&quot;));
    QScrollArea *scrollArea = new QScrollArea(this);
    QGroupBox *groupBox = new QGroupBox(scrollArea);
    groupBox-&gt;setTitle(tr(&quot;SIP Dialog Example&quot;));
    QGridLayout *gridLayout = new QGridLayout(groupBox);
    groupBox-&gt;setLayout(gridLayout);
</db:programlisting>
<db:para>We set the window's title to &quot;SIP Dialog Example&quot; and declare a <db:link xlink:href="qscrollarea.xml">QScrollArea</db:link> object, scrollArea. Next we instantiate a <db:link xlink:href="qgroupbox.xml">QGroupBox</db:link>, groupBox, with scrollArea as its parent. The title of groupBox is also set to &quot;SIP Dialog Example&quot;. A <db:link xlink:href="qgridlayout.xml">QGridLayout</db:link> object, gridLayout, is then used as groupBox's layout.</db:para>
<db:para>We create a <db:link xlink:href="qlineedit.xml">QLineEdit</db:link>, a <db:link xlink:href="qlabel.xml">QLabel</db:link> and a <db:link xlink:href="qpushbutton.xml">QPushButton</db:link> and we set the <db:link xlink:href="qwidget.xml#minimumWidth-prop">minimumWidth</db:link> property to 220 pixels, respectively.</db:para>
<db:programlisting language="cpp">    QLineEdit* lineEdit = new QLineEdit(groupBox);
    lineEdit-&gt;setText(tr(&quot;Open and close the SIP&quot;));
    lineEdit-&gt;setMinimumWidth(220);

    QLabel* label = new QLabel(groupBox);
    label-&gt;setText(tr(&quot;This dialog resizes if the SIP is opened&quot;));
    label-&gt;setMinimumWidth(220);

    QPushButton* button = new QPushButton(groupBox);
    button-&gt;setText(tr(&quot;Close Dialog&quot;));
    button-&gt;setMinimumWidth(220);
</db:programlisting>
<db:para>Also, all three widgets' text are set accordingly. The <db:link xlink:href="qgridlayout.xml#verticalSpacing-prop">verticalSpacing</db:link> property of gridLayout is set based on the height of desktopGeometry. This is to adapt to the different form factors of Windows Mobile. Then, we add our widgets to the layout.</db:para>
<db:programlisting language="cpp">    if (desktopGeometry.height() &lt; 400)
        gridLayout-&gt;setVerticalSpacing(80);
    else
        gridLayout-&gt;setVerticalSpacing(150);

    gridLayout-&gt;addWidget(label);
    gridLayout-&gt;addWidget(lineEdit);
    gridLayout-&gt;addWidget(button);
</db:programlisting>
<db:para>The scrollArea's widget is set to groupBox. We use a <db:link xlink:href="qhboxlayout.xml">QHBoxLayout</db:link> object, layout, to contain scrollArea. The Dialog's layout is set to layout and the scroll area's horizontal scroll bar is turned off.</db:para>
<db:programlisting language="cpp">    scrollArea-&gt;setWidget(groupBox);
    QHBoxLayout* layout = new QHBoxLayout();
    layout-&gt;addWidget(scrollArea);
    setLayout(layout);
    scrollArea-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
</db:programlisting>
<db:para>The following signals are connected to their respective slots:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>button's <db:link xlink:href="qabstractbutton.xml#pressed">pressed</db:link>() signal to <db:link xlink:href="qapplication.xml">QApplication</db:link>'s <db:link xlink:href="qapplication.xml#closeAllWindows">closeAllWindows</db:link>() slot,</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qdesktopwidget.xml">QDesktopWidget</db:link>'s <db:link xlink:href="qdesktopwidget.xml#workAreaResized">workAreaResized</db:link>() signal to dialog's desktopResized() slot.</db:para>
</db:listitem>
</db:itemizedlist>
<db:programlisting language="cpp">    connect(button, &amp;QAbstractButton::clicked, qApp, &amp;QApplication::closeAllWindows);
    connect(QApplication::desktop(), &amp;QDesktopWidget::workAreaResized,
        this, &amp;Dialog::desktopResized);
}
</db:programlisting>
<db:para>The desktopResized() function accepts an integer, <db:code role="parameter">screen</db:code>, corresponding to the screen's index. We only invoke reactToSIP() if <db:code role="parameter">screen</db:code> is the primary screen (e.g. index = 0).</db:para>
<db:programlisting language="cpp">void Dialog::desktopResized(int screen)
{
    if (screen != 0)
        return;
    reactToSIP();
}
</db:programlisting>
<db:para>The reactToSIP() function resizes dialog accordingly if the desktop's available geometry changed vertically, as this change signifies that the SIP may have been opened or closed.</db:para>
<db:programlisting language="cpp">void Dialog::reactToSIP()
{
    QRect availableGeometry = QApplication::desktop()-&gt;availableGeometry(0);

    if (desktopGeometry != availableGeometry) {
        if (windowState() | Qt::WindowMaximized)
            setWindowState(windowState() &amp; ~Qt::WindowMaximized);

        setGeometry(availableGeometry);
    }

    desktopGeometry = availableGeometry;
}
</db:programlisting>
<db:para>If the height has decreased, we unset the maximized window state. Otherwise, we set the maximized window state. Lastly, we update desktopGeometry to the desktop's available geometry.</db:para>
</db:section>
<db:section xml:id="the-main-function">
<db:title>The main() function</db:title>
<db:para>The main() function for the SIP Dialog example instantiates Dialog and invokes its <db:link xlink:href="qdialog.xml#exec">exec</db:link>() function.</db:para>
<db:programlisting language="cpp">int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    Dialog dialog;
    return dialog.exec();
}
</db:programlisting>
<db:note>
<db:para>Although this example uses a dialog, the techniques used here apply to all top-level widgets respectively.</db:para>
</db:note>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="dialogs/sipdialog/dialog.cpp">dialogs/sipdialog/dialog.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="dialogs/sipdialog/dialog.h">dialogs/sipdialog/dialog.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="dialogs/sipdialog/main.cpp">dialogs/sipdialog/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="dialogs/sipdialog/sipdialog.pro">dialogs/sipdialog/sipdialog.pro</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
