<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Graph Gallery</db:title>
<db:productname>QtDataVis3D</db:productname>
<db:edition>Qt Data Visualization | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Gallery of Bar, Scatter, and Surface graphs.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para><db:emphasis>Graph Gallery</db:emphasis> demonstrates all three graph types and some of their special features. The graphs have their own tabs in the application.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/graphgallery-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:guilabel>Welcome</db:guilabel> mode and select the example from <db:guilabel>Examples</db:guilabel>. For more information, see <db:link xlink:href="https://doc.qt.io/qtcreator/creator-build-example-application.html">Qt Creator: Tutorial: Build and run</db:link>.</db:para>
</db:section>
<db:section xml:id="bar-graph">
<db:title>Bar Graph</db:title>
<db:para>In the <db:guilabel>Bar Graph</db:guilabel> tab, create a 3D bar graph using <db:link xlink:href="q3dbars-qtdatavis.xml">Q3DBars</db:link> and combine the use of widgets to adjust various bar graph qualities. The example shows how to:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Create an application with <db:link xlink:href="q3dbars-qtdatavis.xml">Q3DBars</db:link> and some widgets</db:para>
</db:listitem>
<db:listitem>
<db:para>Use <db:link xlink:href="qbar3dseries-qtdatavis.xml">QBar3DSeries</db:link> and <db:link xlink:href="qbardataproxy-qtdatavis.xml">QBarDataProxy</db:link> to set data to the graph</db:para>
</db:listitem>
<db:listitem>
<db:para>Adjust some graph and series properties using widget controls</db:para>
</db:listitem>
<db:listitem>
<db:para>Select a row or a column by clicking an axis label</db:para>
</db:listitem>
<db:listitem>
<db:para>Create a custom proxy to use with <db:link xlink:href="q3dbars-qtdatavis.xml">Q3DBars</db:link></db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For information about interacting with the graph, see <db:link xlink:href="qtdatavisualization-interacting-with-data.xml">this page</db:link>.</db:para>
<db:section xml:id="creating-the-application">
<db:title>Creating the Application</db:title>
<db:para>First, in <db:code>bargraph.cpp</db:code>, instantiate <db:link xlink:href="q3dbars-qtdatavis.xml">Q3DBars</db:link>:</db:para>
<db:programlisting language="cpp">m_barsGraph = new Q3DBars();
</db:programlisting>
<db:para>Then, create the widget, and horizontal and vertical layouts.</db:para>
<db:para>The graph is embedded in a window container using <db:link xlink:href="qwidget.xml#createWindowContainer">QWidget::createWindowContainer</db:link>(). This is required because all data visualization graph classes (<db:link xlink:href="q3dbars-qtdatavis.xml">Q3DBars</db:link>, <db:link xlink:href="q3dscatter-qtdatavis.xml">Q3DScatter</db:link>, <db:link xlink:href="q3dsurface-qtdatavis.xml">Q3DSurface</db:link>) inherit <db:link xlink:href="qwindow.xml">QWindow</db:link>. This is the only way to use a class inheriting <db:link xlink:href="qwindow.xml">QWindow</db:link> as a widget.</db:para>
<db:para>Add the graph and the vertical layout to the horizontal one:</db:para>
<db:programlisting language="cpp">m_barsWidget = new QWidget;
auto *hLayout = new QHBoxLayout(m_barsWidget);
m_container = QWidget::createWindowContainer(m_barsGraph, m_barsWidget);
m_barsGraph-&gt;resize(minimumGraphSize);
m_container-&gt;setMinimumSize(minimumGraphSize);
m_container-&gt;setMaximumSize(maximumGraphSize);
m_container-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
m_container-&gt;setFocusPolicy(Qt::StrongFocus);
hLayout-&gt;addWidget(m_container, 1);

auto *vLayout = new QVBoxLayout();
hLayout-&gt;addLayout(vLayout);
</db:programlisting>
<db:para>Next, create another class to handle the data addition and other interaction with the graph:</db:para>
<db:programlisting language="cpp">auto *modifier = new GraphModifier(m_barsGraph, this);
</db:programlisting>
</db:section>
<db:section xml:id="setting-up-the-bar-graph">
<db:title>Setting up the Bar Graph</db:title>
<db:para>Set up the graph in the constructor of the <db:code>GraphModifier</db:code> class:</db:para>
<db:programlisting language="cpp">GraphModifier::GraphModifier(Q3DBars *bargraph, QObject *parent) :
      QObject(parent),
      m_graph(bargraph),
</db:programlisting>
<db:para>First, create the axes and the series into member variables to support changing them easily:</db:para>
<db:programlisting language="cpp">m_temperatureAxis(new QValue3DAxis),
m_yearAxis(new QCategory3DAxis),
m_monthAxis(new QCategory3DAxis),
m_primarySeries(new QBar3DSeries),
m_secondarySeries(new QBar3DSeries),
m_celsiusString(u&quot;Â°C&quot;_s)
</db:programlisting>
<db:para>Then, set some visual qualities for the graph:</db:para>
<db:programlisting language="cpp">m_graph-&gt;setShadowQuality(QAbstract3DGraph::ShadowQualitySoftMedium);
m_graph-&gt;activeTheme()-&gt;setBackgroundEnabled(false);
m_graph-&gt;activeTheme()-&gt;setFont(QFont(&quot;Times New Roman&quot;, m_fontSize));
m_graph-&gt;activeTheme()-&gt;setLabelBackgroundEnabled(true);
m_graph-&gt;setMultiSeriesUniform(true);
</db:programlisting>
<db:para>Set up the axes and make them the active axes of the graph:</db:para>
<db:programlisting language="cpp">m_temperatureAxis-&gt;setTitle(&quot;Average temperature&quot;);
m_temperatureAxis-&gt;setSegmentCount(m_segments);
m_temperatureAxis-&gt;setSubSegmentCount(m_subSegments);
m_temperatureAxis-&gt;setRange(m_minval, m_maxval);
m_temperatureAxis-&gt;setLabelFormat(u&quot;%.1f &quot;_s + m_celsiusString);
m_temperatureAxis-&gt;setLabelAutoRotation(30.0f);
m_temperatureAxis-&gt;setTitleVisible(true);

m_yearAxis-&gt;setTitle(&quot;Year&quot;);
m_yearAxis-&gt;setLabelAutoRotation(30.0f);
m_yearAxis-&gt;setTitleVisible(true);
m_monthAxis-&gt;setTitle(&quot;Month&quot;);
m_monthAxis-&gt;setLabelAutoRotation(30.0f);
m_monthAxis-&gt;setTitleVisible(true);

m_graph-&gt;setValueAxis(m_temperatureAxis);
m_graph-&gt;setRowAxis(m_yearAxis);
m_graph-&gt;setColumnAxis(m_monthAxis);
</db:programlisting>
<db:para>Give axis labels a small autorotation angle with setLabelAutoRotation() to make them orient slightly toward the camera. This improves axis label readability at extreme camera angles.</db:para>
<db:para>Next, initialize the visual properties of the series. Note that the second series is initially not visible:</db:para>
<db:programlisting language="cpp">m_primarySeries-&gt;setItemLabelFormat(u&quot;Oulu - @colLabel @rowLabel: @valueLabel&quot;_s);
m_primarySeries-&gt;setMesh(QAbstract3DSeries::MeshBevelBar);
m_primarySeries-&gt;setMeshSmooth(false);

m_secondarySeries-&gt;setItemLabelFormat(u&quot;Helsinki - @colLabel @rowLabel: @valueLabel&quot;_s);
m_secondarySeries-&gt;setMesh(QAbstract3DSeries::MeshBevelBar);
m_secondarySeries-&gt;setMeshSmooth(false);
m_secondarySeries-&gt;setVisible(false);
</db:programlisting>
<db:para>Add the series to the graph:</db:para>
<db:programlisting language="cpp">m_graph-&gt;addSeries(m_primarySeries);
m_graph-&gt;addSeries(m_secondarySeries);
</db:programlisting>
<db:para>Finally, set the camera angle by calling the same method the camera angle change button in the UI uses to cycle through various camera angles:</db:para>
<db:programlisting language="cpp">changePresetCamera();
</db:programlisting>
<db:para>The camera is controlled via the scene object of the graph:</db:para>
<db:programlisting language="cpp">static int preset = Q3DCamera::CameraPresetFront;

m_graph-&gt;scene()-&gt;activeCamera()-&gt;setCameraPreset((Q3DCamera::CameraPreset)preset);

if (++preset &gt; Q3DCamera::CameraPresetDirectlyBelow)
    preset = Q3DCamera::CameraPresetFrontLow;
</db:programlisting>
<db:para>For more information about using scene and cameras, see <db:link xlink:href="q3dscene-qtdatavis.xml">Q3DScene</db:link> and <db:link xlink:href="q3dcamera-qtdatavis.xml">Q3DCamera</db:link>.</db:para>
</db:section>
<db:section xml:id="adding-data-to-the-graph">
<db:title>Adding Data to the Graph</db:title>
<db:para>At the end of the constructor, call a method that sets up the data:</db:para>
<db:programlisting language="cpp">resetTemperatureData();
</db:programlisting>
<db:para>This method adds data to the proxies of the two series:</db:para>
<db:programlisting language="cpp">// Set up data
static const float tempOulu[8][12] = {
    {-7.4f, -2.4f, 0.0f, 3.0f, 8.2f, 11.6f, 14.7f, 15.4f, 11.4f, 4.2f, 2.1f, -2.3f},       // 2015
    {-13.4f, -3.9f, -1.8f, 3.1f, 10.6f, 13.7f, 17.8f, 13.6f, 10.7f, 3.5f, -3.1f, -4.2f},   // 2016
...
auto *dataSet = new QBarDataArray;
auto *dataSet2 = new QBarDataArray;

dataSet-&gt;reserve(m_years.size());
for (qsizetype year = 0; year &lt; m_years.size(); ++year) {
    // Create a data row
    auto *dataRow = new QBarDataRow(m_months.size());
    auto *dataRow2 = new QBarDataRow(m_months.size());
    for (qsizetype month = 0; month &lt; m_months.size(); ++month) {
        // Add data to the row
        (*dataRow)[month].setValue(tempOulu[year][month]);
        (*dataRow2)[month].setValue(tempHelsinki[year][month]);
    }
    // Add the row to the set
    dataSet-&gt;append(dataRow);
    dataSet2-&gt;append(dataRow2);
}

// Add data to the data proxy (the data proxy assumes ownership of it)
m_primarySeries-&gt;dataProxy()-&gt;resetArray(dataSet, m_years, m_months);
m_secondarySeries-&gt;dataProxy()-&gt;resetArray(dataSet2, m_years, m_months);
</db:programlisting>
</db:section>
<db:section xml:id="using-widgets-to-control-the-graph">
<db:title>Using Widgets to Control the Graph</db:title>
<db:para>Continue by adding some widgets in <db:code>bargraph.cpp</db:code>. Add a slider:</db:para>
<db:programlisting language="cpp">auto *rotationSliderX = new QSlider(Qt::Horizontal, m_barsWidget);
rotationSliderX-&gt;setTickInterval(30);
rotationSliderX-&gt;setTickPosition(QSlider::TicksBelow);
rotationSliderX-&gt;setMinimum(-180);
rotationSliderX-&gt;setValue(0);
rotationSliderX-&gt;setMaximum(180);
</db:programlisting>
<db:para>Use the slider to rotate the graph instead of just using a mouse or touch. Add it to the vertical layout:</db:para>
<db:programlisting language="cpp">vLayout-&gt;addWidget(new QLabel(u&quot;Rotate horizontally&quot;_s));
vLayout-&gt;addWidget(rotationSliderX, 0, Qt::AlignTop);
</db:programlisting>
<db:para>Then, connect it to a method in <db:code>GraphModifier</db:code>:</db:para>
<db:programlisting language="cpp">QObject::connect(rotationSliderX, &amp;QSlider::valueChanged, modifier, &amp;GraphModifier::rotateX);
</db:programlisting>
<db:para>Create a slot in <db:code>GraphModifier</db:code> for the signal connection. The camera is controlled via the scene object. This time, specify the actual camera position along the orbit around the center point, instead of specifying a preset camera angle:</db:para>
<db:programlisting language="cpp">void GraphModifier::rotateX(int rotation)
{
    m_xRotation = rotation;
    m_graph-&gt;scene()-&gt;activeCamera()-&gt;setCameraPosition(m_xRotation, m_yRotation);
}
</db:programlisting>
<db:para>You can now use the slider to rotate the graph.</db:para>
<db:para>Add more widgets to the vertical layout to control:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Graph rotation</db:para>
</db:listitem>
<db:listitem>
<db:para>Label style</db:para>
</db:listitem>
<db:listitem>
<db:para>Camera preset</db:para>
</db:listitem>
<db:listitem>
<db:para>Background visibility</db:para>
</db:listitem>
<db:listitem>
<db:para>Grid visibility</db:para>
</db:listitem>
<db:listitem>
<db:para>Bar shading smoothness</db:para>
</db:listitem>
<db:listitem>
<db:para>Visibility of the second bar series</db:para>
</db:listitem>
<db:listitem>
<db:para>Value axis direction</db:para>
</db:listitem>
<db:listitem>
<db:para>Axis title visibility and rotation</db:para>
</db:listitem>
<db:listitem>
<db:para>Data range to be shown</db:para>
</db:listitem>
<db:listitem>
<db:para>Bar style</db:para>
</db:listitem>
<db:listitem>
<db:para>Selection mode</db:para>
</db:listitem>
<db:listitem>
<db:para>Theme</db:para>
</db:listitem>
<db:listitem>
<db:para>Shadow quality</db:para>
</db:listitem>
<db:listitem>
<db:para>Font</db:para>
</db:listitem>
<db:listitem>
<db:para>Font size</db:para>
</db:listitem>
<db:listitem>
<db:para>Axis label rotation</db:para>
</db:listitem>
<db:listitem>
<db:para>Data mode</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Some widget controls are intentionally disabled when in the <db:guilabel>Custom Proxy Data</db:guilabel> data mode.</db:para>
</db:section>
<db:section xml:id="selecting-a-row-or-column-by-clicking-an-axis-label">
<db:title>Selecting a Row or Column by Clicking an Axis Label</db:title>
<db:para>Selection by axis label is default functionality for bar graphs. As an example, you can select rows by clicking an axis label in the following way:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Change selection mode to <db:code>SelectionRow</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para>Click a year label</db:para>
</db:listitem>
<db:listitem>
<db:para>The row with the clicked year is selected</db:para>
</db:listitem>
</db:orderedlist>
<db:para>The same method works with <db:code>SelectionSlice</db:code> and <db:code>SelectionItem</db:code> flags, as long as either <db:code>SelectionRow</db:code> or <db:code>SelectionColumn</db:code> is set as well.</db:para>
</db:section>
<db:section xml:id="zooming-to-selection">
<db:title>Zooming to Selection</db:title>
<db:para>As an example of adjusting the camera target, implement an animation of zooming to selection via a button press. Animation initializations are done in the constructor:</db:para>
<db:programlisting language="cpp">Q3DCamera *camera = m_graph-&gt;scene()-&gt;activeCamera();
m_defaultAngleX = camera-&gt;xRotation();
m_defaultAngleY = camera-&gt;yRotation();
m_defaultZoom = camera-&gt;zoomLevel();
m_defaultTarget = camera-&gt;target();

m_animationCameraX.setTargetObject(camera);
m_animationCameraY.setTargetObject(camera);
m_animationCameraZoom.setTargetObject(camera);
m_animationCameraTarget.setTargetObject(camera);

m_animationCameraX.setPropertyName(&quot;xRotation&quot;);
m_animationCameraY.setPropertyName(&quot;yRotation&quot;);
m_animationCameraZoom.setPropertyName(&quot;zoomLevel&quot;);
m_animationCameraTarget.setPropertyName(&quot;target&quot;);

int duration = 1700;
m_animationCameraX.setDuration(duration);
m_animationCameraY.setDuration(duration);
m_animationCameraZoom.setDuration(duration);
m_animationCameraTarget.setDuration(duration);

// The zoom always first zooms out above the graph and then zooms in
qreal zoomOutFraction = 0.3;
m_animationCameraX.setKeyValueAt(zoomOutFraction, QVariant::fromValue(0.0f));
m_animationCameraY.setKeyValueAt(zoomOutFraction, QVariant::fromValue(90.0f));
m_animationCameraZoom.setKeyValueAt(zoomOutFraction, QVariant::fromValue(50.0f));
m_animationCameraTarget.setKeyValueAt(zoomOutFraction,
                                      QVariant::fromValue(QVector3D(0.0f, 0.0f, 0.0f)));
</db:programlisting>
<db:para>Function <db:code>GraphModifier::zoomToSelectedBar()</db:code> contains the zooming functionality. <db:link xlink:href="qpropertyanimation.xml">QPropertyAnimation</db:link> <db:code>m_animationCameraTarget</db:code> targets <db:link xlink:href="q3dcamera-qtdatavis.xml#target-prop">Q3DCamera::target</db:link> property, which takes a value normalized to the range (-1, 1).</db:para>
<db:para>Figure out where the selected bar is relative to axes, and use that as the end value for <db:code>m_animationCameraTarget</db:code>:</db:para>
<db:programlisting language="cpp">QVector3D endTarget;
float xMin = m_graph-&gt;columnAxis()-&gt;min();
float xRange = m_graph-&gt;columnAxis()-&gt;max() - xMin;
float zMin = m_graph-&gt;rowAxis()-&gt;min();
float zRange = m_graph-&gt;rowAxis()-&gt;max() - zMin;
endTarget.setX((selectedBar.y() - xMin) / xRange * 2.0f - 1.0f);
endTarget.setZ((selectedBar.x() - zMin) / zRange * 2.0f - 1.0f);
...
m_animationCameraTarget.setEndValue(QVariant::fromValue(endTarget));
</db:programlisting>
<db:para>Then, rotate the camera so that it always points approximately to the center of the graph at the end of the animation:</db:para>
<db:programlisting language="cpp">qreal endAngleX = 90.0 - qRadiansToDegrees(qAtan(qreal(endTarget.z() / endTarget.x())));
if (endTarget.x() &gt; 0.0f)
    endAngleX -= 180.0f;
float barValue = m_graph-&gt;selectedSeries()-&gt;dataProxy()-&gt;itemAt(selectedBar.x(),
                                                                selectedBar.y())-&gt;value();
float endAngleY = barValue &gt;= 0.0f ? 30.0f : -30.0f;
if (m_graph-&gt;valueAxis()-&gt;reversed())
    endAngleY *= -1.0f;
</db:programlisting>
</db:section>
<db:section xml:id="custom-proxy-for-data">
<db:title>Custom Proxy for Data</db:title>
<db:para>By toggling <db:guilabel>Custom Proxy Data</db:guilabel> data mode on, a custom dataset and the corresponding proxy are taken into use.</db:para>
<db:para>Define a simple flexible data set, <db:code>VariantDataSet</db:code>, where each data item is a variant list. Each item can have multiple values, identified by their index in the list. In this case, the data set is storing monthly rainfall data, where the value in index zero is the year, the value in index one is the month, and the value in index two is the amount of rainfall in that month.</db:para>
<db:para>The custom proxy is similar to itemmodel-based proxies provided by Qt Data Visualization, and it requires mapping to interpret the data.</db:para>
<db:section xml:id="variantdataset">
<db:title>VariantDataSet</db:title>
<db:para>Define the data items as <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> objects. Add functionality for clearing the data set and querying for a reference to the data contained in the set. Also, add signals to be emitted when data is added or the set is cleared:</db:para>
<db:programlisting language="cpp">using VariantDataItem = QVariantList;
using VariantDataItemList = QList&lt;VariantDataItem *&gt;;
...

void clear();

int addItem(VariantDataItem *item);
int addItems(VariantDataItemList *itemList);

const VariantDataItemList &amp;itemList() const;

Q_SIGNALS:
void itemsAdded(int index, int count);
void dataCleared();
</db:programlisting>
</db:section>
<db:section xml:id="variantbardataproxy">
<db:title>VariantBarDataProxy</db:title>
<db:para>Subclass <db:code>VariantBarDataProxy</db:code> from <db:link xlink:href="qbardataproxy-qtdatavis.xml">QBarDataProxy</db:link> and provide a simple API of getters and setters for the data set and the mapping:</db:para>
<db:programlisting language="cpp">class VariantBarDataProxy : public QBarDataProxy
...

// Doesn't gain ownership of the dataset, but does connect to it to listen for data changes.
void setDataSet(VariantDataSet *newSet);
VariantDataSet *dataSet();

// Map key (row, column, value) to value index in data item (VariantItem).
// Doesn't gain ownership of mapping, but does connect to it to listen for mapping changes.
// Modifying mapping that is set to proxy will trigger dataset re-resolving.
void setMapping(VariantBarDataMapping *mapping);
VariantBarDataMapping *mapping();
</db:programlisting>
<db:para>The proxy listens for the changes in the data set and the mapping, and resolves the data set if any changes are detected. This is not a particularly efficient implementation, as any change will cause re-resolving of the entire data set, but that is not an issue for this example.</db:para>
<db:para>In <db:code>resolveDataSet()</db:code> method, sort the variant data values into rows and columns based on the mapping. This is very similar to how <db:link xlink:href="qitemmodelbardataproxy-qtdatavis.xml">QItemModelBarDataProxy</db:link> handles mapping, except you use list indexes instead of item model roles here. Once the values are sorted, generate <db:code>QBarDataArray</db:code> out of them, and call the <db:code>resetArray()</db:code> method in the parent class:</db:para>
<db:programlisting language="cpp">void VariantBarDataProxy::resolveDataSet()
{
    // If we have no data or mapping, or the categories are not defined, simply clear the array
    if (m_dataSet.isNull() || m_mapping.isNull() || !m_mapping-&gt;rowCategories().size()
            || !m_mapping-&gt;columnCategories().size()) {
        resetArray(nullptr);
        return;
    }
    const VariantDataItemList &amp;itemList = m_dataSet-&gt;itemList();

    int rowIndex = m_mapping-&gt;rowIndex();
    int columnIndex = m_mapping-&gt;columnIndex();
    int valueIndex = m_mapping-&gt;valueIndex();
    const QStringList &amp;rowList = m_mapping-&gt;rowCategories();
    const QStringList &amp;columnList = m_mapping-&gt;columnCategories();

    // Sort values into rows and columns
    using ColumnValueMap = QHash&lt;QString, float&gt;;
    QHash &lt;QString, ColumnValueMap&gt; itemValueMap;
    for (const VariantDataItem *item : itemList) {
        itemValueMap[item-&gt;at(rowIndex).toString()][item-&gt;at(columnIndex).toString()]
                = item-&gt;at(valueIndex).toReal();
    }

    // Create a new data array in format the parent class understands
    auto *newProxyArray = new QBarDataArray;
    for (const QString &amp;rowKey : rowList) {
        auto *newProxyRow = new QBarDataRow(columnList.size());
        for (qsizetype i = 0; i &lt; columnList.size(); ++i)
            (*newProxyRow)[i].setValue(itemValueMap[rowKey][columnList.at(i)]);
        newProxyArray-&gt;append(newProxyRow);
    }

    // Finally, reset the data array in the parent class
    resetArray(newProxyArray);
}
</db:programlisting>
</db:section>
<db:section xml:id="variantbardatamapping">
<db:title>VariantBarDataMapping</db:title>
<db:para>Store the mapping information between <db:code>VariantDataSet</db:code> data item indexes and rows, columns, and values of <db:code>QBarDataArray</db:code> in <db:code>VariantBarDataMapping</db:code>. It contains the lists of rows and columns to be included in the resolved data:</db:para>
<db:programlisting language="cpp">Q_PROPERTY(int rowIndex READ rowIndex WRITE setRowIndex NOTIFY rowIndexChanged)
Q_PROPERTY(int columnIndex READ columnIndex WRITE setColumnIndex NOTIFY columnIndexChanged)
Q_PROPERTY(int valueIndex READ valueIndex WRITE setValueIndex NOTIFY valueIndexChanged)
Q_PROPERTY(QStringList rowCategories READ rowCategories WRITE setRowCategories NOTIFY rowCategoriesChanged)
Q_PROPERTY(QStringList columnCategories READ columnCategories WRITE setColumnCategories NOTIFY columnCategoriesChanged)
...

explicit VariantBarDataMapping(int rowIndex, int columnIndex, int valueIndex,
                               const QStringList &amp;rowCategories,
                               const QStringList &amp;columnCategories);
...

void remap(int rowIndex, int columnIndex, int valueIndex,
           const QStringList &amp;rowCategories,
           const QStringList &amp;columnCategories);
...

void mappingChanged();
</db:programlisting>
<db:para>The primary way to use a <db:code>VariantBarDataMapping</db:code> object is to give the mappings in the constructor, though you can use the <db:code>remap()</db:code> method to set them later, either individually or all together. Emit a signal if mapping changes. The outcome is a simplified version of the mapping functionality of <db:link xlink:href="qitemmodelbardataproxy-qtdatavis.xml">QItemModelBarDataProxy</db:link>, adapted to work with variant lists instead of item models.</db:para>
</db:section>
<db:section xml:id="rainfalldata">
<db:title>RainfallData</db:title>
<db:para>Handle the setup of <db:link xlink:href="qbar3dseries-qtdatavis.xml">QBar3DSeries</db:link> with the custom proxy in the <db:code>RainfallData</db:code> class:</db:para>
<db:programlisting language="cpp">m_proxy = new VariantBarDataProxy;
m_series = new QBar3DSeries(m_proxy);
</db:programlisting>
<db:para>Populate the variant data set in the <db:code>addDataSet()</db:code> method:</db:para>
<db:programlisting language="cpp">void RainfallData::addDataSet()
{
    // Create a new variant data set and data item list
    m_dataSet =  new VariantDataSet;
    auto *itemList = new VariantDataItemList;

    // Read data from a data file into the data item list
    QFile dataFile(&quot;:/data/raindata.txt&quot;);
    if (dataFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
        QTextStream stream(&amp;dataFile);
        while (!stream.atEnd()) {
            QString line = stream.readLine();
            if (line.startsWith('#')) // Ignore comments
                continue;
            const auto strList = QStringView{line}.split(',', Qt::SkipEmptyParts);
            // Each line has three data items: Year, month, and rainfall value
            if (strList.size() &lt; 3) {
                qWarning() &lt;&lt; &quot;Invalid row read from data:&quot; &lt;&lt; line;
                continue;
            }
            // Store year and month as strings, and rainfall value as double
            // into a variant data item and add the item to the item list.
            auto *newItem = new VariantDataItem;
            for (int i = 0; i &lt; 2; ++i)
                newItem-&gt;append(strList.at(i).trimmed().toString());
            newItem-&gt;append(strList.at(2).trimmed().toDouble());
            itemList-&gt;append(newItem);
        }
    } else {
        qWarning() &lt;&lt; &quot;Unable to open data file:&quot; &lt;&lt; dataFile.fileName();
    }
    ...
</db:programlisting>
<db:para>Add the data set to the custom proxy and set the mapping:</db:para>
<db:programlisting language="cpp">// Add items to the data set and set it to the proxy
m_dataSet-&gt;addItems(itemList);
m_proxy-&gt;setDataSet(m_dataSet);

// Create new mapping for the data and set it to the proxy
m_mapping = new VariantBarDataMapping(0, 1, 2, m_years, m_numericMonths);
m_proxy-&gt;setMapping(m_mapping);
</db:programlisting>
<db:para>Finally, add a function for getting the created series for displaying:</db:para>
<db:programlisting language="cpp">QBar3DSeries *customSeries() { return m_series; }
</db:programlisting>
</db:section>
</db:section>
</db:section>
<db:section xml:id="scatter-graph">
<db:title>Scatter Graph</db:title>
<db:para>In the <db:guilabel>Scatter Graph</db:guilabel> tab, create a 3D scatter graph using <db:link xlink:href="q3dscatter-qtdatavis.xml">Q3DScatter</db:link>. The example shows how to:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Set up <db:link xlink:href="q3dscatter-qtdatavis.xml">Q3DScatter</db:link> graph</db:para>
</db:listitem>
<db:listitem>
<db:para>Use <db:link xlink:href="qscatterdataproxy-qtdatavis.xml">QScatterDataProxy</db:link> to set data to the graph</db:para>
</db:listitem>
<db:listitem>
<db:para>Create a custom input handler by extending <db:link xlink:href="q3dinputhandler-qtdatavis.xml">Q3DInputHandler</db:link></db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For basic application creation, see <db:link xlink:href="qtdatavis3d-graphgallery-example.xml#bar-graph">Bar Graph</db:link>.</db:para>
<db:section xml:id="setting-up-the-scatter-graph">
<db:title>Setting up the Scatter Graph</db:title>
<db:para>First, set up some visual qualities for the graph in the constructor of the <db:code>ScatterDataModifier</db:code>:</db:para>
<db:programlisting language="cpp">m_graph-&gt;activeTheme()-&gt;setType(Q3DTheme::ThemeStoneMoss);
m_graph-&gt;setShadowQuality(QAbstract3DGraph::ShadowQualitySoftHigh);
m_graph-&gt;scene()-&gt;activeCamera()-&gt;setCameraPreset(Q3DCamera::CameraPresetFront);
m_graph-&gt;scene()-&gt;activeCamera()-&gt;setZoomLevel(80.f);
</db:programlisting>
<db:para>None of these are mandatory, but are used to override graph defaults. You can try how it looks with the preset defaults by commenting out the block above.</db:para>
<db:para>Next, create a <db:link xlink:href="qscatterdataproxy-qtdatavis.xml">QScatterDataProxy</db:link> and the associated <db:link xlink:href="qscatter3dseries-qtdatavis.xml">QScatter3DSeries</db:link>. Set a custom label format and mesh smoothing for the series and add it to the graph:</db:para>
<db:programlisting language="cpp">auto *proxy = new QScatterDataProxy;
auto *series = new QScatter3DSeries(proxy);
series-&gt;setItemLabelFormat(u&quot;@xTitle: @xLabel @yTitle: @yLabel @zTitle: @zLabel&quot;_s);
series-&gt;setMeshSmooth(m_smooth);
m_graph-&gt;addSeries(series);
</db:programlisting>
</db:section>
<db:section xml:id="adding-scatter-data">
<db:title>Adding Scatter Data</db:title>
<db:para>The last thing to do in the <db:code>ScatterDataModifier</db:code> constructor is to add data to the graph:</db:para>
<db:programlisting language="cpp">addData();
</db:programlisting>
<db:para>The actual data addition is done in <db:code>addData()</db:code> method. First, configure the axes:</db:para>
<db:programlisting language="cpp">m_graph-&gt;axisX()-&gt;setTitle(&quot;X&quot;);
m_graph-&gt;axisY()-&gt;setTitle(&quot;Y&quot;);
m_graph-&gt;axisZ()-&gt;setTitle(&quot;Z&quot;);
</db:programlisting>
<db:para>You could do this also in the constructor of <db:code>ScatterDataModifier</db:code>. Doing it here keeps the constructor simpler and the axes' configuration near the data.</db:para>
<db:para>Next, create a data array and populate it:</db:para>
<db:programlisting language="cpp">auto *dataArray = new QScatterDataArray;
dataArray-&gt;reserve(m_itemCount);
    ...
const float limit = qSqrt(m_itemCount) / 2.0f;
for (int i = -limit; i &lt; limit; ++i) {
    for (int j = -limit; j &lt; limit; ++j) {
        const float x = float(i) + 0.5f;
        const float y = qCos(qDegreesToRadians(float(i * j) / m_curveDivider));
        const float z = float(j) + 0.5f;
        dataArray-&gt;append(QScatterDataItem({x, y, z}));
    }
}
</db:programlisting>
<db:para>Finally, tell the proxy to start using the data we gave it:</db:para>
<db:programlisting language="cpp">m_graph-&gt;seriesList().at(0)-&gt;dataProxy()-&gt;resetArray(dataArray);
</db:programlisting>
<db:para>Now, the graph has the data and is ready for use. For information about adding widgets to control the graph, see <db:link xlink:href="qtdatavis3d-graphgallery-example.xml#using-widgets-to-control-the-graph">Using Widgets to Control the Graph</db:link>.</db:para>
</db:section>
<db:section xml:id="replacing-default-input-handling">
<db:title>Replacing Default Input Handling</db:title>
<db:para>Initialize <db:code>m_inputHandler</db:code> in the constructor with a pointer to the scatter graph instance:</db:para>
<db:programlisting language="cpp">m_inputHandler(new AxesInputHandler(scatter))
</db:programlisting>
<db:para>Replace the default input handling mechanism by setting the active input handler of <db:link xlink:href="q3dscatter-qtdatavis.xml">Q3DScatter</db:link> to <db:code>AxesInputHandler</db:code>, which implements the custom behavior:</db:para>
<db:programlisting language="cpp">// Give ownership of the handler to the graph and make it the active handler
m_graph-&gt;setActiveInputHandler(m_inputHandler);
</db:programlisting>
<db:para>The input handler needs access to the axes of the graph, so pass them to it:</db:para>
<db:programlisting language="cpp">// Give our axes to the input handler
m_inputHandler-&gt;setAxes(m_graph-&gt;axisX(), m_graph-&gt;axisZ(), m_graph-&gt;axisY());
</db:programlisting>
</db:section>
<db:section xml:id="extending-mouse-event-handling">
<db:title>Extending Mouse Event Handling</db:title>
<db:para>First, inherit the custom input handler from <db:link xlink:href="q3dinputhandler-qtdatavis.xml">Q3DInputHandler</db:link> instead of <db:link xlink:href="qabstract3dinputhandler-qtdatavis.xml">QAbstract3DInputHandler</db:link> to keep all the functionality of the default input handling, and to add the custom functionality on top of it:</db:para>
<db:programlisting language="cpp">class AxesInputHandler : public Q3DInputHandler
</db:programlisting>
<db:para>Start extending the default functionality by re-implementing some of the mouse events. First, extend <db:code>mousePressEvent</db:code>. Add a <db:code>m_mousePressed</db:code> flag for the left mouse button to it, and keep the rest of the default functionality:</db:para>
<db:programlisting language="cpp">void AxesInputHandler::mousePressEvent(QMouseEvent *event, const QPoint &amp;mousePos)
{
    Q3DInputHandler::mousePressEvent(event, mousePos);
    if (Qt::LeftButton == event-&gt;button())
        m_mousePressed = true;
}
</db:programlisting>
<db:para>Next, modify <db:code>mouseReleaseEvent</db:code> to clear the flag, and reset the internal state:</db:para>
<db:programlisting language="cpp">void AxesInputHandler::mouseReleaseEvent(QMouseEvent *event, const QPoint &amp;mousePos)
{
    Q3DInputHandler::mouseReleaseEvent(event, mousePos);
    m_mousePressed = false;
    m_state = StateNormal;
}
</db:programlisting>
<db:para>Then, modify <db:code>mouseMoveEvent</db:code>. Check if <db:code>m_mousePressed</db:code> flag is <db:code>true</db:code> and the internal state is something other than <db:code>StateNormal</db:code>. If so, set the input positions for mouse movement distance calculations, and call the axis dragging function (see <db:link xlink:href="qtdatavis3d-graphgallery-example.xml#implementing-axis-dragging">Implementing Axis Dragging</db:link> for details):</db:para>
<db:programlisting language="cpp">void AxesInputHandler::mouseMoveEvent(QMouseEvent *event, const QPoint &amp;mousePos)
{
    // Check if we're trying to drag axis label
    if (m_mousePressed &amp;&amp; m_state != StateNormal) {
        setPreviousInputPos(inputPosition());
        setInputPosition(mousePos);
        handleAxisDragging();
    } else {
        Q3DInputHandler::mouseMoveEvent(event, mousePos);
    }
}
</db:programlisting>
</db:section>
<db:section xml:id="implementing-axis-dragging">
<db:title>Implementing Axis Dragging</db:title>
<db:para>First, start listening to the selection signal from the graph. Do that in the constructor, and connect it to the <db:code>handleElementSelected</db:code> method:</db:para>
<db:programlisting language="cpp">// Connect to the item selection signal from graph
connect(graph, &amp;QAbstract3DGraph::selectedElementChanged, this,
        &amp;AxesInputHandler::handleElementSelected);
</db:programlisting>
<db:para>In <db:code>handleElementSelected</db:code>, check the type of the selection, and set the internal state based on it:</db:para>
<db:programlisting language="cpp">switch (type) {
case QAbstract3DGraph::ElementAxisXLabel:
    m_state = StateDraggingX;
    break;
case QAbstract3DGraph::ElementAxisYLabel:
    m_state = StateDraggingY;
    break;
case QAbstract3DGraph::ElementAxisZLabel:
    m_state = StateDraggingZ;
    break;
default:
    m_state = StateNormal;
    break;
}
</db:programlisting>
<db:para>The actual dragging logic is implemented in the <db:code>handleAxisDragging</db:code> method, which is called from <db:code>mouseMoveEvent</db:code>, if the required conditions are met:</db:para>
<db:programlisting language="cpp">// Check if we're trying to drag axis label
if (m_mousePressed &amp;&amp; m_state != StateNormal) {
</db:programlisting>
<db:para>In <db:code>handleAxisDragging</db:code>, first get the scene orientation from the active camera:</db:para>
<db:programlisting language="cpp">// Get scene orientation from active camera
float xRotation = scene()-&gt;activeCamera()-&gt;xRotation();
float yRotation = scene()-&gt;activeCamera()-&gt;yRotation();
</db:programlisting>
<db:para>Then, calculate the modifiers for mouse movement direction based on the orientation:</db:para>
<db:programlisting language="cpp">// Calculate directional drag multipliers based on rotation
float xMulX = qCos(qDegreesToRadians(xRotation));
float xMulY = qSin(qDegreesToRadians(xRotation));
float zMulX = qSin(qDegreesToRadians(xRotation));
float zMulY = qCos(qDegreesToRadians(xRotation));
</db:programlisting>
<db:para>After that, calculate the mouse movement, and modify it based on the y rotation of the camera:</db:para>
<db:programlisting language="cpp">// Get the drag amount
QPoint move = inputPosition() - previousInputPos();

// Flip the effect of y movement if we're viewing from below
float yMove = (yRotation &lt; 0) ? -move.y() : move.y();
</db:programlisting>
<db:para>Then, apply the moved distance to the correct axis:</db:para>
<db:programlisting language="cpp">// Adjust axes
switch (m_state) {
case StateDraggingX:
    distance = (move.x() * xMulX - yMove * xMulY) / m_speedModifier;
    m_axisX-&gt;setRange(m_axisX-&gt;min() - distance, m_axisX-&gt;max() - distance);
    break;
case StateDraggingZ:
    distance = (move.x() * zMulX + yMove * zMulY) / m_speedModifier;
    m_axisZ-&gt;setRange(m_axisZ-&gt;min() + distance, m_axisZ-&gt;max() + distance);
    break;
case StateDraggingY:
    distance = move.y() / m_speedModifier; // No need to use adjusted y move here
    m_axisY-&gt;setRange(m_axisY-&gt;min() + distance, m_axisY-&gt;max() + distance);
    break;
default:
    break;
}
</db:programlisting>
<db:para>Finally, add a function for setting the dragging speed:</db:para>
<db:programlisting language="cpp">inline void setDragSpeedModifier(float modifier) { m_speedModifier = modifier; }
</db:programlisting>
<db:para>This is needed, as the mouse movement distance is absolute in screen coordinates, and you need to adjust it to the axis range. The larger the value, the slower the dragging will be. Note that in this example, the scene zoom level is not taken into account when determining the drag speed, so you'll notice changes in the range adjustment as you change the zoom level.</db:para>
<db:para>You could also adjust the modifier automatically based on the axis range and camera zoom level.</db:para>
</db:section>
</db:section>
<db:section xml:id="surface-graph">
<db:title>Surface Graph</db:title>
<db:para>In the <db:guilabel>Surface Graph</db:guilabel> tab, create a 3D surface graph using <db:link xlink:href="q3dsurface-qtdatavis.xml">Q3DSurface</db:link>. The example shows how to:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Set up a basic <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml">QSurfaceDataProxy</db:link> and set data for it.</db:para>
</db:listitem>
<db:listitem>
<db:para>Use <db:link xlink:href="qheightmapsurfacedataproxy-qtdatavis.xml">QHeightMapSurfaceDataProxy</db:link> for showing 3D height maps.</db:para>
</db:listitem>
<db:listitem>
<db:para>Use topographic data to create 3D height maps.</db:para>
</db:listitem>
<db:listitem>
<db:para>Use three different selection modes for studying the graph.</db:para>
</db:listitem>
<db:listitem>
<db:para>Use axis ranges to display selected portions of the graph.</db:para>
</db:listitem>
<db:listitem>
<db:para>Set a custom surface gradient.</db:para>
</db:listitem>
<db:listitem>
<db:para>Add custom items and labels with <db:link xlink:href="qcustom3ditem-qtdatavis.xml">QCustom3DItem</db:link> and <db:link xlink:href="qcustom3dlabel-qtdatavis.xml">QCustom3DLabel</db:link>.</db:para>
</db:listitem>
<db:listitem>
<db:para>Use custom input handler to enable zooming and panning.</db:para>
</db:listitem>
<db:listitem>
<db:para>Highlight an area of the surface.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For basic application creation, see <db:link xlink:href="qtdatavis3d-graphgallery-example.xml#bar-graph">Bar Graph</db:link>.</db:para>
<db:section xml:id="simple-surface-with-generated-data">
<db:title>Simple Surface with Generated Data</db:title>
<db:para>First, instantiate a new <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml">QSurfaceDataProxy</db:link> and attach it to a new <db:link xlink:href="qsurface3dseries-qtdatavis.xml">QSurface3DSeries</db:link>:</db:para>
<db:programlisting language="cpp">m_sqrtSinProxy = new QSurfaceDataProxy();
m_sqrtSinSeries = new QSurface3DSeries(m_sqrtSinProxy);
</db:programlisting>
<db:para>Then, fill the proxy with a simple square root and sine wave data. Create a new <db:code>QSurfaceDataArray</db:code> instance, and add <db:code>QSurfaceDataRow</db:code> elements to it. Set the created <db:code>QSurfaceDataArray</db:code> as the data array for the <db:link xlink:href="qsurfacedataproxy-qtdatavis.xml">QSurfaceDataProxy</db:link> by calling <db:code>resetArray()</db:code>.</db:para>
<db:programlisting language="cpp">auto *dataArray = new QSurfaceDataArray;
dataArray-&gt;reserve(sampleCountZ);
for (int i = 0 ; i &lt; sampleCountZ ; ++i) {
    auto *newRow = new QSurfaceDataRow;
    newRow-&gt;reserve(sampleCountX);
    // Keep values within range bounds, since just adding step can cause minor drift due
    // to the rounding errors.
    float z = qMin(sampleMax, (i * stepZ + sampleMin));
    for (int j = 0; j &lt; sampleCountX; ++j) {
        float x = qMin(sampleMax, (j * stepX + sampleMin));
        float R = qSqrt(z * z + x * x) + 0.01f;
        float y = (qSin(R) / R + 0.24f) * 1.61f;
        newRow-&gt;append(QSurfaceDataItem({x, y, z}));
    }
    dataArray-&gt;append(newRow);
}

m_sqrtSinProxy-&gt;resetArray(dataArray);
</db:programlisting>
</db:section>
<db:section xml:id="multiseries-height-map-data">
<db:title>Multiseries Height Map Data</db:title>
<db:para>Create the height map by instantiating a <db:link xlink:href="qheightmapsurfacedataproxy-qtdatavis.xml">QHeightMapSurfaceDataProxy</db:link> with a <db:link xlink:href="qimage.xml">QImage</db:link> containing the height data. Use <db:link xlink:href="qheightmapsurfacedataproxy-qtdatavis.xml#setValueRanges">QHeightMapSurfaceDataProxy::setValueRanges</db:link>() to define the value range of the map. In the example, the map is from an imaginary position of 34.0Â° N - 40.0Â° N and 18.0Â° E - 24.0Â° E. These values are used to position the map on the axes.</db:para>
<db:programlisting language="cpp">// Create the first surface layer
QImage heightMapImageOne(&quot;:/data/layer_1.png&quot;);
m_heightMapProxyOne = new QHeightMapSurfaceDataProxy(heightMapImageOne);
m_heightMapSeriesOne = new QSurface3DSeries(m_heightMapProxyOne);
m_heightMapSeriesOne-&gt;setItemLabelFormat(u&quot;(@xLabel, @zLabel): @yLabel&quot;_s);
m_heightMapProxyOne-&gt;setValueRanges(34.f, 40.f, 18.f, 24.f);
</db:programlisting>
<db:para>Add the other surface layers the same way, by creating a proxy and a series for them using height map images.</db:para>
</db:section>
<db:section xml:id="topographic-map-data">
<db:title>Topographic Map Data</db:title>
<db:para>The topographic data is obtained from the National Land Survey of Finland. It provides a product called <db:code>Elevation Model 2 m</db:code>, which is suitable for this example. The topography data is from Levi fell. The accuracy of the data is well beyond the need, and therefore it is compressed and encoded into a PNG file. The height value of the original ASCII data is encoded into RGB format using a multiplier, which you will see later in a code extract. The multiplier is calculated by dividing the largest 24-bit value with the highest point in Finland.</db:para>
<db:para><db:link xlink:href="qheightmapsurfacedataproxy-qtdatavis.xml">QHeightMapSurfaceDataProxy</db:link> converts only one-byte values. To utilize the higher accuracy of the data from the National Land Survey of Finland, read the data from the PNG file and decode it into <db:link xlink:href="qsurface3dseries-qtdatavis.xml">QSurface3DSeries</db:link>.</db:para>
<db:para>First, define the encoding multiplier:</db:para>
<db:programlisting language="cpp">// Value used to encode height data as RGB value on PNG file
const float packingFactor = 11983.f;
</db:programlisting>
<db:para>Then, perform the actual decoding:</db:para>
<db:programlisting language="cpp">QImage heightMapImage(file);
uchar *bits = heightMapImage.bits();
int imageHeight = heightMapImage.height();
int imageWidth = heightMapImage.width();
int widthBits = imageWidth * 4;
float stepX = width / float(imageWidth);
float stepZ = height / float(imageHeight);

auto *dataArray = new QSurfaceDataArray;
dataArray-&gt;reserve(imageHeight);
for (int i = 0; i &lt; imageHeight; ++i) {
    int p = i * widthBits;
    float z = height - float(i) * stepZ;
    auto *newRow = new QSurfaceDataRow;
    newRow-&gt;reserve(imageWidth);
    for (int j = 0; j &lt; imageWidth; ++j) {
        uchar aa = bits[p + 0];
        uchar rr = bits[p + 1];
        uchar gg = bits[p + 2];
        uint color = uint((gg &lt;&lt; 16) + (rr &lt;&lt; 8) + aa);
        float y = float(color) / packingFactor;
        newRow-&gt;append(QSurfaceDataItem({float(j) * stepX, y, z}));
        p += 4;
    }
    dataArray-&gt;append(newRow);
}

dataProxy()-&gt;resetArray(dataArray);
</db:programlisting>
<db:para>Now, the data is usable by the proxy.</db:para>
</db:section>
<db:section xml:id="selecting-the-data-set">
<db:title>Selecting the Data Set</db:title>
<db:para>To demonstrate different proxies, <db:guilabel>Surface Graph</db:guilabel> has three radio buttons to switch between the series.</db:para>
<db:para>With <db:guilabel>Sqrt &amp; Sin</db:guilabel>, the simple generated series is activated. First, set the decorative features, such as enabling the grid for the surface, and selecting the flat shading mode. Next, define the axis label format and value ranges. Set automatic label rotation to improve label readability at low camera angles. Finally, make sure the correct series is added to the graph and the others are not:</db:para>
<db:programlisting language="cpp">m_sqrtSinSeries-&gt;setDrawMode(QSurface3DSeries::DrawSurfaceAndWireframe);
m_sqrtSinSeries-&gt;setFlatShadingEnabled(true);

m_graph-&gt;axisX()-&gt;setLabelFormat(&quot;%.2f&quot;);
m_graph-&gt;axisZ()-&gt;setLabelFormat(&quot;%.2f&quot;);
m_graph-&gt;axisX()-&gt;setRange(sampleMin, sampleMax);
m_graph-&gt;axisY()-&gt;setRange(0.f, 2.f);
m_graph-&gt;axisZ()-&gt;setRange(sampleMin, sampleMax);
m_graph-&gt;axisX()-&gt;setLabelAutoRotation(30.f);
m_graph-&gt;axisY()-&gt;setLabelAutoRotation(90.f);
m_graph-&gt;axisZ()-&gt;setLabelAutoRotation(30.f);

m_graph-&gt;removeSeries(m_heightMapSeriesOne);
m_graph-&gt;removeSeries(m_heightMapSeriesTwo);
m_graph-&gt;removeSeries(m_heightMapSeriesThree);
m_graph-&gt;removeSeries(m_topography);
m_graph-&gt;removeSeries(m_highlight);

m_graph-&gt;addSeries(m_sqrtSinSeries);
</db:programlisting>
<db:para>With <db:guilabel>Multiseries Height Map</db:guilabel>, the height map series are activated and others disabled. Auto-adjusting Y-axis range works well for the height map surface, so ensure it is set.</db:para>
<db:programlisting language="cpp">m_graph-&gt;axisY()-&gt;setAutoAdjustRange(true);
</db:programlisting>
<db:para>With <db:guilabel>Textured Topography</db:guilabel>, the topographic series is activated and others disabled. Activate a custom input handler for this series, to be able to highlight areas on it:</db:para>
<db:programlisting language="cpp">m_graph-&gt;setActiveInputHandler(m_customInputHandler);
</db:programlisting>
<db:para>See <db:link xlink:href="qtdatavis3d-graphgallery-example.xml#use-custom-input-handler-to-enable-zooming-and-panning">Use Custom Input Handler to Enable Zooming and Panning</db:link> for information about the custom input handler for this data set.</db:para>
</db:section>
<db:section xml:id="selection-modes">
<db:title>Selection Modes</db:title>
<db:para>The three selection modes supported by <db:link xlink:href="q3dsurface-qtdatavis.xml">Q3DSurface</db:link> can be used with radio buttons. To activate the selected mode or to clear it, add the following inline methods:</db:para>
<db:programlisting language="cpp">void toggleModeNone() { m_graph-&gt;setSelectionMode(QAbstract3DGraph::SelectionNone); }
void toggleModeItem() { m_graph-&gt;setSelectionMode(QAbstract3DGraph::SelectionItem); }
void toggleModeSliceRow() { m_graph-&gt;setSelectionMode(QAbstract3DGraph::SelectionItemAndRow
                                                      | QAbstract3DGraph::SelectionSlice
                                                      | QAbstract3DGraph::SelectionMultiSeries); }
void toggleModeSliceColumn() { m_graph-&gt;setSelectionMode(QAbstract3DGraph::SelectionItemAndColumn
                                                         | QAbstract3DGraph::SelectionSlice
                                                         | QAbstract3DGraph::SelectionMultiSeries); }
</db:programlisting>
<db:para>Add <db:code>QAbstract3DGraph::SelectionSlice</db:code> and <db:code>QAbstract3DGraph::SelectionMultiSeries</db:code> flags for the row and column selection modes to support doing a slice selection to all visible series in the graph simultaneously.</db:para>
</db:section>
<db:section xml:id="axis-ranges-for-studying-the-graph">
<db:title>Axis Ranges for Studying the Graph</db:title>
<db:para>The example has four slider controls for adjusting the min and max values for X and Z axes. When selecting the proxy, these sliders are adjusted to match the axis ranges of the current data set:</db:para>
<db:programlisting language="cpp">// Reset range sliders for Sqrt &amp; Sin
m_rangeMinX = sampleMin;
m_rangeMinZ = sampleMin;
m_stepX = (sampleMax - sampleMin) / float(sampleCountX - 1);
m_stepZ = (sampleMax - sampleMin) / float(sampleCountZ - 1);
m_axisMinSliderX-&gt;setMinimum(0);
m_axisMinSliderX-&gt;setMaximum(sampleCountX - 2);
m_axisMinSliderX-&gt;setValue(0);
m_axisMaxSliderX-&gt;setMinimum(1);
m_axisMaxSliderX-&gt;setMaximum(sampleCountX - 1);
m_axisMaxSliderX-&gt;setValue(sampleCountX - 1);
m_axisMinSliderZ-&gt;setMinimum(0);
m_axisMinSliderZ-&gt;setMaximum(sampleCountZ - 2);
m_axisMinSliderZ-&gt;setValue(0);
m_axisMaxSliderZ-&gt;setMinimum(1);
m_axisMaxSliderZ-&gt;setMaximum(sampleCountZ - 1);
m_axisMaxSliderZ-&gt;setValue(sampleCountZ - 1);
</db:programlisting>
<db:para>Add support for setting the X range from the widget controls to the graph:</db:para>
<db:programlisting language="cpp">void SurfaceGraphModifier::setAxisXRange(float min, float max)
{
    m_graph-&gt;axisX()-&gt;setRange(min, max);
}
</db:programlisting>
<db:para>Add the support for Z range the same way.</db:para>
</db:section>
<db:section xml:id="custom-surface-gradients">
<db:title>Custom Surface Gradients</db:title>
<db:para>With the <db:guilabel>Sqrt &amp; Sin</db:guilabel> data set, custom surface gradients can be taken into use with two push buttons. Define the gradient with <db:link xlink:href="qlineargradient.xml">QLinearGradient</db:link>, where the desired colors are set. Also, change the color style to <db:link xlink:href="q3dtheme-qtdatavis.xml#ColorStyle-enum">Q3DTheme::ColorStyleRangeGradient</db:link> to use the gradient.</db:para>
<db:programlisting language="cpp">QLinearGradient gr;
gr.setColorAt(0.f, Qt::black);
gr.setColorAt(0.33f, Qt::blue);
gr.setColorAt(0.67f, Qt::red);
gr.setColorAt(1.f, Qt::yellow);

m_sqrtSinSeries-&gt;setBaseGradient(gr);
m_sqrtSinSeries-&gt;setColorStyle(Q3DTheme::ColorStyleRangeGradient);
</db:programlisting>
</db:section>
<db:section xml:id="adding-custom-meshes-to-the-application">
<db:title>Adding Custom Meshes to the Application</db:title>
<db:para>Add the mesh files to <db:code>CMakeLists.txt</db:code> for cmake build:</db:para>
<db:programlisting language="cpp" role="bad">set(graphgallery_resource_files
    ...
    &quot;data/oilrig.obj&quot;
    &quot;data/pipe.obj&quot;
    &quot;data/refinery.obj&quot;
    ...
)

qt6_add_resources(graphgallery &quot;graphgallery&quot;
    PREFIX
        &quot;/&quot;
    FILES
        ${graphgallery_resource_files}
)
</db:programlisting>
<db:para>Also, add them in the qrc resource file for use with qmake:</db:para>
<db:programlisting language="cpp" role="bad">&lt;RCC&gt;
    &lt;qresource prefix=&quot;/&quot;&gt;
        ...
        &lt;file&gt;data/refinery.obj&lt;/file&gt;
        &lt;file&gt;data/oilrig.obj&lt;/file&gt;
        &lt;file&gt;data/pipe.obj&lt;/file&gt;
        ...
    &lt;/qresource&gt;
&lt;/RCC&gt;
</db:programlisting>
</db:section>
<db:section xml:id="adding-custom-item-to-a-graph">
<db:title>Adding Custom Item to a Graph</db:title>
<db:para>With the <db:guilabel>Multiseries Height Map</db:guilabel> data set, custom items are inserted into the graph and can be toggled on or off using checkboxes. Other visual qualities can also be controlled with another set of checkboxes, including see-through for the two top layers, and a highlight for the bottom layer.</db:para>
<db:para>Begin by creating a small <db:link xlink:href="qimage.xml">QImage</db:link>. Fill it with a single color to use as the color for the custom object:</db:para>
<db:programlisting language="cpp">QImage color = QImage(2, 2, QImage::Format_RGB32);
color.fill(Qt::red);
</db:programlisting>
<db:para>Then, specify the position of the item in a variable. The position can then be used for removing the correct item from the graph:</db:para>
<db:programlisting language="cpp">QVector3D positionOne = QVector3D(39.f, 77.f, 19.2f);
</db:programlisting>
<db:para>Then, create a new <db:link xlink:href="qcustom3ditem-qtdatavis.xml">QCustom3DItem</db:link> with all the parameters:</db:para>
<db:programlisting language="cpp">auto *item = new QCustom3DItem(&quot;:/data/oilrig.obj&quot;, positionOne,
                               QVector3D(0.025f, 0.025f, 0.025f),
                               QQuaternion::fromAxisAndAngle(0.f, 1.f, 0.f, 45.f),
                               color);
</db:programlisting>
<db:para>Finally, add the item to the graph:</db:para>
<db:programlisting language="cpp">m_graph-&gt;addCustomItem(item);
</db:programlisting>
</db:section>
<db:section xml:id="adding-custom-label-to-a-graph">
<db:title>Adding Custom Label to a Graph</db:title>
<db:para>Adding a custom label is very similar to adding a custom item. For the label, a custom mesh is not needed, but just a <db:link xlink:href="qcustom3dlabel-qtdatavis.xml">QCustom3DLabel</db:link> instance:</db:para>
<db:programlisting language="cpp">auto *label = new QCustom3DLabel();
label-&gt;setText(&quot;Oil Rig One&quot;);
label-&gt;setPosition(positionOneLabel);
label-&gt;setScaling(QVector3D(1.f, 1.f, 1.f));
m_graph-&gt;addCustomItem(label);
</db:programlisting>
</db:section>
<db:section xml:id="removing-custom-item-from-a-graph">
<db:title>Removing Custom Item from a Graph</db:title>
<db:para>To remove a specific item from the graph, call <db:code>removeCustomItemAt()</db:code> with the position of the item:</db:para>
<db:programlisting language="cpp">m_graph-&gt;removeCustomItemAt(positionOne);
</db:programlisting>
<db:note>
<db:para>Removing a custom item from the graph also deletes the object. If you want to preserve the item, use the <db:code>releaseCustomItem()</db:code> method instead.</db:para>
</db:note>
</db:section>
<db:section xml:id="texture-to-a-surface-series">
<db:title>Texture to a Surface Series</db:title>
<db:para>With the <db:guilabel>Textured Topography</db:guilabel> data set, create a map texture to be used with the topographic height map.</db:para>
<db:para>Set an image to be used as the texture on a surface with <db:link xlink:href="qsurface3dseries-qtdatavis.xml#textureFile-prop">QSurface3DSeries::setTextureFile</db:link>(). Add a check box to control if the texture is set or not, and a handler to react to the checkbox state:</db:para>
<db:programlisting language="cpp">void SurfaceGraphModifier::toggleSurfaceTexture(bool enable)
{
    if (enable)
        m_topography-&gt;setTextureFile(&quot;:/data/maptexture.jpg&quot;);
    else
        m_topography-&gt;setTextureFile(&quot;&quot;);
}
</db:programlisting>
<db:para>The image in this example is read from a JPG file. Setting an empty file with the method clears the texture, and the surface uses the gradients or colors from the theme.</db:para>
</db:section>
<db:section xml:id="use-custom-input-handler-to-enable-zooming-and-panning">
<db:title>Use Custom Input Handler to Enable Zooming and Panning</db:title>
<db:para>With the <db:guilabel>Textured Topography</db:guilabel> data set, create a custom input handler to highlight the selection on the graph and allow panning the graph.</db:para>
<db:para>The panning implementation is similar to the one shown in <db:link xlink:href="qtdatavis3d-graphgallery-example.xml#implementing-axis-dragging">Implementing Axis Dragging</db:link>. The difference is that, in this example, you follow only the X and Z axes and don't allow dragging the surface outside the graph. To limit the dragging, follow the limits of the axes and do nothing if going outside the graph:</db:para>
<db:programlisting language="cpp">case StateDraggingX:
    distance = (move.x() * xMulX - move.y() * xMulY) * m_speedModifier;
    m_axisXMinValue -= distance;
    m_axisXMaxValue -= distance;
    if (m_axisXMinValue &lt; m_areaMinValue) {
        float dist = m_axisXMaxValue - m_axisXMinValue;
        m_axisXMinValue = m_areaMinValue;
        m_axisXMaxValue = m_axisXMinValue + dist;
    }
    if (m_axisXMaxValue &gt; m_areaMaxValue) {
        float dist = m_axisXMaxValue - m_axisXMinValue;
        m_axisXMaxValue = m_areaMaxValue;
        m_axisXMinValue = m_axisXMaxValue - dist;
    }
    m_axisX-&gt;setRange(m_axisXMinValue, m_axisXMaxValue);
    break;
</db:programlisting>
<db:para>For zooming, catch the <db:code>wheelEvent</db:code> and adjust the X and Y axis ranges according to the delta value on <db:link xlink:href="qwheelevent.xml">QWheelEvent</db:link>. Adjust the Y axis so that the aspect ratio between the Y axis and the XZ plane stays the same. This prevents getting a graph in which the height is exaggerated:</db:para>
<db:programlisting language="cpp">void CustomInputHandler::wheelEvent(QWheelEvent *event)
{
    float delta = float(event-&gt;angleDelta().y());

    m_axisXMinValue += delta;
    m_axisXMaxValue -= delta;
    m_axisZMinValue += delta;
    m_axisZMaxValue -= delta;
    checkConstraints();

    float y = (m_axisXMaxValue - m_axisXMinValue) * m_aspectRatio;

    m_axisX-&gt;setRange(m_axisXMinValue, m_axisXMaxValue);
    m_axisY-&gt;setRange(100.f, y);
    m_axisZ-&gt;setRange(m_axisZMinValue, m_axisZMaxValue);
}
</db:programlisting>
<db:para>Next, add some limits to the zoom level, so that it won't get too near to or far from the surface. For instance, if the value for the X axis gets below the allowed limit, i.e. zooming gets too far, the value is set to the minimum allowed value. If the range is going to below the range minimum, both ends of the axis are adjusted so that the range stays at the limit:</db:para>
<db:programlisting language="cpp">if (m_axisXMinValue &lt; m_areaMinValue)
    m_axisXMinValue = m_areaMinValue;
if (m_axisXMaxValue &gt; m_areaMaxValue)
    m_axisXMaxValue = m_areaMaxValue;
// Don't allow too much zoom in
if ((m_axisXMaxValue - m_axisXMinValue) &lt; m_axisXMinRange) {
    float adjust = (m_axisXMinRange - (m_axisXMaxValue - m_axisXMinValue)) / 2.f;
    m_axisXMinValue -= adjust;
    m_axisXMaxValue += adjust;
}
</db:programlisting>
</db:section>
<db:section xml:id="highlight-an-area-of-the-surface">
<db:title>Highlight an Area of the Surface</db:title>
<db:para>To implement a highlight to be displayed on the surface, create a copy of the series and add some offset to the y value. In this example, the class <db:code>HighlightSeries</db:code> implements the creation of the copy in its <db:code>handlePositionChange</db:code> method.</db:para>
<db:para>First, give <db:code>HighlightSeries</db:code> the pointer to the original series, and then start listening to the <db:link xlink:href="qsurface3dseries-qtdatavis.xml#selectedPoint-prop">QSurface3DSeries::selectedPointChanged</db:link> signal:</db:para>
<db:programlisting language="cpp">void HighlightSeries::setTopographicSeries(TopographicSeries *series)
{
    m_topographicSeries = series;
    m_srcWidth = m_topographicSeries-&gt;dataProxy()-&gt;array()-&gt;at(0)-&gt;size();
    m_srcHeight = m_topographicSeries-&gt;dataProxy()-&gt;array()-&gt;size();

    QObject::connect(m_topographicSeries, &amp;QSurface3DSeries::selectedPointChanged,
                     this, &amp;HighlightSeries::handlePositionChange);
}
</db:programlisting>
<db:para>When the signal triggers, check that the position is valid. Then, calculate the ranges for the copied area, and check that they stay within the bounds. Finally, fill the data array of the highlight series with the range from the data array of the topography series:</db:para>
<db:programlisting language="cpp">void HighlightSeries::handlePositionChange(const QPoint &amp;position)
{
    m_position = position;

    if (position == invalidSelectionPosition()) {
        setVisible(false);
        return;
    }

    int halfWidth = m_width / 2;
    int halfHeight = m_height / 2;

    int startX = position.y() - halfWidth;
    if (startX &lt; 0 )
        startX = 0;
    int endX = position.y() + halfWidth;
    if (endX &gt; (m_srcWidth - 1))
        endX = m_srcWidth - 1;
    int startZ = position.x() - halfHeight;
    if (startZ &lt; 0 )
        startZ = 0;
    int endZ = position.x() + halfHeight;
    if (endZ &gt; (m_srcHeight - 1))
        endZ = m_srcHeight - 1;

    QSurfaceDataProxy *srcProxy = m_topographicSeries-&gt;dataProxy();
    const QSurfaceDataArray &amp;srcArray = *srcProxy-&gt;array();

    auto *dataArray = new QSurfaceDataArray;
    dataArray-&gt;reserve(endZ - startZ);
    for (int i = startZ; i &lt; endZ; ++i) {
        auto *newRow = new QSurfaceDataRow;
        newRow-&gt;reserve(endX - startX);
        QSurfaceDataRow *srcRow = srcArray.at(i);
        for (int j = startX; j &lt; endX; ++j) {
            QVector3D pos = srcRow-&gt;at(j).position();
            pos.setY(pos.y() + 0.1f);
            newRow-&gt;append(QSurfaceDataItem(pos));
        }
        dataArray-&gt;append(newRow);
    }

    dataProxy()-&gt;resetArray(dataArray);
    setVisible(true);
}
</db:programlisting>
</db:section>
<db:section xml:id="a-gradient-to-the-highlight-series">
<db:title>A Gradient to the Highlight Series</db:title>
<db:para>Since the <db:code>HighlightSeries</db:code> is <db:link xlink:href="qsurface3dseries-qtdatavis.xml">QSurface3DSeries</db:link>, all the decoration methods a series can have are available. In this example, add a gradient to emphasize the elevation. Because the suitable gradient style depends on the range of the Y axis and we change the range when zooming, the gradient color positions need to be adjusted as the range changes. Do this by defining proportional values for the gradient color positions:</db:para>
<db:programlisting language="cpp">const float darkRedPos = 1.f;
const float redPos = 0.8f;
const float yellowPos = 0.6f;
const float greenPos = 0.4f;
const float darkGreenPos = 0.2f;
</db:programlisting>
<db:para>The gradient modification is done in the <db:code>handleGradientChange</db:code> method, so connect it to react to changes on the Y axis:</db:para>
<db:programlisting language="cpp">QObject::connect(m_graph-&gt;axisY(), &amp;QValue3DAxis::maxChanged,
                 m_highlight, &amp;HighlightSeries::handleGradientChange);
</db:programlisting>
<db:para>When a change in the Y axis max value happens, calculate the new gradient color positions:</db:para>
<db:programlisting language="cpp">void HighlightSeries::handleGradientChange(float value)
{
    float ratio = m_minHeight / value;

    QLinearGradient gr;
    gr.setColorAt(0.f, Qt::black);
    gr.setColorAt(darkGreenPos * ratio, Qt::darkGreen);
    gr.setColorAt(greenPos * ratio, Qt::green);
    gr.setColorAt(yellowPos * ratio, Qt::yellow);
    gr.setColorAt(redPos * ratio, Qt::red);
    gr.setColorAt(darkRedPos * ratio, Qt::darkRed);

    setBaseGradient(gr);
    setColorStyle(Q3DTheme::ColorStyleRangeGradient);
}
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="example-contents">
<db:title>Example Contents</db:title>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtdatavis3d.git/tree/examples/datavisualization/graphgallery?h=6.8">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:section>
</db:article>
