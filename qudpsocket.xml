<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QUdpSocket Class</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> class provides a UDP socket.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QUdpSocket</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += network</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qabstractsocket.xml" xlink:role="class">QAbstractSocket</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QUdpSocket is part of <db:simplelist><db:member><db:link xlink:href="network.xml">Network Programming API</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>UDP (User Datagram Protocol) is a lightweight, unreliable, datagram-oriented, connectionless protocol. It can be used when reliability isn't important. <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> is a subclass of <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> that allows you to send and receive UDP datagrams.</db:para>
<db:para>The most common way to use this class is to bind to an address and port using <db:link xlink:href="qabstractsocket.xml#bind">bind</db:link>(), then call <db:link xlink:href="qudpsocket.xml#writeDatagram">writeDatagram</db:link>() and <db:link xlink:href="qudpsocket.xml#readDatagram">readDatagram</db:link>() to transfer data. If you want to use the standard <db:link xlink:href="qiodevice.xml">QIODevice</db:link> functions <db:link xlink:href="qiodevice.xml#read">read</db:link>(), <db:link xlink:href="qiodevice.xml#readLine">readLine</db:link>(), <db:link xlink:href="qiodevice.xml#write">write</db:link>(), etc., you must first connect the socket directly to a peer by calling <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>().</db:para>
<db:para>The socket emits the <db:link xlink:href="qiodevice.xml#bytesWritten">bytesWritten</db:link>() signal every time a datagram is written to the network. If you just want to send datagrams, you don't need to call <db:link xlink:href="qabstractsocket.xml#bind">bind</db:link>().</db:para>
<db:para>The <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal is emitted whenever datagrams arrive. In that case, <db:link xlink:href="qudpsocket.xml#hasPendingDatagrams">hasPendingDatagrams</db:link>() returns true. Call <db:link xlink:href="qudpsocket.xml#pendingDatagramSize">pendingDatagramSize</db:link>() to obtain the size of the first pending datagram, and <db:link xlink:href="qudpsocket.xml#readDatagram">readDatagram</db:link>() to read it.</db:para>
<db:note>
<db:para>An incoming datagram should be read when you receive the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal, otherwise this signal will not be emitted for the next datagram.</db:para>
</db:note>
<db:para>Example:</db:para>
<db:programlisting language="cpp">void Server::initSocket()
{
    udpSocket = new QUdpSocket(this);
    udpSocket-&gt;bind(QHostAddress::LocalHost, 7755);

    connect(udpSocket, SIGNAL(readyRead()),
            this, SLOT(readPendingDatagrams()));
}

void Server::readPendingDatagrams()
{
    while (udpSocket-&gt;hasPendingDatagrams()) {
        QByteArray datagram;
        datagram.resize(udpSocket-&gt;pendingDatagramSize());
        QHostAddress sender;
        quint16 senderPort;

        udpSocket-&gt;readDatagram(datagram.data(), datagram.size(),
                                &amp;sender, &amp;senderPort);

        processTheDatagram(datagram);
    }
}
</db:programlisting>
<db:para><db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> also supports UDP multicast. Use <db:link xlink:href="qudpsocket.xml#joinMulticastGroup">joinMulticastGroup</db:link>() and <db:link xlink:href="qudpsocket.xml#leaveMulticastGroup">leaveMulticastGroup</db:link>() to control group membership, and <db:link xlink:href="qabstractsocket.xml#SocketOption-enum">QAbstractSocket::MulticastTtlOption</db:link> and <db:link xlink:href="qabstractsocket.xml#SocketOption-enum">QAbstractSocket::MulticastLoopbackOption</db:link> to set the TTL and loopback socket options. Use <db:link xlink:href="qudpsocket.xml#setMulticastInterface">setMulticastInterface</db:link>() to control the outgoing interface for multicast datagrams, and <db:link xlink:href="qudpsocket.xml#multicastInterface">multicastInterface</db:link>() to query it.</db:para>
<db:para>With <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link>, you can also establish a virtual connection to a UDP server using <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>() and then use <db:link xlink:href="qiodevice.xml#read">read</db:link>() and <db:link xlink:href="qiodevice.xml#write">write</db:link>() to exchange datagrams without specifying the receiver for each datagram.</db:para>
<db:para>The <db:link xlink:href="qtnetwork-broadcastsender-example.xml">Broadcast Sender</db:link>, <db:link xlink:href="qtnetwork-broadcastreceiver-example.xml">Broadcast Receiver</db:link>, <db:link xlink:href="qtnetwork-multicastsender-example.xml">Multicast Sender</db:link>, and <db:link xlink:href="qtnetwork-multicastreceiver-example.xml">Multicast Receiver</db:link> examples illustrate how to use <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> in applications.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QUdpSocket">
<db:title>[explicit] QUdpSocket::QUdpSocket(QObject *<db:emphasis>parent</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Creates a <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> object.</db:para>
<db:para><db:code role="parameter">parent</db:code> is passed to the <db:link xlink:href="qobject.xml">QObject</db:link> constructor.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#socketType">socketType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QUdpSocket">
<db:title>[virtual noexcept] QUdpSocket::~QUdpSocket()</db:title>
<db:para>Destroys the socket, closing the connection if necessary.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml#close">close</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasPendingDatagrams">
<db:title>bool QUdpSocket::hasPendingDatagrams() const</db:title>
<db:para>Returns true if at least one datagram is waiting to be read; otherwise returns false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qudpsocket.xml#pendingDatagramSize">pendingDatagramSize</db:link>()</db:member>
<db:member><db:link xlink:href="qudpsocket.xml#readDatagram">readDatagram</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="joinMulticastGroup">
<db:title>[since 4.8] bool QUdpSocket::joinMulticastGroup(const QHostAddress &amp;<db:emphasis>groupAddress</db:emphasis>)</db:title>
<db:para>Joins the multicast group specified by <db:code role="parameter">groupAddress</db:code> on the default interface chosen by the operating system. The socket must be in BoundState, otherwise an error occurs.</db:para>
<db:para>Note that if you are attempting to join an IPv4 group, your socket must not be bound using IPv6 (or in dual mode, using <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::Any</db:link>). You must use <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::AnyIPv4</db:link> instead.</db:para>
<db:para>This function returns true if successful; otherwise it returns false and sets the socket error accordingly.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qudpsocket.xml#leaveMulticastGroup">leaveMulticastGroup</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="joinMulticastGroup-1">
<db:title>[since 4.8] bool QUdpSocket::joinMulticastGroup(const QHostAddress &amp;<db:emphasis>groupAddress</db:emphasis>, const QNetworkInterface &amp;<db:emphasis>iface</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Joins the multicast group address <db:code role="parameter">groupAddress</db:code> on the interface <db:code role="parameter">iface</db:code>.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qudpsocket.xml#leaveMulticastGroup">leaveMulticastGroup</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="leaveMulticastGroup">
<db:title>[since 4.8] bool QUdpSocket::leaveMulticastGroup(const QHostAddress &amp;<db:emphasis>groupAddress</db:emphasis>)</db:title>
<db:para>Leaves the multicast group specified by <db:code role="parameter">groupAddress</db:code> on the default interface chosen by the operating system. The socket must be in BoundState, otherwise an error occurs.</db:para>
<db:para>This function returns true if successful; otherwise it returns false and sets the socket error accordingly.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qudpsocket.xml#joinMulticastGroup">joinMulticastGroup</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="leaveMulticastGroup-1">
<db:title>[since 4.8] bool QUdpSocket::leaveMulticastGroup(const QHostAddress &amp;<db:emphasis>groupAddress</db:emphasis>, const QNetworkInterface &amp;<db:emphasis>iface</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Leaves the multicast group specified by <db:code role="parameter">groupAddress</db:code> on the interface <db:code role="parameter">iface</db:code>.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qudpsocket.xml#joinMulticastGroup">joinMulticastGroup</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="multicastInterface">
<db:title>[since 4.8] QNetworkInterface QUdpSocket::multicastInterface() const</db:title>
<db:para>Returns the interface for the outgoing interface for multicast datagrams. This corresponds to the IP_MULTICAST_IF socket option for IPv4 sockets and the IPV6_MULTICAST_IF socket option for IPv6 sockets. If no interface has been previously set, this function returns an invalid <db:link xlink:href="qnetworkinterface.xml">QNetworkInterface</db:link>. The socket must be in BoundState, otherwise an invalid <db:link xlink:href="qnetworkinterface.xml">QNetworkInterface</db:link> is returned.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qudpsocket.xml#setMulticastInterface">setMulticastInterface</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pendingDatagramSize">
<db:title>qint64 QUdpSocket::pendingDatagramSize() const</db:title>
<db:para>Returns the size of the first pending UDP datagram. If there is no datagram available, this function returns -1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qudpsocket.xml#hasPendingDatagrams">hasPendingDatagrams</db:link>()</db:member>
<db:member><db:link xlink:href="qudpsocket.xml#readDatagram">readDatagram</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="readDatagram">
<db:title>qint64 QUdpSocket::readDatagram(char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>maxSize</db:emphasis>, QHostAddress *<db:emphasis>address</db:emphasis> = Q_NULLPTR, quint16 *<db:emphasis>port</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Receives a datagram no larger than <db:code role="parameter">maxSize</db:code> bytes and stores it in <db:code role="parameter">data</db:code>. The sender's host address and port is stored in *<db:code role="parameter">address</db:code> and *<db:code role="parameter">port</db:code> (unless the pointers are 0).</db:para>
<db:para>Returns the size of the datagram on success; otherwise returns -1.</db:para>
<db:para>If <db:code role="parameter">maxSize</db:code> is too small, the rest of the datagram will be lost. To avoid loss of data, call <db:link xlink:href="qudpsocket.xml#pendingDatagramSize">pendingDatagramSize</db:link>() to determine the size of the pending datagram before attempting to read it. If <db:code role="parameter">maxSize</db:code> is 0, the datagram will be discarded.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qudpsocket.xml#writeDatagram">writeDatagram</db:link>()</db:member>
<db:member><db:link xlink:href="qudpsocket.xml#hasPendingDatagrams">hasPendingDatagrams</db:link>()</db:member>
<db:member><db:link xlink:href="qudpsocket.xml#pendingDatagramSize">pendingDatagramSize</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setMulticastInterface">
<db:title>[since 4.8] void QUdpSocket::setMulticastInterface(const QNetworkInterface &amp;<db:emphasis>iface</db:emphasis>)</db:title>
<db:para>Sets the outgoing interface for multicast datagrams to the interface <db:code role="parameter">iface</db:code>. This corresponds to the IP_MULTICAST_IF socket option for IPv4 sockets and the IPV6_MULTICAST_IF socket option for IPv6 sockets. The socket must be in BoundState, otherwise this function does nothing.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qudpsocket.xml#multicastInterface">multicastInterface</db:link>()</db:member>
<db:member><db:link xlink:href="qudpsocket.xml#joinMulticastGroup">joinMulticastGroup</db:link>()</db:member>
<db:member><db:link xlink:href="qudpsocket.xml#leaveMulticastGroup">leaveMulticastGroup</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="writeDatagram">
<db:title>qint64 QUdpSocket::writeDatagram(const char *<db:emphasis>data</db:emphasis>, qint64 <db:emphasis>size</db:emphasis>, const QHostAddress &amp;<db:emphasis>address</db:emphasis>, quint16 <db:emphasis>port</db:emphasis>)</db:title>
<db:para>Sends the datagram at <db:code role="parameter">data</db:code> of size <db:code role="parameter">size</db:code> to the host address <db:code role="parameter">address</db:code> at port <db:code role="parameter">port</db:code>. Returns the number of bytes sent on success; otherwise returns -1.</db:para>
<db:para>Datagrams are always written as one block. The maximum size of a datagram is highly platform-dependent, but can be as low as 8192 bytes. If the datagram is too large, this function will return -1 and <db:link xlink:href="qabstractsocket.xml#error">error</db:link>() will return DatagramTooLargeError.</db:para>
<db:para>Sending datagrams larger than 512 bytes is in general disadvised, as even if they are sent successfully, they are likely to be fragmented by the IP layer before arriving at their final destination.</db:para>
<db:warning>
<db:para>Calling this function on a connected UDP socket may result in an error and no packet being sent. If you are using a connected socket, use <db:link xlink:href="qiodevice.xml#write">write</db:link>() to send datagrams.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qudpsocket.xml#readDatagram">readDatagram</db:link>()</db:member>
<db:member><db:link xlink:href="qiodevice.xml#write">write</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="writeDatagram-1">
<db:title>qint64 QUdpSocket::writeDatagram(const QByteArray &amp;<db:emphasis>datagram</db:emphasis>, const QHostAddress &amp;<db:emphasis>host</db:emphasis>, quint16 <db:emphasis>port</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends the datagram <db:code role="parameter">datagram</db:code> to the host address <db:code role="parameter">host</db:code> and at port <db:code role="parameter">port</db:code>.</db:para>
</db:section>
</db:section>
</db:article>
