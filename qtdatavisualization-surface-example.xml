<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Surface Example</db:title>
<db:productname>QtDataVisualization</db:productname>
<db:edition>Qt Data Visualization | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Using <db:link xlink:href="q3dsurface.xml">Q3DSurface</db:link> in a widget application.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The surface example shows how to make a simple 3D surface graph using <db:link xlink:href="q3dsurface.xml">Q3DSurface</db:link> and combining the use of widgets for adjusting several adjustable qualities. This example demonstrates the following features:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>How to set up a basic <db:link xlink:href="qsurfacedataproxy.xml">QSurfaceDataProxy</db:link> and set data for it.</db:para>
</db:listitem>
<db:listitem>
<db:para>How to use <db:link xlink:href="qheightmapsurfacedataproxy.xml">QHeightMapSurfaceDataProxy</db:link> for showing 3D height maps.</db:para>
</db:listitem>
<db:listitem>
<db:para>Three different selection modes for studying the graph.</db:para>
</db:listitem>
<db:listitem>
<db:para>Axis range usage for displaying selected portions of the graph.</db:para>
</db:listitem>
<db:listitem>
<db:para>Changing theme.</db:para>
</db:listitem>
<db:listitem>
<db:para>How to set a custom surface gradient.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For instructions about how to interact with the graph, see <db:link xlink:href="qtdatavisualization-interacting-with-data.xml">this page</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/surface-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="http://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:emphasis role="bold">Welcome</db:emphasis> mode and select the example from <db:emphasis role="bold">Examples</db:emphasis>. For more information, visit <db:link xlink:href="http://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="creating-the-application">
<db:title>Creating the Application</db:title>
<db:para>First, in <db:code>main.cpp</db:code>, we create a <db:link xlink:href="qapplication.xml">QApplication</db:link>, instantiate <db:link xlink:href="q3dsurface.xml">Q3DSurface</db:link>, and a window container for it:</db:para>
<db:programlisting language="cpp">QApplication app(argc, argv);
Q3DSurface *graph = new Q3DSurface();
QWidget *container = QWidget::createWindowContainer(graph);
</db:programlisting>
<db:para>The call to <db:link xlink:href="qwidget.xml#createWindowContainer">QWidget::createWindowContainer</db:link> is required, as all data visualization graph classes (<db:link xlink:href="q3dbars.xml">Q3DBars</db:link>, <db:link xlink:href="q3dscatter.xml">Q3DScatter</db:link>, and <db:link xlink:href="q3dsurface.xml">Q3DSurface</db:link>) inherit <db:link xlink:href="qwindow.xml">QWindow</db:link>. Any class inheriting <db:link xlink:href="qwindow.xml">QWindow</db:link> cannot be used as a widget any other way.</db:para>
<db:para>Then we'll create horizontal and vertical layouts. We'll add the graph with the container and the vertical layout into the horizontal one:</db:para>
<db:programlisting language="cpp">QWidget *widget = new QWidget;
QHBoxLayout *hLayout = new QHBoxLayout(widget);
QVBoxLayout *vLayout = new QVBoxLayout();
hLayout-&amp;gt;addWidget(container, 1);
hLayout-&amp;gt;addLayout(vLayout);
vLayout-&amp;gt;setAlignment(Qt::AlignTop);
</db:programlisting>
<db:para>The rest of the code in <db:code>main.cpp</db:code> is creating control widgets for features in <db:link xlink:href="q3dsurface.xml">Q3DSurface</db:link>. We have separated code for changing these features into <db:code>surfacegraph.cpp</db:code> and only connect signals from widgets into methods in <db:code>surfacegraph.cpp</db:code>. Next chapter explains more about using <db:link xlink:href="q3dsurface.xml">Q3DSurface</db:link>.</db:para>
</db:section>
<db:section xml:id="setting-up-proxies-and-data">
<db:title>Setting up Proxies and Data</db:title>
<db:para>First we instantiate a new <db:link xlink:href="qsurfacedataproxy.xml">QSurfaceDataProxy</db:link> and attach it to a new <db:link xlink:href="qsurface3dseries.xml">QSurface3DSeries</db:link>:</db:para>
<db:programlisting language="cpp">m_sqrtSinProxy = new QSurfaceDataProxy();
m_sqrtSinSeries = new QSurface3DSeries(m_sqrtSinProxy);
</db:programlisting>
<db:para>Then we fill the proxy with a simple square root and sine wave data. This is done by creating a new <db:code>QSurfaceDataArray</db:code> instance and adding <db:code>QSurfaceDataRow</db:code> elements to it. The created <db:code>QSurfaceDataArray</db:code> is set to be the data array for the <db:link xlink:href="qsurfacedataproxy.xml">QSurfaceDataProxy</db:link>.</db:para>
<db:programlisting language="cpp">void SurfaceGraph::fillSqrtSinProxy()
{
    float stepX = (sampleMax - sampleMin) / float(sampleCountX - 1);
    float stepZ = (sampleMax - sampleMin) / float(sampleCountZ - 1);

    QSurfaceDataArray *dataArray = new QSurfaceDataArray;
    dataArray-&amp;gt;reserve(sampleCountZ);
    for (int i = 0 ; i &amp;lt; sampleCountZ ; i++) {
        QSurfaceDataRow *newRow = new QSurfaceDataRow(sampleCountX);
        // Keep values within range bounds, since just adding step can cause minor drift due
        // to the rounding errors.
        float z = qMin(sampleMax, (i * stepZ + sampleMin));
        int index = 0;
        for (int j = 0; j &amp;lt; sampleCountX; j++) {
            float x = qMin(sampleMax, (j * stepX + sampleMin));
            float R = qSqrt(z * z + x * x) + 0.01f;
            float y = (qSin(R) / R + 0.24f) * 1.61f;
            (*newRow)[index++].setPosition(QVector3D(x, y, z));
        }
        *dataArray &amp;lt;&amp;lt; newRow;
    }

    m_sqrtSinProxy-&amp;gt;resetArray(dataArray);
}
</db:programlisting>
<db:para>The height map is created by instantiating a <db:link xlink:href="qheightmapsurfacedataproxy.xml">QHeightMapSurfaceDataProxy</db:link> with a <db:link xlink:href="qimage.xml">QImage</db:link> containing the height data. The method <db:link xlink:href="qheightmapsurfacedataproxy.xml#setValueRanges">QHeightMapSurfaceDataProxy::setValueRanges</db:link>() is used to define the value range of the map. In our example the map is from imaginary position of 34.0째 N - 40.0째 N and 18.0째 E - 24.0째 E. These values are used to show and position the map to the axis.</db:para>
<db:programlisting language="cpp">QImage heightMapImage(&quot;:/maps/mountain&quot;);
m_heightMapProxy = new QHeightMapSurfaceDataProxy(heightMapImage);
m_heightMapSeries = new QSurface3DSeries(m_heightMapProxy);
m_heightMapSeries-&amp;gt;setItemLabelFormat(QStringLiteral(&quot;(@xLabel, @zLabel): @yLabel&quot;));
m_heightMapProxy-&amp;gt;setValueRanges(34.0f, 40.0f, 18.0f, 24.0f);
</db:programlisting>
<db:para>For demonstrating different proxies this example has two radio buttons which the user can use to switch between the series. When the user selects the <db:code>Sqrt &amp; Sin</db:code> radio button, the selected series is activated with the following code. First we set the decorative issues like enable the grid for the surface and select the flat shading mode. Next lines define the axis label format and value ranges. Automatic label rotation is set to improve label readability at low camera angles. Finally we make sure the correct series is added to the graph:</db:para>
<db:programlisting language="cpp">m_sqrtSinSeries-&amp;gt;setDrawMode(QSurface3DSeries::DrawSurfaceAndWireframe);
m_sqrtSinSeries-&amp;gt;setFlatShadingEnabled(true);

m_graph-&amp;gt;axisX()-&amp;gt;setLabelFormat(&quot;%.2f&quot;);
m_graph-&amp;gt;axisZ()-&amp;gt;setLabelFormat(&quot;%.2f&quot;);
m_graph-&amp;gt;axisX()-&amp;gt;setRange(sampleMin, sampleMax);
m_graph-&amp;gt;axisY()-&amp;gt;setRange(0.0f, 2.0f);
m_graph-&amp;gt;axisZ()-&amp;gt;setRange(sampleMin, sampleMax);
m_graph-&amp;gt;axisX()-&amp;gt;setLabelAutoRotation(30);
m_graph-&amp;gt;axisY()-&amp;gt;setLabelAutoRotation(90);
m_graph-&amp;gt;axisZ()-&amp;gt;setLabelAutoRotation(30);

m_graph-&amp;gt;removeSeries(m_heightMapSeries);
m_graph-&amp;gt;addSeries(m_sqrtSinSeries);
</db:programlisting>
<db:para>When the <db:code>Height Map</db:code> radio button is activated, the following code sets the correct series active. The axis label format is set to show N and E letters and ranges are set to the imaginary coordinates. Auto adjusting Y-axis range is fine for our height map surface, so we ensure it is set.</db:para>
<db:programlisting language="cpp">m_heightMapSeries-&amp;gt;setDrawMode(QSurface3DSeries::DrawSurface);
m_heightMapSeries-&amp;gt;setFlatShadingEnabled(false);

m_graph-&amp;gt;axisX()-&amp;gt;setLabelFormat(&quot;%.1f N&quot;);
m_graph-&amp;gt;axisZ()-&amp;gt;setLabelFormat(&quot;%.1f E&quot;);
m_graph-&amp;gt;axisX()-&amp;gt;setRange(34.0f, 40.0f);
m_graph-&amp;gt;axisY()-&amp;gt;setAutoAdjustRange(true);
m_graph-&amp;gt;axisZ()-&amp;gt;setRange(18.0f, 24.0f);

m_graph-&amp;gt;axisX()-&amp;gt;setTitle(QStringLiteral(&quot;Latitude&quot;));
m_graph-&amp;gt;axisY()-&amp;gt;setTitle(QStringLiteral(&quot;Height&quot;));
m_graph-&amp;gt;axisZ()-&amp;gt;setTitle(QStringLiteral(&quot;Longitude&quot;));

m_graph-&amp;gt;removeSeries(m_sqrtSinSeries);
m_graph-&amp;gt;addSeries(m_heightMapSeries);
</db:programlisting>
</db:section>
<db:section xml:id="selection-modes">
<db:title>Selection Modes</db:title>
<db:para>Q3Dsurface supports three different selection modes. These are demonstrated in the example with radio buttons, which the user can use to activate a suitable selection mode. The following inline methods are connected to radio buttons to activate the selected mode.</db:para>
<db:programlisting language="cpp">void toggleModeNone() { m_graph-&amp;gt;setSelectionMode(QAbstract3DGraph::SelectionNone); }
void toggleModeItem() { m_graph-&amp;gt;setSelectionMode(QAbstract3DGraph::SelectionItem); }
void toggleModeSliceRow() { m_graph-&amp;gt;setSelectionMode(QAbstract3DGraph::SelectionItemAndRow
                                                      | QAbstract3DGraph::SelectionSlice); }
void toggleModeSliceColumn() { m_graph-&amp;gt;setSelectionMode(QAbstract3DGraph::SelectionItemAndColumn
                                                         | QAbstract3DGraph::SelectionSlice); }
</db:programlisting>
</db:section>
<db:section xml:id="axis-ranges-for-studying-the-graph">
<db:title>Axis Ranges for Studying the Graph</db:title>
<db:para>The example has four slider controls for adjusting the min and max values for X and Z axis. When selecting the proxy these sliders are adjusted so that one step on the slider moves the range by one segment step:</db:para>
<db:programlisting language="cpp">// Reset range sliders for Sqrt&amp;amp;Sin
m_rangeMinX = sampleMin;
m_rangeMinZ = sampleMin;
m_stepX = (sampleMax - sampleMin) / float(sampleCountX - 1);
m_stepZ = (sampleMax - sampleMin) / float(sampleCountZ - 1);
m_axisMinSliderX-&amp;gt;setMaximum(sampleCountX - 2);
m_axisMinSliderX-&amp;gt;setValue(0);
m_axisMaxSliderX-&amp;gt;setMaximum(sampleCountX - 1);
m_axisMaxSliderX-&amp;gt;setValue(sampleCountX - 1);
m_axisMinSliderZ-&amp;gt;setMaximum(sampleCountZ - 2);
m_axisMinSliderZ-&amp;gt;setValue(0);
m_axisMaxSliderZ-&amp;gt;setMaximum(sampleCountZ - 1);
m_axisMaxSliderZ-&amp;gt;setValue(sampleCountZ - 1);
</db:programlisting>
<db:para>The ranges are set for the axes like this:</db:para>
<db:programlisting language="cpp">void SurfaceGraph::setAxisXRange(float min, float max)
{
    m_graph-&amp;gt;axisX()-&amp;gt;setRange(min, max);
}

void SurfaceGraph::setAxisZRange(float min, float max)
{
    m_graph-&amp;gt;axisZ()-&amp;gt;setRange(min, max);
}
</db:programlisting>
</db:section>
<db:section xml:id="themes">
<db:title>Themes</db:title>
<db:para><db:link xlink:href="q3dsurface.xml">Q3DSurface</db:link> supports all the themes Qt Data Visualization has. The example has a pull down menu for selecting the theme. The following method is connected to the menu to activate the selected theme. The theme type is changed to another predefined theme, which overwrites all theme properties to predefined values:</db:para>
<db:programlisting language="cpp">void SurfaceGraph::changeTheme(int theme)
{
    m_graph-&amp;gt;activeTheme()-&amp;gt;setType(Q3DTheme::Theme(theme));
}
</db:programlisting>
</db:section>
<db:section xml:id="custom-surface-gradients">
<db:title>Custom Surface Gradients</db:title>
<db:para>The example demonstrates the custom surface gradients with two push buttons. The gradient can be defined with <db:link xlink:href="qlineargradient.xml">QLinearGradient</db:link> where the desired colors are set to positions. The following code shows how to create an example gradient and set it to the series. Note that you also need to change the color style to <db:link xlink:href="q3dtheme.xml#ColorStyle-enum">Q3DTheme::ColorStyleRangeGradient</db:link> to actually use the gradient.</db:para>
<db:programlisting language="cpp">QLinearGradient gr;
gr.setColorAt(0.0, Qt::black);
gr.setColorAt(0.33, Qt::blue);
gr.setColorAt(0.67, Qt::red);
gr.setColorAt(1.0, Qt::yellow);

m_graph-&amp;gt;seriesList().at(0)-&amp;gt;setBaseGradient(gr);
m_graph-&amp;gt;seriesList().at(0)-&amp;gt;setColorStyle(Q3DTheme::ColorStyleRangeGradient);
</db:programlisting>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="surface/main.cpp">surface/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="surface/surface.pro">surface/surface.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="surface/surface.qrc">surface/surface.qrc</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="surface/surfacegraph.cpp">surface/surfacegraph.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="surface/surfacegraph.h">surface/surfacegraph.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Images:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="surface/mountain.png">surface/mountain.png</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:section></db:article>
