<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>How to Create Qt Plugins</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.2.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A guide to creating plugins to extend Qt applications and functionality provided by Qt.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Qt provides two APIs for creating plugins:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>A higher-level API for writing extensions to Qt itself: custom database drivers, image formats, text codecs, custom styles, etc.</db:para>
</db:listitem>
<db:listitem>
<db:para>A lower-level API for extending Qt applications.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For example, if you want to write a custom QStyle subclass and have Qt applications load it dynamically, you would use the higher-level API.</db:para>
<db:para>Since the higher-level API is built on top of the lower-level API, some issues are common to both.</db:para>
<db:para>If you want to provide plugins for use with Qt Designer, see the Qt Designer module documentation.</db:para>
<db:para>Topics:</db:para>
<db:section xml:id="the-higher-level-api-writing-qt-extensions">
<db:title>The Higher-Level API: Writing Qt Extensions</db:title>
<db:para>Writing a plugin that extends Qt itself is achieved by subclassing the appropriate plugin base class, implementing a few functions, and adding a macro.</db:para>
<db:para>There are several plugin base classes. Derived plugins are stored by default in sub-directories of the standard plugin directory. Qt will not find plugins if they are not stored in the right directory.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Base Class</db:para>
</db:th>
<db:th>
<db:para>Directory Name</db:para>
</db:th>
<db:th>
<db:para>Key Case Sensitivity</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>QAccessibleBridgePlugin</db:para>
</db:td>
<db:td>
<db:para>accessiblebridge</db:para>
</db:td>
<db:td>
<db:para>Case Sensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QAccessiblePlugin</db:para>
</db:td>
<db:td>
<db:para>accessible</db:para>
</db:td>
<db:td>
<db:para>Case Sensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QDecorationPlugin</db:para>
</db:td>
<db:td>
<db:para>decorations</db:para>
</db:td>
<db:td>
<db:para>Case Insensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QFontEnginePlugin</db:para>
</db:td>
<db:td>
<db:para>fontengines</db:para>
</db:td>
<db:td>
<db:para>Case Insensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QIconEnginePlugin</db:para>
</db:td>
<db:td>
<db:para>iconengines</db:para>
</db:td>
<db:td>
<db:para>Case Insensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QImageIOPlugin</db:para>
</db:td>
<db:td>
<db:para>imageformats</db:para>
</db:td>
<db:td>
<db:para>Case Sensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QInputContextPlugin</db:para>
</db:td>
<db:td>
<db:para>inputmethods</db:para>
</db:td>
<db:td>
<db:para>Case Sensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QKbdDriverPlugin</db:para>
</db:td>
<db:td>
<db:para>kbddrivers</db:para>
</db:td>
<db:td>
<db:para>Case Insensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QMouseDriverPlugin</db:para>
</db:td>
<db:td>
<db:para>mousedrivers</db:para>
</db:td>
<db:td>
<db:para>Case Insensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QScreenDriverPlugin</db:para>
</db:td>
<db:td>
<db:para>gfxdrivers</db:para>
</db:td>
<db:td>
<db:para>Case Insensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QScriptExtensionPlugin</db:para>
</db:td>
<db:td>
<db:para>script</db:para>
</db:td>
<db:td>
<db:para>Case Sensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QSqlDriverPlugin</db:para>
</db:td>
<db:td>
<db:para>sqldrivers</db:para>
</db:td>
<db:td>
<db:para>Case Sensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QStylePlugin</db:para>
</db:td>
<db:td>
<db:para>styles</db:para>
</db:td>
<db:td>
<db:para>Case Insensitive</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>QTextCodecPlugin</db:para>
</db:td>
<db:td>
<db:para>codecs</db:para>
</db:td>
<db:td>
<db:para>Case Sensitive</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Suppose that you have a new style class called MyStyle that you want to make available as a plugin. The required code is straightforward, here is the class definition (mystyleplugin.h):</db:para>
<db:programlisting language="cpp">class MyStylePlugin : public QStylePlugin
{
    Q_OBJECT
    Q_PLUGIN_METADATA(IID &quot;org.qt-project.Qt.QStyleFactoryInterface&quot; FILE mystyleplugin.json)
public:
    QStyle *create(const QString &amp;key);
};
</db:programlisting>
<db:para>Ensure that the class implementation is located in a .cpp file:</db:para>
<db:programlisting language="cpp">#include &quot;mystyleplugin.h&quot;

QStyle *MyStylePlugin::create(const QString &amp;key)
{
    if (key.toLower() == &quot;mystyle&quot;)
        return new MyStyle;
    return 0;
}

</db:programlisting>
<db:para>(Note that QStylePlugin is case insensitive, and the lower-case version of the key is used in our <db:link xlink:href="">create()</db:link> implementation; most other plugins are case sensitive.)</db:para>
<db:para>In addition a mystyleplugin.json file containing meta data describing the plugin is required for most plugins. For style plugins it simply contains a list of styles that can be created by the plugin:</db:para>
<db:programlisting language="cpp">{ &quot;Keys&quot;: [ &quot;mystyleplugin&quot; ] }
</db:programlisting>
<db:para>The type of information that needs to be provided in the json file is plugin dependent, please see the class documentation for details on the information that needs to be contained in the file.</db:para>
<db:para>For database drivers, image formats, text codecs, and most other plugin types, no explicit object creation is required. Qt will find and create them as required. Styles are an exception, since you might want to set a style explicitly in code. To apply a style, use code like this:</db:para>
<db:programlisting language="cpp">QApplication::setStyle(QStyleFactory::create(&quot;MyStyle&quot;));
</db:programlisting>
<db:para>Some plugin classes require additional functions to be implemented. See the class documentation for details of the virtual functions that must be reimplemented for each type of plugin.</db:para>
<db:para>The <db:link xlink:href="">Style Plugin Example</db:link> shows how to implement a plugin that extends the QStylePlugin base class.</db:para>
</db:section>
<db:section xml:id="the-lower-level-api-extending-qt-applications">
<db:title>The Lower-Level API: Extending Qt Applications</db:title>
<db:para>Not only Qt itself but also Qt application can be extended through plugins. This requires the application to detect and load plugins using QPluginLoader. In that context, plugins may provide arbitrary functionality and are not limited to database drivers, image formats, text codecs, styles, and the other types of plugin that extend Qt's functionality.</db:para>
<db:para>Making an application extensible through plugins involves the following steps:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Define a set of interfaces (classes with only pure virtual functions) used to talk to the plugins.</db:para>
</db:listitem>
<db:listitem>
<db:para>Use the <db:link xlink:href="qtplugin.xml#Q_DECLARE_INTERFACE">Q_DECLARE_INTERFACE</db:link>() macro to tell Qt's <db:link xlink:href="metaobjects.xml#meta-object-system">meta-object system</db:link> about the interface.</db:para>
</db:listitem>
<db:listitem>
<db:para>Use QPluginLoader in the application to load the plugins.</db:para>
</db:listitem>
<db:listitem>
<db:para>Use qobject_cast() to test whether a plugin implements a given interface.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>Writing a plugin involves these steps:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Declare a plugin class that inherits from <db:link xlink:href="qobject.xml">QObject</db:link> and from the interfaces that the plugin wants to provide.</db:para>
</db:listitem>
<db:listitem>
<db:para>Use the <db:link xlink:href="qobject.xml#Q_INTERFACES">Q_INTERFACES</db:link>() macro to tell Qt's <db:link xlink:href="metaobjects.xml#meta-object-system">meta-object system</db:link> about the interfaces.</db:para>
</db:listitem>
<db:listitem>
<db:para>Export the plugin using the <db:link xlink:href="qtplugin.xml#Q_PLUGIN_METADATA">Q_PLUGIN_METADATA</db:link>() macro.</db:para>
</db:listitem>
<db:listitem>
<db:para>Build the plugin using a suitable .pro file.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>For example, here's the definition of an interface class:</db:para>
<db:programlisting language="cpp">class FilterInterface
{
public:
    virtual ~FilterInterface() {}

    virtual QStringList filters() const = 0;
    virtual QImage filterImage(const QString &amp;filter, const QImage &amp;image,
                               QWidget *parent) = 0;
};
</db:programlisting>
<db:para>Here's the definition of a plugin class that implements that interface:</db:para>
<db:programlisting language="cpp">#include &lt;QObject&gt;
#include &lt;QtPlugin&gt;
#include &lt;QStringList&gt;
#include &lt;QImage&gt;

#include &lt;plugandpaint/interfaces.h&gt;

class ExtraFiltersPlugin : public QObject, public FilterInterface
{
    Q_OBJECT
    Q_PLUGIN_METADATA(IID &quot;org.qt-project.Qt.Examples.PlugAndPaint.FilterInterface&quot; FILE &quot;extrafilters.json&quot;)
    Q_INTERFACES(FilterInterface)

public:
    QStringList filters() const;
    QImage filterImage(const QString &amp;filter, const QImage &amp;image,
                       QWidget *parent);
};
</db:programlisting>
<db:para>The <db:link xlink:href="">Plug &amp; Paint</db:link> example documentation explains this process in detail. See also <db:link xlink:href="">Creating Custom Widgets for Qt Designer</db:link> for information about issues that are specific to Qt Designer. You can also take a look at the <db:link xlink:href="">Echo Plugin Example</db:link> which is a more trivial example on how to implement a plugin that extends Qt applications. Please note that a <db:link xlink:href="qcoreapplication.xml">QCoreApplication</db:link> must have been initialized before plugins can be loaded.</db:para>
</db:section>
<db:section xml:id="locating-plugins">
<db:title>Locating Plugins</db:title>
<db:para>Qt applications automatically know which plugins are available, because plugins are stored in the standard plugin subdirectories. Because of this applications don't require any code to find and load plugins, since Qt handles them automatically.</db:para>
<db:para>During development, the directory for plugins is QTDIR/plugins (where QTDIR is the directory where Qt is installed), with each type of plugin in a subdirectory for that type, e.g. styles. If you want your applications to use plugins and you don't want to use the standard plugins path, have your installation process determine the path you want to use for the plugins, and save the path, e.g. using QSettings, for the application to read when it runs. The application can then call QCoreApplication::addLibraryPath() with this path and your plugins will be available to the application. Note that the final part of the path (e.g., styles) cannot be changed.</db:para>
<db:para>If you want the plugin to be loadable then one approach is to create a subdirectory under the application and place the plugin in that directory. If you distribute any of the plugins that come with Qt (the ones located in the plugins directory), you must copy the sub-directory under plugins where the plugin is located to your applications root folder (i.e., do not include the plugins directory).</db:para>
<db:para>For more information about deployment, see the <db:link xlink:href="">Deploying Qt Applications</db:link> and <db:link xlink:href="">Deploying Plugins</db:link> documentation.</db:para>
</db:section>
<db:section xml:id="static-plugins">
<db:title>Static Plugins</db:title>
<db:para>The normal and most flexible way to include a plugin with an application is to compile it into a dynamic library that is shipped separately, and detected and loaded at runtime.</db:para>
<db:para>Plugins can be linked statically against your application. If you build the static version of Qt, this is the only option for including Qt's predefined plugins. Using static plugins makes the deployment less error-prone, but has the disadvantage that no functionality from plugins can be added without a complete rebuild and redistribution of the application.</db:para>
<db:para>When compiled as a static library, Qt provides the following static plugins:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Plugin name</db:para>
</db:th>
<db:th>
<db:para>Type</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>qtaccessiblewidgets</db:para>
</db:td>
<db:td>
<db:para>Accessibility</db:para>
</db:td>
<db:td>
<db:para>Accessibility for Qt widgets</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qgif</db:para>
</db:td>
<db:td>
<db:para>Image formats</db:para>
</db:td>
<db:td>
<db:para>GIF</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qjpeg</db:para>
</db:td>
<db:td>
<db:para>Image formats</db:para>
</db:td>
<db:td>
<db:para>JPEG</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qmng</db:para>
</db:td>
<db:td>
<db:para>Image formats</db:para>
</db:td>
<db:td>
<db:para>MNG</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qico</db:para>
</db:td>
<db:td>
<db:para>Image formats</db:para>
</db:td>
<db:td>
<db:para>ICO</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsvg</db:para>
</db:td>
<db:td>
<db:para>Image formats</db:para>
</db:td>
<db:td>
<db:para>SVG</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qtiff</db:para>
</db:td>
<db:td>
<db:para>Image formats</db:para>
</db:td>
<db:td>
<db:para>TIFF</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsqldb2</db:para>
</db:td>
<db:td>
<db:para>SQL driver</db:para>
</db:td>
<db:td>
<db:para>IBM DB2</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsqlibase</db:para>
</db:td>
<db:td>
<db:para>SQL driver</db:para>
</db:td>
<db:td>
<db:para>Borland InterBase</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsqlite</db:para>
</db:td>
<db:td>
<db:para>SQL driver</db:para>
</db:td>
<db:td>
<db:para>SQLite version 3</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsqlite2</db:para>
</db:td>
<db:td>
<db:para>SQL driver</db:para>
</db:td>
<db:td>
<db:para>SQLite version 2</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsqlmysql</db:para>
</db:td>
<db:td>
<db:para>SQL driver</db:para>
</db:td>
<db:td>
<db:para>MySQL</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsqloci</db:para>
</db:td>
<db:td>
<db:para>SQL driver</db:para>
</db:td>
<db:td>
<db:para>Oracle (OCI)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsqlodbc</db:para>
</db:td>
<db:td>
<db:para>SQL driver</db:para>
</db:td>
<db:td>
<db:para>Open Database Connectivity (ODBC)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsqlpsql</db:para>
</db:td>
<db:td>
<db:para>SQL driver</db:para>
</db:td>
<db:td>
<db:para>PostgreSQL</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>qsqltds</db:para>
</db:td>
<db:td>
<db:para>SQL driver</db:para>
</db:td>
<db:td>
<db:para>Sybase Adaptive Server (TDS)</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>To link statically against those plugins, you need to add the required plugins to your build using QTPLUGIN. <db:link xlink:href="qtplugin.xml#Q_IMPORT_PLUGIN">Q_IMPORT_PLUGIN</db:link>() macros are also needed in application code, but those are automatically generated by qmake and added to your application project.</db:para>
<db:para>In the .pro file for your application, you need the following entry:</db:para>
<db:programlisting language="cpp">QTPLUGIN     += qjpeg \
                qgif \
                qkrcodecs
</db:programlisting>
<db:para>If you do not want all plugins added to QTPLUGIN to be automatically linked, remove import_plugins from the CONFIG variable:</db:para>
<db:programlisting language="cpp">CONFIG -= import_plugins
</db:programlisting>
<db:para>It is also possible to create your own static plugins, by following these steps:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>Add CONFIG += static to your plugin's .pro file.</db:para>
</db:listitem>
<db:listitem>
<db:para>Use the <db:link xlink:href="qtplugin.xml#Q_IMPORT_PLUGIN">Q_IMPORT_PLUGIN</db:link>() macro in your application.</db:para>
</db:listitem>
<db:listitem>
<db:para>Link your application with your plugin library using LIBS in the .pro file.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>See the <db:link xlink:href="">Plug &amp; Paint</db:link> example and the associated <db:link xlink:href="">Basic Tools</db:link> plugin for details on how to do this.</db:para>
<db:note>
<db:para>If you are not using qmake to build your plugin you need to make sure that the QT_STATICPLUGIN preprocessor macro is defined.</db:para>
</db:note>
<db:para>The default Qt platform adaptation plugin is automatically added to QTPLUGIN in static builds. If you want to add the minimal plugin instead, add qpa_minimal_plugin to CONFIG:</db:para>
<db:programlisting language="cpp">CONFIG += qpa_minimal_plugin
</db:programlisting>
<db:para>If you want neither the default nor the minimal QPA plugin to be linked automatically, remove import_qpa_plugin from CONFIG:</db:para>
<db:programlisting language="cpp">CONFIG -= import_qpa_plugin
</db:programlisting>
</db:section>
<db:section xml:id="deploying-and-debugging-plugins">
<db:title>Deploying and Debugging Plugins</db:title>
<db:para>The <db:link xlink:href="">Deploying Plugins</db:link> document covers the process of deploying plugins with applications and debugging them when problems arise.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>QPluginLoader</db:member>
<db:member>QLibrary</db:member>
<db:member><db:link xlink:href="">Plug &amp; Paint Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:article>
