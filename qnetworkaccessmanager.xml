<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QNetworkAccessManager Class</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 5.15.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> class allows the application to send network requests and receive replies.</db:para>
<db:para>This class was introduced in Qt 4.4.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QNetworkAccessManager</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.4</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += network</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QNetworkAccessManager is part of <db:simplelist><db:member><db:link xlink:href="network.xml">Network Programming API</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The Network Access API is constructed around one <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> object, which holds the common configuration and settings for the requests it sends. It contains the proxy and cache configuration, as well as the signals related to such issues, and reply signals that can be used to monitor the progress of a network operation. One <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> instance should be enough for the whole Qt application. Since <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> is based on <db:link xlink:href="qobject.xml">QObject</db:link>, it can only be used from the thread it belongs to.</db:para>
<db:para>Once a <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> object has been created, the application can use it to send requests over the network. A group of standard functions are supplied that take a request and optional data, and each return a <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> object. The returned object is used to obtain any data returned in response to the corresponding request.</db:para>
<db:para>A simple download off the network could be accomplished with:</db:para>
<db:programlisting language="cpp">QNetworkAccessManager *manager = new QNetworkAccessManager(this);
connect(manager, &amp;amp;QNetworkAccessManager::finished,
        this, &amp;amp;MyClass::replyFinished);

manager-&amp;gt;get(QNetworkRequest(QUrl(&quot;http://qt-project.org&quot;)));
</db:programlisting>
<db:para><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> has an asynchronous API. When the <db:code>replyFinished</db:code> slot above is called, the parameter it takes is the <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> object containing the downloaded data as well as meta-data (headers, etc.).</db:para>
<db:note>
<db:para>After the request has finished, it is the responsibility of the user to delete the <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> object at an appropriate time. Do not directly delete it inside the slot connected to <db:link xlink:href="qnetworkaccessmanager.xml#finished">finished</db:link>(). You can use the <db:link xlink:href="qobject.xml#deleteLater">deleteLater</db:link>() function.</db:para>
</db:note>
<db:note>
<db:para><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> queues the requests it receives. The number of requests executed in parallel is dependent on the protocol. Currently, for the HTTP protocol on desktop platforms, 6 requests are executed in parallel for one host/port combination.</db:para>
</db:note>
<db:para>A more involved example, assuming the manager is already existent, can be:</db:para>
<db:programlisting language="cpp">QNetworkRequest request;
request.setUrl(QUrl(&quot;http://qt-project.org&quot;));
request.setRawHeader(&quot;User-Agent&quot;, &quot;MyOwnBrowser 1.0&quot;);

QNetworkReply *reply = manager-&amp;gt;get(request);
connect(reply, &amp;amp;QIODevice::readyRead, this, &amp;amp;MyClass::slotReadyRead);
connect(reply, &amp;amp;QNetworkReply::errorOccurred,
        this, &amp;amp;MyClass::slotError);
connect(reply, &amp;amp;QNetworkReply::sslErrors,
        this, &amp;amp;MyClass::slotSslErrors);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkrequest.xml">QNetworkRequest</db:link></db:member>
<db:member><db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link></db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Operation-enum">
<db:title>[since 4.7] enum QNetworkAccessManager::Operation</db:title>
<db:enumsynopsis>
<db:enumname>Operation</db:enumname>
<db:enumitem>
<db:enumidentifier>HeadOperation</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>GetOperation</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PutOperation</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>PostOperation</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DeleteOperation</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CustomOperation</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnknownOperation</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Indicates the operation this reply is processing.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:emphasis>::HeadOperation</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>retrieve headers operation (created with <db:link xlink:href="qnetworkaccessmanager.xml#head">head</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:emphasis>::GetOperation</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>retrieve headers and download contents (created with <db:link xlink:href="qnetworkaccessmanager.xml#get">get</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:emphasis>::PutOperation</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>upload contents operation (created with <db:link xlink:href="qnetworkaccessmanager.xml#put">put</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:emphasis>::PostOperation</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>send the contents of an HTML form for processing via HTTP POST (created with <db:link xlink:href="qnetworkaccessmanager.xml#post">post</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:emphasis>::DeleteOperation</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>delete contents operation (created with <db:link xlink:href="qnetworkaccessmanager.xml#deleteResource">deleteResource</db:link>())</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:emphasis>::CustomOperation</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>custom operation (created with <db:link xlink:href="qnetworkaccessmanager.xml#sendCustomRequest">sendCustomRequest</db:link>())</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 4.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkreply.xml#operation">QNetworkReply::operation</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QNetworkAccessManager">
<db:title>[explicit] QNetworkAccessManager::QNetworkAccessManager(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QNetworkAccessManager</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkAccessManager(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> object that is the center of the Network Access API and sets <db:code role="parameter">parent</db:code> as the parent object.</db:para>
</db:section>
<db:section xml:id="dtor.QNetworkAccessManager">
<db:title>[virtual] QNetworkAccessManager::~QNetworkAccessManager()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QNetworkAccessManager</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QNetworkAccessManager()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> object and frees up any resources. Note that <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> objects that are returned from this class have this object set as their parents, which means that they will be deleted along with it if you don't call <db:link xlink:href="qobject.xml#setParent">QObject::setParent</db:link>() on them.</db:para>
</db:section>
<db:section xml:id="addStrictTransportSecurityHosts">
<db:title>[since 5.9] void QNetworkAccessManager::addStrictTransportSecurityHosts(const QVector&lt;QHstsPolicy&gt; &amp;<db:emphasis>knownHosts</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addStrictTransportSecurityHosts</db:methodname>
<db:methodparam>
<db:type>const QVector&lt;QHstsPolicy&gt; &amp;</db:type>
<db:parameter>knownHosts</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addStrictTransportSecurityHosts(const QVector&lt;QHstsPolicy&gt; &amp;knownHosts)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds HTTP Strict Transport Security policies into HSTS cache. <db:code role="parameter">knownHosts</db:code> contains the known hosts that have <db:link xlink:href="qhstspolicy.xml">QHstsPolicy</db:link> information.</db:para>
<db:note>
<db:para>An expired policy will remove a known host from the cache, if previously present.</db:para>
</db:note>
<db:note>
<db:para>While processing HTTP responses, <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> can also update the HSTS cache, removing or updating exitsting policies or introducing new <db:code role="parameter">knownHosts</db:code>. The current implementation thus is server-driven, client code can provide <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> with previously known or discovered policies, but this information can be overridden by &quot;Strict-Transport-Security&quot; response headers.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member>addStrictTransportSecurityHosts()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#enableStrictTransportSecurityStore">enableStrictTransportSecurityStore</db:link>()</db:member>
<db:member><db:link xlink:href="qhstspolicy.xml">QHstsPolicy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="authenticationRequired">
<db:title>void QNetworkAccessManager::authenticationRequired(QNetworkReply *<db:emphasis>reply</db:emphasis>, QAuthenticator *<db:emphasis>authenticator</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>authenticationRequired</db:methodname>
<db:methodparam>
<db:type>QNetworkReply *</db:type>
<db:parameter>reply</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QAuthenticator *</db:type>
<db:parameter>authenticator</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void authenticationRequired(QNetworkReply *reply, QAuthenticator *authenticator)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever a final server requests authentication before it delivers the requested contents. The slot connected to this signal should fill the credentials for the contents (which can be determined by inspecting the <db:code role="parameter">reply</db:code> object) in the <db:code role="parameter">authenticator</db:code> object.</db:para>
<db:para><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> will cache the credentials internally and will send the same values if the server requires authentication again, without emitting the authenticationRequired() signal. If it rejects the credentials, this signal will be emitted again.</db:para>
<db:note>
<db:para>To have the request not send credentials you must not call setUser() or setPassword() on the <db:code role="parameter">authenticator</db:code> object. This will result in the <db:link xlink:href="qnetworkaccessmanager.xml#finished">finished</db:link>() signal being emitted with a <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> with error <db:link xlink:href="qnetworkreply.xml#NetworkError-enum">AuthenticationRequiredError</db:link>.</db:para>
</db:note>
<db:note>
<db:para>It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#proxyAuthenticationRequired">proxyAuthenticationRequired</db:link>()</db:member>
<db:member><db:link xlink:href="qauthenticator.xml#setUser">QAuthenticator::setUser</db:link>()</db:member>
<db:member><db:link xlink:href="qauthenticator.xml#setPassword">QAuthenticator::setPassword</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="autoDeleteReplies">
<db:title>[since 5.14] bool QNetworkAccessManager::autoDeleteReplies() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>autoDeleteReplies</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool autoDeleteReplies() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the true if <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> is currently configured to automatically delete QNetworkReplies, false otherwise.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setAutoDeleteReplies">setAutoDeleteReplies</db:link></db:member>
<db:member><db:link xlink:href="qnetworkrequest.xml#Attribute-enum">QNetworkRequest::AutoDeleteReplyOnFinishAttribute</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cache">
<db:title>[since 4.5] QAbstractNetworkCache *QNetworkAccessManager::cache() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QAbstractNetworkCache *</db:type>
<db:methodname>cache</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QAbstractNetworkCache * cache() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the cache that is used to store data obtained from the network.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setCache">setCache</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clearAccessCache">
<db:title>[since 5.0] void QNetworkAccessManager::clearAccessCache()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clearAccessCache</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clearAccessCache()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Flushes the internal cache of authentication data and network connections.</db:para>
<db:para>This function is useful for doing auto tests.</db:para>
<db:para>This function was introduced in Qt 5.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#clearConnectionCache">clearConnectionCache</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="clearConnectionCache">
<db:title>[since 5.9] void QNetworkAccessManager::clearConnectionCache()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>clearConnectionCache</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void clearConnectionCache()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Flushes the internal cache of network connections. In contrast to <db:link xlink:href="qnetworkaccessmanager.xml#clearAccessCache">clearAccessCache</db:link>() the authentication data is preserved.</db:para>
<db:para>This function was introduced in Qt 5.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#clearAccessCache">clearAccessCache</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectToHost">
<db:title>[since 5.2] void QNetworkAccessManager::connectToHost(const QString &amp;<db:emphasis>hostName</db:emphasis>, quint16 <db:emphasis>port</db:emphasis> = 80)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connectToHost</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>hostName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
<db:initializer>80</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void connectToHost(const QString &amp;hostName, quint16 port)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Initiates a connection to the host given by <db:code role="parameter">hostName</db:code> at port <db:code role="parameter">port</db:code>. This function is useful to complete the TCP handshake to a host before the HTTP request is made, resulting in a lower network latency.</db:para>
<db:note>
<db:para>This function has no possibility to report errors.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#connectToHostEncrypted">connectToHostEncrypted</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#get">get</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#post">post</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#put">put</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#deleteResource">deleteResource</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectToHostEncrypted">
<db:title>[since 5.2] void QNetworkAccessManager::connectToHostEncrypted(const QString &amp;<db:emphasis>hostName</db:emphasis>, quint16 <db:emphasis>port</db:emphasis> = 443, const QSslConfiguration &amp;<db:emphasis>sslConfiguration</db:emphasis> = QSslConfiguration::defaultConfiguration())</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connectToHostEncrypted</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>hostName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
<db:initializer>443</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>sslConfiguration</db:parameter>
<db:initializer>QSslConfiguration::defaultConfiguration()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void connectToHostEncrypted(const QString &amp;hostName, quint16 port, const QSslConfiguration &amp;sslConfiguration)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Initiates a connection to the host given by <db:code role="parameter">hostName</db:code> at port <db:code role="parameter">port</db:code>, using <db:code role="parameter">sslConfiguration</db:code>. This function is useful to complete the TCP and SSL handshake to a host before the HTTPS request is made, resulting in a lower network latency.</db:para>
<db:note>
<db:para>Preconnecting a SPDY connection can be done by calling setAllowedNextProtocols() on <db:code role="parameter">sslConfiguration</db:code> with <db:link xlink:href="qsslconfiguration.xml#NextProtocolSpdy3_0-var">QSslConfiguration::NextProtocolSpdy3_0</db:link> contained in the list of allowed protocols. When using SPDY, one single connection per host is enough, i.e. calling this method multiple times per host will not result in faster network transactions.</db:para>
</db:note>
<db:note>
<db:para>This function has no possibility to report errors.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#connectToHost">connectToHost</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#get">get</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#post">post</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#put">put</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#deleteResource">deleteResource</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectToHostEncrypted-1">
<db:title>[since 5.13] void QNetworkAccessManager::connectToHostEncrypted(const QString &amp;<db:emphasis>hostName</db:emphasis>, quint16 <db:emphasis>port</db:emphasis>, const QSslConfiguration &amp;<db:emphasis>sslConfiguration</db:emphasis>, const QString &amp;<db:emphasis>peerName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>connectToHostEncrypted</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>hostName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QSslConfiguration &amp;</db:type>
<db:parameter>sslConfiguration</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>peerName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void connectToHostEncrypted(const QString &amp;hostName, quint16 port, const QSslConfiguration &amp;sslConfiguration, const QString &amp;peerName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Initiates a connection to the host given by <db:code role="parameter">hostName</db:code> at port <db:code role="parameter">port</db:code>, using <db:code role="parameter">sslConfiguration</db:code> with <db:code role="parameter">peerName</db:code> set to be the hostName used for certificate validation. This function is useful to complete the TCP and SSL handshake to a host before the HTTPS request is made, resulting in a lower network latency.</db:para>
<db:note>
<db:para>Preconnecting a SPDY connection can be done by calling setAllowedNextProtocols() on <db:code role="parameter">sslConfiguration</db:code> with <db:link xlink:href="qsslconfiguration.xml#NextProtocolSpdy3_0-var">QSslConfiguration::NextProtocolSpdy3_0</db:link> contained in the list of allowed protocols. When using SPDY, one single connection per host is enough, i.e. calling this method multiple times per host will not result in faster network transactions.</db:para>
</db:note>
<db:note>
<db:para>This function has no possibility to report errors.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.13.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#connectToHost">connectToHost</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#get">get</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#post">post</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#put">put</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#deleteResource">deleteResource</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cookieJar">
<db:title>QNetworkCookieJar *QNetworkAccessManager::cookieJar() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkCookieJar *</db:type>
<db:methodname>cookieJar</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkCookieJar * cookieJar() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qnetworkcookiejar.xml">QNetworkCookieJar</db:link> that is used to store cookies obtained from the network as well as cookies that are about to be sent.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setCookieJar">setCookieJar</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="createRequest">
<db:title>[virtual protected] QNetworkReply *QNetworkAccessManager::createRequest(QNetworkAccessManager::Operation <db:emphasis>op</db:emphasis>, const QNetworkRequest &amp;<db:emphasis>originalReq</db:emphasis>, QIODevice *<db:emphasis>outgoingData</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:type>QNetworkReply *</db:type>
<db:methodname>createRequest</db:methodname>
<db:methodparam>
<db:type>QNetworkAccessManager::Operation</db:type>
<db:parameter>op</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>originalReq</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>outgoingData</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * createRequest(QNetworkAccessManager::Operation op, const QNetworkRequest &amp;originalReq, QIODevice *outgoingData)</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> object to handle the operation <db:code role="parameter">op</db:code> and request <db:code role="parameter">originalReq</db:code>. The device <db:code role="parameter">outgoingData</db:code> is always 0 for Get and Head requests, but is the value passed to <db:link xlink:href="qnetworkaccessmanager.xml#post">post</db:link>() and <db:link xlink:href="qnetworkaccessmanager.xml#put">put</db:link>() in those operations (the <db:link xlink:href="qbytearray.xml">QByteArray</db:link> variants will pass a <db:link xlink:href="qbuffer.xml">QBuffer</db:link> object).</db:para>
<db:para>The default implementation calls <db:link xlink:href="qnetworkcookiejar.xml#cookiesForUrl">QNetworkCookieJar::cookiesForUrl</db:link>() on the cookie jar set with <db:link xlink:href="qnetworkaccessmanager.xml#setCookieJar">setCookieJar</db:link>() to obtain the cookies to be sent to the remote server.</db:para>
<db:para>The returned object must be in an open state.</db:para>
</db:section>
<db:section xml:id="deleteResource">
<db:title>[since 4.6] QNetworkReply *QNetworkAccessManager::deleteResource(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QNetworkReply *</db:type>
<db:methodname>deleteResource</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * deleteResource(const QNetworkRequest &amp;request)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sends a request to delete the resource identified by the URL of <db:code role="parameter">request</db:code>.</db:para>
<db:note>
<db:para>This feature is currently available for HTTP only, performing an HTTP DELETE request.</db:para>
</db:note>
<db:para>This function was introduced in Qt 4.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#get">get</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#post">post</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#put">put</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#sendCustomRequest">sendCustomRequest</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="enableStrictTransportSecurityStore">
<db:title>[since 5.10] void QNetworkAccessManager::enableStrictTransportSecurityStore(bool <db:emphasis>enabled</db:emphasis>, const QString &amp;<db:emphasis>storeDir</db:emphasis> = QString())</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>enableStrictTransportSecurityStore</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enabled</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>storeDir</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void enableStrictTransportSecurityStore(bool enabled, const QString &amp;storeDir)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">enabled</db:code> is true, the internal HSTS cache will use a persistent store to read and write HSTS policies. <db:code role="parameter">storeDir</db:code> defines where this store will be located. The default location is defined by <db:link xlink:href="qstandardpaths.xml#StandardLocation-enum">QStandardPaths::CacheLocation</db:link>. If there is no writable QStandartPaths::CacheLocation and <db:code role="parameter">storeDir</db:code> is an empty string, the store will be located in the program's working directory.</db:para>
<db:note>
<db:para>If HSTS cache already contains HSTS policies by the time persistent store is enabled, these policies will be preserved in the store. In case both cache and store contain the same known hosts, policies from cache are considered to be more up-to-date (and thus will overwrite the previous values in the store). If this behavior is undesired, enable HSTS store before enabling Strict Tranport Security. By default, the persistent store of HSTS policies is disabled.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#isStrictTransportSecurityStoreEnabled">isStrictTransportSecurityStoreEnabled</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setStrictTransportSecurityEnabled">setStrictTransportSecurityEnabled</db:link>()</db:member>
<db:member><db:link xlink:href="qstandardpaths.xml#standardLocations">QStandardPaths::standardLocations</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="encrypted">
<db:title>[since 5.1] void QNetworkAccessManager::encrypted(QNetworkReply *<db:emphasis>reply</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>encrypted</db:methodname>
<db:methodparam>
<db:type>QNetworkReply *</db:type>
<db:parameter>reply</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void encrypted(QNetworkReply *reply)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when an SSL/TLS session has successfully completed the initial handshake. At this point, no user data has been transmitted. The signal can be used to perform additional checks on the certificate chain, for example to notify users when the certificate for a website has changed. The <db:code role="parameter">reply</db:code> parameter specifies which network reply is responsible. If the reply does not match the expected criteria then it should be aborted by calling <db:link xlink:href="qnetworkreply.xml#abort">QNetworkReply::abort</db:link>() by a slot connected to this signal. The SSL configuration in use can be inspected using the <db:link xlink:href="qnetworkreply.xml#sslConfiguration">QNetworkReply::sslConfiguration</db:link>() method.</db:para>
<db:para>Internally, <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> may open multiple connections to a server, in order to allow it process requests in parallel. These connections may be reused, which means that the encrypted() signal would not be emitted. This means that you are only guaranteed to receive this signal for the first connection to a site in the lifespan of the <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#encrypted">QSslSocket::encrypted</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkreply.xml#encrypted">QNetworkReply::encrypted</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="finished">
<db:title>void QNetworkAccessManager::finished(QNetworkReply *<db:emphasis>reply</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>finished</db:methodname>
<db:methodparam>
<db:type>QNetworkReply *</db:type>
<db:parameter>reply</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void finished(QNetworkReply *reply)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever a pending network reply is finished. The <db:code role="parameter">reply</db:code> parameter will contain a pointer to the reply that has just finished. This signal is emitted in tandem with the <db:link xlink:href="qnetworkreply.xml#finished">QNetworkReply::finished</db:link>() signal.</db:para>
<db:para>See <db:link xlink:href="qnetworkreply.xml#finished">QNetworkReply::finished</db:link>() for information on the status that the object will be in.</db:para>
<db:note>
<db:para>Do not delete the <db:code role="parameter">reply</db:code> object in the slot connected to this signal. Use <db:link xlink:href="qobject.xml#deleteLater">deleteLater</db:link>().</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkreply.xml#finished">QNetworkReply::finished</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkreply.xml#error">QNetworkReply::error</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="get">
<db:title>QNetworkReply *QNetworkAccessManager::get(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QNetworkReply *</db:type>
<db:methodname>get</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * get(const QNetworkRequest &amp;request)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Posts a request to obtain the contents of the target <db:code role="parameter">request</db:code> and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> object opened for reading which emits the <db:link xlink:href="qiodevice.xml#readyRead">readyRead</db:link>() signal whenever new data arrives.</db:para>
<db:para>The contents as well as associated headers will be downloaded.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#post">post</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#put">put</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#deleteResource">deleteResource</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#sendCustomRequest">sendCustomRequest</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="head">
<db:title>QNetworkReply *QNetworkAccessManager::head(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QNetworkReply *</db:type>
<db:methodname>head</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * head(const QNetworkRequest &amp;request)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Posts a request to obtain the network headers for <db:code role="parameter">request</db:code> and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> object which will contain such headers.</db:para>
<db:para>The function is named after the HTTP request associated (HEAD).</db:para>
</db:section>
<db:section xml:id="isStrictTransportSecurityEnabled">
<db:title>[since 5.9] bool QNetworkAccessManager::isStrictTransportSecurityEnabled() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isStrictTransportSecurityEnabled</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isStrictTransportSecurityEnabled() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if HTTP Strict Transport Security (HSTS) was enabled. By default HSTS is disabled.</db:para>
<db:para>This function was introduced in Qt 5.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setStrictTransportSecurityEnabled">setStrictTransportSecurityEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isStrictTransportSecurityStoreEnabled">
<db:title>[since 5.10] bool QNetworkAccessManager::isStrictTransportSecurityStoreEnabled() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isStrictTransportSecurityStoreEnabled</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isStrictTransportSecurityStoreEnabled() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if HSTS cache uses a permanent store to load and store HSTS policies.</db:para>
<db:para>This function was introduced in Qt 5.10.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#enableStrictTransportSecurityStore">enableStrictTransportSecurityStore</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="post">
<db:title>QNetworkReply *QNetworkAccessManager::post(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, QIODevice *<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QNetworkReply *</db:type>
<db:methodname>post</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * post(const QNetworkRequest &amp;request, QIODevice *data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sends an HTTP POST request to the destination specified by <db:code role="parameter">request</db:code> and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> object opened for reading that will contain the reply sent by the server. The contents of the <db:code role="parameter">data</db:code> device will be uploaded to the server.</db:para>
<db:para><db:code role="parameter">data</db:code> must be open for reading and must remain valid until the <db:link xlink:href="qnetworkaccessmanager.xml#finished">finished</db:link>() signal is emitted for this reply.</db:para>
<db:note>
<db:para>Sending a POST request on protocols other than HTTP and HTTPS is undefined and will probably fail.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#get">get</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#put">put</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#deleteResource">deleteResource</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#sendCustomRequest">sendCustomRequest</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="post-1">
<db:title>QNetworkReply *QNetworkAccessManager::post(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QNetworkReply *</db:type>
<db:methodname>post</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * post(const QNetworkRequest &amp;request, const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends the contents of the <db:code role="parameter">data</db:code> byte array to the destination specified by <db:code role="parameter">request</db:code>.</db:para>
</db:section>
<db:section xml:id="post-2">
<db:title>[since 4.8] QNetworkReply *QNetworkAccessManager::post(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, QHttpMultiPart *<db:emphasis>multiPart</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QNetworkReply *</db:type>
<db:methodname>post</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QHttpMultiPart *</db:type>
<db:parameter>multiPart</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * post(const QNetworkRequest &amp;request, QHttpMultiPart *multiPart)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends the contents of the <db:code role="parameter">multiPart</db:code> message to the destination specified by <db:code role="parameter">request</db:code>.</db:para>
<db:para>This can be used for sending MIME multipart messages over HTTP.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhttpmultipart.xml">QHttpMultiPart</db:link></db:member>
<db:member><db:link xlink:href="qhttppart.xml">QHttpPart</db:link></db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#put">put</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="preSharedKeyAuthenticationRequired">
<db:title>[since 5.5] void QNetworkAccessManager::preSharedKeyAuthenticationRequired(QNetworkReply *<db:emphasis>reply</db:emphasis>, QSslPreSharedKeyAuthenticator *<db:emphasis>authenticator</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>preSharedKeyAuthenticationRequired</db:methodname>
<db:methodparam>
<db:type>QNetworkReply *</db:type>
<db:parameter>reply</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QSslPreSharedKeyAuthenticator *</db:type>
<db:parameter>authenticator</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void preSharedKeyAuthenticationRequired(QNetworkReply *reply, QSslPreSharedKeyAuthenticator *authenticator)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required. The <db:code role="parameter">reply</db:code> object is the <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> that is negotiating such ciphersuites.</db:para>
<db:para>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <db:code role="parameter">authenticator</db:code> object according to their needs.</db:para>
<db:note>
<db:para>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</db:para>
</db:note>
<db:note>
<db:para>The <db:code role="parameter">authenticator</db:code> object is owned by the reply and must not be deleted by the application.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslpresharedkeyauthenticator.xml">QSslPreSharedKeyAuthenticator</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="proxy">
<db:title>QNetworkProxy QNetworkAccessManager::proxy() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkProxy</db:type>
<db:methodname>proxy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkProxy proxy() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> that the requests sent using this <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> object will use. The default value for the proxy is <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::DefaultProxy</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setProxy">setProxy</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setProxyFactory">setProxyFactory</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#proxyAuthenticationRequired">proxyAuthenticationRequired</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="proxyAuthenticationRequired">
<db:title>void QNetworkAccessManager::proxyAuthenticationRequired(const QNetworkProxy &amp;<db:emphasis>proxy</db:emphasis>, QAuthenticator *<db:emphasis>authenticator</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>proxyAuthenticationRequired</db:methodname>
<db:methodparam>
<db:type>const QNetworkProxy &amp;</db:type>
<db:parameter>proxy</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QAuthenticator *</db:type>
<db:parameter>authenticator</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void proxyAuthenticationRequired(const QNetworkProxy &amp;proxy, QAuthenticator *authenticator)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever a proxy requests authentication and <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> cannot find a valid, cached credential. The slot connected to this signal should fill in the credentials for the proxy <db:code role="parameter">proxy</db:code> in the <db:code role="parameter">authenticator</db:code> object.</db:para>
<db:para><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> will cache the credentials internally. The next time the proxy requests authentication, <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> will automatically send the same credential without emitting the proxyAuthenticationRequired signal again.</db:para>
<db:para>If the proxy rejects the credentials, <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> will emit the signal again.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#proxy">proxy</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setProxy">setProxy</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#authenticationRequired">authenticationRequired</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="proxyFactory">
<db:title>[since 4.5] QNetworkProxyFactory *QNetworkAccessManager::proxyFactory() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkProxyFactory *</db:type>
<db:methodname>proxyFactory</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkProxyFactory * proxyFactory() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the proxy factory that this <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> object is using to determine the proxies to be used for requests.</db:para>
<db:para>Note that the pointer returned by this function is managed by <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> and could be deleted at any time.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setProxyFactory">setProxyFactory</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#proxy">proxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="put">
<db:title>QNetworkReply *QNetworkAccessManager::put(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, QIODevice *<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QNetworkReply *</db:type>
<db:methodname>put</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * put(const QNetworkRequest &amp;request, QIODevice *data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Uploads the contents of <db:code role="parameter">data</db:code> to the destination <db:code role="parameter">request</db:code> and returns a new <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> object that will be open for reply.</db:para>
<db:para><db:code role="parameter">data</db:code> must be opened for reading when this function is called and must remain valid until the <db:link xlink:href="qnetworkaccessmanager.xml#finished">finished</db:link>() signal is emitted for this reply.</db:para>
<db:para>Whether anything will be available for reading from the returned object is protocol dependent. For HTTP, the server may send a small HTML page indicating the upload was successful (or not). Other protocols will probably have content in their replies.</db:para>
<db:note>
<db:para>For HTTP, this request will send a PUT request, which most servers do not allow. Form upload mechanisms, including that of uploading files through HTML forms, use the POST mechanism.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#get">get</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#post">post</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#deleteResource">deleteResource</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#sendCustomRequest">sendCustomRequest</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="put-1">
<db:title>QNetworkReply *QNetworkAccessManager::put(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QNetworkReply *</db:type>
<db:methodname>put</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * put(const QNetworkRequest &amp;request, const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends the contents of the <db:code role="parameter">data</db:code> byte array to the destination specified by <db:code role="parameter">request</db:code>.</db:para>
</db:section>
<db:section xml:id="put-2">
<db:title>[since 4.8] QNetworkReply *QNetworkAccessManager::put(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, QHttpMultiPart *<db:emphasis>multiPart</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QNetworkReply *</db:type>
<db:methodname>put</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QHttpMultiPart *</db:type>
<db:parameter>multiPart</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * put(const QNetworkRequest &amp;request, QHttpMultiPart *multiPart)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends the contents of the <db:code role="parameter">multiPart</db:code> message to the destination specified by <db:code role="parameter">request</db:code>.</db:para>
<db:para>This can be used for sending MIME multipart messages over HTTP.</db:para>
<db:para>This function was introduced in Qt 4.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhttpmultipart.xml">QHttpMultiPart</db:link></db:member>
<db:member><db:link xlink:href="qhttppart.xml">QHttpPart</db:link></db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#post">post</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="redirectPolicy">
<db:title>[since 5.9] QNetworkRequest::RedirectPolicy QNetworkAccessManager::redirectPolicy() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkRequest::RedirectPolicy</db:type>
<db:methodname>redirectPolicy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkRequest::RedirectPolicy redirectPolicy() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the redirect policy that is used when creating new requests.</db:para>
<db:para>This function was introduced in Qt 5.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setRedirectPolicy">setRedirectPolicy</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkrequest.xml#RedirectPolicy-enum">QNetworkRequest::RedirectPolicy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sendCustomRequest">
<db:title>[since 4.7] QNetworkReply *QNetworkAccessManager::sendCustomRequest(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>verb</db:emphasis>, QIODevice *<db:emphasis>data</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:type>QNetworkReply *</db:type>
<db:methodname>sendCustomRequest</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>verb</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>data</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * sendCustomRequest(const QNetworkRequest &amp;request, const QByteArray &amp;verb, QIODevice *data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sends a custom request to the server identified by the URL of <db:code role="parameter">request</db:code>.</db:para>
<db:para>It is the user's responsibility to send a <db:code role="parameter">verb</db:code> to the server that is valid according to the HTTP specification.</db:para>
<db:para>This method provides means to send verbs other than the common ones provided via <db:link xlink:href="qnetworkaccessmanager.xml#get">get</db:link>() or <db:link xlink:href="qnetworkaccessmanager.xml#post">post</db:link>() etc., for instance sending an HTTP OPTIONS command.</db:para>
<db:para>If <db:code role="parameter">data</db:code> is not empty, the contents of the <db:code role="parameter">data</db:code> device will be uploaded to the server; in that case, data must be open for reading and must remain valid until the <db:link xlink:href="qnetworkaccessmanager.xml#finished">finished</db:link>() signal is emitted for this reply.</db:para>
<db:note>
<db:para>This feature is currently available for HTTP(S) only.</db:para>
</db:note>
<db:para>This function was introduced in Qt 4.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#get">get</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#post">post</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#put">put</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#deleteResource">deleteResource</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sendCustomRequest-1">
<db:title>[since 5.8] QNetworkReply *QNetworkAccessManager::sendCustomRequest(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>verb</db:emphasis>, const QByteArray &amp;<db:emphasis>data</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QNetworkReply *</db:type>
<db:methodname>sendCustomRequest</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>verb</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>data</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * sendCustomRequest(const QNetworkRequest &amp;request, const QByteArray &amp;verb, const QByteArray &amp;data)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends the contents of the <db:code role="parameter">data</db:code> byte array to the destination specified by <db:code role="parameter">request</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
</db:section>
<db:section xml:id="sendCustomRequest-2">
<db:title>[since 5.8] QNetworkReply *QNetworkAccessManager::sendCustomRequest(const QNetworkRequest &amp;<db:emphasis>request</db:emphasis>, const QByteArray &amp;<db:emphasis>verb</db:emphasis>, QHttpMultiPart *<db:emphasis>multiPart</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QNetworkReply *</db:type>
<db:methodname>sendCustomRequest</db:methodname>
<db:methodparam>
<db:type>const QNetworkRequest &amp;</db:type>
<db:parameter>request</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>verb</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QHttpMultiPart *</db:type>
<db:parameter>multiPart</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkReply * sendCustomRequest(const QNetworkRequest &amp;request, const QByteArray &amp;verb, QHttpMultiPart *multiPart)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Sends a custom request to the server identified by the URL of <db:code role="parameter">request</db:code>.</db:para>
<db:para>Sends the contents of the <db:code role="parameter">multiPart</db:code> message to the destination specified by <db:code role="parameter">request</db:code>.</db:para>
<db:para>This can be used for sending MIME multipart messages for custom verbs.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qhttpmultipart.xml">QHttpMultiPart</db:link></db:member>
<db:member><db:link xlink:href="qhttppart.xml">QHttpPart</db:link></db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#put">put</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setAutoDeleteReplies">
<db:title>[since 5.14] void QNetworkAccessManager::setAutoDeleteReplies(bool <db:emphasis>shouldAutoDelete</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setAutoDeleteReplies</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>shouldAutoDelete</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setAutoDeleteReplies(bool shouldAutoDelete)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Enables or disables automatic deletion of <db:link xlink:href="qnetworkreply.xml">QNetworkReplies</db:link>.</db:para>
<db:para>Setting <db:code role="parameter">shouldAutoDelete</db:code> to true is the same as setting the <db:link xlink:href="qnetworkrequest.xml#Attribute-enum">QNetworkRequest::AutoDeleteReplyOnFinishAttribute</db:link> attribute to true on all <db:emphasis>future</db:emphasis> <db:link xlink:href="qnetworkrequest.xml">QNetworkRequests</db:link> passed to this instance of <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> unless the attribute was already explicitly set on the <db:link xlink:href="qnetworkrequest.xml">QNetworkRequest</db:link>.</db:para>
<db:para>This function was introduced in Qt 5.14.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#autoDeleteReplies">autoDeleteReplies</db:link></db:member>
<db:member><db:link xlink:href="qnetworkrequest.xml#Attribute-enum">QNetworkRequest::AutoDeleteReplyOnFinishAttribute</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCache">
<db:title>[since 4.5] void QNetworkAccessManager::setCache(QAbstractNetworkCache *<db:emphasis>cache</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setCache</db:methodname>
<db:methodparam>
<db:type>QAbstractNetworkCache *</db:type>
<db:parameter>cache</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setCache(QAbstractNetworkCache *cache)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the manager's network cache to be the <db:code role="parameter">cache</db:code> specified. The cache is used for all requests dispatched by the manager.</db:para>
<db:para>Use this function to set the network cache object to a class that implements additional features, like saving the cookies to permanent storage.</db:para>
<db:note>
<db:para><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> takes ownership of the <db:code role="parameter">cache</db:code> object.</db:para>
</db:note>
<db:para><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> by default does not have a set cache. Qt provides a simple disk cache, <db:link xlink:href="qnetworkdiskcache.xml">QNetworkDiskCache</db:link>, which can be used.</db:para>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#cache">cache</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkrequest.xml#CacheLoadControl-enum">QNetworkRequest::CacheLoadControl</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCookieJar">
<db:title>void QNetworkAccessManager::setCookieJar(QNetworkCookieJar *<db:emphasis>cookieJar</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setCookieJar</db:methodname>
<db:methodparam>
<db:type>QNetworkCookieJar *</db:type>
<db:parameter>cookieJar</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setCookieJar(QNetworkCookieJar *cookieJar)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the manager's cookie jar to be the <db:code role="parameter">cookieJar</db:code> specified. The cookie jar is used by all requests dispatched by the manager.</db:para>
<db:para>Use this function to set the cookie jar object to a class that implements additional features, like saving the cookies to permanent storage.</db:para>
<db:note>
<db:para><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> takes ownership of the <db:code role="parameter">cookieJar</db:code> object.</db:para>
</db:note>
<db:para>If <db:code role="parameter">cookieJar</db:code> is in the same thread as this <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>, it will set the parent of the <db:code role="parameter">cookieJar</db:code> so that the cookie jar is deleted when this object is deleted as well. If you want to share cookie jars between different <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> objects, you may want to set the cookie jar's parent to 0 after calling this function.</db:para>
<db:para><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> by default does not implement any cookie policy of its own: it accepts all cookies sent by the server, as long as they are well formed and meet the minimum security requirements (cookie domain matches the request's and cookie path matches the request's). In order to implement your own security policy, override the <db:link xlink:href="qnetworkcookiejar.xml#cookiesForUrl">QNetworkCookieJar::cookiesForUrl</db:link>() and <db:link xlink:href="qnetworkcookiejar.xml#setCookiesFromUrl">QNetworkCookieJar::setCookiesFromUrl</db:link>() virtual functions. Those functions are called by <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> when it detects a new cookie.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#cookieJar">cookieJar</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkcookiejar.xml#cookiesForUrl">QNetworkCookieJar::cookiesForUrl</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkcookiejar.xml#setCookiesFromUrl">QNetworkCookieJar::setCookiesFromUrl</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProxy">
<db:title>void QNetworkAccessManager::setProxy(const QNetworkProxy &amp;<db:emphasis>proxy</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setProxy</db:methodname>
<db:methodparam>
<db:type>const QNetworkProxy &amp;</db:type>
<db:parameter>proxy</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setProxy(const QNetworkProxy &amp;proxy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the proxy to be used in future requests to be <db:code role="parameter">proxy</db:code>. This does not affect requests that have already been sent. The <db:link xlink:href="qnetworkaccessmanager.xml#proxyAuthenticationRequired">proxyAuthenticationRequired</db:link>() signal will be emitted if the proxy requests authentication.</db:para>
<db:para>A proxy set with this function will be used for all requests issued by <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>. In some cases, it might be necessary to select different proxies depending on the type of request being sent or the destination host. If that's the case, you should consider using <db:link xlink:href="qnetworkaccessmanager.xml#setProxyFactory">setProxyFactory</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#proxy">proxy</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#proxyAuthenticationRequired">proxyAuthenticationRequired</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setProxyFactory">
<db:title>[since 4.5] void QNetworkAccessManager::setProxyFactory(QNetworkProxyFactory *<db:emphasis>factory</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setProxyFactory</db:methodname>
<db:methodparam>
<db:type>QNetworkProxyFactory *</db:type>
<db:parameter>factory</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setProxyFactory(QNetworkProxyFactory *factory)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the proxy factory for this class to be <db:code role="parameter">factory</db:code>. A proxy factory is used to determine a more specific list of proxies to be used for a given request, instead of trying to use the same proxy value for all requests.</db:para>
<db:para>All queries sent by <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> will have type <db:link xlink:href="qnetworkproxyquery.xml#QueryType-enum">QNetworkProxyQuery::UrlRequest</db:link>.</db:para>
<db:para>For example, a proxy factory could apply the following rules:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>if the target address is in the local network (for example, if the hostname contains no dots or if it's an IP address in the organization's range), return <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::NoProxy</db:link></db:para>
</db:listitem>
<db:listitem>
<db:para>if the request is FTP, return an FTP proxy</db:para>
</db:listitem>
<db:listitem>
<db:para>if the request is HTTP or HTTPS, then return an HTTP proxy</db:para>
</db:listitem>
<db:listitem>
<db:para>otherwise, return a SOCKSv5 proxy server</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The lifetime of the object <db:code role="parameter">factory</db:code> will be managed by <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>. It will delete the object when necessary.</db:para>
<db:note>
<db:para>If a specific proxy is set with <db:link xlink:href="qnetworkaccessmanager.xml#setProxy">setProxy</db:link>(), the factory will not be used.</db:para>
</db:note>
<db:para>This function was introduced in Qt 4.5.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#proxyFactory">proxyFactory</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setProxy">setProxy</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxyquery.xml">QNetworkProxyQuery</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setRedirectPolicy">
<db:title>[since 5.9] void QNetworkAccessManager::setRedirectPolicy(QNetworkRequest::RedirectPolicy <db:emphasis>policy</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setRedirectPolicy</db:methodname>
<db:methodparam>
<db:type>QNetworkRequest::RedirectPolicy</db:type>
<db:parameter>policy</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setRedirectPolicy(QNetworkRequest::RedirectPolicy policy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the manager's redirect policy to be the <db:code role="parameter">policy</db:code> specified. This policy will affect all subsequent requests created by the manager.</db:para>
<db:para>Use this function to enable or disable HTTP redirects on the manager's level.</db:para>
<db:note>
<db:para>When creating a request QNetworkRequest::RedirectAttributePolicy has the highest priority, next by priority is <db:link xlink:href="qnetworkrequest.xml#Attribute-enum">QNetworkRequest::FollowRedirectsAttribute</db:link>. Finally, the manager's policy has the lowest priority.</db:para>
</db:note>
<db:para>For backwards compatibility the default value is <db:link xlink:href="qnetworkrequest.xml#RedirectPolicy-enum">QNetworkRequest::ManualRedirectPolicy</db:link>. This may change in the future and some type of auto-redirect policy will become the default; clients relying on manual redirect handling are encouraged to set this policy explicitly in their code.</db:para>
<db:para>This function was introduced in Qt 5.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#redirectPolicy">redirectPolicy</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkrequest.xml#RedirectPolicy-enum">QNetworkRequest::RedirectPolicy</db:link></db:member>
<db:member><db:link xlink:href="qnetworkrequest.xml#Attribute-enum">QNetworkRequest::FollowRedirectsAttribute</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setStrictTransportSecurityEnabled">
<db:title>[since 5.9] void QNetworkAccessManager::setStrictTransportSecurityEnabled(bool <db:emphasis>enabled</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setStrictTransportSecurityEnabled</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>enabled</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setStrictTransportSecurityEnabled(bool enabled)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If <db:code role="parameter">enabled</db:code> is true, <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> follows the HTTP Strict Transport Security policy (HSTS, RFC6797). When processing a request, <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> automatically replaces the &quot;http&quot; scheme with &quot;https&quot; and uses a secure transport for HSTS hosts. If it's set explicitly, port 80 is replaced by port 443.</db:para>
<db:para>When HSTS is enabled, for each HTTP response containing HSTS header and received over a secure transport, <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> will update its HSTS cache, either remembering a host with a valid policy or removing a host with an expired or disabled HSTS policy.</db:para>
<db:para>This function was introduced in Qt 5.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#isStrictTransportSecurityEnabled">isStrictTransportSecurityEnabled</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setTransferTimeout">
<db:title>[since 5.15] void QNetworkAccessManager::setTransferTimeout(int <db:emphasis>timeout</db:emphasis> = QNetworkRequest::DefaultTransferTimeoutConstant)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setTransferTimeout</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>timeout</db:parameter>
<db:initializer>QNetworkRequest::DefaultTransferTimeoutConstant</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setTransferTimeout(int timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets <db:code role="parameter">timeout</db:code> as the transfer timeout in milliseconds.</db:para>
<db:para>Transfers are aborted if no bytes are transferred before the timeout expires. Zero means no timer is set. If no argument is provided, the timeout is <db:link xlink:href="qnetworkrequest.xml#TransferTimeoutConstant-enum">QNetworkRequest::DefaultTransferTimeoutConstant</db:link>. If this function is not called, the timeout is disabled and has the value zero. The request-specific non-zero timeouts set for the requests that are executed override this value. This means that if <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> has an enabled timeout, it needs to be disabled to execute a request without a timeout.</db:para>
<db:para>This function was introduced in Qt 5.15.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#transferTimeout">transferTimeout</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sslErrors">
<db:title>void QNetworkAccessManager::sslErrors(QNetworkReply *<db:emphasis>reply</db:emphasis>, const QList&lt;QSslError&gt; &amp;<db:emphasis>errors</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>sslErrors</db:methodname>
<db:methodparam>
<db:type>QNetworkReply *</db:type>
<db:parameter>reply</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QList&lt;QSslError&gt; &amp;</db:type>
<db:parameter>errors</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void sslErrors(QNetworkReply *reply, const QList&lt;QSslError&gt; &amp;errors)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted if the SSL/TLS session encountered errors during the set up, including certificate verification errors. The <db:code role="parameter">errors</db:code> parameter contains the list of errors and <db:code role="parameter">reply</db:code> is the <db:link xlink:href="qnetworkreply.xml">QNetworkReply</db:link> that is encountering these errors.</db:para>
<db:para>To indicate that the errors are not fatal and that the connection should proceed, the <db:link xlink:href="qnetworkreply.xml#ignoreSslErrors">QNetworkReply::ignoreSslErrors</db:link>() function should be called from the slot connected to this signal. If it is not called, the SSL session will be torn down before any data is exchanged (including the URL).</db:para>
<db:para>This signal can be used to display an error message to the user indicating that security may be compromised and display the SSL settings (see sslConfiguration() to obtain it). If the user decides to proceed after analyzing the remote certificate, the slot should call ignoreSslErrors().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsslsocket.xml#sslErrors" role="deprecated">QSslSocket::sslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkreply.xml#sslErrors">QNetworkReply::sslErrors</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkreply.xml#sslConfiguration">QNetworkReply::sslConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkreply.xml#ignoreSslErrors">QNetworkReply::ignoreSslErrors</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="strictTransportSecurityHosts">
<db:title>[since 5.9] QVector&lt;QHstsPolicy&gt; QNetworkAccessManager::strictTransportSecurityHosts() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVector&lt;QHstsPolicy&gt;</db:type>
<db:methodname>strictTransportSecurityHosts</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVector&lt;QHstsPolicy&gt; strictTransportSecurityHosts() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the list of HTTP Strict Transport Security policies. This list can differ from what was initially set via <db:link xlink:href="qnetworkaccessmanager.xml#addStrictTransportSecurityHosts">addStrictTransportSecurityHosts</db:link>() if HSTS cache was updated from a &quot;Strict-Transport-Security&quot; response header.</db:para>
<db:para>This function was introduced in Qt 5.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#addStrictTransportSecurityHosts">addStrictTransportSecurityHosts</db:link>()</db:member>
<db:member><db:link xlink:href="qhstspolicy.xml">QHstsPolicy</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportedSchemes">
<db:title>[since 5.2] QStringList QNetworkAccessManager::supportedSchemes() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>supportedSchemes</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList supportedSchemes() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Lists all the URL schemes supported by the access manager.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#supportedSchemesImplementation">supportedSchemesImplementation</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="supportedSchemesImplementation">
<db:title>[protected, since 5.2] QStringList QNetworkAccessManager::supportedSchemesImplementation() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>supportedSchemesImplementation</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList supportedSchemesImplementation() const</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Lists all the URL schemes supported by the access manager.</db:para>
<db:para>You should not call this function directly; use <db:link xlink:href="qnetworkaccessmanager.xml#supportedSchemes">QNetworkAccessManager::supportedSchemes</db:link>() instead.</db:para>
<db:para>Reimplement this slot to provide your own supported schemes in a <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> subclass. It is for instance necessary when your subclass provides support for new protocols.</db:para>
<db:para>Because of binary compatibility constraints, the <db:link xlink:href="qnetworkaccessmanager.xml#supportedSchemes">supportedSchemes</db:link>() method (introduced in Qt 5.2) is not virtual. Instead, <db:link xlink:href="qnetworkaccessmanager.xml#supportedSchemes">supportedSchemes</db:link>() will dynamically detect and call this slot.</db:para>
<db:para>This function was introduced in Qt 5.2.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#supportedSchemes">supportedSchemes</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="transferTimeout">
<db:title>[since 5.15] int QNetworkAccessManager::transferTimeout() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>transferTimeout</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int transferTimeout() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the timeout used for transfers, in milliseconds.</db:para>
<db:para>This timeout is zero if <db:link xlink:href="qnetworkaccessmanager.xml#setTransferTimeout">setTransferTimeout</db:link>() hasn't been called, which means that the timeout is not used.</db:para>
<db:para>This function was introduced in Qt 5.15.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setTransferTimeout">setTransferTimeout</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QNetworkAccessManager</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-member-type-documentation">
<db:title>Obsolete Member Type Documentation</db:title>
<db:section xml:id="NetworkAccessibility-enum">
<db:title>enum QNetworkAccessManager::NetworkAccessibility</db:title>
<db:enumsynopsis>
<db:enumname>NetworkAccessibility</db:enumname>
<db:enumitem>
<db:enumidentifier>UnknownAccessibility</db:enumidentifier>
<db:enumvalue>-1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NotAccessible</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Accessible</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Indicates whether the network is accessible via this network access manager.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:emphasis>::UnknownAccessibility</db:code></db:para>
</db:td>
<db:td><db:code>-1</db:code></db:td>
<db:td>
<db:para>The network accessibility cannot be determined.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:emphasis>::NotAccessible</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The network is not currently accessible, either because there is currently no network coverage or network access has been explicitly disabled by a call to <db:link xlink:href="qnetworkaccessmanager.xml#setNetworkAccessible">setNetworkAccessible</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link></db:emphasis>::Accessible</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The network is accessible.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#networkAccessible">networkAccessible</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete-property-documentation">
<db:title>Obsolete Property Documentation</db:title>
<db:section xml:id="networkAccessible-prop">
<db:title>[since 4.7] networkAccessible : NetworkAccessibility</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>NetworkAccessibility</db:type>
<db:varname>networkAccessible</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">networkAccessible</db:synopsisinfo>
<db:synopsisinfo role="setter">setNetworkAccessible</db:synopsisinfo>
<db:synopsisinfo role="notifier">networkAccessibleChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This property holds whether the network is currently accessible via this network access manager.</db:para>
<db:para>If the network is <db:link xlink:href="qnetworkaccessmanager.xml#NetworkAccessibility-enum">not accessible</db:link> the network access manager will not process any new network requests, all such requests will fail with an error. Requests with URLs with the file:// scheme will still be processed.</db:para>
<db:para>By default the value of this property reflects the physical state of the device. Applications may override it to disable all network requests via this network access manager by calling</db:para>
<db:programlisting language="cpp">networkAccessManager-&amp;gt;setNetworkAccessible(QNetworkAccessManager::NotAccessible);
</db:programlisting>
<db:para>Network requests can be re-enabled again, and this property will resume to reflect the actual device state by calling</db:para>
<db:programlisting language="cpp">networkAccessManager-&amp;gt;setNetworkAccessible(QNetworkAccessManager::Accessible);
</db:programlisting>
<db:note>
<db:para>Calling <db:link xlink:href="qnetworkaccessmanager.xml#setNetworkAccessible">setNetworkAccessible</db:link>() does not change the network state.</db:para>
</db:note>
<db:para>This property was introduced in Qt 4.7.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qnetworkaccessmanager.xml#NetworkAccessibility-enum">QNetworkAccessManager::NetworkAccessibility</db:link></db:type> <db:emphasis role="bold"><db:link xlink:href="qnetworkaccessmanager.xml#networkAccessible">networkAccessible</db:link></db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qnetworkaccessmanager.xml#setNetworkAccessible">setNetworkAccessible</db:link></db:emphasis>(<db:type><db:link xlink:href="qnetworkaccessmanager.xml#NetworkAccessibility-enum">QNetworkAccessManager::NetworkAccessibility</db:link></db:type> <db:emphasis>accessible</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold"><db:link xlink:href="qnetworkaccessmanager.xml#networkAccessibleChanged">networkAccessibleChanged</db:link></db:emphasis>(<db:type><db:link xlink:href="qnetworkaccessmanager.xml#NetworkAccessibility-enum">QNetworkAccessManager::NetworkAccessibility</db:link></db:type> <db:emphasis>accessible</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="obsolete-member-function-documentation">
<db:title>Obsolete Member Function Documentation</db:title>
<db:section xml:id="activeConfiguration">
<db:title>[since 4.7] QNetworkConfiguration QNetworkAccessManager::activeConfiguration() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkConfiguration</db:type>
<db:methodname>activeConfiguration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkConfiguration activeConfiguration() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns the current active network configuration.</db:para>
<db:para>If the network configuration returned by <db:link xlink:href="qnetworkaccessmanager.xml#configuration">configuration</db:link>() is of type <db:link xlink:href="qnetworkconfiguration.xml#Type-enum">QNetworkConfiguration::ServiceNetwork</db:link> this function will return the current active child network configuration of that configuration. Otherwise returns the same network configuration as <db:link xlink:href="qnetworkaccessmanager.xml#configuration">configuration</db:link>().</db:para>
<db:para>Use this function to return the actual network configuration currently in use by the network session.</db:para>
<db:para>This function was introduced in Qt 4.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#configuration">configuration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="configuration">
<db:title>[since 4.7] QNetworkConfiguration QNetworkAccessManager::configuration() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkConfiguration</db:type>
<db:methodname>configuration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkConfiguration configuration() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns the network configuration that will be used to create the <db:link xlink:href="qnetworksession.xml">network session</db:link> which will be used when processing network requests.</db:para>
<db:para>This function was introduced in Qt 4.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setConfiguration">setConfiguration</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#activeConfiguration">activeConfiguration</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="networkAccessible">
<db:title>[since 4.7] QNetworkAccessManager::NetworkAccessibility QNetworkAccessManager::networkAccessible() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkAccessManager::NetworkAccessibility</db:type>
<db:methodname>networkAccessible</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">networkAccessible</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkAccessManager::NetworkAccessibility networkAccessible() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Returns the current network accessibility.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qnetworkaccessmanager.xml#networkAccessible-prop">networkAccessible</db:link>. </db:para>
</db:note>
<db:para>This function was introduced in Qt 4.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#setNetworkAccessible">setNetworkAccessible</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="networkAccessibleChanged">
<db:title>void QNetworkAccessManager::networkAccessibleChanged(QNetworkAccessManager::NetworkAccessibility <db:emphasis>accessible</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>networkAccessibleChanged</db:methodname>
<db:methodparam>
<db:type>QNetworkAccessManager::NetworkAccessibility</db:type>
<db:parameter>accessible</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">networkAccessible</db:synopsisinfo>
<db:synopsisinfo role="signature">void networkAccessibleChanged(QNetworkAccessManager::NetworkAccessibility accessible)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>This signal is emitted when the value of the <db:link xlink:href="qnetworkaccessmanager.xml#networkAccessible">networkAccessible</db:link> property changes. <db:code role="parameter">accessible</db:code> is the new network accessibility.</db:para>
<db:note>
<db:para>Notifier signal for property <db:link xlink:href="qnetworkaccessmanager.xml#networkAccessible-prop">networkAccessible</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="setConfiguration">
<db:title>[since 4.7] void QNetworkAccessManager::setConfiguration(const QNetworkConfiguration &amp;<db:emphasis>config</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setConfiguration</db:methodname>
<db:methodparam>
<db:type>const QNetworkConfiguration &amp;</db:type>
<db:parameter>config</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setConfiguration(const QNetworkConfiguration &amp;config)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Sets the network configuration that will be used when creating the <db:link xlink:href="qnetworksession.xml">network session</db:link> to <db:code role="parameter">config</db:code>.</db:para>
<db:para>The network configuration is used to create and open a network session before any request that requires network access is process. If no network configuration is explicitly set via this function the network configuration returned by <db:link xlink:href="qnetworkconfigurationmanager.xml#defaultConfiguration">QNetworkConfigurationManager::defaultConfiguration</db:link>() will be used.</db:para>
<db:para>To restore the default network configuration set the network configuration to the value returned from <db:link xlink:href="qnetworkconfigurationmanager.xml#defaultConfiguration">QNetworkConfigurationManager::defaultConfiguration</db:link>().</db:para>
<db:para>Setting a network configuration means that the <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link> instance will only be using the specified one. In particular, if the default network configuration changes (upon e.g. Wifi being available), this new configuration needs to be enabled manually if desired.</db:para>
<db:programlisting language="cpp">QNetworkConfigurationManager manager;
networkAccessManager-&amp;gt;setConfiguration(manager.defaultConfiguration());
</db:programlisting>
<db:para>If an invalid network configuration is set, a network session will not be created. In this case network requests will be processed regardless, but may fail. For example:</db:para>
<db:programlisting language="cpp">networkAccessManager-&amp;gt;setConfiguration(QNetworkConfiguration());
</db:programlisting>
<db:para>This function was introduced in Qt 4.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#configuration">configuration</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworksession.xml">QNetworkSession</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setNetworkAccessible">
<db:title>[since 4.7] void QNetworkAccessManager::setNetworkAccessible(QNetworkAccessManager::NetworkAccessibility <db:emphasis>accessible</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setNetworkAccessible</db:methodname>
<db:methodparam>
<db:type>QNetworkAccessManager::NetworkAccessibility</db:type>
<db:parameter>accessible</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">networkAccessible</db:synopsisinfo>
<db:synopsisinfo role="signature">void setNetworkAccessible(QNetworkAccessManager::NetworkAccessibility accessible)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">deprecated</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function is deprecated. We strongly advise against using it in new code.</db:para>
<db:para>Overrides the reported network accessibility. If <db:code role="parameter">accessible</db:code> is <db:link xlink:href="qnetworkaccessmanager.xml#NetworkAccessibility-enum">NotAccessible</db:link> the reported network accessiblity will always be <db:link xlink:href="qnetworkaccessmanager.xml#NetworkAccessibility-enum">NotAccessible</db:link>. Otherwise the reported network accessibility will reflect the actual device state.</db:para>
<db:note>
<db:para>Setter function for property <db:link xlink:href="qnetworkaccessmanager.xml#networkAccessible-prop">networkAccessible</db:link>. </db:para>
</db:note>
<db:para>This function was introduced in Qt 4.7.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkaccessmanager.xml#networkAccessible">networkAccessible</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
