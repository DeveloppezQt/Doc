<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QCborValue Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.4.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> class encapsulates a value in CBOR.</db:para>
<db:para>This class was introduced in Qt 5.12.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QCborValue</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.12</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QCborValue is part of <db:simplelist><db:member><db:link xlink:href="cbor.xml">CBOR Support in Qt</db:link></db:member><db:member>qtserialization</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>This class can be used to hold one of the many types available in CBOR. CBOR is the Concise Binary Object Representation, a very compact form of binary data encoding that is a superset of JSON. It was created by the IETF Constrained RESTful Environments (CoRE) WG, which has used it in many new RFCs. It is meant to be used alongside the <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc7252">CoAP protocol</db:link>.</db:para>
<db:para>CBOR has three groups of built-in types:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Basic types: integers, floating point (double), boolean, null, etc.</db:para>
</db:listitem>
<db:listitem>
<db:para>String-like types: strings and byte arrays</db:para>
</db:listitem>
<db:listitem>
<db:para>Containers: arrays and maps</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Additionally, CBOR supports a form of type extensibility by associating a &quot;tag&quot; to one of the above types to convey more information. For example, a UUID is represented by a tag and a byte array containing the 16 bytes of the UUID content. <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> supports creating and decoding several of those extended types directly with Qt classes (like <db:link xlink:href="quuid.xml">QUuid</db:link>).</db:para>
<db:para>For the complete list, see <db:link xlink:href="qcborvalue.xml#Type-enum">QCborValue::Type</db:link>. The type of a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> can be queried using <db:link xlink:href="qcborvalue.xml#type">type</db:link>() or one of the &quot;isXxxx&quot; functions.</db:para>
<db:section xml:id="extended-types-and-tagged-values">
<db:title>Extended types and tagged values</db:title>
<db:para>A tagged value is a normal <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> that is paired with a number that is its tag. See <db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">QCborKnownTags</db:link> for more information on what tags are in the API as well as the full, official list. Such combinations form extended types.</db:para>
<db:para><db:link xlink:href="qcborvalue.xml">QCborValue</db:link> has support for certain extended types in the API, like URL (with <db:link xlink:href="qurl.xml">QUrl</db:link>) and UUID (with <db:link xlink:href="quuid.xml">QUuid</db:link>). Other extended types not supported in the API are represented by a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> of <db:link xlink:href="qcborvalue.xml#Type-enum">Tag</db:link> type. The tag can later be retrieved by <db:link xlink:href="qcborvalue.xml#tag">tag</db:link>() and the tagged value using <db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>().</db:para>
<db:para>In order to support future compatibility, QCborValues containing extended Qt types compare equal to the tag type of the same contents. In other words, the following expression is true:</db:para>
<db:programlisting language="cpp">    QCborValue(uuid) == QCborValue(QCborKnownTags::Uuid, uuid.toRfc4122());
</db:programlisting>
</db:section>
<db:section xml:id="undefined-and-null-values">
<db:title>Undefined and null values</db:title>
<db:para><db:link xlink:href="qcborvalue.xml">QCborValue</db:link> can contain a value of &quot;null&quot;, which is not of any specific type. It resembles the C++ std::nullptr_t type, whose only possible value is nullptr. <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> has a constructor taking such a type and creates a null <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>.</db:para>
<db:para>Null values are used to indicate that an optional value is not present. In that aspect, it is similar to the C++ Standard Library type std::optional when that is disengaged. Unlike the C++ type, CBOR nulls are simply of type &quot;Null&quot; and it is not possible to determine what concrete type it is replacing.</db:para>
<db:para><db:link xlink:href="qcborvalue.xml">QCborValue</db:link> can also be of the undefined type, which represents a value of &quot;undefined&quot;. In fact, that is what the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> default constructor creates.</db:para>
<db:para>Undefined values are different from null values. While nulls are used to indicate an optional value that is not provided, Undefined is usually used to indicate that an expected value could not be provided, usually due to an error or a precondition that could not be satisfied.</db:para>
<db:para>Such values are completely valid and may appear in CBOR streams, unlike JSON content and <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>'s undefined bit. But like <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>'s Undefined, it is returned by a CBOR container's value() or read-only operator[] for invalid look-ups (index out of range for <db:link xlink:href="qcborarray.xml">QCborArray</db:link>, or key not found for <db:link xlink:href="qcbormap.xml">QCborMap</db:link>). It is not possible to tell such a case apart from the value of Undefined, so if that is required, check the <db:link xlink:href="qcborarray.xml">QCborArray</db:link> size and use the <db:link xlink:href="qcbormap.xml">QCborMap</db:link> iterator API.</db:para>
</db:section>
<db:section xml:id="simple-types">
<db:title>Simple types</db:title>
<db:para>CBOR supports additional simple types that, like Null and Undefined, carry no other value. They are called interchangeably &quot;Simple Types&quot; and &quot;Simple Values&quot;. CBOR encodes booleans as two distinct types (one for true and one for false), but <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> has a convenience API for them.</db:para>
<db:para>There are currently no other defined CBOR simple types. <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> supports them simply by their number with API like <db:link xlink:href="qcborvalue.xml#isSimpleType">isSimpleType</db:link>() and <db:link xlink:href="qcborvalue.xml#toSimpleType">toSimpleType</db:link>(), available for compatibility with future specifications before the Qt API can be updated. Their use before such a specification is discouraged, as other CBOR implementations may not support them fully.</db:para>
</db:section>
<db:section xml:id="cbor-support">
<db:title>CBOR support</db:title>
<db:para><db:link xlink:href="qcborvalue.xml">QCborValue</db:link> supports all CBOR features required to create canonical and strict streams. It implements almost all of the features specified in <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc7049">RFC 7049</db:link>.</db:para>
<db:para>The following table lists the CBOR features that <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> supports.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Feature</db:para>
</db:th>
<db:th>
<db:para>Support</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Unsigned numbers</db:para>
</db:td>
<db:td>
<db:para>Yes (qint64 range)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Negative numbers</db:para>
</db:td>
<db:td>
<db:para>Yes (qint64 range)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Byte strings</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Text strings</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Chunked strings</db:para>
</db:td>
<db:td>
<db:para>See below</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Tags</db:para>
</db:td>
<db:td>
<db:para>Yes (arbitrary)</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Booleans</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Null</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Undefined</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Arbitrary simple values</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Half-precision float (16-bit)</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Single-precision float (32-bit)</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Double-precision float (64-bit)</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Infinities and NaN floating point</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Determinate-length arrays and maps</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Indeterminate-length arrays and maps</db:para>
</db:td>
<db:td>
<db:para>Yes</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Map key types other than strings and integers</db:para>
</db:td>
<db:td>
<db:para>Yes (arbitrary)</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Integers in <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> are limited to the range of the qint64 type. That is, from -9,223,372,036,854,775,808 (-2<db:superscript>63</db:superscript>) to 9,223,372,036,854,775,807 (2<db:superscript>63</db:superscript> - 1). CBOR itself can represent integer values outside of this range, which <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> does not support. When decoding a stream using <db:link xlink:href="qcborvalue.xml#fromCbor">fromCbor</db:link>() containing one of those values, <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> will convert automatically to <db:link xlink:href="qcborvalue.xml#Type-enum">Double</db:link>, but that may lose up to 11 bits of precision.</db:para>
<db:para><db:link xlink:href="qcborvalue.xml#fromCbor">fromCbor</db:link>() is able to decode chunked strings, but will always merge the chunks together into a single <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>. For that reason, it always writes non-chunked strings when using <db:link xlink:href="qcborvalue.xml#toCbor">toCbor</db:link>() (which is required by the Canonical format anyway).</db:para>
<db:para><db:link xlink:href="qcborvalue.xml">QCborValue</db:link> will always convert half- and single-precision floating point values in the CBOR stream to double-precision. The <db:link xlink:href="qcborvalue.xml#toCbor">toCbor</db:link>() function can take a parameter indicating to recreate them.</db:para>
</db:section>
<db:section xml:id="qcborvalueref">
<db:title>QCborValueRef</db:title>
<db:para>QCborValueRef is a helper class for <db:link xlink:href="qcborarray.xml">QCborArray</db:link> and <db:link xlink:href="qcbormap.xml">QCborMap</db:link>. It is the type you get when using one of the mutating APIs in those classes. Unlike <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, new values can be assigned to that class. When that is done, the array or map it refers to will be modified with the new value. In all other aspects, its API is identical to <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborarray.xml">QCborArray</db:link></db:member>
<db:member><db:link xlink:href="qcbormap.xml">QCborMap</db:link></db:member>
<db:member><db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link></db:member>
<db:member><db:link xlink:href="qcborstreamwriter.xml">QCborStreamWriter</db:link></db:member>
<db:member><db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link></db:member>
<db:member><db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link></db:member>
<db:member><db:link xlink:href="qtcore-serialization-cbordump-example.xml">Cbordump Example</db:link></db:member>
<db:member><db:link xlink:href="qtcore-serialization-convert-example.xml">Convert Example</db:link></db:member>
<db:member><db:link xlink:href="qtcore-serialization-savegame-example.xml">JSON Save Game Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="DiagnosticNotationOption-enum">
<db:title>enum QCborValue::DiagnosticNotationOption</db:title>
<db:bridgehead renderas="sect2">flags QCborValue::DiagnosticNotationOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>DiagnosticNotationOption</db:enumname>
<db:enumitem>
<db:enumidentifier>Compact</db:enumidentifier>
<db:enumvalue>0x00</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LineWrapped</db:enumidentifier>
<db:enumvalue>0x01</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ExtendedFormat</db:enumidentifier>
<db:enumvalue>0x02</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QCborValue::DiagnosticNotationOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum is used in the option argument to <db:link xlink:href="qcborvalue.xml#toDiagnosticNotation">toDiagnosticNotation</db:link>(), to modify the output format.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::Compact</db:code></db:para>
</db:td>
<db:td><db:code>0x00</db:code></db:td>
<db:td>
<db:para>Does not use any line-breaks, producing a compact representation.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::LineWrapped</db:code></db:para>
</db:td>
<db:td><db:code>0x01</db:code></db:td>
<db:td>
<db:para>Uses line-breaks, one <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> per line.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::ExtendedFormat</db:code></db:para>
</db:td>
<db:td><db:code>0x02</db:code></db:td>
<db:td>
<db:para>Uses some different options to represent values, not found in RFC 7049. Those options are subject to change.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Currently, ExtendedFormat will change how byte arrays are represented. Without it, they are always hex-encoded and without spaces. With it, <db:link xlink:href="qcborvalue.xml#toCbor">QCborValue::toCbor</db:link>() will either use hex with spaces, base64 or base64url encoding, depending on the context.</db:para>
<db:para>The <db:code>DiagnosticNotationOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;DiagnosticNotationOption&gt;. </db:code>It stores an OR combination of <db:code>DiagnosticNotationOption</db:code> values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toDiagnosticNotation">toDiagnosticNotation</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="EncodingOption-enum">
<db:title>enum QCborValue::EncodingOption</db:title>
<db:bridgehead renderas="sect2">flags QCborValue::EncodingOptions</db:bridgehead>
<db:enumsynopsis>
<db:enumname>EncodingOption</db:enumname>
<db:enumitem>
<db:enumidentifier>SortKeysInMaps</db:enumidentifier>
<db:enumvalue>0x01</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UseFloat</db:enumidentifier>
<db:enumvalue>0x02</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UseFloat16</db:enumidentifier>
<db:enumvalue>UseFloat | 0x04</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UseIntegers</db:enumidentifier>
<db:enumvalue>0x08</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NoTransformation</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QCborValue::EncodingOptions</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum is used in the options argument to <db:link xlink:href="qcborvalue.xml#toCbor">toCbor</db:link>(), modifying the behavior of the encoder.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::NoTransformation</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>(Default) Performs no transformations.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::UseFloat</db:code></db:para>
</db:td>
<db:td><db:code>0x02</db:code></db:td>
<db:td>
<db:para>Tells the encoder to use IEEE 754 single-precision floating point (that is, float) whenever possible.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::UseFloat16</db:code></db:para>
</db:td>
<db:td><db:code>UseFloat | 0x04</db:code></db:td>
<db:td>
<db:para>Tells the encoder to use IEEE 754 half-precision floating point (that is, qfloat16), whenever possible. Implies UseFloat.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::UseIntegers</db:code></db:para>
</db:td>
<db:td><db:code>0x08</db:code></db:td>
<db:td>
<db:para>Tells the encoder to use integers whenever a value of type <db:link xlink:href="qcborvalue.xml#Type-enum">Double</db:link> contains an integer.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The use of UseFloat16 is required to encode the stream in Canonical Format, but is not otherwise necessary.</db:para>
<db:para>The <db:code>EncodingOptions</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;EncodingOption&gt;. </db:code>It stores an OR combination of <db:code>EncodingOption</db:code> values.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toCbor">toCbor</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="Type-enum">
<db:title>enum QCborValue::Type</db:title>
<db:enumsynopsis>
<db:enumname>Type</db:enumname>
<db:enumitem>
<db:enumidentifier>Integer</db:enumidentifier>
<db:enumvalue>0x00</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ByteArray</db:enumidentifier>
<db:enumvalue>0x40</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>String</db:enumidentifier>
<db:enumvalue>0x60</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Array</db:enumidentifier>
<db:enumvalue>0x80</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Map</db:enumidentifier>
<db:enumvalue>0xa0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Tag</db:enumidentifier>
<db:enumvalue>0xc0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SimpleType</db:enumidentifier>
<db:enumvalue>0x100</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>False</db:enumidentifier>
<db:enumvalue>SimpleType + int(QCborSimpleType::False)</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>True</db:enumidentifier>
<db:enumvalue>SimpleType + int(QCborSimpleType::True)</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Null</db:enumidentifier>
<db:enumvalue>SimpleType + int(QCborSimpleType::Null)</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Undefined</db:enumidentifier>
<db:enumvalue>SimpleType + int(QCborSimpleType::Undefined)</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Double</db:enumidentifier>
<db:enumvalue>0x202</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>DateTime</db:enumidentifier>
<db:enumvalue>0x10000</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Url</db:enumidentifier>
<db:enumvalue>0x10020</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RegularExpression</db:enumidentifier>
<db:enumvalue>0x10023</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Uuid</db:enumidentifier>
<db:enumvalue>0x10025</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Invalid</db:enumidentifier>
<db:enumvalue>-1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum represents the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> type. It is returned by the <db:link xlink:href="qcborvalue.xml#type">type</db:link>() function.</db:para>
<db:para>The CBOR built-in types are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::Integer</db:code></db:para>
</db:td>
<db:td><db:code>0x00</db:code></db:td>
<db:td>
<db:para>qint64: An integer value</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::ByteArray</db:code></db:para>
</db:td>
<db:td><db:code>0x40</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link>: a byte array (&quot;byte string&quot;)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::String</db:code></db:para>
</db:td>
<db:td><db:code>0x60</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qstring.xml">QString</db:link>: a Unicode string (&quot;text string&quot;)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::Array</db:code></db:para>
</db:td>
<db:td><db:code>0x80</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qcborarray.xml">QCborArray</db:link>: an array of QCborValues</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::Map</db:code></db:para>
</db:td>
<db:td><db:code>0xa0</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qcbormap.xml">QCborMap</db:link>: an associative container of QCborValues</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::SimpleType</db:code></db:para>
</db:td>
<db:td><db:code>0x100</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qtcborcommon.xml#QCborSimpleType-enum">QCborSimpleType</db:link>: one of several simple types/values</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::False</db:code></db:para>
</db:td>
<db:td><db:code>SimpleType + int(QCborSimpleType::False)</db:code></db:td>
<db:td>
<db:para>bool: the simple type for value false</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::True</db:code></db:para>
</db:td>
<db:td><db:code>SimpleType + int(QCborSimpleType::True)</db:code></db:td>
<db:td>
<db:para>bool: the simple type for value true</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::Null</db:code></db:para>
</db:td>
<db:td><db:code>SimpleType + int(QCborSimpleType::Null)</db:code></db:td>
<db:td>
<db:para>std::nullptr_t: the simple type for the null value</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::Undefined</db:code></db:para>
</db:td>
<db:td><db:code>SimpleType + int(QCborSimpleType::Undefined)</db:code></db:td>
<db:td>
<db:para>(no type) the simple type for the undefined value</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::Double</db:code></db:para>
</db:td>
<db:td><db:code>0x202</db:code></db:td>
<db:td>
<db:para>double: a double-precision floating point</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::Invalid</db:code></db:para>
</db:td>
<db:td><db:code>-1</db:code></db:td>
<db:td>
<db:para>Not a valid value, this usually indicates a CBOR decoding error</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Additionally, <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> can represent extended types:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::Tag</db:code></db:para>
</db:td>
<db:td><db:code>0xc0</db:code></db:td>
<db:td>
<db:para>An unknown or unrecognized extended type, represented by its tag (a <db:link xlink:href="qtcborcommon.xml#QCborTag-enum">QCborTag</db:link>) and the tagged value (a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>)</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::DateTime</db:code></db:para>
</db:td>
<db:td><db:code>0x10000</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qdatetime.xml">QDateTime</db:link>: a date and time stamp</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::Url</db:code></db:para>
</db:td>
<db:td><db:code>0x10020</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qurl.xml">QUrl</db:link>: a URL or URI</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::RegularExpression</db:code></db:para>
</db:td>
<db:td><db:code>0x10023</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>: the pattern of a regular expression</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qcborvalue.xml">QCborValue</db:link></db:emphasis>::Uuid</db:code></db:para>
</db:td>
<db:td><db:code>0x10025</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="quuid.xml">QUuid</db:link>: a UUID</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QCborValue-13">
<db:title>QCborValue::QCborValue(QCborArray &amp;&amp;<db:emphasis>a</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="QCborValue-12">QCborValue::QCborValue(const QCborArray &amp;<db:emphasis>a</db:emphasis>)</db:bridgehead>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with the array <db:code role="parameter">a</db:code>. The array can later be retrieved using <db:link xlink:href="qcborvalue.xml#toArray">toArray</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toArray">toArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isArray">isArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isMap">isMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-15">
<db:title>QCborValue::QCborValue(QCborMap &amp;&amp;<db:emphasis>m</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="QCborValue-14">QCborValue::QCborValue(const QCborMap &amp;<db:emphasis>m</db:emphasis>)</db:bridgehead>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with the map <db:code role="parameter">m</db:code>. The map can later be retrieved using <db:link xlink:href="qcborvalue.xml#toMap">toMap</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toMap">toMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isMap">isMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isArray">isArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-17">
<db:title>QCborValue::QCborValue(QCborKnownTags <db:emphasis>tag</db:emphasis>, const QCborValue &amp;<db:emphasis>tv</db:emphasis> = QCborValue())</db:title>
<db:bridgehead renderas="sect2" xml:id="QCborValue-16">QCborValue::QCborValue(QCborTag <db:emphasis>tag</db:emphasis>, const QCborValue &amp;<db:emphasis>tv</db:emphasis> = QCborValue())</db:bridgehead>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> for the extended type represented by the tag value <db:code role="parameter">tag</db:code>, tagging value <db:code role="parameter">tv</db:code>. The tag can later be retrieved using <db:link xlink:href="qcborvalue.xml#tag">tag</db:link>() and the tagged value using <db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isTag">isTag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#tag">tag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>()</db:member>
<db:member><db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">QCborKnownTags</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toArray">
<db:title>QCborArray QCborValue::toArray() const</db:title>
<db:bridgehead renderas="sect2" xml:id="toArray-1">QCborArray QCborValue::toArray(const QCborArray &amp;<db:emphasis>defaultValue</db:emphasis>) const</db:bridgehead>
<db:para>Returns the array value stored in this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, if it is of the array type. Otherwise, it returns <db:code role="parameter">defaultValue</db:code>.</db:para>
<db:para>Note that this function performs no conversion from other types to <db:link xlink:href="qcborarray.xml">QCborArray</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isArray">isArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isByteArray">isByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isMap">isMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isContainer">isContainer</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toMap">toMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toMap">
<db:title>QCborMap QCborValue::toMap() const</db:title>
<db:bridgehead renderas="sect2" xml:id="toMap-1">QCborMap QCborValue::toMap(const QCborMap &amp;<db:emphasis>defaultValue</db:emphasis>) const</db:bridgehead>
<db:para>Returns the map value stored in this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, if it is of the map type. Otherwise, it returns <db:code role="parameter">defaultValue</db:code>.</db:para>
<db:para>Note that this function performs no conversion from other types to <db:link xlink:href="qcbormap.xml">QCborMap</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isMap">isMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isArray">isArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isContainer">isContainer</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toArray">toArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromCbor-2">
<db:title>[static] QCborValue QCborValue::fromCbor(const char *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>, QCborParserError *<db:emphasis>error</db:emphasis> = nullptr)</db:title>
<db:bridgehead renderas="sect2" xml:id="fromCbor-3">[static] QCborValue QCborValue::fromCbor(const quint8 *<db:emphasis>data</db:emphasis>, qsizetype <db:emphasis>len</db:emphasis>, QCborParserError *<db:emphasis>error</db:emphasis> = nullptr)</db:bridgehead>
<db:para>This is an overloaded function.</db:para>
<db:para>Converts <db:code role="parameter">len</db:code> bytes of <db:code role="parameter">data</db:code> to a <db:link xlink:href="qbytearray.xml">QByteArray</db:link> and then calls the overload of this function that accepts a <db:link xlink:href="qbytearray.xml">QByteArray</db:link>, also passing <db:code role="parameter">error</db:code>, if provided.</db:para>
</db:section>
<db:section xml:id="QCborValue">
<db:title>QCborValue::QCborValue()</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> of the <db:link xlink:href="qcborvalue.xml#Type-enum">Undefined</db:link> type.</db:para>
<db:para>CBOR undefined values are used to indicate missing information, usually as a result of a previous operation that did not complete as expected. They are also used by the <db:link xlink:href="qcborarray.xml">QCborArray</db:link> and <db:link xlink:href="qcbormap.xml">QCborMap</db:link> API to indicate the searched item was not found.</db:para>
<db:para>Undefined values are represented by the <db:link xlink:href="qtcborcommon.xml#QCborSimpleType-enum">Undefined simple type</db:link>. Because of that, QCborValues with undefined values will also return true for <db:link xlink:href="qcborvalue.xml#isSimpleType">isSimpleType</db:link>() and isSimpleType(QCborSimpleType::Undefined).</db:para>
<db:para>Undefined values are different from null values.</db:para>
<db:para><db:link xlink:href="qcborvalue.xml">QCborValue</db:link> objects with undefined values are also different from invalid <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> objects. The API will not create invalid QCborValues, but they may exist as a result of a parsing error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isUndefined">isUndefined</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isSimpleType">isSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-1">
<db:title>QCborValue::QCborValue(QCborValue::Type <db:emphasis>t_</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>QCborValue::Type</db:type>
<db:parameter>t_</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(QCborValue::Type t_)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> of type <db:code role="parameter">t_</db:code>. The value associated with such a type (if any) will be default constructed.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-2">
<db:title>QCborValue::QCborValue(<db:emphasis>std::nullptr_t</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>std::nullptr_t</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(std::nullptr_t)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> of the <db:link xlink:href="qcborvalue.xml#Type-enum">Null</db:link> type.</db:para>
<db:para>CBOR null values are used to indicate optional values that were not provided. They are distinct from undefined values, in that null values are usually not the result of an earlier error or problem.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUndefined">isUndefined</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isSimpleType">isSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-3">
<db:title>QCborValue::QCborValue(bool <db:emphasis>b</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>b</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(bool b)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with boolean value <db:code role="parameter">b</db:code>. The value can later be retrieved using <db:link xlink:href="qcborvalue.xml#toBool">toBool</db:link>().</db:para>
<db:para>Internally, CBOR booleans are represented by a pair of types, one for true and one for false. For that reason, boolean QCborValues will return true for <db:link xlink:href="qcborvalue.xml#isSimpleType">isSimpleType</db:link>() and one of isSimpleType(QCborSimpleType::False) or isSimpleType(QCborSimpleType::True).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toBool">toBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isBool">isBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isFalse">isFalse</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isSimpleType">isSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-4">
<db:title>QCborValue::QCborValue(qint64 <db:emphasis>i</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>i</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(qint64 i)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with integer value <db:code role="parameter">i</db:code>. The value can later be retrieved using <db:link xlink:href="qcborvalue.xml#toInteger">toInteger</db:link>().</db:para>
<db:para>CBOR integer values are distinct from floating point values. Therefore, <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> objects with integers will compare differently to <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> objects containing floating-point, even if the values contained in the objects are equivalent.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toInteger">toInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isInteger">isInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isDouble">isDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-5">
<db:title>QCborValue::QCborValue(double <db:emphasis>d</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>double</db:type>
<db:parameter>d</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(double d)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with floating point value <db:code role="parameter">d</db:code>. The value can later be retrieved using <db:link xlink:href="qcborvalue.xml#toDouble">toDouble</db:link>().</db:para>
<db:para>CBOR floating point values are distinct from integer values. Therefore, <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> objects with integers will compare differently to <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> objects containing floating-point, even if the values contained in the objects are equivalent.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toDouble">toDouble</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isDouble">isDouble</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isInteger">isInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-6">
<db:title>QCborValue::QCborValue(QCborSimpleType <db:emphasis>st</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>QCborSimpleType</db:type>
<db:parameter>st</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(QCborSimpleType st)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> of simple type <db:code role="parameter">st</db:code>. The type can later later be retrieved using <db:link xlink:href="qcborvalue.xml#toSimpleType">toSimpleType</db:link>() as well as <db:link xlink:href="qcborvalue.xml#isSimpleType">isSimpleType</db:link>(st).</db:para>
<db:para>CBOR simple types are types that do not have any associated value, like C++'s std::nullptr_t type, whose only possible value is nullptr.</db:para>
<db:para>If <db:code role="parameter">st</db:code> is QCborSimpleType::Null, the resulting <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> will be of the <db:link xlink:href="qcborvalue.xml#Type-enum">Null</db:link> type and similarly for QCborSimpleType::Undefined. If <db:code role="parameter">st</db:code> is QCborSimpleType::False or QCborSimpleType::True, the created <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> will be a boolean containing a value of false or true, respectively.</db:para>
<db:para>This function can be used with simple types not defined in the API. For example, to create a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with simple type 12, one could write:</db:para>
<db:programlisting language="cpp">    QCborValue value(QCborSimpleType(12));
</db:programlisting>
<db:para>Simple types should not be used until a specification for them has been published, since other implementations may not support them properly. Simple type values 24 to 31 are reserved and must not be used.</db:para>
<db:para><db:link xlink:href="qcborvalue.xml#isSimpleType">isSimpleType</db:link>(), <db:link xlink:href="qcborvalue.xml#isNull">isNull</db:link>(), <db:link xlink:href="qcborvalue.xml#isUndefined">isUndefined</db:link>(), <db:link xlink:href="qcborvalue.xml#isTrue">isTrue</db:link>(), <db:link xlink:href="qcborvalue.xml#isFalse">isFalse</db:link>()</db:para>
</db:section>
<db:section xml:id="QCborValue-7">
<db:title>QCborValue::QCborValue(const QByteArray &amp;<db:emphasis>ba</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>ba</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(const QByteArray &amp;ba)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with byte array value <db:code role="parameter">ba</db:code>. The value can later be retrieved using <db:link xlink:href="qcborvalue.xml#toByteArray">toByteArray</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toByteArray">toByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isByteArray">isByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isString">isString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-8">
<db:title>QCborValue::QCborValue(const QString &amp;<db:emphasis>s</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>s</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">8</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(const QString &amp;s)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with string value <db:code role="parameter">s</db:code>. The value can later be retrieved using <db:link xlink:href="qcborvalue.xml#toString">toString</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toString">toString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isString">isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isByteArray">isByteArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-9">
<db:title>QCborValue::QCborValue(QStringView <db:emphasis>s</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>QStringView</db:type>
<db:parameter>s</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">9</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(QStringView s)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with string value <db:code role="parameter">s</db:code>. The value can later be retrieved using <db:link xlink:href="qcborvalue.xml#toString">toString</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toString">toString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isString">isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isByteArray">isByteArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-10">
<db:title>QCborValue::QCborValue(QLatin1StringView <db:emphasis>s</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>QLatin1StringView</db:type>
<db:parameter>s</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">10</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(QLatin1StringView s)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with string value <db:code role="parameter">s</db:code>. The value can later be retrieved using <db:link xlink:href="qcborvalue.xml#toString">toString</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toString">toString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isString">isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isByteArray">isByteArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-18">
<db:title>[explicit] QCborValue::QCborValue(const QDateTime &amp;<db:emphasis>dt</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>const QDateTime &amp;</db:type>
<db:parameter>dt</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">18</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(const QDateTime &amp;dt)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object of the date/time extended type and containing the value represented by <db:code role="parameter">dt</db:code>. The value can later be retrieved using <db:link xlink:href="qcborvalue.xml#toDateTime">toDateTime</db:link>().</db:para>
<db:para>The CBOR date/time types are extension types using tags: either a string (in ISO date format) tagged as a <db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">DateTime</db:link> or a number (of seconds since the start of 1970, UTC) tagged as a <db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">UnixTime_t</db:link>. When parsing CBOR streams, <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> will convert <db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">UnixTime_t</db:link> to the string-based type.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toDateTime">toDateTime</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isDateTime">isDateTime</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-19">
<db:title>[explicit] QCborValue::QCborValue(const QUrl &amp;<db:emphasis>url</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>url</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">19</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(const QUrl &amp;url)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object of the URL extended type and containing the value represented by <db:code role="parameter">url</db:code>. The value can later be retrieved using <db:link xlink:href="qcborvalue.xml#toUrl">toUrl</db:link>().</db:para>
<db:para>The CBOR URL type is an extended type represented by a string tagged as an <db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">Url</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toUrl">toUrl</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUrl">isUrl</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-20">
<db:title>[explicit] QCborValue::QCborValue(const QRegularExpression &amp;<db:emphasis>rx</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>const QRegularExpression &amp;</db:type>
<db:parameter>rx</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">20</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(const QRegularExpression &amp;rx)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object of the regular expression pattern extended type and containing the value represented by <db:code role="parameter">rx</db:code>. The value can later be retrieved using <db:link xlink:href="qcborvalue.xml#toRegularExpression">toRegularExpression</db:link>().</db:para>
<db:para>The CBOR regular expression type is an extended type represented by a string tagged as an <db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">RegularExpression</db:link>. Note that CBOR regular expressions only store the patterns, so any flags that the <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link> object may carry will be lost.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toRegularExpression">toRegularExpression</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isRegularExpression">isRegularExpression</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-21">
<db:title>[explicit] QCborValue::QCborValue(const QUuid &amp;<db:emphasis>uuid</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>const QUuid &amp;</db:type>
<db:parameter>uuid</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">21</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(const QUuid &amp;uuid)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object of the UUID extended type and containing the value represented by <db:code role="parameter">uuid</db:code>. The value can later be retrieved using <db:link xlink:href="qcborvalue.xml#toUuid">toUuid</db:link>().</db:para>
<db:para>The CBOR UUID type is an extended type represented by a byte array tagged as an <db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">Uuid</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toUuid">toUuid</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUuid">isUuid</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QCborValue-23">
<db:title>QCborValue::QCborValue(const QCborValue &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">23</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(const QCborValue &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Copies the contents of <db:code role="parameter">other</db:code> into this object.</db:para>
</db:section>
<db:section xml:id="QCborValue-24">
<db:title>QCborValue::QCborValue(QCborValue &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QCborValue</db:methodname>
<db:methodparam>
<db:type>QCborValue &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">24</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue(QCborValue &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Moves the contents of the <db:code role="parameter">other</db:code> <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object into this one and frees the resources of this one.</db:para>
</db:section>
<db:section xml:id="dtor.QCborValue">
<db:title>QCborValue::~QCborValue()</db:title>
<db:destructorsynopsis>
<db:methodname>~QCborValue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QCborValue()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Disposes of the current <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object and frees any associated resources.</db:para>
</db:section>
<db:section xml:id="compare">
<db:title>int QCborValue::compare(const QCborValue &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>compare</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int compare(const QCborValue &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares this value and <db:code role="parameter">other</db:code>, and returns an integer that indicates whether this value should be sorted prior to (if the result is negative) or after <db:code role="parameter">other</db:code> (if the result is positive). If this function returns 0, the two values are equal and hold the same contents.</db:para>
<db:para>If each <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> contains an array or map, the comparison is recursive to elements contained in them.</db:para>
<db:section xml:id="extended-types">
<db:title>Extended types</db:title>
<db:para><db:link xlink:href="qcborvalue.xml">QCborValue</db:link> compares equal a <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> containing an extended type, like <db:link xlink:href="qcborvalue.xml#Type-enum">Url</db:link> and <db:link xlink:href="qcborvalue.xml#Type-enum">Url</db:link> and its equivalent tagged representation. So, for example, the following expression is true:</db:para>
<db:programlisting language="cpp">    QCborValue(QUrl(&quot;https://example.com&quot;)) == QCborValue(QCborKnownTags::Url, &quot;https://example.com&quot;);
</db:programlisting>
<db:para>Do note that Qt types like <db:link xlink:href="qurl.xml">QUrl</db:link> and <db:link xlink:href="qdatetime.xml">QDateTime</db:link> will normalize and otherwise modify their arguments. The expression above is true only because the string on the right side is the normalized value that the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> on the left would take. If, for example, the &quot;https&quot; part were uppercase in both sides, the comparison would fail. For information on normalizations performed by <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, please consult the documentation of the constructor taking the Qt type in question.</db:para>
</db:section>
<db:section xml:id="sorting-order">
<db:title>Sorting order</db:title>
<db:para>Sorting order in CBOR is defined in <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc7049#section-3.9">RFC 7049, section 3.9</db:link>, which discusses the sorting of keys in a map when following the Canonical encoding. According to the specification, &quot;sorting is performed on the bytes of the representation of the key data items&quot; and lists as consequences that:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>&quot;If two keys have different lengths, the shorter one sorts earlier;&quot;</db:para>
</db:listitem>
<db:listitem>
<db:para>&quot;If two keys have the same length, the one with the lower value in (byte-wise) lexical order sorts earlier.&quot;</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>This results in surprising sorting of QCborValues, where the result of this function is different from that which would later be retrieved by comparing the contained elements. For example, the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> containing string &quot;zzz&quot; sorts before the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> with string &quot;foobar&quot;, even though when comparing as <db:link xlink:href="qstring.xml#compare">QStrings</db:link> or <db:link xlink:href="qbytearray.xml">QByteArrays</db:link> the &quot;zzz&quot; sorts after &quot;foobar&quot; (dictionary order).</db:para>
<db:para>The specification does not clearly indicate what sorting order should be done for values of different types (it says sorting should not pay &quot;attention to the 3/5 bit splitting for major types&quot;). <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> makes the assumption that types should be sorted too. The numeric values of the <db:link xlink:href="qcborvalue.xml#Type-enum">QCborValue::Type</db:link> enumeration are in that order, with the exception of the extended types, which compare as their tagged equivalents.</db:para>
<db:note>
<db:para>Sorting order is preliminary and is subject to change. Applications should not depend on the order returned by this function for the time being.</db:para>
</db:note>
</db:section>
<db:section>
<db:title>Notes</db:title>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborarray.xml#compare">QCborArray::compare</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#compare">QCborMap::compare</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#operator-eq-eq">operator==</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromCbor">
<db:title>[static] QCborValue QCborValue::fromCbor(QCborStreamReader &amp;<db:emphasis>reader</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QCborValue</db:type>
<db:methodname>fromCbor</db:methodname>
<db:methodparam>
<db:type>QCborStreamReader &amp;</db:type>
<db:parameter>reader</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue fromCbor(QCborStreamReader &amp;reader)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Decodes one item from the CBOR stream found in <db:code role="parameter">reader</db:code> and returns the equivalent representation. This function is recursive: if the item is a map or array, it will decode all items found in that map or array, until the outermost object is finished.</db:para>
<db:para>This function need not be used on the root element of a <db:link xlink:href="qcborstreamreader.xml">QCborStreamReader</db:link>. For example, the following code illustrates how to skip the CBOR signature tag from the beginning of a file:</db:para>
<db:programlisting language="cpp">    if (reader.isTag() &amp;amp;&amp;amp; reader.toTag() == QCborKnownTags::Signature)
        reader.next();

    QCborValue contents = QCborValue::fromCbor(reader);
</db:programlisting>
<db:para>The returned value may be partially complete and indistinguishable from a valid <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> even if the decoding failed. To determine if there was an error, check if <db:link xlink:href="qcborstreamreader.xml#lastError">reader.lastError</db:link>() is indicating an error condition. This function stops decoding immediately after the first error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toCbor">toCbor</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toDiagnosticNotation">toDiagnosticNotation</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toVariant">toVariant</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toJsonValue">toJsonValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromCbor-1">
<db:title>[static] QCborValue QCborValue::fromCbor(const QByteArray &amp;<db:emphasis>ba</db:emphasis>, QCborParserError *<db:emphasis>error</db:emphasis> = nullptr)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QCborValue</db:type>
<db:methodname>fromCbor</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>ba</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QCborParserError *</db:type>
<db:parameter>error</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue fromCbor(const QByteArray &amp;ba, QCborParserError *error)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Decodes one item from the CBOR stream found in the byte array <db:code role="parameter">ba</db:code> and returns the equivalent representation. This function is recursive: if the item is a map or array, it will decode all items found in that map or array, until the outermost object is finished.</db:para>
<db:para>This function stores the error state, if any, in the object pointed to by <db:code role="parameter">error</db:code>, along with the offset of where the error occurred. If no error happened, it stores <db:link xlink:href="qcborerror.xml">NoError</db:link> in the error state and the number of bytes that it consumed (that is, it stores the offset for the first unused byte). Using that information makes it possible to parse further data that may exist in the same byte array.</db:para>
<db:para>The returned value may be partially complete and indistinguishable from a valid <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> even if the decoding failed. To determine if there was an error, check if there was an error stored in <db:code role="parameter">error</db:code>. This function stops decoding immediately after the first error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toCbor">toCbor</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toDiagnosticNotation">toDiagnosticNotation</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toVariant">toVariant</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toJsonValue">toJsonValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromJsonValue">
<db:title>[static] QCborValue QCborValue::fromJsonValue(const QJsonValue &amp;<db:emphasis>v</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QCborValue</db:type>
<db:methodname>fromJsonValue</db:methodname>
<db:methodparam>
<db:type>const QJsonValue &amp;</db:type>
<db:parameter>v</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue fromJsonValue(const QJsonValue &amp;v)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the JSON value contained in <db:code role="parameter">v</db:code> into its corresponding CBOR value and returns it. There is no data loss in converting from JSON to CBOR, as the CBOR type set is richer than JSON's. Additionally, values converted to CBOR using this function can be converted back to JSON using <db:link xlink:href="qcborvalue.xml#toJsonValue">toJsonValue</db:link>() with no data loss.</db:para>
<db:para>The following table lists the mapping of JSON types to CBOR types:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>JSON Type</db:para>
</db:th>
<db:th>
<db:para>CBOR Type</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Bool</db:para>
</db:td>
<db:td>
<db:para>Bool</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Number</db:para>
</db:td>
<db:td>
<db:para>Integer (if the number has no fraction and is in the qint64 range) or Double</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>String</db:para>
</db:td>
<db:td>
<db:para>String</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Array</db:para>
</db:td>
<db:td>
<db:para>Array</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Object</db:para>
</db:td>
<db:td>
<db:para>Map</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Null</db:para>
</db:td>
<db:td>
<db:para>Null</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para><db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link> can also be undefined, indicating a previous operation that failed to complete (for example, searching for a key not present in an object). Undefined values are not JSON types and may not appear in JSON arrays and objects, but this function does return the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> undefined value if the corresponding <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link> is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toJsonValue">toJsonValue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#fromVariant">fromVariant</db:link>()</db:member>
<db:member><db:link xlink:href="qcborarray.xml#fromJsonArray">QCborArray::fromJsonArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#fromJsonObject">QCborMap::fromJsonObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="fromVariant">
<db:title>[static] QCborValue QCborValue::fromVariant(const QVariant &amp;<db:emphasis>variant</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QCborValue</db:type>
<db:methodname>fromVariant</db:methodname>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>variant</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue fromVariant(const QVariant &amp;variant)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts the <db:link xlink:href="qvariant.xml">QVariant</db:link> <db:code role="parameter">variant</db:code> into <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> and returns it.</db:para>
<db:para>QVariants may contain a large list of different meta types, many of which have no corresponding representation in CBOR. That includes all user-defined meta types. When preparing transmission using CBOR, it is suggested to encode carefully each value to prevent loss of representation.</db:para>
<db:para>The following table lists the conversion this function will apply:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Qt (C++) type</db:para>
</db:th>
<db:th>
<db:para>CBOR type</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>invalid (QVariant())</db:para>
</db:td>
<db:td>
<db:para>Undefined</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>bool</db:para>
</db:td>
<db:td>
<db:para>Bool</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>std::nullptr_t</db:para>
</db:td>
<db:td>
<db:para>Null</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>short, ushort, int, uint, qint64</db:para>
</db:td>
<db:td>
<db:para>Integer</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>quint64</db:para>
</db:td>
<db:td>
<db:para>Integer, or Double if outside the range of qint64</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>float, double</db:para>
</db:td>
<db:td>
<db:para>Double</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qcborvalue.xml#Type-enum">ByteArray</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qdatetime.xml">QDateTime</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qcborvalue.xml#Type-enum">DateTime</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qtcborcommon.xml#QCborSimpleType-enum">QCborSimpleType</db:link></db:para>
</db:td>
<db:td>
<db:para>Simple type</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qjsonarray.xml">QJsonArray</db:link></db:para>
</db:td>
<db:td>
<db:para>Array, converted using QCborArray::formJsonArray()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qjsondocument.xml">QJsonDocument</db:link></db:para>
</db:td>
<db:td>
<db:para>Array or Map</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qjsonobject.xml">QJsonObject</db:link></db:para>
</db:td>
<db:td>
<db:para>Map, converted using <db:link xlink:href="qcbormap.xml#fromJsonObject">QCborMap::fromJsonObject</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link></db:para>
</db:td>
<db:td>
<db:para>converted using <db:link xlink:href="qcborvalue.xml#fromJsonValue">fromJsonValue</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qcborvalue.xml#Type-enum">RegularExpression</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qstring.xml">QString</db:link></db:para>
</db:td>
<db:td>
<db:para>String</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qstringlist.xml">QStringList</db:link></db:para>
</db:td>
<db:td>
<db:para>Array</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qvariant.xml#QVariantHash-typedef">QVariantHash</db:link></db:para>
</db:td>
<db:td>
<db:para>Map</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link></db:para>
</db:td>
<db:td>
<db:para>Array</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link></db:para>
</db:td>
<db:td>
<db:para>Map</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qurl.xml">QUrl</db:link></db:para>
</db:td>
<db:td>
<db:para>Url</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="quuid.xml">QUuid</db:link></db:para>
</db:td>
<db:td>
<db:para>Uuid</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>If <db:link xlink:href="qvariant.xml#isNull">QVariant::isNull</db:link>() returns true, a null <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is returned or inserted into the list or object, regardless of the type carried by <db:link xlink:href="qvariant.xml">QVariant</db:link>. Note the behavior change in Qt 6.0 affecting <db:link xlink:href="qvariant.xml#isNull">QVariant::isNull</db:link>() also affects this function.</db:para>
<db:para>For other types not listed above, a conversion to string will be attempted, usually but not always by calling <db:link xlink:href="qvariant.xml#toString">QVariant::toString</db:link>(). If the conversion fails the value is replaced by an Undefined CBOR value. Note that <db:link xlink:href="qvariant.xml#toString">QVariant::toString</db:link>() is also lossy for the majority of types.</db:para>
<db:para>Please note that the conversions via <db:link xlink:href="qvariant.xml#toString">QVariant::toString</db:link>() are subject to change at any time. Both <db:link xlink:href="qvariant.xml">QVariant</db:link> and <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> may be extended in the future to support more types, which will result in a change in how this function performs conversions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toVariant">toVariant</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#fromJsonValue">fromJsonValue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborarray.xml#toVariantList">QCborArray::toVariantList</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#toVariantMap">QCborMap::toVariantMap</db:link>()</db:member>
<db:member><db:link xlink:href="qjsonvalue.xml#fromVariant">QJsonValue::fromVariant</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isArray">
<db:title>bool QCborValue::isArray() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isArray() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of the array type. The array value can be retrieved using <db:link xlink:href="qcborvalue.xml#toArray">toArray</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toArray">toArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isBool">
<db:title>bool QCborValue::isBool() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isBool</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isBool() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is a boolean. The value can be retrieved using <db:link xlink:href="qcborvalue.xml#toBool">toBool</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toBool">toBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isFalse">isFalse</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isByteArray">
<db:title>bool QCborValue::isByteArray() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isByteArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isByteArray() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of the byte array type. The byte array value can be retrieved using <db:link xlink:href="qcborvalue.xml#toByteArray">toByteArray</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toByteArray">toByteArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isContainer">
<db:title>bool QCborValue::isContainer() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isContainer</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isContainer() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This convenience function returns true if the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is either an array or a map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isArray">isArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isMap">isMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isDateTime">
<db:title>bool QCborValue::isDateTime() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isDateTime</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isDateTime() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of the date/time type. The value can be retrieved using <db:link xlink:href="qcborvalue.xml#toDateTime">toDateTime</db:link>(). Date/times are extended types that use the tag <db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">DateTime</db:link>.</db:para>
<db:para>Additionally, when decoding from a CBOR stream, <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> will interpret tags of value <db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">UnixTime_t</db:link> and convert them to the equivalent date/time.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toDateTime">toDateTime</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isDouble">
<db:title>bool QCborValue::isDouble() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isDouble</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isDouble() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of the floating-point type. The value can be retrieved using <db:link xlink:href="qcborvalue.xml#toDouble">toDouble</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toDouble">toDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isFalse">
<db:title>bool QCborValue::isFalse() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isFalse</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isFalse() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is a boolean with false value. This function exists because, internally, CBOR booleans are stored as two separate types, one for true and one for false.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isBool">isBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toBool">toBool</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isInteger">
<db:title>bool QCborValue::isInteger() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isInteger</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isInteger() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of the integer type. The integer value can be retrieved using <db:link xlink:href="qcborvalue.xml#toInteger">toInteger</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toInteger">toInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isInvalid">
<db:title>bool QCborValue::isInvalid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isInvalid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isInvalid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is not of any valid type. Invalid QCborValues are distinct from those with undefined values and they usually represent a decoding error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isUndefined">isUndefined</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isNull">isNull</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isMap">
<db:title>bool QCborValue::isMap() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isMap</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isMap() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of the map type. The map value can be retrieved using <db:link xlink:href="qcborvalue.xml#toMap">toMap</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toMap">toMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isNull">
<db:title>bool QCborValue::isNull() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isNull</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isNull() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of the null type.</db:para>
<db:para>CBOR null values are used to indicate optional values that were not provided. They are distinct from undefined values, in that null values are usually not the result of an earlier error or problem.</db:para>
<db:para>Null values are distinct from undefined values and from invalid <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> objects. The API will not create invalid QCborValues, but they may exist as a result of a parsing error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUndefined">isUndefined</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isInvalid">isInvalid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isRegularExpression">
<db:title>bool QCborValue::isRegularExpression() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isRegularExpression</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isRegularExpression() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> contains a regular expression's pattern. The pattern can be retrieved using <db:link xlink:href="qcborvalue.xml#toRegularExpression">toRegularExpression</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toRegularExpression">toRegularExpression</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSimpleType">
<db:title>bool QCborValue::isSimpleType() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSimpleType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSimpleType() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of one of the CBOR simple types. The type itself can later be retrieved using <db:link xlink:href="qcborvalue.xml#type">type</db:link>(), even for types that don't have an enumeration in the API. They can also be checked with the <db:link xlink:href="qcborvalue.xml#isSimpleType-1">isSimpleType</db:link>(QCborSimpleType) overload.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtcborcommon.xml#QCborSimpleType-enum">QCborSimpleType</db:link></db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isSimpleType-1">isSimpleType</db:link>(QCborSimpleType)</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toSimpleType">toSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSimpleType-1">
<db:title>bool QCborValue::isSimpleType(QCborSimpleType <db:emphasis>st</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSimpleType</db:methodname>
<db:methodparam>
<db:type>QCborSimpleType</db:type>
<db:parameter>st</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSimpleType(QCborSimpleType st) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of a simple type and <db:link xlink:href="qcborvalue.xml#toSimpleType">toSimpleType</db:link>() would return <db:code role="parameter">st</db:code>, false otherwise. This function can be used to check for any CBOR simple type, even those for which there is no enumeration in the API. For example, for the simple type of value 12, you could write:</db:para>
<db:programlisting language="cpp">    value.isSimpleType(QCborSimpleType(12));
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#QCborValue-6">QCborValue::QCborValue</db:link>(QCborSimpleType)</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isSimpleType">isSimpleType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isFalse">isFalse</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isNull">isNull</db:link></db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUndefined">isUndefined</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toSimpleType">toSimpleType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isString">
<db:title>bool QCborValue::isString() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isString</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isString() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of the string type. The string value can be retrieved using <db:link xlink:href="qcborvalue.xml#toString">toString</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toString">toString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isTag">
<db:title>bool QCborValue::isTag() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isTag</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isTag() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of the tag type. The tag value can be retrieved using <db:link xlink:href="qcborvalue.xml#tag">tag</db:link>() and the tagged value using <db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>().</db:para>
<db:para>This function also returns true for extended types that the API recognizes. For code that handles extended types directly before the Qt API is updated to support them, it is possible to recreate the tag + tagged value pair by using <db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#tag">tag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isTrue">
<db:title>bool QCborValue::isTrue() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isTrue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isTrue() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is a boolean with true value. This function exists because, internally, CBOR booleans are stored as two separate types, one for false and one for true.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isBool">isBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isFalse">isFalse</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toBool">toBool</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isUndefined">
<db:title>bool QCborValue::isUndefined() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isUndefined</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isUndefined() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of the undefined type.</db:para>
<db:para>CBOR undefined values are used to indicate missing information, usually as a result of a previous operation that did not complete as expected. They are also used by the <db:link xlink:href="qcborarray.xml">QCborArray</db:link> and <db:link xlink:href="qcbormap.xml">QCborMap</db:link> API to indicate the searched item was not found.</db:para>
<db:para>Undefined values are distinct from null values.</db:para>
<db:para><db:link xlink:href="qcborvalue.xml">QCborValue</db:link> objects with undefined values are also different from invalid <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> objects. The API will not create invalid QCborValues, but they may exist as a result of a parsing error.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isInvalid">isInvalid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isUrl">
<db:title>bool QCborValue::isUrl() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isUrl</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isUrl() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of the URL type. The URL value can be retrieved using <db:link xlink:href="qcborvalue.xml#toUrl">toUrl</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toUrl">toUrl</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isUuid">
<db:title>bool QCborValue::isUuid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isUuid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isUuid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> contains a UUID. The value can be retrieved using <db:link xlink:href="qcborvalue.xml#toUuid">toUuid</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toUuid">toUuid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QCborValue::swap(QCborValue &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QCborValue &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QCborValue &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps the contents of this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object and <db:code role="parameter">other</db:code>.</db:para>
</db:section>
<db:section xml:id="tag">
<db:title>QCborTag QCborValue::tag(QCborTag <db:emphasis>defaultValue</db:emphasis> = QCborTag(-1)) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborTag</db:type>
<db:methodname>tag</db:methodname>
<db:methodparam>
<db:type>QCborTag</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>QCborTag(-1)</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborTag tag(QCborTag defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the tag of this extended <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object, if it is of the tag type, <db:code role="parameter">defaultValue</db:code> otherwise.</db:para>
<db:para>CBOR represents extended types by associating a number (the tag) with a stored representation. This function returns that number. To retrieve the representation, use <db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isTag">isTag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isDateTime">isDateTime</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUrl">isUrl</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isRegularExpression">isRegularExpression</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUuid">isUuid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="taggedValue">
<db:title>QCborValue QCborValue::taggedValue(const QCborValue &amp;<db:emphasis>defaultValue</db:emphasis> = QCborValue()) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborValue</db:type>
<db:methodname>taggedValue</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>QCborValue()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue taggedValue(const QCborValue &amp;defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the tagged value of this extended <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object, if it is of the tag type, <db:code role="parameter">defaultValue</db:code> otherwise.</db:para>
<db:para>CBOR represents extended types by associating a number (the tag) with a stored representation. This function returns that representation. To retrieve the tag, use <db:link xlink:href="qcborvalue.xml#tag">tag</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isTag">isTag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#tag">tag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isDateTime">isDateTime</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUrl">isUrl</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isRegularExpression">isRegularExpression</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUuid">isUuid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toBool">
<db:title>bool QCborValue::toBool(bool <db:emphasis>defaultValue</db:emphasis> = false) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>toBool</db:methodname>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>false</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool toBool(bool defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the boolean value stored in this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, if it is of a boolean type. Otherwise, it returns <db:code role="parameter">defaultValue</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isBool">isBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isFalse">isFalse</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toByteArray">
<db:title>QByteArray QCborValue::toByteArray(const QByteArray &amp;<db:emphasis>defaultValue</db:emphasis> = {}) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>toByteArray</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray toByteArray(const QByteArray &amp;defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the byte array value stored in this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, if it is of the byte array type. Otherwise, it returns <db:code role="parameter">defaultValue</db:code>.</db:para>
<db:para>Note that this function performs no conversion from other types to <db:link xlink:href="qbytearray.xml">QByteArray</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isByteArray">isByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isString">isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toString">toString</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toCbor">
<db:title>QByteArray QCborValue::toCbor(QCborValue::EncodingOptions <db:emphasis>opt</db:emphasis> = NoTransformation) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>toCbor</db:methodname>
<db:methodparam>
<db:type>QCborValue::EncodingOptions</db:type>
<db:parameter>opt</db:parameter>
<db:initializer>NoTransformation</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray toCbor(QCborValue::EncodingOptions opt) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Encodes this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object to its CBOR representation, using the options specified in <db:code role="parameter">opt</db:code>, and return the byte array containing that representation.</db:para>
<db:para>This function will not fail, except if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> or any of the contained items, if this is a map or array, are invalid. Invalid types are not produced normally by the API, but can result from decoding errors.</db:para>
<db:para>By default, this function performs no transformation on the values in the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, writing all floating point directly as double-precision (double) types. If the <db:link xlink:href="qcborvalue.xml#EncodingOption-enum">UseFloat</db:link> option is specified, it will use single precision (float) for any floating point value for which there's no loss of precision in using that representation. That includes infinities and NaN values.</db:para>
<db:para>Similarly, if <db:link xlink:href="qcborvalue.xml#EncodingOption-enum">UseFloat16</db:link> is specified, this function will try to use half-precision (qfloat16) floating point if the conversion to that results in no loss of precision. This is always true for infinities and NaN.</db:para>
<db:para>If <db:link xlink:href="qcborvalue.xml#EncodingOption-enum">UseIntegers</db:link> is specified, it will use integers for any floating point value that contains an actual integer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#fromCbor">fromCbor</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#fromVariant">fromVariant</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#fromJsonValue">fromJsonValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toCbor-1">
<db:title>void QCborValue::toCbor(QCborStreamWriter &amp;<db:emphasis>writer</db:emphasis>, QCborValue::EncodingOptions <db:emphasis>opt</db:emphasis> = NoTransformation) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:void/>
<db:methodname>toCbor</db:methodname>
<db:methodparam>
<db:type>QCborStreamWriter &amp;</db:type>
<db:parameter>writer</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QCborValue::EncodingOptions</db:type>
<db:parameter>opt</db:parameter>
<db:initializer>NoTransformation</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void toCbor(QCborStreamWriter &amp;writer, QCborValue::EncodingOptions opt) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Encodes this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object to its CBOR representation, using the options specified in <db:code role="parameter">opt</db:code>, to the writer specified by <db:code role="parameter">writer</db:code>. The same writer can be used by multiple QCborValues, for example, in order to encode different elements in a larger array.</db:para>
<db:para>This function will not fail, except if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> or any of the contained items, if this is a map or array, are invalid. Invalid types are not produced normally by the API, but can result from decoding errors.</db:para>
<db:para>By default, this function performs no transformation on the values in the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, writing all floating point directly as double-precision (binary64) types. If the <db:link xlink:href="qcborvalue.xml#EncodingOption-enum">UseFloat</db:link> option is specified, it will use single precision (binary32) for any floating point value for which there's no loss of precision in using that representation. That includes infinities and NaN values.</db:para>
<db:para>Similarly, if <db:link xlink:href="qcborvalue.xml#EncodingOption-enum">UseFloat16</db:link> is specified, this function will try to use half-precision (binary16) floating point if the conversion to that results in no loss of precision. This is always true for infinities and NaN.</db:para>
<db:para>If <db:link xlink:href="qcborvalue.xml#EncodingOption-enum">UseIntegers</db:link> is specified, it will use integers for any floating point value that contains an actual integer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#fromCbor">fromCbor</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#fromVariant">fromVariant</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#fromJsonValue">fromJsonValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDateTime">
<db:title>QDateTime QCborValue::toDateTime(const QDateTime &amp;<db:emphasis>defaultValue</db:emphasis> = {}) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QDateTime</db:type>
<db:methodname>toDateTime</db:methodname>
<db:methodparam>
<db:type>const QDateTime &amp;</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QDateTime toDateTime(const QDateTime &amp;defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the date/time value stored in this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, if it is of the date/time extended type. Otherwise, it returns <db:code role="parameter">defaultValue</db:code>.</db:para>
<db:para>Note that this function performs no conversion from other types to <db:link xlink:href="qdatetime.xml">QDateTime</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isDateTime">isDateTime</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTag">isTag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDiagnosticNotation">
<db:title>QString QCborValue::toDiagnosticNotation(QCborValue::DiagnosticNotationOptions <db:emphasis>opts</db:emphasis> = Compact) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>toDiagnosticNotation</db:methodname>
<db:methodparam>
<db:type>QCborValue::DiagnosticNotationOptions</db:type>
<db:parameter>opts</db:parameter>
<db:initializer>Compact</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString toDiagnosticNotation(QCborValue::DiagnosticNotationOptions opts) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates the diagnostic notation equivalent of this CBOR object and returns it. The <db:code role="parameter">opts</db:code> parameter controls the dialect of the notation. Diagnostic notation is useful in debugging, to aid the developer in understanding what value is stored in the <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> or in a CBOR stream. For that reason, the Qt API provides no support for parsing the diagnostic back into the in-memory format or CBOR stream, though the representation is unique and it would be possible.</db:para>
<db:para>CBOR diagnostic notation is specified by <db:link xlink:href="https://datatracker.ietf.org/doc/html/rfc7049#section-6">section 6</db:link> of RFC 7049. It is a text representation of the CBOR stream and it is very similar to JSON, but it supports the CBOR types not found in JSON. The extended format enabled by the <db:link xlink:href="qcborvalue.xml#DiagnosticNotationOption-enum">ExtendedFormat</db:link> flag is currently in some IETF drafts and its format is subject to change.</db:para>
<db:para>This function produces the equivalent representation of the stream that <db:link xlink:href="qcborvalue.xml#toCbor">toCbor</db:link>() would produce, without any transformation option provided there. This also implies this function may not produce a representation of the stream that was used to create the object, if it was created using <db:link xlink:href="qcborvalue.xml#fromCbor">fromCbor</db:link>(), as that function may have applied transformations. For a high-fidelity notation of a stream, without transformation, see the cbordump example.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#toCbor">toCbor</db:link>()</db:member>
<db:member><db:link xlink:href="qjsondocument.xml#toJson">QJsonDocument::toJson</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toDouble">
<db:title>double QCborValue::toDouble(double <db:emphasis>defaultValue</db:emphasis> = 0) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>double</db:type>
<db:methodname>toDouble</db:methodname>
<db:methodparam>
<db:type>double</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">double toDouble(double defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the floating point value stored in this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, if it is of the Double type. If it is of the Integer type, this function returns the integer value converted to double. In any other case, it returns <db:code role="parameter">defaultValue</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isDouble">isDouble</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isInteger">isInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toInteger">toInteger</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toInteger">
<db:title>qint64 QCborValue::toInteger(qint64 <db:emphasis>defaultValue</db:emphasis> = 0) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>qint64</db:type>
<db:methodname>toInteger</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">qint64 toInteger(qint64 defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the integer value stored in this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, if it is of the integer type. If it is of the Double type, this function returns the floating point value converted to integer. In any other case, it returns <db:code role="parameter">defaultValue</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isInteger">isInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isDouble">isDouble</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toDouble">toDouble</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toJsonValue">
<db:title>QJsonValue QCborValue::toJsonValue() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QJsonValue</db:type>
<db:methodname>toJsonValue</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QJsonValue toJsonValue() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object to an equivalent representation in JSON and returns it as a <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link>.</db:para>
<db:para>Please note that CBOR contains a richer and wider type set than JSON, so some information may be lost in this conversion. The following table compares CBOR types to JSON types and indicates whether information may be lost or not.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>CBOR Type</db:para>
</db:th>
<db:th>
<db:para>JSON Type</db:para>
</db:th>
<db:th>
<db:para>Comments</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Bool</db:para>
</db:td>
<db:td>
<db:para>Bool</db:para>
</db:td>
<db:td>
<db:para>No data loss possible</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Double</db:para>
</db:td>
<db:td>
<db:para>Number</db:para>
</db:td>
<db:td>
<db:para>Infinities and NaN will be converted to Null; no data loss for other values</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Integer</db:para>
</db:td>
<db:td>
<db:para>Number</db:para>
</db:td>
<db:td>
<db:para>Data loss possible in the conversion if the integer is larger than 2<db:superscript>53</db:superscript> or smaller than -2<db:superscript>53</db:superscript>.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Null</db:para>
</db:td>
<db:td>
<db:para>Null</db:para>
</db:td>
<db:td>
<db:para>No data loss possible</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Undefined</db:para>
</db:td>
<db:td>
<db:para>Null</db:para>
</db:td>
<db:td>
<db:para>Type information lost</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>String</db:para>
</db:td>
<db:td>
<db:para>String</db:para>
</db:td>
<db:td>
<db:para>No data loss possible</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Byte Array</db:para>
</db:td>
<db:td>
<db:para>String</db:para>
</db:td>
<db:td>
<db:para>Converted to a lossless encoding like Base64url, but the distinction between strings and byte arrays is lost</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Other simple types</db:para>
</db:td>
<db:td>
<db:para>String</db:para>
</db:td>
<db:td>
<db:para>Type information lost</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Array</db:para>
</db:td>
<db:td>
<db:para>Array</db:para>
</db:td>
<db:td>
<db:para>Conversion applies to each contained value</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Map</db:para>
</db:td>
<db:td>
<db:para>Object</db:para>
</db:td>
<db:td>
<db:para>Keys are converted to string; values converted according to this table</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Tags and extended types</db:para>
</db:td>
<db:td>
<db:para>Special</db:para>
</db:td>
<db:td>
<db:para>The tag number itself is lost and the tagged value is converted to JSON</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>For information on the conversion of CBOR map keys to string, see <db:link xlink:href="qcbormap.xml#toJsonObject">QCborMap::toJsonObject</db:link>().</db:para>
<db:para>If this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> contains the undefined value, this function will return an undefined <db:link xlink:href="qjsonvalue.xml">QJsonValue</db:link> too. Note that JSON does not support undefined values and undefined QJsonValues are an extension to the specification. They cannot be held in a <db:link xlink:href="qjsonarray.xml">QJsonArray</db:link> or <db:link xlink:href="qjsonobject.xml">QJsonObject</db:link>, but can be returned from functions to indicate a failure. For all other intents and purposes, they are the same as null.</db:para>
<db:section xml:id="special-handling-of-tags-and-extended-types">
<db:title>Special handling of tags and extended types</db:title>
<db:para>Some tags are handled specially and change the transformation of the tagged value from CBOR to JSON. The following table lists those special cases:</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Tag</db:para>
</db:th>
<db:th>
<db:para>CBOR type</db:para>
</db:th>
<db:th>
<db:para>Transformation</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">ExpectedBase64url</db:link></db:para>
</db:td>
<db:td>
<db:para>Byte array</db:para>
</db:td>
<db:td>
<db:para>Encodes the byte array as Base64url</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">ExpectedBase64</db:link></db:para>
</db:td>
<db:td>
<db:para>Byte array</db:para>
</db:td>
<db:td>
<db:para>Encodes the byte array as Base64</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qtcborcommon.xml#QCborKnownTags-enum">ExpectedBase16</db:link></db:para>
</db:td>
<db:td>
<db:para>Byte array</db:para>
</db:td>
<db:td>
<db:para>Encodes the byte array as hex</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Url</db:para>
</db:td>
<db:td>
<db:para>Url and String</db:para>
</db:td>
<db:td>
<db:para>Uses <db:link xlink:href="qurl.xml#toEncoded">QUrl::toEncoded</db:link>() to normalize the encoding to the URL's fully encoded format</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Uuid</db:para>
</db:td>
<db:td>
<db:para>Uuid and Byte array</db:para>
</db:td>
<db:td>
<db:para>Uses <db:link xlink:href="quuid.xml#toString">QUuid::toString</db:link>() to create the string representation</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section>
<db:title>Notes</db:title>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#fromJsonValue">fromJsonValue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toVariant">toVariant</db:link>()</db:member>
<db:member><db:link xlink:href="qcborarray.xml#toJsonArray">QCborArray::toJsonArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#toJsonObject">QCborMap::toJsonObject</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toRegularExpression">
<db:title>QRegularExpression QCborValue::toRegularExpression(const QRegularExpression &amp;<db:emphasis>defaultValue</db:emphasis> = {}) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRegularExpression</db:type>
<db:methodname>toRegularExpression</db:methodname>
<db:methodparam>
<db:type>const QRegularExpression &amp;</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRegularExpression toRegularExpression(const QRegularExpression &amp;defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the regular expression value stored in this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, if it is of the regular expression pattern extended type. Otherwise, it returns <db:code role="parameter">defaultValue</db:code>.</db:para>
<db:para>Note that this function performs no conversion from other types to <db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isRegularExpression">isRegularExpression</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTag">isTag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toSimpleType">
<db:title>QCborSimpleType QCborValue::toSimpleType(QCborSimpleType <db:emphasis>defaultValue</db:emphasis> = QCborSimpleType::Undefined) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborSimpleType</db:type>
<db:methodname>toSimpleType</db:methodname>
<db:methodparam>
<db:type>QCborSimpleType</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>QCborSimpleType::Undefined</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborSimpleType toSimpleType(QCborSimpleType defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the simple type this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is of, if it is a simple type. If it is not a simple type, it returns <db:code role="parameter">defaultValue</db:code>.</db:para>
<db:para>The following types are simple types and this function will return the listed values:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qcborvalue.xml#Type-enum">QCborValue::False</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtcborcommon.xml#QCborSimpleType-enum">QCborSimpleType::False</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qcborvalue.xml#Type-enum">QCborValue::True</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtcborcommon.xml#QCborSimpleType-enum">QCborSimpleType::True</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qcborvalue.xml#Type-enum">QCborValue::Null</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtcborcommon.xml#QCborSimpleType-enum">QCborSimpleType::Null</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qcborvalue.xml#Type-enum">QCborValue::Undefined</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtcborcommon.xml#QCborSimpleType-enum">QCborSimpleType::Undefined</db:link></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isSimpleType">isSimpleType</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isBool">isBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isFalse">isFalse</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUndefined">isUndefined</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toString">
<db:title>QString QCborValue::toString(const QString &amp;<db:emphasis>defaultValue</db:emphasis> = {}) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>toString</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString toString(const QString &amp;defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the string value stored in this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, if it is of the string type. Otherwise, it returns <db:code role="parameter">defaultValue</db:code>.</db:para>
<db:para>Note that this function performs no conversion from other types to <db:link xlink:href="qstring.xml">QString</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isString">isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isByteArray">isByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toByteArray">toByteArray</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUrl">
<db:title>QUrl QCborValue::toUrl(const QUrl &amp;<db:emphasis>defaultValue</db:emphasis> = {}) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QUrl</db:type>
<db:methodname>toUrl</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUrl toUrl(const QUrl &amp;defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the URL value stored in this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, if it is of the URL extended type. Otherwise, it returns <db:code role="parameter">defaultValue</db:code>.</db:para>
<db:para>Note that this function performs no conversion from other types to <db:link xlink:href="qurl.xml">QUrl</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isUrl">isUrl</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTag">isTag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toUuid">
<db:title>QUuid QCborValue::toUuid(const QUuid &amp;<db:emphasis>defaultValue</db:emphasis> = {}) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QUuid</db:type>
<db:methodname>toUuid</db:methodname>
<db:methodparam>
<db:type>const QUuid &amp;</db:type>
<db:parameter>defaultValue</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QUuid toUuid(const QUuid &amp;defaultValue) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the UUID value stored in this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>, if it is of the UUID extended type. Otherwise, it returns <db:code role="parameter">defaultValue</db:code>.</db:para>
<db:para>Note that this function performs no conversion from other types to <db:link xlink:href="quuid.xml">QUuid</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isUuid">isUuid</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTag">isTag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#taggedValue">taggedValue</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="toVariant">
<db:title>QVariant QCborValue::toVariant() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>toVariant</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant toVariant() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Converts this value to a native Qt type and returns the corresponding <db:link xlink:href="qvariant.xml">QVariant</db:link>.</db:para>
<db:para>The following table lists the mapping performed between <db:link xlink:href="qcborvalue.xml#Type-enum">QCborValue types</db:link> and <db:link xlink:href="qmetatype.xml#Type-enum">Qt meta types</db:link>.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>CBOR Type</db:para>
</db:th>
<db:th>
<db:para>Qt or C++ type</db:para>
</db:th>
<db:th>
<db:para>Notes</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>Integer</db:para>
</db:td>
<db:td>
<db:para>qint64</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Double</db:para>
</db:td>
<db:td>
<db:para>double</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Bool</db:para>
</db:td>
<db:td>
<db:para>bool</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Null</db:para>
</db:td>
<db:td>
<db:para>std::nullptr_t</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Undefined</db:para>
</db:td>
<db:td>
<db:para>no type (QVariant())</db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Byte array</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qbytearray.xml">QByteArray</db:link></db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>String</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qstring.xml">QString</db:link></db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Array</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link></db:para>
</db:td>
<db:td>
<db:para>Recursively converts all values</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Map</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link></db:para>
</db:td>
<db:td>
<db:para>Key types are &quot;stringified&quot;</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Other simple types</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qtcborcommon.xml#QCborSimpleType-enum">QCborSimpleType</db:link></db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qcborvalue.xml#Type-enum">DateTime</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qdatetime.xml">QDateTime</db:link></db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Url</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qurl.xml">QUrl</db:link></db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qcborvalue.xml#Type-enum">RegularExpression</db:link></db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qregularexpression.xml">QRegularExpression</db:link></db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Uuid</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="quuid.xml">QUuid</db:link></db:para>
</db:td>
<db:td>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Other tags</db:para>
</db:td>
<db:td>
<db:para>Special</db:para>
</db:td>
<db:td>
<db:para>The tag is ignored and the tagged value is converted using this function</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Note that values in both CBOR Maps and Arrays are converted recursively using this function too and placed in <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> and <db:link xlink:href="qvariant.xml#QVariantList-typedef">QVariantList</db:link> instead. You will not find <db:link xlink:href="qcbormap.xml">QCborMap</db:link> and <db:link xlink:href="qcborarray.xml">QCborArray</db:link> stored inside the QVariants.</db:para>
<db:para>QVariantMaps have string keys, unlike CBOR, so the conversion of a <db:link xlink:href="qcbormap.xml">QCborMap</db:link> to <db:link xlink:href="qvariant.xml#QVariantMap-typedef">QVariantMap</db:link> will imply a step of &quot;stringification&quot; of the key values. See <db:link xlink:href="qcbormap.xml#toJsonObject">QCborMap::toJsonObject</db:link>() for details.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#fromVariant">fromVariant</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#toJsonValue">toJsonValue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborarray.xml#toVariantList">QCborArray::toVariantList</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#toVariantMap">QCborMap::toVariantMap</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="type">
<db:title>QCborValue::Type QCborValue::type() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QCborValue::Type</db:type>
<db:methodname>type</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue::Type type() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the type of this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link>. The type can also later be retrieved by one of the &quot;isXxx&quot; functions.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#isInteger">isInteger</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isByteArray">isByteArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isString">isString</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isArray">isArray</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isMap">isMap</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTag">isTag</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isFalse">isFalse</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isTrue">isTrue</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isBool">isBool</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isNull">isNull</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUndefined">isUndefined</db:link></db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isDouble">isDouble</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isDateTime">isDateTime</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUrl">isUrl</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isRegularExpression">isRegularExpression</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#isUuid">isUuid</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QCborValue::operator!=(const QCborValue &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QCborValue &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares this value and <db:code role="parameter">other</db:code>, and returns true if contents differ, false otherwise. If each <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> contains an array or map, the comparison is recursive to elements contained in them.</db:para>
<db:para>For more information on CBOR equality in Qt, see, <db:link xlink:href="qcborvalue.xml#compare">QCborValue::compare</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#compare">compare</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#operator-eq-eq">QCborValue::operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-eq-eq">QCborMap::operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#operator-eq-eq">operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#operator-lt">operator&lt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-lt">
<db:title>bool QCborValue::operator&lt;(const QCborValue &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator&lt;</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator&lt;(const QCborValue &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares this value and <db:code role="parameter">other</db:code>, and returns true if this value should be sorted before <db:code role="parameter">other</db:code>, false otherwise. If each <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> contains an array or map, the comparison is recursive to elements contained in them.</db:para>
<db:para>For more information on CBOR sorting order, see <db:link xlink:href="qcborvalue.xml#compare">QCborValue::compare</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#compare">compare</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#operator-eq-eq">QCborValue::operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-eq-eq">QCborMap::operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#operator-eq-eq">operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#operator-not-eq">operator!=</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-eq">
<db:title>QCborValue &amp;QCborValue::operator=(const QCborValue &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValue &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue &amp; operator=(const QCborValue &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Replaces the contents of this QCborObject with a copy of <db:code role="parameter">other</db:code>.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QCborValue &amp;QCborValue::operator=(QCborValue &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValue &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>QCborValue &amp;&amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">move-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValue &amp; operator=(QCborValue &amp;&amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Moves the contents of the <db:code role="parameter">other</db:code> <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object into this one and frees the resources of this one. Returns a reference to this object.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QCborValue::operator==(const QCborValue &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QCborValue &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QCborValue &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares this value and <db:code role="parameter">other</db:code>, and returns true if they hold the same contents, false otherwise. If each <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> contains an array or map, the comparison is recursive to elements contained in them.</db:para>
<db:para>For more information on CBOR equality in Qt, see, <db:link xlink:href="qcborvalue.xml#compare">compare</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#compare">compare</db:link>()</db:member>
<db:member><db:link xlink:href="">QCborValue::operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-eq-eq">QCborMap::operator==</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#operator-not-eq">operator!=</db:link>()</db:member>
<db:member><db:link xlink:href="qcborvalue.xml#operator-lt">operator&lt;</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>const QCborValue QCborValue::operator[](const QString &amp;<db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QCborValue</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QCborValue operator[](const QString &amp;key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>If this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is a <db:link xlink:href="qcbormap.xml">QCborMap</db:link>, searches elements for the value whose key matches <db:code role="parameter">key</db:code>. If there's no key matching <db:code role="parameter">key</db:code> in the map or if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object is not a map, returns the undefined value.</db:para>
<db:para>This function is equivalent to:</db:para>
<db:programlisting language="cpp">    value.toMap().value(key);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#operator-5b-5d-2">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">QCborMap::operator[]</db:link></db:member>
<db:member><db:link xlink:href="qcbormap.xml#value">QCborMap::value</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">QCborMap::find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-1">
<db:title>const QCborValue QCborValue::operator[](QLatin1StringView <db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QCborValue</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>QLatin1StringView</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const QCborValue operator[](QLatin1StringView key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>If this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is a <db:link xlink:href="qcbormap.xml">QCborMap</db:link>, searches elements for the value whose key matches <db:code role="parameter">key</db:code>. If there's no key matching <db:code role="parameter">key</db:code> in the map or if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object is not a map, returns the undefined value.</db:para>
<db:para>This function is equivalent to:</db:para>
<db:programlisting language="cpp">    value.toMap().value(key);
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#operator-5b-5d-2">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">QCborMap::operator[]</db:link></db:member>
<db:member><db:link xlink:href="qcbormap.xml#value">QCborMap::value</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">QCborMap::find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-2">
<db:title>const QCborValue QCborValue::operator[](qint64 <db:emphasis>key</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QCborValue</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">const QCborValue operator[](qint64 key) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>If this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is a <db:link xlink:href="qcbormap.xml">QCborMap</db:link>, searches elements for the value whose key matches <db:code role="parameter">key</db:code>. If this is a <db:link xlink:href="qcborarray.xml">QCborArray</db:link>, returns the element whose index is <db:code role="parameter">key</db:code>. If there's no matching value in the array or map, or if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> object is not an array or map, returns the undefined value.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#operator-5b-5d">operator[]</db:link></db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">QCborMap::operator[]</db:link></db:member>
<db:member><db:link xlink:href="qcbormap.xml#value">QCborMap::value</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">QCborMap::find</db:link>()</db:member>
<db:member><db:link xlink:href="qcborarray.xml#operator-5b-5d">QCborArray::operator[]</db:link></db:member>
<db:member><db:link xlink:href="qcborarray.xml#at">QCborArray::at</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-3">
<db:title>QCborValueRef QCborValue::operator[](qint64 <db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValueRef</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>qint64</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValueRef operator[](qint64 key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a QCborValueRef that can be used to read or modify the entry in this, as a map or array, with the given <db:code role="parameter">key</db:code>. When this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is a <db:link xlink:href="qcbormap.xml">QCborMap</db:link> or, for 0 &lt;= key &lt; 0x10000, a <db:link xlink:href="qcborarray.xml">QCborArray</db:link>, this function is equivalent to the matching operator[] on that map or array.</db:para>
<db:para>Before returning the reference: if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> was an array but the key is out of range, the array is first converted to a map (so that map[i] is array[i] for each index, i, with valid array[i]); otherwise, if it was not a map it will be over-written with an empty map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#operator-5b-5d">operator[]</db:link></db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">QCborMap::operator[]</db:link></db:member>
<db:member><db:link xlink:href="qcbormap.xml#value">QCborMap::value</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">QCborMap::find</db:link>()</db:member>
<db:member><db:link xlink:href="qcborarray.xml#operator-5b-5d">QCborArray::operator[]</db:link></db:member>
<db:member><db:link xlink:href="qcborarray.xml#at">QCborArray::at</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-4">
<db:title>QCborValueRef QCborValue::operator[](QLatin1StringView <db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValueRef</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>QLatin1StringView</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValueRef operator[](QLatin1StringView key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a QCborValueRef that can be used to read or modify the entry in this, as a map, with the given <db:code role="parameter">key</db:code>. When this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is a <db:link xlink:href="qcbormap.xml">QCborMap</db:link>, this function is equivalent to the matching operator[] on that map.</db:para>
<db:para>Before returning the reference: if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> was an array, it is first converted to a map (so that map[i] is array[i] for each index, i, with valid array[i]); otherwise, if it was not a map it will be over-written with an empty map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#operator-5b-5d-2">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">QCborMap::operator[]</db:link></db:member>
<db:member><db:link xlink:href="qcbormap.xml#value">QCborMap::value</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">QCborMap::find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d-5">
<db:title>QCborValueRef QCborValue::operator[](const QString &amp;<db:emphasis>key</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QCborValueRef</db:type>
<db:methodname>operator[]</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>key</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">QCborValueRef operator[](const QString &amp;key)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a QCborValueRef that can be used to read or modify the entry in this, as a map, with the given <db:code role="parameter">key</db:code>. When this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> is a <db:link xlink:href="qcbormap.xml">QCborMap</db:link>, this function is equivalent to the matching operator[] on that map.</db:para>
<db:para>Before returning the reference: if this <db:link xlink:href="qcborvalue.xml">QCborValue</db:link> was an array, it is first converted to a map (so that map[i] is array[i] for each index, i, with valid array[i]); otherwise, if it was not a map it will be over-written with an empty map.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qcborvalue.xml#operator-5b-5d-2">operator[]</db:link>(qint64)</db:member>
<db:member><db:link xlink:href="qcbormap.xml#operator-5b-5d">QCborMap::operator[]</db:link></db:member>
<db:member><db:link xlink:href="qcbormap.xml#value">QCborMap::value</db:link>()</db:member>
<db:member><db:link xlink:href="qcbormap.xml#find">QCborMap::find</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
