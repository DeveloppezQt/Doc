<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>WebEngine Quick Nano Browser</db:title>
<db:productname>QtWebEngine</db:productname>
<db:edition>Qt 6.4.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt WebEngine Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A web browser implemented using the <db:link xlink:href="qml-qtwebengine-webengineview.xml">WebEngineView</db:link> QML type.</db:para>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/quicknanobrowser-demo.jpg"/>
</db:imageobject>
</db:mediaobject>
<db:para><db:emphasis>Quick Nano Browser</db:emphasis> demonstrates how to use the <db:link xlink:href="qtwebengine-qmlmodule.xml">Qt WebEngine QML types</db:link> to develop a small web browser application that consists of a browser window with a title bar, toolbar, tab view, and status bar. The web content is loaded in a web engine view within the tab view. If certificate errors occur, users are prompted for action in a message dialog. The status bar pops up to display the URL of a hovered link.</db:para>
<db:para>A web page can issue a request for being displayed in fullscreen mode. Users can allow full screen mode by using a toolbar button. They can leave fullscreen mode by using a keyboard shortcut. Additional toolbar buttons enable moving backwards and forwards in the browser history, reloading tab content, and opening a settings menu for enabling the following features: JavaScript, plugins, fullscreen mode, off the record, HTTP disk cache, autoloading images, and ignoring certificate errors.</db:para>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="https://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:guilabel>Welcome</db:guilabel> mode and select the example from <db:guilabel>Examples</db:guilabel>. For more information, visit <db:link xlink:href="https://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="creating-the-main-browser-window">
<db:title>Creating the Main Browser Window</db:title>
<db:para>When the browser main window is loaded, it creates an empty tab using the default profile. Each tab is a web engine view that fills the main window.</db:para>
<db:para>We create the main window in the <db:emphasis>BrowserWindow.qml</db:emphasis> file using the <db:link xlink:href="qml-qtquick-controls2-applicationwindow.xml">ApplicationWindow</db:link> type:</db:para>
<db:programlisting language="cpp">ApplicationWindow {
    id: browserWindow
    property QtObject applicationRoot
    property Item currentWebView: tabBar.currentIndex &amp;lt; tabBar.count ? tabLayout.children[tabBar.currentIndex] : null
    ...
    width: 1300
    height: 900
    visible: true
    title: currentWebView &amp;amp;&amp;amp; currentWebView.title
</db:programlisting>
<db:para>We use the <db:link xlink:href="qml-qtquick-controls2-tabbar.xml">TabBar</db:link> Qt Quick control to create a tab bar anchored to the top of the window, and create a new, empty tab:</db:para>
<db:programlisting language="cpp">    TabBar {
        id: tabBar
        anchors.top: parent.top
        anchors.left: parent.left
        anchors.right: parent.right
        Component.onCompleted: createTab(defaultProfile)

        function createTab(profile, focusOnNewTab = true, url = undefined) {
            var webview = tabComponent.createObject(tabLayout, {profile: profile});
            var newTabButton = tabButtonComponent.createObject(tabBar, {tabTitle: Qt.binding(function () { return webview.title; })});
            tabBar.addItem(newTabButton);
            if (focusOnNewTab) {
                tabBar.setCurrentIndex(tabBar.count - 1);
            }
</db:programlisting>
<db:para>The tab contains a web engine view that loads web content:</db:para>
<db:programlisting language="cpp">        Component {
            id: tabComponent
            WebEngineView {
                id: webEngineView
                focus: true

                onLinkHovered: function(hoveredUrl) {
                    if (hoveredUrl == &quot;&quot;)
                        hideStatusText.start();
                    else {
                        statusText.text = hoveredUrl;
                        statusBubble.visible = true;
                        hideStatusText.stop();
                    }
                }

                states: [
                    State {
                        name: &quot;FullScreen&quot;
                        PropertyChanges {
                            target: tabBar
                            visible: false
                            height: 0
                        }
                        PropertyChanges {
                            target: navigationBar
                            visible: false
                        }
                    }
                ]
                settings.localContentCanAccessRemoteUrls: true
                settings.localContentCanAccessFileUrls: false
                settings.autoLoadImages: appSettings.autoLoadImages
                settings.javascriptEnabled: appSettings.javaScriptEnabled
                settings.errorPageEnabled: appSettings.errorPageEnabled
                settings.pluginsEnabled: appSettings.pluginsEnabled
                settings.fullScreenSupportEnabled: appSettings.fullScreenSupportEnabled
                settings.autoLoadIconsForPage: appSettings.autoLoadIconsForPage
                settings.touchIconsEnabled: appSettings.touchIconsEnabled
                settings.webRTCPublicInterfacesOnly: appSettings.webRTCPublicInterfacesOnly
                settings.pdfViewerEnabled: appSettings.pdfViewerEnabled

                onCertificateError: function(error) {
                    error.defer();
                    sslDialog.enqueue(error);
                }

                onNewWindowRequested: function(request) {
                    if (!request.userInitiated)
                        console.warn(&quot;Blocked a popup window.&quot;);
                    else if (request.destination === WebEngineNewWindowRequest.InNewTab) {
                        var tab = tabBar.createTab(currentWebView.profile, true, request.requestedUrl);
                        tab.acceptAsNewWindow(request);
                    } else if (request.destination === WebEngineNewWindowRequest.InNewBackgroundTab) {
                        var backgroundTab = tabBar.createTab(currentWebView.profile, false);
                        backgroundTab.acceptAsNewWindow(request);
                    } else if (request.destination === WebEngineNewWindowRequest.InNewDialog) {
                        var dialog = applicationRoot.createDialog(currentWebView.profile);
                        dialog.currentWebView.acceptAsNewWindow(request);
                    } else {
                        var window = applicationRoot.createWindow(currentWebView.profile);
                        window.currentWebView.acceptAsNewWindow(request);
                    }
                }

                onFullScreenRequested: function(request) {
                    if (request.toggleOn) {
                        webEngineView.state = &quot;FullScreen&quot;;
                        browserWindow.previousVisibility = browserWindow.visibility;
                        browserWindow.showFullScreen();
                        fullScreenNotification.show();
                    } else {
                        webEngineView.state = &quot;&quot;;
                        browserWindow.visibility = browserWindow.previousVisibility;
                        fullScreenNotification.hide();
                    }
                    request.accept();
                }

                onQuotaRequested: function(request) {
                    if (request.requestedSize &amp;lt;= 5 * 1024 * 1024)
                        request.accept();
                    else
                        request.reject();
                }

                onRegisterProtocolHandlerRequested: function(request) {
                    console.log(&quot;accepting registerProtocolHandler request for &quot;
                                + request.scheme + &quot; from &quot; + request.origin);
                    request.accept();
                }

                onRenderProcessTerminated: function(terminationStatus, exitCode) {
                    var status = &quot;&quot;;
                    switch (terminationStatus) {
                    case WebEngineView.NormalTerminationStatus:
                        status = &quot;(normal exit)&quot;;
                        break;
                    case WebEngineView.AbnormalTerminationStatus:
                        status = &quot;(abnormal exit)&quot;;
                        break;
                    case WebEngineView.CrashedTerminationStatus:
                        status = &quot;(crashed)&quot;;
                        break;
                    case WebEngineView.KilledTerminationStatus:
                        status = &quot;(killed)&quot;;
                        break;
                    }

                    print(&quot;Render process exited with code &quot; + exitCode + &quot; &quot; + status);
                    reloadTimer.running = true;
                }

                onSelectClientCertificate: function(selection) {
                    selection.certificates[0].select();
                }

                onFindTextFinished: function(result) {
                    if (!findBar.visible)
                        findBar.visible = true;

                    findBar.numberOfMatches = result.numberOfMatches;
                    findBar.activeMatch = result.activeMatch;
                }

                onLoadingChanged: function(loadRequest) {
                    if (loadRequest.status == WebEngineView.LoadStartedStatus)
                        findBar.reset();
                }

                Timer {
                    id: reloadTimer
                    interval: 0
                    running: false
                    repeat: false
                    onTriggered: currentWebView.reload()
                }
            }
        }
</db:programlisting>
<db:para>We use the <db:link xlink:href="qml-qtquick-controls2-action.xml">Action</db:link> type to create new tabs:</db:para>
<db:programlisting language="cpp">    Action {
        shortcut: StandardKey.AddTab
        onTriggered: {
            tabBar.createTab(tabBar.count != 0 ? currentWebView.profile : defaultProfile);
            addressBar.forceActiveFocus();
            addressBar.selectAll();
        }
</db:programlisting>
<db:para>We use the <db:link xlink:href="qml-qtquick-controls2-textfield.xml">TextField</db:link> Qt Quick Control within a <db:link xlink:href="qml-qtquick-controls2-toolbar.xml">ToolBar</db:link> to create an address bar that shows the current URL and where users can enter another URL:</db:para>
<db:programlisting language="cpp">    menuBar: ToolBar {
        id: navigationBar
        RowLayout {
            anchors.fill: parent
    ...
            TextField {
                id: addressBar
    ...
                focus: true
                Layout.fillWidth: true
                Binding on text {
                    when: currentWebView
                    value: currentWebView.url
                }
                onAccepted: currentWebView.url = Utils.fromUserInput(text)
                selectByMouse: true
            }
</db:programlisting>
</db:section>
<db:section xml:id="handling-certificate-errors">
<db:title>Handling Certificate Errors</db:title>
<db:para>If the certificate of the site being loaded triggers a certificate error, we call the <db:link xlink:href="qml-qtwebengine-webenginecertificateerror.xml#defer-method">defer</db:link>() QML method to pause the URL request and wait for user input:</db:para>
<db:programlisting language="cpp">                onCertificateError: function(error) {
                    error.defer();
                    sslDialog.enqueue(error);
                }
</db:programlisting>
<db:para>We use the Dialog type to prompt users to continue or cancel the loading of the web page. If users select <db:guilabel>Yes</db:guilabel>, we call the <db:link xlink:href="qml-qtwebengine-webenginecertificateerror.xml#acceptCertificate-method">acceptCertificate</db:link>() method to continue loading content from the URL. If users select <db:guilabel>No</db:guilabel>, we call the <db:link xlink:href="qml-qtwebengine-webenginecertificateerror.xml#rejectCertificate-method">rejectCertificate</db:link>() method to reject the request and stop loading content from the URL:</db:para>
<db:programlisting language="cpp">    Dialog {
        id: sslDialog
        anchors.centerIn: parent
        contentWidth: Math.max(mainText.width, detailedText.width)
        contentHeight: mainText.height + detailedText.height
        property var certErrors: []
        // fixme: icon!
        // icon: StandardIcon.Warning
        standardButtons: Dialog.No | Dialog.Yes
        title: &quot;Server's certificate not trusted&quot;
        contentItem: Item {
            id: textContentItem
            Label {
                id: mainText
                text: &quot;Do you wish to continue?&quot;
            }
            Text {
                id: detailedText
                anchors.top: mainText.bottom
                text: &quot;If you wish so, you may continue with an unverified certificate.\n&quot; +
                      &quot;Accepting an unverified certificate means\n&quot; +
                      &quot;you may not be connected with the host you tried to connect to.\n&quot; +
                      &quot;Do you wish to override the security check and continue?&quot;
            }
        }

        onAccepted: {
            certErrors.shift().acceptCertificate();
            presentError();
        }
        onRejected: reject()

        function reject(){
            certErrors.shift().rejectCertificate();
            presentError();
        }
        function enqueue(error){
            certErrors.push(error);
            presentError();
        }
        function presentError(){
            visible = certErrors.length &amp;gt; 0
        }
    }
</db:programlisting>
</db:section>
<db:section xml:id="entering-and-leaving-fullscreen-mode">
<db:title>Entering and Leaving Fullscreen Mode</db:title>
<db:para>We create a menu item for allowing fullscreen mode in a settings menu that we place on the tool bar. Also, we create an action for leaving fullscreen mode by using a keyboard shortcut. We call the <db:link xlink:href="qml-qtwebengine-fullscreenrequest.xml#accept-method">accept</db:link>() method to accept the fullscreen request. The methdod sets the <db:link xlink:href="qml-qtwebengine-webengineview.xml#isFullScreen-prop">isFullScreen</db:link> property to be equal to the <db:link xlink:href="qml-qtwebengine-fullscreenrequest.xml#toggleOn-prop">toggleOn</db:link> property.</db:para>
<db:programlisting language="cpp">                onFullScreenRequested: function(request) {
                    if (request.toggleOn) {
                        webEngineView.state = &quot;FullScreen&quot;;
                        browserWindow.previousVisibility = browserWindow.visibility;
                        browserWindow.showFullScreen();
                        fullScreenNotification.show();
                    } else {
                        webEngineView.state = &quot;&quot;;
                        browserWindow.visibility = browserWindow.previousVisibility;
                        fullScreenNotification.hide();
                    }
                    request.accept();
                }
</db:programlisting>
<db:para>When entering fullscreen mode, we display a notification using the FullScreenNotification custom type that we create in <db:emphasis>FullScreenNotification.qml</db:emphasis>.</db:para>
<db:para>We use the <db:link xlink:href="qml-qtquick-controls2-action.xml">Action</db:link> type in the settings menu to create a shortcut for leaving fullscreen mode by pressing the escape key:</db:para>
<db:programlisting language="cpp">    Settings {
        id : appSettings
        property alias fullScreenSupportEnabled: fullScreenSupportEnabled.checked
        property alias autoLoadIconsForPage: autoLoadIconsForPage.checked
        property alias touchIconsEnabled: touchIconsEnabled.checked
        property alias webRTCPublicInterfacesOnly : webRTCPublicInterfacesOnly.checked
        property alias devToolsEnabled: devToolsEnabled.checked
        property alias pdfViewerEnabled: pdfViewerEnabled.checked
    }

    Action {
        shortcut: &quot;Escape&quot;
        onTriggered: {
            if (currentWebView.state == &quot;FullScreen&quot;) {
                browserWindow.visibility = browserWindow.previousVisibility;
                fullScreenNotification.hide();
                currentWebView.triggerWebAction(WebEngineView.ExitFullScreen);
            }

            if (findBar.visible)
                findBar.visible = false;
        }
    }
</db:programlisting>
</db:section>
<db:section xml:id="files-and-attributions">
<db:title>Files and Attributions</db:title>
<db:para>The example uses icons from the Tango Icon Library:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="">Tango Icon Library</db:link></db:para>
</db:td>
<db:td>
<db:para>Public Domain</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtwebengine.git/tree/examples/webenginequick/quicknanobrowser?h=6.4">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
