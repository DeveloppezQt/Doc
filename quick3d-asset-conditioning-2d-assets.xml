<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Optimizing 2D Assets</db:title>
<db:productname>QtQuick3D</db:productname>
<db:edition>Qt Quick 3D | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Quick 3D Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Qt Quick 3D Reference Documentation.</db:para></db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>Optimizing the images used by Texture components in your scene can substantially improve both the startup and runtime performance of your application, as well as the visual quality in certain situations.</db:para>
<db:section xml:id="motivation">
<db:title>Motivation</db:title>
<db:para>Unoptimized images can hurt the performance of your application in several ways:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>A large image takes more memory bandwidth when being traversed as a texture.</db:para>
</db:listitem>
<db:listitem>
<db:para>PNG and JPG compressed images must be decompressed before they can be sent to the graphics system.</db:para>
</db:listitem>
<db:listitem>
<db:para>Poorly sized images degrade performance and quality on startup</db:para>
</db:listitem>
<db:listitem>
<db:para>Sending uncompressed images to the graphics system takes longer, and they take up more graphics memory when there.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Additionally, choosing an appropriate size for your images and <db:link xlink:href="quick3d-asset-conditioning-2d-assets.xml#using-mipmaps">using mipmaps</db:link> can prevent aliasing issues if your image is going to be shown substantially smaller at some points.</db:para>
<db:anchor xml:id="image-dimensions"/>
</db:section>
<db:section xml:id="reducing-image-dimensions">
<db:title>Reducing Image Dimensions</db:title>
<db:note>
<db:para>Make your image small, but with dimensions that are power of two.</db:para>
</db:note>
<db:para>The first thing you need to do is resize your image to be <db:emphasis>almost</db:emphasis> as small as possible. Smaller images can be loaded faster by the graphics system as they need less bandwidth and memory. Think about the largest size that your image will ever be seen at, and resize your image down to that size. If your texture will be tiling at about 32 pixels per repetition, don't save it at 1024×1024.</db:para>
<db:para>However, note that both the horizontal and vertical dimensions of your image must be POT(power of two) to be stored on the GPU. Most of modern GPUs support NPOT(non-power of two) textures but many investigations show that using NPOT textures hurts about 30% of the performance. If you need to use NPOT textures, we recommend to make the dimensions multiple of 4. It might help your GPU to use its memory and cache efficiently and finally increase performance.</db:para>
<db:note>
<db:para>If you are <db:link xlink:href="quick3d-asset-conditioning-2d-assets.xml#using-mipmaps">using mipmaps</db:link>, there are further constraints on image dimensions.</db:para>
</db:note>
</db:section>
<db:section xml:id="using-mipmaps">
<db:title>Using MipMaps</db:title>
<db:note>
<db:para>Use mipmaps when your image may be seen smaller than the original size, including portions in perspective.</db:para>
</db:note>
<db:para>Enabling mipmaps creates many smaller copies of the image at an additional 1/3 memory usage. Each mipmap dimension is halved from the one preceding it, and is downsized in image editing tool with good image resampling. The result speeds up rendering, decreases the time that the GPU uses for texture lookup, and also reduces aliasing artifacts such as moiré effects or <db:link xlink:href="quick3d-asset-conditioning-anti-aliasing.xml#texture-aliasing">texture subsampling</db:link>.</db:para>
<db:para>To provide mipmaps at build time, the texture needs to be in a container format like KTX, as standard image formats do not have the capability of storing mipmaps.</db:para>
<db:para>It is possible to generate mipmaps at runtime by setting the property <db:link xlink:href="qml-qtquick3d-texture.xml#generateMipmaps-prop">Texture::generateMipmaps</db:link> to <db:code>true</db:code>.</db:para>
<db:note>
<db:para>Mipmaps require specific image dimensions to work correctly at all levels, depending on which encoding is used.</db:para>
</db:note>
<db:section xml:id="mipmaps-and-image-dimensions">
<db:title>MipMaps and Image Dimensions</db:title>
<db:para>If the original image dimensions are represented by <db:code>width</db:code>, <db:code>height</db:code>, and <db:code>depth</db:code>, the number of mipmap levels will be <db:code>1 + floor(log2(max(width, height, depth)))</db:code> and each levels' dimensions will be <db:code>max(1, width_prev &gt;&gt; 1)</db:code>, <db:code>max(1, height_prev &gt;&gt; 1)</db:code>, and <db:code>max(1, depth_prev &gt;&gt; 1)</db:code>.</db:para>
</db:section>
</db:section>
<db:section xml:id="saving-alpha-channels">
<db:title>Saving Alpha Channels</db:title>
<db:para>Most of the time when dealing with images with semi-transparent regions, it is easier to use image editing tool's transparent layers when editing such images. If you choose a compressed encoding that supports alpha, the transparent regions of your scene are properly used for the alpha information.</db:para>
<db:para>However, in certain cases you need to control the RGB values of fully transparent pixels. Specifically, you can see visual artifacts if:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Any portion of your image will ever be seen at a size larger than saved.</db:para>
</db:listitem>
<db:listitem>
<db:para>You have fully transparent pixels in your image next to rather opaque pixels.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In this case, the texture interpolation between a fully-transparent pixel and its neighboring somewhat-opaque pixel blends the RGB values between the two. If you use the image editing tool's transparent layers, the RGB values for certain transparent pixels are saved as white, and you will thus see white fringing at the edges of your transparent regions.</db:para>
<db:para>For such cases, instead of creating a semi-transparent layer in your image editing tool, create a layer with no transparency at all, setting the RGB value for every pixel you care about. Then, save the alpha information in a fourth channel.</db:para>
</db:section>
</db:article>
