<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Sub-Attaq</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>This example shows Qt's ability to combine <db:link xlink:href="animation-overview.xml">the animation framework</db:link> and <db:link xlink:href="statemachine-api.xml">the state machine framework</db:link> to create a game.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the QtCore module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

//Own
#include &quot;boat.h&quot;
#include &quot;boat_p.h&quot;
#include &quot;bomb.h&quot;
#include &quot;pixmapitem.h&quot;
#include &quot;graphicsscene.h&quot;
#include &quot;animationmanager.h&quot;
#include &quot;qanimationstate.h&quot;

//Qt
#include &amp;lt;QtCore/QPropertyAnimation&amp;gt;
#include &amp;lt;QtCore/QStateMachine&amp;gt;
#include &amp;lt;QtCore/QHistoryState&amp;gt;
#include &amp;lt;QtCore/QFinalState&amp;gt;
#include &amp;lt;QtCore/QState&amp;gt;
#include &amp;lt;QtCore/QSequentialAnimationGroup&amp;gt;

static QAbstractAnimation *setupDestroyAnimation(Boat *boat)
{
    QSequentialAnimationGroup *group = new QSequentialAnimationGroup(boat);
    for (int i = 1; i &amp;lt;= 4; i++) {
        PixmapItem *step = new PixmapItem(QString(&quot;explosion/boat/step%1&quot;).arg(i),GraphicsScene::Big, boat);
        step-&amp;gt;setZValue(6);
        step-&amp;gt;setOpacity(0);

        //fade-in
        QPropertyAnimation *anim = new QPropertyAnimation(step, &quot;opacity&quot;);
        anim-&amp;gt;setEndValue(1);
        anim-&amp;gt;setDuration(100);
        group-&amp;gt;insertAnimation(i-1, anim);

        //and then fade-out
        QPropertyAnimation *anim2 = new QPropertyAnimation(step, &quot;opacity&quot;);
        anim2-&amp;gt;setEndValue(0);
        anim2-&amp;gt;setDuration(100);
        group-&amp;gt;addAnimation(anim2);
    }

    AnimationManager::self()-&amp;gt;registerAnimation(group);
    return group;
}

Boat::Boat() : PixmapItem(QString(&quot;boat&quot;), GraphicsScene::Big),
    speed(0), bombsAlreadyLaunched(0), direction(Boat::None), movementAnimation(0)
{
    setZValue(4);
    setFlags(QGraphicsItem::ItemIsFocusable);

    //The movement animation used to animate the boat
    movementAnimation = new QPropertyAnimation(this, &quot;pos&quot;);

    //The destroy animation used to explode the boat
    destroyAnimation = setupDestroyAnimation(this);

    //We setup the state machine of the boat
    machine = new QStateMachine(this);
    QState *moving = new QState(machine);
    StopState *stopState = new StopState(this, moving);
    machine-&amp;gt;setInitialState(moving);
    moving-&amp;gt;setInitialState(stopState);
    MoveStateRight *moveStateRight = new MoveStateRight(this, moving);
    MoveStateLeft *moveStateLeft = new MoveStateLeft(this, moving);
    LaunchStateRight *launchStateRight = new LaunchStateRight(this, machine);
    LaunchStateLeft *launchStateLeft = new LaunchStateLeft(this, machine);

    //then setup the transitions for the rightMove state
    KeyStopTransition *leftStopRight = new KeyStopTransition(this, QEvent::KeyPress, Qt::Key_Left);
    leftStopRight-&amp;gt;setTargetState(stopState);
    KeyMoveTransition *leftMoveRight = new KeyMoveTransition(this, QEvent::KeyPress, Qt::Key_Left);
    leftMoveRight-&amp;gt;setTargetState(moveStateRight);
    KeyMoveTransition *rightMoveRight = new KeyMoveTransition(this, QEvent::KeyPress, Qt::Key_Right);
    rightMoveRight-&amp;gt;setTargetState(moveStateRight);
    KeyMoveTransition *rightMoveStop = new KeyMoveTransition(this, QEvent::KeyPress, Qt::Key_Right);
    rightMoveStop-&amp;gt;setTargetState(moveStateRight);

    //then setup the transitions for the leftMove state
    KeyStopTransition *rightStopLeft = new KeyStopTransition(this, QEvent::KeyPress, Qt::Key_Right);
    rightStopLeft-&amp;gt;setTargetState(stopState);
    KeyMoveTransition *rightMoveLeft = new KeyMoveTransition(this, QEvent::KeyPress, Qt::Key_Right);
    rightMoveLeft-&amp;gt;setTargetState(moveStateLeft);
    KeyMoveTransition *leftMoveLeft = new KeyMoveTransition(this, QEvent::KeyPress,Qt::Key_Left);
    leftMoveLeft-&amp;gt;setTargetState(moveStateLeft);
    KeyMoveTransition *leftMoveStop = new KeyMoveTransition(this, QEvent::KeyPress,Qt::Key_Left);
    leftMoveStop-&amp;gt;setTargetState(moveStateLeft);

    //We set up the right move state
    moveStateRight-&amp;gt;addTransition(leftStopRight);
    moveStateRight-&amp;gt;addTransition(leftMoveRight);
    moveStateRight-&amp;gt;addTransition(rightMoveRight);
    stopState-&amp;gt;addTransition(rightMoveStop);

    //We set up the left move state
    moveStateLeft-&amp;gt;addTransition(rightStopLeft);
    moveStateLeft-&amp;gt;addTransition(leftMoveLeft);
    moveStateLeft-&amp;gt;addTransition(rightMoveLeft);
    stopState-&amp;gt;addTransition(leftMoveStop);

    //The animation is finished, it means we reached the border of the screen, the boat is stopped so we move to the stop state
    moveStateLeft-&amp;gt;addTransition(movementAnimation, SIGNAL(finished()), stopState);
    moveStateRight-&amp;gt;addTransition(movementAnimation, SIGNAL(finished()), stopState);

    //We set up the keys for dropping bombs
    KeyLaunchTransition *upFireLeft = new KeyLaunchTransition(this, QEvent::KeyPress, Qt::Key_Up);
    upFireLeft-&amp;gt;setTargetState(launchStateRight);
    KeyLaunchTransition *upFireRight = new KeyLaunchTransition(this, QEvent::KeyPress, Qt::Key_Up);
    upFireRight-&amp;gt;setTargetState(launchStateRight);
    KeyLaunchTransition *upFireStop = new KeyLaunchTransition(this, QEvent::KeyPress, Qt::Key_Up);
    upFireStop-&amp;gt;setTargetState(launchStateRight);
    KeyLaunchTransition *downFireLeft = new KeyLaunchTransition(this, QEvent::KeyPress, Qt::Key_Down);
    downFireLeft-&amp;gt;setTargetState(launchStateLeft);
    KeyLaunchTransition *downFireRight = new KeyLaunchTransition(this, QEvent::KeyPress, Qt::Key_Down);
    downFireRight-&amp;gt;setTargetState(launchStateLeft);
    KeyLaunchTransition *downFireMove = new KeyLaunchTransition(this, QEvent::KeyPress, Qt::Key_Down);
    downFireMove-&amp;gt;setTargetState(launchStateLeft);

    //We set up transitions for fire up
    moveStateRight-&amp;gt;addTransition(upFireRight);
    moveStateLeft-&amp;gt;addTransition(upFireLeft);
    stopState-&amp;gt;addTransition(upFireStop);

    //We set up transitions for fire down
    moveStateRight-&amp;gt;addTransition(downFireRight);
    moveStateLeft-&amp;gt;addTransition(downFireLeft);
    stopState-&amp;gt;addTransition(downFireMove);

    //Finally the launch state should come back to its original state
    QHistoryState *historyState = new QHistoryState(moving);
    launchStateLeft-&amp;gt;addTransition(historyState);
    launchStateRight-&amp;gt;addTransition(historyState);

    QFinalState *final = new QFinalState(machine);

    //This state play the destroyed animation
    QAnimationState *destroyedState = new QAnimationState(machine);
    destroyedState-&amp;gt;setAnimation(destroyAnimation);

    //Play a nice animation when the boat is destroyed
    moving-&amp;gt;addTransition(this, SIGNAL(boatDestroyed()), destroyedState);

    //Transition to final state when the destroyed animation is finished
    destroyedState-&amp;gt;addTransition(destroyedState, SIGNAL(animationFinished()), final);

    //The machine has finished to be executed, then the boat is dead
    connect(machine,SIGNAL(finished()), this, SIGNAL(boatExecutionFinished()));

}

void Boat::run()
{
    //We register animations
    AnimationManager::self()-&amp;gt;registerAnimation(movementAnimation);
    AnimationManager::self()-&amp;gt;registerAnimation(destroyAnimation);
    machine-&amp;gt;start();
}

void Boat::stop()
{
    movementAnimation-&amp;gt;stop();
    machine-&amp;gt;stop();
}

void Boat::updateBoatMovement()
{
    if (speed == 0 || direction == Boat::None) {
        movementAnimation-&amp;gt;stop();
        return;
    }

    movementAnimation-&amp;gt;stop();

    if (direction == Boat::Left) {
        movementAnimation-&amp;gt;setEndValue(QPointF(0,y()));
        movementAnimation-&amp;gt;setDuration(x()/speed*15);
    }
    else /*if (direction == Boat::Right)*/ {
        movementAnimation-&amp;gt;setEndValue(QPointF(scene()-&amp;gt;width()-size().width(),y()));
        movementAnimation-&amp;gt;setDuration((scene()-&amp;gt;width()-size().width()-x())/speed*15);
    }
    movementAnimation-&amp;gt;start();
}

void Boat::destroy()
{
    movementAnimation-&amp;gt;stop();
    emit boatDestroyed();
}

int Boat::bombsLaunched() const
{
    return bombsAlreadyLaunched;
}

void Boat::setBombsLaunched(int number)
{
    if (number &amp;gt; MAX_BOMB) {
        qWarning(&quot;Boat::setBombsLaunched : It impossible to launch that number of bombs&quot;);
        return;
    }
    bombsAlreadyLaunched = number;
}

int Boat::currentSpeed() const
{
    return speed;
}

void Boat::setCurrentSpeed(int speed)
{
    if (speed &amp;gt; 3 || speed &amp;lt; 0) {
        qWarning(&quot;Boat::setCurrentSpeed: The boat can't run on that speed&quot;);
        return;
    }
    this-&amp;gt;speed = speed;
}

enum Boat::Movement Boat::currentDirection() const
{
    return direction;
}

void Boat::setCurrentDirection(Movement direction)
{
    this-&amp;gt;direction = direction;
}

int Boat::type() const
{
    return Type;
}

</db:programlisting>
</db:article>
