<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Move Blocks Example</db:title>
<db:productname>QtStateMachine</db:productname>
<db:edition>Qt 6.4.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt State Machine Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Move Blocks example shows how to animate items in a <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> using a <db:link xlink:href="qstatemachine.xml">QStateMachine</db:link> with a custom transition.</db:para>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/moveblocks-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The example animates the blue blocks that you can see in the image above. The animation moves the blocks between four preset positions.</db:para>
<db:para>The example consists of the following classes:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:code>StateSwitcher</db:code> inherits <db:link xlink:href="qstate.xml">QState</db:link> and can add <db:code>StateSwitchTransition</db:code>s to other states. When entered, it will randomly transition to one of these states.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>StateSwitchTransition</db:code> is a custom transition that triggers on <db:code>StateSwitchEvent</db:code>s.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>StateSwitchEvent</db:code> is a <db:link xlink:href="qevent.xml">QEvent</db:link> that triggers <db:code>StateSwitchTransition</db:code>s.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:code>QGraphicsRectWidget</db:code> is a <db:link xlink:href="qgraphicswidget.xml">QGraphicsWidget</db:link> that simply paints its background in a solid <db:link xlink:href="qt.xml#GlobalColor-enum">blue</db:link> color.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The blocks are instances of <db:code>QGraphicsRectWidget</db:code> and are animated in a <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link>. We do this by building a state graph, which we insert animations into. The graph is then executed in a <db:link xlink:href="qstatemachine.xml">QStateMachine</db:link>. All this is done in <db:code>main()</db:code>. Let's look at the <db:code>main()</db:code> function first.</db:para>
<db:section xml:id="the-main-function">
<db:title>The <db:code>main()</db:code> Function</db:title>
<db:para>After <db:link xlink:href="qapplication.xml">QApplication</db:link> has been initialized, we set up the <db:link xlink:href="qgraphicsscene.xml">QGraphicsScene</db:link> with its <db:code>QGraphicsRectWidget</db:code>s.</db:para>
<db:programlisting language="cpp">    QGraphicsRectWidget *button1 = new QGraphicsRectWidget;
    QGraphicsRectWidget *button2 = new QGraphicsRectWidget;
    QGraphicsRectWidget *button3 = new QGraphicsRectWidget;
    QGraphicsRectWidget *button4 = new QGraphicsRectWidget;
    button2-&amp;gt;setZValue(1);
    button3-&amp;gt;setZValue(2);
    button4-&amp;gt;setZValue(3);
    QGraphicsScene scene(0, 0, 300, 300);
    scene.setBackgroundBrush(Qt::black);
    scene.addItem(button1);
    scene.addItem(button2);
    scene.addItem(button3);
    scene.addItem(button4);
</db:programlisting>
<db:para>After adding the scene to a <db:link xlink:href="qgraphicsview.xml">QGraphicsView</db:link>, it is time to build the state graph. Let's first look at a statechart of what we are trying to build.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/move-blocks-chart.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Note that the <db:code>group</db:code> has seven sub states, but we have only included three of them in the diagram. The code that builds this graph will be examined line-by-line, and will show how the graph works. First off, we construct the <db:code>group</db:code> state:</db:para>
<db:programlisting language="cpp">    QStateMachine machine;

    QState *group = new QState();
    group-&amp;gt;setObjectName(&quot;group&quot;);
    QTimer timer;
    timer.setInterval(1250);
    timer.setSingleShot(true);
    QObject::connect(group, &amp;amp;QState::entered, &amp;amp;timer, QOverload&amp;lt;&amp;gt;::of(&amp;amp;QTimer::start));
</db:programlisting>
<db:para>The timer is used to add a delay between each time the blocks are moved. The timer is started when <db:code>group</db:code> is entered. As we will see later, <db:code>group</db:code> has a transition back to the <db:code>StateSwitcher</db:code> when the timer times out. <db:code>group</db:code> is the initial state in the machine, so an animation will be scheduled when the example is started.</db:para>
<db:programlisting language="cpp">    QState *state1;
    QState *state2;
    QState *state3;
    QState *state4;
    QState *state5;
    QState *state6;
    QState *state7;

    state1 = createGeometryState(button1, QRect(100, 0, 50, 50),
                                 button2, QRect(150, 0, 50, 50),
                                 button3, QRect(200, 0, 50, 50),
                                 button4, QRect(250, 0, 50, 50),
                                 group);
    ...
    state7 = createGeometryState(button1, QRect(0, 0, 50, 50),
                                 button2, QRect(250, 0, 50, 50),
                                 button3, QRect(0, 250, 50, 50),
                                 button4, QRect(250, 250, 50, 50),
                                 group);
    group-&amp;gt;setInitialState(state1);
</db:programlisting>
<db:para><db:code>createGeometryState()</db:code> returns a <db:link xlink:href="qstate.xml">QState</db:link> that will set the geometry of our items upon entry. It also assigns <db:code>group</db:code> as the parent of this state.</db:para>
<db:para>A <db:link xlink:href="qpropertyanimation.xml">QPropertyAnimation</db:link> inserted into a transition will use the values assigned to a <db:link xlink:href="qstate.xml">QState</db:link> (with <db:link xlink:href="qstate.xml#assignProperty">QState::assignProperty</db:link>()), i.e., the animation will interpolate between the current values of the properties and the values in the target state. We add animated transitions to the state graph later.</db:para>
<db:programlisting language="cpp">    QParallelAnimationGroup animationGroup;
    QSequentialAnimationGroup *subGroup;

    QPropertyAnimation *anim = new QPropertyAnimation(button4, &quot;geometry&quot;);
    anim-&amp;gt;setDuration(1000);
    anim-&amp;gt;setEasingCurve(QEasingCurve::OutElastic);
    animationGroup.addAnimation(anim);
</db:programlisting>
<db:para>We move the items in parallel. Each item is added to <db:code>animationGroup</db:code>, which is the animation that is inserted into the transitions.</db:para>
<db:programlisting language="cpp">    subGroup = new QSequentialAnimationGroup(&amp;amp;animationGroup);
    subGroup-&amp;gt;addPause(100);
    anim = new QPropertyAnimation(button3, &quot;geometry&quot;);
    anim-&amp;gt;setDuration(1000);
    anim-&amp;gt;setEasingCurve(QEasingCurve::OutElastic);
    subGroup-&amp;gt;addAnimation(anim);
</db:programlisting>
<db:para>The sequential animation group, <db:code>subGroup</db:code>, helps us insert a delay between the animation of each item.</db:para>
<db:programlisting language="cpp">    StateSwitcher *stateSwitcher = new StateSwitcher(&amp;amp;machine);
    stateSwitcher-&amp;gt;setObjectName(&quot;stateSwitcher&quot;);
    group-&amp;gt;addTransition(&amp;amp;timer, &amp;amp;QTimer::timeout, stateSwitcher);
    stateSwitcher-&amp;gt;addState(state1, &amp;amp;animationGroup);
    stateSwitcher-&amp;gt;addState(state2, &amp;amp;animationGroup);
    ...
    stateSwitcher-&amp;gt;addState(state7, &amp;amp;animationGroup);
</db:programlisting>
<db:para>A StateSwitchTransition is added to the state switcher in <db:code>StateSwitcher::addState()</db:code>. We also add the animation in this function. Since <db:link xlink:href="qpropertyanimation.xml">QPropertyAnimation</db:link> uses the values from the states, we can insert the same <db:link xlink:href="qpropertyanimation.xml">QPropertyAnimation</db:link> instance in all <db:code>StateSwitchTransition</db:code>s.</db:para>
<db:para>As mentioned previously, we add a transition to the state switcher that triggers when the timer times out.</db:para>
<db:programlisting language="cpp">    machine.addState(group);
    machine.setInitialState(group);
    machine.start();
</db:programlisting>
<db:para>Finally, we can create the state machine, add our initial state, and start execution of the state graph.</db:para>
<db:section xml:id="the-creategeometrystate-function">
<db:title>The <db:code>createGeometryState()</db:code> Function</db:title>
<db:para>In <db:code>createGeometryState()</db:code>, we set up the geometry for each graphics item.</db:para>
<db:programlisting language="cpp">QState *createGeometryState(QObject *w1, const QRect &amp;amp;rect1,
                            QObject *w2, const QRect &amp;amp;rect2,
                            QObject *w3, const QRect &amp;amp;rect3,
                            QObject *w4, const QRect &amp;amp;rect4,
                            QState *parent)
{
    QState *result = new QState(parent);
    result-&amp;gt;assignProperty(w1, &quot;geometry&quot;, rect1);
    result-&amp;gt;assignProperty(w2, &quot;geometry&quot;, rect2);
    result-&amp;gt;assignProperty(w3, &quot;geometry&quot;, rect3);
    result-&amp;gt;assignProperty(w4, &quot;geometry&quot;, rect4);

    return result;
}
</db:programlisting>
<db:para>As mentioned before, <db:link xlink:href="qml-qtqml-statemachine-qabstracttransition.xml">QAbstractTransition</db:link> will set up an animation added with <db:link xlink:href="qabstracttransition.xml#addAnimation">addAnimation</db:link>() using property values set with <db:link xlink:href="qstate.xml#assignProperty">assignProperty</db:link>().</db:para>
</db:section>
</db:section>
<db:section xml:id="the-stateswitcher-class">
<db:title>The StateSwitcher Class</db:title>
<db:para><db:code>StateSwitcher</db:code> has state switch transitions to each <db:link xlink:href="qstate.xml">QState</db:link>s we created with <db:code>createGeometryState()</db:code>. Its job is to transition to one of these states at random when it is entered.</db:para>
<db:para>All functions in <db:code>StateSwitcher</db:code> are inlined. We'll step through its definition.</db:para>
<db:programlisting language="cpp">class StateSwitcher : public QState
{
    Q_OBJECT
public:
    StateSwitcher(QStateMachine *machine)
        : QState(machine), m_stateCount(0), m_lastIndex(0)
    { }
</db:programlisting>
<db:para><db:code>StateSwitcher</db:code> is a state designed for a particular purpose and will always be a top-level state. We use <db:code>m_stateCount</db:code> to keep track of how many states we are managing, and <db:code>m_lastIndex</db:code> to remember which state was the last state to which we transitioned.</db:para>
<db:programlisting language="cpp">    void onEntry(QEvent *) override
    {
        int n;
        while ((n = QRandomGenerator::global()-&amp;gt;bounded(m_stateCount) + 1) == m_lastIndex)
        { }
        m_lastIndex = n;
        machine()-&amp;gt;postEvent(new StateSwitchEvent(n));
    }
    void onExit(QEvent *) override {}
</db:programlisting>
<db:para>We select the next state we are going to transition to, and post a <db:code>StateSwitchEvent</db:code>, which we know will trigger the <db:code>StateSwitchTransition</db:code> to the selected state.</db:para>
<db:programlisting language="cpp">    void addState(QState *state, QAbstractAnimation *animation) {
        StateSwitchTransition *trans = new StateSwitchTransition(++m_stateCount);
        trans-&amp;gt;setTargetState(state);
        addTransition(trans);
        trans-&amp;gt;addAnimation(animation);
    }
</db:programlisting>
<db:para>This is where the magic happens. We assign a number to each state added. This number is given to both a StateSwitchTransition and to StateSwitchEvents. As we have seen, state switch events will trigger a transition with the same number.</db:para>
</db:section>
<db:section xml:id="the-stateswitchtransition-class">
<db:title>The StateSwitchTransition Class</db:title>
<db:para><db:code>StateSwitchTransition</db:code> inherits <db:link xlink:href="qml-qtqml-statemachine-qabstracttransition.xml">QAbstractTransition</db:link> and triggers on <db:code>StateSwitchEvent</db:code>s. It contains only inline functions, so let's take a look at its <db:link xlink:href="qabstracttransition.xml#eventTest">eventTest</db:link>() function, which is the only function that we define..</db:para>
<db:programlisting language="cpp">    bool eventTest(QEvent *event) override
    {
        return (event-&amp;gt;type() == QEvent::Type(StateSwitchEvent::StateSwitchType))
            &amp;amp;&amp;amp; (static_cast&amp;lt;StateSwitchEvent *&amp;gt;(event)-&amp;gt;rand() == m_rand);
    }
</db:programlisting>
<db:para><db:code>eventTest</db:code> is called by <db:link xlink:href="qstatemachine.xml">QStateMachine</db:link> when it checks whether a transition should be triggeredâ€“a return value of true means that it will. We simply check if our assigned number is equal to the event's number (in which case we fire away).</db:para>
</db:section>
<db:section xml:id="the-stateswitchevent-class">
<db:title>The StateSwitchEvent Class</db:title>
<db:para><db:code>StateSwitchEvent</db:code> inherits <db:link xlink:href="qevent.xml">QEvent</db:link>, and holds a number that has been assigned to a state and state switch transition by <db:code>StateSwitcher</db:code>. We have already seen how it is used to trigger <db:code>StateSwitchTransition</db:code>s in <db:code>StateSwitcher</db:code>.</db:para>
<db:programlisting language="cpp">class StateSwitchEvent: public QEvent
{
public:
    StateSwitchEvent()
        : QEvent(Type(StateSwitchType))
    {
    }

    explicit StateSwitchEvent(int rand)
        : QEvent(Type(StateSwitchType)),
          m_rand(rand)
    {
    }

    enum { StateSwitchType = QEvent::User + 256 };

    int rand() const { return m_rand; }

private:
    int m_rand;
};
</db:programlisting>
<db:para>We only have inlined functions in this class, so a look at its definition will do.</db:para>
</db:section>
<db:section xml:id="the-qgraphicsrectwidget-class">
<db:title>The QGraphicsRectWidget Class</db:title>
<db:para>QGraphicsRectWidget inherits <db:link xlink:href="qgraphicswidget.xml">QGraphicsWidget</db:link> and simply paints its <db:link xlink:href="qwidget.xml#rect-prop">rect</db:link>() blue. We inline <db:link xlink:href="qwidget.xml#paintEvent">paintEvent</db:link>(), which is the only function we define. Here is the QGraphicsRectWidget class definition:</db:para>
<db:programlisting language="cpp">class QGraphicsRectWidget : public QGraphicsWidget
{
public:
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *,
               QWidget *) override
    {
        painter-&amp;gt;fillRect(rect(), Qt::blue);
    }
};
</db:programlisting>
</db:section>
<db:section xml:id="moving-on">
<db:title>Moving On</db:title>
<db:para>The technique shown in this example works equally well for all <db:link xlink:href="qpropertyanimation.xml">QPropertyAnimation</db:link>s. As long as the value to be animated is a Qt property, you can insert an animation of it into a state graph.</db:para>
<db:para>QState::addAnimation() takes a <db:link xlink:href="qabstractanimation.xml">QAbstractAnimation</db:link>, so any type of animation can be inserted into the graph.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtscxml.git/tree/examples/statemachine/animation/moveblocks?h=6.4">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
