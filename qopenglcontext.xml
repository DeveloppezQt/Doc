<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QOpenGLContext Class</db:title>
<db:productname>QtGui</db:productname>
<db:edition>Qt 6.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt GUI Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> class represents a native OpenGL context, enabling OpenGL rendering on a <db:link xlink:href="qsurface.xml">QSurface</db:link>.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QOpenGLContext</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Gui)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Gui)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += gui</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QOpenGLContext is part of <db:simplelist><db:member><db:link xlink:href="painting-3d.xml">Rendering in 3D</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> represents the OpenGL state of an underlying OpenGL context. To set up a context, set its screen and format such that they match those of the surface or surfaces with which the context is meant to be used, if necessary make it share resources with other contexts with <db:link xlink:href="qopenglcontext.xml#setShareContext">setShareContext</db:link>(), and finally call <db:link xlink:href="qopenglcontext.xml#create">create</db:link>(). Use the return value or <db:link xlink:href="qopenglcontext.xml#isValid">isValid</db:link>() to check if the context was successfully initialized.</db:para>
<db:para>A context can be made current against a given surface by calling <db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>(). When OpenGL rendering is done, call <db:link xlink:href="qopenglcontext.xml#swapBuffers">swapBuffers</db:link>() to swap the front and back buffers of the surface, so that the newly rendered content becomes visible. To be able to support certain platforms, <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> requires that you call <db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>() again before starting rendering a new frame, after calling <db:link xlink:href="qopenglcontext.xml#swapBuffers">swapBuffers</db:link>().</db:para>
<db:para>If the context is temporarily not needed, such as when the application is not rendering, it can be useful to delete it in order to free resources. You can connect to the <db:link xlink:href="qopenglcontext.xml#aboutToBeDestroyed">aboutToBeDestroyed</db:link>() signal to clean up any resources that have been allocated with different ownership from the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> itself.</db:para>
<db:para>Once a <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> has been made current, you can render to it in a platform independent way by using Qt's OpenGL enablers such as <db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link>, <db:link xlink:href="qopenglbuffer.xml">QOpenGLBuffer</db:link>, <db:link xlink:href="qopenglshaderprogram.xml">QOpenGLShaderProgram</db:link>, and <db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link>. It is also possible to use the platform's OpenGL API directly, without using the Qt enablers, although potentially at the cost of portability. The latter is necessary when wanting to use OpenGL 1.x or OpenGL ES 1.x.</db:para>
<db:para>For more information about the OpenGL API, refer to the official <db:link xlink:href="http://www.opengl.org">OpenGL documentation</db:link>.</db:para>
<db:para>For an example of how to use <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> see the <db:link xlink:href="qtopengl-openglwindow-example.xml">OpenGL Window</db:link> example.</db:para>
<db:section xml:id="thread-affinity">
<db:title>Thread Affinity</db:title>
<db:para><db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> can be moved to a different thread with <db:link xlink:href="qobject.xml#moveToThread">moveToThread</db:link>(). Do not call <db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>() from a different thread than the one to which the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> object belongs. A context can only be current in one thread and against one surface at a time, and a thread only has one context current at a time.</db:para>
</db:section>
<db:section xml:id="context-resource-sharing">
<db:title>Context Resource Sharing</db:title>
<db:para>Resources such as textures and vertex buffer objects can be shared between contexts. Use <db:link xlink:href="qopenglcontext.xml#setShareContext">setShareContext</db:link>() before calling <db:link xlink:href="qopenglcontext.xml#create">create</db:link>() to specify that the contexts should share these resources. <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> internally keeps track of a <db:link xlink:href="qopenglcontextgroup.xml">QOpenGLContextGroup</db:link> object which can be accessed with <db:link xlink:href="qopenglcontext.xml#shareGroup">shareGroup</db:link>(), and which can be used to find all the contexts in a given share group. A share group consists of all contexts that have been successfully initialized and are sharing with an existing context in the share group. A non-sharing context has a share group consisting of a single context.</db:para>
</db:section>
<db:section xml:id="default-framebuffer">
<db:title>Default Framebuffer</db:title>
<db:para>On certain platforms, a framebuffer other than 0 might be the default frame buffer depending on the current surface. Instead of calling glBindFramebuffer(0), it is recommended that you use glBindFramebuffer(ctx-&gt;<db:link xlink:href="qopenglcontext.xml#defaultFramebufferObject">defaultFramebufferObject</db:link>()), to ensure that your application is portable between different platforms. However, if you use <db:link xlink:href="qopenglfunctions.xml#glBindFramebuffer">QOpenGLFunctions::glBindFramebuffer</db:link>(), this is done automatically for you.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link></db:member>
<db:member><db:link xlink:href="qopenglbuffer.xml">QOpenGLBuffer</db:link></db:member>
<db:member><db:link xlink:href="qopenglshaderprogram.xml">QOpenGLShaderProgram</db:link></db:member>
<db:member><db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="OpenGLModuleType-enum">
<db:title>enum QOpenGLContext::OpenGLModuleType</db:title>
<db:enumsynopsis>
<db:enumname>OpenGLModuleType</db:enumname>
<db:enumitem>
<db:enumidentifier>LibGL</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>LibGLES</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum defines the type of the underlying OpenGL implementation.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link></db:emphasis>::LibGL</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>OpenGL</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link></db:emphasis>::LibGLES</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>OpenGL ES 2.0 or higher</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QOpenGLContext">
<db:title>[explicit] QOpenGLContext::QOpenGLContext(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QOpenGLContext</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLContext(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Creates a new OpenGL context instance with parent object <db:code role="parameter">parent</db:code>.</db:para>
<db:para>Before it can be used you need to set the proper format and call <db:link xlink:href="qopenglcontext.xml#create">create</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#create">create</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="dtor.QOpenGLContext">
<db:title>[virtual] QOpenGLContext::~QOpenGLContext()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QOpenGLContext</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QOpenGLContext()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> object.</db:para>
<db:para>If this is the current context for the thread, <db:link xlink:href="qopenglcontext.xml#doneCurrent">doneCurrent</db:link>() is also called.</db:para>
</db:section>
<db:section xml:id="aboutToBeDestroyed">
<db:title>void QOpenGLContext::aboutToBeDestroyed()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>aboutToBeDestroyed</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void aboutToBeDestroyed()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted before the underlying native OpenGL context is destroyed, such that users may clean up OpenGL resources that might otherwise be left dangling in the case of shared OpenGL contexts.</db:para>
<db:para>If you wish to make the context current in order to do clean-up, make sure to only connect to the signal using a direct connection.</db:para>
<db:note>
<db:para>In Qt for Python, this signal will not be received when emitted from the destructor of <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> or <db:link xlink:href="qopenglwindow.xml">QOpenGLWindow</db:link> due to the Python instance already being destroyed. We recommend doing cleanups in <db:link xlink:href="qwidget.xml#hideEvent">QWidget::hideEvent</db:link>() instead.</db:para>
</db:note>
</db:section>
<db:section xml:id="areSharing">
<db:title>[static] bool QOpenGLContext::areSharing(QOpenGLContext *<db:emphasis>first</db:emphasis>, QOpenGLContext *<db:emphasis>second</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>areSharing</db:methodname>
<db:methodparam>
<db:type>QOpenGLContext *</db:type>
<db:parameter>first</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QOpenGLContext *</db:type>
<db:parameter>second</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool areSharing(QOpenGLContext *first, QOpenGLContext *second)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the <db:code role="parameter">first</db:code> and <db:code role="parameter">second</db:code> contexts are sharing OpenGL resources.</db:para>
</db:section>
<db:section xml:id="create">
<db:title>bool QOpenGLContext::create()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>create</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool create()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Attempts to create the OpenGL context with the current configuration.</db:para>
<db:para>The current configuration includes the format, the share context, and the screen.</db:para>
<db:para>If the OpenGL implementation on your system does not support the requested version of OpenGL context, then <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> will try to create the closest matching version. The actual created context properties can be queried using the <db:link xlink:href="qsurfaceformat.xml">QSurfaceFormat</db:link> returned by the <db:link xlink:href="qopenglcontext.xml#format">format</db:link>() function. For example, if you request a context that supports OpenGL 4.3 Core profile but the driver and/or hardware only supports version 3.2 Core profile contexts then you will get a 3.2 Core profile context.</db:para>
<db:para>Returns <db:code>true</db:code> if the native context was successfully created and is ready to be used with <db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>(), <db:link xlink:href="qopenglcontext.xml#swapBuffers">swapBuffers</db:link>(), etc.</db:para>
<db:note>
<db:para>If the context already exists, this function destroys the existing context first, and then creates a new one.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglcontext.xml#format">format</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="currentContext">
<db:title>[static] QOpenGLContext *QOpenGLContext::currentContext()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QOpenGLContext *</db:type>
<db:methodname>currentContext</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLContext * currentContext()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the last context which called <db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link> in the current thread, or <db:code>nullptr</db:code>, if no context is current.</db:para>
</db:section>
<db:section xml:id="defaultFramebufferObject">
<db:title>GLuint QOpenGLContext::defaultFramebufferObject() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>GLuint</db:type>
<db:methodname>defaultFramebufferObject</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">GLuint defaultFramebufferObject() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Call this to get the default framebuffer object for the current surface.</db:para>
<db:para>On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0. Thus, instead of calling glBindFramebuffer(0), you should call glBindFramebuffer(ctx-&gt;defaultFramebufferObject()) if you want your application to work across different Qt platforms.</db:para>
<db:para>If you use the glBindFramebuffer() in <db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link> you do not have to worry about this, as it automatically binds the current context's defaultFramebufferObject() when 0 is passed.</db:para>
<db:note>
<db:para>Widgets that render via framebuffer objects, like <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> and <db:link xlink:href="qquickwidget.xml">QQuickWidget</db:link>, will override the value returned from this function when painting is active, because at that time the correct &quot;default&quot; framebuffer is the widget's associated backing framebuffer, not the platform-specific one belonging to the top-level window's surface. This ensures the expected behavior for this function and other classes relying on it (for example, <db:link xlink:href="qopenglframebufferobject.xml#bindDefault">QOpenGLFramebufferObject::bindDefault</db:link>() or <db:link xlink:href="qopenglframebufferobject.xml#release">QOpenGLFramebufferObject::release</db:link>()).</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglframebufferobject.xml">QOpenGLFramebufferObject</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="doneCurrent">
<db:title>void QOpenGLContext::doneCurrent()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>doneCurrent</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void doneCurrent()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Convenience function for calling <db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link> with a 0 surface.</db:para>
<db:para>This results in no context being current in the current thread.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglcontext.xml#currentContext">currentContext</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="extensions">
<db:title>QSet&lt;QByteArray&gt; QOpenGLContext::extensions() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSet&lt;QByteArray&gt;</db:type>
<db:methodname>extensions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSet&lt;QByteArray&gt; extensions() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the set of OpenGL extensions supported by this context.</db:para>
<db:para>The context or a sharing context must be current.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#hasExtension">hasExtension</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="extraFunctions">
<db:title>QOpenGLExtraFunctions *QOpenGLContext::extraFunctions() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QOpenGLExtraFunctions *</db:type>
<db:methodname>extraFunctions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLExtraFunctions * extraFunctions() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Get the <db:link xlink:href="qopenglextrafunctions.xml">QOpenGLExtraFunctions</db:link> instance for this context.</db:para>
<db:para><db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> offers this as a convenient way to access <db:link xlink:href="qopenglextrafunctions.xml">QOpenGLExtraFunctions</db:link> without having to manage it manually.</db:para>
<db:para>The context or a sharing context must be current.</db:para>
<db:para>The returned <db:link xlink:href="qopenglextrafunctions.xml">QOpenGLExtraFunctions</db:link> instance is ready to be used and it does not need initializeOpenGLFunctions() to be called.</db:para>
<db:note>
<db:para><db:link xlink:href="qopenglextrafunctions.xml">QOpenGLExtraFunctions</db:link> contains functionality that is not guaranteed to be available at runtime. Runtime availability depends on the platform, graphics driver, and the OpenGL version requested by the application.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link></db:member>
<db:member><db:link xlink:href="qopenglextrafunctions.xml">QOpenGLExtraFunctions</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="format">
<db:title>QSurfaceFormat QOpenGLContext::format() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSurfaceFormat</db:type>
<db:methodname>format</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSurfaceFormat format() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the format of the underlying platform context, if <db:link xlink:href="qopenglcontext.xml#create">create</db:link>() has been called.</db:para>
<db:para>Otherwise, returns the requested format.</db:para>
<db:para>The requested and the actual format may differ. Requesting a given OpenGL version does not mean the resulting context will target exactly the requested version. It is only guaranteed that the version/profile/options combination for the created context is compatible with the request, as long as the driver is able to provide such a context.</db:para>
<db:para>For example, requesting an OpenGL version 3.x core profile context may result in an OpenGL 4.x core profile context. Similarly, a request for OpenGL 2.1 may result in an OpenGL 3.0 context with deprecated functions enabled. Finally, depending on the driver, unsupported versions may result in either a context creation failure or in a context for the highest supported version.</db:para>
<db:para>Similar differences are possible in the buffer sizes, for example, the resulting context may have a larger depth buffer than requested. This is perfectly normal.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#setFormat">setFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="functions">
<db:title>QOpenGLFunctions *QOpenGLContext::functions() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QOpenGLFunctions *</db:type>
<db:methodname>functions</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLFunctions * functions() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Get the <db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link> instance for this context.</db:para>
<db:para><db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> offers this as a convenient way to access <db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link> without having to manage it manually.</db:para>
<db:para>The context or a sharing context must be current.</db:para>
<db:para>The returned <db:link xlink:href="qopenglfunctions.xml">QOpenGLFunctions</db:link> instance is ready to be used and it does not need initializeOpenGLFunctions() to be called.</db:para>
</db:section>
<db:section xml:id="getProcAddress">
<db:title>QFunctionPointer QOpenGLContext::getProcAddress(const QByteArray &amp;<db:emphasis>procName</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFunctionPointer</db:type>
<db:methodname>getProcAddress</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>procName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFunctionPointer getProcAddress(const QByteArray &amp;procName) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Resolves the function pointer to an OpenGL extension function, identified by <db:code role="parameter">procName</db:code></db:para>
<db:para>Returns <db:code>nullptr</db:code> if no such function can be found.</db:para>
</db:section>
<db:section xml:id="getProcAddress-1">
<db:title>QFunctionPointer QOpenGLContext::getProcAddress(const char *<db:emphasis>procName</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QFunctionPointer</db:type>
<db:methodname>getProcAddress</db:methodname>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>procName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFunctionPointer getProcAddress(const char *procName) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
</db:section>
<db:section xml:id="globalShareContext">
<db:title>[static] QOpenGLContext *QOpenGLContext::globalShareContext()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QOpenGLContext *</db:type>
<db:methodname>globalShareContext</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLContext * globalShareContext()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the application-wide shared OpenGL context, if present. Otherwise, returns <db:code>nullptr</db:code>.</db:para>
<db:para>This is useful if you need to upload OpenGL objects (buffers, textures, etc.) before creating or showing a <db:link xlink:href="qopenglwidget.xml">QOpenGLWidget</db:link> or <db:link xlink:href="qquickwidget.xml">QQuickWidget</db:link>.</db:para>
<db:note>
<db:para>You must set the <db:link xlink:href="qt.xml#ApplicationAttribute-enum">Qt::AA_ShareOpenGLContexts</db:link> flag on <db:link xlink:href="qguiapplication.xml">QGuiApplication</db:link> before creating the <db:link xlink:href="qguiapplication.xml">QGuiApplication</db:link> object, otherwise Qt may not create a global shared context.</db:para>
</db:note>
<db:warning>
<db:para>Do not attempt to make the context returned by this function current on any surface. Instead, you can create a new context which shares with the global one, and then make the new context current.</db:para>
</db:warning>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qt.xml#ApplicationAttribute-enum">Qt::AA_ShareOpenGLContexts</db:link></db:member>
<db:member><db:link xlink:href="qopenglcontext.xml#setShareContext">setShareContext</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasExtension">
<db:title>bool QOpenGLContext::hasExtension(const QByteArray &amp;<db:emphasis>extension</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasExtension</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>extension</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasExtension(const QByteArray &amp;extension) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if this OpenGL context supports the specified OpenGL <db:code role="parameter">extension</db:code>, <db:code>false</db:code> otherwise.</db:para>
<db:para>The context or a sharing context must be current.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#extensions">extensions</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isOpenGLES">
<db:title>bool QOpenGLContext::isOpenGLES() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isOpenGLES</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isOpenGLES() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the context is an OpenGL ES context.</db:para>
<db:para>If the context has not yet been created, the result is based on the requested format set via <db:link xlink:href="qopenglcontext.xml#setFormat">setFormat</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#create">create</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglcontext.xml#format">format</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglcontext.xml#setFormat">setFormat</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isValid">
<db:title>bool QOpenGLContext::isValid() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isValid</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isValid() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns if this context is valid, i.e. has been successfully created.</db:para>
<db:para>On some platforms the return value of <db:code>false</db:code> for a context that was successfully created previously indicates that the OpenGL context was lost.</db:para>
<db:para>The typical way to handle context loss scenarios in applications is to check via this function whenever <db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>() fails and returns <db:code>false</db:code>. If this function then returns <db:code>false</db:code>, recreate the underlying native OpenGL context by calling <db:link xlink:href="qopenglcontext.xml#create">create</db:link>(), call <db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>() again and then reinitialize all OpenGL resources.</db:para>
<db:para>On some platforms context loss situations is not something that can avoided. On others however, they may need to be opted-in to. This can be done by enabling <db:link xlink:href="qsurfaceformat.xml#FormatOption-enum">ResetNotification</db:link> in the <db:link xlink:href="qsurfaceformat.xml">QSurfaceFormat</db:link>. This will lead to setting <db:code>RESET_NOTIFICATION_STRATEGY_EXT</db:code> to <db:code>LOSE_CONTEXT_ON_RESET_EXT</db:code> in the underlying native OpenGL context. <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> will then monitor the status via <db:code>glGetGraphicsResetStatusEXT()</db:code> in every <db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#create">create</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeCurrent">
<db:title>bool QOpenGLContext::makeCurrent(QSurface *<db:emphasis>surface</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>makeCurrent</db:methodname>
<db:methodparam>
<db:type>QSurface *</db:type>
<db:parameter>surface</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool makeCurrent(QSurface *surface)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Makes the context current in the current thread, against the given <db:code role="parameter">surface</db:code>. Returns <db:code>true</db:code> if successful; otherwise returns <db:code>false</db:code>. The latter may happen if the surface is not exposed, or the graphics hardware is not available due to e.g. the application being suspended.</db:para>
<db:para>If <db:code role="parameter">surface</db:code> is <db:code>nullptr</db:code> this is equivalent to calling <db:link xlink:href="qopenglcontext.xml#doneCurrent">doneCurrent</db:link>().</db:para>
<db:para>Avoid calling this function from a different thread than the one the <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> instance lives in. If you wish to use <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link> from a different thread you should first make sure it's not current in the current thread, by calling <db:link xlink:href="qopenglcontext.xml#doneCurrent">doneCurrent</db:link>() if necessary. Then call moveToThread(otherThread) before using it in the other thread.</db:para>
<db:para>By default Qt employs a check that enforces the above condition on the thread affinity. It is still possible to disable this check by setting the <db:code>Qt::AA_DontCheckOpenGLContextThreadAffinity</db:code> application attribute. Be sure to understand the consequences of using QObjects from outside the thread they live in, as explained in the <db:link xlink:href="qobject.xml#thread-affinity">QObject thread affinity</db:link> documentation.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#functions">functions</db:link>()</db:member>
<db:member><db:link xlink:href="qopenglcontext.xml#doneCurrent">doneCurrent</db:link>()</db:member>
<db:member><db:link xlink:href="qt.xml#ApplicationAttribute-enum">Qt::AA_DontCheckOpenGLContextThreadAffinity</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="nativeInterface">
<db:title>QNativeInterface *QOpenGLContext::nativeInterface() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNativeInterface *</db:type>
<db:methodname>nativeInterface</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNativeInterface * nativeInterface() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a native interface of the given type for the context.</db:para>
<db:para>This function provides access to platform specific functionality of <db:link xlink:href="qopenglcontext.xml">QOpenGLContext</db:link>, as defined in the <db:link xlink:href="qnativeinterface-sub-qtgui.xml">QNativeInterface</db:link> namespace:</db:para>
<db:variablelist role="native-interfaces-qopenglcontext">
<db:varlistentry>
<db:term><db:link xlink:href="qnativeinterface-qcocoaglcontext.xml" xlink:role="class">QNativeInterface::QCocoaGLContext</db:link></db:term>
<db:listitem>
<db:para>Native interface to an NSOpenGLContext on macOS.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qnativeinterface-qeglcontext.xml" xlink:role="class">QNativeInterface::QEGLContext</db:link></db:term>
<db:listitem>
<db:para>Native interface to an EGL context.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qnativeinterface-qglxcontext.xml" xlink:role="class">QNativeInterface::QGLXContext</db:link></db:term>
<db:listitem>
<db:para>Native interface to a GLX context.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qnativeinterface-qwglcontext.xml" xlink:role="class">QNativeInterface::QWGLContext</db:link></db:term>
<db:listitem>
<db:para>Native interface to a WGL context on Windows.</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:para>If the requested interface is not available a <db:code>nullptr</db:code> is returned.</db:para>
</db:section>
<db:section xml:id="openGLModuleType">
<db:title>[static] QOpenGLContext::OpenGLModuleType QOpenGLContext::openGLModuleType()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QOpenGLContext::OpenGLModuleType</db:type>
<db:methodname>openGLModuleType</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLContext::OpenGLModuleType openGLModuleType()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the underlying OpenGL implementation type.</db:para>
<db:para>On platforms where the OpenGL implementation is not dynamically loaded, the return value is determined during compile time and never changes.</db:para>
<db:note>
<db:para>A desktop OpenGL implementation may be capable of creating ES-compatible contexts too. Therefore in most cases it is more appropriate to check <db:link xlink:href="qsurfaceformat.xml#renderableType">QSurfaceFormat::renderableType</db:link>() or use the convenience function <db:link xlink:href="qopenglcontext.xml#isOpenGLES">isOpenGLES</db:link>().</db:para>
</db:note>
<db:note>
<db:para>This function requires that the <db:link xlink:href="qguiapplication.xml">QGuiApplication</db:link> instance is already created.</db:para>
</db:note>
</db:section>
<db:section xml:id="screen">
<db:title>QScreen *QOpenGLContext::screen() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QScreen *</db:type>
<db:methodname>screen</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QScreen * screen() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the screen the context was created for.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#setScreen">setScreen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setFormat">
<db:title>void QOpenGLContext::setFormat(const QSurfaceFormat &amp;<db:emphasis>format</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setFormat</db:methodname>
<db:methodparam>
<db:type>const QSurfaceFormat &amp;</db:type>
<db:parameter>format</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setFormat(const QSurfaceFormat &amp;format)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the <db:code role="parameter">format</db:code> the OpenGL context should be compatible with. You need to call <db:link xlink:href="qopenglcontext.xml#create">create</db:link>() before it takes effect.</db:para>
<db:para>When the format is not explicitly set via this function, the format returned by <db:link xlink:href="qsurfaceformat.xml#defaultFormat">QSurfaceFormat::defaultFormat</db:link>() will be used. This means that when having multiple contexts, individual calls to this function can be replaced by one single call to <db:link xlink:href="qsurfaceformat.xml#setDefaultFormat">QSurfaceFormat::setDefaultFormat</db:link>() before creating the first context.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#format">format</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setScreen">
<db:title>void QOpenGLContext::setScreen(QScreen *<db:emphasis>screen</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setScreen</db:methodname>
<db:methodparam>
<db:type>QScreen *</db:type>
<db:parameter>screen</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setScreen(QScreen *screen)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the <db:code role="parameter">screen</db:code> the OpenGL context should be valid for. You need to call <db:link xlink:href="qopenglcontext.xml#create">create</db:link>() before it takes effect.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#screen">screen</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setShareContext">
<db:title>void QOpenGLContext::setShareContext(QOpenGLContext *<db:emphasis>shareContext</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setShareContext</db:methodname>
<db:methodparam>
<db:type>QOpenGLContext *</db:type>
<db:parameter>shareContext</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setShareContext(QOpenGLContext *shareContext)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Makes this context share textures, shaders, and other OpenGL resources with <db:code role="parameter">shareContext</db:code>. You need to call <db:link xlink:href="qopenglcontext.xml#create">create</db:link>() before it takes effect.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#shareContext">shareContext</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="shareContext">
<db:title>QOpenGLContext *QOpenGLContext::shareContext() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QOpenGLContext *</db:type>
<db:methodname>shareContext</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLContext * shareContext() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the share context this context was created with.</db:para>
<db:para>If the underlying platform was not able to support the requested sharing, this will return 0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qopenglcontext.xml#setShareContext">setShareContext</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="shareGroup">
<db:title>QOpenGLContextGroup *QOpenGLContext::shareGroup() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QOpenGLContextGroup *</db:type>
<db:methodname>shareGroup</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QOpenGLContextGroup * shareGroup() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the share group this context belongs to.</db:para>
</db:section>
<db:section xml:id="supportsThreadedOpenGL">
<db:title>[static] bool QOpenGLContext::supportsThreadedOpenGL()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>bool</db:type>
<db:methodname>supportsThreadedOpenGL</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool supportsThreadedOpenGL()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the platform supports OpenGL rendering outside the main (gui) thread.</db:para>
<db:para>The value is controlled by the platform plugin in use and may also depend on the graphics drivers.</db:para>
</db:section>
<db:section xml:id="surface">
<db:title>QSurface *QOpenGLContext::surface() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QSurface *</db:type>
<db:methodname>surface</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QSurface * surface() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the surface the context has been made current with.</db:para>
<db:para>This is the surface passed as an argument to <db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>().</db:para>
</db:section>
<db:section xml:id="swapBuffers">
<db:title>void QOpenGLContext::swapBuffers(QSurface *<db:emphasis>surface</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swapBuffers</db:methodname>
<db:methodparam>
<db:type>QSurface *</db:type>
<db:parameter>surface</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swapBuffers(QSurface *surface)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swap the back and front buffers of <db:code role="parameter">surface</db:code>.</db:para>
<db:para>Call this to finish a frame of OpenGL rendering, and make sure to call <db:link xlink:href="qopenglcontext.xml#makeCurrent">makeCurrent</db:link>() again before issuing any further OpenGL commands, for example as part of a new frame.</db:para>
</db:section>
</db:section>
</db:article>
