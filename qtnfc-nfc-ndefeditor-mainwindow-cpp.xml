<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>NDEF Editor Example</db:title>
<db:productname>QtNfc</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt NFC Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>An example about reading and writing NFC Data Exchange Format (NDEF) messages to NFC Forum Tags.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2017 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the QtNfc module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** &quot;Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;

#include &quot;textrecordeditor.h&quot;
#include &quot;urirecordeditor.h&quot;
#include &quot;mimeimagerecordeditor.h&quot;

#include &amp;lt;QtNfc/qndefnfcurirecord.h&amp;gt;
#include &amp;lt;QtNfc/qndefnfctextrecord.h&amp;gt;
#include &amp;lt;QtNfc/qndefrecord.h&amp;gt;
#include &amp;lt;QtNfc/qndefmessage.h&amp;gt;
#include &amp;lt;QtNfc/qnearfieldmanager.h&amp;gt;
#include &amp;lt;QtNfc/qnearfieldtarget.h&amp;gt;

#include &amp;lt;QtWidgets/QMenu&amp;gt;
#include &amp;lt;QtWidgets/QVBoxLayout&amp;gt;
#include &amp;lt;QtWidgets/QFrame&amp;gt;
#include &amp;lt;QtWidgets/QLabel&amp;gt;
#include &amp;lt;QtWidgets/QFileDialog&amp;gt;

class EmptyRecordLabel : public QLabel
{
    Q_OBJECT

public:
    EmptyRecordLabel() : QLabel(tr(&quot;Empty Record&quot;)) { }
    ~EmptyRecordLabel() { }

    void setRecord(const QNdefRecord &amp;amp;record)
    {
        Q_UNUSED(record);
    }

    QNdefRecord record() const
    {
        return QNdefRecord();
    }
};

class UnknownRecordLabel : public QLabel
{
    Q_OBJECT

public:
    UnknownRecordLabel() : QLabel(tr(&quot;Unknown Record Type&quot;)) { }
    ~UnknownRecordLabel() { }

    void setRecord(const QNdefRecord &amp;amp;record) { m_record = record; }
    QNdefRecord record() const { return m_record; }

private:
    QNdefRecord m_record;
};

template &amp;lt;typename T&amp;gt;
void addRecord(Ui::MainWindow *ui, const QNdefRecord &amp;amp;record = QNdefRecord())
{
    QVBoxLayout *vbox = qobject_cast&amp;lt;QVBoxLayout *&amp;gt;(ui-&amp;gt;scrollAreaWidgetContents-&amp;gt;layout());
    if (!vbox)
        return;

    if (!vbox-&amp;gt;isEmpty()) {
        QFrame *hline = new QFrame;
        hline-&amp;gt;setFrameShape(QFrame::HLine);
        hline-&amp;gt;setObjectName(QStringLiteral(&quot;line-spacer&quot;));

        vbox-&amp;gt;addWidget(hline);
    }

    T *recordEditor = new T;
    recordEditor-&amp;gt;setObjectName(QStringLiteral(&quot;record-editor&quot;));

    if (!record.isEmpty())
        recordEditor-&amp;gt;setRecord(record);

    vbox-&amp;gt;addWidget(recordEditor);
}

MainWindow::MainWindow(QWidget *parent)
:   QMainWindow(parent), ui(new Ui::MainWindow), m_touchAction(NoAction)
{
    ui-&amp;gt;setupUi(this);

    QMenu *addRecordMenu = new QMenu(this);
    addRecordMenu-&amp;gt;addAction(tr(&quot;NFC Text Record&quot;), this, SLOT(addNfcTextRecord()));
    addRecordMenu-&amp;gt;addAction(tr(&quot;NFC URI Record&quot;), this, SLOT(addNfcUriRecord()));
    addRecordMenu-&amp;gt;addAction(tr(&quot;MIME Image Record&quot;), this, SLOT(addMimeImageRecord()));
    addRecordMenu-&amp;gt;addAction(tr(&quot;Empty Record&quot;), this, SLOT(addEmptyRecord()));
    ui-&amp;gt;addRecord-&amp;gt;setMenu(addRecordMenu);

    QVBoxLayout *vbox = new QVBoxLayout;
    ui-&amp;gt;scrollAreaWidgetContents-&amp;gt;setLayout(vbox);

    m_manager = new QNearFieldManager(this);
    connect(m_manager, &amp;amp;QNearFieldManager::targetDetected,
            this, &amp;amp;MainWindow::targetDetected);
    connect(m_manager, &amp;amp;QNearFieldManager::targetLost,
            this, &amp;amp;MainWindow::targetLost);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::addNfcTextRecord()
{
    addRecord&amp;lt;TextRecordEditor&amp;gt;(ui);
}

void MainWindow::addNfcUriRecord()
{
    addRecord&amp;lt;UriRecordEditor&amp;gt;(ui);
}

void MainWindow::addMimeImageRecord()
{
    addRecord&amp;lt;MimeImageRecordEditor&amp;gt;(ui);
}

void MainWindow::addEmptyRecord()
{
    addRecord&amp;lt;EmptyRecordLabel&amp;gt;(ui);
}

void MainWindow::loadMessage()
{
    QString filename = QFileDialog::getOpenFileName(this, tr(&quot;Select NDEF Message&quot;));
    if (filename.isEmpty())
        return;

    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly))
        return;

    QByteArray ndef = file.readAll();

    ndefMessageRead(QNdefMessage::fromByteArray(ndef));

    file.close();
}

void MainWindow::saveMessage()
{
    QString filename = QFileDialog::getSaveFileName(this, tr(&quot;Select NDEF Message&quot;));
    if (filename.isEmpty())
        return;

    QFile file(filename);
    if (!file.open(QIODevice::WriteOnly))
        return;

    file.write(ndefMessage().toByteArray());

    file.close();
}

void MainWindow::touchReceive()
{
    ui-&amp;gt;status-&amp;gt;setStyleSheet(QStringLiteral(&quot;background: blue&quot;));

    m_touchAction = ReadNdef;

    m_manager-&amp;gt;setTargetAccessModes(QNearFieldManager::NdefReadTargetAccess);
    m_manager-&amp;gt;startTargetDetection();
}

void MainWindow::touchStore()
{
    ui-&amp;gt;status-&amp;gt;setStyleSheet(QStringLiteral(&quot;background: yellow&quot;));

    m_touchAction = WriteNdef;

    m_manager-&amp;gt;setTargetAccessModes(QNearFieldManager::NdefWriteTargetAccess);
    m_manager-&amp;gt;startTargetDetection();
}

void MainWindow::targetDetected(QNearFieldTarget *target)
{
    switch (m_touchAction) {
    case NoAction:
        break;
    case ReadNdef:
        connect(target, &amp;amp;QNearFieldTarget::ndefMessageRead, this, &amp;amp;MainWindow::ndefMessageRead);
        connect(target, &amp;amp;QNearFieldTarget::error, this, &amp;amp;MainWindow::targetError);

        m_request = target-&amp;gt;readNdefMessages();
        if (!m_request.isValid()) // cannot read messages
            targetError(QNearFieldTarget::NdefReadError, m_request);
        break;
    case WriteNdef:
        connect(target, &amp;amp;QNearFieldTarget::ndefMessagesWritten, this, &amp;amp;MainWindow::ndefMessageWritten);
        connect(target, &amp;amp;QNearFieldTarget::error, this, &amp;amp;MainWindow::targetError);

        m_request = target-&amp;gt;writeNdefMessages(QList&amp;lt;QNdefMessage&amp;gt;() &amp;lt;&amp;lt; ndefMessage());
        if (!m_request.isValid()) // cannot write messages
            targetError(QNearFieldTarget::NdefWriteError, m_request);
        break;
    }
}

void MainWindow::targetLost(QNearFieldTarget *target)
{
    target-&amp;gt;deleteLater();
}

void MainWindow::ndefMessageRead(const QNdefMessage &amp;amp;message)
{
    clearMessage();

    for (const QNdefRecord &amp;amp;record : message) {
        if (record.isRecordType&amp;lt;QNdefNfcTextRecord&amp;gt;()) {
            addRecord&amp;lt;TextRecordEditor&amp;gt;(ui, record);
        } else if (record.isRecordType&amp;lt;QNdefNfcUriRecord&amp;gt;()) {
            addRecord&amp;lt;UriRecordEditor&amp;gt;(ui, record);
        } else if (record.typeNameFormat() == QNdefRecord::Mime &amp;amp;&amp;amp;
                   record.type().startsWith(&quot;image/&quot;)) {
            addRecord&amp;lt;MimeImageRecordEditor&amp;gt;(ui, record);
        } else if (record.isEmpty()) {
            addRecord&amp;lt;EmptyRecordLabel&amp;gt;(ui);
        } else {
            addRecord&amp;lt;UnknownRecordLabel&amp;gt;(ui, record);
        }
    }

    ui-&amp;gt;status-&amp;gt;setStyleSheet(QString());
    m_manager-&amp;gt;setTargetAccessModes(QNearFieldManager::NoTargetAccess);
    m_manager-&amp;gt;stopTargetDetection();
    m_request = QNearFieldTarget::RequestId();
    ui-&amp;gt;statusBar-&amp;gt;clearMessage();
}

void MainWindow::ndefMessageWritten()
{
    ui-&amp;gt;status-&amp;gt;setStyleSheet(QString());
    m_manager-&amp;gt;setTargetAccessModes(QNearFieldManager::NoTargetAccess);
    m_manager-&amp;gt;stopTargetDetection();
    m_request = QNearFieldTarget::RequestId();
    ui-&amp;gt;statusBar-&amp;gt;clearMessage();
}

void MainWindow::targetError(QNearFieldTarget::Error error, const QNearFieldTarget::RequestId &amp;amp;id)
{
    Q_UNUSED(error);
    Q_UNUSED(id);

    if (m_request == id) {
        switch (error) {
        case QNearFieldTarget::NoError:
            ui-&amp;gt;statusBar-&amp;gt;clearMessage();
            break;
        case QNearFieldTarget::UnsupportedError:
            ui-&amp;gt;statusBar-&amp;gt;showMessage(tr(&quot;Unsupported tag&quot;));
            break;
        case QNearFieldTarget::TargetOutOfRangeError:
            ui-&amp;gt;statusBar-&amp;gt;showMessage(tr(&quot;Tag removed from field&quot;));
            break;
        case QNearFieldTarget::NoResponseError:
            ui-&amp;gt;statusBar-&amp;gt;showMessage(tr(&quot;No response from tag&quot;));
            break;
        case QNearFieldTarget::ChecksumMismatchError:
            ui-&amp;gt;statusBar-&amp;gt;showMessage(tr(&quot;Checksum mismatch&quot;));
            break;
        case QNearFieldTarget::InvalidParametersError:
            ui-&amp;gt;statusBar-&amp;gt;showMessage(tr(&quot;Invalid parameters&quot;));
            break;
        case QNearFieldTarget::NdefReadError:
            ui-&amp;gt;statusBar-&amp;gt;showMessage(tr(&quot;NDEF read error&quot;));
            break;
        case QNearFieldTarget::NdefWriteError:
            ui-&amp;gt;statusBar-&amp;gt;showMessage(tr(&quot;NDEF write error&quot;));
            break;
        default:
            ui-&amp;gt;statusBar-&amp;gt;showMessage(tr(&quot;Unknown error&quot;));
        }

        ui-&amp;gt;status-&amp;gt;setStyleSheet(QString());
        m_manager-&amp;gt;setTargetAccessModes(QNearFieldManager::NoTargetAccess);
        m_manager-&amp;gt;stopTargetDetection();
        m_request = QNearFieldTarget::RequestId();
    }
}

void MainWindow::clearMessage()
{
    QWidget *scrollArea = ui-&amp;gt;scrollAreaWidgetContents;

    qDeleteAll(scrollArea-&amp;gt;findChildren&amp;lt;QWidget *&amp;gt;(QStringLiteral(&quot;line-spacer&quot;)));
    qDeleteAll(scrollArea-&amp;gt;findChildren&amp;lt;QWidget *&amp;gt;(QStringLiteral(&quot;record-editor&quot;)));
}

QNdefMessage MainWindow::ndefMessage() const
{
    QVBoxLayout *vbox = qobject_cast&amp;lt;QVBoxLayout *&amp;gt;(ui-&amp;gt;scrollAreaWidgetContents-&amp;gt;layout());
    if (!vbox)
        return QNdefMessage();

    QNdefMessage message;

    for (int i = 0; i &amp;lt; vbox-&amp;gt;count(); ++i) {
        QWidget *widget = vbox-&amp;gt;itemAt(i)-&amp;gt;widget();

        if (TextRecordEditor *editor = qobject_cast&amp;lt;TextRecordEditor *&amp;gt;(widget)) {
            message.append(editor-&amp;gt;record());
        } else if (UriRecordEditor *editor = qobject_cast&amp;lt;UriRecordEditor *&amp;gt;(widget)) {
            message.append(editor-&amp;gt;record());
        } else if (MimeImageRecordEditor *editor = qobject_cast&amp;lt;MimeImageRecordEditor *&amp;gt;(widget)) {
            message.append(editor-&amp;gt;record());
        } else if (qobject_cast&amp;lt;EmptyRecordLabel *&amp;gt;(widget)) {
            message.append(QNdefRecord());
        } else if (UnknownRecordLabel *label = qobject_cast&amp;lt;UnknownRecordLabel *&amp;gt;(widget)) {
            message.append(label-&amp;gt;record());
        }
    }

    return message;
}

#include &quot;mainwindow.moc&quot;

</db:programlisting>
</db:article>
