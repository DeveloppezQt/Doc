<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QSpan Class</db:title>
<db:subtitle>template &lt;typename T, std::size_t E = std::size_t(-1)&gt; class QSpan</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.9.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A non-owning container over contiguous data.</db:para>
<db:para>This class was introduced in Qt 6.7.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QSpan</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 6.7</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QSpan is part of <db:simplelist><db:member>tools</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A <db:link xlink:href="qspan.xml">QSpan</db:link> references a contiguous portion of another contiguous container. It acts as an interface type for all kinds of contiguous containers, without the need to construct an owning container such as <db:link xlink:href="qlist.xml">QList</db:link> or std::vector first.</db:para>
<db:para>The data referenced by a <db:link xlink:href="qspan.xml">QSpan</db:link> may be represented as an array (or array-compatible data-structure such as <db:link xlink:href="qlist.xml">QList</db:link>, std::vector, <db:link xlink:href="qvarlengtharray.xml">QVarLengthArray</db:link>, etc.). <db:link xlink:href="qspan.xml">QSpan</db:link> itself merely stores a pointer to the data, so users must ensure that <db:link xlink:href="qspan.xml">QSpan</db:link> objects do not outlive the data they reference.</db:para>
<db:para>Unlike views such as <db:link xlink:href="qstringview.xml">QStringView</db:link>, <db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link> and <db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link>, referenced data can be modified through a <db:link xlink:href="qspan.xml">QSpan</db:link> object. To prevent this, construct a <db:link xlink:href="qspan.xml">QSpan</db:link> over a const T (see <db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link>):</db:para>
<db:programlisting language="cpp">int numbers[] = {0, 1, 2};
QSpan&lt;int&gt; span = numbers;
span[0] = 42;
// numbers == {42, 1, 2};
QSpan&lt;const int&gt; cspan = numbers;
cspan[0] = 0; // ERROR: cspan[0] is read-only
</db:programlisting>
<db:anchor xml:id="variable-fixed-spans"/>
<db:section xml:id="variable-size-and-fixed-size-spans">
<db:title>Variable-Size and Fixed-Size Spans</db:title>
<db:para>A <db:link xlink:href="qspan.xml">QSpan</db:link> can be <db:emphasis>fixed-size</db:emphasis> or <db:emphasis>variable-sized</db:emphasis>.</db:para>
<db:para>A variable-sized span is formed by omitting the second template argument (or setting it to std::dynamic_extent, which is, however, only available in C++20 builds), as seen in the example above.</db:para>
<db:para>A fixed-size span is formed by passing a number as the second template argument:</db:para>
<db:programlisting language="cpp">int numbers[] = {0, 1, 2};
QSpan&lt;int, 3&gt; span = numbers;
QSpan&lt;const int, 3&gt; = numbers; // also OK
</db:programlisting>
<db:para>As the name suggests, a fixed-size span's <db:link xlink:href="qspan.xml#size">size</db:link>() is fixed at compile-time whereas the <db:link xlink:href="qspan.xml#size">size</db:link>() of a variable-sized span is determined only at run-time.</db:para>
<db:para>A fixed-size span is not default-constructible (unless its <db:link xlink:href="qspan.xml#extent-var">extent</db:link> is zero (0)). A variable-sized span <db:emphasis>is</db:emphasis> default-constructible and will have data() == nullptr and size() == 0.</db:para>
<db:para>A fixed-size span can be implicitly converted into a variable-sized one. The opposite direction (variable-length into fixed-length) has the precondition that both span's sizes must match.</db:para>
<db:anchor xml:id="const-mutable-spans"/>
</db:section>
<db:section xml:id="const-and-mutable-spans">
<db:title>Const and Mutable Spans</db:title>
<db:para>Unlike with owning containers, const is <db:emphasis>shallow</db:emphasis> in <db:link xlink:href="qspan.xml">QSpan</db:link>: you can still modify the data through a const <db:link xlink:href="qspan.xml">QSpan</db:link> (but not through a QSpan&lt;const T&gt;), and <db:link xlink:href="qspan.xml#begin">begin</db:link>() and <db:link xlink:href="qspan.xml#end">end</db:link>() are not overloaded on const/non-const. There are <db:link xlink:href="qspan.xml#cbegin">cbegin</db:link>() and <db:link xlink:href="qspan.xml#cend">cend</db:link>(), though, that return const_iterators which prevent modification of the data even though T is not const:</db:para>
<db:programlisting language="cpp">int numbers[] = {0, 1, 2};
const QSpan&lt;int&gt; span = numbers;
span.front() = 42;   // OK, numbers[0] == 42 now
*span.begin() = 31;  // OK, numbers[0] == 31 now
*span.cbegin() = -1; // ERROR: cannot assign through a const_iterator
</db:programlisting>
<db:anchor xml:id="other-span-properties"/>
</db:section>
<db:section xml:id="other-properties">
<db:title>Other Properties</db:title>
<db:para><db:link xlink:href="qspan.xml">QSpan</db:link> should be passed by value, not by reference-to-const:</db:para>
<db:programlisting language="cpp">void consume(QSpan&lt;const int&gt; data); // OK
void consume(const QSpan&lt;const int&gt; &amp;data); // works, but is non-idiomatic and less efficient
</db:programlisting>
<db:para>QSpan&lt;T,N&gt; is a <db:emphasis>Literal Type</db:emphasis>, regardless of whether T is a Literal Type or not.</db:para>
<db:anchor xml:id="span-stl"/>
</db:section>
<db:section xml:id="qspan-vs-std-span">
<db:title>QSpan vs. std::span</db:title>
<db:para><db:link xlink:href="qspan.xml">QSpan</db:link> is closely modelled after <db:link xlink:href="https://en.cppreference.com/w/cpp/container/span">std::span</db:link>, but has a few differences which we'll discuss here. Since they both implicitly convert into each other, you're free to choose whichever one you like best in your own code.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qspan.xml">QSpan</db:link> is using the signed qsizetype as size_type whereas std::span uses size_t.</db:para>
</db:listitem>
<db:listitem>
<db:para>(since Qt 6.9) QSpan&lt;const T&gt; doesn't detach Qt containers, std::span does.</db:para>
</db:listitem>
<db:listitem>
<db:para>All <db:link xlink:href="qspan.xml">QSpan</db:link> constructors are implicit; many std::span ones are explicit.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qspan.xml">QSpan</db:link> can be constructed from rvalue owning containers, std::span can not.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The last two are required for source-compatibility when functions that took owning containers are converted to take <db:link xlink:href="qspan.xml">QSpan</db:link> instead, which is a vitally-important use-case in Qt. The use of qsizetype is for consistency with the rest of Qt containers. <db:link xlink:href="qspan.xml">QSpan</db:link> template arguments still use size_t to avoid introducing unnecessary error conditions (negative sizes).</db:para>
<db:anchor xml:id="span-compatible-iterators"/>
</db:section>
<db:section xml:id="compatible-iterators">
<db:title>Compatible Iterators</db:title>
<db:para><db:link xlink:href="qspan.xml">QSpan</db:link> can be constructed from an iterator and size or from an iterator pair, provided the iterators are <db:emphasis>compatible</db:emphasis> ones. Eventually, this should mean C++20 std::contiguous_iterator and std::sentinel_for, but while Qt still supports C++17, only raw pointers are considered contiguous iterators.</db:para>
<db:anchor xml:id="span-compatible-ranges"/>
</db:section>
<db:section xml:id="compatible-ranges">
<db:title>Compatible Ranges</db:title>
<db:para><db:link xlink:href="qspan.xml">QSpan</db:link> can also be constructed from a <db:emphasis>compatible</db:emphasis> range. A range is compatible if it has <db:link xlink:href="qspan.xml#compatible-iterators">compatible iterators</db:link>.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml">QList</db:link></db:member>
<db:member><db:link xlink:href="qstringview.xml">QStringView</db:link></db:member>
<db:member><db:link xlink:href="qlatin1stringview.xml">QLatin1StringView</db:link></db:member>
<db:member><db:link xlink:href="qutf8stringview.xml">QUtf8StringView</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="const_iterator-typedef">
<db:title>[alias] QSpan::const_iterator</db:title>
<db:para>An alias for const T* and const_pointer, respectively.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#const_pointer-typedef">const_pointer</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#iterator-typedef">iterator</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const_reverse_iterator-typedef">const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="const_pointer-typedef">
<db:title>[alias] QSpan::const_pointer</db:title>
<db:para>An alias for const T* and const element_type*, respectively.</db:para>
<db:para>This alias is provided for compatbility with the STL.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#element_type-typedef">element_type</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#pointer-typedef">pointer</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const_reference-typedef">const_reference</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const_iterator-typedef">const_iterator</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="const_reference-typedef">
<db:title>[alias] QSpan::const_reference</db:title>
<db:para>An alias for const T&amp; and const element_type&amp;, respectively.</db:para>
<db:para>This alias is provided for compatbility with the STL.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#element_type-typedef">element_type</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#reference-typedef">reference</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const_pointer-typedef">const_pointer</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="const_reverse_iterator-typedef">
<db:title>[alias] QSpan::const_reverse_iterator</db:title>
<db:para>An alias for std::reverse_iterator&lt;const_iterator&gt;.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#const_iterator-typedef">const_iterator</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#reverse_iterator-typedef">reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="difference_type-typedef">
<db:title>[alias] QSpan::difference_type</db:title>
<db:para>An alias for qptrdiff. This <db:link xlink:href="qspan.xml#qspan-vs-std-span">differs from std::span</db:link>.</db:para>
<db:para>This alias is provided for compatbility with the STL.</db:para>
</db:section>
<db:section xml:id="element_type-typedef">
<db:title>[alias] QSpan::element_type</db:title>
<db:para>An alias for T. Includes the const, if any.</db:para>
<db:para>This alias is provided for compatbility with the STL.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#value_type-typedef">value_type</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#pointer-typedef">pointer</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="iterator-typedef">
<db:title>[alias] QSpan::iterator</db:title>
<db:para>An alias for T* and pointer, respectively. Includes the const, if any.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#pointer-typedef">pointer</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const_iterator-typedef">const_iterator</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#reverse_iterator-typedef">reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="pointer-typedef">
<db:title>[alias] QSpan::pointer</db:title>
<db:para>An alias for T* and element_type*, respectively. Includes the const, if any.</db:para>
<db:para>This alias is provided for compatbility with the STL.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#element_type-typedef">element_type</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const_pointer-typedef">const_pointer</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#reference-typedef">reference</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#iterator-typedef">iterator</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reference-typedef">
<db:title>[alias] QSpan::reference</db:title>
<db:para>An alias for T&amp; and element_type&amp;, respectively. Includes the const, if any.</db:para>
<db:para>This alias is provided for compatbility with the STL.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#element_type-typedef">element_type</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const_reference-typedef">const_reference</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#pointer-typedef">pointer</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="reverse_iterator-typedef">
<db:title>[alias] QSpan::reverse_iterator</db:title>
<db:para>An alias for std::reverse_iterator&lt;iterator&gt;. Includes the const, if any.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#iterator-typedef">iterator</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const_reverse_iterator-typedef">const_reverse_iterator</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size_type-typedef">
<db:title>[alias] QSpan::size_type</db:title>
<db:para>An alias for qsizetype. This <db:link xlink:href="qspan.xml#qspan-vs-std-span">differs from std::span</db:link>.</db:para>
<db:para>This alias is provided for compatbility with the STL.</db:para>
</db:section>
<db:section xml:id="value_type-typedef">
<db:title>[alias] QSpan::value_type</db:title>
<db:para>An alias for T. Excludes the const, if any.</db:para>
<db:para>This alias is provided for compatbility with the STL.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#element_type-typedef">element_type</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QSpan-2">
<db:title>[default] QSpan::QSpan(QSpan&lt;T, E&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="QSpan-4">[default] QSpan::QSpan(const QSpan&lt;T, E&gt; &amp;<db:emphasis>other</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="operator-eq">[default] QSpan&lt;T, E&gt; &amp;QSpan::operator=(QSpan&lt;T, E&gt; &amp;&amp;<db:emphasis>other</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="operator-eq-1">[default] QSpan&lt;T, E&gt; &amp;QSpan::operator=(const QSpan&lt;T, E&gt; &amp;<db:emphasis>other</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="dtor.QSpan">[default] QSpan::~QSpan()</db:bridgehead>
<db:para>These Special Member Functions are implicitly-defined.</db:para>
<db:note>
<db:para>Moves are equivalent to copies. Only <db:link xlink:href="qspan.xml#data">data</db:link>() and <db:link xlink:href="qspan.xml#size">size</db:link>() are copied from span to span, not the referenced data.</db:para>
</db:note>
</db:section>
<db:section xml:id="QSpan-5">
<db:title>[constexpr noexcept] QSpan::QSpan(const std::array&lt;S, N&gt; &amp;<db:emphasis>arr</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="QSpan-6">[constexpr noexcept] QSpan::QSpan(q20::type_identity_t&lt;T&gt; (&amp;)[N] <db:emphasis>arr</db:emphasis>)</db:bridgehead>
<db:bridgehead renderas="sect2" xml:id="QSpan-7">[constexpr noexcept] QSpan::QSpan(std::array&lt;S, N&gt; &amp;<db:emphasis>arr</db:emphasis>)</db:bridgehead>
<db:para>Constructs a <db:link xlink:href="qspan.xml">QSpan</db:link> referencing the data in the supplied array <db:code role="parameter">arr</db:code>.</db:para>
<db:note>
<db:para>q20::type_identity_t is a C++17 backport of C++20's <db:link xlink:href="https://en.cppreference.com/w/cpp/types/type_identity">std::type_identity_t</db:link>.</db:para>
</db:note>
<db:section xml:id="constraints">
<db:title>Constraints</db:title>
<db:para>Participates in overload resolution only if</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>either N or <db:link xlink:href="qspan.xml#extent-var">extent</db:link> are std::dynamic_extent or otherwise <db:link xlink:href="qspan.xml#extent-var">extent</db:link> == N</db:para>
</db:listitem>
<db:listitem>
<db:para>and either S or const S are the same as T.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Notes</db:title>
</db:section>
</db:section>
<db:section xml:id="QSpan-1">
<db:title>[constexpr noexcept] QSpan::QSpan(QSpan&lt;S, N&gt; <db:emphasis>other</db:emphasis>)</db:title>
<db:bridgehead renderas="sect2" xml:id="QSpan-9">[constexpr noexcept] QSpan::QSpan(std::span&lt;S, N&gt; <db:emphasis>other</db:emphasis>)</db:bridgehead>
<db:para>Constructs a <db:link xlink:href="qspan.xml">QSpan</db:link> referencing the data in the supplied span <db:code role="parameter">other</db:code>.</db:para>
<db:section xml:id="constraints">
<db:title>Constraints</db:title>
<db:para>Participates in overload resolution only if</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>either N or <db:link xlink:href="qspan.xml#extent-var">extent</db:link> are std::dynamic_extent or <db:link xlink:href="qspan.xml#extent-var">extent</db:link> == N</db:para>
</db:listitem>
<db:listitem>
<db:para>and either S or const S are the same as T.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Notes</db:title>
</db:section>
</db:section>
<db:section xml:id="empty">
<db:title>[constexpr noexcept] auto QSpan::empty() const</db:title>
<db:bridgehead renderas="sect2" xml:id="isEmpty">[constexpr noexcept] auto QSpan::isEmpty() const</db:bridgehead>
<db:para>Returns whether the span is empty, that is, whether size() == 0.</db:para>
<db:para>These functions do the same thing: <db:link xlink:href="qspan.xml#empty">empty</db:link>() is provided for STL compatibility and <db:link xlink:href="qspan.xml#isEmpty">isEmpty</db:link>() is provided for Qt compatibility.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#size_bytes">size_bytes</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sliced">
<db:title>[constexpr] auto QSpan::sliced(QSpan&lt;T, E&gt;::size_type <db:emphasis>pos</db:emphasis>) const</db:title>
<db:bridgehead renderas="sect2" xml:id="subspan-2">[constexpr] auto QSpan::subspan(QSpan&lt;T, E&gt;::size_type <db:emphasis>pos</db:emphasis>) const</db:bridgehead>
<db:para>Returns a <db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">variable-sized</db:link> span of size size() - pos referencing the remainder of this span after dropping the first <db:code role="parameter">pos</db:code> elements.</db:para>
<db:para><db:code role="parameter">pos</db:code> must be non-negative.</db:para>
<db:para>This span must hold at least <db:code role="parameter">pos</db:code> elements (E &gt;= <db:code role="parameter">pos</db:code> <db:emphasis>and</db:emphasis> <db:link xlink:href="qspan.xml#size">size</db:link>() &gt;= <db:code role="parameter">pos</db:code>), otherwise the behavior is undefined.</db:para>
<db:para>These functions do the same thing: <db:link xlink:href="qspan.xml#subspan">subspan</db:link>() is provided for STL compatibility and <db:link xlink:href="qspan.xml#sliced">sliced</db:link>() is provided for Qt compatibility.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#subspan">subspan</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#first-1">first</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#last-1">last</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#slice">slice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="sliced-1">
<db:title>[constexpr] auto QSpan::sliced(QSpan&lt;T, E&gt;::size_type <db:emphasis>pos</db:emphasis>, QSpan&lt;T, E&gt;::size_type <db:emphasis>n</db:emphasis>) const</db:title>
<db:bridgehead renderas="sect2" xml:id="subspan-3">[constexpr] auto QSpan::subspan(QSpan&lt;T, E&gt;::size_type <db:emphasis>pos</db:emphasis>, QSpan&lt;T, E&gt;::size_type <db:emphasis>n</db:emphasis>) const</db:bridgehead>
<db:para>Returns a <db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">variable-sized</db:link> span of size <db:code role="parameter">n</db:code> referencing the <db:code role="parameter">n</db:code> elements of this span starting at <db:code role="parameter">pos</db:code>.</db:para>
<db:para>Both <db:code role="parameter">pos</db:code> and <db:code role="parameter">n</db:code> must be non-negative.</db:para>
<db:para>This span must hold at least pos + n elements (E &gt;= pos + n <db:emphasis>and</db:emphasis> <db:link xlink:href="qspan.xml#size">size</db:link>() &gt;= pos + n), otherwise the behavior is undefined.</db:para>
<db:para>These functions do the same thing: <db:link xlink:href="qspan.xml#subspan">subspan</db:link>() is provided for STL compatibility and <db:link xlink:href="qspan.xml#sliced">sliced</db:link>() is provided for Qt compatibility.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#subspan">subspan</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#first-1">first</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#last-1">last</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#chopped">chopped</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#slice">slice</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QSpan">
<db:title>[default] QSpan::QSpan()</db:title>
<db:para>Default constructor.</db:para>
<db:para>This constructor is only present if E is either zero (0) or std::dynamic_extent. In other words: only fixed-zero-sized or variable-sized spans are default-constructible.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#extent-var">extent</db:link></db:member>
<db:member><db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">Variable-Size and Fixed-Size Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QSpan-3">
<db:title>[constexpr] QSpan::QSpan(Range &amp;&amp;<db:emphasis>r</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qspan.xml">QSpan</db:link> referencing the data in the supplied range <db:code role="parameter">r</db:code>.</db:para>
<db:section xml:id="constraints">
<db:title>Constraints</db:title>
<db:para>Participates in overload resolution only if Range is <db:link xlink:href="qspan.xml#compatible-ranges">a compatible range</db:link>.</db:para>
</db:section>
<db:section>
<db:title>Notes</db:title>
</db:section>
</db:section>
<db:section xml:id="QSpan-8">
<db:title>[constexpr] QSpan::QSpan(std::initializer_list&lt;QSpan&lt;T, E&gt;::value_type&gt; <db:emphasis>il</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qspan.xml">QSpan</db:link> referencing the data in the supplied initializer list <db:code role="parameter">il</db:code>.</db:para>
<db:note>
<db:para>This constructor is noexcept only if E is std::dynamic_extent.</db:para>
</db:note>
<db:note>
<db:para>If E is not std::dynamic_extent and the size of <db:code role="parameter">il</db:code> is not E, the behavior is undefined.</db:para>
</db:note>
<db:section xml:id="constraints">
<db:title>Constraints</db:title>
<db:para>Participates in overload resolution only if T is const-qualified.</db:para>
</db:section>
<db:section>
<db:title>Notes</db:title>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QSpan-10">
<db:title>[constexpr] QSpan::QSpan(It <db:emphasis>first</db:emphasis>, It <db:emphasis>last</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qspan.xml">QSpan</db:link> referencing the data starting at <db:code role="parameter">first</db:code> and having length (<db:code role="parameter">last</db:code> - <db:code role="parameter">first</db:code>).</db:para>
<db:para>[first, last) must be a valid range.</db:para>
<db:section xml:id="constraints">
<db:title>Constraints</db:title>
<db:para>Participates in overload resolution only if It is <db:link xlink:href="qspan.xml#compatible-iterators">a compatible iterator</db:link>.</db:para>
</db:section>
<db:section>
<db:title>Notes</db:title>
</db:section>
</db:section>
<db:section xml:id="QSpan-11">
<db:title>[constexpr] QSpan::QSpan(It <db:emphasis>first</db:emphasis>, qsizetype <db:emphasis>count</db:emphasis>)</db:title>
<db:para>Constructs a <db:link xlink:href="qspan.xml">QSpan</db:link> referencing the data starting at <db:code role="parameter">first</db:code> and having length <db:code role="parameter">count</db:code>.</db:para>
<db:para>[first, count) must be a valid range.</db:para>
<db:section xml:id="constraints">
<db:title>Constraints</db:title>
<db:para>Participates in overload resolution only if It is <db:link xlink:href="qspan.xml#compatible-iterators">a compatible iterator</db:link>.</db:para>
</db:section>
<db:section>
<db:title>Notes</db:title>
</db:section>
</db:section>
<db:section xml:id="back">
<db:title>[constexpr] auto QSpan::back() const</db:title>
<db:para>Returns a reference to the last element in the span.</db:para>
<db:para>The span must not be empty, otherwise the behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#operator-5b-5d">operator[]</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#front">front</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#empty">empty</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="begin">
<db:title>[constexpr noexcept] auto QSpan::begin() const</db:title>
<db:para>Returns an interator pointing at the beginning of the span.</db:para>
<db:para>Because <db:link xlink:href="qspan.xml">QSpan</db:link> iterators are just pointers, this is the same as calling <db:link xlink:href="qspan.xml#data">data</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cbegin">
<db:title>[constexpr noexcept] auto QSpan::cbegin() const</db:title>
<db:para>Returns a <db:link xlink:href="qspan.xml#const_iterator-typedef">const_iterator</db:link> pointing to the beginning of the span.</db:para>
<db:para>This will return a read-only iterator even if T is not const:</db:para>
<db:programlisting language="cpp">QSpan&lt;int&gt; span = ~~~;
*span.begin() = 42; // OK
*span.cbegin() = 42; // ERROR: cannot assign through a const_iterator
</db:programlisting>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#cend">cend</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="cend">
<db:title>[constexpr noexcept] auto QSpan::cend() const</db:title>
<db:para>Returns a <db:link xlink:href="qspan.xml#const_iterator-typedef">const_iterator</db:link> pointing to one past the end of the span.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="chop">
<db:title>[constexpr, since 6.9] void QSpan::chop(QSpan&lt;T, E&gt;::size_type <db:emphasis>n</db:emphasis>)</db:title>
<db:para>Same as *this = chopped(<db:code role="parameter">n</db:code>).</db:para>
<db:para>This function is only available on <db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">variable-sized spans</db:link>.</db:para>
<db:para>This function was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#chopped">chopped</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="chopped">
<db:title>[constexpr, since 6.9] auto QSpan::chopped(QSpan&lt;T, E&gt;::size_type <db:emphasis>n</db:emphasis>) const</db:title>
<db:para>Returns a <db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">variable-sized</db:link> span of size <db:link xlink:href="qspan.xml#size">size</db:link>() - <db:code role="parameter">n</db:code> referencing the first <db:link xlink:href="qspan.xml#size">size</db:link>() - <db:code role="parameter">n</db:code> elements of this span.</db:para>
<db:para>Same as first(size() - n).</db:para>
<db:para><db:code role="parameter">n</db:code> must be non-negative.</db:para>
<db:para>This span must hold at least <db:code role="parameter">n</db:code> elements (E &gt;= <db:code role="parameter">n</db:code> <db:emphasis>and</db:emphasis> <db:link xlink:href="qspan.xml#size">size</db:link>() &gt;= <db:code role="parameter">n</db:code>), otherwise the behavior is undefined.</db:para>
<db:para>This function was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#subspan">subspan</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#first-1">first</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#last-1">last</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#chop">chop</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="crbegin">
<db:title>[constexpr noexcept] auto QSpan::crbegin() const</db:title>
<db:para>Returns a <db:link xlink:href="qspan.xml#const_reverse_iterator-typedef">const_reverse_iterator</db:link> pointing to the beginning of the reversed span.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="crend">
<db:title>[constexpr noexcept] auto QSpan::crend() const</db:title>
<db:para>Returns a <db:link xlink:href="qspan.xml#const_reverse_iterator-typedef">const_reverse_iterator</db:link> pointing to one past the end of the reversed span.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#cend">cend</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="data">
<db:title>[constexpr noexcept] auto QSpan::data() const</db:title>
<db:para>Returns a pointer to the beginning of the span.</db:para>
<db:para>The same as calling <db:link xlink:href="qspan.xml#begin">begin</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#front">front</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="end">
<db:title>[constexpr noexcept] auto QSpan::end() const</db:title>
<db:para>Returns an iterator pointing to one past the end of the span.</db:para>
<db:para>Because <db:link xlink:href="qspan.xml">QSpan</db:link> iterators are just pointers, this it the same as calling data() + size().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#cend">cend</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#data">data</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first">
<db:title>[constexpr noexcept(...)] auto QSpan::first() const</db:title>
<db:para>Returns a <db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">fixed-sized</db:link> span of size Count referencing the first Count elements of *this.</db:para>
<db:para>The span must hold at least Count elements (E &gt;= Count <db:emphasis>and</db:emphasis> <db:link xlink:href="qspan.xml#size">size</db:link>() &gt;= Count), otherwise the behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#first-1">first</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#subspan">subspan</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="first-1">
<db:title>[constexpr] auto QSpan::first(QSpan&lt;T, E&gt;::size_type <db:emphasis>n</db:emphasis>) const</db:title>
<db:para>Returns a <db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">variable-sized</db:link> span of size <db:code role="parameter">n</db:code> referencing the first <db:code role="parameter">n</db:code> elements of *this.</db:para>
<db:para><db:code role="parameter">n</db:code> must be non-negative.</db:para>
<db:para>The span must hold at least <db:code role="parameter">n</db:code> elements (E &gt;= <db:code role="parameter">n</db:code> <db:emphasis>and</db:emphasis> <db:link xlink:href="qspan.xml#size">size</db:link>() &gt;= <db:code role="parameter">n</db:code>), otherwise the behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#first">first&lt;N&gt;</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#last-1">last</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#subspan-2">subspan</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#subspan-3">subspan</db:link>(QSpan&lt;T,E&gt;::size_type, QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#chopped">chopped</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="front">
<db:title>[constexpr] auto QSpan::front() const</db:title>
<db:para>Returns a reference to the first element in the span.</db:para>
<db:para>The span must not be empty, otherwise the behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#operator-5b-5d">operator[]</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#back">back</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#empty">empty</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last">
<db:title>[constexpr noexcept(...)] auto QSpan::last() const</db:title>
<db:para>Returns a <db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">fixed-sized</db:link> span of size Count referencing the last Count elements of *this.</db:para>
<db:para>The span must hold at least Count elements (E &gt;= Count <db:emphasis>and</db:emphasis> <db:link xlink:href="qspan.xml#size">size</db:link>() &gt;= Count), otherwise the behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#last-1">last</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#subspan">subspan</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="last-1">
<db:title>[constexpr] auto QSpan::last(QSpan&lt;T, E&gt;::size_type <db:emphasis>n</db:emphasis>) const</db:title>
<db:para>Returns a <db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">variable-sized</db:link> span of size <db:code role="parameter">n</db:code> referencing the last <db:code role="parameter">n</db:code> elements of *this.</db:para>
<db:para><db:code role="parameter">n</db:code> must be non-negative.</db:para>
<db:para>The span must hold at least <db:code role="parameter">n</db:code> elements (E &gt;= <db:code role="parameter">n</db:code> <db:emphasis>and</db:emphasis> <db:link xlink:href="qspan.xml#size">size</db:link>() &gt;= <db:code role="parameter">n</db:code>), otherwise the behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#first-1">first</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#subspan-2">subspan</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#subspan-3">subspan</db:link>(QSpan&lt;T,E&gt;::size_type, QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#sliced">sliced</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#chopped">chopped</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rbegin">
<db:title>[constexpr noexcept] auto QSpan::rbegin() const</db:title>
<db:para>Returns a <db:link xlink:href="qspan.xml#reverse_iterator-typedef">reverse_iterator</db:link> pointing to the beginning of the reversed span.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#rend">rend</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#crbegin">crbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#begin">begin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#cbegin">cbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rend">
<db:title>[constexpr noexcept] auto QSpan::rend() const</db:title>
<db:para>Returns a <db:link xlink:href="qspan.xml#reverse_iterator-typedef">reverse_iterator</db:link> pointing to one past the end of the reversed span.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#rbegin">rbegin</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#crend">crend</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#end">end</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#cend">cend</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size">
<db:title>[constexpr noexcept] auto QSpan::size() const</db:title>
<db:para>Returns the size of the span, that is, the number of elements it references.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#size_bytes">size_bytes</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#empty">empty</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="size_bytes">
<db:title>[constexpr noexcept] auto QSpan::size_bytes() const</db:title>
<db:para>Returns the size of the span in bytes, that is, the number of elements multiplied by sizeof(T).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#empty">empty</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#isEmpty">isEmpty</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="slice">
<db:title>[constexpr, since 6.9] void QSpan::slice(QSpan&lt;T, E&gt;::size_type <db:emphasis>pos</db:emphasis>)</db:title>
<db:para>Same as *this = sliced(<db:code role="parameter">pos</db:code>).</db:para>
<db:para>This function is only available on <db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">variable-sized spans</db:link>.</db:para>
<db:para>This function was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#sliced">sliced</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="slice-1">
<db:title>[constexpr, since 6.9] void QSpan::slice(QSpan&lt;T, E&gt;::size_type <db:emphasis>pos</db:emphasis>, QSpan&lt;T, E&gt;::size_type <db:emphasis>n</db:emphasis>)</db:title>
<db:para>Same as *this = sliced(<db:code role="parameter">pos</db:code>,<db:code role="parameter">n</db:code>).</db:para>
<db:para>This function is only available on <db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">variable-sized spans</db:link>.</db:para>
<db:para>This function was introduced in Qt 6.9.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#sliced">sliced</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="subspan">
<db:title>[constexpr noexcept(...)] auto QSpan::subspan() const</db:title>
<db:para>Returns a span of size Count referencing the Count elements of this span starting at Offset.</db:para>
<db:para>If *this is a variable-sized span, the return type is a variable-sized span, otherwise it is a fixed-sized span.</db:para>
<db:para>This span must hold at least Offset + Count elements (E &gt;= Offset + Count <db:emphasis>and</db:emphasis> <db:link xlink:href="qspan.xml#size">size</db:link>() &gt;= Offset + Count), otherwise the behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#subspan-3">subspan</db:link>(QSpan&lt;T,E&gt;::size_type, QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member>subspan()</db:member>
<db:member><db:link xlink:href="qspan.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">Variable-Size and Fixed-Size Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="subspan-1">
<db:title>[constexpr noexcept(...)] auto QSpan::subspan() const</db:title>
<db:para>Returns a span of size E - Offset referencing the remainder of this span after dropping the first Offset elements.</db:para>
<db:para>If *this is a variable-sized span, the return type is a variable-sized span, otherwise it is a fixed-sized span.</db:para>
<db:para>This span must hold at least Offset elements (E &gt;= Offset <db:emphasis>and</db:emphasis> <db:link xlink:href="qspan.xml#size">size</db:link>() &gt;= Offset), otherwise the behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#subspan-2">subspan</db:link>(QSpan&lt;T,E&gt;::size_type)</db:member>
<db:member><db:link xlink:href="qspan.xml#subspan">subspan</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#first">first</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#last">last</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">Variable-Size and Fixed-Size Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-5b-5d">
<db:title>[constexpr] QSpan&lt;T, E&gt;::reference QSpan::operator[](QSpan&lt;T, E&gt;::size_type <db:emphasis>idx</db:emphasis>) const</db:title>
<db:para>Returns a reference to the element at index <db:code role="parameter">idx</db:code> in the span.</db:para>
<db:para>The index must be in range, that is, <db:code role="parameter">idx</db:code> &gt;= 0 and <db:code role="parameter">idx</db:code> &lt; <db:link xlink:href="qspan.xml#size">size</db:link>(), otherwise the behavior is undefined.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#front">front</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#back">back</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#size">size</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#empty">empty</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-variable-documentation">
<db:title>Member Variable Documentation</db:title>
<db:section xml:id="extent-var">
<db:title>const std::size_t QSpan::extent</db:title>
<db:para>The second template argument of QSpan&lt;T, E&gt;, that is, E. This is std::dynamic_extent for <db:link xlink:href="qspan.xml#variable-size-and-fixed-size-spans">variable-sized spans</db:link>.</db:para>
<db:note>
<db:para>While all other sizes and indexes in <db:link xlink:href="qspan.xml">QSpan</db:link> use qsizetype, this variable, like E, is actually of type size_t, for compatibility with std::span and std::dynamic_extent.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#size">size</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="as_bytes">
<db:title>[noexcept, since 6.8] auto as_bytes(QSpan&lt;T, E&gt; <db:emphasis>s</db:emphasis>)</db:title>
<db:para>Returns <db:code role="parameter">s</db:code> as a QSpan&lt;const std::byte, E'&gt; whose <db:link xlink:href="qspan.xml#size">size</db:link>() is equal to s.size_bytes().</db:para>
<db:para>If E is std::dynamic_extent then so is E'. Otherwise, E' = E * sizeof(T).</db:para>
<db:note>
<db:para>q20::dynamic_extent is a C++17 backport of C++20's <db:link xlink:href="https://en.cppreference.com/w/cpp/container/span/dynamic_extent">std::dynamic_extent</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#as_writable_bytes">as_writable_bytes</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#size_bytes">size_bytes</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="as_writable_bytes">
<db:title>[noexcept, since 6.8] auto as_writable_bytes(QSpan&lt;T, E&gt; <db:emphasis>s</db:emphasis>)</db:title>
<db:para>Returns <db:code role="parameter">s</db:code> as a QSpan&lt;std::byte, E'&gt; whose <db:link xlink:href="qspan.xml#size">size</db:link>() is equal to s.size_bytes().</db:para>
<db:para>If E is std::dynamic_extent then so is E'. Otherwise, E' = E * sizeof(T).</db:para>
<db:note>
<db:para>q20::dynamic_extent is a C++17 backport of C++20's <db:link xlink:href="https://en.cppreference.com/w/cpp/container/span/dynamic_extent">std::dynamic_extent</db:link>.</db:para>
</db:note>
<db:section xml:id="constraints">
<db:title>Constraints</db:title>
<db:para>Participates in overload resolution only if !std::is_const_v&lt;T&gt;.</db:para>
</db:section>
<db:section>
<db:title>Notes</db:title>
<db:para>This function was introduced in Qt 6.8.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qspan.xml#as_bytes">as_bytes</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#size_bytes">size_bytes</db:link>()</db:member>
<db:member><db:link xlink:href="qspan.xml#const-and-mutable-spans">Const and Mutable Spans</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
