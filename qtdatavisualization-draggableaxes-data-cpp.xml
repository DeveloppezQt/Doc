<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Axis Range Dragging With Labels Example</db:title>
<db:productname>QtDataVisualization</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Implementing a custom input handler to support axis dragging.</db:para>
<db:para>This documentation was introduced in QtDataVisualization 1.1.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the Qt Data Visualization module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:GPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3 or (at your option) any later version
** approved by the KDE Free Qt Foundation. The licenses are as published by
** the Free Software Foundation and appearing in the file LICENSE.GPL3
** included in the packaging of this file. Please review the following
** information to ensure the GNU General Public License requirements will
** be met: https://www.gnu.org/licenses/gpl-3.0.html.
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;data.h&quot;

#include &lt;QtDataVisualization/QScatterDataProxy&gt;
#include &lt;QtDataVisualization/Q3DScene&gt;
#include &lt;QtDataVisualization/Q3DCamera&gt;
#include &lt;QtDataVisualization/QScatter3DSeries&gt;
#include &lt;QtDataVisualization/Q3DTheme&gt;

using namespace QtDataVisualization;

const int itemCount = 500;

Data::Data(Q3DScatter *scatter)
    : m_graph(scatter),
      m_inputHandler(new AxesInputHandler(scatter)),
      m_autoAdjust(false)
{
    m_graph-&gt;activeTheme()-&gt;setType(Q3DTheme::ThemeEbony);
    m_graph-&gt;activeTheme()-&gt;setLabelBorderEnabled(true);
    m_graph-&gt;activeTheme()-&gt;setLabelBackgroundColor(QColor(QRgb(0x151550)));
    m_graph-&gt;activeTheme()-&gt;setLabelTextColor(Qt::lightGray);
    m_graph-&gt;activeTheme()-&gt;setFont(QFont(&quot;Arial Black&quot;, 30));
    m_graph-&gt;setShadowQuality(QAbstract3DGraph::ShadowQualityMedium);
    m_graph-&gt;scene()-&gt;activeCamera()-&gt;setCameraPreset(Q3DCamera::CameraPresetIsometricRight);

    m_graph-&gt;axisX()-&gt;setRange(-20.0f, 20.0f);
    m_graph-&gt;axisY()-&gt;setRange(-10.0f, 10.0f);
    m_graph-&gt;axisZ()-&gt;setRange(-20.0f, 20.0f);

    // Give ownership of the handler to the graph and make it the active handler
    m_graph-&gt;setActiveInputHandler(m_inputHandler);

    // Give our axes to the input handler
    m_inputHandler-&gt;setAxes(m_graph-&gt;axisX(), m_graph-&gt;axisZ(), m_graph-&gt;axisY());

    addData();
}

Data::~Data()
{
    delete m_graph;
}

void Data::toggleRanges()
{
    if (!m_autoAdjust) {
        m_graph-&gt;axisX()-&gt;setAutoAdjustRange(true);
        m_graph-&gt;axisZ()-&gt;setAutoAdjustRange(true);
        m_graph-&gt;axisY()-&gt;setAutoAdjustRange(true);
        m_inputHandler-&gt;setDragSpeedModifier(1.5f);
        m_autoAdjust = true;
    } else {
        m_graph-&gt;axisX()-&gt;setRange(-20.0f, 20.0f);
        m_graph-&gt;axisY()-&gt;setRange(-10.0f, 10.0f);
        m_graph-&gt;axisZ()-&gt;setRange(-20.0f, 20.0f);
        m_inputHandler-&gt;setDragSpeedModifier(15.0f);
        m_autoAdjust = false;
    }
}

void Data::addData()
{
    QScatter3DSeries *series = new QScatter3DSeries;
    series-&gt;setMesh(QAbstract3DSeries::MeshCube);
    series-&gt;setMeshSmooth(true);
    m_graph-&gt;addSeries(series);

    QScatter3DSeries *series2 = new QScatter3DSeries;
    series2-&gt;setMesh(QAbstract3DSeries::MeshMinimal);
    series2-&gt;setMeshSmooth(true);
    m_graph-&gt;addSeries(series2);

    QScatter3DSeries *series3 = new QScatter3DSeries;
    series3-&gt;setMesh(QAbstract3DSeries::MeshSphere);
    series3-&gt;setMeshSmooth(true);
    m_graph-&gt;addSeries(series3);

    QScatter3DSeries *series4 = new QScatter3DSeries;
    series4-&gt;setMesh(QAbstract3DSeries::MeshBevelCube);
    series4-&gt;setMeshSmooth(true);
    m_graph-&gt;addSeries(series4);

    QScatter3DSeries *series5 = new QScatter3DSeries;
    series5-&gt;setMesh(QAbstract3DSeries::MeshSphere);
    m_graph-&gt;addSeries(series5);

    QScatterDataArray *dataArray = new QScatterDataArray;
    dataArray-&gt;resize(itemCount);
    QScatterDataItem *ptrToDataArray = &amp;dataArray-&gt;first();
    for (int i = 0; i &lt; itemCount; i++) {
        ptrToDataArray-&gt;setPosition(randVector());
        ptrToDataArray++;
    }
    QScatterDataArray *dataArray2 = new QScatterDataArray;
    dataArray2-&gt;resize(itemCount);
    ptrToDataArray = &amp;dataArray2-&gt;first();
    for (int i = 0; i &lt; itemCount; i++) {
        ptrToDataArray-&gt;setPosition(randVector());
        ptrToDataArray++;
    }
    QScatterDataArray *dataArray3 = new QScatterDataArray;
    dataArray3-&gt;resize(itemCount);
    ptrToDataArray = &amp;dataArray3-&gt;first();
    for (int i = 0; i &lt; itemCount; i++) {
        ptrToDataArray-&gt;setPosition(randVector());
        ptrToDataArray++;
    }
    QScatterDataArray *dataArray4 = new QScatterDataArray;
    dataArray4-&gt;resize(itemCount);
    ptrToDataArray = &amp;dataArray4-&gt;first();
    for (int i = 0; i &lt; itemCount; i++) {
        ptrToDataArray-&gt;setPosition(randVector());
        ptrToDataArray++;
    }
    QScatterDataArray *dataArray5 = new QScatterDataArray;
    dataArray5-&gt;resize(itemCount);
    ptrToDataArray = &amp;dataArray5-&gt;first();
    for (int i = 0; i &lt; itemCount; i++) {
        ptrToDataArray-&gt;setPosition(randVector());
        ptrToDataArray++;
    }

    m_graph-&gt;seriesList().at(0)-&gt;dataProxy()-&gt;resetArray(dataArray);
    m_graph-&gt;seriesList().at(1)-&gt;dataProxy()-&gt;resetArray(dataArray2);
    m_graph-&gt;seriesList().at(2)-&gt;dataProxy()-&gt;resetArray(dataArray3);
    m_graph-&gt;seriesList().at(3)-&gt;dataProxy()-&gt;resetArray(dataArray4);
    m_graph-&gt;seriesList().at(4)-&gt;dataProxy()-&gt;resetArray(dataArray5);
}

QVector3D Data::randVector()
{
    return QVector3D(
                (float)(rand() % 100) / 2.0f - (float)(rand() % 100) / 2.0f,
                (float)(rand() % 100) / 2.0f - (float)(rand() % 100) / 2.0f,
                (float)(rand() % 100) / 2.0f - (float)(rand() % 100) / 2.0f);
}

</db:programlisting>
</db:article>
