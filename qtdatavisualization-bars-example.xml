<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Bars Example</db:title>
<db:productname>QtDataVisualization</db:productname>
<db:edition>Qt Data Visualization | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Using <db:link xlink:href="q3dbars.xml">Q3DBars</db:link> in a widget application.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The bars example shows how to make a 3D bar graph using <db:link xlink:href="q3dbars.xml">Q3DBars</db:link> and combining the use of widgets for adjusting several adjustable qualities. The example shows how to:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Create an application with <db:link xlink:href="q3dbars.xml">Q3DBars</db:link> and some widgets</db:para>
</db:listitem>
<db:listitem>
<db:para>Use <db:link xlink:href="qbar3dseries.xml">QBar3DSeries</db:link> and <db:link xlink:href="qbardataproxy.xml">QBarDataProxy</db:link> to set data to the graph</db:para>
</db:listitem>
<db:listitem>
<db:para>Adjust some graph and series properties using widget controls</db:para>
</db:listitem>
<db:listitem>
<db:para>Select a row or a column by clicking an axis label</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>It also demonstrates how having negative bar values affects the graph.</db:para>
<db:para>For instructions about how to interact with the graph, see <db:link xlink:href="qtdatavisualization-interacting-with-data.xml">this page</db:link>.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/bars-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="http://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:emphasis role="bold">Welcome</db:emphasis> mode and select the example from <db:emphasis role="bold">Examples</db:emphasis>. For more information, visit <db:link xlink:href="http://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="creating-the-application">
<db:title>Creating the Application</db:title>
<db:para>First, in main.cpp, we create a <db:link xlink:href="qapplication.xml">QApplication</db:link>, instantiate <db:link xlink:href="q3dbars.xml">Q3DBars</db:link> and a window container for it:</db:para>
<db:programlisting language="cpp">QApplication app(argc, argv);
Q3DBars *widgetgraph = new Q3DBars();
QWidget *container = QWidget::createWindowContainer(widgetgraph);
</db:programlisting>
<db:para>The call to <db:link xlink:href="qwidget.xml#createWindowContainer">QWidget::createWindowContainer</db:link> is required, as all data visualization graph classes (<db:link xlink:href="q3dbars.xml">Q3DBars</db:link>, <db:link xlink:href="q3dscatter.xml">Q3DScatter</db:link>, <db:link xlink:href="q3dsurface.xml">Q3DSurface</db:link>) inherit <db:link xlink:href="qwindow.xml">QWindow</db:link>. Any class inheriting <db:link xlink:href="qwindow.xml">QWindow</db:link> cannot be used as a widget any other way.</db:para>
<db:para>Then we'll create horizontal and vertical layouts. We'll add the graph and the vertical layout into the horizontal one:</db:para>
<db:programlisting language="cpp">QWidget *widget = new QWidget;
QHBoxLayout *hLayout = new QHBoxLayout(widget);
QVBoxLayout *vLayout = new QVBoxLayout();
hLayout-&amp;gt;addWidget(container, 1);
hLayout-&amp;gt;addLayout(vLayout);
</db:programlisting>
<db:para>We're not using the vertical layout for anything yet, but we'll get back to it in <db:link xlink:href="qtdatavisualization-scatter-example.xml#using-widgets-to-control-the-graph">Using widgets to control the graph</db:link></db:para>
<db:para>Next, let's create another class to handle the data addition and other interaction with the graph. Let's call it <db:code>GraphModifier</db:code> (See <db:link xlink:href="qtdatavisualization-scatter-example.xml#setting-up-the-graph">Setting up the graph</db:link> and <db:link xlink:href="qtdatavisualization-scatter-example.xml#adding-data-to-the-graph">Adding data to the graph</db:link> for details):</db:para>
<db:programlisting language="cpp">GraphModifier *modifier = new GraphModifier(widgetgraph);
</db:programlisting>
<db:para>The application main is done and we can show the graph and start the event loop:</db:para>
<db:programlisting language="cpp">widget-&amp;gt;show();
return app.exec();
</db:programlisting>
</db:section>
<db:section xml:id="setting-up-the-graph">
<db:title>Setting up the Graph</db:title>
<db:para>Let's set up the graph in the constructor of the <db:code>GraphModifier</db:code> class we instantiated in the application main:</db:para>
<db:programlisting language="cpp">GraphModifier::GraphModifier(Q3DBars *bargraph)
    : m_graph(bargraph),
      m_xRotation(0.0f),
      m_yRotation(0.0f),
      m_fontSize(30),
      m_segments(4),
      m_subSegments(3),
      m_minval(-20.0f),
      m_maxval(20.0f),
      m_temperatureAxis(new QValue3DAxis),
      m_yearAxis(new QCategory3DAxis),
      m_monthAxis(new QCategory3DAxis),
      m_primarySeries(new QBar3DSeries),
      m_secondarySeries(new QBar3DSeries),
      m_barMesh(QAbstract3DSeries::MeshBevelBar),
      m_smooth(false)
{
    m_graph-&amp;gt;setShadowQuality(QAbstract3DGraph::ShadowQualitySoftMedium);
    m_graph-&amp;gt;activeTheme()-&amp;gt;setBackgroundEnabled(false);
    m_graph-&amp;gt;activeTheme()-&amp;gt;setFont(QFont(&quot;Times New Roman&quot;, m_fontSize));
    m_graph-&amp;gt;activeTheme()-&amp;gt;setLabelBackgroundEnabled(true);
    m_graph-&amp;gt;setMultiSeriesUniform(true);

    m_months &amp;lt;&amp;lt; &quot;January&quot; &amp;lt;&amp;lt; &quot;February&quot; &amp;lt;&amp;lt; &quot;March&quot; &amp;lt;&amp;lt; &quot;April&quot; &amp;lt;&amp;lt; &quot;May&quot; &amp;lt;&amp;lt; &quot;June&quot; &amp;lt;&amp;lt; &quot;July&quot; &amp;lt;&amp;lt; &quot;August&quot; &amp;lt;&amp;lt; &quot;September&quot; &amp;lt;&amp;lt; &quot;October&quot; &amp;lt;&amp;lt; &quot;November&quot; &amp;lt;&amp;lt; &quot;December&quot;;
    m_years &amp;lt;&amp;lt; &quot;2006&quot; &amp;lt;&amp;lt; &quot;2007&quot; &amp;lt;&amp;lt; &quot;2008&quot; &amp;lt;&amp;lt; &quot;2009&quot; &amp;lt;&amp;lt; &quot;2010&quot; &amp;lt;&amp;lt; &quot;2011&quot; &amp;lt;&amp;lt; &quot;2012&quot; &amp;lt;&amp;lt; &quot;2013&quot;;

    m_temperatureAxis-&amp;gt;setTitle(&quot;Average temperature&quot;);
    m_temperatureAxis-&amp;gt;setSegmentCount(m_segments);
    m_temperatureAxis-&amp;gt;setSubSegmentCount(m_subSegments);
    m_temperatureAxis-&amp;gt;setRange(m_minval, m_maxval);
    m_temperatureAxis-&amp;gt;setLabelFormat(QString(QStringLiteral(&quot;%.1f &quot;) + celsiusString));
    m_temperatureAxis-&amp;gt;setLabelAutoRotation(30.0f);
    m_temperatureAxis-&amp;gt;setTitleVisible(true);

    m_yearAxis-&amp;gt;setTitle(&quot;Year&quot;);
    m_yearAxis-&amp;gt;setLabelAutoRotation(30.0f);
    m_yearAxis-&amp;gt;setTitleVisible(true);
    m_monthAxis-&amp;gt;setTitle(&quot;Month&quot;);
    m_monthAxis-&amp;gt;setLabelAutoRotation(30.0f);
    m_monthAxis-&amp;gt;setTitleVisible(true);

    m_graph-&amp;gt;setValueAxis(m_temperatureAxis);
    m_graph-&amp;gt;setRowAxis(m_yearAxis);
    m_graph-&amp;gt;setColumnAxis(m_monthAxis);

    m_primarySeries-&amp;gt;setItemLabelFormat(QStringLiteral(&quot;Oulu - @colLabel @rowLabel: @valueLabel&quot;));
    m_primarySeries-&amp;gt;setMesh(QAbstract3DSeries::MeshBevelBar);
    m_primarySeries-&amp;gt;setMeshSmooth(false);

    m_secondarySeries-&amp;gt;setItemLabelFormat(QStringLiteral(&quot;Helsinki - @colLabel @rowLabel: @valueLabel&quot;));
    m_secondarySeries-&amp;gt;setMesh(QAbstract3DSeries::MeshBevelBar);
    m_secondarySeries-&amp;gt;setMeshSmooth(false);
    m_secondarySeries-&amp;gt;setVisible(false);

    m_graph-&amp;gt;addSeries(m_primarySeries);
    m_graph-&amp;gt;addSeries(m_secondarySeries);

    changePresetCamera();

    resetTemperatureData();

    // Set up property animations for zooming to the selected bar
    Q3DCamera *camera = m_graph-&amp;gt;scene()-&amp;gt;activeCamera();
    m_defaultAngleX = camera-&amp;gt;xRotation();
    m_defaultAngleY = camera-&amp;gt;yRotation();
    m_defaultZoom = camera-&amp;gt;zoomLevel();
    m_defaultTarget = camera-&amp;gt;target();

    m_animationCameraX.setTargetObject(camera);
    m_animationCameraY.setTargetObject(camera);
    m_animationCameraZoom.setTargetObject(camera);
    m_animationCameraTarget.setTargetObject(camera);

    m_animationCameraX.setPropertyName(&quot;xRotation&quot;);
    m_animationCameraY.setPropertyName(&quot;yRotation&quot;);
    m_animationCameraZoom.setPropertyName(&quot;zoomLevel&quot;);
    m_animationCameraTarget.setPropertyName(&quot;target&quot;);

    int duration = 1700;
    m_animationCameraX.setDuration(duration);
    m_animationCameraY.setDuration(duration);
    m_animationCameraZoom.setDuration(duration);
    m_animationCameraTarget.setDuration(duration);

    // The zoom always first zooms out above the graph and then zooms in
    qreal zoomOutFraction = 0.3;
    m_animationCameraX.setKeyValueAt(zoomOutFraction, QVariant::fromValue(0.0f));
    m_animationCameraY.setKeyValueAt(zoomOutFraction, QVariant::fromValue(90.0f));
    m_animationCameraZoom.setKeyValueAt(zoomOutFraction, QVariant::fromValue(50.0f));
    m_animationCameraTarget.setKeyValueAt(zoomOutFraction,
                                          QVariant::fromValue(QVector3D(0.0f, 0.0f, 0.0f)));
}
</db:programlisting>
<db:para>Let's take a closer look at parts of the code.</db:para>
<db:para>First we're creating the axes and the series into member variables to support changing them easily later on, if we want to:</db:para>
<db:programlisting language="cpp">m_temperatureAxis(new QValue3DAxis),
m_yearAxis(new QCategory3DAxis),
m_monthAxis(new QCategory3DAxis),
m_primarySeries(new QBar3DSeries),
m_secondarySeries(new QBar3DSeries),
</db:programlisting>
<db:para>Then we're setting some of the visual qualities for the graph:</db:para>
<db:programlisting language="cpp">m_graph-&amp;gt;setShadowQuality(QAbstract3DGraph::ShadowQualitySoftMedium);
m_graph-&amp;gt;activeTheme()-&amp;gt;setBackgroundEnabled(false);
m_graph-&amp;gt;activeTheme()-&amp;gt;setFont(QFont(&quot;Times New Roman&quot;, m_fontSize));
m_graph-&amp;gt;activeTheme()-&amp;gt;setLabelBackgroundEnabled(true);
m_graph-&amp;gt;setMultiSeriesUniform(true);
</db:programlisting>
<db:para>We're also setting up the axes and setting them to the graph as active axes:</db:para>
<db:programlisting language="cpp">m_temperatureAxis-&amp;gt;setTitle(&quot;Average temperature&quot;);
m_temperatureAxis-&amp;gt;setSegmentCount(m_segments);
m_temperatureAxis-&amp;gt;setSubSegmentCount(m_subSegments);
m_temperatureAxis-&amp;gt;setRange(m_minval, m_maxval);
m_temperatureAxis-&amp;gt;setLabelFormat(QString(QStringLiteral(&quot;%.1f &quot;) + celsiusString));
m_temperatureAxis-&amp;gt;setLabelAutoRotation(30.0f);
m_temperatureAxis-&amp;gt;setTitleVisible(true);

m_yearAxis-&amp;gt;setTitle(&quot;Year&quot;);
m_yearAxis-&amp;gt;setLabelAutoRotation(30.0f);
m_yearAxis-&amp;gt;setTitleVisible(true);
m_monthAxis-&amp;gt;setTitle(&quot;Month&quot;);
m_monthAxis-&amp;gt;setLabelAutoRotation(30.0f);
m_monthAxis-&amp;gt;setTitleVisible(true);

m_graph-&amp;gt;setValueAxis(m_temperatureAxis);
m_graph-&amp;gt;setRowAxis(m_yearAxis);
m_graph-&amp;gt;setColumnAxis(m_monthAxis);
</db:programlisting>
<db:para>We give axis labels a small autorotation angle to make them orient somewhat toward the camera. This is done to improve axis label readability at extreme camera angles.</db:para>
<db:para>Next we initialize the visual properties of the series. Note that the second series is initially not visible:</db:para>
<db:programlisting language="cpp">m_primarySeries-&amp;gt;setItemLabelFormat(QStringLiteral(&quot;Oulu - @colLabel @rowLabel: @valueLabel&quot;));
m_primarySeries-&amp;gt;setMesh(QAbstract3DSeries::MeshBevelBar);
m_primarySeries-&amp;gt;setMeshSmooth(false);

m_secondarySeries-&amp;gt;setItemLabelFormat(QStringLiteral(&quot;Helsinki - @colLabel @rowLabel: @valueLabel&quot;));
m_secondarySeries-&amp;gt;setMesh(QAbstract3DSeries::MeshBevelBar);
m_secondarySeries-&amp;gt;setMeshSmooth(false);
m_secondarySeries-&amp;gt;setVisible(false);
</db:programlisting>
<db:para>The series need to be added to the graph to show them:</db:para>
<db:programlisting language="cpp">m_graph-&amp;gt;addSeries(m_primarySeries);
m_graph-&amp;gt;addSeries(m_secondarySeries);
</db:programlisting>
<db:para>Finally, we set the camera angle by calling the same method the camera angle change button in the UI uses to cycle through various camera angles:</db:para>
<db:programlisting language="cpp">changePresetCamera();
</db:programlisting>
<db:para>There you can see that the camera is controlled via the scene object of the graph:</db:para>
<db:programlisting language="cpp">static int preset = Q3DCamera::CameraPresetFront;

m_graph-&amp;gt;scene()-&amp;gt;activeCamera()-&amp;gt;setCameraPreset((Q3DCamera::CameraPreset)preset);

if (++preset &amp;gt; Q3DCamera::CameraPresetDirectlyBelow)
    preset = Q3DCamera::CameraPresetFrontLow;
</db:programlisting>
<db:para>For more information about using scene and cameras, see <db:link xlink:href="q3dscene.xml">Q3DScene</db:link> and <db:link xlink:href="q3dcamera.xml">Q3DCamera</db:link>.</db:para>
<db:para>That concludes setting up the graph.</db:para>
</db:section>
<db:section xml:id="adding-data-to-the-graph">
<db:title>Adding Data to the Graph</db:title>
<db:para>At the end of the constructor there's a call:</db:para>
<db:programlisting language="cpp">resetTemperatureData();
</db:programlisting>
<db:para>This method is used to add data to the proxies of the two series:</db:para>
<db:programlisting language="cpp">// Set up data
static const float tempOulu[8][12] = {
    {-6.7f, -11.7f, -9.7f, 3.3f, 9.2f, 14.0f, 16.3f, 17.8f, 10.2f, 2.1f, -2.6f, -0.3f},    // 2006
    {-6.8f, -13.3f, 0.2f, 1.5f, 7.9f, 13.4f, 16.1f, 15.5f, 8.2f, 5.4f, -2.6f, -0.8f},      // 2007
    {-4.2f, -4.0f, -4.6f, 1.9f, 7.3f, 12.5f, 15.0f, 12.8f, 7.6f, 5.1f, -0.9f, -1.3f},      // 2008
    {-7.8f, -8.8f, -4.2f, 0.7f, 9.3f, 13.2f, 15.8f, 15.5f, 11.2f, 0.6f, 0.7f, -8.4f},      // 2009
    {-14.4f, -12.1f, -7.0f, 2.3f, 11.0f, 12.6f, 18.8f, 13.8f, 9.4f, 3.9f, -5.6f, -13.0f},  // 2010
    {-9.0f, -15.2f, -3.8f, 2.6f, 8.3f, 15.9f, 18.6f, 14.9f, 11.1f, 5.3f, 1.8f, -0.2f},     // 2011
    {-8.7f, -11.3f, -2.3f, 0.4f, 7.5f, 12.2f, 16.4f, 14.1f, 9.2f, 3.1f, 0.3f, -12.1f},     // 2012
    {-7.9f, -5.3f, -9.1f, 0.8f, 11.6f, 16.6f, 15.9f, 15.5f, 11.2f, 4.0f, 0.1f, -1.9f}      // 2013
};

static const float tempHelsinki[8][12] = {
    {-3.7f, -7.8f, -5.4f, 3.4f, 10.7f, 15.4f, 18.6f, 18.7f, 14.3f, 8.5f, 2.9f, 4.1f},      // 2006
    {-1.2f, -7.5f, 3.1f, 5.5f, 10.3f, 15.9f, 17.4f, 17.9f, 11.2f, 7.3f, 1.1f, 0.5f},       // 2007
    {-0.6f, 1.2f, 0.2f, 6.3f, 10.2f, 13.8f, 18.1f, 15.1f, 10.1f, 9.4f, 2.5f, 0.4f},        // 2008
    {-2.9f, -3.5f, -0.9f, 4.7f, 10.9f, 14.0f, 17.4f, 16.8f, 13.2f, 4.1f, 2.6f, -2.3f},     // 2009
    {-10.2f, -8.0f, -1.9f, 6.6f, 11.3f, 14.5f, 21.0f, 18.8f, 12.6f, 6.1f, -0.5f, -7.3f},   // 2010
    {-4.4f, -9.1f, -2.0f, 5.5f, 9.9f, 15.6f, 20.8f, 17.8f, 13.4f, 8.9f, 3.6f, 1.5f},       // 2011
    {-3.5f, -3.2f, -0.7f, 4.0f, 11.1f, 13.4f, 17.3f, 15.8f, 13.1f, 6.4f, 4.1f, -5.1f},     // 2012
    {-4.8f, -1.8f, -5.0f, 2.9f, 12.8f, 17.2f, 18.0f, 17.1f, 12.5f, 7.5f, 4.5f, 2.3f}       // 2013
};

// Create data arrays
QBarDataArray *dataSet = new QBarDataArray;
QBarDataArray *dataSet2 = new QBarDataArray;
QBarDataRow *dataRow;
QBarDataRow *dataRow2;

dataSet-&amp;gt;reserve(m_years.size());
for (int year = 0; year &amp;lt; m_years.size(); year++) {
    // Create a data row
    dataRow = new QBarDataRow(m_months.size());
    dataRow2 = new QBarDataRow(m_months.size());
    for (int month = 0; month &amp;lt; m_months.size(); month++) {
        // Add data to the row
        (*dataRow)[month].setValue(tempOulu[year][month]);
        (*dataRow2)[month].setValue(tempHelsinki[year][month]);
    }
    // Add the row to the set
    dataSet-&amp;gt;append(dataRow);
    dataSet2-&amp;gt;append(dataRow2);
}

// Add data to the data proxy (the data proxy assumes ownership of it)
m_primarySeries-&amp;gt;dataProxy()-&amp;gt;resetArray(dataSet, m_years, m_months);
m_secondarySeries-&amp;gt;dataProxy()-&amp;gt;resetArray(dataSet2, m_years, m_months);
</db:programlisting>
<db:para>Now the series have data to show.</db:para>
</db:section>
<db:section xml:id="using-widgets-to-control-the-graph">
<db:title>Using Widgets to Control the Graph</db:title>
<db:para>There isn't much interaction yet, so let's continue by adding some widgets back in the application main. Let's just focus on two as an example:</db:para>
<db:programlisting language="cpp">QSlider *rotationSliderX = new QSlider(Qt::Horizontal, widget);
rotationSliderX-&amp;gt;setTickInterval(30);
rotationSliderX-&amp;gt;setTickPosition(QSlider::TicksBelow);
rotationSliderX-&amp;gt;setMinimum(-180);
rotationSliderX-&amp;gt;setValue(0);
rotationSliderX-&amp;gt;setMaximum(180);
QSlider *rotationSliderY = new QSlider(Qt::Horizontal, widget);
rotationSliderY-&amp;gt;setTickInterval(15);
rotationSliderY-&amp;gt;setTickPosition(QSlider::TicksAbove);
rotationSliderY-&amp;gt;setMinimum(-90);
rotationSliderY-&amp;gt;setValue(0);
rotationSliderY-&amp;gt;setMaximum(90);
</db:programlisting>
<db:para>We can use these slider widgets to rotate the graph instead of just using the mouse or touch.</db:para>
<db:para>Let's add them to the vertical layout we created earlier:</db:para>
<db:programlisting language="cpp">vLayout-&amp;gt;addWidget(new QLabel(QStringLiteral(&quot;Rotate horizontally&quot;)));
vLayout-&amp;gt;addWidget(rotationSliderX, 0, Qt::AlignTop);
vLayout-&amp;gt;addWidget(new QLabel(QStringLiteral(&quot;Rotate vertically&quot;)));
vLayout-&amp;gt;addWidget(rotationSliderY, 0, Qt::AlignTop);
</db:programlisting>
<db:para>Then we'll connect them to methods in <db:code>GraphModifier</db:code>:</db:para>
<db:programlisting language="cpp">QObject::connect(rotationSliderX, &amp;amp;QSlider::valueChanged, modifier, &amp;amp;GraphModifier::rotateX);
QObject::connect(rotationSliderY, &amp;amp;QSlider::valueChanged, modifier, &amp;amp;GraphModifier::rotateY);
</db:programlisting>
<db:para>Here are the methods in <db:code>GraphModifier</db:code> the signals were connected to. The camera is controlled via the scene object. This time we specify the actual camera position along the orbit around the center point, instead of specifying a preset camera angle:</db:para>
<db:programlisting language="cpp">void GraphModifier::rotateX(int rotation)
{
    m_xRotation = rotation;
    m_graph-&amp;gt;scene()-&amp;gt;activeCamera()-&amp;gt;setCameraPosition(m_xRotation, m_yRotation);
}

void GraphModifier::rotateY(int rotation)
{
    m_yRotation = rotation;
    m_graph-&amp;gt;scene()-&amp;gt;activeCamera()-&amp;gt;setCameraPosition(m_xRotation, m_yRotation);
}
</db:programlisting>
<db:para>Now these two sliders can be used to rotate the graph.</db:para>
<db:para>And so we have an application in which we can control:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Graph rotation</db:para>
</db:listitem>
<db:listitem>
<db:para>Label style</db:para>
</db:listitem>
<db:listitem>
<db:para>Camera preset</db:para>
</db:listitem>
<db:listitem>
<db:para>Background visibility</db:para>
</db:listitem>
<db:listitem>
<db:para>Grid visibility</db:para>
</db:listitem>
<db:listitem>
<db:para>Bar shading smoothness</db:para>
</db:listitem>
<db:listitem>
<db:para>Visibility of the second bar series</db:para>
</db:listitem>
<db:listitem>
<db:para>Value axis direction</db:para>
</db:listitem>
<db:listitem>
<db:para>Axis title visibility and rotation</db:para>
</db:listitem>
<db:listitem>
<db:para>Data range to be shown</db:para>
</db:listitem>
<db:listitem>
<db:para>Bar style</db:para>
</db:listitem>
<db:listitem>
<db:para>Selection mode</db:para>
</db:listitem>
<db:listitem>
<db:para>Theme</db:para>
</db:listitem>
<db:listitem>
<db:para>Shadow quality</db:para>
</db:listitem>
<db:listitem>
<db:para>Font</db:para>
</db:listitem>
<db:listitem>
<db:para>Font size</db:para>
</db:listitem>
<db:listitem>
<db:para>Axis label rotation</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="selecting-a-row-column-by-clicking-an-axis-label">
<db:title>Selecting a Row/column by Clicking an Axis Label</db:title>
<db:para>Selection by axis label is default functionality for bar graphs. As an example, you can select rows by clicking an axis label in the following way:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Change selection mode to <db:code>SelectionRow</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para>Click a year label</db:para>
</db:listitem>
<db:listitem>
<db:para>The row with the clicked year is selected</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>You can use the same method with <db:code>SelectionSlice</db:code> and <db:code>SelectionItem</db:code> flags, as long as you have either <db:code>SelectionRow</db:code> or <db:code>SelectionColumn</db:code> set as well.</db:para>
</db:section>
<db:section xml:id="zooming-to-selection">
<db:title>Zooming to Selection</db:title>
<db:para>As an example of adjusting camera target we have implemented an animation of zooming to selection via a button press. Animation initializations are done in the constructor:</db:para>
<db:programlisting language="cpp">Q3DCamera *camera = m_graph-&amp;gt;scene()-&amp;gt;activeCamera();
m_defaultAngleX = camera-&amp;gt;xRotation();
m_defaultAngleY = camera-&amp;gt;yRotation();
m_defaultZoom = camera-&amp;gt;zoomLevel();
m_defaultTarget = camera-&amp;gt;target();

m_animationCameraX.setTargetObject(camera);
m_animationCameraY.setTargetObject(camera);
m_animationCameraZoom.setTargetObject(camera);
m_animationCameraTarget.setTargetObject(camera);

m_animationCameraX.setPropertyName(&quot;xRotation&quot;);
m_animationCameraY.setPropertyName(&quot;yRotation&quot;);
m_animationCameraZoom.setPropertyName(&quot;zoomLevel&quot;);
m_animationCameraTarget.setPropertyName(&quot;target&quot;);

int duration = 1700;
m_animationCameraX.setDuration(duration);
m_animationCameraY.setDuration(duration);
m_animationCameraZoom.setDuration(duration);
m_animationCameraTarget.setDuration(duration);

// The zoom always first zooms out above the graph and then zooms in
qreal zoomOutFraction = 0.3;
m_animationCameraX.setKeyValueAt(zoomOutFraction, QVariant::fromValue(0.0f));
m_animationCameraY.setKeyValueAt(zoomOutFraction, QVariant::fromValue(90.0f));
m_animationCameraZoom.setKeyValueAt(zoomOutFraction, QVariant::fromValue(50.0f));
m_animationCameraTarget.setKeyValueAt(zoomOutFraction,
                                      QVariant::fromValue(QVector3D(0.0f, 0.0f, 0.0f)));
</db:programlisting>
<db:para>The function <db:code>GraphModifier::zoomToSelectedBar()</db:code> contains the rest of the functionality:</db:para>
<db:programlisting language="cpp">void GraphModifier::zoomToSelectedBar()
{
    m_animationCameraX.stop();
    m_animationCameraY.stop();
    m_animationCameraZoom.stop();
    m_animationCameraTarget.stop();

    Q3DCamera *camera = m_graph-&amp;gt;scene()-&amp;gt;activeCamera();
    float currentX = camera-&amp;gt;xRotation();
    float currentY = camera-&amp;gt;yRotation();
    float currentZoom = camera-&amp;gt;zoomLevel();
    QVector3D currentTarget = camera-&amp;gt;target();

    m_animationCameraX.setStartValue(QVariant::fromValue(currentX));
    m_animationCameraY.setStartValue(QVariant::fromValue(currentY));
    m_animationCameraZoom.setStartValue(QVariant::fromValue(currentZoom));
    m_animationCameraTarget.setStartValue(QVariant::fromValue(currentTarget));

    QPoint selectedBar = m_graph-&amp;gt;selectedSeries()
            ? m_graph-&amp;gt;selectedSeries()-&amp;gt;selectedBar()
            : QBar3DSeries::invalidSelectionPosition();

    if (selectedBar != QBar3DSeries::invalidSelectionPosition()) {
        // Normalize selected bar position within axis range to determine target coordinates
        QVector3D endTarget;
        float xMin = m_graph-&amp;gt;columnAxis()-&amp;gt;min();
        float xRange = m_graph-&amp;gt;columnAxis()-&amp;gt;max() - xMin;
        float zMin = m_graph-&amp;gt;rowAxis()-&amp;gt;min();
        float zRange = m_graph-&amp;gt;rowAxis()-&amp;gt;max() - zMin;
        endTarget.setX((selectedBar.y() - xMin) / xRange * 2.0f - 1.0f);
        endTarget.setZ((selectedBar.x() - zMin) / zRange * 2.0f - 1.0f);

        // Rotate the camera so that it always points approximately to the graph center
        qreal endAngleX = 90.0 - qRadiansToDegrees(qAtan(qreal(endTarget.z() / endTarget.x())));
        if (endTarget.x() &amp;gt; 0.0f)
            endAngleX -= 180.0f;
        float barValue = m_graph-&amp;gt;selectedSeries()-&amp;gt;dataProxy()-&amp;gt;itemAt(selectedBar.x(),
                                                                        selectedBar.y())-&amp;gt;value();
        float endAngleY = barValue &amp;gt;= 0.0f ? 30.0f : -30.0f;
        if (m_graph-&amp;gt;valueAxis()-&amp;gt;reversed())
            endAngleY *= -1.0f;

        m_animationCameraX.setEndValue(QVariant::fromValue(float(endAngleX)));
        m_animationCameraY.setEndValue(QVariant::fromValue(endAngleY));
        m_animationCameraZoom.setEndValue(QVariant::fromValue(250));
        m_animationCameraTarget.setEndValue(QVariant::fromValue(endTarget));
    } else {
        // No selected bar, so return to the default view
        m_animationCameraX.setEndValue(QVariant::fromValue(m_defaultAngleX));
        m_animationCameraY.setEndValue(QVariant::fromValue(m_defaultAngleY));
        m_animationCameraZoom.setEndValue(QVariant::fromValue(m_defaultZoom));
        m_animationCameraTarget.setEndValue(QVariant::fromValue(m_defaultTarget));
    }

    m_animationCameraX.start();
    m_animationCameraY.start();
    m_animationCameraZoom.start();
    m_animationCameraTarget.start();
}
</db:programlisting>
<db:para>The <db:link xlink:href="qpropertyanimation.xml">QPropertyAnimation</db:link> <db:code>m_animationCameraTarget</db:code> targets <db:link xlink:href="q3dcamera.xml#target-prop">Q3DCamera::target</db:link> property, which takes a value normalized to the range (-1, 1). We figure out where the selected bar is relative to axes, and use that as the end value for <db:code>m_animationCameraTarget</db:code>:</db:para>
<db:programlisting language="cpp">QVector3D endTarget;
float xMin = m_graph-&amp;gt;columnAxis()-&amp;gt;min();
float xRange = m_graph-&amp;gt;columnAxis()-&amp;gt;max() - xMin;
float zMin = m_graph-&amp;gt;rowAxis()-&amp;gt;min();
float zRange = m_graph-&amp;gt;rowAxis()-&amp;gt;max() - zMin;
endTarget.setX((selectedBar.y() - xMin) / xRange * 2.0f - 1.0f);
endTarget.setZ((selectedBar.x() - zMin) / zRange * 2.0f - 1.0f);
    ...
m_animationCameraTarget.setEndValue(QVariant::fromValue(endTarget));
</db:programlisting>
<db:para>Likewise, we want to angle the camera so that it always points approximately to the center of the graph at the end of the animation:</db:para>
<db:programlisting language="cpp">qreal endAngleX = 90.0 - qRadiansToDegrees(qAtan(qreal(endTarget.z() / endTarget.x())));
if (endTarget.x() &amp;gt; 0.0f)
    endAngleX -= 180.0f;
float barValue = m_graph-&amp;gt;selectedSeries()-&amp;gt;dataProxy()-&amp;gt;itemAt(selectedBar.x(),
                                                                selectedBar.y())-&amp;gt;value();
float endAngleY = barValue &amp;gt;= 0.0f ? 30.0f : -30.0f;
if (m_graph-&amp;gt;valueAxis()-&amp;gt;reversed())
    endAngleY *= -1.0f;
</db:programlisting>
</db:section>
<db:section xml:id="example-contents">
<db:title>Example Contents</db:title>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="bars/bars.pro">bars/bars.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="bars/graphmodifier.cpp">bars/graphmodifier.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="bars/graphmodifier.h">bars/graphmodifier.h</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="bars/main.cpp">bars/main.cpp</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
</db:section></db:article>
