<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QRemoteObjectNode Class</db:title>
<db:productname>QtRemoteObjects</db:productname>
<db:edition>Qt 6.4.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Remote Objects Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A node on a Qt Remote Objects network.</db:para>
</db:abstract>
<db:pubdate>2024-01-26</db:pubdate>
<db:date>2024-01-26</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QRemoteObjectNode</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS RemoteObjects)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::RemoteObjects)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += remoteobjects</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qremoteobjecthostbase.xml" xlink:role="class">QRemoteObjectHostBase</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Instantiated By</db:term>
<db:listitem>
<db:para>qml-qtremoteobjects-node.xml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qremoteobjecthostbase.xml" xlink:role="class">QRemoteObjectHostBase</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link> class provides an entry point to a <db:link xlink:href="qml-qtremoteobjects-qtremoteobjects.xml">QtRemoteObjects</db:link> network. A network can be as simple as two nodes, or an arbitrarily complex set of processes and devices.</db:para>
<db:para>A <db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link> does not have a url that other nodes can connect to, and thus is able to acquire replicas only. It is not able to share source objects (only <db:link xlink:href="qremoteobjecthost.xml">QRemoteObjectHost</db:link> and <db:link xlink:href="qremoteobjectregistryhost.xml">QRemoteObjectRegistryHost</db:link> Nodes can share).</db:para>
<db:para>Nodes may connect to each other directly using <db:link xlink:href="qremoteobjectnode.xml#connectToNode">connectToNode</db:link>, or they can use the <db:link xlink:href="qremoteobjectregistry.xml">QRemoteObjectRegistry</db:link> to simplify connections.</db:para>
<db:para>The <db:link xlink:href="qremoteobjectregistry.xml">QRemoteObjectRegistry</db:link> is a special replica available to every node that connects to the Registry Url. It knows how to connect to every QRemoteObjectSource object on the network.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qremoteobjecthost.xml">QRemoteObjectHost</db:link></db:member>
<db:member><db:link xlink:href="qremoteobjectregistryhost.xml">QRemoteObjectRegistryHost</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="ErrorCode-enum">
<db:title>enum QRemoteObjectNode::ErrorCode</db:title>
<db:enumsynopsis>
<db:enumname>ErrorCode</db:enumname>
<db:enumitem>
<db:enumidentifier>NoError</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RegistryNotAcquired</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>RegistryAlreadyHosted</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NodeIsNoServer</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ServerAlreadyCreated</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UnintendedRegistryHosting</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>OperationNotValidOnClientNode</db:enumidentifier>
<db:enumvalue>6</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SourceNotRegistered</db:enumidentifier>
<db:enumvalue>7</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>MissingObjectName</db:enumidentifier>
<db:enumvalue>8</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>HostUrlInvalid</db:enumidentifier>
<db:enumvalue>9</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ProtocolMismatch</db:enumidentifier>
<db:enumvalue>10</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ListenFailed</db:enumidentifier>
<db:enumvalue>11</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum type specifies the various error codes associated with <db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link> errors:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link></db:emphasis>::NoError</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>No error.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link></db:emphasis>::RegistryNotAcquired</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The registry could not be acquired.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link></db:emphasis>::RegistryAlreadyHosted</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The registry is already defined and hosting Sources.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link></db:emphasis>::NodeIsNoServer</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The given <db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link> is not a host node.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link></db:emphasis>::ServerAlreadyCreated</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The host node has already been initialized.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link></db:emphasis>::UnintendedRegistryHosting</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>An attempt was made to create a host <db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link> and connect to itself as the registry.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link></db:emphasis>::OperationNotValidOnClientNode</db:code></db:para>
</db:td>
<db:td><db:code>6</db:code></db:td>
<db:td>
<db:para>The attempted operation is not valid on a client <db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link></db:emphasis>::SourceNotRegistered</db:code></db:para>
</db:td>
<db:td><db:code>7</db:code></db:td>
<db:td>
<db:para>The given QRemoteObjectSource is not registered on this node.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link></db:emphasis>::MissingObjectName</db:code></db:para>
</db:td>
<db:td><db:code>8</db:code></db:td>
<db:td>
<db:para>The given <db:link xlink:href="qobject.xml">QObject</db:link> does not have <db:link xlink:href="qobject.xml#objectName-prop">objectName</db:link>() set.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link></db:emphasis>::HostUrlInvalid</db:code></db:para>
</db:td>
<db:td><db:code>9</db:code></db:td>
<db:td>
<db:para>The given url has an invalid or unrecognized scheme.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link></db:emphasis>::ProtocolMismatch</db:code></db:para>
</db:td>
<db:td><db:code>10</db:code></db:td>
<db:td>
<db:para>The client and the server have different protocol versions.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link></db:emphasis>::ListenFailed</db:code></db:para>
</db:td>
<db:td><db:code>11</db:code></db:td>
<db:td>
<db:para>Can't listen on the specified host port.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
<db:section xml:id="RemoteObjectSchemaHandler-typedef">
<db:title>[since 5.12] QRemoteObjectNode::RemoteObjectSchemaHandler</db:title>
<db:typedefsynopsis>
<db:typedefname>RemoteObjectSchemaHandler</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>Typedef for a std::function method that can take a <db:link xlink:href="qurl.xml">QUrl</db:link> input and is responsible for creating the communications channel between this node and the node hosting the desired <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link>. As some types of QIODevices (e.g., <db:link xlink:href="qsslsocket.xml">QSslSocket</db:link>) require additional steps before the device is ready for use, the method is responsible for calling <db:link xlink:href="qremoteobjectnode.xml#addClientSideConnection">addClientSideConnection</db:link> once the connection is fully established.</db:para>
<db:para>This typedef was introduced in Qt 5.12.</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="heartbeatInterval-prop">
<db:title>heartbeatInterval : int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>heartbeatInterval</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">heartbeatInterval</db:synopsisinfo>
<db:synopsisinfo role="setter">setHeartbeatInterval</db:synopsisinfo>
<db:synopsisinfo role="notifier">heartbeatIntervalChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Heartbeat interval in ms.</db:para>
<db:para>The heartbeat (only helpful for socket connections) will periodically send a message to connected nodes to detect whether the connection was disrupted. Qt Remote Objects will try to reconnect automatically if it detects a dropped connection. This function can help with that detection since the client will only detect that the server is unavailable when it tries to send data.</db:para>
<db:para>A value of <db:code>0</db:code> (the default) will disable the heartbeat.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">heartbeatInterval</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setHeartbeatInterval</db:emphasis>(<db:type>int</db:type> <db:emphasis>interval</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">heartbeatIntervalChanged</db:emphasis>(<db:type>int</db:type> <db:emphasis>heartbeatInterval</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="persistedStore-prop">
<db:title>[since 5.11] persistedStore : QRemoteObjectAbstractPersistedStore*</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QRemoteObjectAbstractPersistedStore*</db:type>
<db:varname>persistedStore</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">persistedStore</db:synopsisinfo>
<db:synopsisinfo role="setter">setPersistedStore</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>Allows setting a <db:link xlink:href="qremoteobjectabstractpersistedstore.xml">QRemoteObjectAbstractPersistedStore</db:link> instance for the node.</db:para>
<db:para>Allows replica <db:link xlink:href="qtremoteobjects-repc.xml#prop">PROP</db:link> members with the PERSISTED trait to save their current value when the replica is deleted and restore a stored value the next time the replica is started.</db:para>
<db:para>Requires a <db:link xlink:href="qremoteobjectabstractpersistedstore.xml">QRemoteObjectAbstractPersistedStore</db:link> class implementation to control where and how persistence is handled.</db:para>
<db:para>This property was introduced in Qt 5.11.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qremoteobjectabstractpersistedstore.xml">QRemoteObjectAbstractPersistedStore</db:link></db:type> *<db:emphasis role="bold">persistedStore</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setPersistedStore</db:emphasis>(<db:type><db:link xlink:href="qremoteobjectabstractpersistedstore.xml">QRemoteObjectAbstractPersistedStore</db:link></db:type> *<db:emphasis>persistedStore</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="registryUrl-prop">
<db:title>registryUrl : QUrl</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QUrl</db:type>
<db:varname>registryUrl</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">registryUrl</db:synopsisinfo>
<db:synopsisinfo role="setter">setRegistryUrl</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the address of the <db:link xlink:href="qremoteobjectregistry.xml">Registry</db:link> used by this node.</db:para>
<db:para>This is an empty <db:link xlink:href="qurl.xml">QUrl</db:link> if there is no registry in use.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qurl.xml">QUrl</db:link></db:type> <db:emphasis role="bold">registryUrl</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para>virtual <db:type>bool</db:type> <db:emphasis role="bold">setRegistryUrl</db:emphasis>(const <db:type><db:link xlink:href="qurl.xml">QUrl</db:link></db:type> &amp;<db:emphasis>registryAddress</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QRemoteObjectNode">
<db:title>QRemoteObjectNode::QRemoteObjectNode(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QRemoteObjectNode</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QRemoteObjectNode(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Default constructor for <db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link> with the given <db:code role="parameter">parent</db:code>. A Node constructed in this manner can not be connected to, and thus can not expose Source objects on the network. It also will not include a <db:link xlink:href="qremoteobjectregistry.xml">QRemoteObjectRegistry</db:link>, unless set manually using <db:link xlink:href="qremoteobjectnode.xml#registryUrl-prop">setRegistryUrl</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qremoteobjectnode.xml#connectToNode">connectToNode</db:link></db:member>
<db:member><db:link xlink:href="qremoteobjectnode.xml#registryUrl-prop">setRegistryUrl</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QRemoteObjectNode-1">
<db:title>QRemoteObjectNode::QRemoteObjectNode(const QUrl &amp;<db:emphasis>registryAddress</db:emphasis>, QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QRemoteObjectNode</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>registryAddress</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QRemoteObjectNode(const QUrl &amp;registryAddress, QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para><db:link xlink:href="qremoteobjectnode.xml">QRemoteObjectNode</db:link> connected to a {<db:link xlink:href="qremoteobjectregistry.xml">QRemoteObjectRegistry</db:link>} {Registry}. A Node constructed in this manner can not be connected to, and thus can not expose Source objects on the network. Finding and connecting to other (Host) Nodes is handled by the <db:link xlink:href="qremoteobjectregistry.xml">QRemoteObjectRegistry</db:link> specified by <db:code role="parameter">registryAddress</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qremoteobjectnode.xml#connectToNode">connectToNode</db:link></db:member>
<db:member><db:link xlink:href="qremoteobjectnode.xml#registryUrl-prop">setRegistryUrl</db:link></db:member>
<db:member><db:link xlink:href="qremoteobjecthost.xml">QRemoteObjectHost</db:link></db:member>
<db:member><db:link xlink:href="qremoteobjectregistryhost.xml">QRemoteObjectRegistryHost</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="acquire">
<db:title>ObjectType *QRemoteObjectNode::acquire(const QString &amp;<db:emphasis>name</db:emphasis> = QString())</db:title>
<db:methodsynopsis>
<db:type>ObjectType *</db:type>
<db:methodname>acquire</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">ObjectType * acquire(const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to a Replica of type ObjectType (which is a template parameter and must inherit from <db:link xlink:href="qremoteobjectreplica.xml">QRemoteObjectReplica</db:link>). That is, the template parameter must be a <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link> generated type. The <db:code role="parameter">name</db:code> parameter can be used to specify the <db:code role="parameter">name</db:code> given to the object during the <db:link xlink:href="qremoteobjecthostbase.xml#enableRemoting">QRemoteObjectHost::enableRemoting</db:link>() call.</db:para>
</db:section>
<db:section xml:id="acquireDynamic">
<db:title>QRemoteObjectDynamicReplica *QRemoteObjectNode::acquireDynamic(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QRemoteObjectDynamicReplica *</db:type>
<db:methodname>acquireDynamic</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRemoteObjectDynamicReplica * acquireDynamic(const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a <db:link xlink:href="qremoteobjectdynamicreplica.xml">QRemoteObjectDynamicReplica</db:link> of the Source <db:code role="parameter">name</db:code>.</db:para>
</db:section>
<db:section xml:id="acquireModel">
<db:title>QAbstractItemModelReplica *QRemoteObjectNode::acquireModel(const QString &amp;<db:emphasis>name</db:emphasis>, QtRemoteObjects::InitialAction <db:emphasis>action</db:emphasis> = QtRemoteObjects::FetchRootSize, const QList&lt;int&gt; &amp;<db:emphasis>rolesHint</db:emphasis> = {})</db:title>
<db:methodsynopsis>
<db:type>QAbstractItemModelReplica *</db:type>
<db:methodname>acquireModel</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QtRemoteObjects::InitialAction</db:type>
<db:parameter>action</db:parameter>
<db:initializer>QtRemoteObjects::FetchRootSize</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QList&lt;int&gt; &amp;</db:type>
<db:parameter>rolesHint</db:parameter>
<db:initializer>{}</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QAbstractItemModelReplica * acquireModel(const QString &amp;name, QtRemoteObjects::InitialAction action, const QList&lt;int&gt; &amp;rolesHint)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to a <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link> which is specifically derived from <db:link xlink:href="qabstractitemmodel.xml">QAbstractItemModel</db:link>. The <db:code role="parameter">name</db:code> provided must match the name used with the matching <db:link xlink:href="qremoteobjecthostbase.xml#enableRemoting">enableRemoting</db:link> that put the <db:link xlink:href="qtremoteobjects-repc.xml#model">Model</db:link> on the network. <db:code role="parameter">action</db:code> specifies whether the model should fetch data before the <db:link xlink:href="qremoteobjectreplica.xml#initialized">initialized</db:link> signal is emitted. If it's set to <db:link xlink:href="qtremoteobjects.xml#InitialAction-enum">QtRemoteObjects::PrefetchData</db:link>, then the data for roles in the <db:code role="parameter">rolesHint</db:code> will be prefetched. If <db:code role="parameter">rolesHint</db:code> is empty, then the data for all the roles exposed by <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> will be prefetched.</db:para>
<db:para>The returned model will be empty until it is initialized with the <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link>.</db:para>
</db:section>
<db:section xml:id="addClientSideConnection">
<db:title>[since 5.12] void QRemoteObjectNode::addClientSideConnection(QIODevice *<db:emphasis>ioDevice</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>addClientSideConnection</db:methodname>
<db:methodparam>
<db:type>QIODevice *</db:type>
<db:parameter>ioDevice</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void addClientSideConnection(QIODevice *ioDevice)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>In order to <db:link xlink:href="qremoteobjectnode.xml#acquire">QRemoteObjectNode::acquire</db:link>() <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link> objects over <db:link xlink:href="qtremoteobjects-external-schemas.xml#external-qiodevices">External QIODevices</db:link>, Qt Remote Objects needs access to the communications channel (a <db:link xlink:href="qiodevice.xml">QIODevice</db:link>) between the respective nodes. It is the addClientSideConnection() call that enables this, taking the <db:code role="parameter">ioDevice</db:code> as input. Any <db:link xlink:href="qremoteobjectnode.xml#acquire">acquire</db:link>() call made without calling addClientSideConnection will still work, but the Node will not be able to initialize the <db:link xlink:href="qtremoteobjects-replica.xml#replica">Replica</db:link> without being provided the connection to the Host node.</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qremoteobjecthostbase.xml#addHostSideConnection">QRemoteObjectHostBase::addHostSideConnection</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="connectToNode">
<db:title>bool QRemoteObjectNode::connectToNode(const QUrl &amp;<db:emphasis>address</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>connectToNode</db:methodname>
<db:methodparam>
<db:type>const QUrl &amp;</db:type>
<db:parameter>address</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool connectToNode(const QUrl &amp;address)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Connects a client node to the host node at <db:code role="parameter">address</db:code>.</db:para>
<db:para>Connections will remain valid until the host node is deleted or no longer accessible over a network.</db:para>
<db:para>Once a client is connected to a host, valid Replicas can then be acquired if the corresponding Source is being remoted.</db:para>
<db:para>Return <db:code>true</db:code> on success, <db:code>false</db:code> otherwise (usually an unrecognized url, or connecting to already connected address).</db:para>
</db:section>
<db:section xml:id="instances">
<db:title>QStringList QRemoteObjectNode::instances() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>instances</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList instances() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This templated function (taking a <db:link xlink:href="qtremoteobjects-repc.xml">repc</db:link> generated type as the template parameter) will return the list of names of every instance of that type on the Remote Objects network. For example, if you have a Shape class defined in a .rep file, and Circle and Square classes inherit from the Source definition, they can be shared on the Remote Objects network using <db:link xlink:href="qremoteobjecthostbase.xml#enableRemoting">enableRemoting</db:link>.</db:para>
<db:programlisting language="cpp">Square square;
Circle circle;
myHost.enableRemoting(&amp;amp;square, &quot;Square&quot;);
myHost.enableRemoting(&amp;amp;circle, &quot;Circle&quot;);
</db:programlisting>
<db:para>Then instance can be used to find the available instances of Shape.</db:para>
<db:programlisting language="cpp">QStringList instances = clientNode.instances&amp;lt;Shape&amp;gt;();
// will return a QStringList containing &quot;Circle&quot; and &quot;Square&quot;
auto instance1 = clientNode.acquire&amp;lt;Shape&amp;gt;(&quot;Circle&quot;);
auto instance2 = clientNode.acquire&amp;lt;Shape&amp;gt;(&quot;Square&quot;);
...
</db:programlisting>
</db:section>
<db:section xml:id="instances-1">
<db:title>QStringList QRemoteObjectNode::instances(QStringView <db:emphasis>typeName</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QStringList</db:type>
<db:methodname>instances</db:methodname>
<db:methodparam>
<db:type>QStringView</db:type>
<db:parameter>typeName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QStringList instances(QStringView typeName) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads <db:link xlink:href="qremoteobjectnode.xml#instances">instances</db:link>().</db:para>
<db:para>This convenience function provides the same result as the templated version, but takes the name of the <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> class as a parameter (<db:code role="parameter">typeName</db:code>) rather than deriving it from the class type.</db:para>
</db:section>
<db:section xml:id="lastError">
<db:title>QRemoteObjectNode::ErrorCode QRemoteObjectNode::lastError() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QRemoteObjectNode::ErrorCode</db:type>
<db:methodname>lastError</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QRemoteObjectNode::ErrorCode lastError() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the last error set.</db:para>
</db:section>
<db:section xml:id="registerExternalSchema">
<db:title>[since 5.12] void QRemoteObjectNode::registerExternalSchema(const QString &amp;<db:emphasis>schema</db:emphasis>, QRemoteObjectNode::RemoteObjectSchemaHandler <db:emphasis>handler</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>registerExternalSchema</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>schema</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QRemoteObjectNode::RemoteObjectSchemaHandler</db:type>
<db:parameter>handler</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void registerExternalSchema(const QString &amp;schema, QRemoteObjectNode::RemoteObjectSchemaHandler handler)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Provide a custom method to handle externally provided schemas</db:para>
<db:para>This method is tied to the <db:link xlink:href="qtremoteobjects-registry.xml#registry">Registry</db:link> and <db:link xlink:href="qtremoteobjects-external-schemas.xml#external-schemas">External Schemas</db:link>. By registering a std::function handler for an external schema, the registered method will be called when the registry is notified of a <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> you've acquired being available. Without this registration, QtRO would only be able to handle the &quot;built-in&quot; schemas.</db:para>
<db:para>The provided method, <db:code role="parameter">handler</db:code>, will be called when the registry sees a <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> object on a new (not yet connected) Node with a {QUrl::schema()} of <db:code role="parameter">schema</db:code>. The <db:code role="parameter">handler</db:code>, of type <db:link xlink:href="qremoteobjectnode.xml#RemoteObjectSchemaHandler-typedef">QRemoteObjectNode::RemoteObjectSchemaHandler</db:link> will get the <db:link xlink:href="qurl.xml">QUrl</db:link> of the Node providing the <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> as an input parameter, and is responsible for establishing the communications channel (a <db:link xlink:href="qiodevice.xml">QIODevice</db:link> of some sort) and calling <db:link xlink:href="qremoteobjectnode.xml#addClientSideConnection">addClientSideConnection</db:link> with it.</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qremoteobjectnode.xml#RemoteObjectSchemaHandler-typedef">RemoteObjectSchemaHandler</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="registry">
<db:title>const QRemoteObjectRegistry *QRemoteObjectNode::registry() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QRemoteObjectRegistry *</db:type>
<db:methodname>registry</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QRemoteObjectRegistry * registry() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a pointer to the Node's <db:link xlink:href="qremoteobjectregistry.xml">QRemoteObjectRegistry</db:link>, if the Node is using the Registry feature; otherwise it returns <db:code>nullptr</db:code>.</db:para>
</db:section>
<db:section xml:id="remoteObjectAdded">
<db:title>void QRemoteObjectNode::remoteObjectAdded(const QRemoteObjectSourceLocation &amp;<db:emphasis>loc</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>remoteObjectAdded</db:methodname>
<db:methodparam>
<db:type>const QRemoteObjectSourceLocation &amp;</db:type>
<db:parameter>loc</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void remoteObjectAdded(const QRemoteObjectSourceLocation &amp;loc)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever a new <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> object is added to the Registry. The signal will not be emitted if there is no Registry set (i.e., Sources over connections made via <db:link xlink:href="qremoteobjectnode.xml#connectToNode">connectToNode</db:link> directly). The <db:code role="parameter">loc</db:code> parameter contains the information about the added Source, including name, type and the <db:link xlink:href="qurl.xml">QUrl</db:link> of the hosting Node.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qremoteobjectnode.xml#remoteObjectRemoved">remoteObjectRemoved</db:link>()</db:member>
<db:member><db:link xlink:href="qremoteobjectnode.xml#instances">instances</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remoteObjectRemoved">
<db:title>void QRemoteObjectNode::remoteObjectRemoved(const QRemoteObjectSourceLocation &amp;<db:emphasis>loc</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>remoteObjectRemoved</db:methodname>
<db:methodparam>
<db:type>const QRemoteObjectSourceLocation &amp;</db:type>
<db:parameter>loc</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void remoteObjectRemoved(const QRemoteObjectSourceLocation &amp;loc)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever a known <db:link xlink:href="qtremoteobjects-source.xml#source">Source</db:link> object is removed from the Registry. The signal will not be emitted if there is no Registry set (i.e., Sources over connections made via <db:link xlink:href="qremoteobjectnode.xml#connectToNode">connectToNode</db:link> directly). The <db:code role="parameter">loc</db:code> parameter contains the information about the removed Source, including name, type and the <db:link xlink:href="qurl.xml">QUrl</db:link> of the hosting Node.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qremoteobjectnode.xml#remoteObjectAdded">remoteObjectAdded</db:link></db:member>
<db:member><db:link xlink:href="qremoteobjectnode.xml#instances">instances</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setName">
<db:title>[virtual] void QRemoteObjectNode::setName(const QString &amp;<db:emphasis>name</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>setName</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>name</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setName(const QString &amp;name)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets <db:code role="parameter">name</db:code> as the internal name for this Node. This is then output as part of the logging (if enabled). This is primarily useful if you merge log data from multiple nodes.</db:para>
</db:section>
<db:section xml:id="timerEvent">
<db:title>[override virtual protected] void QRemoteObjectNode::timerEvent(<db:emphasis>QTimerEvent *</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>timerEvent</db:methodname>
<db:methodparam>
<db:type>QTimerEvent *</db:type>
<db:parameter></db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void timerEvent(QTimerEvent *) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qobject.xml#timerEvent" role="function">QObject::timerEvent(QTimerEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="waitForRegistry">
<db:title>bool QRemoteObjectNode::waitForRegistry(int <db:emphasis>timeout</db:emphasis> = 30000)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>waitForRegistry</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>timeout</db:parameter>
<db:initializer>30000</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool waitForRegistry(int timeout)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Blocks until this Node's <db:link xlink:href="qtremoteobjects-registry.xml#registry">Registry</db:link> is initialized or <db:code role="parameter">timeout</db:code> (in milliseconds) expires. Returns <db:code>true</db:code> if the <db:link xlink:href="qtremoteobjects-registry.xml#registry">Registry</db:link> is successfully initialized upon return, or <db:code>false</db:code> otherwise.</db:para>
</db:section>
</db:section>
</db:article>
