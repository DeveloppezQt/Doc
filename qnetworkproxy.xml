<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QNetworkProxy Class</db:title>
<db:productname>QtNetwork</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Network Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> class provides a network layer proxy.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QNetworkProxy</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Network)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Network)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += network</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QNetworkProxy is part of <db:simplelist><db:member><db:link xlink:href="network.xml">Network Programming API</db:link></db:member><db:member>shared</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> provides the method for configuring network layer proxy support to the Qt network classes. The currently supported classes are <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link>, <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link>, <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link>, <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> and <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>. The proxy support is designed to be as transparent as possible. This means that existing network-enabled applications that you have written should automatically support network proxy using the following code.</db:para>
<db:programlisting language="cpp">QNetworkProxy proxy;
proxy.setType(QNetworkProxy::Socks5Proxy);
proxy.setHostName(&quot;proxy.example.com&quot;);
proxy.setPort(1080);
proxy.setUser(&quot;username&quot;);
proxy.setPassword(&quot;password&quot;);
QNetworkProxy::setApplicationProxy(proxy);
</db:programlisting>
<db:para>An alternative to setting an application wide proxy is to specify the proxy for individual sockets using <db:link xlink:href="qabstractsocket.xml#setProxy">QAbstractSocket::setProxy</db:link>() and <db:link xlink:href="qtcpserver.xml#setProxy">QTcpServer::setProxy</db:link>(). In this way, it is possible to disable the use of a proxy for specific sockets using the following code:</db:para>
<db:programlisting language="cpp">serverSocket-&amp;gt;setProxy(QNetworkProxy::NoProxy);
</db:programlisting>
<db:para>Network proxy is not used if the address used in <db:link xlink:href="qabstractsocket.xml#connectToHost">connectToHost</db:link>(), <db:link xlink:href="qabstractsocket.xml#bind">bind</db:link>() or <db:link xlink:href="qtcpserver.xml#listen">listen</db:link>() is equivalent to <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::LocalHost</db:link> or <db:link xlink:href="qhostaddress.xml#SpecialAddress-enum">QHostAddress::LocalHostIPv6</db:link>.</db:para>
<db:para>Each type of proxy support has certain restrictions associated with it. You should read the <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">ProxyType</db:link> documentation carefully before selecting a proxy type to use.</db:para>
<db:note>
<db:para>Changes made to currently connected sockets do not take effect. If you need to change a connected socket, you should reconnect it.</db:para>
</db:note>
<db:section xml:id="socks5">
<db:title>SOCKS5</db:title>
<db:para>The SOCKS5 support since Qt 4 is based on <db:link xlink:href="http://www.rfc-editor.org/rfc/rfc1928.txt">RFC 1928</db:link> and <db:link xlink:href="http://www.rfc-editor.org/rfc/rfc1929.txt">RFC 1929</db:link>. The supported authentication methods are no authentication and username/password authentication. Both IPv4 and IPv6 are supported. Domain names are resolved through the SOCKS5 server if the <db:link xlink:href="qnetworkproxy.xml#Capability-enum">QNetworkProxy::HostNameLookupCapability</db:link> is enabled, otherwise they are resolved locally and the IP address is sent to the server. There are several things to remember when using SOCKS5 with <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link> and <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link>:</db:para>
<db:para>With <db:link xlink:href="qudpsocket.xml">QUdpSocket</db:link>, a call to <db:link xlink:href="qabstractsocket.xml#bind">bind</db:link>() may fail with a timeout error. If a port number other than 0 is passed to <db:link xlink:href="qabstractsocket.xml#bind">bind</db:link>(), it is not guaranteed that it is the specified port that will be used. Use <db:link xlink:href="qabstractsocket.xml#localPort">localPort</db:link>() and <db:link xlink:href="qabstractsocket.xml#localAddress">localAddress</db:link>() to get the actual address and port number in use. Because proxied UDP goes through two UDP connections, it is more likely that packets will be dropped.</db:para>
<db:para>With <db:link xlink:href="qtcpserver.xml">QTcpServer</db:link> a call to <db:link xlink:href="qtcpserver.xml#listen">listen</db:link>() may fail with a timeout error. If a port number other than 0 is passed to <db:link xlink:href="qtcpserver.xml#listen">listen</db:link>(), then it is not guaranteed that it is the specified port that will be used. Use <db:link xlink:href="qtcpserver.xml#serverPort">serverPort</db:link>() and <db:link xlink:href="qtcpserver.xml#serverAddress">serverAddress</db:link>() to get the actual address and port used to listen for connections. SOCKS5 only supports one accepted connection per call to <db:link xlink:href="qtcpserver.xml#listen">listen</db:link>(), and each call is likely to result in a different <db:link xlink:href="qtcpserver.xml#serverPort">serverPort</db:link>() being used.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link></db:member>
<db:member><db:link xlink:href="qtcpserver.xml">QTcpServer</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="Capability-enum">
<db:title>enum QNetworkProxy::Capability</db:title>
<db:bridgehead renderas="sect2">flags QNetworkProxy::Capabilities</db:bridgehead>
<db:enumsynopsis>
<db:enumname>Capability</db:enumname>
<db:enumitem>
<db:enumidentifier>TunnelingCapability</db:enumidentifier>
<db:enumvalue>0x0001</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>ListeningCapability</db:enumidentifier>
<db:enumvalue>0x0002</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>UdpTunnelingCapability</db:enumidentifier>
<db:enumvalue>0x0004</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>CachingCapability</db:enumidentifier>
<db:enumvalue>0x0008</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>HostNameLookupCapability</db:enumidentifier>
<db:enumvalue>0x0010</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SctpTunnelingCapability</db:enumidentifier>
<db:enumvalue>0x00020</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>SctpListeningCapability</db:enumidentifier>
<db:enumvalue>0x00040</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QNetworkProxy::Capabilities</db:typedefname>
</db:typedefsynopsis>
<db:para>These flags indicate the capabilities that a given proxy server supports.</db:para>
<db:para><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> sets different capabilities by default when the object is created (see <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::ProxyType</db:link> for a list of the defaults). However, it is possible to change the capabilities after the object has been created with <db:link xlink:href="qnetworkproxy.xml#setCapabilities">setCapabilities</db:link>().</db:para>
<db:para>The capabilities that <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> supports are:</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::TunnelingCapability</db:code></db:para>
</db:td>
<db:td><db:code>0x0001</db:code></db:td>
<db:td>
<db:para>Ability to open transparent, tunneled TCP connections to a remote host. The proxy server relays the transmission verbatim from one side to the other and does no caching.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::ListeningCapability</db:code></db:para>
</db:td>
<db:td><db:code>0x0002</db:code></db:td>
<db:td>
<db:para>Ability to create a listening socket and wait for an incoming TCP connection from a remote host.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::UdpTunnelingCapability</db:code></db:para>
</db:td>
<db:td><db:code>0x0004</db:code></db:td>
<db:td>
<db:para>Ability to relay UDP datagrams via the proxy server to and from a remote host.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::CachingCapability</db:code></db:para>
</db:td>
<db:td><db:code>0x0008</db:code></db:td>
<db:td>
<db:para>Ability to cache the contents of the transfer. This capability is specific to each protocol and proxy type. For example, HTTP proxies can cache the contents of web data transferred with &quot;GET&quot; commands.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::HostNameLookupCapability</db:code></db:para>
</db:td>
<db:td><db:code>0x0010</db:code></db:td>
<db:td>
<db:para>Ability to connect to perform the lookup on a remote host name and connect to it, as opposed to requiring the application to perform the name lookup and request connection to IP addresses only.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::SctpTunnelingCapability</db:code></db:para>
</db:td>
<db:td><db:code>0x00020</db:code></db:td>
<db:td>
<db:para>Ability to open transparent, tunneled SCTP connections to a remote host.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::SctpListeningCapability</db:code></db:para>
</db:td>
<db:td><db:code>0x00040</db:code></db:td>
<db:td>
<db:para>Ability to create a listening socket and wait for an incoming SCTP connection from a remote host.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>Capabilities</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;Capability&gt;. </db:code>It stores an OR combination of <db:code>Capability</db:code> values.</db:para>
</db:section>
<db:section xml:id="ProxyType-enum">
<db:title>enum QNetworkProxy::ProxyType</db:title>
<db:enumsynopsis>
<db:enumname>ProxyType</db:enumname>
<db:enumitem>
<db:enumidentifier>DefaultProxy</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Socks5Proxy</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NoProxy</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>HttpProxy</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>HttpCachingProxy</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>FtpCachingProxy</db:enumidentifier>
<db:enumvalue>5</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the types of network proxying provided in Qt.</db:para>
<db:para>There are two types of proxies that Qt understands: transparent proxies and caching proxies. The first group consists of proxies that can handle any arbitrary data transfer, while the second can only handle specific requests. The caching proxies only make sense for the specific classes where they can be used.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::NoProxy</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>No proxying is used</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::DefaultProxy</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>Proxy is determined based on the application proxy set using <db:link xlink:href="qnetworkproxy.xml#setApplicationProxy">setApplicationProxy</db:link>()</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::Socks5Proxy</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para><db:link xlink:href="qnetworkproxy.xml#socks5">Socks5</db:link> proxying is used</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::HttpProxy</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>HTTP transparent proxying is used</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::HttpCachingProxy</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>Proxying for HTTP requests only</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link></db:emphasis>::FtpCachingProxy</db:code></db:para>
</db:td>
<db:td><db:code>5</db:code></db:td>
<db:td>
<db:para>Proxying for FTP requests only</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The table below lists different proxy types and their capabilities. Since each proxy type has different capabilities, it is important to understand them before choosing a proxy type.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Proxy type</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
<db:th>
<db:para>Default capabilities</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>SOCKS 5</db:para>
</db:td>
<db:td>
<db:para>Generic proxy for any kind of connection. Supports TCP, UDP, binding to a port (incoming connections) and authentication.</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qnetworkproxy.xml#Capability-enum">TunnelingCapability</db:link>, <db:link xlink:href="qnetworkproxy.xml#Capability-enum">ListeningCapability</db:link>, <db:link xlink:href="qnetworkproxy.xml#Capability-enum">UdpTunnelingCapability</db:link>, <db:link xlink:href="qnetworkproxy.xml#Capability-enum">HostNameLookupCapability</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>HTTP</db:para>
</db:td>
<db:td>
<db:para>Implemented using the &quot;CONNECT&quot; command, supports only outgoing TCP connections; supports authentication.</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qnetworkproxy.xml#Capability-enum">TunnelingCapability</db:link>, <db:link xlink:href="qnetworkproxy.xml#Capability-enum">CachingCapability</db:link>, <db:link xlink:href="qnetworkproxy.xml#Capability-enum">HostNameLookupCapability</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Caching-only HTTP</db:para>
</db:td>
<db:td>
<db:para>Implemented using normal HTTP commands, it is useful only in the context of HTTP requests (see <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>)</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qnetworkproxy.xml#Capability-enum">CachingCapability</db:link>, <db:link xlink:href="qnetworkproxy.xml#Capability-enum">HostNameLookupCapability</db:link></db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>Caching FTP</db:para>
</db:td>
<db:td>
<db:para>Implemented using an FTP proxy, it is useful only in the context of FTP requests (see <db:link xlink:href="qnetworkaccessmanager.xml">QNetworkAccessManager</db:link>)</db:para>
</db:td>
<db:td>
<db:para><db:link xlink:href="qnetworkproxy.xml#Capability-enum">CachingCapability</db:link>, <db:link xlink:href="qnetworkproxy.xml#Capability-enum">HostNameLookupCapability</db:link></db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Also note that you shouldn't set the application default proxy (<db:link xlink:href="qnetworkproxy.xml#setApplicationProxy">setApplicationProxy</db:link>()) to a proxy that doesn't have the <db:link xlink:href="qnetworkproxy.xml#Capability-enum">TunnelingCapability</db:link> capability. If you do, <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> will not know how to open connections.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#setType">setType</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#capabilities">capabilities</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setCapabilities">setCapabilities</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QNetworkProxy">
<db:title>QNetworkProxy::QNetworkProxy()</db:title>
<db:constructorsynopsis>
<db:methodname>QNetworkProxy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkProxy()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> with <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">DefaultProxy</db:link> type.</db:para>
<db:para>The proxy type is determined by <db:link xlink:href="qnetworkproxy.xml#applicationProxy">applicationProxy</db:link>(), which defaults to <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">NoProxy</db:link> or a system-wide proxy if one is configured.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#setType">setType</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setApplicationProxy">setApplicationProxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QNetworkProxy-1">
<db:title>QNetworkProxy::QNetworkProxy(QNetworkProxy::ProxyType <db:emphasis>type</db:emphasis>, const QString &amp;<db:emphasis>hostName</db:emphasis> = QString(), quint16 <db:emphasis>port</db:emphasis> = 0, const QString &amp;<db:emphasis>user</db:emphasis> = QString(), const QString &amp;<db:emphasis>password</db:emphasis> = QString())</db:title>
<db:constructorsynopsis>
<db:methodname>QNetworkProxy</db:methodname>
<db:methodparam>
<db:type>QNetworkProxy::ProxyType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>hostName</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
<db:initializer>0</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>user</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>password</db:parameter>
<db:initializer>QString()</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkProxy(QNetworkProxy::ProxyType type, const QString &amp;hostName, quint16 port, const QString &amp;user, const QString &amp;password)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> with <db:code role="parameter">type</db:code>, <db:code role="parameter">hostName</db:code>, <db:code role="parameter">port</db:code>, <db:code role="parameter">user</db:code> and <db:code role="parameter">password</db:code>.</db:para>
<db:para>The default capabilities for proxy type <db:code role="parameter">type</db:code> are set automatically.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#capabilities">capabilities</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="QNetworkProxy-2">
<db:title>QNetworkProxy::QNetworkProxy(const QNetworkProxy &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:constructorsynopsis>
<db:methodname>QNetworkProxy</db:methodname>
<db:methodparam>
<db:type>const QNetworkProxy &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-constructor</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkProxy(const QNetworkProxy &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a copy of <db:code role="parameter">other</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QNetworkProxy">
<db:title>QNetworkProxy::~QNetworkProxy()</db:title>
<db:destructorsynopsis>
<db:methodname>~QNetworkProxy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QNetworkProxy()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> object.</db:para>
</db:section>
<db:section xml:id="applicationProxy">
<db:title>[static] QNetworkProxy QNetworkProxy::applicationProxy()</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:type>QNetworkProxy</db:type>
<db:methodname>applicationProxy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkProxy applicationProxy()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the application level network proxying.</db:para>
<db:para>If a <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> or <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> has the <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::DefaultProxy</db:link> type, then the <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> returned by this function is used.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxyfactory.xml">QNetworkProxyFactory</db:link></db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setApplicationProxy">setApplicationProxy</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#proxy">QAbstractSocket::proxy</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#proxy">QTcpServer::proxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="capabilities">
<db:title>QNetworkProxy::Capabilities QNetworkProxy::capabilities() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkProxy::Capabilities</db:type>
<db:methodname>capabilities</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkProxy::Capabilities capabilities() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the capabilities of this proxy server.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#setCapabilities">setCapabilities</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#type">type</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hasRawHeader">
<db:title>bool QNetworkProxy::hasRawHeader(const QByteArray &amp;<db:emphasis>headerName</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>hasRawHeader</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>headerName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool hasRawHeader(const QByteArray &amp;headerName) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the raw header <db:code role="parameter">headerName</db:code> is in use for this proxy. Returns false if the proxy is not of type <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">HttpProxy</db:link> or <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">HttpCachingProxy</db:link>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#rawHeader">rawHeader</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setRawHeader">setRawHeader</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="header">
<db:title>QVariant QNetworkProxy::header(QNetworkRequest::KnownHeaders <db:emphasis>header</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QVariant</db:type>
<db:methodname>header</db:methodname>
<db:methodparam>
<db:type>QNetworkRequest::KnownHeaders</db:type>
<db:parameter>header</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QVariant header(QNetworkRequest::KnownHeaders header) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the value of the known network header <db:code role="parameter">header</db:code> if it is in use for this proxy. If it is not present, returns QVariant() (i.e., an invalid variant).</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkrequest.xml#KnownHeaders-enum">QNetworkRequest::KnownHeaders</db:link></db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#rawHeader">rawHeader</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setHeader">setHeader</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="hostName">
<db:title>QString QNetworkProxy::hostName() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>hostName</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString hostName() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the host name of the proxy host.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#setHostName">setHostName</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setPort">setPort</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#port">port</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isCachingProxy">
<db:title>bool QNetworkProxy::isCachingProxy() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isCachingProxy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isCachingProxy() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this proxy supports the <db:link xlink:href="qnetworkproxy.xml#Capability-enum">QNetworkProxy::CachingCapability</db:link> capability.</db:para>
<db:para>In Qt 4.4, the capability was tied to the proxy type, but since Qt 4.5 it is possible to remove the capability of caching from a proxy by calling <db:link xlink:href="qnetworkproxy.xml#setCapabilities">setCapabilities</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#capabilities">capabilities</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#isTransparentProxy">isTransparentProxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isTransparentProxy">
<db:title>bool QNetworkProxy::isTransparentProxy() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isTransparentProxy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isTransparentProxy() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if this proxy supports transparent tunneling of TCP connections. This matches the <db:link xlink:href="qnetworkproxy.xml#Capability-enum">QNetworkProxy::TunnelingCapability</db:link> capability.</db:para>
<db:para>In Qt 4.4, the capability was tied to the proxy type, but since Qt 4.5 it is possible to remove the capability of caching from a proxy by calling <db:link xlink:href="qnetworkproxy.xml#setCapabilities">setCapabilities</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#capabilities">capabilities</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#isCachingProxy">isCachingProxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="password">
<db:title>QString QNetworkProxy::password() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>password</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString password() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the password used for authentication.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#user">user</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setPassword">setPassword</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setUser">setUser</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="port">
<db:title>quint16 QNetworkProxy::port() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>quint16</db:type>
<db:methodname>port</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">quint16 port() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the port of the proxy host.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#setHostName">setHostName</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setPort">setPort</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#hostName">hostName</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rawHeader">
<db:title>QByteArray QNetworkProxy::rawHeader(const QByteArray &amp;<db:emphasis>headerName</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QByteArray</db:type>
<db:methodname>rawHeader</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>headerName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QByteArray rawHeader(const QByteArray &amp;headerName) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the raw form of header <db:code role="parameter">headerName</db:code>. If no such header is present or the proxy is not of type <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">HttpProxy</db:link> or <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">HttpCachingProxy</db:link>, an empty <db:link xlink:href="qbytearray.xml">QByteArray</db:link> is returned, which may be indistinguishable from a header that is present but has no content (use <db:link xlink:href="qnetworkproxy.xml#hasRawHeader">hasRawHeader</db:link>() to find out if the header exists or not).</db:para>
<db:para>Raw headers can be set with <db:link xlink:href="qnetworkproxy.xml#setRawHeader">setRawHeader</db:link>() or with <db:link xlink:href="qnetworkproxy.xml#setHeader">setHeader</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#header">header</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setRawHeader">setRawHeader</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="rawHeaderList">
<db:title>QList&lt;QByteArray&gt; QNetworkProxy::rawHeaderList() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QList&lt;QByteArray&gt;</db:type>
<db:methodname>rawHeaderList</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QList&lt;QByteArray&gt; rawHeaderList() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns a list of all raw headers that are set in this network proxy. The list is in the order that the headers were set.</db:para>
<db:para>If the proxy is not of type <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">HttpProxy</db:link> or <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">HttpCachingProxy</db:link> an empty <db:link xlink:href="qlist.xml">QList</db:link> is returned.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#hasRawHeader">hasRawHeader</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#rawHeader">rawHeader</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setApplicationProxy">
<db:title>[static] void QNetworkProxy::setApplicationProxy(const QNetworkProxy &amp;<db:emphasis>networkProxy</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>setApplicationProxy</db:methodname>
<db:methodparam>
<db:type>const QNetworkProxy &amp;</db:type>
<db:parameter>networkProxy</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setApplicationProxy(const QNetworkProxy &amp;networkProxy)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the application level network proxying to be <db:code role="parameter">networkProxy</db:code>.</db:para>
<db:para>If a <db:link xlink:href="qabstractsocket.xml">QAbstractSocket</db:link> or <db:link xlink:href="qtcpsocket.xml">QTcpSocket</db:link> has the <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">QNetworkProxy::DefaultProxy</db:link> type, then the <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> set with this function is used. If you want more flexibility in determining which proxy is used, use the <db:link xlink:href="qnetworkproxyfactory.xml">QNetworkProxyFactory</db:link> class.</db:para>
<db:para>Setting a default proxy value with this function will override the application proxy factory set with <db:link xlink:href="qnetworkproxyfactory.xml#setApplicationProxyFactory">QNetworkProxyFactory::setApplicationProxyFactory</db:link>, and disable the use of a system proxy.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxyfactory.xml">QNetworkProxyFactory</db:link></db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#applicationProxy">applicationProxy</db:link>()</db:member>
<db:member><db:link xlink:href="qabstractsocket.xml#setProxy">QAbstractSocket::setProxy</db:link>()</db:member>
<db:member><db:link xlink:href="qtcpserver.xml#setProxy">QTcpServer::setProxy</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setCapabilities">
<db:title>void QNetworkProxy::setCapabilities(QNetworkProxy::Capabilities <db:emphasis>capabilities</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setCapabilities</db:methodname>
<db:methodparam>
<db:type>QNetworkProxy::Capabilities</db:type>
<db:parameter>capabilities</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setCapabilities(QNetworkProxy::Capabilities capabilities)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the capabilities of this proxy to <db:code role="parameter">capabilities</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#setType">setType</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#capabilities">capabilities</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setHeader">
<db:title>void QNetworkProxy::setHeader(QNetworkRequest::KnownHeaders <db:emphasis>header</db:emphasis>, const QVariant &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setHeader</db:methodname>
<db:methodparam>
<db:type>QNetworkRequest::KnownHeaders</db:type>
<db:parameter>header</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QVariant &amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setHeader(QNetworkRequest::KnownHeaders header, const QVariant &amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the value of the known header <db:code role="parameter">header</db:code> to be <db:code role="parameter">value</db:code>, overriding any previously set headers. This operation also sets the equivalent raw HTTP header.</db:para>
<db:para>If the proxy is not of type <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">HttpProxy</db:link> or <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">HttpCachingProxy</db:link> this has no effect.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkrequest.xml#KnownHeaders-enum">QNetworkRequest::KnownHeaders</db:link></db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setRawHeader">setRawHeader</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#header">header</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setHostName">
<db:title>void QNetworkProxy::setHostName(const QString &amp;<db:emphasis>hostName</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setHostName</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>hostName</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setHostName(const QString &amp;hostName)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the host name of the proxy host to be <db:code role="parameter">hostName</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#hostName">hostName</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setPort">setPort</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#port">port</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPassword">
<db:title>void QNetworkProxy::setPassword(const QString &amp;<db:emphasis>password</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPassword</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>password</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPassword(const QString &amp;password)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the password for proxy authentication to be <db:code role="parameter">password</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#user">user</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setUser">setUser</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#password">password</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setPort">
<db:title>void QNetworkProxy::setPort(quint16 <db:emphasis>port</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setPort</db:methodname>
<db:methodparam>
<db:type>quint16</db:type>
<db:parameter>port</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setPort(quint16 port)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the port of the proxy host to be <db:code role="parameter">port</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#hostName">hostName</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setHostName">setHostName</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#port">port</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setRawHeader">
<db:title>void QNetworkProxy::setRawHeader(const QByteArray &amp;<db:emphasis>headerName</db:emphasis>, const QByteArray &amp;<db:emphasis>headerValue</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setRawHeader</db:methodname>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>headerName</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>headerValue</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setRawHeader(const QByteArray &amp;headerName, const QByteArray &amp;headerValue)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the header <db:code role="parameter">headerName</db:code> to be of value <db:code role="parameter">headerValue</db:code>. If <db:code role="parameter">headerName</db:code> corresponds to a known header (see <db:link xlink:href="qnetworkrequest.xml#KnownHeaders-enum">QNetworkRequest::KnownHeaders</db:link>), the raw format will be parsed and the corresponding &quot;cooked&quot; header will be set as well.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="cpp">request.setRawHeader(QByteArray(&quot;Last-Modified&quot;), QByteArray(&quot;Sun, 06 Nov 1994 08:49:37 GMT&quot;));
</db:programlisting>
<db:para>will also set the known header LastModifiedHeader to be the <db:link xlink:href="qdatetime.xml">QDateTime</db:link> object of the parsed date.</db:para>
<db:note>
<db:para>Setting the same header twice overrides the previous setting. To accomplish the behaviour of multiple HTTP headers of the same name, you should concatenate the two values, separating them with a comma (&quot;,&quot;) and set one single raw header.</db:para>
</db:note>
<db:para>If the proxy is not of type <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">HttpProxy</db:link> or <db:link xlink:href="qnetworkproxy.xml#ProxyType-enum">HttpCachingProxy</db:link> this has no effect.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkrequest.xml#KnownHeaders-enum">QNetworkRequest::KnownHeaders</db:link></db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setHeader">setHeader</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#hasRawHeader">hasRawHeader</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#rawHeader">rawHeader</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setType">
<db:title>void QNetworkProxy::setType(QNetworkProxy::ProxyType <db:emphasis>type</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setType</db:methodname>
<db:methodparam>
<db:type>QNetworkProxy::ProxyType</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setType(QNetworkProxy::ProxyType type)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the proxy type for this instance to be <db:code role="parameter">type</db:code>.</db:para>
<db:para>Note that changing the type of a proxy does not change the set of capabilities this <db:link xlink:href="qnetworkproxy.xml">QNetworkProxy</db:link> object holds if any capabilities have been set with <db:link xlink:href="qnetworkproxy.xml#setCapabilities">setCapabilities</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#type">type</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setCapabilities">setCapabilities</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="setUser">
<db:title>void QNetworkProxy::setUser(const QString &amp;<db:emphasis>user</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setUser</db:methodname>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>user</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setUser(const QString &amp;user)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the user name for proxy authentication to be <db:code role="parameter">user</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#user">user</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setPassword">setPassword</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#password">password</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="swap">
<db:title>void QNetworkProxy::swap(QNetworkProxy &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>swap</db:methodname>
<db:methodparam>
<db:type>QNetworkProxy &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void swap(QNetworkProxy &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Swaps this network proxy instance with <db:code role="parameter">other</db:code>. This function is very fast and never fails.</db:para>
</db:section>
<db:section xml:id="type">
<db:title>QNetworkProxy::ProxyType QNetworkProxy::type() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNetworkProxy::ProxyType</db:type>
<db:methodname>type</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkProxy::ProxyType type() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the proxy type for this instance.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#setType">setType</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="user">
<db:title>QString QNetworkProxy::user() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QString</db:type>
<db:methodname>user</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QString user() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the user name used for authentication.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnetworkproxy.xml#setUser">setUser</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#setPassword">setPassword</db:link>()</db:member>
<db:member><db:link xlink:href="qnetworkproxy.xml#password">password</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="operator-not-eq">
<db:title>bool QNetworkProxy::operator!=(const QNetworkProxy &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator!=</db:methodname>
<db:methodparam>
<db:type>const QNetworkProxy &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator!=(const QNetworkProxy &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares the value of this network proxy to <db:code role="parameter">other</db:code> and returns true if they differ.</db:para>
</db:section>
<db:section xml:id="operator-eq-1">
<db:title>QNetworkProxy &amp;QNetworkProxy::operator=(const QNetworkProxy &amp;<db:emphasis>other</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QNetworkProxy &amp;</db:type>
<db:methodname>operator=</db:methodname>
<db:methodparam>
<db:type>const QNetworkProxy &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">copy-assign</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QNetworkProxy &amp; operator=(const QNetworkProxy &amp;other)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Assigns the value of the network proxy <db:code role="parameter">other</db:code> to this network proxy.</db:para>
</db:section>
<db:section xml:id="operator-eq-eq">
<db:title>bool QNetworkProxy::operator==(const QNetworkProxy &amp;<db:emphasis>other</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>operator==</db:methodname>
<db:methodparam>
<db:type>const QNetworkProxy &amp;</db:type>
<db:parameter>other</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool operator==(const QNetworkProxy &amp;other) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Compares the value of this network proxy to <db:code role="parameter">other</db:code> and returns true if they are equal (same proxy type, server as well as username and password)</db:para>
</db:section>
</db:section>
</db:article>
