<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Using TinyCAN Backend</db:title>
<db:productname>QtSerialBus</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Serial Bus Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Overview of how to use the TinyCAN backend.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The TinyCAN backend encapsulates the low-level API to work with the <db:link xlink:href="http://www.mhs-elektronik.de/">MHS Elektronik</db:link> CAN adapters.</db:para>
<db:section xml:id="creating-can-bus-devices">
<db:title>Creating CAN Bus Devices</db:title>
<db:para>At first it is necessary to check that <db:link xlink:href="qcanbus.xml">QCanBus</db:link> provides the desired backend:</db:para>
<db:programlisting language="cpp">foreach (const QByteArray &amp;backend, QCanBus::instance()-&gt;plugins()) {
    if (backend == &quot;tinycan&quot;) {
        // were found
        break;
    }
}
</db:programlisting>
<db:para>Where <db:emphasis>tinycan</db:emphasis> is the backend name.</db:para>
<db:para>Next, a connection to a specific interface can be established:</db:para>
<db:programlisting language="cpp">QCanBusDevice *device = QCanBus::instance()-&gt;createDevice(&quot;tinycan&quot;, QStringLiteral(&quot;channela&quot;));
device-&gt;connectDevice();
</db:programlisting>
<db:para>Where <db:emphasis>channela</db:emphasis> is the active CAN interface name. The TinyCAN backend provides two interfaces, <db:emphasis>channela</db:emphasis> and <db:emphasis>channelb</db:emphasis>.</db:para>
<db:note>
<db:para>Only the USB adapters are currently supported by this backend.</db:para>
</db:note>
<db:para>The device is now open for writing and reading CAN frames:</db:para>
<db:programlisting language="cpp">QCanBusFrame frame;
frame.setFrameId(8);
QByteArray payload(&quot;A36E&quot;);
frame.setPayload(payload);
device-&gt;writeFrame(frame);
</db:programlisting>
<db:para>The reading can be done using the <db:link xlink:href="qcanbusdevice.xml#readFrame">readFrame</db:link>() method. The <db:link xlink:href="qcanbusdevice.xml#framesReceived">framesReceived</db:link>() signal is emitted when new frames are available for reading:</db:para>
<db:programlisting language="cpp">QCanBusFrame frame = device-&gt;readFrame();
</db:programlisting>
<db:para>TinyCAN supports the following configurations that can be controlled through <db:link xlink:href="qcanbusdevice.xml#setConfigurationParameter">setConfigurationParameter</db:link>():</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Configuration parameter key</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para><db:link xlink:href="qcanbusdevice.xml#ConfigurationKey-enum">QCanBusDevice::BitRateKey</db:link></db:para>
</db:td>
<db:td>
<db:para>Determines the bit rate of the CAN bus connection. The following bit rates are supported: 10000, 20000, 50000, 100000, 125000, 250000, 500000, 800000, 1000000.</db:para>
</db:td>
</db:tr>
</db:informaltable>
</db:section>
</db:article>
