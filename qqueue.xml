<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en_US">
<db:info>
<db:title>QQueue Class</db:title>
<db:subtitle>template &lt;typename T&gt; class QQueue</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.2.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qqueue.xml">QQueue</db:link> class is a generic container that provides a queue.</db:para>
<db:note>
<db:para>All functions in this class are reentrant.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QQueue</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qlist.xml" xlink:role="class">QList</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QQueue is part of <db:simplelist><db:member>tools</db:member><db:member><db:link xlink:href="shared.xml">Implicitly Shared Classes</db:link></db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qqueue.xml">QQueue</db:link>&lt;T&gt; is one of Qt's generic <db:link xlink:href="containers.xml">container classes</db:link>. It implements a queue data structure for items of a same type.</db:para>
<db:para>A queue is a first in, first out (FIFO) structure. Items are added to the tail of the queue using enqueue() and retrieved from the head using dequeue(). The head() function provides access to the head item without removing it.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">QQueue&lt;int&gt; queue;
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);
while (!queue.isEmpty())
    cout &lt;&lt; queue.dequeue() &lt;&lt; endl;
</db:programlisting>
<db:para>The example will output 1, 2, 3 in that order.</db:para>
<db:para><db:link xlink:href="qqueue.xml">QQueue</db:link> inherits from <db:link xlink:href="qlist.xml">QList</db:link>. All of <db:link xlink:href="qlist.xml">QList</db:link>'s functionality also applies to <db:link xlink:href="qqueue.xml">QQueue</db:link>. For example, you can use isEmpty() to test whether the queue is empty, and you can traverse a <db:link xlink:href="qqueue.xml">QQueue</db:link> using <db:link xlink:href="qlist.xml">QList</db:link>'s iterator classes (for example, <db:link xlink:href="qlistiterator.xml">QListIterator</db:link>). But in addition, <db:link xlink:href="qqueue.xml">QQueue</db:link> provides three convenience functions that make it easy to implement FIFO semantics: enqueue(), dequeue(), and head().</db:para>
<db:para><db:link xlink:href="qqueue.xml">QQueue</db:link>'s value type must be an <db:link xlink:href="containers.xml">assignable data type</db:link>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value. Use QWidget* instead.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qlist.xml">QList</db:link></db:member>
<db:member><db:link xlink:href="qstack.xml">QStack</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:article>
