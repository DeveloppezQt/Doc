<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QInAppStore Class</db:title>
<db:productname>QtPurchasing</db:productname>
<db:edition>Qt 5.8.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt Purchasing Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The main entry point for managing in-app purchases.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QInAppStore</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para><db:link xlink:href="qinappstore.xml">QInAppStore</db:link> is used for managing in-app purchases in your application in a cross-platform way.</db:para>
<db:section xml:id="using-the-qinappstore">
<db:title>Using the QInAppStore</db:title>
<db:para>In general there are two steps to completing an in-app purchase using the API:</db:para>
<db:section xml:id="initialize-the-store">
<db:title>Initialize the store</db:title>
<db:para>Upon start-up of your application, connect all signals in <db:link xlink:href="qinappstore.xml">QInAppStore</db:link> to related slots in your own <db:link xlink:href="qobject.xml">QObject</db:link>. Then use the <db:link xlink:href="qinappstore.xml#registerProduct">registerProduct</db:link>() function to register the ID of each product you expect to find registered in the external store, as well as its type.</db:para>
<db:para>Registering a product is asynchronous, and will at some point yield one of the following two signals: 1. <db:link xlink:href="qinappstore.xml#productRegistered">productRegistered</db:link>() if the product was found in the external store with a matching type. 2. <db:link xlink:href="qinappstore.xml#productUnknown">productUnknown</db:link>() if the product was not found in the external store with the type you specified.</db:para>
<db:para>In addition, a <db:link xlink:href="qinappstore.xml#transactionReady">transactionReady</db:link>() signal may be emitted for any existing transaction which has not yet been finalized. At this point, you should check if the transaction has previously been registered. If it hasn't, register it right away. Finally, call <db:link xlink:href="qinapptransaction.xml#finalize">QInAppTransaction::finalize</db:link>() on the transaction.</db:para>
</db:section>
<db:section xml:id="complete-a-purchase">
<db:title>Complete a purchase</db:title>
<db:para>Once the items have been successfully registered in the store, you can purchase them. Get the previously registered <db:link xlink:href="qinappproduct.xml">QInAppProduct</db:link> using <db:link xlink:href="qinappstore.xml#registeredProduct">registeredProduct</db:link>() and call <db:link xlink:href="qinappproduct.xml#purchase">QInAppProduct::purchase</db:link>(). This call is also asynchronous.</db:para>
<db:para>At some point later on, the <db:link xlink:href="qinappstore.xml#transactionReady">transactionReady</db:link>() signal will be emitted for the purchase. Check <db:link xlink:href="qinapptransaction.xml#status-prop">QInAppTransaction::status</db:link>() to see if the purchase was completed successfully. If it was, then you must save the information about the purchase in a safe way, so that the application can restore it later.</db:para>
<db:para>When you are done, call <db:link xlink:href="qinapptransaction.xml#finalize">QInAppTransaction::finalize</db:link>(), regardless of its status. Transactions which are not finalized will be emitted again the next time your application calls <db:link xlink:href="qinappstore.xml#registerProduct">registerProduct</db:link>() for the same product.</db:para>
<db:note>
<db:para>Please mind that <db:link xlink:href="qinappstore.xml">QInAppStore</db:link> does not save the purchased state of items in the store for you. The application should store this information in a safe way upon receiving the <db:link xlink:href="qinappstore.xml#transactionReady">transactionReady</db:link>() signal, before calling <db:link xlink:href="qinapptransaction.xml#finalize">QInAppTransaction::finalize</db:link>().</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="types-of-purchases">
<db:title>Types of purchases</db:title>
<db:para>There are two types of purchases supported by <db:link xlink:href="qinappstore.xml">QInAppStore</db:link>: <db:link xlink:href="qinappproduct.xml#ProductType-enum">QInAppProduct::Consumable</db:link> and <db:link xlink:href="qinappproduct.xml#ProductType-enum">QInAppProduct::Unlockable</db:link>. The former will be consumed when the transaction is completed and <db:link xlink:href="qinapptransaction.xml#finalize">QInAppTransaction::finalize</db:link>() is called, meaning that it can be purchased again, any number of times. Unlockable items can only be purchased once.</db:para>
<db:para>Consumable products are temporary and can be purchased multiple times. Examples could be a day-ticket on the bus or a magic sword in a computer game. Note that when purchasing the same product multiple times, you should call <db:link xlink:href="qinapptransaction.xml#finalize">QInAppTransaction::finalize</db:link>() on each transaction before you can purchase the same product again.</db:para>
<db:para>Unlockable products are products that a user will buy once, and the purchase of these items will be persistent. It can typically be used for things like unlocking content or functionality in the application.</db:para>
</db:section>
<db:section xml:id="restoring-purchases">
<db:title>Restoring purchases</db:title>
<db:para>If your application has unlockable products, and does not store the purchase states of these products in a way which makes it possible to restore them when the user reinstalls the application, you should provide a way for the user to restore the purchases manually.</db:para>
<db:para>Call the <db:link xlink:href="qinappstore.xml#restorePurchases">restorePurchases</db:link>() function to begin this process. Granted that the remote store supports it, you will then at some point get <db:link xlink:href="qinappstore.xml#transactionReady">transactionReady</db:link>() for each unlockable item which has previously been purchased by the current user.</db:para>
<db:para>Save the purchase state of each product and call <db:link xlink:href="qinapptransaction.xml#finalize">QInAppTransaction::finalize</db:link>() as you would for a regular purchase.</db:para>
<db:para>Since <db:link xlink:href="qinappstore.xml#restorePurchases">restorePurchases</db:link>() may, on some platforms, cause the user to be prompted for their password, it should usually be called as a reaction to user input. For instance applications can have a button in the UI which will trigger <db:link xlink:href="qinappstore.xml#restorePurchases">restorePurchases</db:link>() and which users can hit manually if they have reinstalled the application (or installed it on a new device) and need to unlock the features that they have previously paid for.</db:para>
<db:note>
<db:para>This depends on support for this functionality in the remote store. If the remote store does not save the purchase state of unlockable products for you, the call will yield no <db:link xlink:href="qinappstore.xml#transactionReady">transactionReady</db:link>() signals, as if no products have been purchased. Both the Android and OS X / iOS backends support restoring unlockable products.</db:para>
</db:note>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QInAppStore">
<db:title>[explicit] QInAppStore::QInAppStore(QObject *<db:emphasis>parent</db:emphasis> = Q_NULLPTR)</db:title>
<db:para>Constructs a <db:link xlink:href="qinappstore.xml">QInAppStore</db:link> with the given <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QInAppStore">
<db:title>[virtual noexcept] QInAppStore::~QInAppStore()</db:title>
<db:para>Destroys the <db:link xlink:href="qinappstore.xml">QInAppStore</db:link>.</db:para>
</db:section>
<db:section xml:id="productRegistered">
<db:title>void QInAppStore::productRegistered(QInAppProduct *<db:emphasis>product</db:emphasis>)</db:title>
<db:para>This signal is emitted when information about a <db:code role="parameter">product</db:code> has been collected from the remote store. It is emitted as a reaction to a <db:link xlink:href="qinappstore.xml#registerProduct">registerProduct</db:link>() call for the same product.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qinappstore.xml#productUnknown">productUnknown</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="productUnknown">
<db:title>void QInAppStore::productUnknown(QInAppProduct::ProductType <db:emphasis>productType</db:emphasis>, const QString &amp;<db:emphasis>identifier</db:emphasis>)</db:title>
<db:para>This signal is emitted when the product named <db:code role="parameter">identifier</db:code> was registered using <db:link xlink:href="qinappstore.xml#registerProduct">registerProduct</db:link>() and matching information could not be provided by the remote store. The <db:code role="parameter">productType</db:code> matches the product type which was originally passed to <db:link xlink:href="qinappstore.xml#registerProduct">registerProduct</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qinappstore.xml#productRegistered">productRegistered</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="registerProduct">
<db:title>void QInAppStore::registerProduct(QInAppProduct::ProductType <db:emphasis>productType</db:emphasis>, const QString &amp;<db:emphasis>identifier</db:emphasis>)</db:title>
<db:para>Registers a product identified by <db:code role="parameter">identifier</db:code> and with the given <db:code role="parameter">productType</db:code>. The <db:code role="parameter">identifier</db:code> must match the identifier of the product in the remote store. If the remote store differentiates between consumable and unlockable products, the <db:code role="parameter">productType</db:code> must also match this.</db:para>
<db:para>Calling this function will asynchronously yield either a <db:link xlink:href="qinappstore.xml#productRegistered">productRegistered</db:link>() or a <db:link xlink:href="qinappstore.xml#productUnknown">productUnknown</db:link>() signal. It may also yield a <db:link xlink:href="qinappstore.xml#transactionReady">transactionReady</db:link>() signal if there is a pending transaction for the product which has not yet been finalized.</db:para>
</db:section>
<db:section xml:id="registeredProduct">
<db:title>QInAppProduct *QInAppStore::registeredProduct(const QString &amp;<db:emphasis>identifier</db:emphasis>) const</db:title>
<db:para>Returns the previously registered product uniquely known by the <db:code role="parameter">identifier</db:code>.</db:para>
</db:section>
<db:section xml:id="restorePurchases">
<db:title>void QInAppStore::restorePurchases()</db:title>
<db:para>Requests existing purchases of unlockable items and will yield a <db:link xlink:href="qinappstore.xml#transactionReady">transactionReady</db:link>() signal for each unlockable product that the remote store confirms have previously been purchased by the current user.</db:para>
<db:para>This function can typically be used for restoring unlockable products when the application has been reinstalled and lost the saved purchase states.</db:para>
<db:note>
<db:para>Calling this function may prompt the user for their password on some platforms.</db:para>
</db:note>
</db:section>
<db:section xml:id="setPlatformProperty">
<db:title>void QInAppStore::setPlatformProperty(const QString &amp;<db:emphasis>propertyName</db:emphasis>, const QString &amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Sets the platform specific property given by <db:code role="parameter">propertyName</db:code> to <db:code role="parameter">value</db:code>. This can be used to pass information to the platform implementation. The properties will be silently ignored on other platforms.</db:para>
<db:para>Currently, the only supported platform property is &quot;AndroidPublicKey&quot; which is used by the Android backend to verify purchases. If it is not set, purchases will be accepted with no verification. (You can also do the verification manually by getting the signature from the <db:link xlink:href="qinapptransaction.xml">QInAppTransaction</db:link> object for the purchase.) For more information, see <db:link xlink:href="http://developer.android.com/google/play/billing/billing_integrate.html#billing-security">the Android documentation for billing security</db:link>.</db:para>
</db:section>
<db:section xml:id="transactionReady">
<db:title>void QInAppStore::transactionReady(QInAppTransaction *<db:emphasis>transaction</db:emphasis>)</db:title>
<db:para>This signal is emitted whenever there is a <db:code role="parameter">transaction</db:code> which needs to be finalized. It is emitted either when a purchase request has been made for a product, when <db:link xlink:href="qinappstore.xml#restorePurchases">restorePurchases</db:link>() has been called and the product was previously purchased, or when <db:link xlink:href="qinappstore.xml#registerProduct">registerProduct</db:link>() was called for a product and there was a pending transaction for the product which had not yet been finalized.</db:para>
</db:section>
</db:section>
</db:article>
