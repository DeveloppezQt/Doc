<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QNearFieldManager Class</db:title>
<db:productname>QtNfc</db:productname>
<db:edition>Qt 5.15.0 Reference Documentation</db:edition>
<db:titleabbrev>Qt NFC Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qnearfieldmanager.xml">QNearFieldManager</db:link> class provides access to notifications for NFC events.</db:para>
<db:para>This class was introduced in Qt 5.2.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QNearFieldManager</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 5.2</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += nfc</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QNearFieldManager is part of <db:simplelist><db:member>connectivity-nfc</db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>NFC Forum devices support two modes of communications. The first mode, peer-to-peer communications, is used to communicate between two NFC Forum devices. The second mode, master/slave communications, is used to communicate between an NFC Forum device and an NFC Forum Tag or Contactless Card. The <db:link xlink:href="qnearfieldmanager.xml#targetDetected">targetDetected</db:link>() signal is emitted when a target device enters communications range. Communications can be initiated from the slot connected to this signal.</db:para>
<db:para>NFC Forum devices generally operate as the master in master/slave communications. Some devices are also capable of operating as the slave, so called Card Emulation mode. In this mode the local NFC device emulates a NFC Forum Tag or Contactless Card.</db:para>
<db:para>NFC Forum Tags can contain one or more messages in a standardized format. These messages are encapsulated by the <db:link xlink:href="qndefmessage.xml">QNdefMessage</db:link> class. Use the <db:link xlink:href="qnearfieldmanager.xml#registerNdefMessageHandler">registerNdefMessageHandler</db:link>() functions to register message handlers with particular criteria. Handlers can be unregistered with the <db:link xlink:href="qnearfieldmanager.xml#unregisterNdefMessageHandler">unregisterNdefMessageHandler</db:link>() function.</db:para>
<db:para>Applications can connect to the <db:link xlink:href="qnearfieldmanager.xml#targetDetected">targetDetected</db:link>() and <db:link xlink:href="qnearfieldmanager.xml#targetLost">targetLost</db:link>() signals to get notified when an NFC Forum Tag enters or leaves proximity. Before these signals are emitted target detection must be started with the <db:link xlink:href="qnearfieldmanager.xml#startTargetDetection">startTargetDetection</db:link>() function. Target detection can be stopped with the <db:link xlink:href="qnearfieldmanager.xml#stopTargetDetection">stopTargetDetection</db:link>() function. Before a detected target can be accessed it is necessary to request access rights. This must be done before the target device is touched. The <db:link xlink:href="qnearfieldmanager.xml#setTargetAccessModes">setTargetAccessModes</db:link>() function is used to set the types of access the application wants to perform on the detected target. When access is no longer required the target access modes should be set to <db:link xlink:href="qnearfieldmanager.xml#TargetAccessMode-enum">NoTargetAccess</db:link> as other applications may be blocked from accessing targets. The current target access modes can be retried with the <db:link xlink:href="qnearfieldmanager.xml#targetAccessModes">targetAccessModes</db:link>() function.</db:para>
<db:section xml:id="automatically-launching-ndef-message-handlers">
<db:title>Automatically launching NDEF message handlers</db:title>
<db:para>On some platforms it is possible to pre-register an application to receive NDEF messages matching a given criteria. This is useful to get the system to automatically launch your application when a matching NDEF message is received. This removes the need to have the user manually launch NDEF handling applications, prior to touching a tag, or to have those applications always running and using system resources.</db:para>
<db:para>The process of registering the handler is different for each platform. Please refer to the platform documentation on how such a registration may be done. If the application has been registered as an NDEF message handler, the application only needs to call the <db:link xlink:href="qnearfieldmanager.xml#registerNdefMessageHandler">registerNdefMessageHandler</db:link>() function:</db:para>
<db:programlisting language="cpp">QNearFieldManager *manager = new QNearFieldManager(this);
manager-&amp;gt;registerNdefMessageHandler(this,
            SLOT(handleNdefMessage(QNdefMessage,QNearFieldTarget*)));
</db:programlisting>
<db:para>Automatically launching NDEF message handlers is supported on <db:link xlink:href="nfc-android.xml">Android</db:link>.</db:para>
<db:section xml:id="nfc-on-linux">
<db:title>NFC on Linux</db:title>
<db:para>The <db:link xlink:href="https://01.org/linux-nfc">Linux NFC project</db:link> provides software to support NFC on Linux platforms. The neard daemon will allow access to the supported hardware via DBus interfaces. <db:link xlink:href="qtnfc-module.xml">QtNfc</db:link> requires neard version 0.14 which can be built from source or installed via the appropriate Linux package manager. Not all API features are currently supported. To allow <db:link xlink:href="qtnfc-module.xml">QtNfc</db:link> to access the DBus interfaces the neard daemon has to be running. In case of problems debug output can be enabled by enabling categorized logging for 'qt.nfc.neard'.</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-type-documentation">
<db:title>Member Type Documentation</db:title>
<db:section xml:id="AdapterState-enum">
<db:title>[since 5.12] enum QNearFieldManager::AdapterState</db:title>
<db:enumsynopsis>
<db:enumname>AdapterState</db:enumname>
<db:enumitem>
<db:enumidentifier>Offline</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TurningOn</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Online</db:enumidentifier>
<db:enumvalue>3</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TurningOff</db:enumidentifier>
<db:enumvalue>4</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>This enum describes the different states a NFC adapter can have.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnearfieldmanager.xml">QNearFieldManager</db:link></db:emphasis>::<db:emphasis role="bold">AdapterState</db:emphasis>::Offline</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The nfc adapter is offline.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnearfieldmanager.xml">QNearFieldManager</db:link></db:emphasis>::<db:emphasis role="bold">AdapterState</db:emphasis>::TurningOn</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The nfc adapter is turning on.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnearfieldmanager.xml">QNearFieldManager</db:link></db:emphasis>::<db:emphasis role="bold">AdapterState</db:emphasis>::Online</db:code></db:para>
</db:td>
<db:td><db:code>3</db:code></db:td>
<db:td>
<db:para>The nfc adapter is online.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnearfieldmanager.xml">QNearFieldManager</db:link></db:emphasis>::<db:emphasis role="bold">AdapterState</db:emphasis>::TurningOff</db:code></db:para>
</db:td>
<db:td><db:code>4</db:code></db:td>
<db:td>
<db:para>The nfc adapter is turning off.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>This enum was introduced or modified in Qt 5.12.</db:para>
</db:section>
<db:section xml:id="TargetAccessMode-enum">
<db:title>enum QNearFieldManager::TargetAccessMode</db:title>
<db:bridgehead renderas="sect2">flags QNearFieldManager::TargetAccessModes</db:bridgehead>
<db:enumsynopsis>
<db:enumname>TargetAccessMode</db:enumname>
<db:enumitem>
<db:enumidentifier>NoTargetAccess</db:enumidentifier>
<db:enumvalue>0x00</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NdefReadTargetAccess</db:enumidentifier>
<db:enumvalue>0x01</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>NdefWriteTargetAccess</db:enumidentifier>
<db:enumvalue>0x02</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>TagTypeSpecificTargetAccess</db:enumidentifier>
<db:enumvalue>0x04</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:typedefsynopsis>
<db:typedefname>QNearFieldManager::TargetAccessModes</db:typedefname>
</db:typedefsynopsis>
<db:para>This enum describes the different access modes an application can have.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnearfieldmanager.xml">QNearFieldManager</db:link></db:emphasis>::NoTargetAccess</db:code></db:para>
</db:td>
<db:td><db:code>0x00</db:code></db:td>
<db:td>
<db:para>The application cannot access NFC capabilities.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnearfieldmanager.xml">QNearFieldManager</db:link></db:emphasis>::NdefReadTargetAccess</db:code></db:para>
</db:td>
<db:td><db:code>0x01</db:code></db:td>
<db:td>
<db:para>The application can read NDEF messages from targets by calling <db:link xlink:href="qnearfieldtarget.xml#readNdefMessages">QNearFieldTarget::readNdefMessages</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnearfieldmanager.xml">QNearFieldManager</db:link></db:emphasis>::NdefWriteTargetAccess</db:code></db:para>
</db:td>
<db:td><db:code>0x02</db:code></db:td>
<db:td>
<db:para>The application can write NDEF messages to targets by calling <db:link xlink:href="qnearfieldtarget.xml#writeNdefMessages">QNearFieldTarget::writeNdefMessages</db:link>().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qnearfieldmanager.xml">QNearFieldManager</db:link></db:emphasis>::TagTypeSpecificTargetAccess</db:code></db:para>
</db:td>
<db:td><db:code>0x04</db:code></db:td>
<db:td>
<db:para>The application can access targets using raw commands by calling <db:link xlink:href="qnearfieldtarget.xml#sendCommand">QNearFieldTarget::sendCommand</db:link>().</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>TargetAccessModes</db:code> type is a typedef for <db:code><db:link xlink:href="qflags.xml">QFlags</db:link>&lt;TargetAccessMode&gt;. </db:code>It stores an OR combination of <db:code>TargetAccessMode</db:code> values.</db:para>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QNearFieldManager">
<db:title>[explicit] QNearFieldManager::QNearFieldManager(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QNearFieldManager</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QNearFieldManager(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a new near field manager with <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QNearFieldManager">
<db:title>[virtual] QNearFieldManager::~QNearFieldManager()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QNearFieldManager</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QNearFieldManager()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the near field manager.</db:para>
</db:section>
<db:section xml:id="adapterStateChanged">
<db:title>[since 5.12] void QNearFieldManager::adapterStateChanged(QNearFieldManager::AdapterState <db:emphasis>state</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>adapterStateChanged</db:methodname>
<db:methodparam>
<db:type>QNearFieldManager::AdapterState</db:type>
<db:parameter>state</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void adapterStateChanged(QNearFieldManager::AdapterState state)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever the <db:code role="parameter">state</db:code> of the NFC adapter changed.</db:para>
<db:note>
<db:para>Currently, this signal is only emitted on Android.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.12.</db:para>
</db:section>
<db:section xml:id="isAvailable">
<db:title>bool QNearFieldManager::isAvailable() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isAvailable</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isAvailable() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the device has a NFC adapter and it is turned on; otherwise returns <db:code>false</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnearfieldmanager.xml#isSupported">isSupported</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isSupported">
<db:title>[since 5.12] bool QNearFieldManager::isSupported() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isSupported</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isSupported() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns <db:code>true</db:code> if the underlying device has a NFC adapter; otherwise returns <db:code>false</db:code>.</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnearfieldmanager.xml#isAvailable">isAvailable</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="registerNdefMessageHandler">
<db:title>int QNearFieldManager::registerNdefMessageHandler(QObject *<db:emphasis>object</db:emphasis>, const char *<db:emphasis>method</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>registerNdefMessageHandler</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int registerNdefMessageHandler(QObject *object, const char *method)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers <db:code role="parameter">object</db:code> to receive notifications on <db:code role="parameter">method</db:code> when a tag has been detected and has an NDEF message that matches a pre-registered message format. The <db:code role="parameter">method</db:code> on <db:code role="parameter">object</db:code> should have the prototype 'void <db:link xlink:href="qnearfieldmanager.xml#targetDetected">targetDetected</db:link>(const <db:link xlink:href="qndefmessage.xml">QNdefMessage</db:link> &amp;message, <db:link xlink:href="qnearfieldtarget.xml">QNearFieldTarget</db:link> *target)'.</db:para>
<db:para>Returns an identifier, which can be used to unregister the handler, on success; otherwise returns -1.</db:para>
<db:para>This function is used to register a <db:link xlink:href="qnearfieldmanager.xml">QNearFieldManager</db:link> instance to receive notifications when a NDEF message matching a pre-registered message format is received. See the section on <db:link xlink:href="qnearfieldmanager.xml#automatically-launching-ndef-message-handlers">Automatically launching NDEF message handlers</db:link>.</db:para>
<db:note>
<db:para>The <db:emphasis>target</db:emphasis> parameter of <db:code role="parameter">method</db:code> may not be available on all platforms, in which case <db:emphasis>target</db:emphasis> will be 0.</db:para>
</db:note>
</db:section>
<db:section xml:id="registerNdefMessageHandler-1">
<db:title>int QNearFieldManager::registerNdefMessageHandler(QNdefRecord::TypeNameFormat <db:emphasis>typeNameFormat</db:emphasis>, const QByteArray &amp;<db:emphasis>type</db:emphasis>, QObject *<db:emphasis>object</db:emphasis>, const char *<db:emphasis>method</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>registerNdefMessageHandler</db:methodname>
<db:methodparam>
<db:type>QNdefRecord::TypeNameFormat</db:type>
<db:parameter>typeNameFormat</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QByteArray &amp;</db:type>
<db:parameter>type</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int registerNdefMessageHandler(QNdefRecord::TypeNameFormat typeNameFormat, const QByteArray &amp;type, QObject *object, const char *method)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers <db:code role="parameter">object</db:code> to receive notifications on <db:code role="parameter">method</db:code> when a tag has been detected and has an NDEF record that matches <db:code role="parameter">typeNameFormat</db:code> and <db:code role="parameter">type</db:code>. The <db:code role="parameter">method</db:code> on <db:code role="parameter">object</db:code> should have the prototype 'void <db:link xlink:href="qnearfieldmanager.xml#targetDetected">targetDetected</db:link>(const <db:link xlink:href="qndefmessage.xml">QNdefMessage</db:link> &amp;message, <db:link xlink:href="qnearfieldtarget.xml">QNearFieldTarget</db:link> *target)'.</db:para>
<db:para>Returns an identifier, which can be used to unregister the handler, on success; otherwise returns -1.</db:para>
<db:note>
<db:para>The <db:emphasis>target</db:emphasis> parameter of <db:code role="parameter">method</db:code> may not be available on all platforms, in which case <db:emphasis>target</db:emphasis> will be 0.</db:para>
</db:note>
<db:note>
<db:para>On platforms using neard registering message handlers is not supported.</db:para>
</db:note>
</db:section>
<db:section xml:id="registerNdefMessageHandler-2">
<db:title>int QNearFieldManager::registerNdefMessageHandler(const QNdefFilter &amp;<db:emphasis>filter</db:emphasis>, QObject *<db:emphasis>object</db:emphasis>, const char *<db:emphasis>method</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>registerNdefMessageHandler</db:methodname>
<db:methodparam>
<db:type>const QNdefFilter &amp;</db:type>
<db:parameter>filter</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>object</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">int registerNdefMessageHandler(const QNdefFilter &amp;filter, QObject *object, const char *method)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Registers <db:code role="parameter">object</db:code> to receive notifications on <db:code role="parameter">method</db:code> when a tag has been detected and has an NDEF message that matches <db:code role="parameter">filter</db:code> is detected. The <db:code role="parameter">method</db:code> on <db:code role="parameter">object</db:code> should have the prototype 'void <db:link xlink:href="qnearfieldmanager.xml#targetDetected">targetDetected</db:link>(const <db:link xlink:href="qndefmessage.xml">QNdefMessage</db:link> &amp;message, <db:link xlink:href="qnearfieldtarget.xml">QNearFieldTarget</db:link> *target)'.</db:para>
<db:para>Returns an identifier, which can be used to unregister the handler, on success; otherwise returns -1.</db:para>
<db:note>
<db:para>The <db:emphasis>target</db:emphasis> parameter of <db:code role="parameter">method</db:code> may not be available on all platforms, in which case <db:emphasis>target</db:emphasis> will be 0.</db:para>
</db:note>
</db:section>
<db:section xml:id="setTargetAccessModes">
<db:title>void QNearFieldManager::setTargetAccessModes(QNearFieldManager::TargetAccessModes <db:emphasis>accessModes</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setTargetAccessModes</db:methodname>
<db:methodparam>
<db:type>QNearFieldManager::TargetAccessModes</db:type>
<db:parameter>accessModes</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setTargetAccessModes(QNearFieldManager::TargetAccessModes accessModes)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Sets the requested target access modes to <db:code role="parameter">accessModes</db:code>.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnearfieldmanager.xml#targetAccessModes">targetAccessModes</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="startTargetDetection">
<db:title>bool QNearFieldManager::startTargetDetection()</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>startTargetDetection</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool startTargetDetection()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Starts detecting targets and returns true if target detection is successfully started; otherwise returns false. Causes the <db:link xlink:href="qnearfieldmanager.xml#targetDetected">targetDetected</db:link>() signal to be emitted when a target is within proximity.</db:para>
<db:note>
<db:para>For platforms using neard: target detection will stop as soon as a tag has been detected.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnearfieldmanager.xml#stopTargetDetection">stopTargetDetection</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="stopTargetDetection">
<db:title>void QNearFieldManager::stopTargetDetection()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>stopTargetDetection</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void stopTargetDetection()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Stops detecting targets. The <db:link xlink:href="qnearfieldmanager.xml#targetDetected">targetDetected</db:link>() signal will no longer be emitted until another call to <db:link xlink:href="qnearfieldmanager.xml#startTargetDetection">startTargetDetection</db:link>() is made.</db:para>
</db:section>
<db:section xml:id="targetAccessModes">
<db:title>QNearFieldManager::TargetAccessModes QNearFieldManager::targetAccessModes() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>QNearFieldManager::TargetAccessModes</db:type>
<db:methodname>targetAccessModes</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QNearFieldManager::TargetAccessModes targetAccessModes() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns current requested target access modes.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnearfieldmanager.xml#setTargetAccessModes">setTargetAccessModes</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="targetDetected">
<db:title>void QNearFieldManager::targetDetected(QNearFieldTarget *<db:emphasis>target</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>targetDetected</db:methodname>
<db:methodparam>
<db:type>QNearFieldTarget *</db:type>
<db:parameter>target</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void targetDetected(QNearFieldTarget *target)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever a target is detected. The <db:code role="parameter">target</db:code> parameter represents the detected target.</db:para>
<db:para>This signal will be emitted for all detected targets.</db:para>
<db:para><db:link xlink:href="qnearfieldmanager.xml">QNearFieldManager</db:link> maintains ownership of <db:code role="parameter">target</db:code>, however, it will not be destroyed until the <db:link xlink:href="qnearfieldmanager.xml">QNearFieldManager</db:link> destructor is called. Ownership may be transferred by calling <db:link xlink:href="qobject.xml#setParent">setParent</db:link>().</db:para>
<db:para>Do not delete <db:code role="parameter">target</db:code> from the slot connected to this signal, instead call <db:link xlink:href="qobject.xml#deleteLater">deleteLater</db:link>().</db:para>
<db:note>
<db:para>that if <db:code role="parameter">target</db:code> is deleted before it moves out of proximity the <db:link xlink:href="qnearfieldmanager.xml#targetLost">targetLost</db:link>() signal will not be emitted.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnearfieldmanager.xml#targetLost">targetLost</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="targetLost">
<db:title>void QNearFieldManager::targetLost(QNearFieldTarget *<db:emphasis>target</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>targetLost</db:methodname>
<db:methodparam>
<db:type>QNearFieldTarget *</db:type>
<db:parameter>target</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void targetLost(QNearFieldTarget *target)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted whenever a target moves out of proximity. The <db:code role="parameter">target</db:code> parameter represents the lost target.</db:para>
<db:para>Do not delete <db:code role="parameter">target</db:code> from the slot connected to this signal, instead use <db:link xlink:href="qobject.xml#deleteLater">deleteLater</db:link>().</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qnearfieldtarget.xml#disconnected">QNearFieldTarget::disconnected</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="unregisterNdefMessageHandler">
<db:title>bool QNearFieldManager::unregisterNdefMessageHandler(int <db:emphasis>handlerId</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>bool</db:type>
<db:methodname>unregisterNdefMessageHandler</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>handlerId</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">bool unregisterNdefMessageHandler(int handlerId)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Unregisters the target detect handler identified by <db:code role="parameter">handlerId</db:code>.</db:para>
<db:para>Returns true on success; otherwise returns false.</db:para>
</db:section>
</db:section>
</db:article>
