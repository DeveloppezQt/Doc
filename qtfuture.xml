<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QtFuture Namespace</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Contains miscellaneous identifiers used by the <db:link xlink:href="qfuture.xml">QFuture</db:link> class.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QFuture</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
</db:section>
<db:section xml:id="type-documentation">
<db:title>Type Documentation</db:title>
<db:section xml:id="Launch-enum">
<db:title>[since 6.0] enum QtFuture::Launch</db:title>
<db:enumsynopsis>
<db:enumname>Launch</db:enumname>
<db:enumitem>
<db:enumidentifier>Sync</db:enumidentifier>
<db:enumvalue>0</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Async</db:enumidentifier>
<db:enumvalue>1</db:enumvalue>
</db:enumitem>
<db:enumitem>
<db:enumidentifier>Inherit</db:enumidentifier>
<db:enumvalue>2</db:enumvalue>
</db:enumitem>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:enumsynopsis>
<db:para>Represents execution policies for running a <db:link xlink:href="qfuture.xml">QFuture</db:link> continuation.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtfuture.xml">QtFuture</db:link></db:emphasis>::<db:emphasis role="bold">Launch</db:emphasis>::Sync</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The continuation will be launched in the same thread that fulfills the promise associated with the future to which the continuation was attached, or if it has already finished, the continuation will be invoked immediately, in the thread that executes then().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtfuture.xml">QtFuture</db:link></db:emphasis>::<db:emphasis role="bold">Launch</db:emphasis>::Async</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The continuation will be launched in a separate thread taken from the global <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtfuture.xml">QtFuture</db:link></db:emphasis>::<db:emphasis role="bold">Launch</db:emphasis>::Inherit</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The continuation will inherit the launch policy or thread pool of the future to which it is attached.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Sync is used as a default launch policy.</db:para>
<db:para>This enum was introduced or modified in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#then">QFuture::then</db:link>()</db:member>
<db:member><db:link xlink:href="qthreadpool.xml#globalInstance">QThreadPool::globalInstance</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="function-documentation">
<db:title>Function Documentation</db:title>
<db:section xml:id="connect">
<db:title>QFuture&lt;ArgsType&lt;Signal&gt;&gt; QtFuture::connect(Sender *<db:emphasis>sender</db:emphasis>, Signal <db:emphasis>signal</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;ArgsType&lt;Signal&gt;&gt;</db:type>
<db:methodname>connect</db:methodname>
<db:methodparam>
<db:type>Sender *</db:type>
<db:parameter>sender</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Signal</db:type>
<db:parameter>signal</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;ArgsType&lt;Signal&gt;&gt; connect(Sender *sender, Signal signal)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates and returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> which will become available when the <db:code role="parameter">sender</db:code> emits the <db:code role="parameter">signal</db:code>. If the <db:code role="parameter">signal</db:code> takes no arguments, a <db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;void&gt; is returned. If the <db:code role="parameter">signal</db:code> takes a single argument, the resulted <db:link xlink:href="qfuture.xml">QFuture</db:link> will be filled with the signal's argument value. If the <db:code role="parameter">signal</db:code> takes multiple arguments, the resulted <db:link xlink:href="qfuture.xml">QFuture</db:link> is filled with std::tuple storing the values of signal's arguments. If the <db:code role="parameter">sender</db:code> is destroyed before the <db:code role="parameter">signal</db:code> is emitted, the resulted <db:link xlink:href="qfuture.xml">QFuture</db:link> will be canceled.</db:para>
<db:para>For example, let's say we have the following object:</db:para>
<db:programlisting language="cpp">class Object : public QObject
{
    Q_OBJECT
    ...
signals:
    void noArgSignal();
    void singleArgSignal(int value);
    void multipleArgs(int value1, double value2, const QString &amp;amp;value3);
};
</db:programlisting>
<db:para>We can connect its signals to <db:link xlink:href="qfuture.xml">QFuture</db:link> objects in the following way:</db:para>
<db:programlisting language="cpp">Object object;
QFuture&amp;lt;void&amp;gt; voidFuture = QtFuture::connect(&amp;amp;object, &amp;amp;Object::noArgSignal);
QFuture&amp;lt;int&amp;gt; intFuture = QtFuture::connect(&amp;amp;object, &amp;amp;Object::singleArgSignal);

using Args = std::tuple&amp;lt;int, double, QString&amp;gt;;
QFuture&amp;lt;Args&amp;gt; tupleFuture = QtFuture::connect(&amp;amp;object, &amp;amp;Object::multipleArgs)
</db:programlisting>
<db:para>We can also chain continuations to be run when a signal is emitted:</db:para>
<db:programlisting language="cpp">QtFuture::connect(&amp;amp;object, &amp;amp;Object::singleArgSignal).then([](int value) {
    // do something with the value
});
</db:programlisting>
<db:para>You can also start the continuation in a new thread or a custom thread pool using <db:link xlink:href="qtfuture.xml#Launch-enum">QtFuture::Launch</db:link> policies. For example:</db:para>
<db:programlisting language="cpp">QtFuture::connect(&amp;amp;object, &amp;amp;Object::singleArgSignal).then(QtFuture::Launch::Async, [](int value) {
    // this will run in a new thread
});
</db:programlisting>
<db:para>Throwing an exception from a slot invoked by Qt's signal-slot connection is considered to be an undefined behavior, if it is not handled within the slot. But with QFuture::connect(), you can throw and handle exceptions from the continuations:</db:para>
<db:programlisting language="cpp">QtFuture::connect(&amp;amp;object, &amp;amp;Object::singleArgSignal).then([](int value) {
    ...
    throw std::exception();
    ...
}).onFailed([](const std::exception &amp;amp;e) {
    // handle the exception
}).onFailed([] {
    // handle other exceptions
});
</db:programlisting>
<db:note>
<db:para>The connected future will be fulfilled only once, when the signal is emitted for the first time.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qfuture.xml#then">QFuture::then</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeExceptionalFuture">
<db:title>[since 6.1] QFuture&lt;T&gt; QtFuture::makeExceptionalFuture(const QException &amp;<db:emphasis>exception</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>makeExceptionalFuture</db:methodname>
<db:methodparam>
<db:type>const QException &amp;</db:type>
<db:parameter>exception</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; makeExceptionalFuture(const QException &amp;exception)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Creates and returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> which already has an exception <db:code role="parameter">exception</db:code>.</db:para>
<db:programlisting language="cpp">QException e;
auto f = QtFuture::makeExceptionalFuture&amp;lt;int&amp;gt;(e);
...
try {
    f.result(); // throws QException
} catch (QException &amp;amp;) {
    // handle exception here
}
</db:programlisting>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qexception.xml">QException</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyFuture-1">QtFuture::makeReadyFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeExceptionalFuture-1">
<db:title>[since 6.1] QFuture&lt;T&gt; QtFuture::makeExceptionalFuture(std::exception_ptr <db:emphasis>exception</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>makeExceptionalFuture</db:methodname>
<db:methodparam>
<db:type>std::exception_ptr</db:type>
<db:parameter>exception</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; makeExceptionalFuture(std::exception_ptr exception)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates and returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> which already has an exception <db:code role="parameter">exception</db:code>.</db:para>
<db:programlisting language="cpp">struct TestException
{
};
...
auto exception = std::make_exception_ptr(TestException());
auto f = QtFuture::makeExceptionalFuture&amp;lt;int&amp;gt;(exception);
...
try {
    f.result(); // throws TestException
} catch (TestException &amp;amp;) {
    // handle exception here
}
</db:programlisting>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qexception.xml">QException</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyFuture-1">QtFuture::makeReadyFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeReadyFuture">
<db:title>[since 6.1] QFuture&lt;std::decay_t&lt;T&gt;&gt; QtFuture::makeReadyFuture(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;std::decay_t&lt;T&gt;&gt;</db:type>
<db:methodname>makeReadyFuture</db:methodname>
<db:methodparam>
<db:type>T &amp;&amp;</db:type>
<db:parameter>value</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;std::decay_t&lt;T&gt;&gt; makeReadyFuture(T &amp;&amp;value)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates and returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> which already has a result <db:code role="parameter">value</db:code>. The returned <db:link xlink:href="qfuture.xml">QFuture</db:link> has a type of std::decay_t&lt;T&gt;, where T is not void.</db:para>
<db:programlisting language="cpp">auto f = QtFuture::makeReadyFuture(std::make_unique&amp;lt;int&amp;gt;(42));
...
const int result = *f.takeResult(); // result == 42
</db:programlisting>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeExceptionalFuture">QtFuture::makeExceptionalFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeReadyFuture-1">
<db:title>[since 6.1] QFuture&lt;void&gt; QtFuture::makeReadyFuture()</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;void&gt;</db:type>
<db:methodname>makeReadyFuture</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;void&gt; makeReadyFuture()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates and returns a void <db:link xlink:href="qfuture.xml">QFuture</db:link>. Such <db:link xlink:href="qfuture.xml">QFuture</db:link> can't store any result. One can use it to query the state of the computation. The returned <db:link xlink:href="qfuture.xml">QFuture</db:link> will always be in the finished state.</db:para>
<db:programlisting language="cpp">auto f = QtFuture::makeReadyFuture();
...
const bool started = f.isStarted(); // started == true
const bool running = f.isRunning(); // running == false
const bool finished = f.isFinished(); // finished == true
</db:programlisting>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qfuture.xml#isStarted">QFuture::isStarted</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isRunning">QFuture::isRunning</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isFinished">QFuture::isFinished</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeExceptionalFuture">QtFuture::makeExceptionalFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeReadyFuture-2">
<db:title>[since 6.1] QFuture&lt;T&gt; QtFuture::makeReadyFuture(const QList&lt;T&gt; &amp;<db:emphasis>values</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>QFuture&lt;T&gt;</db:type>
<db:methodname>makeReadyFuture</db:methodname>
<db:methodparam>
<db:type>const QList&lt;T&gt; &amp;</db:type>
<db:parameter>values</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QFuture&lt;T&gt; makeReadyFuture(const QList&lt;T&gt; &amp;values)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates and returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> which already has multiple results set from <db:code role="parameter">values</db:code>.</db:para>
<db:programlisting language="cpp">const QList&amp;lt;int&amp;gt; values { 1, 2, 3 };
auto f = QtFuture::makeReadyFuture(values);
...
const int count = f.resultCount(); // count == 3
const auto results = f.results(); // results == { 1, 2, 3 }
</db:programlisting>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeExceptionalFuture">QtFuture::makeExceptionalFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:article>
