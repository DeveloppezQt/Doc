<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QtFuture Namespace</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 6.8.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Contains miscellaneous identifiers used by the <db:link xlink:href="qfuture.xml">QFuture</db:link> class.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QFuture</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Core)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Core)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
</db:section>
<db:section xml:id="classes">
<db:title>Classes</db:title>
<db:section>
<db:title>[since 6.3] QtFuture::WhenAnyResult</db:title>
<db:para>The QtFuture::WhenAnyResult&lt;T&gt; struct is used for packaging the copy and the index of the first completed QFuture&lt;T&gt; in the sequence of futures packaging type T that are passed to <db:link xlink:href="qtfuture.xml#whenAny">QtFuture::whenAny</db:link>().</db:para>
<db:para>This struct was introduced in Qt 6.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#whenAny">QtFuture::whenAny</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="type-documentation">
<db:title>Type Documentation</db:title>
<db:section xml:id="Launch-enum">
<db:title>[since 6.0] enum QtFuture::Launch</db:title>
<db:para>Represents execution policies for running a <db:link xlink:href="qfuture.xml">QFuture</db:link> continuation.</db:para>
<db:informaltable>
<db:thead>
<db:tr>
<db:th>Constant</db:th>
<db:th>Value</db:th>
<db:th>Description</db:th>
</db:tr>
</db:thead>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtfuture.xml">QtFuture</db:link></db:emphasis>::<db:emphasis role="bold">Launch</db:emphasis>::Sync</db:code></db:para>
</db:td>
<db:td><db:code>0</db:code></db:td>
<db:td>
<db:para>The continuation will be launched in the same thread that fulfills the promise associated with the future to which the continuation was attached, or if it has already finished, the continuation will be invoked immediately, in the thread that executes then().</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtfuture.xml">QtFuture</db:link></db:emphasis>::<db:emphasis role="bold">Launch</db:emphasis>::Async</db:code></db:para>
</db:td>
<db:td><db:code>1</db:code></db:td>
<db:td>
<db:para>The continuation will be launched in a separate thread taken from the global <db:link xlink:href="qthreadpool.xml">QThreadPool</db:link>.</db:para>
</db:td>
</db:tr>
<db:tr>
<db:td>
<db:para><db:code><db:emphasis role="bold"><db:link xlink:href="qtfuture.xml">QtFuture</db:link></db:emphasis>::<db:emphasis role="bold">Launch</db:emphasis>::Inherit</db:code></db:para>
</db:td>
<db:td><db:code>2</db:code></db:td>
<db:td>
<db:para>The continuation will inherit the launch policy or thread pool of the future to which it is attached.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>Sync is used as a default launch policy.</db:para>
<db:para>This enum was introduced in Qt 6.0.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml#then">QFuture::then</db:link>()</db:member>
<db:member><db:link xlink:href="qthreadpool.xml#globalInstance">QThreadPool::globalInstance</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="function-documentation">
<db:title>Function Documentation</db:title>
<db:section xml:id="connect">
<db:title>QFuture&lt;QtFuture::ArgsType&lt;Signal&gt;&gt; QtFuture::connect(Sender *<db:emphasis>sender</db:emphasis>, Signal <db:emphasis>signal</db:emphasis>)</db:title>
<db:para>Creates and returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> which will become available when the <db:code role="parameter">sender</db:code> emits the <db:code role="parameter">signal</db:code>. If the <db:code role="parameter">signal</db:code> takes no arguments, a <db:link xlink:href="qfuture.xml">QFuture</db:link>&lt;void&gt; is returned. If the <db:code role="parameter">signal</db:code> takes a single argument, the resulted <db:link xlink:href="qfuture.xml">QFuture</db:link> will be filled with the signal's argument value. If the <db:code role="parameter">signal</db:code> takes multiple arguments, the resulted <db:link xlink:href="qfuture.xml">QFuture</db:link> is filled with std::tuple storing the values of signal's arguments. If the <db:code role="parameter">sender</db:code> is destroyed before the <db:code role="parameter">signal</db:code> is emitted, the resulted <db:link xlink:href="qfuture.xml">QFuture</db:link> will be canceled.</db:para>
<db:para>For example, let's say we have the following object:</db:para>
<db:programlisting language="cpp">class Object : public QObject
{
    Q_OBJECT
    ...
signals:
    void noArgSignal();
    void singleArgSignal(int value);
    void multipleArgs(int value1, double value2, const QString &amp;value3);
};
</db:programlisting>
<db:para>We can connect its signals to <db:link xlink:href="qfuture.xml">QFuture</db:link> objects in the following way:</db:para>
<db:programlisting language="cpp">Object object;
QFuture&lt;void&gt; voidFuture = QtFuture::connect(&amp;object, &amp;Object::noArgSignal);
QFuture&lt;int&gt; intFuture = QtFuture::connect(&amp;object, &amp;Object::singleArgSignal);

using Args = std::tuple&lt;int, double, QString&gt;;
QFuture&lt;Args&gt; tupleFuture = QtFuture::connect(&amp;object, &amp;Object::multipleArgs)
</db:programlisting>
<db:para>We can also chain continuations to be run when a signal is emitted:</db:para>
<db:programlisting language="cpp">QtFuture::connect(&amp;object, &amp;Object::singleArgSignal).then([](int value) {
    // do something with the value
});
</db:programlisting>
<db:para>You can also start the continuation in a new thread or a custom thread pool using <db:link xlink:href="qtfuture.xml#Launch-enum">QtFuture::Launch</db:link> policies. For example:</db:para>
<db:programlisting language="cpp">QtFuture::connect(&amp;object, &amp;Object::singleArgSignal).then(QtFuture::Launch::Async, [](int value) {
    // this will run in a new thread
});
</db:programlisting>
<db:para>Throwing an exception from a slot invoked by Qt's signal-slot connection is considered to be an undefined behavior, if it is not handled within the slot. But with QFuture::connect(), you can throw and handle exceptions from the continuations:</db:para>
<db:programlisting language="cpp">QtFuture::connect(&amp;object, &amp;Object::singleArgSignal).then([](int value) {
    ...
    throw std::exception();
    ...
}).onFailed([](const std::exception &amp;e) {
    // handle the exception
}).onFailed([] {
    // handle other exceptions
});
</db:programlisting>
<db:note>
<db:para>The connected future will be fulfilled only once, when the signal is emitted for the first time.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qfuture.xml#then">QFuture::then</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeExceptionalFuture">
<db:title>[since 6.1] QFuture&lt;T&gt; QtFuture::makeExceptionalFuture(const QException &amp;<db:emphasis>exception</db:emphasis>)</db:title>
<db:para>Creates and returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> which already has an exception <db:code role="parameter">exception</db:code>.</db:para>
<db:programlisting language="cpp">QException e;
auto f = QtFuture::makeExceptionalFuture&lt;int&gt;(e);
...
try {
    f.result(); // throws QException
} catch (QException &amp;) {
    // handle exception here
}
</db:programlisting>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qexception.xml">QException</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyVoidFuture">QtFuture::makeReadyVoidFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyValueFuture">QtFuture::makeReadyValueFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeExceptionalFuture-1">
<db:title>[since 6.1] QFuture&lt;T&gt; QtFuture::makeExceptionalFuture(std::__exception_ptr::exception_ptr <db:emphasis>exception</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates and returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> which already has an exception <db:code role="parameter">exception</db:code>.</db:para>
<db:programlisting language="cpp">struct TestException
{
};
...
auto exception = std::make_exception_ptr(TestException());
auto f = QtFuture::makeExceptionalFuture&lt;int&gt;(exception);
...
try {
    f.result(); // throws TestException
} catch (TestException &amp;) {
    // handle exception here
}
</db:programlisting>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qexception.xml">QException</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyVoidFuture">QtFuture::makeReadyVoidFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyValueFuture">QtFuture::makeReadyValueFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeReadyRangeFuture">
<db:title>[since 6.6] QFuture&lt;QtFuture::ContainedType&lt;Container&gt;&gt; QtFuture::makeReadyRangeFuture(Container &amp;&amp;<db:emphasis>container</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Takes an input container <db:code role="parameter">container</db:code> and returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> with multiple results of type ContainedType initialized from the values of the <db:code role="parameter">container</db:code>.</db:para>
<db:note>
<db:para>This overload only participates in overload resolution if the Container has input iterators.</db:para>
</db:note>
<db:programlisting language="cpp">const std::vector&lt;int&gt; values{1, 2, 3};
auto f = QtFuture::makeReadyRangeFuture(values);
    ...
const int count = f.resultCount(); // count == 3
const auto results = f.results(); // results == { 1, 2, 3 }
</db:programlisting>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyVoidFuture">QtFuture::makeReadyVoidFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyValueFuture">QtFuture::makeReadyValueFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeExceptionalFuture">QtFuture::makeExceptionalFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeReadyRangeFuture-1">
<db:title>[since 6.6] QFuture&lt;ValueType&gt; QtFuture::makeReadyRangeFuture(std::initializer_list&lt;ValueType&gt; <db:emphasis>values</db:emphasis>)</db:title>
<db:para>This is an overloaded function.</db:para>
<db:para>Returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> with multiple results of type ValueType initialized from the input initializer list <db:code role="parameter">values</db:code>.</db:para>
<db:programlisting language="cpp">auto f = QtFuture::makeReadyRangeFuture({1, 2, 3});
    ...
const int count = f.resultCount(); // count == 3
const auto results = f.results(); // results == { 1, 2, 3 }
</db:programlisting>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyVoidFuture">QtFuture::makeReadyVoidFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyValueFuture">QtFuture::makeReadyValueFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeExceptionalFuture">QtFuture::makeExceptionalFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeReadyValueFuture">
<db:title>[since 6.6] QFuture&lt;std::decay_t&lt;T&gt;&gt; QtFuture::makeReadyValueFuture(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>Creates and returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> which already has a result <db:code role="parameter">value</db:code>. The returned <db:link xlink:href="qfuture.xml">QFuture</db:link> has a type of std::decay_t&lt;T&gt;, where T is not void. The returned <db:link xlink:href="qfuture.xml">QFuture</db:link> will already be in the finished state.</db:para>
<db:programlisting language="cpp">auto f = QtFuture::makeReadyValueFuture(std::make_unique&lt;int&gt;(42));
...
const int result = *f.takeResult(); // result == 42
</db:programlisting>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyRangeFuture">QtFuture::makeReadyRangeFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyVoidFuture">QtFuture::makeReadyVoidFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeExceptionalFuture">QtFuture::makeExceptionalFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeReadyVoidFuture">
<db:title>[since 6.6] QFuture&lt;void&gt; QtFuture::makeReadyVoidFuture()</db:title>
<db:para>Creates and returns a void <db:link xlink:href="qfuture.xml">QFuture</db:link>. Such <db:link xlink:href="qfuture.xml">QFuture</db:link> can't store any result. One can use it to query the state of the computation. The returned <db:link xlink:href="qfuture.xml">QFuture</db:link> will already be in the finished state.</db:para>
<db:programlisting language="cpp">auto f = QtFuture::makeReadyVoidFuture();
...
const bool started = f.isStarted(); // started == true
const bool running = f.isRunning(); // running == false
const bool finished = f.isFinished(); // finished == true
</db:programlisting>
<db:para>This function was introduced in Qt 6.6.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qfuture.xml#isStarted">QFuture::isStarted</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isRunning">QFuture::isRunning</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isFinished">QFuture::isFinished</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyValueFuture">QtFuture::makeReadyValueFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyRangeFuture">QtFuture::makeReadyRangeFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeExceptionalFuture">QtFuture::makeExceptionalFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="whenAll">
<db:title>[since 6.3] QFuture&lt;OutputSequence&gt; QtFuture::whenAll(Futures &amp;&amp;... <db:emphasis>futures</db:emphasis>)</db:title>
<db:para>Returns a new <db:link xlink:href="qfuture.xml">QFuture</db:link> that succeeds when all <db:code role="parameter">futures</db:code> packaging arbitrary types complete. OutputSequence is a sequence of completed futures. The type of its entries is std::variant&lt;Futures...&gt;. For each QFuture&lt;T&gt; passed to whenAll(), the entry at the corresponding position in OutputSequence will be a std::variant holding that QFuture&lt;T&gt;, in its completed state. If the type of OutputSequence is not specified, the resulting futures will be returned in a <db:link xlink:href="qlist.xml">QList</db:link> of std::variant&lt;Futures...&gt;. For example:</db:para>
<db:programlisting language="cpp">QFuture&lt;int&gt; intFuture = ...;
QFuture&lt;QString&gt; stringFuture = ...;
QFuture&lt;void&gt; voidFuture = ...;

using FuturesVariant = std::variant&lt;QFuture&lt;int&gt;, QFuture&lt;QString&gt;, QFuture&lt;void&gt;&gt;;

// whenAll has type QFuture&lt;QList&lt;FuturesVariant&gt;&gt;
auto whenAll = QtFuture::whenAll(intFuture, stringFuture, voidFuture);

// whenAllVector has type QFuture&lt;std::vector&lt;FuturesVariant&gt;&gt;
auto whenAllVector =
        QtFuture::whenAll&lt;std::vector&lt;FuturesVariant&gt;&gt;(intFuture, stringFuture, voidFuture);

</db:programlisting>
<db:note>
<db:para>The output sequence should support random access and the resize() operation.</db:para>
</db:note>
<db:para>The returned future always completes successfully after all the specified futures complete. It doesn't matter if any of these futures completes with error or is canceled. You can use .then() to process the completed futures after the future returned by whenAll() succeeds:</db:para>
<db:programlisting language="cpp">QFuture&lt;int&gt; intFuture = ...;
QFuture&lt;QString&gt; stringFuture = ...;
QFuture&lt;void&gt; voidFuture = ...;

using FuturesVariant = std::variant&lt;QFuture&lt;int&gt;, QFuture&lt;QString&gt;, QFuture&lt;void&gt;&gt;;

QtFuture::whenAll(intFuture, stringFuture, voidFuture)
        .then([](const QList&lt;FuturesVariant&gt; &amp;results) {
            ...
            for (auto result : results)
            {
                // assuming handleResult() is overloaded based on the QFuture type
                std::visit([](auto &amp;&amp;future) { handleResult(future); }, result);
            }
            ...
        });
</db:programlisting>
<db:note>
<db:para>If the input futures complete on different threads, the future returned by this method will complete in the thread that the last future completes in. Therefore, the continuations attached to the future returned by whenAll() cannot always make assumptions about which thread they will be run on. Use the overload of .then() that takes a context object if you want to control which thread the continuations are invoked on.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.3.</db:para>
</db:section>
<db:section xml:id="whenAll-1">
<db:title>[since 6.3] QFuture&lt;OutputSequence&gt; QtFuture::whenAll(InputIt <db:emphasis>first</db:emphasis>, InputIt <db:emphasis>last</db:emphasis>)</db:title>
<db:para>Returns a new <db:link xlink:href="qfuture.xml">QFuture</db:link> that succeeds when all futures from <db:code role="parameter">first</db:code> to <db:code role="parameter">last</db:code> complete. <db:code role="parameter">first</db:code> and <db:code role="parameter">last</db:code> are iterators to a sequence of futures packaging type T. OutputSequence is a sequence containing all completed futures from <db:code role="parameter">first</db:code> to <db:code role="parameter">last</db:code>, appearing in the same order as in the input. If the type of OutputSequence is not specified, the resulting futures will be returned in a QList of QFuture&lt;T&gt;. For example:</db:para>
<db:programlisting language="cpp">QList&lt;QFuture&lt;int&gt;&gt; inputFutures {...};

// whenAll has type QFuture&lt;QList&lt;QFuture&lt;int&gt;&gt;&gt;
auto whenAll = QtFuture::whenAll(inputFutures.begin(), inputFutures.end());

// whenAllVector has type QFuture&lt;std::vector&lt;QFuture&lt;int&gt;&gt;&gt;
auto whenAllVector =
        QtFuture::whenAll&lt;std::vector&lt;QFuture&lt;int&gt;&gt;&gt;(inputFutures.begin(), inputFutures.end());
</db:programlisting>
<db:note>
<db:para>The output sequence must support random access and the resize() operation.</db:para>
</db:note>
<db:para>If first equals last, this function returns a ready <db:link xlink:href="qfuture.xml">QFuture</db:link> that contains an empty OutputSequence.</db:para>
<db:para>The returned future always completes successfully after all the specified futures complete. It doesn't matter if any of these futures completes with error or is canceled. You can use .then() to process the completed futures after the future returned by whenAll() succeeds:</db:para>
<db:programlisting language="cpp">QList&lt;QFuture&lt;int&gt;&gt; inputFutures {...};

QtFuture::whenAll(inputFutures.begin(), inputFutures.end())
        .then([](const QList&lt;QFuture&lt;int&gt;&gt; &amp;results) {
            for (auto future : results) {
                if (future.isCanceled())
                    // handle the cancellation (possibly due to an exception)
                else
                    // do something with the result
            }
        });
</db:programlisting>
<db:note>
<db:para>If the input futures complete on different threads, the future returned by this method will complete in the thread that the last future completes in. Therefore, the continuations attached to the future returned by whenAll() cannot always make assumptions about which thread they will be run on. Use the overload of .then() that takes a context object if you want to control which thread the continuations are invoked on.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.3.</db:para>
</db:section>
<db:section xml:id="whenAny">
<db:title>[since 6.3] QFuture&lt;std::variant&lt;std::decay_t&lt;Futures&gt;...&gt;&gt; QtFuture::whenAny(Futures &amp;&amp;... <db:emphasis>futures</db:emphasis>)</db:title>
<db:para>Returns a new <db:link xlink:href="qfuture.xml">QFuture</db:link> that succeeds when any of the <db:code role="parameter">futures</db:code> completes. <db:code role="parameter">futures</db:code> can package arbitrary types. The returned future packages the value of type std::variant&lt;Futures...&gt; which in turn packages the first completed <db:link xlink:href="qfuture.xml">QFuture</db:link> from <db:code role="parameter">futures</db:code>. You can use <db:link xlink:href="https://en.cppreference.com/w/cpp/utility/variant/index">std::variant::index()</db:link> to find out the index of the future in the sequence of <db:code role="parameter">futures</db:code> that finished first.</db:para>
<db:para>The returned future always completes successfully after the first future from the specified futures completes. It doesn't matter if the first future completes with error or is canceled. You can use .then() to process the result after the future returned by whenAny() succeeds:</db:para>
<db:programlisting language="cpp">QFuture&lt;int&gt; intFuture = ...;
QFuture&lt;QString&gt; stringFuture = ...;
QFuture&lt;void&gt; voidFuture = ...;

using FuturesVariant = std::variant&lt;QFuture&lt;int&gt;, QFuture&lt;QString&gt;, QFuture&lt;void&gt;&gt;;

QtFuture::whenAny(intFuture, stringFuture, voidFuture).then([](const FuturesVariant &amp;result) {
    ...
    // assuming handleResult() is overloaded based on the QFuture type
    std::visit([](auto &amp;&amp;future) { handleResult(future); }, result);
    ...
});
</db:programlisting>
<db:note>
<db:para>If the input futures complete on different threads, the future returned by this method will complete in the thread that the first future completes in. Therefore, the continuations attached to the future returned by whenAny() cannot always make assumptions about which thread they will be run on. Use the overload of .then() that takes a context object if you want to control which thread the continuations are invoked on.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.3.</db:para>
</db:section>
<db:section xml:id="whenAny-1">
<db:title>[since 6.3] QFuture&lt;QtFuture::WhenAnyResult&lt;T&gt;&gt; QtFuture::whenAny(InputIt <db:emphasis>first</db:emphasis>, InputIt <db:emphasis>last</db:emphasis>)</db:title>
<db:para>Returns a new <db:link xlink:href="qfuture.xml">QFuture</db:link> that succeeds when any of the futures from <db:code role="parameter">first</db:code> to <db:code role="parameter">last</db:code> completes. <db:code role="parameter">first</db:code> and <db:code role="parameter">last</db:code> are iterators to a sequence of futures packaging type T. The returned future packages a value of type QtFuture::WhenAnyResult&lt;T&gt; which in turn packages the index of the first completed QFuture and the QFuture itself. If <db:code role="parameter">first</db:code> equals <db:code role="parameter">last</db:code>, this function returns a ready QFuture that has -1 for the index field in the <db:link xlink:href="qtfuture-whenanyresult.xml">QtFuture::WhenAnyResult</db:link> struct and a default-constructed QFuture&lt;T&gt; for the future field. Note that a default-constructed <db:link xlink:href="qfuture.xml">QFuture</db:link> is a completed future in a cancelled state.</db:para>
<db:para>The returned future always completes successfully after the first future from the specified futures completes. It doesn't matter if the first future completes with error or is canceled. You can use .then() to process the result after the future returned by whenAny() succeeds:</db:para>
<db:programlisting language="cpp">QList&lt;QFuture&lt;int&gt;&gt; inputFutures = ...;

QtFuture::whenAny(inputFutures.begin(), inputFutures.end())
        .then([](const QtFuture::WhenAnyResult&lt;int&gt; &amp;result) {
            qsizetype index = result.index;
            QFuture&lt;int&gt; future = result.future;
            // ...
        });
</db:programlisting>
<db:note>
<db:para>If the input futures complete on different threads, the future returned by this method will complete in the thread that the first future completes in. Therefore, the continuations attached to the future returned by whenAny() cannot always make assumptions about which thread they will be run on. Use the overload of .then() that takes a context object if you want to control which thread the continuations are invoked on.</db:para>
</db:note>
<db:para>This function was introduced in Qt 6.3.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtfuture-whenanyresult.xml">QtFuture::WhenAnyResult</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="obsolete">
<db:title>Obsolete Members for QtFuture</db:title>
<db:para><db:emphasis role="bold">The following members of class <db:link xlink:href="qtfuture.xml">QtFuture</db:link> are deprecated.</db:emphasis> We strongly advise against using them in new code.</db:para>
<db:section xml:id="obsolete-function-documentation">
<db:title>Obsolete Function Documentation</db:title>
<db:section xml:id="makeReadyFuture">
<db:title>[since 6.1, deprecated in 6.6] QFuture&lt;void&gt; QtFuture::makeReadyFuture()</db:title>
<db:para>This function is deprecated since 6.6. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use <db:link xlink:href="qtfuture.xml#makeReadyVoidFuture">makeReadyVoidFuture</db:link>() instead.</db:para>
<db:para>Creates and returns a void <db:link xlink:href="qfuture.xml">QFuture</db:link>. Such <db:link xlink:href="qfuture.xml">QFuture</db:link> can't store any result. One can use it to query the state of the computation. The returned <db:link xlink:href="qfuture.xml">QFuture</db:link> will always be in the finished state.</db:para>
<db:programlisting language="cpp">auto f = QtFuture::makeReadyFuture();
...
const bool started = f.isStarted(); // started == true
const bool running = f.isRunning(); // running == false
const bool finished = f.isFinished(); // finished == true
</db:programlisting>
<db:para>The method should be avoided because it has an inconsistent set of overloads. From Qt 6.10 onwards, using it in code will result in compiler warnings.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qfuture.xml#isStarted">QFuture::isStarted</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isRunning">QFuture::isRunning</db:link>()</db:member>
<db:member><db:link xlink:href="qfuture.xml#isFinished">QFuture::isFinished</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyVoidFuture">QtFuture::makeReadyVoidFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyValueFuture">QtFuture::makeReadyValueFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyRangeFuture">QtFuture::makeReadyRangeFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeExceptionalFuture">QtFuture::makeExceptionalFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeReadyFuture-1">
<db:title>[since 6.1, deprecated in 6.6] QFuture&lt;std::decay_t&lt;T&gt;&gt; QtFuture::makeReadyFuture(T &amp;&amp;<db:emphasis>value</db:emphasis>)</db:title>
<db:para>This function is deprecated since 6.6. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use <db:link xlink:href="qtfuture.xml#makeReadyValueFuture">makeReadyValueFuture</db:link>() instead.</db:para>
<db:para>Creates and returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> which already has a result <db:code role="parameter">value</db:code>. The returned <db:link xlink:href="qfuture.xml">QFuture</db:link> has a type of std::decay_t&lt;T&gt;, where T is not void.</db:para>
<db:programlisting language="cpp">auto f = QtFuture::makeReadyFuture(std::make_unique&lt;int&gt;(42));
...
const int result = *f.takeResult(); // result == 42
</db:programlisting>
<db:para>The method should be avoided because it has an inconsistent set of overloads. From Qt 6.10 onwards, using it in code will result in compiler warnings.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyVoidFuture">QtFuture::makeReadyVoidFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyValueFuture">QtFuture::makeReadyValueFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyRangeFuture">QtFuture::makeReadyRangeFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeExceptionalFuture">QtFuture::makeExceptionalFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="makeReadyFuture-2">
<db:title>[since 6.1, deprecated in 6.6] QFuture&lt;T&gt; QtFuture::makeReadyFuture(const QList&lt;T&gt; &amp;<db:emphasis>values</db:emphasis>)</db:title>
<db:para>This function is deprecated since 6.6. We strongly advise against using it in new code.</db:para>
<db:para>This is an overloaded function.</db:para>
<db:para>Use <db:link xlink:href="qtfuture.xml#makeReadyRangeFuture">makeReadyRangeFuture</db:link>() instead.</db:para>
<db:para>Creates and returns a <db:link xlink:href="qfuture.xml">QFuture</db:link> which already has multiple results set from <db:code role="parameter">values</db:code>.</db:para>
<db:programlisting language="cpp">const QList&lt;int&gt; values { 1, 2, 3 };
auto f = QtFuture::makeReadyFuture(values);
...
const int count = f.resultCount(); // count == 3
const auto results = f.results(); // results == { 1, 2, 3 }
</db:programlisting>
<db:para>The method should be avoided because it has an inconsistent set of overloads. From Qt 6.10 onwards, using it in code will result in compiler warnings.</db:para>
<db:para>This function was introduced in Qt 6.1.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qfuture.xml">QFuture</db:link></db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyVoidFuture">QtFuture::makeReadyVoidFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyValueFuture">QtFuture::makeReadyValueFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeReadyRangeFuture">QtFuture::makeReadyRangeFuture</db:link>()</db:member>
<db:member><db:link xlink:href="qtfuture.xml#makeExceptionalFuture">QtFuture::makeExceptionalFuture</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
</db:section>
</db:article>
