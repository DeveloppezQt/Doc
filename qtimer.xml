<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QTimer Class</db:title>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.12.12 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qtimer.xml">QTimer</db:link> class provides repetitive and single-shot timers.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QTimer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qobject.xml" xlink:role="class">QObject</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para/>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QTimer is part of <db:simplelist><db:member><db:link xlink:href="events.xml">Event Classes</db:link></db:member></db:simplelist></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>The <db:link xlink:href="qtimer.xml">QTimer</db:link> class provides a high-level programming interface for timers. To use it, create a <db:link xlink:href="qtimer.xml">QTimer</db:link>, connect its <db:link xlink:href="qtimer.xml#timeout">timeout</db:link>() signal to the appropriate slots, and call <db:link xlink:href="qtimer.xml#start-1">start</db:link>(). From then on, it will emit the <db:link xlink:href="qtimer.xml#timeout">timeout</db:link>() signal at constant intervals.</db:para>
<db:para>Example for a one second (1000 millisecond) timer (from the <db:link xlink:href="qtwidgets-widgets-analogclock-example.xml">Analog Clock</db:link> example):</db:para>
<db:programlisting language="cpp">    QTimer *timer = new QTimer(this);
    connect(timer, SIGNAL(timeout()), this, SLOT(update()));
    timer-&amp;gt;start(1000);
</db:programlisting>
<db:para>From then on, the update() slot is called every second.</db:para>
<db:para>You can set a timer to time out only once by calling <db:link xlink:href="qtimer.xml#singleShot-prop">setSingleShot</db:link>(true). You can also use the static <db:link xlink:href="qtimer.xml#singleShot">QTimer::singleShot</db:link>() function to call a slot after a specified interval:</db:para>
<db:programlisting language="cpp">    QTimer::singleShot(200, this, SLOT(updateCaption()));
</db:programlisting>
<db:para>In multithreaded applications, you can use <db:link xlink:href="qtimer.xml">QTimer</db:link> in any thread that has an event loop. To start an event loop from a non-GUI thread, use <db:link xlink:href="qthread.xml#exec">QThread::exec</db:link>(). Qt uses the timer's <db:link xlink:href="qobject.xml#thread">thread affinity</db:link> to determine which thread will emit the <db:link xlink:href="qtimer.xml#timeout">timeout</db:link>() signal. Because of this, you must start and stop the timer in its thread; it is not possible to start a timer from another thread.</db:para>
<db:para>As a special case, a <db:link xlink:href="qtimer.xml">QTimer</db:link> with a timeout of 0 will time out as soon as all the events in the window system's event queue have been processed. This can be used to do heavy work while providing a snappy user interface:</db:para>
<db:programlisting language="cpp">    QTimer *timer = new QTimer(this);
    connect(timer, SIGNAL(timeout()), this, SLOT(processOneThing()));
    timer-&amp;gt;start();
</db:programlisting>
<db:para>From then on, processOneThing() will be called repeatedly. It should be written in such a way that it always returns quickly (typically after processing one data item) so that Qt can deliver events to the user interface and stop the timer as soon as it has done all its work. This is the traditional way of implementing heavy work in GUI applications, but as multithreading is nowadays becoming available on more and more platforms, we expect that zero-millisecond <db:link xlink:href="qtimer.xml">QTimer</db:link> objects will gradually be replaced by <db:link xlink:href="qthread.xml">QThread</db:link>s.</db:para>
<db:section xml:id="accuracy-and-timer-resolution">
<db:title>Accuracy and Timer Resolution</db:title>
<db:para>The accuracy of timers depends on the underlying operating system and hardware. Most platforms support a resolution of 1 millisecond, though the accuracy of the timer will not equal this resolution in many real-world situations.</db:para>
<db:para>The accuracy also depends on the <db:link xlink:href="qt.xml#TimerType-enum">timer type</db:link>. For <db:link xlink:href="qt.xml#TimerType-enum">Qt::PreciseTimer</db:link>, <db:link xlink:href="qtimer.xml">QTimer</db:link> will try to keep the accuracy at 1 millisecond. Precise timers will also never time out earlier than expected.</db:para>
<db:para>For <db:link xlink:href="qt.xml#TimerType-enum">Qt::CoarseTimer</db:link> and <db:link xlink:href="qt.xml#TimerType-enum">Qt::VeryCoarseTimer</db:link> types, <db:link xlink:href="qtimer.xml">QTimer</db:link> may wake up earlier than expected, within the margins for those types: 5% of the interval for <db:link xlink:href="qt.xml#TimerType-enum">Qt::CoarseTimer</db:link> and 500 ms for <db:link xlink:href="qt.xml#TimerType-enum">Qt::VeryCoarseTimer</db:link>.</db:para>
<db:para>All timer types may time out later than expected if the system is busy or unable to provide the requested accuracy. In such a case of timeout overrun, Qt will emit <db:link xlink:href="qtimer.xml#timeout">timeout</db:link>() only once, even if multiple timeouts have expired, and then will resume the original interval.</db:para>
</db:section>
<db:section xml:id="alternatives-to-qtimer">
<db:title>Alternatives to QTimer</db:title>
<db:para>An alternative to using <db:link xlink:href="qtimer.xml">QTimer</db:link> is to call <db:link xlink:href="qobject.xml#startTimer">QObject::startTimer</db:link>() for your object and reimplement the <db:link xlink:href="qobject.xml#timerEvent">QObject::timerEvent</db:link>() event handler in your class (which must inherit <db:link xlink:href="qobject.xml">QObject</db:link>). The disadvantage is that <db:link xlink:href="qtimer.xml#timerEvent">timerEvent</db:link>() does not support such high-level features as single-shot timers or signals.</db:para>
<db:para>Another alternative is <db:link xlink:href="qbasictimer.xml">QBasicTimer</db:link>. It is typically less cumbersome than using <db:link xlink:href="qobject.xml#startTimer">QObject::startTimer</db:link>() directly. See <db:link xlink:href="timers.xml">Timers</db:link> for an overview of all three approaches.</db:para>
<db:para>Some operating systems limit the number of timers that may be used; Qt tries to work around these limitations.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qbasictimer.xml">QBasicTimer</db:link></db:member>
<db:member><db:link xlink:href="qtimerevent.xml">QTimerEvent</db:link></db:member>
<db:member><db:link xlink:href="qobject.xml#timerEvent">QObject::timerEvent</db:link>()</db:member>
<db:member><db:link xlink:href="timers.xml">Timers</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-analogclock-example.xml">Analog Clock Example</db:link></db:member>
<db:member><db:link xlink:href="qtwidgets-widgets-wiggly-example.xml">Wiggly Example</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="active-prop">
<db:title>[read-only, since 4.3] active : const bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>active</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isActive</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This boolean property is true if the timer is running; otherwise false.</db:para>
<db:para>This property was introduced in Qt 4.3.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold"><db:link xlink:href="qtimer.xml#isActive">isActive</db:link></db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="interval-prop">
<db:title>interval : int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>interval</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">interval</db:synopsisinfo>
<db:synopsisinfo role="setter">setInterval</db:synopsisinfo>
<db:synopsisinfo role="setter">setInterval</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the timeout interval in milliseconds</db:para>
<db:para>The default value for this property is 0. A <db:link xlink:href="qtimer.xml">QTimer</db:link> with a timeout interval of 0 will time out as soon as all the events in the window system's event queue have been processed.</db:para>
<db:para>Setting the interval of an active timer changes its <db:link xlink:href="qtimer.xml#timerId">timerId</db:link>().</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">interval</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setInterval</db:emphasis>(<db:type>int</db:type> <db:emphasis>msec</db:emphasis>)</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setInterval</db:emphasis>(<db:type>std::chrono::milliseconds</db:type> <db:emphasis>value</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#singleShot">singleShot</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="remainingTime-prop">
<db:title>[read-only, since 5.0] remainingTime : const int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>remainingTime</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">remainingTime</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the remaining time in milliseconds</db:para>
<db:para>Returns the timer's remaining value in milliseconds left until the timeout. If the timer is inactive, the returned value will be -1. If the timer is overdue, the returned value will be 0.</db:para>
<db:para>This property was introduced in Qt 5.0.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">remainingTime</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#interval-prop">interval</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singleShot-prop">
<db:title>singleShot : bool</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>bool</db:type>
<db:varname>singleShot</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">isSingleShot</db:synopsisinfo>
<db:synopsisinfo role="setter">setSingleShot</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds whether the timer is a single-shot timer</db:para>
<db:para>A single-shot timer fires only once, non-single-shot timers fire every <db:link xlink:href="qtimer.xml#interval-prop">interval</db:link> milliseconds.</db:para>
<db:para>The default value for this property is false.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>bool</db:type> <db:emphasis role="bold">isSingleShot</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setSingleShot</db:emphasis>(<db:type>bool</db:type> <db:emphasis>singleShot</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#interval-prop">interval</db:link></db:member>
<db:member><db:link xlink:href="qtimer.xml#singleShot">singleShot</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="timerType-prop">
<db:title>timerType : Qt::TimerType</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>Qt::TimerType</db:type>
<db:varname>timerType</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">timerType</db:synopsisinfo>
<db:synopsisinfo role="setter">setTimerType</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>controls the accuracy of the timer</db:para>
<db:para>The default value for this property is Qt::CoarseTimer.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qt.xml#TimerType-enum">Qt::TimerType</db:link></db:type> <db:emphasis role="bold">timerType</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setTimerType</db:emphasis>(<db:type><db:link xlink:href="qt.xml#TimerType-enum">Qt::TimerType</db:link></db:type> <db:emphasis>atype</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qt.xml#TimerType-enum">Qt::TimerType</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QTimer">
<db:title>[explicit] QTimer::QTimer(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QTimer</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QTimer(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a timer with the given <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QTimer">
<db:title>[virtual] QTimer::~QTimer()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QTimer</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QTimer()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Destroys the timer.</db:para>
</db:section>
<db:section xml:id="callOnTimeout">
<db:title>[since 5.12] QMetaObject::Connection QTimer::callOnTimeout(Functor <db:emphasis>slot</db:emphasis>, Qt::ConnectionType <db:emphasis>connectionType</db:emphasis> = Qt::AutoConnection)</db:title>
<db:methodsynopsis>
<db:type>QMetaObject::Connection</db:type>
<db:methodname>callOnTimeout</db:methodname>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>slot</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ConnectionType</db:type>
<db:parameter>connectionType</db:parameter>
<db:initializer>Qt::AutoConnection</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaObject::Connection callOnTimeout(Functor slot, Qt::ConnectionType connectionType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Creates a connection from the <db:link xlink:href="qtimer.xml#timeout">timeout</db:link>() signal to <db:code role="parameter">slot</db:code>, and returns a handle to the connection.</db:para>
<db:para>This method is provided for convenience. It's equivalent to calling QObject::connect(timer, &amp;QTimer::timeout, timer, slot, connectionType).</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qobject.xml#connect">QObject::connect</db:link>()</db:member>
<db:member><db:link xlink:href="qtimer.xml#timeout">timeout</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="callOnTimeout-1">
<db:title>[since 5.12] QMetaObject::Connection QTimer::callOnTimeout(const QObject *<db:emphasis>context</db:emphasis>, Functor <db:emphasis>slot</db:emphasis>, Qt::ConnectionType <db:emphasis>connectionType</db:emphasis> = Qt::AutoConnection)</db:title>
<db:methodsynopsis>
<db:type>QMetaObject::Connection</db:type>
<db:methodname>callOnTimeout</db:methodname>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>context</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>slot</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ConnectionType</db:type>
<db:parameter>connectionType</db:parameter>
<db:initializer>Qt::AutoConnection</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaObject::Connection callOnTimeout(const QObject *context, Functor slot, Qt::ConnectionType connectionType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads <db:link xlink:href="qtimer.xml#callOnTimeout">callOnTimeout</db:link>().</db:para>
<db:para>Creates a connection from the <db:link xlink:href="qtimer.xml#timeout">timeout</db:link>() signal to <db:code role="parameter">slot</db:code> to be placed in a specific event loop of <db:code role="parameter">context</db:code>, and returns a handle to the connection.</db:para>
<db:para>This method is provided for convenience. It's equivalent to calling QObject::connect(timer, &amp;QTimer::timeout, context, slot, connectionType).</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qobject.xml#connect">QObject::connect</db:link>()</db:member>
<db:member><db:link xlink:href="qtimer.xml#timeout">timeout</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="callOnTimeout-2">
<db:title>[since 5.12] QMetaObject::Connection QTimer::callOnTimeout(const QObject *<db:emphasis>receiver</db:emphasis>, PointerToMemberFunction <db:emphasis>slot</db:emphasis>, Qt::ConnectionType <db:emphasis>connectionType</db:emphasis> = Qt::AutoConnection)</db:title>
<db:methodsynopsis>
<db:type>QMetaObject::Connection</db:type>
<db:methodname>callOnTimeout</db:methodname>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>PointerToMemberFunction</db:type>
<db:parameter>slot</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::ConnectionType</db:type>
<db:parameter>connectionType</db:parameter>
<db:initializer>Qt::AutoConnection</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">QMetaObject::Connection callOnTimeout(const QObject *receiver, PointerToMemberFunction slot, Qt::ConnectionType connectionType)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads <db:link xlink:href="qtimer.xml#callOnTimeout">callOnTimeout</db:link>().</db:para>
<db:para>Creates a connection from the <db:link xlink:href="qtimer.xml#timeout">timeout</db:link>() signal to the <db:code role="parameter">slot</db:code> in the <db:code role="parameter">receiver</db:code> object. Returns a handle to the connection.</db:para>
<db:para>This method is provided for convenience. It's equivalent to calling QObject::connect(timer, &amp;QTimer::timeout, receiver, slot, connectionType).</db:para>
<db:para>This function was introduced in Qt 5.12.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qobject.xml#connect">QObject::connect</db:link>()</db:member>
<db:member><db:link xlink:href="qtimer.xml#timeout">timeout</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="intervalAsDuration">
<db:title>[since 5.8] std::chrono::milliseconds QTimer::intervalAsDuration() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>std::chrono::milliseconds</db:type>
<db:methodname>intervalAsDuration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">std::chrono::milliseconds intervalAsDuration() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the interval of this timer as a std::chrono::milliseconds object.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#interval-prop">interval</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="isActive">
<db:title>bool QTimer::isActive() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>bool</db:type>
<db:methodname>isActive</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="associated-property">active</db:synopsisinfo>
<db:synopsisinfo role="signature">bool isActive() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns true if the timer is running (pending); otherwise returns false.</db:para>
<db:note>
<db:para>Getter function for property <db:link xlink:href="qtimer.xml#active-prop">active</db:link>. </db:para>
</db:note>
</db:section>
<db:section xml:id="remainingTimeAsDuration">
<db:title>[since 5.8] std::chrono::milliseconds QTimer::remainingTimeAsDuration() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>std::chrono::milliseconds</db:type>
<db:methodname>remainingTimeAsDuration</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">std::chrono::milliseconds remainingTimeAsDuration() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the time remaining in this timer object as a std::chrono::milliseconds object. If this timer is due or overdue, the returned value is std::chrono::milliseconds::zero(). If the remaining time could not be found or the timer is not active, this function returns a negative duration.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#remainingTime-prop">remainingTime</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singleShot">
<db:title>[static] void QTimer::singleShot(int <db:emphasis>msec</db:emphasis>, const QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>member</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>singleShot</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>member</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void singleShot(int msec, const QObject *receiver, const char *member)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">reentrant</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This static function calls a slot after a given time interval.</db:para>
<db:para>It is very convenient to use this function because you do not need to bother with a <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link> or create a local <db:link xlink:href="qtimer.xml">QTimer</db:link> object.</db:para>
<db:para>Example:</db:para>
<db:programlisting language="cpp">#include &amp;lt;QApplication&amp;gt;
#include &amp;lt;QTimer&amp;gt;

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    QTimer::singleShot(600000, &amp;amp;app, SLOT(quit()));
    ...
    return app.exec();
}
</db:programlisting>
<db:para>This sample program automatically terminates after 10 minutes (600,000 milliseconds).</db:para>
<db:para>The <db:code role="parameter">receiver</db:code> is the receiving object and the <db:code role="parameter">member</db:code> is the slot. The time interval is <db:code role="parameter">msec</db:code> milliseconds.</db:para>
<db:note>
<db:para>This function is <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#singleShot-prop">setSingleShot</db:link>()</db:member>
<db:member><db:link xlink:href="qtimer.xml#start-1">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singleShot-1">
<db:title>[static] void QTimer::singleShot(int <db:emphasis>msec</db:emphasis>, Qt::TimerType <db:emphasis>timerType</db:emphasis>, const QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>member</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>singleShot</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::TimerType</db:type>
<db:parameter>timerType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>member</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void singleShot(int msec, Qt::TimerType timerType, const QObject *receiver, const char *member)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">reentrant</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This static function calls a slot after a given time interval.</db:para>
<db:para>It is very convenient to use this function because you do not need to bother with a <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link> or create a local <db:link xlink:href="qtimer.xml">QTimer</db:link> object.</db:para>
<db:para>The <db:code role="parameter">receiver</db:code> is the receiving object and the <db:code role="parameter">member</db:code> is the slot. The time interval is <db:code role="parameter">msec</db:code> milliseconds. The <db:code role="parameter">timerType</db:code> affects the accuracy of the timer.</db:para>
<db:note>
<db:para>This function is <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#start-1">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singleShot-2">
<db:title>[static, since 5.4] void QTimer::singleShot(int <db:emphasis>msec</db:emphasis>, const QObject *<db:emphasis>receiver</db:emphasis>, PointerToMemberFunction <db:emphasis>method</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>singleShot</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>PointerToMemberFunction</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void singleShot(int msec, const QObject *receiver, PointerToMemberFunction method)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">reentrant</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This static function calls a member function of a <db:link xlink:href="qobject.xml">QObject</db:link> after a given time interval.</db:para>
<db:para>It is very convenient to use this function because you do not need to bother with a <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link> or create a local <db:link xlink:href="qtimer.xml">QTimer</db:link> object.</db:para>
<db:para>The <db:code role="parameter">receiver</db:code> is the receiving object and the <db:code role="parameter">method</db:code> is the member function. The time interval is <db:code role="parameter">msec</db:code> milliseconds.</db:para>
<db:para>If <db:code role="parameter">receiver</db:code> is destroyed before the interval occurs, the method will not be called. The function will be run in the thread of <db:code role="parameter">receiver</db:code>. The receiver's thread must have a running Qt event loop.</db:para>
<db:note>
<db:para>This function is <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#start-1">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singleShot-3">
<db:title>[static, since 5.4] void QTimer::singleShot(int <db:emphasis>msec</db:emphasis>, Qt::TimerType <db:emphasis>timerType</db:emphasis>, const QObject *<db:emphasis>receiver</db:emphasis>, PointerToMemberFunction <db:emphasis>method</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>singleShot</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::TimerType</db:type>
<db:parameter>timerType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>PointerToMemberFunction</db:type>
<db:parameter>method</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">3</db:synopsisinfo>
<db:synopsisinfo role="signature">void singleShot(int msec, Qt::TimerType timerType, const QObject *receiver, PointerToMemberFunction method)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">reentrant</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This static function calls a member function of a <db:link xlink:href="qobject.xml">QObject</db:link> after a given time interval.</db:para>
<db:para>It is very convenient to use this function because you do not need to bother with a <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link> or create a local <db:link xlink:href="qtimer.xml">QTimer</db:link> object.</db:para>
<db:para>The <db:code role="parameter">receiver</db:code> is the receiving object and the <db:code role="parameter">method</db:code> is the member function. The time interval is <db:code role="parameter">msec</db:code> milliseconds. The <db:code role="parameter">timerType</db:code> affects the accuracy of the timer.</db:para>
<db:para>If <db:code role="parameter">receiver</db:code> is destroyed before the interval occurs, the method will not be called. The function will be run in the thread of <db:code role="parameter">receiver</db:code>. The receiver's thread must have a running Qt event loop.</db:para>
<db:note>
<db:para>This function is <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#start-1">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singleShot-4">
<db:title>[static, since 5.4] void QTimer::singleShot(int <db:emphasis>msec</db:emphasis>, Functor <db:emphasis>functor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>singleShot</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>functor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">4</db:synopsisinfo>
<db:synopsisinfo role="signature">void singleShot(int msec, Functor functor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">reentrant</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This static function calls <db:code role="parameter">functor</db:code> after a given time interval.</db:para>
<db:para>It is very convenient to use this function because you do not need to bother with a <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link> or create a local <db:link xlink:href="qtimer.xml">QTimer</db:link> object.</db:para>
<db:para>The time interval is <db:code role="parameter">msec</db:code> milliseconds.</db:para>
<db:note>
<db:para>This function is <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#start-1">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singleShot-5">
<db:title>[static, since 5.4] void QTimer::singleShot(int <db:emphasis>msec</db:emphasis>, Qt::TimerType <db:emphasis>timerType</db:emphasis>, Functor <db:emphasis>functor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>singleShot</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::TimerType</db:type>
<db:parameter>timerType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>functor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">5</db:synopsisinfo>
<db:synopsisinfo role="signature">void singleShot(int msec, Qt::TimerType timerType, Functor functor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">reentrant</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This static function calls <db:code role="parameter">functor</db:code> after a given time interval.</db:para>
<db:para>It is very convenient to use this function because you do not need to bother with a <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link> or create a local <db:link xlink:href="qtimer.xml">QTimer</db:link> object.</db:para>
<db:para>The time interval is <db:code role="parameter">msec</db:code> milliseconds. The <db:code role="parameter">timerType</db:code> affects the accuracy of the timer.</db:para>
<db:note>
<db:para>This function is <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#start-1">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singleShot-6">
<db:title>[static, since 5.4] void QTimer::singleShot(int <db:emphasis>msec</db:emphasis>, const QObject *<db:emphasis>context</db:emphasis>, Functor <db:emphasis>functor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>singleShot</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>context</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>functor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">6</db:synopsisinfo>
<db:synopsisinfo role="signature">void singleShot(int msec, const QObject *context, Functor functor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">reentrant</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This static function calls <db:code role="parameter">functor</db:code> after a given time interval.</db:para>
<db:para>It is very convenient to use this function because you do not need to bother with a <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link> or create a local <db:link xlink:href="qtimer.xml">QTimer</db:link> object.</db:para>
<db:para>The time interval is <db:code role="parameter">msec</db:code> milliseconds.</db:para>
<db:para>If <db:code role="parameter">context</db:code> is destroyed before the interval occurs, the method will not be called. The function will be run in the thread of <db:code role="parameter">context</db:code>. The context's thread must have a running Qt event loop.</db:para>
<db:note>
<db:para>This function is <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#start-1">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singleShot-7">
<db:title>[static, since 5.4] void QTimer::singleShot(int <db:emphasis>msec</db:emphasis>, Qt::TimerType <db:emphasis>timerType</db:emphasis>, const QObject *<db:emphasis>context</db:emphasis>, Functor <db:emphasis>functor</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>singleShot</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::TimerType</db:type>
<db:parameter>timerType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>context</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Functor</db:type>
<db:parameter>functor</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">7</db:synopsisinfo>
<db:synopsisinfo role="signature">void singleShot(int msec, Qt::TimerType timerType, const QObject *context, Functor functor)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">reentrant</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This static function calls <db:code role="parameter">functor</db:code> after a given time interval.</db:para>
<db:para>It is very convenient to use this function because you do not need to bother with a <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link> or create a local <db:link xlink:href="qtimer.xml">QTimer</db:link> object.</db:para>
<db:para>The time interval is <db:code role="parameter">msec</db:code> milliseconds. The <db:code role="parameter">timerType</db:code> affects the accuracy of the timer.</db:para>
<db:para>If <db:code role="parameter">context</db:code> is destroyed before the interval occurs, the method will not be called. The function will be run in the thread of <db:code role="parameter">context</db:code>. The context's thread must have a running Qt event loop.</db:para>
<db:note>
<db:para>This function is <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.4.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#start-1">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singleShot-8">
<db:title>[static, since 5.8] void QTimer::singleShot(std::chrono::milliseconds <db:emphasis>msec</db:emphasis>, const QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>member</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>singleShot</db:methodname>
<db:methodparam>
<db:type>std::chrono::milliseconds</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>member</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">8</db:synopsisinfo>
<db:synopsisinfo role="signature">void singleShot(std::chrono::milliseconds msec, const QObject *receiver, const char *member)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">reentrant</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This static function calls a slot after a given time interval.</db:para>
<db:para>It is very convenient to use this function because you do not need to bother with a <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link> or create a local <db:link xlink:href="qtimer.xml">QTimer</db:link> object.</db:para>
<db:para>The <db:code role="parameter">receiver</db:code> is the receiving object and the <db:code role="parameter">member</db:code> is the slot. The time interval is given in the duration object <db:code role="parameter">msec</db:code>.</db:para>
<db:note>
<db:para>This function is <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#start-1">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="singleShot-9">
<db:title>[static, since 5.8] void QTimer::singleShot(std::chrono::milliseconds <db:emphasis>msec</db:emphasis>, Qt::TimerType <db:emphasis>timerType</db:emphasis>, const QObject *<db:emphasis>receiver</db:emphasis>, const char *<db:emphasis>member</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>static</db:modifier>
<db:void/>
<db:methodname>singleShot</db:methodname>
<db:methodparam>
<db:type>std::chrono::milliseconds</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>Qt::TimerType</db:type>
<db:parameter>timerType</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QObject *</db:type>
<db:parameter>receiver</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const char *</db:type>
<db:parameter>member</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">9</db:synopsisinfo>
<db:synopsisinfo role="signature">void singleShot(std::chrono::milliseconds msec, Qt::TimerType timerType, const QObject *receiver, const char *member)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">reentrant</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>This static function calls a slot after a given time interval.</db:para>
<db:para>It is very convenient to use this function because you do not need to bother with a <db:link xlink:href="qobject.xml#timerEvent">timerEvent</db:link> or create a local <db:link xlink:href="qtimer.xml">QTimer</db:link> object.</db:para>
<db:para>The <db:code role="parameter">receiver</db:code> is the receiving object and the <db:code role="parameter">member</db:code> is the slot. The time interval is given in the duration object <db:code role="parameter">msec</db:code>. The <db:code role="parameter">timerType</db:code> affects the accuracy of the timer.</db:para>
<db:note>
<db:para>This function is <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
<db:para>This function was introduced in Qt 5.8.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#start-1">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="start">
<db:title>void QTimer::start(int <db:emphasis>msec</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>start</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void start(int msec)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Starts or restarts the timer with a timeout interval of <db:code role="parameter">msec</db:code> milliseconds.</db:para>
<db:para>If the timer is already running, it will be <db:link xlink:href="qtimer.xml#stop">stopped</db:link> and restarted.</db:para>
<db:para>If <db:link xlink:href="qtimer.xml#singleShot">singleShot</db:link> is true, the timer will be activated only once.</db:para>
</db:section>
<db:section xml:id="start-1">
<db:title>void QTimer::start()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>start</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void start()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This function overloads start().</db:para>
<db:para>Starts or restarts the timer with the timeout specified in <db:link xlink:href="qtimer.xml#interval-prop">interval</db:link>.</db:para>
<db:para>If the timer is already running, it will be <db:link xlink:href="qtimer.xml#stop">stopped</db:link> and restarted.</db:para>
<db:para>If <db:link xlink:href="qtimer.xml#singleShot">singleShot</db:link> is true, the timer will be activated only once.</db:para>
</db:section>
<db:section xml:id="start-2">
<db:title>[since 5.8] void QTimer::start(std::chrono::milliseconds <db:emphasis>msec</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>start</db:methodname>
<db:methodparam>
<db:type>std::chrono::milliseconds</db:type>
<db:parameter>msec</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void start(std::chrono::milliseconds msec)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This is an overloaded function.</db:para>
<db:para>Starts or restarts the timer with a timeout of duration <db:code role="parameter">msec</db:code> milliseconds.</db:para>
<db:para>If the timer is already running, it will be <db:link xlink:href="qtimer.xml#stop">stopped</db:link> and restarted.</db:para>
<db:para>If <db:link xlink:href="qtimer.xml#singleShot">singleShot</db:link> is true, the timer will be activated only once.</db:para>
<db:para>This function was introduced in Qt 5.8.</db:para>
</db:section>
<db:section xml:id="stop">
<db:title>void QTimer::stop()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>stop</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void stop()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Stops the timer.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#start-1">start</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="timeout">
<db:title>void QTimer::timeout()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>timeout</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void timeout()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the timer times out.</db:para>
<db:note>
<db:para>This is a private signal. It can be used in signal connections but cannot be emitted by the user.</db:para></db:note>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtimer.xml#interval-prop">interval</db:link></db:member>
<db:member><db:link xlink:href="qtimer.xml#start-1">start</db:link>()</db:member>
<db:member><db:link xlink:href="qtimer.xml#stop">stop</db:link>()</db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="timerEvent">
<db:title>[override virtual protected] void QTimer::timerEvent(QTimerEvent *<db:emphasis>e</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:modifier>virtual</db:modifier>
<db:void/>
<db:methodname>timerEvent</db:methodname>
<db:methodparam>
<db:type>QTimerEvent *</db:type>
<db:parameter>e</db:parameter>
</db:methodparam>
<db:modifier>override</db:modifier>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void timerEvent(QTimerEvent *e) override</db:synopsisinfo>
<db:synopsisinfo role="access">protected</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Reimplements: <db:link xlink:href="qobject.xml#timerEvent" role="function">QObject::timerEvent(QTimerEvent *event)</db:link>.</db:para>
</db:section>
<db:section xml:id="timerId">
<db:title>int QTimer::timerId() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>int</db:type>
<db:methodname>timerId</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int timerId() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the ID of the timer if the timer is running; otherwise returns -1.</db:para>
</db:section>
</db:section>
</db:article>
