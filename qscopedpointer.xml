<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QScopedPointer Class</db:title>
<db:subtitle>template &lt;typename T, typename Cleanup = QScopedPointerDeleter&lt;T&gt;&gt; class QScopedPointer</db:subtitle>
<db:productname>QtCore</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Core Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link> class stores a pointer to a dynamically allocated object, and deletes it upon destruction.</db:para>
<db:para>This class was introduced in Qt 4.6.</db:para>
<db:note>
<db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.xml">reentrant</db:link>.</db:para>
</db:note>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QScopedPointer</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Since</db:term>
<db:listitem>
<db:para>Qt 4.6</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += core</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qscopedarraypointer.xml" xlink:role="class">QScopedArrayPointer</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Group</db:term>
<db:listitem>
<db:para>QScopedPointer is part of <db:simplelist><db:member>misc</db:member></db:simplelist>
</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>Managing heap allocated objects manually is hard and error prone, with the common result that code leaks memory and is hard to maintain. <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link> is a small utility class that heavily simplifies this by assigning stack-based memory ownership to heap allocations, more generally called resource acquisition is initialization(RAII).</db:para>
<db:para><db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link> guarantees that the object pointed to will get deleted when the current scope disappears.</db:para>
<db:para>Consider this function which does heap allocations, and has various exit points:</db:para>
<db:programlisting language="cpp">void myFunction(bool useSubClass)
{
    MyClass *p = useSubClass ? new MyClass() : new MySubClass;
    QIODevice *device = handsOverOwnership();

    if (m_value &gt; 3) {
        delete p;
        delete device;
        return;
    }

    try {
        process(device);
    }
    catch (...) {
        delete p;
        delete device;
        throw;
    }

    delete p;
    delete device;
}
</db:programlisting>
<db:para>It's encumbered by the manual delete calls. With <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link>, the code can be simplified to:</db:para>
<db:programlisting language="cpp">void myFunction(bool useSubClass)
{
    // assuming that MyClass has a virtual destructor
    QScopedPointer&lt;MyClass&gt; p(useSubClass ? new MyClass() : new MySubClass);
    QScopedPointer&lt;QIODevice&gt; device(handsOverOwnership());

    if (m_value &gt; 3)
        return;

    process(device);
}
</db:programlisting>
<db:para>The code the compiler generates for <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link> is the same as when writing it manually. Code that makes use of <db:code role="parameter">delete</db:code> are candidates for <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link> usage (and if not, possibly another type of smart pointer such as <db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link>). <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link> intentionally has no copy constructor or assignment operator, such that ownership and lifetime is clearly communicated.</db:para>
<db:para>The const qualification on a regular C++ pointer can also be expressed with a <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link>:</db:para>
<db:programlisting language="cpp">    const QWidget *const p = new QWidget();
    // is equivalent to:
    const QScopedPointer&lt;const QWidget&gt; p(new QWidget());

    QWidget *const p = new QWidget();
    // is equivalent to:
    const QScopedPointer&lt;QWidget&gt; p(new QWidget());

    const QWidget *p = new QWidget();
    // is equivalent to:
    QScopedPointer&lt;const QWidget&gt; p(new QWidget());
</db:programlisting>
<db:section xml:id="custom-cleanup-handlers">
<db:title>Custom Cleanup Handlers</db:title>
<db:para>Arrays as well as pointers that have been allocated with <db:code>malloc</db:code> must not be deleted using <db:code>delete</db:code>. <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link>'s second template parameter can be used for custom cleanup handlers.</db:para>
<db:para>The following custom cleanup handlers exist:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>QScopedPointerDeleter - the default, deletes the pointer using <db:code>delete</db:code></db:para>
</db:listitem>
<db:listitem>
<db:para>QScopedPointerArrayDeleter - deletes the pointer using <db:code>delete []</db:code>. Use this handler for pointers that were allocated with <db:code>new []</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>QScopedPointerPodDeleter - deletes the pointer using <db:code>free()</db:code>. Use this handler for pointers that were allocated with <db:code>malloc()</db:code>.</db:para>
</db:listitem>
<db:listitem>
<db:para>QScopedPointerDeleteLater - deletes a pointer by calling <db:code>deleteLater()</db:code> on it. Use this handler for pointers to <db:link xlink:href="qobject.xml">QObject</db:link>'s that are actively participating in a <db:link xlink:href="qeventloop.xml">QEventLoop</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>You can pass your own classes as handlers, provided that they have a public static function <db:code>void cleanup(T *pointer)</db:code>.</db:para>
<db:programlisting language="cpp">// this QScopedPointer deletes its data using the delete[] operator:
QScopedPointer&lt;int, QScopedPointerArrayDeleter&lt;int&gt; &gt; arrayPointer(new int[42]);

// this QScopedPointer frees its data using free():
QScopedPointer&lt;int, QScopedPointerPodDeleter&gt; podPointer(reinterpret_cast&lt;int *&gt;(malloc(42)));

// this struct calls &quot;myCustomDeallocator&quot; to delete the pointer
struct ScopedPointerCustomDeleter
{
    static inline void cleanup(MyCustomClass *pointer)
    {
        myCustomDeallocator(pointer);
    }
};

// QScopedPointer using a custom deleter:
QScopedPointer&lt;MyCustomClass, ScopedPointerCustomDeleter&gt; customPointer(new MyCustomClass);
</db:programlisting>
</db:section>
<db:section xml:id="forward-declared-pointers">
<db:title>Forward Declared Pointers</db:title>
<db:para>Classes that are forward declared can be used within <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link>, as long as the destructor of the forward declared class is available whenever a <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link> needs to clean up.</db:para>
<db:para>Concretely, this means that all classes containing a <db:link xlink:href="qscopedpointer.xml">QScopedPointer</db:link> that points to a forward declared class must have non-inline constructors, destructors and assignment operators:</db:para>
<db:programlisting language="cpp">class MyPrivateClass; // forward declare MyPrivateClass

class MyClass
{
private:
    QScopedPointer&lt;MyPrivateClass&gt; privatePtr; // QScopedPointer to forward declared class

public:
    MyClass(); // OK
    inline ~MyClass() {} // VIOLATION - Destructor must not be inline

private:
    Q_DISABLE_COPY(MyClass) // OK - copy constructor and assignment operators
                             // are now disabled, so the compiler won't implicitely
                             // generate them.
};
</db:programlisting>
<db:para>Otherwise, the compiler output a warning about not being able to destruct <db:code>MyPrivateClass</db:code>.</db:para>
</db:section>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qsharedpointer.xml">QSharedPointer</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
</db:article>
