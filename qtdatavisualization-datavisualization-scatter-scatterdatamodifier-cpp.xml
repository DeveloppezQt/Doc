<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Scatter Example</db:title>
<db:productname>QtDataVisualization</db:productname>
<db:edition>Qt Data Visualization | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Data Visualization Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Using <db:link xlink:href="q3dscatter.xml">Q3DScatter</db:link> in a widget application.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:programlisting language="cpp">/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the Qt Data Visualization module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:GPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3 or (at your option) any later version
** approved by the KDE Free Qt Foundation. The licenses are as published by
** the Free Software Foundation and appearing in the file LICENSE.GPL3
** included in the packaging of this file. Please review the following
** information to ensure the GNU General Public License requirements will
** be met: https://www.gnu.org/licenses/gpl-3.0.html.
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include &quot;scatterdatamodifier.h&quot;
#include &amp;lt;QtDataVisualization/qscatterdataproxy.h&amp;gt;
#include &amp;lt;QtDataVisualization/qvalue3daxis.h&amp;gt;
#include &amp;lt;QtDataVisualization/q3dscene.h&amp;gt;
#include &amp;lt;QtDataVisualization/q3dcamera.h&amp;gt;
#include &amp;lt;QtDataVisualization/qscatter3dseries.h&amp;gt;
#include &amp;lt;QtDataVisualization/q3dtheme.h&amp;gt;
#include &amp;lt;QtCore/qmath.h&amp;gt;
#include &amp;lt;QtCore/qrandom.h&amp;gt;
#include &amp;lt;QtWidgets/QComboBox&amp;gt;

using namespace QtDataVisualization;

//#define RANDOM_SCATTER // Uncomment this to switch to random scatter

const int numberOfItems = 3600;
const float curveDivider = 3.0f;
const int lowerNumberOfItems = 900;
const float lowerCurveDivider = 0.75f;

ScatterDataModifier::ScatterDataModifier(Q3DScatter *scatter)
    : m_graph(scatter),
      m_fontSize(40.0f),
      m_style(QAbstract3DSeries::MeshSphere),
      m_smooth(true),
      m_itemCount(lowerNumberOfItems),
      m_curveDivider(lowerCurveDivider)
{
    m_graph-&amp;gt;activeTheme()-&amp;gt;setType(Q3DTheme::ThemeEbony);
    QFont font = m_graph-&amp;gt;activeTheme()-&amp;gt;font();
    font.setPointSize(m_fontSize);
    m_graph-&amp;gt;activeTheme()-&amp;gt;setFont(font);
    m_graph-&amp;gt;setShadowQuality(QAbstract3DGraph::ShadowQualitySoftLow);
    m_graph-&amp;gt;scene()-&amp;gt;activeCamera()-&amp;gt;setCameraPreset(Q3DCamera::CameraPresetFront);

    QScatterDataProxy *proxy = new QScatterDataProxy;
    QScatter3DSeries *series = new QScatter3DSeries(proxy);
    series-&amp;gt;setItemLabelFormat(QStringLiteral(&quot;@xTitle: @xLabel @yTitle: @yLabel @zTitle: @zLabel&quot;));
    series-&amp;gt;setMeshSmooth(m_smooth);
    m_graph-&amp;gt;addSeries(series);

    addData();
}

ScatterDataModifier::~ScatterDataModifier()
{
    delete m_graph;
}

void ScatterDataModifier::addData()
{
    // Configure the axes according to the data
    m_graph-&amp;gt;axisX()-&amp;gt;setTitle(&quot;X&quot;);
    m_graph-&amp;gt;axisY()-&amp;gt;setTitle(&quot;Y&quot;);
    m_graph-&amp;gt;axisZ()-&amp;gt;setTitle(&quot;Z&quot;);

    QScatterDataArray *dataArray = new QScatterDataArray;
    dataArray-&amp;gt;resize(m_itemCount);
    QScatterDataItem *ptrToDataArray = &amp;amp;dataArray-&amp;gt;first();

#ifdef RANDOM_SCATTER
    for (int i = 0; i &amp;lt; m_itemCount; i++) {
        ptrToDataArray-&amp;gt;setPosition(randVector());
        ptrToDataArray++;
    }
#else
    float limit = qSqrt(m_itemCount) / 2.0f;
    for (float i = -limit; i &amp;lt; limit; i++) {
        for (float j = -limit; j &amp;lt; limit; j++) {
            ptrToDataArray-&amp;gt;setPosition(QVector3D(i + 0.5f,
                                                  qCos(qDegreesToRadians((i * j) / m_curveDivider)),
                                                  j + 0.5f));
            ptrToDataArray++;
        }
    }
#endif

    m_graph-&amp;gt;seriesList().at(0)-&amp;gt;dataProxy()-&amp;gt;resetArray(dataArray);
}

void ScatterDataModifier::changeStyle(int style)
{
    QComboBox *comboBox = qobject_cast&amp;lt;QComboBox *&amp;gt;(sender());
    if (comboBox) {
        m_style = QAbstract3DSeries::Mesh(comboBox-&amp;gt;itemData(style).toInt());
        if (m_graph-&amp;gt;seriesList().size())
            m_graph-&amp;gt;seriesList().at(0)-&amp;gt;setMesh(m_style);
    }
}

void ScatterDataModifier::setSmoothDots(int smooth)
{
    m_smooth = bool(smooth);
    QScatter3DSeries *series = m_graph-&amp;gt;seriesList().at(0);
    series-&amp;gt;setMeshSmooth(m_smooth);
}

void ScatterDataModifier::changeTheme(int theme)
{
    Q3DTheme *currentTheme = m_graph-&amp;gt;activeTheme();
    currentTheme-&amp;gt;setType(Q3DTheme::Theme(theme));
    emit backgroundEnabledChanged(currentTheme-&amp;gt;isBackgroundEnabled());
    emit gridEnabledChanged(currentTheme-&amp;gt;isGridEnabled());
    emit fontChanged(currentTheme-&amp;gt;font());
}

void ScatterDataModifier::changePresetCamera()
{
    static int preset = Q3DCamera::CameraPresetFrontLow;

    m_graph-&amp;gt;scene()-&amp;gt;activeCamera()-&amp;gt;setCameraPreset((Q3DCamera::CameraPreset)preset);

    if (++preset &amp;gt; Q3DCamera::CameraPresetDirectlyBelow)
        preset = Q3DCamera::CameraPresetFrontLow;
}

void ScatterDataModifier::changeLabelStyle()
{
    m_graph-&amp;gt;activeTheme()-&amp;gt;setLabelBackgroundEnabled(!m_graph-&amp;gt;activeTheme()-&amp;gt;isLabelBackgroundEnabled());
}

void ScatterDataModifier::changeFont(const QFont &amp;amp;font)
{
    QFont newFont = font;
    newFont.setPointSizeF(m_fontSize);
    m_graph-&amp;gt;activeTheme()-&amp;gt;setFont(newFont);
}

void ScatterDataModifier::shadowQualityUpdatedByVisual(QAbstract3DGraph::ShadowQuality sq)
{
    int quality = int(sq);
    emit shadowQualityChanged(quality); // connected to a checkbox in main.cpp
}

void ScatterDataModifier::changeShadowQuality(int quality)
{
    QAbstract3DGraph::ShadowQuality sq = QAbstract3DGraph::ShadowQuality(quality);
    m_graph-&amp;gt;setShadowQuality(sq);
}

void ScatterDataModifier::setBackgroundEnabled(int enabled)
{
    m_graph-&amp;gt;activeTheme()-&amp;gt;setBackgroundEnabled((bool)enabled);
}

void ScatterDataModifier::setGridEnabled(int enabled)
{
    m_graph-&amp;gt;activeTheme()-&amp;gt;setGridEnabled((bool)enabled);
}

void ScatterDataModifier::toggleItemCount()
{
    if (m_itemCount == numberOfItems) {
        m_itemCount = lowerNumberOfItems;
        m_curveDivider = lowerCurveDivider;
    } else {
        m_itemCount = numberOfItems;
        m_curveDivider = curveDivider;
    }
    m_graph-&amp;gt;seriesList().at(0)-&amp;gt;dataProxy()-&amp;gt;resetArray(0);
    addData();
}

QVector3D ScatterDataModifier::randVector()
{
    return QVector3D(
                (float)(QRandomGenerator::global()-&amp;gt;bounded(100)) / 2.0f -
                (float)(QRandomGenerator::global()-&amp;gt;bounded(100)) / 2.0f,
                (float)(QRandomGenerator::global()-&amp;gt;bounded(100)) / 100.0f -
                (float)(QRandomGenerator::global()-&amp;gt;bounded(100)) / 100.0f,
                (float)(QRandomGenerator::global()-&amp;gt;bounded(100)) / 2.0f -
                (float)(QRandomGenerator::global()-&amp;gt;bounded(100)) / 2.0f);
}

</db:programlisting>
</db:article>
