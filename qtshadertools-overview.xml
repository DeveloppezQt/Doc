<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt Shader Tools Overview</db:title>
<db:productname>QtShaderTools</db:productname>
<db:edition>Qt 6.5.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Shader Tools Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Provides insight into the Qt Shader Tools module.</db:para>
</db:abstract>
<db:pubdate>2024-02-14</db:pubdate>
<db:date>2024-02-14</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The Qt Shader Tools module builds on the SPIR-V Open Source Ecosystem as described at <db:link xlink:href="https://www.khronos.org/spir/">the Khronos SPIR-V web site</db:link>. For compiling into SPIR-V, <db:link xlink:href="https://github.com/KhronosGroup/glslang">glslang</db:link> is used, while translating and reflecting is done via <db:link xlink:href="https://github.com/KhronosGroup/SPIRV-Cross">SPIRV-Cross</db:link>.</db:para>
<db:para>For shader code to be written once in Qt applications and libraries, all shaders are expected to be written in a single language, which is then compiled into SPIR-V. This shading language is Vulkan-compatible GLSL at the moment. This is different from what the OpenGL-style GLSL Qt 5.x expects. See the <db:link xlink:href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_vulkan_glsl.txt">GL_KHR_vulkan_glslspecification</db:link> for an overview of the differences.</db:para>
<db:para>Source code for other shading languages, such as GLSL, HLSL, and the Metal Shading Language, is then generated from translating the SPIR-V bytecode, together with reflection information (inputs, outputs, shader resources). For GLSL in particular, this also involves generating multiple variants, meaning source code suitable for different GLSL versions, such as GLSL ES 100, GLSL ES 300, and GLSL 120 and 150. This is then packed into serializable QShader container objects, typically stored on disk as <db:code>.qsb</db:code> files. The Qt Rendering Hardware Interface consumes QShader instances directly, picking the shader source or bytecode that is best suited for the graphics API used at run time. A QShader object is typically deserialized from <db:code>.qsb</db:code> files shipped with the application or Qt itself in the Qt Resource System.</db:para>
<db:para>Some platforms provide the option of compiling shader source code to an intermediate format similar to SPIR-V. This involves running platform-specific tools. With Direct 3D, the <db:code>qsb</db:code> tool provides the option to invoke <db:link xlink:href="https://docs.microsoft.com/en-us/windows/win32/direct3dtools/fxc">the fxc tool from the Windows SDK</db:link> once the HLSL source code has been generated. It then replaces the HLSL source code with the <db:code>DXBC</db:code> binary generated by <db:code>fxc</db:code>. This can have a positive effect on applications' runtime performance since they no longer need to do the first phase of compilation (HLSL source to DXBC) themselves. For macOS and iOS, the <db:link xlink:href="https://developer.apple.com/documentation/metal/libraries/building_a_library_with_metal_s_command-line_tools?language=objc">XCode SDK provides similar tools</db:link>. The downside of this approach is that running these tools is only possible on their respective platforms. Therefore, this is best suited for use in combination with qsb's CMake integration since doing shader conditioning at application build time implicitly comes with the knowledge needed about the target platform and what platform-specific tools can be invoked.</db:para>
<db:para>The following diagram describes the steps that happen during an invocation of the <db:code>qsb</db:code> tool:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/shaderconditioning.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>The main components of the Qt shader conditioning system are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>the <db:code>qsb</db:code> command-line tool</db:para>
</db:listitem>
<db:listitem>
<db:para>CMake integration for the <db:code>qsb</db:code> tool</db:para>
</db:listitem>
<db:listitem>
<db:para>QShader (part of the <db:link xlink:href="qtgui-module.xml">QtGui</db:link> module)</db:para>
</db:listitem>
<db:listitem>
<db:para>QShaderBaker (part of this module, the library equivalent of the <db:code>qsb</db:code> tool)</db:para>
</db:listitem>
</db:itemizedlist>
<db:note>
<db:para>As of Qt 6.5, the C++ APIs are considered private. They are not recommended for direct usage from applications. Rather, use the <db:code>qsb</db:code> command-line tool either directly, or indirectly from CMake projects.</db:para>
</db:note>
<db:section xml:id="typical-usage-with-qt-quick">
<db:title>Typical Usage with Qt Quick</db:title>
<db:para>Application developers typically work with custom shader code in Qt Quick scenes that have one of the following:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="qml-qtquick-shadereffect.xml">ShaderEffect</db:link> items</db:para>
</db:listitem>
<db:listitem>
<db:para><db:link xlink:href="qquickitem.xml">QQuickItem</db:link> subclasses that use scene graph nodes in combination with custom materials built by subclassing <db:link xlink:href="qsgmaterial.xml">QSGMaterial</db:link>.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For example, consider the following QML snippet:</db:para>
<db:programlisting language="qml">ShaderEffect {
    width: 100; height: 100
    fragmentShader: &quot;myeffect.frag.qsb&quot;
}
</db:programlisting>
<db:para>Here the <db:link xlink:href="qml-qtquick-shadereffect.xml#fragmentShader-prop">fragmentShader</db:link> URL refers to a <db:code>.qsb</db:code> file relative to the <db:code>.qml</db:code> file's location. The application is expected to ship <db:code>myeffect.frag.qsb</db:code> next to the <db:code>.qml</db:code> file. To generate that file from the Vulkan-style GLSL source (which itself does not need to be shipped with the application), the application must use the <db:code>qsb</db:code> tool either directly or via CMake.</db:para>
</db:section>
<db:section xml:id="typical-usage-with-qt-quick-3d">
<db:title>Typical Usage with Qt Quick 3D</db:title>
<db:para>Qt Quick 3D uses the Shader Tools module directly to perform shader conditioning at run time. In addition, it provides solutions for pre-generating shaders for materials at build time, in case a runtime dependency to shader compilers and other tools is not seen ideal. In either case, developers don't need to work directly with the <db:code>qsb</db:code> tool since it's encapsulated by the Qt Quick 3D's own framework and tools.</db:para>
</db:section>
</db:article>
