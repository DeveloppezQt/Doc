<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Calculator Builder Example</db:title>
<db:productname>QtDesigner</db:productname>
<db:edition>Qt 6.1.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Designer Manual</db:titleabbrev>
<db:abstract>
<db:para>Creating a user interface from a <db:emphasis>Qt Designer</db:emphasis> form at run-time.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/calculatorbuilder-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>We use the form created in the <db:link xlink:href="qtdesigner-calculatorform-example.xml">Calculator Form</db:link> example to show that the same user interface can be generated when the application is executed or defined when the application is built.</db:para>
<db:section xml:id="preparation">
<db:title>Preparation</db:title>
<db:para>The <db:link xlink:href="qtdesigner-calculatorform-example.xml">Calculator Form</db:link> example defines a user interface that we can use without modification. In this example, we use a <db:link xlink:href="resources.xml">resource file</db:link> to contain the <db:code>calculatorform.ui</db:code> file created in the previous example, but it could be stored on disk instead.</db:para>
<db:para>To generate a form at run time, we need to link the example against the <db:code>QtUiTools</db:code> module library. The project file we use contains all the necessary information to do this:</db:para>
<db:programlisting language="cpp">HEADERS     = calculatorform.h
RESOURCES   = calculatorbuilder.qrc
SOURCES     = calculatorform.cpp \
              main.cpp
QT += widgets uitools
</db:programlisting>
<db:para>All the other necessary files are declared as usual.</db:para>
</db:section>
<db:section xml:id="calculatorform-class-definition">
<db:title>CalculatorForm Class Definition</db:title>
<db:para>The <db:code>CalculatorForm</db:code> class defines the widget used to host the form's user interface:</db:para>
<db:programlisting language="cpp">class CalculatorForm : public QWidget
{
    Q_OBJECT

public:
    explicit CalculatorForm(QWidget *parent = nullptr);

private slots:
    void on_inputSpinBox1_valueChanged(int value);
    void on_inputSpinBox2_valueChanged(int value);

private:
    QSpinBox *ui_inputSpinBox1;
    QSpinBox *ui_inputSpinBox2;
    QLabel *ui_outputWidget;
};
</db:programlisting>
<db:para>Note that we do not need to include a header file to describe the user interface. We only define two public slots, using the auto-connection naming convention required by <db:code>uic</db:code>, and declare private variables that we will use to access widgets provided by the form after they are constructed.</db:para>
</db:section>
<db:section xml:id="calculatorform-class-implementation">
<db:title>CalculatorForm Class Implementation</db:title>
<db:para>We will need to use the <db:link xlink:href="quiloader.xml">QUiLoader</db:link> class that is provided by the <db:code>libQtUiTools</db:code> library, so we first ensure that we include the header file for the module:</db:para>
<db:programlisting language="cpp">#include &amp;lt;QtUiTools&amp;gt;
</db:programlisting>
<db:para>The constructor uses a form loader object to construct the user interface that we retrieve, via a <db:link xlink:href="qfile.xml">QFile</db:link> object, from the example's resources:</db:para>
<db:programlisting language="cpp">CalculatorForm::CalculatorForm(QWidget *parent)
    : QWidget(parent)
{
    QUiLoader loader;

    QFile file(&quot;:/forms/calculatorform.ui&quot;);
    file.open(QFile::ReadOnly);
    QWidget *formWidget = loader.load(&amp;amp;file, this);
    file.close();
</db:programlisting>
<db:para>By including the user interface in the example's resources, we ensure that it will be present when the example is run. The <db:code>loader.load()</db:code> function takes the user interface description contained in the file and constructs the form widget as a child widget of the <db:code>CalculatorForm</db:code>.</db:para>
<db:para>We are interested in three widgets in the generated user interface: two spin boxes and a label. For convenience, we retrieve pointers to these widgets from the widget that was constructed by the <db:code>FormBuilder</db:code>, and we record them for later use. The <db:code>qFindChild()</db:code> template function allows us to query widgets in order to find named child widgets.</db:para>
<db:programlisting language="cpp">    ui_inputSpinBox1 = findChild&amp;lt;QSpinBox*&amp;gt;(&quot;inputSpinBox1&quot;);
    ui_inputSpinBox2 = findChild&amp;lt;QSpinBox*&amp;gt;(&quot;inputSpinBox2&quot;);
    ui_outputWidget = findChild&amp;lt;QLabel*&amp;gt;(&quot;outputWidget&quot;);
</db:programlisting>
<db:para>The widgets created by the form loader need to be connected to the specially-named slots in the <db:code>CalculatorForm</db:code> object. We use Qt's meta-object system to enable these connections:</db:para>
<db:programlisting language="cpp">    QMetaObject::connectSlotsByName(this);
</db:programlisting>
<db:para>The form widget is added to a layout, and the window title is set:</db:para>
<db:programlisting language="cpp">    QVBoxLayout *layout = new QVBoxLayout;
    layout-&amp;gt;addWidget(formWidget);
    setLayout(layout);

    setWindowTitle(tr(&quot;Calculator Builder&quot;));
}
</db:programlisting>
<db:para>The two slots that modify widgets provided by the form are defined in a similar way to those in the <db:link xlink:href="qtdesigner-calculatorform-example.xml">Calculator Form</db:link> example, except that we read the values from the spin boxes and write the result to the output widget via the pointers we recorded in the constructor:</db:para>
<db:programlisting language="cpp">void CalculatorForm::on_inputSpinBox1_valueChanged(int value)
{
    ui_outputWidget-&amp;gt;setText(QString::number(value + ui_inputSpinBox2-&amp;gt;value()));
}

void CalculatorForm::on_inputSpinBox2_valueChanged(int value)
{
    ui_outputWidget-&amp;gt;setText(QString::number(value + ui_inputSpinBox1-&amp;gt;value()));
}
</db:programlisting>
<db:para>The advantage of this approach is that we can replace the form when the application is run, but we can still manipulate the widgets it contains as long as they are given appropriate names.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qttools.git/tree/examples/designer/calculatorbuilder?h=6.1">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
