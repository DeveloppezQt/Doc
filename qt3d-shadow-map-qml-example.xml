<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt 3D: Shadow Map QML Example</db:title>
<db:productname>Qt3D</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt 3D Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A Qt 3D QML application that illustrates how to render a scene in Qt 3D with shadows.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/shadowmapping-qt3d.png"/>
</db:imageobject>
</db:mediaobject>
<db:para><db:emphasis>Qt 3D Shadow Map</db:emphasis> illustrates how to configure the renderer in order to accommodate custom rendering techniques. The example application displays a self-shadowed plane and trefoil knot.</db:para>
<db:para>We implement <db:link xlink:href="qt3d-overview.xml#shadow-mapping">shadow mapping</db:link> using a two pass rendering. In the first pass, we generate the shadow information. In the second pass, we generate the scene using the forward rendering technique with Phong shading, while at the same time using the information gathered in the first pass to draw the shadows.</db:para>
<db:para>The entire rendering is configured using QML, but it is possible to use C++ to achieve the very same result.</db:para>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="http://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:emphasis role="bold">Welcome</db:emphasis> mode and select the example from <db:emphasis role="bold">Examples</db:emphasis>. For more information, visit <db:link xlink:href="http://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="setting-up-the-scene">
<db:title>Setting Up the Scene</db:title>
<db:para>We set up the entire scene in the <db:emphasis>main.qml</db:emphasis> file.</db:para>
<db:para>To be able to use the types in the Q3D and Q3D Renderer modules, we must import the modules:</db:para>
<db:programlisting language="cpp">import Qt3D.Core 2.0
import Qt3D.Render 2.0
</db:programlisting>
<db:para>The first entities we create are a <db:link xlink:href="qml-qt3d-render-camera.xml">Camera</db:link>, which represents the camera used for the final rendering, and a <db:link xlink:href="dnd.xml#configuration">Configuration</db:link>, which allows us to control this camera using the keyboard or the mouse:</db:para>
<db:programlisting language="cpp">import Qt3D.Input 2.0
import Qt3D.Extras 2.0

Entity {
    id: sceneRoot

    Camera {
        id: camera
        projectionType: CameraLens.PerspectiveProjection
        fieldOfView: 45
        aspectRatio: _window.width / _window.height
        nearPlane: 0.1
        farPlane: 1000.0
        position: Qt.vector3d(0.0, 10.0, 20.0)
        viewCenter: Qt.vector3d(0.0, 0.0, 0.0)
        upVector: Qt.vector3d(0.0, 1.0, 0.0)
    }

    FirstPersonCameraController { camera: camera }

</db:programlisting>
<db:para>We then create a Light custom entity, which represents our light. It is a directional spotlight, placed somewhere above the plane and looking down at the scene’s origin:</db:para>
<db:programlisting language="cpp">    ShadowMapLight {
        id: light
    }

</db:programlisting>
<db:para>This light entity is used by our custom framegraph, ShadowMapFrameGraph, and our rendering effect, AdsEffect, whose instances are created just after the light:</db:para>
<db:programlisting language="cpp">    components: [
        ShadowMapFrameGraph {
            id: framegraph
            viewCamera: camera
            lightCamera: light.lightCamera
        },
        // Event Source will be set by the Qt3DQuickWindow
        InputSettings { }
    ]

    AdsEffect {
        id: shadowMapEffect

        shadowTexture: framegraph.shadowTexture
        light: light
    }

</db:programlisting>
<db:para>Last, we create three entities for the meshes in the scene: a trefoil knot, a toy plane, and a ground plane. They aggregate a mesh, a transformation, and a material that uses the AdsEffect. The toy plane and the trefoil knot transformations are animated:</db:para>
<db:programlisting language="cpp">    // Trefoil knot entity
    Trefoil {
        material: AdsMaterial {
            effect: shadowMapEffect
            specularColor: Qt.rgba(0.5, 0.5, 0.5, 1.0)
        }
    }

    // Toyplane entity
    Toyplane {
        material: AdsMaterial {
            effect: shadowMapEffect
            diffuseColor: Qt.rgba(0.9, 0.5, 0.3, 1.0)
            shininess: 75
        }
    }

    // Plane entity
    GroundPlane {
        material: AdsMaterial {
            effect: shadowMapEffect
            diffuseColor: Qt.rgba(0.2, 0.5, 0.3, 1.0)
            specularColor: Qt.rgba(0, 0, 0, 1.0)
        }
    }
}

</db:programlisting>
</db:section>
<db:section xml:id="specifying-the-light">
<db:title>Specifying the Light</db:title>
<db:para>We specify the Light custom entity in <db:emphasis>ShadowMapLight.qml</db:emphasis>.</db:para>
<db:para>Again, we import the necessary modules:</db:para>
<db:programlisting language="cpp">import Qt3D.Core 2.0
import Qt3D.Render 2.0

</db:programlisting>
<db:para>We then use an <db:link xlink:href="qml-qt3d-core-entity.xml">Entity</db:link> type as the root element of the custom QML type. The light is a directional spotlight that exposes as properties a position, intensity, and a 4×4 transformation matrix:</db:para>
<db:programlisting language="cpp">Entity {
    id: root

    property vector3d lightPosition: Qt.vector3d(30.0, 30.0, 0.0)
    property vector3d lightIntensity: Qt.vector3d(1.0, 1.0, 1.0)

    readonly property Camera lightCamera: lightCamera
    readonly property matrix4x4 lightViewProjection: lightCamera.projectionMatrix.times(lightCamera.viewMatrix)

</db:programlisting>
<db:para>In the first rendering pass, we use the light as a camera, and therefore we use a <db:link xlink:href="qml-qt3d-render-camera.xml">Camera</db:link> entity within the light and expose it as a property:</db:para>
<db:programlisting language="cpp">    Camera {
        id: lightCamera
        objectName: &quot;lightCameraLens&quot;
        projectionType: CameraLens.PerspectiveProjection
        fieldOfView: 45
        aspectRatio: 1
        nearPlane : 0.1
        farPlane : 200.0
        position: root.lightPosition
        viewCenter: Qt.vector3d(0.0, 0.0, 0.0)
        upVector: Qt.vector3d(0.0, 1.0, 0.0)
    }
}

</db:programlisting>
</db:section>
<db:section xml:id="configuring-the-framegraph">
<db:title>Configuring the Framegraph</db:title>
<db:para>In Qt 3D, the framegraph is the data-driven configuration for the rendering. We implement the framegraph in the <db:emphasis>ShadowMapFrameGraph.qml</db:emphasis> file.</db:para>
<db:para>In addition to the Qt 3D and Qt 3D Render modules, we also import the Qt Quick module:</db:para>
<db:programlisting language="cpp">import QtQuick 2.2 as QQ2
import Qt3D.Core 2.0
import Qt3D.Render 2.0

</db:programlisting>
<db:para>The code defines a RendererSettings entity that has a tree of entities as the active framegraph:</db:para>
<db:programlisting language="cpp">RenderSettings {
    id: root

    property alias viewCamera: viewCameraSelector.camera
    property alias lightCamera: lightCameraSelector.camera
    readonly property Texture2D shadowTexture: depthTexture

    activeFrameGraph: Viewport {
        normalizedRect: Qt.rect(0.0, 0.0, 1.0, 1.0)

        RenderSurfaceSelector {
            RenderPassFilter {
                matchAny: [ FilterKey { name: &quot;pass&quot;; value: &quot;shadowmap&quot; } ]

                RenderTargetSelector {
                    target: RenderTarget {
                        attachments: [
                            RenderTargetOutput {
                                objectName: &quot;depth&quot;
                                attachmentPoint: RenderTargetOutput.Depth
                                texture: Texture2D {
                                    id: depthTexture
                                    width: 1024
                                    height: 1024
                                    format: Texture.DepthFormat
                                    generateMipMaps: false
                                    magnificationFilter: Texture.Linear
                                    minificationFilter: Texture.Linear
                                    wrapMode {
                                        x: WrapMode.ClampToEdge
                                        y: WrapMode.ClampToEdge
                                    }
                                    comparisonFunction: Texture.CompareLessEqual
                                    comparisonMode: Texture.CompareRefToTexture
                                }
                            }
                        ]
                    }

                    ClearBuffers {
                        buffers: ClearBuffers.DepthBuffer

                        CameraSelector {
                            id: lightCameraSelector
                        }
                    }
                }
            }

            RenderPassFilter {
                matchAny: [ FilterKey { name: &quot;pass&quot;; value: &quot;forward&quot; } ]

                ClearBuffers {
                    clearColor: Qt.rgba(0.0, 0.4, 0.7, 1.0)
</db:programlisting>
<db:para>Any path from the leaves of this tree to the root is a viable framegraph configuration. Filter entities can enable or disable such paths, and selector entities can alter the configuration.</db:para>
<db:para>In our case, the tree looks like this:</db:para>
<db:programlisting language="cpp" role="bad">Viewport
    RenderPassFilter
        RenderTargetSelector
            ClearBuffers
                CameraSelector
    RenderPassFilter
        ClearBuffers
            CameraSelector
</db:programlisting>
<db:para>So we have two paths from the topmost <db:link xlink:href="qml-qt3d-render-viewport.xml">Viewport</db:link> entity. Each path corresponds to a pass of the shadow map technique. The paths are enabled and disabled using a RenderPassFilter, an entity that can filter depending on arbitrary values defined in a given render pass. In this example, it is a string:</db:para>
<db:programlisting language="cpp">                    buffers: ClearBuffers.ColorDepthBuffer

                    CameraSelector {
                        id: viewCameraSelector
                    }
                }
            }
        }
    }
}

</db:programlisting>
<db:para>The actual passes are not defined here. The framegraph simply modifies its configuration when a given pass is rendered.</db:para>
</db:section>
<db:section xml:id="generating-the-shadow-map">
<db:title>Generating the Shadow Map</db:title>
<db:para>In the shadow map generation pass, we must render to an offscreen surface (Framebuffer Object) which has a depth texture attachment. In Qt 3D, it is represented by the RenderTarget entity, which has a number of attachments.</db:para>
<db:para>In this example, we need only a depth attachment. We define it as a RenderAttachment entity using the RenderAttachment.DepthAttachment <db:code>type</db:code> that stores the depth and a Texture2D entity that actually configures the exture storage used to store the depth information:</db:para>
<db:programlisting language="cpp"></db:programlisting>
<db:para>Moreover, in this first pass, we must render using the light’s camera. Therefore, we have a <db:link xlink:href="qml-qt3d-render-cameraselector.xml">CameraSelector</db:link> entity that sets the camera to the one exported by the Light:</db:para>
<db:programlisting language="cpp"></db:programlisting>
<db:para>The second pass is more straightforward, because we simply render to the screen using the main camera.</db:para>
</db:section>
<db:section xml:id="using-effects">
<db:title>Using Effects</db:title>
<db:para>The bulk of the magic happens in the <db:emphasis>AdsEffect.qml</db:emphasis> file, where our main <db:link xlink:href="qml-qt3d-render-effect.xml">Effect</db:link> entity is defined. It implements the Ambient, Diffuse and Specular (ADS) Lightning Model Phong shading with the addition of shadow mapped generated shadows.</db:para>
<db:para>An effect contains the implementation of a particular rendering strategy. In this example, shadow mapping using two passes:</db:para>
<db:programlisting language="cpp">Effect {
    id: root

    property Texture2D shadowTexture
    property ShadowMapLight light

</db:programlisting>
<db:para>The <db:code>parameters</db:code> list defines some default values for the effect. The values will get mapped to OpenGL shader program uniforms, so that in the shaders we can access them. In this example, we expose some information from the Light entity (position, intensity, view or projection matrix defined by the internal camera) and the shadow map texture exposed by the framegraph:</db:para>
<db:programlisting language="cpp">    parameters: [
        Parameter { name: &quot;lightViewProjection&quot;; value: root.light.lightViewProjection },
        Parameter { name: &quot;lightPosition&quot;;  value: root.light.lightPosition },
        Parameter { name: &quot;lightIntensity&quot;; value: root.light.lightIntensity },

        Parameter { name: &quot;shadowMapTexture&quot;; value: root.shadowTexture }
    ]

</db:programlisting>
<db:para>It is possible to put such parameters all the way down, from a <db:link xlink:href="qml-qt3d-render-material.xml">Material</db:link>, to its <db:link xlink:href="qml-qt3d-render-effect.xml">Effect</db:link>, to one of the effect’s Techniques. This allows a <db:link xlink:href="qml-qt3d-render-material.xml">Material</db:link> instance to override defaults in an <db:link xlink:href="qml-qt3d-render-effect.xml">Effect</db:link> or <db:link xlink:href="qml-qt3d-render-technique.xml">Technique</db:link>. The bindings array provides the same thing, except that it also allows us to rename some parameters. In this example, it renames the <db:code>ambient</db:code>, <db:code>diffuse</db:code>, and <db:code>specular</db:code> values defined in the material to the actual uniform names used by the shader programs:</db:para>
<db:programlisting language="cpp"></db:programlisting>
<db:para>To adapt the implementation to different hardware or OpenGL versions, we could use one or more <db:link xlink:href="qml-qt3d-render-technique.xml">Technique</db:link> elements. In this example, only one technique is provided, targeting OpenGL 3.2 Core, or later:</db:para>
<db:programlisting language="cpp">    techniques: [
        Technique {
            graphicsApiFilter {
                api: GraphicsApiFilter.OpenGL
                profile: GraphicsApiFilter.CoreProfile
                majorVersion: 3
                minorVersion: 2
            }

</db:programlisting>
<db:para>Inside the technique, we finally have the definition of our two rendering passes. We <db:emphasis>tag</db:emphasis> each pass with an <db:link xlink:href="qml-qt3d-render-filterkey.xml">FilterKey</db:link> entity, matching the ones we specified in the framegraph configuration, so that each pass will have different rendering settings:</db:para>
<db:programlisting language="cpp">            renderPasses: [
                RenderPass {
                    filterKeys: [ FilterKey { name: &quot;pass&quot;; value: &quot;shadowmap&quot; } ]

</db:programlisting>
<db:para>The first pass is the shadow map generation. We load a suitable set of GLSL shaders, which are actually extremely simple. They do only MVP (Model, View, Projection) to bring meshes from their model space into clip space (and, remember, in this first pass, the light is the camera). The fragment shader is totally empty, because there is no color to be generated, and the depth will be automatically captured for us by OpenGL:</db:para>
<db:programlisting language="cpp">                    shaderProgram: ShaderProgram {
                        vertexShaderCode:   loadSource(&quot;qrc:/shaders/shadowmap.vert&quot;)
                        fragmentShaderCode: loadSource(&quot;qrc:/shaders/shadowmap.frag&quot;)
                    }

</db:programlisting>
<db:para>In this first pass, we also set some custom OpenGL state in the form of a polygon offset and depth testing mode:</db:para>
<db:programlisting language="cpp">                    renderStates: [
                        PolygonOffset { scaleFactor: 4; depthSteps: 4 },
                        DepthTest { depthFunction: DepthTest.Less }
                    ]
</db:programlisting>
</db:section>
<db:section xml:id="rendering-using-phong-shading">
<db:title>Rendering Using Phong Shading</db:title>
<db:para>The second pass is a normal forward rendering using Phong shading. The code in the effect entity is extremely simple. We simply configure some parameters and load a pair of shaders which will be used when drawing.</db:para>
<db:para>The first part of the shadow mapping happens in the vertex shader defined in <db:emphasis>ads.vert</db:emphasis> file, where we output towards the fragment shader the coordinates of each vertex in light space:</db:para>
<db:programlisting language="cpp">    positionInLightSpace = shadowMatrix * lightViewProjection * modelMatrix * vec4(vertexPosition, 1.0);

</db:programlisting>
<db:para>Actually, the coordinates get adjusted a little to allow us to easily sample the shadow map texture.</db:para>
<db:para>The second part happens in the fragment shader defined in the <db:emphasis>ads.frag</db:emphasis> file, where we sample the shadow map. If the currently processed fragment is behind the one closest to the light, then the current fragment is in shadow (and only gets ambient contribution). Otherwise, it gets full Phong shading:</db:para>
<db:programlisting language="cpp">void main()
{
    float shadowMapSample = textureProj(shadowMapTexture, positionInLightSpace);

    vec3 ambient = lightIntensity * ka;

    vec3 result = ambient;
    if (shadowMapSample &gt; 0)
        result += dsModel(position, normalize(normal));

    fragColor = vec4(result, 1.0);
}

</db:programlisting>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/AdsEffect.qml">shadow-map-qml/AdsEffect.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/AdsMaterial.qml">shadow-map-qml/AdsMaterial.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/GroundPlane.qml">shadow-map-qml/GroundPlane.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/ShadowMapFrameGraph.qml">shadow-map-qml/ShadowMapFrameGraph.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/ShadowMapLight.qml">shadow-map-qml/ShadowMapLight.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/Toyplane.qml">shadow-map-qml/Toyplane.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/Trefoil.qml">shadow-map-qml/Trefoil.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/main.cpp">shadow-map-qml/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/main.qml">shadow-map-qml/main.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/shaders/ads.vert">shadow-map-qml/shaders/ads.vert</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/shaders/es3/ads.vert">shadow-map-qml/shaders/es3/ads.vert</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/shaders/es3/shadowmap.vert">shadow-map-qml/shaders/es3/shadowmap.vert</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/shaders/shadowmap.vert">shadow-map-qml/shaders/shadowmap.vert</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/shadow-map-qml.pro">shadow-map-qml/shadow-map-qml.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="shadow-map-qml/shadow-map-qml.qrc">shadow-map-qml/shadow-map-qml.qrc</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
