<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Part 6 - Loading and Saving</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.13.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Describes how to add save and load functionality.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>This part covers the Qt file handling features we use to write loading and saving routines for the address book.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part6-screenshot.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>Although browsing and searching the contact list are useful features, our address book is not complete until we can save existing contacts and load them again at a later time.</db:para>
<db:para>Qt provides a number of classes for <db:link xlink:href="io.xml">input and output</db:link>, but we have chosen to use two which are simple to use in combination: QFile and QDataStream.</db:para>
<db:para>A QFile object represents a file on disk that can be read from and written to. QFile is a subclass of the more general QIODevice class which represents many different kinds of devices.</db:para>
<db:para>A QDataStream object is used to serialize binary data so that it can be stored in a QIODevice and retrieved again later. Reading from a QIODevice and writing to it is as simple as opening the stream - with the respective device as a parameter - and reading from or writing to it.</db:para>
<db:section xml:id="defining-the-addressbook-class">
<db:title>Defining the AddressBook Class</db:title>
<db:para>We declare two public slots, <db:code>saveToFile()</db:code> and <db:code>loadFromFile()</db:code>, as well as two QPushButton objects, <db:code>loadButton</db:code> and <db:code>saveButton</db:code>.</db:para>
<db:programlisting language="cpp">    void saveToFile();
    void loadFromFile();
    ...
    QPushButton *loadButton;
    QPushButton *saveButton;
</db:programlisting>
</db:section>
<db:section xml:id="implementing-the-addressbook-class">
<db:title>Implementing the AddressBook Class</db:title>
<db:para>In our constructor, we instantiate <db:code>loadButton</db:code> and <db:code>saveButton</db:code>. Ideally, it would be more user-friendly to set the push buttons' labels to &quot;Load contacts from a file&quot; and &quot;Save contacts to a file&quot;. However, due to the size of our other push buttons, we set the labels to <db:guilabel>Load...</db:guilabel> and <db:guilabel>Save...</db:guilabel>. Fortunately, Qt provides a simple way to set tooltips with <db:link xlink:href="">setToolTip()</db:link> and we use it in the following way for our push buttons:</db:para>
<db:programlisting language="cpp">    loadButton-&amp;gt;setToolTip(tr(&quot;Load contacts from a file&quot;));
    ...
    saveButton-&amp;gt;setToolTip(tr(&quot;Save contacts to a file&quot;));
</db:programlisting>
<db:para>Although it is not shown here, just like the other features we implemented, we add the push buttons to the layout panel on the right, <db:code>buttonLayout1</db:code>, and we connect the push buttons' <db:link xlink:href="">clicked()</db:link> signals to their respective slots.</db:para>
<db:para>For the saving feature, we first obtain <db:code>fileName</db:code> using QFileDialog::getSaveFileName(). This is a convenience function provided by QFileDialog, which pops up a modal file dialog and allows the user to enter a file name or select any existing <db:code>.abk</db:code> file. The <db:code>.abk</db:code> file is our Address Book extension that we create when we save contacts.</db:para>
<db:programlisting language="cpp">void AddressBook::saveToFile()
{
    QString fileName = QFileDialog::getSaveFileName(this,
        tr(&quot;Save Address Book&quot;), &quot;&quot;,
        tr(&quot;Address Book (*.abk);;All Files (*)&quot;));
</db:programlisting>
<db:para>The file dialog that pops up is displayed in the screenshot below:</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part6-save.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>If <db:code>fileName</db:code> is not empty, we create a QFile object, <db:code>file</db:code>, with <db:code>fileName</db:code>. QFile works with QDataStream as QFile is a QIODevice.</db:para>
<db:para>Next, we attempt to open the file in WriteOnly mode. If this is unsuccessful, we display a QMessageBox to inform the user.</db:para>
<db:programlisting language="cpp">    if (fileName.isEmpty())
        return;
    else {
        QFile file(fileName);
        if (!file.open(QIODevice::WriteOnly)) {
            QMessageBox::information(this, tr(&quot;Unable to open file&quot;),
                file.errorString());
            return;
        }
</db:programlisting>
<db:para>Otherwise, we instantiate a QDataStream object, <db:code>out</db:code>, to write the open file. QDataStream requires that the same version of the stream is used for reading and writing. We ensure that this is the case by setting the version used to the <db:link xlink:href="">version introduced with Qt 4.5</db:link> before serializing the data to <db:code>file</db:code>.</db:para>
<db:programlisting language="cpp">        QDataStream out(&amp;amp;file);
        out.setVersion(QDataStream::Qt_4_5);
        out &amp;lt;&amp;lt; contacts;
    }
}
</db:programlisting>
<db:para>For the loading feature, we also obtain <db:code>fileName</db:code> using QFileDialog::getOpenFileName(). This function, the counterpart to QFileDialog::getSaveFileName(), also pops up the modal file dialog and allows the user to enter a file name or select any existing <db:code>.abk</db:code> file to load it into the address book.</db:para>
<db:programlisting language="cpp">void AddressBook::loadFromFile()
{
    QString fileName = QFileDialog::getOpenFileName(this,
        tr(&quot;Open Address Book&quot;), &quot;&quot;,
        tr(&quot;Address Book (*.abk);;All Files (*)&quot;));
</db:programlisting>
<db:para>On Windows, for example, this function pops up a native file dialog, as shown in the following screenshot.</db:para>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/addressbook-tutorial-part6-load.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>If <db:code>fileName</db:code> is not empty, again, we use a QFile object, <db:code>file</db:code>, and attempt to open it in ReadOnly mode. Similar to our implementation of <db:code>saveToFile()</db:code>, if this attempt is unsuccessful, we display a QMessageBox to inform the user.</db:para>
<db:programlisting language="cpp">    if (fileName.isEmpty())
        return;
    else {

        QFile file(fileName);

        if (!file.open(QIODevice::ReadOnly)) {
            QMessageBox::information(this, tr(&quot;Unable to open file&quot;),
                file.errorString());
            return;
        }

        QDataStream in(&amp;amp;file);
        in.setVersion(QDataStream::Qt_4_5);
        contacts.clear();   // clear existing contacts
        in &amp;gt;&amp;gt; contacts;
</db:programlisting>
<db:para>Otherwise, we instantiate a QDataStream object, <db:code>in</db:code>, set its version as above and read the serialized data into the <db:code>contacts</db:code> data structure. The <db:code>contacts</db:code> object is emptied before data is read into it to simplify the file reading process. A more advanced method would be to read the contacts into a temporary <db:link xlink:href="qmap.xml">QMap</db:link> object, and copy over non-duplicate contacts into <db:code>contacts</db:code>.</db:para>
<db:programlisting language="cpp">        if (contacts.isEmpty()) {
            QMessageBox::information(this, tr(&quot;No contacts in file&quot;),
                tr(&quot;The file you are attempting to open contains no contacts.&quot;));
        } else {
            QMap&amp;lt;QString, QString&amp;gt;::iterator i = contacts.begin();
            nameLine-&amp;gt;setText(i.key());
            addressText-&amp;gt;setText(i.value());
        }
    }

    updateInterface(NavigationMode);
}
</db:programlisting>
<db:para>To display the contacts that have been read from the file, we must first validate the data obtained to ensure that the file we read from actually contains address book contacts. If it does, we display the first contact; otherwise, we display a QMessageBox to inform the user about the problem. Lastly, we update the interface to enable and disable the push buttons accordingly.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/tutorials/addressbook/part6?h=5.13">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
