<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Audio Overview</db:title>
<db:productname>QtMultimedia</db:productname>
<db:edition>Qt 5.6.3 Reference Documentation</db:edition>
<db:titleabbrev>Qt Multimedia Documentation</db:titleabbrev>
<db:abstract>
<db:para>Audio playback, recording and processing.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:section xml:id="audio-features">
<db:title>Audio Features</db:title>
<db:para>Qt Multimedia offers a range of audio classes, covering both low and high level approaches to audio input, output and processing. In addition to traditional audio usage, the <db:link xlink:href="qtaudioengine-qmlmodule.xml">Qt Audio Engine</db:link> QML types offer high level 3D positional audio for QML applications. See that documentation for more information.</db:para>
</db:section>
<db:section xml:id="audio-implementation-details">
<db:title>Audio Implementation Details</db:title>
<db:section xml:id="playing-compressed-audio">
<db:title>Playing Compressed Audio</db:title>
<db:para>For playing media or audio files that are not simple, uncompressed audio, you can use the <db:link xlink:href="qmediaplayer.xml">QMediaPlayer</db:link> C++ class, or the <db:link xlink:href="qml-qtmultimedia-audio.xml">Audio</db:link> and <db:link xlink:href="qml-qtmultimedia-mediaplayer.xml">MediaPlayer</db:link> QML types. The <db:link xlink:href="qmediaplayer.xml">QMediaPlayer</db:link> class and associated QML types are also capable of playing <db:link xlink:href="videooverview.xml#playing-video-in-c">video</db:link>, if required. The compressed audio formats supported does depend on the operating system environment, and also what media plugins the user may have installed.</db:para>
<db:para>Here is how you play a local file using C++:</db:para>
<db:programlisting language="cpp">player = new QMediaPlayer;
// ...
player-&gt;setMedia(QUrl::fromLocalFile(&quot;/Users/me/Music/coolsong.mp3&quot;));
player-&gt;setVolume(50);
player-&gt;play();
</db:programlisting>
<db:para>You can also put files (even remote URLs) into a playlist:</db:para>
<db:programlisting language="cpp">player = new QMediaPlayer;

playlist = new QMediaPlaylist(player);
playlist-&gt;addMedia(QUrl(&quot;http://example.com/myfile1.mp3&quot;));
playlist-&gt;addMedia(QUrl(&quot;http://example.com/myfile2.mp3&quot;));
// ...
playlist-&gt;setCurrentIndex(1);
player-&gt;play();
</db:programlisting>
</db:section>
<db:section xml:id="recording-audio-to-a-file">
<db:title>Recording Audio to a File</db:title>
<db:para>For recording audio to a file, the <db:link xlink:href="qaudiorecorder.xml">QAudioRecorder</db:link> class allows you to compress audio data from an input device and record it.</db:para>
<db:programlisting language="cpp">audioRecorder = new QAudioRecorder;

QAudioEncoderSettings audioSettings;
audioSettings.setCodec(&quot;audio/amr&quot;);
audioSettings.setQuality(QMultimedia::HighQuality);

audioRecorder-&gt;setEncodingSettings(audioSettings);

audioRecorder-&gt;setOutputLocation(QUrl::fromLocalFile(&quot;test.amr&quot;));
audioRecorder-&gt;record();
</db:programlisting>
</db:section>
<db:section xml:id="low-latency-sound-effects">
<db:title>Low Latency Sound Effects</db:title>
<db:para>In addition to the raw access to sound devices described above, the <db:link xlink:href="qsoundeffect.xml">QSoundEffect</db:link> class (and <db:link xlink:href="qml-qtmultimedia-soundeffect.xml">SoundEffect</db:link> QML type) offers a slightly higher level way to play sounds. These classes allow you to specify a WAV format file which can then be played with low latency when necessary. Both <db:link xlink:href="qsoundeffect.xml">QSoundEffect</db:link> and <db:link xlink:href="qml-qtmultimedia-soundeffect.xml">SoundEffect</db:link> have essentially the same API.</db:para>
<db:para>You can adjust the number of <db:link xlink:href="qsoundeffect.xml#loopCount">loops</db:link> a sound effect is played, as well as the <db:link xlink:href="qsoundeffect.xml#setVolume">volume</db:link> (or <db:link xlink:href="qsoundeffect.xml#setMuted">muting</db:link>) of the effect.</db:para>
<db:para>For older, Qt 4.x based applications <db:link xlink:href="qsound.xml">QSound</db:link> is also available. Applications are recommended to use <db:link xlink:href="qsoundeffect.xml">QSoundEffect</db:link> where possible.</db:para>
</db:section>
<db:section xml:id="monitoring-audio-data-during-playback-or-recording">
<db:title>Monitoring Audio Data During Playback or Recording</db:title>
<db:para>The <db:link xlink:href="qaudioprobe.xml">QAudioProbe</db:link> class allows you to monitor audio data being played or recorded in the higher level classes like <db:link xlink:href="qmediaplayer.xml">QMediaPlayer</db:link>, <db:link xlink:href="qcamera.xml">QCamera</db:link> and <db:link xlink:href="qaudiorecorder.xml">QAudioRecorder</db:link>. After creating your high level class, you can simply set the source of the probe to your class, and receive audio buffers as they are processed. This is useful for several audio processing tasks, particularly for visualization or adjusting gain. You cannot modify the buffers, and they may arrive at a slightly different time than the media pipeline processes them.</db:para>
<db:para>Here's an example of installing a probe during recording:</db:para>
<db:programlisting language="cpp">audioRecorder = new QAudioRecorder;

QAudioEncoderSettings audioSettings;
audioSettings.setCodec(&quot;audio/amr&quot;);
audioSettings.setQuality(QMultimedia::HighQuality);

audioRecorder-&gt;setEncodingSettings(audioSettings);

audioRecorder-&gt;setOutputLocation(QUrl::fromLocalFile(&quot;test.amr&quot;));

audioProbe = new QAudioProbe(this);
if (audioProbe-&gt;setSource(audioRecorder)) {
    // Probing succeeded, audioProbe-&gt;isValid() should be true.
    connect(audioProbe, SIGNAL(audioBufferProbed(QAudioBuffer)),
            this, SLOT(calculateLevel(QAudioBuffer)));
}

audioRecorder-&gt;record();
// Now audio buffers being recorded should be signaled
// by the probe, so we can do things like calculating the
// audio power level, or performing a frequency transform
</db:programlisting>
</db:section>
<db:section xml:id="low-level-audio-playback-and-recording">
<db:title>Low Level Audio Playback and Recording</db:title>
<db:para>Qt Multimedia offers classes for raw access to audio input and output facilities, allowing applications to receive raw data from devices like microphones, and to write raw data to speakers or other devices. Generally these classes do not do any audio decoding, or other processing, but they can support different types of raw audio data.</db:para>
<db:para>The <db:link xlink:href="qaudiooutput.xml">QAudioOutput</db:link> class offers raw audio data output, while <db:link xlink:href="qaudioinput.xml">QAudioInput</db:link> offers raw audio data input. Both classes have adjustable buffers and latency, so they are suitable for both low latency use cases (like games or VOIP) and high latency (like music playback). The available hardware determines what audio outputs and inputs are available.</db:para>
<db:section xml:id="push-and-pull">
<db:title>Push and Pull</db:title>
<db:para>The low level audio classes can operate in two modes - <db:code>push</db:code> and <db:code>pull</db:code>. In <db:code>pull</db:code> mode, the audio device is started by giving it a <db:link xlink:href="qiodevice.xml">QIODevice</db:link>. For an output device, the <db:link xlink:href="qaudiooutput.xml">QAudioOutput</db:link> class will pull data from the <db:link xlink:href="qiodevice.xml">QIODevice</db:link> (using <db:link xlink:href="qiodevice.xml#read">QIODevice::read</db:link>()) when more audio data is required. Conversely, for <db:code>pull</db:code> mode with <db:link xlink:href="qaudioinput.xml">QAudioInput</db:link>, when audio data is available then the data will be written directly to the <db:link xlink:href="qiodevice.xml">QIODevice</db:link>.</db:para>
<db:para>In <db:code>push</db:code> mode, the audio device provides a <db:link xlink:href="qiodevice.xml">QIODevice</db:link> instance that can be written or read to as needed. Typically this results in simpler code but more buffering, which may affect latency.</db:para>
</db:section>
</db:section>
<db:section xml:id="decoding-compressed-audio-to-memory">
<db:title>Decoding Compressed Audio to Memory</db:title>
<db:para>In some cases you may want to decode a compressed audio file and do further processing yourself (for example, mixing multiple samples or using custom digital signal processing algorithms). <db:link xlink:href="qaudiodecoder.xml">QAudioDecoder</db:link> supports decoding local files or data streams from <db:link xlink:href="qiodevice.xml">QIODevice</db:link> instances.</db:para>
<db:para>Here's an example of decoding a local file:</db:para>
<db:programlisting language="cpp">QAudioFormat desiredFormat;
desiredFormat.setChannelCount(2);
desiredFormat.setCodec(&quot;audio/x-raw&quot;);
desiredFormat.setSampleType(QAudioFormat::UnSignedInt);
desiredFormat.setSampleRate(48000);
desiredFormat.setSampleSize(16);

QAudioDecoder *decoder = new QAudioDecoder(this);
decoder-&gt;setAudioFormat(desiredFormat);
decoder-&gt;setSourceFilename(&quot;level1.mp3&quot;);

connect(decoder, SIGNAL(bufferReady()), this, SLOT(readBuffer()));
decoder-&gt;start();

// Now wait for bufferReady() signal and call decoder-&gt;read()
</db:programlisting>
</db:section>
</db:section>
<db:section xml:id="examples">
<db:title>Examples</db:title>
<db:para>There are both C++ and QML examples available.</db:para>
<db:section xml:id="c-examples">
<db:title>C++ Examples</db:title>
</db:section>
</db:section>
<db:section xml:id="reference-documentation">
<db:title>Reference Documentation</db:title>
<db:section xml:id="c-classes">
<db:title>C++ Classes</db:title>
<db:variablelist role="multimedia_audio">
<db:varlistentry>
<db:term><db:link xlink:href="qaudio.xml" xlink:role="namespace">QAudio</db:link></db:term>
<db:listitem>
<db:para>The QAudio namespace contains enums used by the audio classes.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qaudiobuffer.xml" xlink:role="class">QAudioBuffer</db:link></db:term>
<db:listitem>
<db:para>The QAudioBuffer class represents a collection of audio samples with a specific format and sample rate.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qaudiobuffer-stereoframe.xml" xlink:role="class">QAudioBuffer::StereoFrame</db:link></db:term>
<db:listitem>
<db:para>The StereoFrame class provides a simple wrapper for a stereo audio frame.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qaudiodecoder.xml" xlink:role="class">QAudioDecoder</db:link></db:term>
<db:listitem>
<db:para>The QAudioDecoder class allows decoding audio.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qaudiodeviceinfo.xml" xlink:role="class">QAudioDeviceInfo</db:link></db:term>
<db:listitem>
<db:para>The QAudioDeviceInfo class provides an interface to query audio devices and their functionality.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qaudioformat.xml" xlink:role="class">QAudioFormat</db:link></db:term>
<db:listitem>
<db:para>The QAudioFormat class stores audio stream parameter information.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qaudioinput.xml" xlink:role="class">QAudioInput</db:link></db:term>
<db:listitem>
<db:para>The QAudioInput class provides an interface for receiving audio data from an audio input device.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qaudiooutput.xml" xlink:role="class">QAudioOutput</db:link></db:term>
<db:listitem>
<db:para>The QAudioOutput class provides an interface for sending audio data to an audio output device.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qaudioprobe.xml" xlink:role="class">QAudioProbe</db:link></db:term>
<db:listitem>
<db:para>The QAudioProbe class allows you to monitor audio being played or recorded.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qsound.xml" xlink:role="class">QSound</db:link></db:term>
<db:listitem>
<db:para>The QSound class provides a method to play .wav sound files.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qsoundeffect.xml" xlink:role="class">QSoundEffect</db:link></db:term>
<db:listitem>
<db:para>The QSoundEffect class provides a way to play low latency sound effects.</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
</db:section>
<db:section xml:id="qml-types">
<db:title>QML Types</db:title>
<db:variablelist role="multimedia_audio_qml">
<db:varlistentry>
<db:term><db:link xlink:href="qml-qtmultimedia-audio.xml" xlink:role="">Audio</db:link></db:term>
<db:listitem>
<db:para>Add audio playback to a scene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qml-qtmultimedia-mediaplayer.xml" xlink:role="">MediaPlayer</db:link></db:term>
<db:listitem>
<db:para>Add media playback to a scene.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qml-qtmultimedia-playlist.xml" xlink:role="">Playlist</db:link></db:term>
<db:listitem>
<db:para>For specifying a list of media to be played.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qml-qtmultimedia-playlistitem.xml" xlink:role="">PlaylistItem</db:link></db:term>
<db:listitem>
<db:para>Defines an item in a Playlist.</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:link xlink:href="qml-qtmultimedia-soundeffect.xml" xlink:role="">SoundEffect</db:link></db:term>
<db:listitem>
<db:para>The SoundEffect type provides a way to play sound effects in QML.</db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
</db:section>
</db:section>
</db:article>
