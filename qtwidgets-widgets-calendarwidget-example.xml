<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Calendar Widget Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.14.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Calendar Widget example shows use of QCalendarWidget.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/calendarwidgetexample.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>QCalendarWidget displays one calendar month at a time and lets the user select a date. The calendar consists of four components: a navigation bar that lets the user change the month that is displayed, a grid where each cell represents one day in the month, and two headers that display weekday names and week numbers.</db:para>
<db:para>The Calendar Widget example displays a QCalendarWidget and lets the user configure its appearance and behavior using QComboBoxes, QCheckBoxes, and QDateEdits. In addition, the user can influence the formatting of individual dates and headers.</db:para>
<db:para>The properties of the QCalendarWidget are summarized in the table below.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Property</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>selectedDate</db:para>
</db:td>
<db:td>
<db:para>The currently selected date.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>minimumDate</db:para>
</db:td>
<db:td>
<db:para>The earliest date that can be selected.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>maximumDate</db:para>
</db:td>
<db:td>
<db:para>The latest date that can be selected.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>firstDayOfWeek</db:para>
</db:td>
<db:td>
<db:para>The day that is displayed as the first day of the week (usually Sunday or Monday).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>gridVisible</db:para>
</db:td>
<db:td>
<db:para>Whether the grid should be shown.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>selectionMode</db:para>
</db:td>
<db:td>
<db:para>Whether the user can select a date or not.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>horizontalHeaderFormat</db:para>
</db:td>
<db:td>
<db:para>The format of the day names in the horizontal header (e.g., &quot;M&quot;, &quot;Mon&quot;, or &quot;Monday&quot;).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>verticalHeaderFormat</db:para>
</db:td>
<db:td>
<db:para>The format of the vertical header.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>navigationBarVisible</db:para>
</db:td>
<db:td>
<db:para>Whether the navigation bar at the top of the calendar widget is shown.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The example consists of one class, <db:code>Window</db:code>, which creates and lays out the QCalendarWidget and the other widgets that let the user configure the QCalendarWidget.</db:para>
<db:section xml:id="window-class-definition">
<db:title>Window Class Definition</db:title>
<db:para>Here is the definition of the <db:code>Window</db:code> class:</db:para>
<db:programlisting language="cpp">class Window : public QWidget
{
    Q_OBJECT

public:
    Window(QWidget *parent = nullptr);

private slots:
    void localeChanged(int index);
    void firstDayChanged(int index);
    void selectionModeChanged(int index);
    void horizontalHeaderChanged(int index);
    void verticalHeaderChanged(int index);
    void selectedDateChanged();
    void minimumDateChanged(QDate date);
    void maximumDateChanged(QDate date);
    void weekdayFormatChanged();
    void weekendFormatChanged();
    void reformatHeaders();
    void reformatCalendarPage();

private:
    void createPreviewGroupBox();
    void createGeneralOptionsGroupBox();
    void createDatesGroupBox();
    void createTextFormatsGroupBox();
    QComboBox *createColorComboBox();

    QGroupBox *previewGroupBox;
    QGridLayout *previewLayout;
    QCalendarWidget *calendar;

    QGroupBox *generalOptionsGroupBox;
    QLabel *localeLabel;
    QLabel *firstDayLabel;
    ...
    QCheckBox *mayFirstCheckBox;
};
</db:programlisting>
<db:para>As is often the case with classes that represent self-contained windows, most of the API is private. We will review the private members as we stumble upon them in the implementation.</db:para>
</db:section>
<db:section xml:id="window-class-implementation">
<db:title>Window Class Implementation</db:title>
<db:para>Let's now review the class implementation, starting with the constructor:</db:para>
<db:programlisting language="cpp">Window::Window(QWidget *parent)
    : QWidget(parent)
{
    createPreviewGroupBox();
    createGeneralOptionsGroupBox();
    createDatesGroupBox();
    createTextFormatsGroupBox();

    QGridLayout *layout = new QGridLayout;
    layout-&amp;gt;addWidget(previewGroupBox, 0, 0);
    layout-&amp;gt;addWidget(generalOptionsGroupBox, 0, 1);
    layout-&amp;gt;addWidget(datesGroupBox, 1, 0);
    layout-&amp;gt;addWidget(textFormatsGroupBox, 1, 1);
    layout-&amp;gt;setSizeConstraint(QLayout::SetFixedSize);
    setLayout(layout);

    previewLayout-&amp;gt;setRowMinimumHeight(0, calendar-&amp;gt;sizeHint().height());
    previewLayout-&amp;gt;setColumnMinimumWidth(0, calendar-&amp;gt;sizeHint().width());

    setWindowTitle(tr(&quot;Calendar Widget&quot;));
}
</db:programlisting>
<db:para>We start by creating the four QGroupBoxes and their child widgets (including the QCalendarWidget) using four private <db:code>create...GroupBox()</db:code> functions, described below. Then we arrange the group boxes in a QGridLayout.</db:para>
<db:para>We set the grid layout's resize policy to QLayout::SetFixedSize to prevent the user from resizing the window. In that mode, the window's size is set automatically by QGridLayout based on the size hints of its contents widgets.</db:para>
<db:para>To ensure that the window isn't automatically resized every time we change a property of the QCalendarWidget (for example, hiding the navigation bar, the vertical header, or the grid), we set the minimum height of row 0 and the minimum width of column 0 to the initial size of the QCalendarWidget.</db:para>
<db:para>Let's move on to the <db:code>createPreviewGroupBox()</db:code> function:</db:para>
<db:programlisting language="cpp">void Window::createPreviewGroupBox()
{
    previewGroupBox = new QGroupBox(tr(&quot;Preview&quot;));

    calendar = new QCalendarWidget;
    calendar-&amp;gt;setMinimumDate(QDate(1900, 1, 1));
    calendar-&amp;gt;setMaximumDate(QDate(3000, 1, 1));
    calendar-&amp;gt;setGridVisible(true);

    connect(calendar, &amp;amp;QCalendarWidget::currentPageChanged,
            this, &amp;amp;Window::reformatCalendarPage);

    previewLayout = new QGridLayout;
    previewLayout-&amp;gt;addWidget(calendar, 0, 0, Qt::AlignCenter);
    previewGroupBox-&amp;gt;setLayout(previewLayout);
}
</db:programlisting>
<db:para>The <db:guilabel>Preview</db:guilabel> group box contains only one widget: the QCalendarWidget. We set it up, connect its <db:link xlink:href="">currentPageChanged()</db:link> signal to our <db:code>reformatCalendarPage()</db:code> slot to make sure that every new page gets the formatting specified by the user.</db:para>
<db:para>The <db:code>createGeneralOptionsGroupBox()</db:code> function is somewhat large and several widgets are set up in the same way. We will look at parts of its implementation here and skip the rest:</db:para>
<db:programlisting language="cpp">void Window::createGeneralOptionsGroupBox()
{
    generalOptionsGroupBox = new QGroupBox(tr(&quot;General Options&quot;));

    localeCombo = new QComboBox;
    int curLocaleIndex = -1;
    int index = 0;
    for (int _lang = QLocale::C; _lang &amp;lt;= QLocale::LastLanguage; ++_lang) {
        QLocale::Language lang = static_cast&amp;lt;QLocale::Language&amp;gt;(_lang);
        QList&amp;lt;QLocale::Country&amp;gt; countries = QLocale::countriesForLanguage(lang);
        for (int i = 0; i &amp;lt; countries.count(); ++i) {
            QLocale::Country country = countries.at(i);
            QString label = QLocale::languageToString(lang);
            label += QLatin1Char('/');
            label += QLocale::countryToString(country);
            QLocale locale(lang, country);
            if (this-&amp;gt;locale().language() == lang &amp;amp;&amp;amp; this-&amp;gt;locale().country() == country)
                curLocaleIndex = index;
            localeCombo-&amp;gt;addItem(label, locale);
            ++index;
        }
    }
    if (curLocaleIndex != -1)
        localeCombo-&amp;gt;setCurrentIndex(curLocaleIndex);
    localeLabel = new QLabel(tr(&quot;&amp;amp;Locale&quot;));
    localeLabel-&amp;gt;setBuddy(localeCombo);

    firstDayCombo = new QComboBox;
    firstDayCombo-&amp;gt;addItem(tr(&quot;Sunday&quot;), Qt::Sunday);
    firstDayCombo-&amp;gt;addItem(tr(&quot;Monday&quot;), Qt::Monday);
    firstDayCombo-&amp;gt;addItem(tr(&quot;Tuesday&quot;), Qt::Tuesday);
    firstDayCombo-&amp;gt;addItem(tr(&quot;Wednesday&quot;), Qt::Wednesday);
    firstDayCombo-&amp;gt;addItem(tr(&quot;Thursday&quot;), Qt::Thursday);
    firstDayCombo-&amp;gt;addItem(tr(&quot;Friday&quot;), Qt::Friday);
    firstDayCombo-&amp;gt;addItem(tr(&quot;Saturday&quot;), Qt::Saturday);

    firstDayLabel = new QLabel(tr(&quot;Wee&amp;amp;k starts on:&quot;));
    firstDayLabel-&amp;gt;setBuddy(firstDayCombo);
    ...
</db:programlisting>
<db:para>We start with the setup of the <db:guilabel>Week starts on</db:guilabel> combobox. This combobox controls which day should be displayed as the first day of the week.</db:para>
<db:para>The QComboBox class lets us attach user data as a QVariant to each item. The data can later be retrieved with QComboBox's <db:link xlink:href="">itemData()</db:link> function. QVariant doesn't directly support the Qt::DayOfWeek data type, but it supports <db:code>int</db:code>, and C++ will happily convert any enum value to <db:code>int</db:code>.</db:para>
<db:programlisting language="cpp">    ...
    connect(localeCombo, QOverload&amp;lt;int&amp;gt;::of(&amp;amp;QComboBox::currentIndexChanged),
            this, &amp;amp;Window::localeChanged);
    connect(firstDayCombo, QOverload&amp;lt;int&amp;gt;::of(&amp;amp;QComboBox::currentIndexChanged),
            this, &amp;amp;Window::firstDayChanged);
    connect(selectionModeCombo, QOverload&amp;lt;int&amp;gt;::of(&amp;amp;QComboBox::currentIndexChanged),
            this, &amp;amp;Window::selectionModeChanged);
    connect(gridCheckBox, &amp;amp;QCheckBox::toggled,
            calendar, &amp;amp;QCalendarWidget::setGridVisible);
    connect(navigationCheckBox, &amp;amp;QCheckBox::toggled,
            calendar, &amp;amp;QCalendarWidget::setNavigationBarVisible);
    connect(horizontalHeaderCombo, QOverload&amp;lt;int&amp;gt;::of(&amp;amp;QComboBox::currentIndexChanged),
            this, &amp;amp;Window::horizontalHeaderChanged);
    connect(verticalHeaderCombo, QOverload&amp;lt;int&amp;gt;::of(&amp;amp;QComboBox::currentIndexChanged),
            this, &amp;amp;Window::verticalHeaderChanged);
    ...
</db:programlisting>
<db:para>After having created the widgets, we connect the signals and slots. We connect the comboboxes to private slots of <db:code>Window</db:code> or to public slots provided by QComboBox.</db:para>
<db:programlisting language="cpp">    ...
    firstDayChanged(firstDayCombo-&amp;gt;currentIndex());
    selectionModeChanged(selectionModeCombo-&amp;gt;currentIndex());
    horizontalHeaderChanged(horizontalHeaderCombo-&amp;gt;currentIndex());
    verticalHeaderChanged(verticalHeaderCombo-&amp;gt;currentIndex());
}
</db:programlisting>
<db:para>At the end of the function, we call the slots that update the calendar to ensure that the QCalendarWidget is synchronized with the other widgets on startup.</db:para>
<db:para>Let's now take a look at the <db:code>createDatesGroupBox()</db:code> private function:</db:para>
<db:programlisting language="cpp">void Window::createDatesGroupBox()
{
    datesGroupBox = new QGroupBox(tr(&quot;Dates&quot;));

    minimumDateEdit = new QDateEdit;
    minimumDateEdit-&amp;gt;setDisplayFormat(&quot;MMM d yyyy&quot;);
    minimumDateEdit-&amp;gt;setDateRange(calendar-&amp;gt;minimumDate(),
                                  calendar-&amp;gt;maximumDate());
    minimumDateEdit-&amp;gt;setDate(calendar-&amp;gt;minimumDate());

    minimumDateLabel = new QLabel(tr(&quot;&amp;amp;Minimum Date:&quot;));
    minimumDateLabel-&amp;gt;setBuddy(minimumDateEdit);

    currentDateEdit = new QDateEdit;
    currentDateEdit-&amp;gt;setDisplayFormat(&quot;MMM d yyyy&quot;);
    currentDateEdit-&amp;gt;setDate(calendar-&amp;gt;selectedDate());
    currentDateEdit-&amp;gt;setDateRange(calendar-&amp;gt;minimumDate(),
                                  calendar-&amp;gt;maximumDate());

    currentDateLabel = new QLabel(tr(&quot;&amp;amp;Current Date:&quot;));
    currentDateLabel-&amp;gt;setBuddy(currentDateEdit);

    maximumDateEdit = new QDateEdit;
    maximumDateEdit-&amp;gt;setDisplayFormat(&quot;MMM d yyyy&quot;);
    maximumDateEdit-&amp;gt;setDateRange(calendar-&amp;gt;minimumDate(),
                                  calendar-&amp;gt;maximumDate());
    maximumDateEdit-&amp;gt;setDate(calendar-&amp;gt;maximumDate());

    maximumDateLabel = new QLabel(tr(&quot;Ma&amp;amp;ximum Date:&quot;));
    maximumDateLabel-&amp;gt;setBuddy(maximumDateEdit);
</db:programlisting>
<db:para>In this function, we create the <db:guilabel>Minimum Date</db:guilabel>, <db:guilabel>Maximum Date</db:guilabel>, and <db:guilabel>Current Date</db:guilabel> editor widgets, which control the calendar's minimum, maximum, and selected dates. The calendar's minimum and maximum dates have already been set in <db:code>createPrivewGroupBox()</db:code>; we can then set the widgets default values to the calendars values.</db:para>
<db:programlisting language="cpp">    connect(currentDateEdit, &amp;amp;QDateEdit::dateChanged,
            calendar, &amp;amp;QCalendarWidget::setSelectedDate);
    connect(calendar, &amp;amp;QCalendarWidget::selectionChanged,
            this, &amp;amp;Window::selectedDateChanged);
    connect(minimumDateEdit, &amp;amp;QDateEdit::dateChanged,
            this, &amp;amp;Window::minimumDateChanged);
    connect(maximumDateEdit, &amp;amp;QDateEdit::dateChanged,
            this, &amp;amp;Window::maximumDateChanged);
    ...
}
</db:programlisting>
<db:para>We connect the <db:code>currentDateEdit</db:code>'s <db:link xlink:href="">dateChanged()</db:link> signal directly to the calendar's <db:link xlink:href="">setSelectedDate()</db:link> slot. When the calendar's selected date changes, either as a result of a user action or programmatically, our <db:code>selectedDateChanged()</db:code> slot updates the <db:guilabel>Current Date</db:guilabel> editor. We also need to react when the user changes the <db:guilabel>Minimum Date</db:guilabel> and <db:guilabel>Maximum Date</db:guilabel> editors.</db:para>
<db:para>Here is the <db:code>createTextFormatsGroup()</db:code> function:</db:para>
<db:programlisting language="cpp">void Window::createTextFormatsGroupBox()
{
    textFormatsGroupBox = new QGroupBox(tr(&quot;Text Formats&quot;));

    weekdayColorCombo = createColorComboBox();
    weekdayColorCombo-&amp;gt;setCurrentIndex(
            weekdayColorCombo-&amp;gt;findText(tr(&quot;Black&quot;)));

    weekdayColorLabel = new QLabel(tr(&quot;&amp;amp;Weekday color:&quot;));
    weekdayColorLabel-&amp;gt;setBuddy(weekdayColorCombo);

    weekendColorCombo = createColorComboBox();
    weekendColorCombo-&amp;gt;setCurrentIndex(
            weekendColorCombo-&amp;gt;findText(tr(&quot;Red&quot;)));

    weekendColorLabel = new QLabel(tr(&quot;Week&amp;amp;end color:&quot;));
    weekendColorLabel-&amp;gt;setBuddy(weekendColorCombo);
</db:programlisting>
<db:para>We set up the <db:guilabel>Weekday Color</db:guilabel> and <db:guilabel>Weekend Color</db:guilabel> comboboxes using <db:code>createColorCombo()</db:code>, which instantiates a QComboBox and populates it with colors (&quot;Red&quot;, &quot;Blue&quot;, etc.).</db:para>
<db:programlisting language="cpp">    headerTextFormatCombo = new QComboBox;
    headerTextFormatCombo-&amp;gt;addItem(tr(&quot;Bold&quot;));
    headerTextFormatCombo-&amp;gt;addItem(tr(&quot;Italic&quot;));
    headerTextFormatCombo-&amp;gt;addItem(tr(&quot;Plain&quot;));

    headerTextFormatLabel = new QLabel(tr(&quot;&amp;amp;Header text:&quot;));
    headerTextFormatLabel-&amp;gt;setBuddy(headerTextFormatCombo);

    firstFridayCheckBox = new QCheckBox(tr(&quot;&amp;amp;First Friday in blue&quot;));

    mayFirstCheckBox = new QCheckBox(tr(&quot;May &amp;amp;1 in red&quot;));
</db:programlisting>
<db:para>The <db:guilabel>Header Text Format</db:guilabel> combobox lets the user change the text format (bold, italic, or plain) used for horizontal and vertical headers. The <db:guilabel>First Friday in blue</db:guilabel> and <db:guilabel>May 1 in red</db:guilabel> check box affect the rendering of specific dates.</db:para>
<db:programlisting language="cpp">    connect(weekdayColorCombo, QOverload&amp;lt;int&amp;gt;::of(&amp;amp;QComboBox::currentIndexChanged),
            this, &amp;amp;Window::weekdayFormatChanged);
    connect(weekdayColorCombo, QOverload&amp;lt;int&amp;gt;::of(&amp;amp;QComboBox::currentIndexChanged),
            this, &amp;amp;Window::reformatCalendarPage);
    connect(weekendColorCombo, QOverload&amp;lt;int&amp;gt;::of(&amp;amp;QComboBox::currentIndexChanged),
            this, &amp;amp;Window::weekendFormatChanged);
    connect(weekendColorCombo, QOverload&amp;lt;int&amp;gt;::of(&amp;amp;QComboBox::currentIndexChanged),
            this, &amp;amp;Window::reformatCalendarPage);
    connect(headerTextFormatCombo, QOverload&amp;lt;int&amp;gt;::of(&amp;amp;QComboBox::currentIndexChanged),
            this, &amp;amp;Window::reformatHeaders);
    connect(firstFridayCheckBox, &amp;amp;QCheckBox::toggled,
            this, &amp;amp;Window::reformatCalendarPage);
    connect(mayFirstCheckBox, &amp;amp;QCheckBox::toggled,
            this, &amp;amp;Window::reformatCalendarPage);
</db:programlisting>
<db:para>We connect the check boxes and comboboxes to various private slots. The <db:guilabel>First Friday in blue</db:guilabel> and <db:guilabel>May 1 in red</db:guilabel> check boxes are both connected to <db:code>reformatCalendarPage()</db:code>, which is also called when the calendar switches month.</db:para>
<db:programlisting language="cpp">    ...
    reformatHeaders();
    reformatCalendarPage();
}
</db:programlisting>
<db:para>At the end of <db:code>createTextFormatsGroupBox()</db:code>, we call private slots to synchronize the QCalendarWidget with the other widgets.</db:para>
<db:para>We're now done reviewing the four <db:code>create...GroupBox()</db:code> functions. Let's now take a look at the other private functions and slots.</db:para>
<db:programlisting language="cpp">QComboBox *Window::createColorComboBox()
{
    QComboBox *comboBox = new QComboBox;
    comboBox-&amp;gt;addItem(tr(&quot;Red&quot;), QColor(Qt::red));
    comboBox-&amp;gt;addItem(tr(&quot;Blue&quot;), QColor(Qt::blue));
    comboBox-&amp;gt;addItem(tr(&quot;Black&quot;), QColor(Qt::black));
    comboBox-&amp;gt;addItem(tr(&quot;Magenta&quot;), QColor(Qt::magenta));
    return comboBox;
}
</db:programlisting>
<db:para>In <db:code>createColorCombo()</db:code>, we create a combobox and populate it with standard colors. The second argument to QComboBox::addItem() is a QVariant storing user data (in this case, QColor objects).</db:para>
<db:para>This function was used to set up the <db:guilabel>Weekday Color</db:guilabel> and <db:guilabel>Weekend Color</db:guilabel> comboboxes.</db:para>
<db:programlisting language="cpp">void Window::firstDayChanged(int index)
{
    calendar-&amp;gt;setFirstDayOfWeek(Qt::DayOfWeek(
                                firstDayCombo-&amp;gt;itemData(index).toInt()));
}
</db:programlisting>
<db:para>When the user changes the <db:guilabel>Week starts on</db:guilabel> combobox's value, <db:code>firstDayChanged()</db:code> is invoked with the index of the combobox's new value. We retrieve the custom data item associated with the new current item using <db:link xlink:href="">itemData()</db:link> and cast it to a Qt::DayOfWeek.</db:para>
<db:para><db:code>selectionModeChanged()</db:code>, <db:code>horizontalHeaderChanged()</db:code>, and <db:code>verticalHeaderChanged()</db:code> are very similar to <db:code>firstDayChanged()</db:code>, so they are omitted.</db:para>
<db:programlisting language="cpp">void Window::selectedDateChanged()
{
    currentDateEdit-&amp;gt;setDate(calendar-&amp;gt;selectedDate());
}
</db:programlisting>
<db:para>The <db:code>selectedDateChanged()</db:code> updates the <db:guilabel>Current Date</db:guilabel> editor to reflect the current state of the QCalendarWidget.</db:para>
<db:programlisting language="cpp">void Window::minimumDateChanged(QDate date)
{
    calendar-&amp;gt;setMinimumDate(date);
    maximumDateEdit-&amp;gt;setDate(calendar-&amp;gt;maximumDate());
}
</db:programlisting>
<db:para>When the user changes the minimum date, we tell the QCalenderWidget. We also update the <db:guilabel>Maximum Date</db:guilabel> editor, because if the new minimum date is later than the current maximum date, QCalendarWidget will automatically adapt its maximum date to avoid a contradicting state.</db:para>
<db:programlisting language="cpp">void Window::maximumDateChanged(QDate date)
{
    calendar-&amp;gt;setMaximumDate(date);
    minimumDateEdit-&amp;gt;setDate(calendar-&amp;gt;minimumDate());
}
</db:programlisting>
<db:para><db:code>maximumDateChanged()</db:code> is implemented similarly to <db:code>minimumDateChanged()</db:code>.</db:para>
<db:programlisting language="cpp">void Window::weekdayFormatChanged()
{
    QTextCharFormat format;

    format.setForeground(qvariant_cast&amp;lt;QColor&amp;gt;(
        weekdayColorCombo-&amp;gt;itemData(weekdayColorCombo-&amp;gt;currentIndex())));
    calendar-&amp;gt;setWeekdayTextFormat(Qt::Monday, format);
    calendar-&amp;gt;setWeekdayTextFormat(Qt::Tuesday, format);
    calendar-&amp;gt;setWeekdayTextFormat(Qt::Wednesday, format);
    calendar-&amp;gt;setWeekdayTextFormat(Qt::Thursday, format);
    calendar-&amp;gt;setWeekdayTextFormat(Qt::Friday, format);
}
</db:programlisting>
<db:para>Each combobox item has a QColor object as user data corresponding to the item's text. After fetching the colors from the comboboxes, we set the text format of each day of the week.</db:para>
<db:para>The text format of a column in the calendar is given as a QTextCharFormat, which besides the foreground color lets us specify various character formatting information. In this example, we only show a subset of the possibilities.</db:para>
<db:programlisting language="cpp">void Window::weekendFormatChanged()
{
    QTextCharFormat format;

    format.setForeground(qvariant_cast&amp;lt;QColor&amp;gt;(
        weekendColorCombo-&amp;gt;itemData(weekendColorCombo-&amp;gt;currentIndex())));
    calendar-&amp;gt;setWeekdayTextFormat(Qt::Saturday, format);
    calendar-&amp;gt;setWeekdayTextFormat(Qt::Sunday, format);
}
</db:programlisting>
<db:para><db:code>weekendFormatChanged()</db:code> is the same as <db:code>weekdayFormatChanged()</db:code>, except that it affects Saturday and Sunday instead of Monday to Friday.</db:para>
<db:programlisting language="cpp">void Window::reformatHeaders()
{
    QString text = headerTextFormatCombo-&amp;gt;currentText();
    QTextCharFormat format;

    if (text == tr(&quot;Bold&quot;))
        format.setFontWeight(QFont::Bold);
    else if (text == tr(&quot;Italic&quot;))
        format.setFontItalic(true);
    else if (text == tr(&quot;Green&quot;))
        format.setForeground(Qt::green);
    calendar-&amp;gt;setHeaderTextFormat(format);
}
</db:programlisting>
<db:para>The <db:code>reformatHeaders()</db:code> slot is called when the user changes the text format of the headers. We compare the current text of the <db:guilabel>Header Text Format</db:guilabel> combobox to determine which format to apply. (An alternative would have been to store QTextCharFormat values alongside the combobox items.)</db:para>
<db:programlisting language="cpp">void Window::reformatCalendarPage()
{
    QTextCharFormat mayFirstFormat;
    const QDate mayFirst(calendar-&amp;gt;yearShown(), 5, 1);

    QTextCharFormat firstFridayFormat;
    QDate firstFriday(calendar-&amp;gt;yearShown(), calendar-&amp;gt;monthShown(), 1);
    while (firstFriday.dayOfWeek() != Qt::Friday)
        firstFriday = firstFriday.addDays(1);

    if (firstFridayCheckBox-&amp;gt;isChecked()) {
        firstFridayFormat.setForeground(Qt::blue);
    } else { // Revert to regular colour for this day of the week.
        Qt::DayOfWeek dayOfWeek(static_cast&amp;lt;Qt::DayOfWeek&amp;gt;(firstFriday.dayOfWeek()));
        firstFridayFormat.setForeground(calendar-&amp;gt;weekdayTextFormat(dayOfWeek).foreground());
    }

    calendar-&amp;gt;setDateTextFormat(firstFriday, firstFridayFormat);

    // When it is checked, &quot;May First in Red&quot; always takes precedence over &quot;First Friday in Blue&quot;.
    if (mayFirstCheckBox-&amp;gt;isChecked()) {
        mayFirstFormat.setForeground(Qt::red);
    } else if (!firstFridayCheckBox-&amp;gt;isChecked() || firstFriday != mayFirst) {
        // We can now be certain we won't be resetting &quot;May First in Red&quot; when we restore
        // may 1st's regular colour for this day of the week.
        Qt::DayOfWeek dayOfWeek(static_cast&amp;lt;Qt::DayOfWeek&amp;gt;(mayFirst.dayOfWeek()));
        calendar-&amp;gt;setDateTextFormat(mayFirst, calendar-&amp;gt;weekdayTextFormat(dayOfWeek));
    }

    calendar-&amp;gt;setDateTextFormat(mayFirst, mayFirstFormat);
}
</db:programlisting>
<db:para>In <db:code>reformatCalendarPage()</db:code>, we set the text format of the first Friday in the month and May 1 in the current year. The text formats that are actually used depend on which check boxes are checked and what the weekday/weekend formats are.</db:para>
<db:para>QCalendarWidget lets us set the text format of individual dates with the <db:link xlink:href="">setDateTextFormat()</db:link>. We chose to set the date formats when the calendar page changes - i.e. a new month is displayed - and when the weekday/weekend format is changed. We check which of the <db:code>mayFirstCheckBox</db:code> and <db:code>firstDayCheckBox</db:code>, if any, are checked and set the text formats accordingly.</db:para>
</db:section>
<db:section>
<db:title>Example project</db:title>
<db:para><db:link xlink:href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/widgets/calendarwidget?h=5.14">Example project @ code.qt.io</db:link></db:para>
</db:section>
</db:article>
