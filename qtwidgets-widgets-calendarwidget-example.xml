<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Calendar Widget Example</db:title>
<db:productname>QtWidgets</db:productname>
<db:edition>Qt 5.4.2 Reference Documentation</db:edition>
<db:titleabbrev>Qt Widgets Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The Calendar Widget example shows use of QCalendarWidget.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/calendarwidgetexample.png"/>
</db:imageobject>
</db:mediaobject>
<db:para>QCalendarWidget displays one calendar month at a time and lets the user select a date. The calendar consists of four components: a navigation bar that lets the user change the month that is displayed, a grid where each cell represents one day in the month, and two headers that display weekday names and week numbers.</db:para>
<db:para>The Calendar Widget example displays a QCalendarWidget and lets the user configure its appearance and behavior using QComboBoxes, QCheckBoxes, and QDateEdits. In addition, the user can influence the formatting of individual dates and headers.</db:para>
<db:para>The properties of the QCalendarWidget are summarized in the table below.</db:para>
<db:informaltable style="generic">
<db:thead>
<db:tr>
<db:th>
<db:para>Property</db:para>
</db:th>
<db:th>
<db:para>Description</db:para>
</db:th>
</db:tr>
</db:thead>
<db:tr valign="top">
<db:td>
<db:para>selectedDate</db:para>
</db:td>
<db:td>
<db:para>The currently selected date.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>minimumDate</db:para>
</db:td>
<db:td>
<db:para>The earliest date that can be selected.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>maximumDate</db:para>
</db:td>
<db:td>
<db:para>The latest date that can be selected.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>firstDayOfWeek</db:para>
</db:td>
<db:td>
<db:para>The day that is displayed as the first day of the week (usually Sunday or Monday).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>gridVisible</db:para>
</db:td>
<db:td>
<db:para>Whether the grid should be shown.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>selectionMode</db:para>
</db:td>
<db:td>
<db:para>Whether the user can select a date or not.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>horizontalHeaderFormat</db:para>
</db:td>
<db:td>
<db:para>The format of the day names in the horizontal header (e.g., &quot;M&quot;, &quot;Mon&quot;, or &quot;Monday&quot;).</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>verticalHeaderFormat</db:para>
</db:td>
<db:td>
<db:para>The format of the vertical header.</db:para>
</db:td>
</db:tr>
<db:tr valign="top">
<db:td>
<db:para>navigationBarVisible</db:para>
</db:td>
<db:td>
<db:para>Whether the navigation bar at the top of the calendar widget is shown.</db:para>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The example consists of one class, <db:code>Window</db:code>, which creates and lays out the QCalendarWidget and the other widgets that let the user configure the QCalendarWidget.</db:para>
<db:section xml:id="window-class-definition">
<db:title>Window Class Definition</db:title>
<db:para>Here is the definition of the <db:code>Window</db:code> class:</db:para>
<db:programlisting language="cpp">class Window : public QWidget
{
    Q_OBJECT

public:
    Window();

private slots:
    void localeChanged(int index);
    void firstDayChanged(int index);
    void selectionModeChanged(int index);
    void horizontalHeaderChanged(int index);
    void verticalHeaderChanged(int index);
    void selectedDateChanged();
    void minimumDateChanged(const QDate &amp;date);
    void maximumDateChanged(const QDate &amp;date);
    void weekdayFormatChanged();
    void weekendFormatChanged();
    void reformatHeaders();
    void reformatCalendarPage();

private:
    void createPreviewGroupBox();
    void createGeneralOptionsGroupBox();
    void createDatesGroupBox();
    void createTextFormatsGroupBox();
    QComboBox *createColorComboBox();

    QGroupBox *previewGroupBox;
    QGridLayout *previewLayout;
    QCalendarWidget *calendar;

    QGroupBox *generalOptionsGroupBox;
    QLabel *localeLabel;
    QLabel *firstDayLabel;
    ...
    QCheckBox *mayFirstCheckBox;
};
</db:programlisting>
<db:para>As is often the case with classes that represent self-contained windows, most of the API is private. We will review the private members as we stumble upon them in the implementation.</db:para>
</db:section>
<db:section xml:id="window-class-implementation">
<db:title>Window Class Implementation</db:title>
<db:para>Let's now review the class implementation, starting with the constructor:</db:para>
<db:programlisting language="cpp">Window::Window()
{
    createPreviewGroupBox();
    createGeneralOptionsGroupBox();
    createDatesGroupBox();
    createTextFormatsGroupBox();

    QGridLayout *layout = new QGridLayout;
    layout-&gt;addWidget(previewGroupBox, 0, 0);
    layout-&gt;addWidget(generalOptionsGroupBox, 0, 1);
    layout-&gt;addWidget(datesGroupBox, 1, 0);
    layout-&gt;addWidget(textFormatsGroupBox, 1, 1);
    layout-&gt;setSizeConstraint(QLayout::SetFixedSize);
    setLayout(layout);

    previewLayout-&gt;setRowMinimumHeight(0, calendar-&gt;sizeHint().height());
    previewLayout-&gt;setColumnMinimumWidth(0, calendar-&gt;sizeHint().width());

    setWindowTitle(tr(&quot;Calendar Widget&quot;));
}
</db:programlisting>
<db:para>We start by creating the four QGroupBoxes and their child widgets (including the QCalendarWidget) using four private <db:code>create...GroupBox()</db:code> functions, described below. Then we arrange the group boxes in a QGridLayout.</db:para>
<db:para>We set the grid layout's resize policy to QLayout::SetFixedSize to prevent the user from resizing the window. In that mode, the window's size is set automatically by QGridLayout based on the size hints of its contents widgets.</db:para>
<db:para>To ensure that the window isn't automatically resized every time we change a property of the QCalendarWidget (e.g., hiding the navigation bar, trhe vertical header, or the grid), we set the minimum height of row 0 and the minimum width of column 0 to the initial size of the QCalendarWidget.</db:para>
<db:para>Let's move on to the <db:code>createPreviewGroupBox()</db:code> function:</db:para>
<db:programlisting language="cpp">void Window::createPreviewGroupBox()
{
    previewGroupBox = new QGroupBox(tr(&quot;Preview&quot;));

    calendar = new QCalendarWidget;
    calendar-&gt;setMinimumDate(QDate(1900, 1, 1));
    calendar-&gt;setMaximumDate(QDate(3000, 1, 1));
    calendar-&gt;setGridVisible(true);

    connect(calendar, SIGNAL(currentPageChanged(int,int)),
            this, SLOT(reformatCalendarPage()));

    previewLayout = new QGridLayout;
    previewLayout-&gt;addWidget(calendar, 0, 0, Qt::AlignCenter);
    previewGroupBox-&gt;setLayout(previewLayout);
}
</db:programlisting>
<db:para>The <db:guilabel>Preview</db:guilabel> group box contains only one widget: the QCalendarWidget. We set it up, connect its <db:link xlink:href="">currentPageChanged()</db:link> signal to our <db:code>reformatCalendarPage()</db:code> slot to make sure that every new page gets the formatting specified by the user.</db:para>
<db:para>The <db:code>createGeneralOptionsGroupBox()</db:code> function is somewhat large and several widgets are set up the same way; we look at parts of its implementation here and skip the rest:</db:para>
<db:programlisting language="cpp">void Window::createGeneralOptionsGroupBox()
{
    generalOptionsGroupBox = new QGroupBox(tr(&quot;General Options&quot;));

    localeCombo = new QComboBox;
    int curLocaleIndex = -1;
    int index = 0;
    for (int _lang = QLocale::C; _lang &lt;= QLocale::LastLanguage; ++_lang) {
        QLocale::Language lang = static_cast&lt;QLocale::Language&gt;(_lang);
        QList&lt;QLocale::Country&gt; countries = QLocale::countriesForLanguage(lang);
        for (int i = 0; i &lt; countries.count(); ++i) {
            QLocale::Country country = countries.at(i);
            QString label = QLocale::languageToString(lang);
            label += QLatin1Char('/');
            label += QLocale::countryToString(country);
            QLocale locale(lang, country);
            if (this-&gt;locale().language() == lang &amp;&amp; this-&gt;locale().country() == country)
                curLocaleIndex = index;
            localeCombo-&gt;addItem(label, locale);
            ++index;
        }
    }
    if (curLocaleIndex != -1)
        localeCombo-&gt;setCurrentIndex(curLocaleIndex);
    localeLabel = new QLabel(tr(&quot;&amp;Locale&quot;));
    localeLabel-&gt;setBuddy(localeCombo);

    firstDayCombo = new QComboBox;
    firstDayCombo-&gt;addItem(tr(&quot;Sunday&quot;), Qt::Sunday);
    firstDayCombo-&gt;addItem(tr(&quot;Monday&quot;), Qt::Monday);
    firstDayCombo-&gt;addItem(tr(&quot;Tuesday&quot;), Qt::Tuesday);
    firstDayCombo-&gt;addItem(tr(&quot;Wednesday&quot;), Qt::Wednesday);
    firstDayCombo-&gt;addItem(tr(&quot;Thursday&quot;), Qt::Thursday);
    firstDayCombo-&gt;addItem(tr(&quot;Friday&quot;), Qt::Friday);
    firstDayCombo-&gt;addItem(tr(&quot;Saturday&quot;), Qt::Saturday);

    firstDayLabel = new QLabel(tr(&quot;Wee&amp;k starts on:&quot;));
    firstDayLabel-&gt;setBuddy(firstDayCombo);
    ...
</db:programlisting>
<db:para>We start with the setup of the <db:guilabel>Week starts on</db:guilabel> combobox. This combobox controls which day should be displayed as the first day of the week.</db:para>
<db:para>The QComboBox class lets us attach user data as a <db:link xlink:href="qvariant.xml">QVariant</db:link> to each item. The data can later be retrieved with QComboBox's <db:link xlink:href="">itemData()</db:link> function. <db:link xlink:href="qvariant.xml">QVariant</db:link> doesn't directly support the <db:link xlink:href="qt.xml#DayOfWeek-enum">Qt::DayOfWeek</db:link> data type, but it supports <db:code>int</db:code>, and C++ will happily convert any enum value to <db:code>int</db:code>.</db:para>
<db:programlisting language="cpp">    ...
    connect(localeCombo, SIGNAL(currentIndexChanged(int)),
            this, SLOT(localeChanged(int)));
    connect(firstDayCombo, SIGNAL(currentIndexChanged(int)),
            this, SLOT(firstDayChanged(int)));
    connect(selectionModeCombo, SIGNAL(currentIndexChanged(int)),
            this, SLOT(selectionModeChanged(int)));
    connect(gridCheckBox, SIGNAL(toggled(bool)),
            calendar, SLOT(setGridVisible(bool)));
    connect(navigationCheckBox, SIGNAL(toggled(bool)),
            calendar, SLOT(setNavigationBarVisible(bool)));
    connect(horizontalHeaderCombo, SIGNAL(currentIndexChanged(int)),
            this, SLOT(horizontalHeaderChanged(int)));
    connect(verticalHeaderCombo, SIGNAL(currentIndexChanged(int)),
            this, SLOT(verticalHeaderChanged(int)));
    ...
</db:programlisting>
<db:para>After creating the widgets, we connect the signals and slots. We connect the comboboxes to private slots of <db:code>Window</db:code> or to public slots provided by QComboBox.</db:para>
<db:programlisting language="cpp">    ...
    firstDayChanged(firstDayCombo-&gt;currentIndex());
    selectionModeChanged(selectionModeCombo-&gt;currentIndex());
    horizontalHeaderChanged(horizontalHeaderCombo-&gt;currentIndex());
    verticalHeaderChanged(verticalHeaderCombo-&gt;currentIndex());
}
</db:programlisting>
<db:para>At the end of the function, we call the slots that update the calendar to ensure that the QCalendarWidget is synchronized with the other widgets on startup.</db:para>
<db:para>Let's now take a look at the <db:code>createDatesGroupBox()</db:code> private function:</db:para>
<db:programlisting language="cpp">void Window::createDatesGroupBox()
{
    datesGroupBox = new QGroupBox(tr(&quot;Dates&quot;));

    minimumDateEdit = new QDateEdit;
    minimumDateEdit-&gt;setDisplayFormat(&quot;MMM d yyyy&quot;);
    minimumDateEdit-&gt;setDateRange(calendar-&gt;minimumDate(),
                                  calendar-&gt;maximumDate());
    minimumDateEdit-&gt;setDate(calendar-&gt;minimumDate());

    minimumDateLabel = new QLabel(tr(&quot;&amp;Minimum Date:&quot;));
    minimumDateLabel-&gt;setBuddy(minimumDateEdit);

    currentDateEdit = new QDateEdit;
    currentDateEdit-&gt;setDisplayFormat(&quot;MMM d yyyy&quot;);
    currentDateEdit-&gt;setDate(calendar-&gt;selectedDate());
    currentDateEdit-&gt;setDateRange(calendar-&gt;minimumDate(),
                                  calendar-&gt;maximumDate());

    currentDateLabel = new QLabel(tr(&quot;&amp;Current Date:&quot;));
    currentDateLabel-&gt;setBuddy(currentDateEdit);

    maximumDateEdit = new QDateEdit;
    maximumDateEdit-&gt;setDisplayFormat(&quot;MMM d yyyy&quot;);
    maximumDateEdit-&gt;setDateRange(calendar-&gt;minimumDate(),
                                  calendar-&gt;maximumDate());
    maximumDateEdit-&gt;setDate(calendar-&gt;maximumDate());

    maximumDateLabel = new QLabel(tr(&quot;Ma&amp;ximum Date:&quot;));
    maximumDateLabel-&gt;setBuddy(maximumDateEdit);

</db:programlisting>
<db:para>In this function, we create the <db:guilabel>Minimum Date</db:guilabel>, <db:guilabel>Maximum Date</db:guilabel>, and <db:guilabel>Current Date</db:guilabel> editor widgets, which control the calendar's minimum, maximum, and selected dates. The calendar's minimum and maximum dates have already been set in <db:code>createPrivewGroupBox()</db:code>; we can then set the widgets default values to the calendars values.</db:para>
<db:programlisting language="cpp">    connect(currentDateEdit, SIGNAL(dateChanged(QDate)),
            calendar, SLOT(setSelectedDate(QDate)));
    connect(calendar, SIGNAL(selectionChanged()),
            this, SLOT(selectedDateChanged()));
    connect(minimumDateEdit, SIGNAL(dateChanged(QDate)),
            this, SLOT(minimumDateChanged(QDate)));
    connect(maximumDateEdit, SIGNAL(dateChanged(QDate)),
            this, SLOT(maximumDateChanged(QDate)));
    ...
}
</db:programlisting>
<db:para>We connect the <db:code>currentDateEdit</db:code>'s <db:link xlink:href="">dateChanged()</db:link> signal directly to the calendar's <db:link xlink:href="">setSelectedDate()</db:link> slot. When the calendar's selected date changes, either as a result of a user action or programmatically, our <db:code>selectedDateChanged()</db:code> slot updates the <db:guilabel>Current Date</db:guilabel> editor. We also need to react when the user changes the <db:guilabel>Minimum Date</db:guilabel> and <db:guilabel>Maximum Date</db:guilabel> editors.</db:para>
<db:para>Here is the <db:code>createTextFormatsGroup()</db:code> function:</db:para>
<db:programlisting language="cpp">void Window::createTextFormatsGroupBox()
{
    textFormatsGroupBox = new QGroupBox(tr(&quot;Text Formats&quot;));

    weekdayColorCombo = createColorComboBox();
    weekdayColorCombo-&gt;setCurrentIndex(
            weekdayColorCombo-&gt;findText(tr(&quot;Black&quot;)));

    weekdayColorLabel = new QLabel(tr(&quot;&amp;Weekday color:&quot;));
    weekdayColorLabel-&gt;setBuddy(weekdayColorCombo);

    weekendColorCombo = createColorComboBox();
    weekendColorCombo-&gt;setCurrentIndex(
            weekendColorCombo-&gt;findText(tr(&quot;Red&quot;)));

    weekendColorLabel = new QLabel(tr(&quot;Week&amp;end color:&quot;));
    weekendColorLabel-&gt;setBuddy(weekendColorCombo);

</db:programlisting>
<db:para>We set up the <db:guilabel>Weekday Color</db:guilabel> and <db:guilabel>Weekend Color</db:guilabel> comboboxes using <db:code>createColorCombo()</db:code>, which instantiates a QComboBox and populates it with colors (&quot;Red&quot;, &quot;Blue&quot;, etc.).</db:para>
<db:programlisting language="cpp">    headerTextFormatCombo = new QComboBox;
    headerTextFormatCombo-&gt;addItem(tr(&quot;Bold&quot;));
    headerTextFormatCombo-&gt;addItem(tr(&quot;Italic&quot;));
    headerTextFormatCombo-&gt;addItem(tr(&quot;Plain&quot;));

    headerTextFormatLabel = new QLabel(tr(&quot;&amp;Header text:&quot;));
    headerTextFormatLabel-&gt;setBuddy(headerTextFormatCombo);

    firstFridayCheckBox = new QCheckBox(tr(&quot;&amp;First Friday in blue&quot;));

    mayFirstCheckBox = new QCheckBox(tr(&quot;May &amp;1 in red&quot;));

</db:programlisting>
<db:para>The <db:guilabel>Header Text Format</db:guilabel> combobox lets the user change the text format (bold, italic, or plain) used for horizontal and vertical headers. The <db:guilabel>First Friday in blue</db:guilabel> and <db:guilabel>May 1 in red</db:guilabel> check box affect the rendering of specific dates.</db:para>
<db:programlisting language="cpp">    connect(weekdayColorCombo, SIGNAL(currentIndexChanged(int)),
            this, SLOT(weekdayFormatChanged()));
    connect(weekdayColorCombo, SIGNAL(currentIndexChanged(int)),
            this, SLOT(reformatCalendarPage()));
    connect(weekendColorCombo, SIGNAL(currentIndexChanged(int)),
            this, SLOT(weekendFormatChanged()));
    connect(weekendColorCombo, SIGNAL(currentIndexChanged(int)),
            this, SLOT(reformatCalendarPage()));
    connect(headerTextFormatCombo, SIGNAL(currentIndexChanged(QString)),
            this, SLOT(reformatHeaders()));
    connect(firstFridayCheckBox, SIGNAL(toggled(bool)),
            this, SLOT(reformatCalendarPage()));
    connect(mayFirstCheckBox, SIGNAL(toggled(bool)),
            this, SLOT(reformatCalendarPage()));

</db:programlisting>
<db:para>We connect the check boxes and comboboxes to various private slots. The <db:guilabel>First Friday in blue</db:guilabel> and <db:guilabel>May 1 in red</db:guilabel> check boxes are both connected to <db:code>reformatCalendarPage()</db:code>, which is also called when the calendar switches month.</db:para>
<db:programlisting language="cpp">    ...
    reformatHeaders();
    reformatCalendarPage();
}
</db:programlisting>
<db:para>At the end of <db:code>createTextFormatsGroupBox()</db:code>, we call private slots to synchronize the QCalendarWidget with the other widgets.</db:para>
<db:para>We're now done reviewing the four <db:code>create...GroupBox()</db:code> functions. Let's now take a look at the other private functions and slots.</db:para>
<db:programlisting language="cpp">QComboBox *Window::createColorComboBox()
{
    QComboBox *comboBox = new QComboBox;
    comboBox-&gt;addItem(tr(&quot;Red&quot;), QColor(Qt::red));
    comboBox-&gt;addItem(tr(&quot;Blue&quot;), QColor(Qt::blue));
    comboBox-&gt;addItem(tr(&quot;Black&quot;), QColor(Qt::black));
    comboBox-&gt;addItem(tr(&quot;Magenta&quot;), QColor(Qt::magenta));
    return comboBox;
}
</db:programlisting>
<db:para>In <db:code>createColorCombo()</db:code>, we create a combobox and populate it with standard colors. The second argument to QComboBox::addItem() is a <db:link xlink:href="qvariant.xml">QVariant</db:link> storing user data (in this case, QColor objects).</db:para>
<db:para>This function was used to set up the <db:guilabel>Weekday Color</db:guilabel> and <db:guilabel>Weekend Color</db:guilabel> comboboxes.</db:para>
<db:programlisting language="cpp">void Window::firstDayChanged(int index)
{
    calendar-&gt;setFirstDayOfWeek(Qt::DayOfWeek(
                                firstDayCombo-&gt;itemData(index).toInt()));
}
</db:programlisting>
<db:para>When the user changes the <db:guilabel>Week starts on</db:guilabel> combobox's value, <db:code>firstDayChanged()</db:code> is invoked with the index of the combobox's new value. We retrieve the custom data item associated with the new current item using <db:link xlink:href="">itemData()</db:link> and cast it to a <db:link xlink:href="qt.xml#DayOfWeek-enum">Qt::DayOfWeek</db:link>.</db:para>
<db:para><db:code>selectionModeChanged()</db:code>, <db:code>horizontalHeaderChanged()</db:code>, and <db:code>verticalHeaderChanged()</db:code> are very similar to <db:code>firstDayChanged()</db:code>, so they are omitted.</db:para>
<db:programlisting language="cpp">void Window::selectedDateChanged()
{
    currentDateEdit-&gt;setDate(calendar-&gt;selectedDate());
}
</db:programlisting>
<db:para>The <db:code>selectedDateChanged()</db:code> updates the <db:guilabel>Current Date</db:guilabel> editor to reflect the current state of the QCalendarWidget.</db:para>
<db:programlisting language="cpp">void Window::minimumDateChanged(const QDate &amp;date)
{
    calendar-&gt;setMinimumDate(date);
    maximumDateEdit-&gt;setDate(calendar-&gt;maximumDate());
}
</db:programlisting>
<db:para>When the user changes the minimum date, we tell the QCalenderWidget. We also update the <db:guilabel>Maximum Date</db:guilabel> editor, because if the new minimum date is later than the current maximum date, QCalendarWidget will automatically adapt its maximum date to avoid a contradicting state.</db:para>
<db:programlisting language="cpp">void Window::maximumDateChanged(const QDate &amp;date)
{
    calendar-&gt;setMaximumDate(date);
    minimumDateEdit-&gt;setDate(calendar-&gt;minimumDate());
}
</db:programlisting>
<db:para><db:code>maximumDateChanged()</db:code> is implemented similarly to <db:code>minimumDateChanged()</db:code>.</db:para>
<db:programlisting language="cpp">void Window::weekdayFormatChanged()
{
    QTextCharFormat format;

    format.setForeground(qvariant_cast&lt;QColor&gt;(
        weekdayColorCombo-&gt;itemData(weekdayColorCombo-&gt;currentIndex())));
    calendar-&gt;setWeekdayTextFormat(Qt::Monday, format);
    calendar-&gt;setWeekdayTextFormat(Qt::Tuesday, format);
    calendar-&gt;setWeekdayTextFormat(Qt::Wednesday, format);
    calendar-&gt;setWeekdayTextFormat(Qt::Thursday, format);
    calendar-&gt;setWeekdayTextFormat(Qt::Friday, format);
}
</db:programlisting>
<db:para>Each combobox item has a QColor object as user data corresponding to the item's text. After fetching the colors from the comboboxes, we set the text format of each day of the week.</db:para>
<db:para>The text format of a column in the calendar is given as a QTextCharFormat, which besides the foreground color lets us specify various character formatting information. In this example, we only show a subset of the possibilities.</db:para>
<db:programlisting language="cpp">void Window::weekendFormatChanged()
{
    QTextCharFormat format;

    format.setForeground(qvariant_cast&lt;QColor&gt;(
        weekendColorCombo-&gt;itemData(weekendColorCombo-&gt;currentIndex())));
    calendar-&gt;setWeekdayTextFormat(Qt::Saturday, format);
    calendar-&gt;setWeekdayTextFormat(Qt::Sunday, format);
}
</db:programlisting>
<db:para><db:code>weekendFormatChanged()</db:code> is the same as <db:code>weekdayFormatChanged()</db:code>, except that it affects Saturday and Sunday instead of Monday to Friday.</db:para>
<db:programlisting language="cpp">void Window::reformatHeaders()
{
    QString text = headerTextFormatCombo-&gt;currentText();
    QTextCharFormat format;

    if (text == tr(&quot;Bold&quot;)) {
        format.setFontWeight(QFont::Bold);
    } else if (text == tr(&quot;Italic&quot;)) {
        format.setFontItalic(true);
    } else if (text == tr(&quot;Green&quot;)) {
        format.setForeground(Qt::green);
    }
    calendar-&gt;setHeaderTextFormat(format);
}
</db:programlisting>
<db:para>The <db:code>reformatHeaders()</db:code> slot is called when the user changes the text format of the headers. We compare the current text of the <db:guilabel>Header Text Format</db:guilabel> combobox to determine which format to apply. (An alternative would have been to store QTextCharFormat values alongside the combobox items.)</db:para>
<db:programlisting language="cpp">void Window::reformatCalendarPage()
{
    QTextCharFormat mayFirstFormat;
    const QDate mayFirst(calendar-&gt;yearShown(), 5, 1);

    QTextCharFormat firstFridayFormat;
    QDate firstFriday(calendar-&gt;yearShown(), calendar-&gt;monthShown(), 1);
    while (firstFriday.dayOfWeek() != Qt::Friday)
        firstFriday = firstFriday.addDays(1);

    if (firstFridayCheckBox-&gt;isChecked()) {
        firstFridayFormat.setForeground(Qt::blue);
    } else { // Revert to regular colour for this day of the week.
        Qt::DayOfWeek dayOfWeek(static_cast&lt;Qt::DayOfWeek&gt;(firstFriday.dayOfWeek()));
        firstFridayFormat.setForeground(calendar-&gt;weekdayTextFormat(dayOfWeek).foreground());
    }

    calendar-&gt;setDateTextFormat(firstFriday, firstFridayFormat);

    // When it is checked, &quot;May First in Red&quot; always takes precedence over &quot;First Friday in Blue&quot;.
    if (mayFirstCheckBox-&gt;isChecked()) {
        mayFirstFormat.setForeground(Qt::red);
    } else if (!firstFridayCheckBox-&gt;isChecked() || firstFriday != mayFirst) {
        // We can now be certain we won't be resetting &quot;May First in Red&quot; when we restore
        // may 1st's regular colour for this day of the week.
        Qt::DayOfWeek dayOfWeek(static_cast&lt;Qt::DayOfWeek&gt;(mayFirst.dayOfWeek()));
        calendar-&gt;setDateTextFormat(mayFirst, calendar-&gt;weekdayTextFormat(dayOfWeek));
    }

    calendar-&gt;setDateTextFormat(mayFirst, mayFirstFormat);
}
</db:programlisting>
<db:para>In <db:code>reformatCalendarPage()</db:code>, we set the text format of the first Friday in the month and May 1 in the current year. The text formats that are actually used depend on which check boxes are checked and what the weekday/weekend formats are.</db:para>
<db:para>QCalendarWidget lets us set the text format of individual dates with the <db:link xlink:href="">setDateTextFormat()</db:link>. We chose to set the date formats when the calendar page changes - i.e. a new month is displayed - and when the weekday/weekend format is changed. We check which of the <db:code>mayFirstCheckBox</db:code> and <db:code>firstDayCheckBox</db:code>, if any, are checked and set the text formats accordingly.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="widgets/calendarwidget/calendarwidget.pro">widgets/calendarwidget/calendarwidget.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/calendarwidget/main.cpp">widgets/calendarwidget/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/calendarwidget/window.cpp">widgets/calendarwidget/window.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="widgets/calendarwidget/window.h">widgets/calendarwidget/window.h</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
