<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>Qt 3D: Multi Viewport QML Example</db:title>
<db:productname>Qt3D</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt 3D Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>A QML example that demonstrates rendering a Scenegraph from multiple viewports.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:mediaobject>
<db:imageobject>
<db:imagedata fileref="images/multiviewport-qml-example.png"/>
</db:imageobject>
</db:mediaobject>
<db:para><db:emphasis>Multi Viewport</db:emphasis> renders a Scenegraph from the point of view of four virtual cameras into the four quadrants of a window. This is a common configuration for 3D CAD or modelling tools or could be adjusted to help with rendering a rear-view mirror in a car racing game or a CCTV camera display.</db:para>
<db:para>For more information, see <db:link xlink:href="qt3drender-framegraph.xml#a-multi-viewport-framegraph">A Multi Viewport FrameGraph</db:link>.</db:para>
<db:section xml:id="running-the-example">
<db:title>Running the Example</db:title>
<db:para>To run the example from <db:link xlink:href="http://doc.qt.io/qtcreator/index.html">Qt Creator</db:link>, open the <db:emphasis role="bold">Welcome</db:emphasis> mode and select the example from <db:emphasis role="bold">Examples</db:emphasis>. For more information, visit <db:link xlink:href="http://doc.qt.io/qtcreator/creator-build-example-application.html">Building and Running an Example</db:link>.</db:para>
</db:section>
<db:section xml:id="creating-multiple-renderviews">
<db:title>Creating Multiple RenderViews</db:title>
<db:para>Using the rules defined in <db:link xlink:href="qt3drender-framegraph.xml#framegraph-rules">Framegraph Rules</db:link>, we construct five RenderView objects from the FrameGraph:</db:para>
<db:programlisting language="cpp">        Viewport {
            id: mainViewport
            normalizedRect: Qt.rect(0, 0, 1, 1)

            ClearBuffers {
                buffers: ClearBuffers.ColorDepthBuffer
            }

            Viewport {
                id: topLeftViewport
                normalizedRect: Qt.rect(0, 0, 0.5, 0.5)
                CameraSelector { id: cameraSelectorTopLeftViewport }
            }

            Viewport {
                id: topRightViewport
                normalizedRect: Qt.rect(0.5, 0, 0.5, 0.5)
                CameraSelector { id: cameraSelectorTopRightViewport }
            }

            Viewport {
                id: bottomLeftViewport
                normalizedRect: Qt.rect(0, 0.5, 0.5, 0.5)
                CameraSelector { id: cameraSelectorBottomLeftViewport }
            }

            Viewport {
                id: bottomRightViewport
                normalizedRect: Qt.rect(0.5, 0.5, 0.5, 0.5)
                CameraSelector { id: cameraSelectorBottomRightViewport }
            }
        }
    }
}

</db:programlisting>
<db:para>The <db:emphasis>order is important</db:emphasis>. If the <db:link xlink:href="qml-qt3d-render-clearbuffers.xml">ClearBuffers</db:link> node were to be the last instead of the first, this would result in a black screen for the simple reason that everything would be cleared right after having been so carefully rendered. For a similar reason, it could not be used as the root of the FrameGraph as that would result in a call to clear the whole screen for each of our viewports.</db:para>
<db:para>Although the declaration order of the FrameGraph is important, Qt 3D is able to process each RenderView in parallel as each RenderView is independent of the others for the purposes of generating a set of RenderCommands to be submitted whilst the RenderView's state is in effect.</db:para>
<db:para>Qt 3D uses a task-based approach to parallelism which naturally scales up with the number of available cores. The RenderCommands for the RenderViews can be generated in parallel across many cores, and as long as we take care to submit the RenderViews in the correct order on the dedicated OpenGL submission thread, the resulting scene will be rendered correctly.</db:para>
</db:section>
<db:section>
<db:title>List of Files</db:title>
<db:para>Files:</db:para>
<db:section>
<db:title>List of Files</db:title>
<db:itemizedlist>
<db:listitem>
<db:para><db:link xlink:href="multiviewport/QuadViewportFrameGraph.qml">multiviewport/QuadViewportFrameGraph.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="multiviewport/SimpleCamera.qml">multiviewport/SimpleCamera.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="multiviewport/main.cpp">multiviewport/main.cpp</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="multiviewport/main.qml">multiviewport/main.qml</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="multiviewport/multiviewport.pro">multiviewport/multiviewport.pro</db:link></db:para></db:listitem>
<db:listitem>
<db:para><db:link xlink:href="multiviewport/multiviewport.qrc">multiviewport/multiviewport.qrc</db:link></db:para></db:listitem>
</db:itemizedlist>
</db:section>
</db:section></db:article>
