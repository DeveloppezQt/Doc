<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>QBarDataProxy Class</db:title>
<db:productname>QtGraphs</db:productname>
<db:edition>Qt Graphs | Commercial or GPLv3</db:edition>
<db:titleabbrev>Qt Graphs Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>The <db:link xlink:href="qbardataproxy.xml">QBarDataProxy</db:link> class is the data proxy for a 3D bars graph.</db:para>
</db:abstract>
<db:pubdate>2024-12-27</db:pubdate>
<db:date>2024-12-27</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:variablelist>
<db:varlistentry>
<db:term>Header</db:term>
<db:listitem>
<db:para>QBarDataProxy</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>CMake</db:term>
<db:listitem>
<db:para>find_package(Qt6 REQUIRED COMPONENTS Graphs)</db:para>
<db:para>target_link_libraries(mytarget PRIVATE Qt6::Graphs)</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>qmake</db:term>
<db:listitem>
<db:para>QT += graphs</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qitemmodelbardataproxy.xml" xlink:role="class">QItemModelBarDataProxy</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Instantiated By</db:term>
<db:listitem>
<db:para>qml-qtgraphs-bardataproxy.xml</db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherits</db:term>
<db:listitem>
<db:para><db:link xlink:href="qabstractdataproxy.xml" xlink:role="class">QAbstractDataProxy</db:link></db:para>
</db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Inherited By</db:term>
<db:listitem>
<db:para><db:link xlink:href="qitemmodelbardataproxy.xml" xlink:role="class">QItemModelBarDataProxy</db:link></db:para>
</db:listitem>
</db:varlistentry>
</db:variablelist>
<db:section xml:id="details">
<db:title>Detailed Description</db:title>
<db:para>A bar data proxy handles adding, inserting, changing, and removing rows of data.</db:para>
<db:para>The data array is a list of vectors (rows) of <db:link xlink:href="qbardataitem.xml">QBarDataItem</db:link> instances. Each row can contain a different number of items or even be null.</db:para>
<db:para><db:link xlink:href="qbardataproxy.xml">QBarDataProxy</db:link> takes ownership of all QtGraphs::QBarDataRow objects passed to it, whether directly or in a QtGraphs::QBarDataArray container. If bar data row pointers are used to directly modify data after adding the array to the proxy, the appropriate signal must be emitted to update the graph.</db:para>
<db:para><db:link xlink:href="qbardataproxy.xml">QBarDataProxy</db:link> optionally keeps track of row and column labels, which <db:link xlink:href="qcategory3daxis.xml">QCategory3DAxis</db:link> can utilize to show axis labels. The row and column labels are stored in a separate array from the data and row manipulation methods provide alternate versions that do not affect the row labels. This enables the option of having row labels that relate to the position of the data in the array rather than the data itself.</db:para>
<db:section>
<db:title>See Also</db:title>
<db:para><db:emphasis>See also </db:emphasis>
<db:simplelist type="vert" role="see-also">
<db:member><db:link xlink:href="qtgraphs-data-handling.xml">Qt Graphs Data Handling</db:link></db:member>
</db:simplelist>
</db:para>
</db:section>
</db:section>
<db:section xml:id="property-documentation">
<db:title>Property Documentation</db:title>
<db:section xml:id="colCount-prop">
<db:title>[read-only] colCount : const int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>colCount</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">colCount</db:synopsisinfo>
<db:synopsisinfo role="notifier">colCountChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the number of columns in the array.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">colCount</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">colCountChanged</db:emphasis>(<db:type>int</db:type> <db:emphasis>count</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="columnLabels-prop">
<db:title>columnLabels : QStringList</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QStringList</db:type>
<db:varname>columnLabels</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">columnLabels</db:synopsisinfo>
<db:synopsisinfo role="setter">setColumnLabels</db:synopsisinfo>
<db:synopsisinfo role="notifier">columnLabelsChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the optional column labels for the array.</db:para>
<db:para>Indexes in this array match column indexes in rows. If the list is shorter than the longest row, all columns will not get labels.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstringlist.xml">QStringList</db:link></db:type> <db:emphasis role="bold">columnLabels</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setColumnLabels</db:emphasis>(const <db:type><db:link xlink:href="qstringlist.xml">QStringList</db:link></db:type> &amp;<db:emphasis>labels</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">columnLabelsChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="rowCount-prop">
<db:title>[read-only] rowCount : const int</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>int</db:type>
<db:varname>rowCount</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">rowCount</db:synopsisinfo>
<db:synopsisinfo role="notifier">rowCountChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the number of rows in the array.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>int</db:type> <db:emphasis role="bold">rowCount</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">rowCountChanged</db:emphasis>(<db:type>int</db:type> <db:emphasis>count</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="rowLabels-prop">
<db:title>rowLabels : QStringList</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QStringList</db:type>
<db:varname>rowLabels</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">rowLabels</db:synopsisinfo>
<db:synopsisinfo role="setter">setRowLabels</db:synopsisinfo>
<db:synopsisinfo role="notifier">rowLabelsChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the optional row labels for the array.</db:para>
<db:para>Indexes in this array match the row indexes in the data array. If the list is shorter than the number of rows, all rows will not get labels.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qstringlist.xml">QStringList</db:link></db:type> <db:emphasis role="bold">rowLabels</db:emphasis>() const</db:para>
</db:listitem>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">setRowLabels</db:emphasis>(const <db:type><db:link xlink:href="qstringlist.xml">QStringList</db:link></db:type> &amp;<db:emphasis>labels</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">rowLabelsChanged</db:emphasis>()</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section xml:id="series-prop">
<db:title>[read-only] series : QBar3DSeries* const</db:title>
<db:fieldsynopsis>
<db:modifier>(Qt property)</db:modifier>
<db:type>QBar3DSeries*</db:type>
<db:varname>series</db:varname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
<db:synopsisinfo role="getter">series</db:synopsisinfo>
<db:synopsisinfo role="notifier">seriesChanged</db:synopsisinfo>
</db:fieldsynopsis>
<db:para>This property holds the series this proxy is attached to.</db:para>
<db:para>
<db:emphasis role="bold">Access functions:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type><db:link xlink:href="qbar3dseries.xml">QBar3DSeries</db:link></db:type> *<db:emphasis role="bold">series</db:emphasis>() const</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>
<db:emphasis role="bold">Notifier signal:
</db:emphasis>
</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:type>void</db:type> <db:emphasis role="bold">seriesChanged</db:emphasis>(<db:type><db:link xlink:href="qbar3dseries.xml">QBar3DSeries</db:link></db:type> *<db:emphasis>series</db:emphasis>)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:section>
<db:section xml:id="member-function-documentation">
<db:title>Member Function Documentation</db:title>
<db:section xml:id="QBarDataProxy">
<db:title>[explicit] QBarDataProxy::QBarDataProxy(QObject *<db:emphasis>parent</db:emphasis> = nullptr)</db:title>
<db:constructorsynopsis>
<db:methodname>QBarDataProxy</db:methodname>
<db:methodparam>
<db:type>QObject *</db:type>
<db:parameter>parent</db:parameter>
<db:initializer>nullptr</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">constructor</db:synopsisinfo>
<db:synopsisinfo role="signature">QBarDataProxy(QObject *parent)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:constructorsynopsis>
<db:para>Constructs a bar data proxy with the given <db:code role="parameter">parent</db:code>.</db:para>
</db:section>
<db:section xml:id="dtor.QBarDataProxy">
<db:title>[virtual] QBarDataProxy::~QBarDataProxy()</db:title>
<db:destructorsynopsis>
<db:modifier>virtual</db:modifier>
<db:methodname>~QBarDataProxy</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">destructor</db:synopsisinfo>
<db:synopsisinfo role="signature">~QBarDataProxy()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:destructorsynopsis>
<db:para>Deletes the bar data proxy.</db:para>
</db:section>
<db:section xml:id="addRow">
<db:title>int QBarDataProxy::addRow(QBarDataRow *<db:emphasis>row</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>addRow</db:methodname>
<db:methodparam>
<db:type>QBarDataRow *</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int addRow(QBarDataRow *row)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds the new row <db:code role="parameter">row</db:code> to the end of an array. Existing row labels are not affected.</db:para>
<db:para>Returns the index of the added row.</db:para>
</db:section>
<db:section xml:id="addRow-1">
<db:title>int QBarDataProxy::addRow(QBarDataRow *<db:emphasis>row</db:emphasis>, const QString &amp;<db:emphasis>label</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>addRow</db:methodname>
<db:methodparam>
<db:type>QBarDataRow *</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>label</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int addRow(QBarDataRow *row, const QString &amp;label)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds a the new row <db:code role="parameter">row</db:code> with the label <db:code role="parameter">label</db:code> to the end of an array.</db:para>
<db:para>Returns the index of the added row.</db:para>
</db:section>
<db:section xml:id="addRows">
<db:title>int QBarDataProxy::addRows(const QBarDataArray &amp;<db:emphasis>rows</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>addRows</db:methodname>
<db:methodparam>
<db:type>const QBarDataArray &amp;</db:type>
<db:parameter>rows</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">int addRows(const QBarDataArray &amp;rows)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds the new <db:code role="parameter">rows</db:code> to the end of an array. Existing row labels are not affected.</db:para>
<db:para>Returns the index of the first added row.</db:para>
</db:section>
<db:section xml:id="addRows-1">
<db:title>int QBarDataProxy::addRows(const QBarDataArray &amp;<db:emphasis>rows</db:emphasis>, const QStringList &amp;<db:emphasis>labels</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:type>int</db:type>
<db:methodname>addRows</db:methodname>
<db:methodparam>
<db:type>const QBarDataArray &amp;</db:type>
<db:parameter>rows</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>labels</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">int addRows(const QBarDataArray &amp;rows, const QStringList &amp;labels)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Adds the new <db:code role="parameter">rows</db:code> with <db:code role="parameter">labels</db:code> to the end of the array.</db:para>
<db:para>Returns the index of the first added row.</db:para>
</db:section>
<db:section xml:id="array">
<db:title>const QBarDataArray *QBarDataProxy::array() const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QBarDataArray *</db:type>
<db:methodname>array</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QBarDataArray * array() const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the pointer to the data array.</db:para>
</db:section>
<db:section xml:id="arrayReset">
<db:title>void QBarDataProxy::arrayReset()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>arrayReset</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void arrayReset()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the data array is reset. If the contents of the whole array are changed without calling <db:link xlink:href="qbardataproxy.xml#resetArray">resetArray</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="insertRow">
<db:title>void QBarDataProxy::insertRow(int <db:emphasis>rowIndex</db:emphasis>, QBarDataRow *<db:emphasis>row</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>insertRow</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QBarDataRow *</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void insertRow(int rowIndex, QBarDataRow *row)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts the new row <db:code role="parameter">row</db:code> into <db:code role="parameter">rowIndex</db:code>. If <db:code role="parameter">rowIndex</db:code> is equal to the array size, the rows are added to the end of the array. The existing row labels are not affected.</db:para>
<db:note>
<db:para>The row labels array will be out of sync with the row array after this call if there were labeled rows beyond the inserted row.</db:para>
</db:note>
</db:section>
<db:section xml:id="insertRow-1">
<db:title>void QBarDataProxy::insertRow(int <db:emphasis>rowIndex</db:emphasis>, QBarDataRow *<db:emphasis>row</db:emphasis>, const QString &amp;<db:emphasis>label</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>insertRow</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QBarDataRow *</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>label</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void insertRow(int rowIndex, QBarDataRow *row, const QString &amp;label)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts the new row <db:code role="parameter">row</db:code> with the label <db:code role="parameter">label</db:code> into <db:code role="parameter">rowIndex</db:code>. If <db:code role="parameter">rowIndex</db:code> is equal to array size, rows are added to the end of the array.</db:para>
</db:section>
<db:section xml:id="insertRows">
<db:title>void QBarDataProxy::insertRows(int <db:emphasis>rowIndex</db:emphasis>, const QBarDataArray &amp;<db:emphasis>rows</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>insertRows</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QBarDataArray &amp;</db:type>
<db:parameter>rows</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void insertRows(int rowIndex, const QBarDataArray &amp;rows)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts new <db:code role="parameter">rows</db:code> into <db:code role="parameter">rowIndex</db:code>. If <db:code role="parameter">rowIndex</db:code> is equal to the array size, the rows are added to the end of the array. The existing row labels are not affected.</db:para>
<db:note>
<db:para>The row labels array will be out of sync with the row array after this call if there were labeled rows beyond the inserted rows.</db:para>
</db:note>
</db:section>
<db:section xml:id="insertRows-1">
<db:title>void QBarDataProxy::insertRows(int <db:emphasis>rowIndex</db:emphasis>, const QBarDataArray &amp;<db:emphasis>rows</db:emphasis>, const QStringList &amp;<db:emphasis>labels</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>insertRows</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QBarDataArray &amp;</db:type>
<db:parameter>rows</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>labels</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void insertRows(int rowIndex, const QBarDataArray &amp;rows, const QStringList &amp;labels)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Inserts new <db:code role="parameter">rows</db:code> with <db:code role="parameter">labels</db:code> into <db:code role="parameter">rowIndex</db:code>. If <db:code role="parameter">rowIndex</db:code> is equal to the array size, the rows are added to the end of the array.</db:para>
</db:section>
<db:section xml:id="itemAt">
<db:title>const QBarDataItem *QBarDataProxy::itemAt(int <db:emphasis>rowIndex</db:emphasis>, int <db:emphasis>columnIndex</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QBarDataItem *</db:type>
<db:methodname>itemAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>columnIndex</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QBarDataItem * itemAt(int rowIndex, int columnIndex) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the pointer to the item at the position specified by <db:code role="parameter">rowIndex</db:code> and <db:code role="parameter">columnIndex</db:code>. It is guaranteed to be valid only until the next call that modifies data.</db:para>
</db:section>
<db:section xml:id="itemAt-1">
<db:title>const QBarDataItem *QBarDataProxy::itemAt(const QPoint &amp;<db:emphasis>position</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QBarDataItem *</db:type>
<db:methodname>itemAt</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>position</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">const QBarDataItem * itemAt(const QPoint &amp;position) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the pointer to the item at the position <db:code role="parameter">position</db:code>. The x-value of <db:code role="parameter">position</db:code> indicates the row and the y-value indicates the column. The item is guaranteed to be valid only until the next call that modifies data.</db:para>
</db:section>
<db:section xml:id="itemChanged">
<db:title>void QBarDataProxy::itemChanged(int <db:emphasis>rowIndex</db:emphasis>, int <db:emphasis>columnIndex</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>itemChanged</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>columnIndex</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void itemChanged(int rowIndex, int columnIndex)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the item at the position specified by <db:code role="parameter">rowIndex</db:code> and <db:code role="parameter">columnIndex</db:code> changes. If the item is changed in the array without calling <db:link xlink:href="qbardataproxy.xml#setItem">setItem</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="removeRows">
<db:title>void QBarDataProxy::removeRows(int <db:emphasis>rowIndex</db:emphasis>, int <db:emphasis>removeCount</db:emphasis>, bool <db:emphasis>removeLabels</db:emphasis> = true)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>removeRows</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>removeCount</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>bool</db:type>
<db:parameter>removeLabels</db:parameter>
<db:initializer>true</db:initializer>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void removeRows(int rowIndex, int removeCount, bool removeLabels)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Removes the number of rows specified by <db:code role="parameter">removeCount</db:code> starting at the position <db:code role="parameter">rowIndex</db:code>. Attempting to remove rows past the end of the array does nothing. If <db:code role="parameter">removeLabels</db:code> is <db:code>true</db:code>, the corresponding row labels are also removed. Otherwise, the row labels are not affected.</db:para>
<db:note>
<db:para>If <db:code role="parameter">removeLabels</db:code> is <db:code>false</db:code>, the row labels array will be out of sync with the row array if there are labeled rows beyond the removed rows.</db:para>
</db:note>
</db:section>
<db:section xml:id="resetArray">
<db:title>void QBarDataProxy::resetArray()</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resetArray</db:methodname>
<db:void/>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void resetArray()</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Clears the existing array and row and column labels.</db:para>
</db:section>
<db:section xml:id="resetArray-1">
<db:title>void QBarDataProxy::resetArray(QBarDataArray *<db:emphasis>newArray</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resetArray</db:methodname>
<db:methodparam>
<db:type>QBarDataArray *</db:type>
<db:parameter>newArray</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void resetArray(QBarDataArray *newArray)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Takes ownership of the array <db:code role="parameter">newArray</db:code>. Clears the existing array if the new array differs from it. If the arrays are the same, this function just triggers the <db:link xlink:href="qbardataproxy.xml#arrayReset">arrayReset</db:link>() signal.</db:para>
<db:para>Passing a null array deletes the old array and creates a new empty array. Row and column labels are not affected.</db:para>
</db:section>
<db:section xml:id="resetArray-2">
<db:title>void QBarDataProxy::resetArray(QBarDataArray *<db:emphasis>newArray</db:emphasis>, const QStringList &amp;<db:emphasis>rowLabels</db:emphasis>, const QStringList &amp;<db:emphasis>columnLabels</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>resetArray</db:methodname>
<db:methodparam>
<db:type>QBarDataArray *</db:type>
<db:parameter>newArray</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>rowLabels</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>columnLabels</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">2</db:synopsisinfo>
<db:synopsisinfo role="signature">void resetArray(QBarDataArray *newArray, const QStringList &amp;rowLabels, const QStringList &amp;columnLabels)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Takes ownership of the array <db:code role="parameter">newArray</db:code>. Clears the existing array if the new array differs from it. If the arrays are the same, this function just triggers the <db:link xlink:href="qbardataproxy.xml#arrayReset">arrayReset</db:link>() signal.</db:para>
<db:para>Passing a null array deletes the old array and creates a new empty array.</db:para>
<db:para>The <db:code role="parameter">rowLabels</db:code> and <db:code role="parameter">columnLabels</db:code> lists specify the new labels for rows and columns.</db:para>
</db:section>
<db:section xml:id="rowAt">
<db:title>const QBarDataRow *QBarDataProxy::rowAt(int <db:emphasis>rowIndex</db:emphasis>) const</db:title>
<db:methodsynopsis>
<db:modifier>const</db:modifier>
<db:type>const QBarDataRow *</db:type>
<db:methodname>rowAt</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">const QBarDataRow * rowAt(int rowIndex) const</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Returns the pointer to the row at the position <db:code role="parameter">rowIndex</db:code>. It is guaranteed to be valid only until the next call that modifies data.</db:para>
</db:section>
<db:section xml:id="rowsAdded">
<db:title>void QBarDataProxy::rowsAdded(int <db:emphasis>startIndex</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>rowsAdded</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>startIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void rowsAdded(int startIndex, int count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the number of rows specified by <db:code role="parameter">count</db:code> is added starting at the position <db:code role="parameter">startIndex</db:code>. If rows are added to the array without calling <db:link xlink:href="qbardataproxy.xml#addRow">addRow</db:link>() or <db:link xlink:href="qbardataproxy.xml#addRows">addRows</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="rowsChanged">
<db:title>void QBarDataProxy::rowsChanged(int <db:emphasis>startIndex</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>rowsChanged</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>startIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void rowsChanged(int startIndex, int count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the number of rows specified by <db:code role="parameter">count</db:code> is changed starting at the position <db:code role="parameter">startIndex</db:code>. If rows are changed in the array without calling <db:link xlink:href="qbardataproxy.xml#setRow">setRow</db:link>() or <db:link xlink:href="qbardataproxy.xml#setRows">setRows</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="rowsInserted">
<db:title>void QBarDataProxy::rowsInserted(int <db:emphasis>startIndex</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>rowsInserted</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>startIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void rowsInserted(int startIndex, int count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the number of rows specified by <db:code role="parameter">count</db:code> is inserted at the position <db:code role="parameter">startIndex</db:code>.</db:para>
<db:para>If rows are inserted into the array without calling <db:link xlink:href="qbardataproxy.xml#insertRow">insertRow</db:link>() or <db:link xlink:href="qbardataproxy.xml#insertRows">insertRows</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="rowsRemoved">
<db:title>void QBarDataProxy::rowsRemoved(int <db:emphasis>startIndex</db:emphasis>, int <db:emphasis>count</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>rowsRemoved</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>startIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>count</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void rowsRemoved(int startIndex, int count)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>This signal is emitted when the number of rows specified by <db:code role="parameter">count</db:code> is removed starting at the position <db:code role="parameter">startIndex</db:code>.</db:para>
<db:para>The index is the current array size if the rows were removed from the end of the array. If rows are removed from the array without calling <db:link xlink:href="qbardataproxy.xml#removeRows">removeRows</db:link>(), this signal needs to be emitted to update the graph.</db:para>
</db:section>
<db:section xml:id="setItem">
<db:title>void QBarDataProxy::setItem(int <db:emphasis>rowIndex</db:emphasis>, int <db:emphasis>columnIndex</db:emphasis>, const QBarDataItem &amp;<db:emphasis>item</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setItem</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>columnIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QBarDataItem &amp;</db:type>
<db:parameter>item</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setItem(int rowIndex, int columnIndex, const QBarDataItem &amp;item)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Changes a single item at the position specified by <db:code role="parameter">rowIndex</db:code> and <db:code role="parameter">columnIndex</db:code> to the item <db:code role="parameter">item</db:code>.</db:para>
</db:section>
<db:section xml:id="setItem-1">
<db:title>void QBarDataProxy::setItem(const QPoint &amp;<db:emphasis>position</db:emphasis>, const QBarDataItem &amp;<db:emphasis>item</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setItem</db:methodname>
<db:methodparam>
<db:type>const QPoint &amp;</db:type>
<db:parameter>position</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QBarDataItem &amp;</db:type>
<db:parameter>item</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setItem(const QPoint &amp;position, const QBarDataItem &amp;item)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Changes a single item at the position <db:code role="parameter">position</db:code> to the item <db:code role="parameter">item</db:code>. The x-value of <db:code role="parameter">position</db:code> indicates the row and the y-value indicates the column.</db:para>
</db:section>
<db:section xml:id="setRow">
<db:title>void QBarDataProxy::setRow(int <db:emphasis>rowIndex</db:emphasis>, QBarDataRow *<db:emphasis>row</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setRow</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QBarDataRow *</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setRow(int rowIndex, QBarDataRow *row)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Changes an existing row by replacing the row at the position <db:code role="parameter">rowIndex</db:code> with the new row specified by <db:code role="parameter">row</db:code>. The new row can be the same as the existing row already stored at <db:code role="parameter">rowIndex</db:code>. Existing row labels are not affected.</db:para>
</db:section>
<db:section xml:id="setRow-1">
<db:title>void QBarDataProxy::setRow(int <db:emphasis>rowIndex</db:emphasis>, QBarDataRow *<db:emphasis>row</db:emphasis>, const QString &amp;<db:emphasis>label</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setRow</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>QBarDataRow *</db:type>
<db:parameter>row</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QString &amp;</db:type>
<db:parameter>label</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setRow(int rowIndex, QBarDataRow *row, const QString &amp;label)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Changes an existing row by replacing the row at the position <db:code role="parameter">rowIndex</db:code> with the new row specified by <db:code role="parameter">row</db:code>. The new row can be the same as the existing row already stored at <db:code role="parameter">rowIndex</db:code>. Changes the row label to <db:code role="parameter">label</db:code>.</db:para>
</db:section>
<db:section xml:id="setRows">
<db:title>void QBarDataProxy::setRows(int <db:emphasis>rowIndex</db:emphasis>, const QBarDataArray &amp;<db:emphasis>rows</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setRows</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QBarDataArray &amp;</db:type>
<db:parameter>rows</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="signature">void setRows(int rowIndex, const QBarDataArray &amp;rows)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Changes existing rows by replacing the rows starting at the position <db:code role="parameter">rowIndex</db:code> with the new rows specifies by <db:code role="parameter">rows</db:code>. Existing row labels are not affected. The rows in the <db:code role="parameter">rows</db:code> array can be the same as the existing rows already stored at <db:code role="parameter">rowIndex</db:code>.</db:para>
</db:section>
<db:section xml:id="setRows-1">
<db:title>void QBarDataProxy::setRows(int <db:emphasis>rowIndex</db:emphasis>, const QBarDataArray &amp;<db:emphasis>rows</db:emphasis>, const QStringList &amp;<db:emphasis>labels</db:emphasis>)</db:title>
<db:methodsynopsis>
<db:void/>
<db:methodname>setRows</db:methodname>
<db:methodparam>
<db:type>int</db:type>
<db:parameter>rowIndex</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QBarDataArray &amp;</db:type>
<db:parameter>rows</db:parameter>
</db:methodparam>
<db:methodparam>
<db:type>const QStringList &amp;</db:type>
<db:parameter>labels</db:parameter>
</db:methodparam>
<db:synopsisinfo role="meta">plain</db:synopsisinfo>
<db:synopsisinfo role="overload">overload</db:synopsisinfo>
<db:synopsisinfo role="overload-number">1</db:synopsisinfo>
<db:synopsisinfo role="signature">void setRows(int rowIndex, const QBarDataArray &amp;rows, const QStringList &amp;labels)</db:synopsisinfo>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:methodsynopsis>
<db:para>Changes existing rows by replacing the rows starting at the position <db:code role="parameter">rowIndex</db:code> with the new rows specifies by <db:code role="parameter">rows</db:code>. The row labels are changed to <db:code role="parameter">labels</db:code>. The rows in the <db:code role="parameter">rows</db:code> array can be the same as the existing rows already stored at <db:code role="parameter">rowIndex</db:code>.</db:para>
</db:section>
</db:section>
<db:section xml:id="related-non-members">
<db:title>Related Non-Members</db:title>
<db:section xml:id="QBarDataArray-typedef">
<db:title>[alias] QBarDataArray</db:title>
<db:typedefsynopsis>
<db:typedefname>QBarDataArray</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>A list of pointers to <db:link xlink:href="qbardataproxy.xml#QBarDataRow-typedef">QBarDataRow</db:link> objects.</db:para>
</db:section>
<db:section xml:id="QBarDataRow-typedef">
<db:title>[alias] QBarDataRow</db:title>
<db:typedefsynopsis>
<db:typedefname>QBarDataRow</db:typedefname>
<db:synopsisinfo role="access">public</db:synopsisinfo>
<db:synopsisinfo role="status">active</db:synopsisinfo>
<db:synopsisinfo role="threadsafeness">unspecified</db:synopsisinfo>
</db:typedefsynopsis>
<db:para>A list of <db:link xlink:href="qbardataitem.xml">QBarDataItem</db:link> objects.</db:para>
</db:section>
</db:section>
</db:article>
