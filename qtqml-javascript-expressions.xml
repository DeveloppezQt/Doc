<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.2" xml:lang="en">
<db:info>
<db:title>JavaScript Expressions in QML Documents</db:title>
<db:productname>QtQml</db:productname>
<db:edition>Qt 5.7.1 Reference Documentation</db:edition>
<db:titleabbrev>Qt QML Reference Documentation</db:titleabbrev>
<db:abstract>
<db:para>Description of where JavaScript expressions are valid in QML documents.</db:para>
</db:abstract>
<db:pubdate>2025-06-29</db:pubdate>
<db:date>2025-06-29</db:date>
<db:authorgroup>
<db:author>
<db:orgname class="corporation">The Qt Company Ltd.</db:orgname>
</db:author>
</db:authorgroup>
</db:info>
<db:para>The <db:link xlink:href="qtqml-javascript-hostenvironment.xml">JavaScript Host Environment</db:link> provided by QML can run valid standard JavaScript constructs such as conditional operators, arrays, variable setting, loops. In addition to the standard JavaScript properties, the <db:link xlink:href="qtqml-javascript-qmlglobalobject.xml">QML Global Object</db:link> includes a number of helper methods that simplify building UIs and interacting with the QML environment.</db:para>
<db:para>The JavaScript environment provided by QML is stricter than that in a web browser. For example, in QML you cannot add to, or modify, members of the JavaScript global object. In regular JavaScript, it is possible to do this accidentally by using a variable without declaring it. In QML this will throw an exception, so all local variables must be explicitly declared. See <db:link xlink:href="qtqml-javascript-hostenvironment.xml#javascript-environment-restrictions">JavaScript Environment Restrictions</db:link> for a complete description of the restrictions on JavaScript code executed from QML.</db:para>
<db:para>Various parts of <db:link xlink:href="qtqml-documents-topic.xml">QML documents</db:link> can contain JavaScript code:</db:para>
<db:orderedlist numeration="arabic">
<db:listitem>
<db:para>The body of <db:link xlink:href="qtqml-syntax-propertybinding.xml">property bindings</db:link>. These JavaScript expressions describe relationships between QML object <db:link xlink:href="qtqml-syntax-objectattributes.xml#property-attributes">properties</db:link>. When any of a property's <db:emphasis>dependencies</db:emphasis> change, the property is automatically updated too, according to the specified relationship.</db:para>
</db:listitem>
<db:listitem>
<db:para>The body of <db:link xlink:href="qtqml-syntax-objectattributes.xml#signal-attributes">Signal handlers</db:link>. These JavaScript statements are automatically evaluated whenever a QML object emits the associated signal.</db:para>
</db:listitem>
<db:listitem>
<db:para>The definition of <db:link xlink:href="qtqml-syntax-objectattributes.xml#method-attributes">custom methods</db:link>. JavaScript functions that are defined within the body of a QML object become methods of that object.</db:para>
</db:listitem>
<db:listitem>
<db:para>Standalone <db:link xlink:href="qtqml-javascript-imports.xml">JavaScript resource (.js) files</db:link>. These files are actually separate from QML documents, but they can be imported into QML documents. Functions and variables that are defined within the imported files can be used in property bindings, signal handlers, and custom methods.</db:para>
</db:listitem>
</db:orderedlist>
<db:section xml:id="javascript-in-property-bindings">
<db:title>JavaScript in Property Bindings</db:title>
<db:para>In the following example, the <db:link xlink:href="qml-qtquick-rectangle.xml">Rectangle</db:link>'s <db:code>color</db:code> depends on the <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link>'s <db:code>pressed</db:code> property. This relationship is described using a conditional expression:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Rectangle {
    id: colorbutton
    width: 200; height: 80;

    color: mousearea.pressed ? &quot;steelblue&quot; : &quot;lightsteelblue&quot;

    MouseArea {
        id: mousearea
        anchors.fill: parent
    }
}
</db:programlisting>
<db:para>In fact, any JavaScript expression (no matter how complex) may be used in a property binding definition, as long as the result of the expression is a value whose type can be assigned to the property. This includes side effects. However, complex bindings and side effects are discouraged because they can reduce the performance, readability, and maintainability of the code.</db:para>
<db:para>There are two ways to define a property binding: the first (and most common) is, as previously shown, in a <db:link xlink:href="qtqml-syntax-objectattributes.xml#value-assignment-on-initialization">property initialization</db:link>. The second (and much rarer) way is to assign the property a function returned from the <db:link xlink:href="qml-qtqml-qt.xml#binding-method">Qt.binding</db:link>() function, from within imperative JavaScript code, as shown below:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Rectangle {
    id: colorbutton
    width: 200; height: 80;

    color: &quot;red&quot;

    MouseArea {
        id: mousearea
        anchors.fill: parent
    }

    Component.onCompleted: {
        color = Qt.binding(function() { return mousearea.pressed ? &quot;steelblue&quot; : &quot;lightsteelblue&quot; });
    }
}
</db:programlisting>
<db:para>See the <db:link xlink:href="qtqml-syntax-propertybinding.xml">property bindings</db:link> documentation for more information about how to define property bindings, and see the documentation about <db:link xlink:href="qtqml-syntax-propertybinding.xml#creating-property-bindings-from-javascript">Property Assignment versus Property Binding</db:link> for information about how bindings differ from value assignments.</db:para>
</db:section>
<db:section xml:id="javascript-in-signal-handlers">
<db:title>JavaScript in Signal Handlers</db:title>
<db:para>QML object types can emit signals in reaction to certain events occurring. Those signals can be handled by signal handler functions, which can be defined by clients to implement custom program logic.</db:para>
<db:para>Suppose that a button represented by a Rectangle type has a <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> and a Text label. The <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> will emit its <db:link xlink:href="qml-qtquick-mousearea.xml#pressed-signal">pressed</db:link> signal when the user presses the defined interactive area, which will automatically trigger the <db:code>onPressed</db:code> handler, which can be defined by clients. The QML engine will execute the JavaScript expressions defined in the <db:code>onPressed</db:code> and <db:code>onReleased</db:code> handlers, as required. Typically, a signal handler is bound to JavaScript expressions to initiate other events or to simply assign property values.</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Rectangle {
    id: button
    width: 200; height: 80; color: &quot;lightsteelblue&quot;

    MouseArea {
        id: mousearea
        anchors.fill: parent

        onPressed: {
            // arbitrary JavaScript expression
            label.text = &quot;I am Pressed!&quot;
        }
        onReleased: {
            // arbitrary JavaScript expression
            label.text = &quot;Click Me!&quot;
        }

    }

    Text {
        id: label
        anchors.centerIn: parent
        text: &quot;Press Me!&quot;
    }
}
</db:programlisting>
<db:para>Please see the <db:link xlink:href="qtqml-syntax-signals.xml">Signal and Handler Event System</db:link> documentation for in-depth discussion of signals and signal handlers, and see the <db:link xlink:href="qtqml-syntax-objectattributes.xml">QML Object Attributes</db:link> documentation for in-depth discussion of how to define the implementation of signal handlers in QML with JavaScript.</db:para>
</db:section>
<db:section xml:id="javascript-in-standalone-functions">
<db:title>JavaScript in Standalone Functions</db:title>
<db:para>Program logic can also be defined in JavaScript functions. These functions can be defined inline in QML documents (as custom methods) or externally in imported JavaScript files.</db:para>
<db:section xml:id="javascript-in-custom-object-methods">
<db:title>JavaScript in Custom Object Methods</db:title>
<db:para>Custom methods can be defined in QML documents and may be called from signal handlers, property bindings, or functions in other QML objects. Methods defined in this way are often referred to as <db:emphasis>inline JavaScript functions</db:emphasis> because their implementation is included in the QML object type definition (QML document), as opposed to an external JavaScript file.</db:para>
<db:para>An example of an inline custom method is as follows:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Item {
    function factorial(a) {
        a = parseInt(a);
        if (a &lt;= 0)
            return 1;
        else
            return a * factorial(a - 1);
    }

    MouseArea {
        anchors.fill: parent
        onClicked: console.log(factorial(10))
    }
}
</db:programlisting>
<db:para>The factorial function will run whenever the <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> detects a <db:code>clicked</db:code> signal.</db:para>
<db:para>Importantly, custom methods defined inline in a QML document are exposed to other objects, and therefore inline functions on the root object in a QML component can be invoked by callers outside the component. If this is not desired, the method can be added to a non-root object or, preferably, written in an external JavaScript file.</db:para>
<db:para>See the <db:link xlink:href="qtqml-syntax-objectattributes.xml">QML Object Attributes</db:link> documentation for in-depth discussion of how to define custom methods in QML with JavaScript code implementations.</db:para>
</db:section>
<db:section xml:id="functions-in-imported-javascript-files">
<db:title>Functions in Imported JavaScript Files</db:title>
<db:para>Non-trivial program logic is best separated into external JavaScript files. These files can be imported into QML files using an <db:code>import</db:code> statement, in the same way that <db:link xlink:href="qtqml-modules-topic.xml">modules</db:link> are imported.</db:para>
<db:para>For example, the <db:code>factorial()</db:code> method in the above example could be moved into an external file named <db:code>factorial.js</db:code>, and accessed like this:</db:para>
<db:programlisting language="qml">import &quot;factorial.js&quot; as MathFunctions

Item {
    MouseArea {
        anchors.fill: parent
        onClicked: console.log(MathFunctions.factorial(10))
    }
}
</db:programlisting>
<db:para>For more information about loading external JavaScript files into QML, read the section about <db:link xlink:href="qtqml-javascript-imports.xml">Importing JavaScript Resources in QML</db:link>.</db:para>
</db:section>
<db:section xml:id="connecting-signals-to-javascript-functions">
<db:title>Connecting Signals to JavaScript Functions</db:title>
<db:para>QML object types which emit signals also provide default signal handlers for their signals, as described in a previous section. Sometimes, however, a client will want to cause a signal emitted from one object to trigger a function defined in another object; and in that case, a signal connection is often preferable.</db:para>
<db:para>A signal emitted by a QML object may be connected to a JavaScript function by calling the signal's <db:code>connect()</db:code> method and passing the JavaScript function as an argument. For example, the following code connects the <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link> <db:code>clicked</db:code> signal to the <db:code>jsFunction()</db:code> in <db:code>script.js</db:code>:</db:para>
<db:informaltable style="generic">
<db:tr valign="top">
<db:td>
<db:programlisting language="qml">import QtQuick 2.0
import &quot;script.js&quot; as MyScript

Item {
    id: item
    width: 200; height: 200

    MouseArea {
        id: mouseArea
        anchors.fill: parent
    }

    Component.onCompleted: {
        mouseArea.clicked.connect(MyScript.jsFunction)
    }
}
</db:programlisting>
</db:td>
<db:td>
<db:programlisting language="cpp">// script.js

function jsFunction() {
    console.log(&quot;Called JavaScript function!&quot;)
}
</db:programlisting>
</db:td>
</db:tr>
</db:informaltable>
<db:para>The <db:code>jsFunction()</db:code> will now be called whenever <db:link xlink:href="qml-qtquick-mousearea.xml">MouseArea</db:link>'s <db:code>clicked</db:code> signal is emitted.</db:para>
<db:para>See <db:link xlink:href="qtqml-syntax-signals.xml">Connecting Signals to Methods and Signals</db:link> for more information.</db:para>
</db:section>
</db:section>
<db:section xml:id="javascript-in-application-startup-code">
<db:title>JavaScript in Application Startup Code</db:title>
<db:para>It is occasionally necessary to run some imperative code at application (or component instance) startup. While it is tempting to just include the startup script as <db:emphasis>global code</db:emphasis> in an external script file, this can have severe limitations as the QML environment may not have been fully established. For example, some objects might not have been created or some <db:link xlink:href="qtqml-syntax-propertybinding.xml">property bindings</db:link> may not have been established. See <db:link xlink:href="qtqml-javascript-hostenvironment.xml#javascript-environment-restrictions">JavaScript Environment Restrictions</db:link> for the exact limitations of global script code.</db:para>
<db:para>A QML object will emit the <db:code>Component.completed</db:code> <db:link xlink:href="qtqml-syntax-signals.xml#attached-signal-handlers">attached signal</db:link> when its instantiation is complete. JavaScript code in the corresponding <db:code>Component.onCompleted</db:code> handler runs after the object is instantiated. Thus, the best place to write application startup code is in the <db:code>Component.onCompleted</db:code> handler of the top-level object, because this object emits <db:code>Component.completed</db:code> when the QML environment is fully established.</db:para>
<db:para>For example:</db:para>
<db:programlisting language="qml">import QtQuick 2.0

Rectangle {
    function startupFunction() {
        // ... startup code
    }

    Component.onCompleted: startupFunction();
}
</db:programlisting>
<db:para>Any object in a QML file - including nested objects and nested QML component instances - can use this attached property. If there is more than one <db:code>onCompleted()</db:code> handler to execute at startup, they are run sequentially in an undefined order.</db:para>
<db:para>Likewise, every <db:code>Component</db:code> will emit a <db:link xlink:href="qml-qtqml-component.xml#destruction-signal">destruction</db:link>() signal just before being destroyed.</db:para>
</db:section>
</db:article>
